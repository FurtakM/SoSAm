// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 37 0 0
// DebugMode ;
   8: CALL 165 0 0
// PrepareNature ;
  12: CALL 340 0 0
// PrepareRussian ;
  16: CALL 11946 0 0
// PrepareAmerican ;
  20: CALL 1054 0 0
// PrepareOvsyenko ;
  24: CALL 1698 0 0
// Action ;
  28: CALL 2556 0 0
// SaveForQuickRestart ;
  32: CALL_OW 22
// end ;
  36: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar ; function Init ; begin
  37: LD_INT 0
  39: PPUSH
// debug := false ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  48: LD_ADDR_EXP 4
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// mission_prefix := 09_ ;
  56: LD_ADDR_EXP 1
  60: PUSH
  61: LD_STRING 09_
  63: ST_TO_ADDR
// powell_want_sib := false ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  72: LD_ADDR_EXP 6
  76: PUSH
  77: LD_INT 31500
  79: ST_TO_ADDR
// game_time := 47 47$00 ;
  80: LD_ADDR_EXP 7
  84: PUSH
  85: LD_INT 98700
  87: ST_TO_ADDR
// ru_can_attack := false ;
  88: LD_ADDR_EXP 8
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// ru_can_attack_terminal := false ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// ar_can_arrive := false ;
 104: LD_ADDR_EXP 10
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ar_spawned := false ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// player_want_mortar := false ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// player_want_info := false ;
 128: LD_ADDR_EXP 13
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// player_get_mortar := false ;
 136: LD_ADDR_EXP 14
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// player_get_info := false ;
 144: LD_ADDR_EXP 15
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// player_attacked_ar := false ;
 152: LD_ADDR_EXP 16
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// end ;
 160: LD_VAR 0 1
 164: RET
// function DebugMode ; begin
 165: LD_INT 0
 167: PPUSH
// if not debug then
 168: LD_EXP 2
 172: NOT
 173: IFFALSE 177
// exit ;
 175: GO 184
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 222
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 199: LD_ADDR_VAR 0 5
 203: PUSH
 204: LD_VAR 0 3
 208: PUSH
 209: LD_VAR 0 1
 213: STR
 214: PPUSH
 215: CALL_OW 34
 219: ST_TO_ADDR
 220: GO 237
// unit := NewCharacter ( ident ) ;
 222: LD_ADDR_VAR 0 5
 226: PUSH
 227: LD_VAR 0 1
 231: PPUSH
 232: CALL_OW 25
 236: ST_TO_ADDR
// result := unit ;
 237: LD_ADDR_VAR 0 4
 241: PUSH
 242: LD_VAR 0 5
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 4
 251: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 252: LD_INT 0
 254: PPUSH
// uc_side := side ;
 255: LD_ADDR_OWVAR 20
 259: PUSH
 260: LD_VAR 0 1
 264: ST_TO_ADDR
// uc_nation := nation ;
 265: LD_ADDR_OWVAR 21
 269: PUSH
 270: LD_VAR 0 2
 274: ST_TO_ADDR
// vc_chassis := chassis ;
 275: LD_ADDR_OWVAR 37
 279: PUSH
 280: LD_VAR 0 3
 284: ST_TO_ADDR
// vc_engine := engine ;
 285: LD_ADDR_OWVAR 39
 289: PUSH
 290: LD_VAR 0 4
 294: ST_TO_ADDR
// vc_control := control ;
 295: LD_ADDR_OWVAR 38
 299: PUSH
 300: LD_VAR 0 5
 304: ST_TO_ADDR
// vc_weapon := weapon ;
 305: LD_ADDR_OWVAR 40
 309: PUSH
 310: LD_VAR 0 6
 314: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 315: LD_ADDR_OWVAR 41
 319: PUSH
 320: LD_VAR 0 7
 324: ST_TO_ADDR
// result := CreateVehicle ;
 325: LD_ADDR_VAR 0 8
 329: PUSH
 330: CALL_OW 45
 334: ST_TO_ADDR
// end ;
 335: LD_VAR 0 8
 339: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 340: LD_INT 0
 342: PPUSH
 343: PPUSH
 344: PPUSH
 345: PPUSH
// uc_side = 0 ;
 346: LD_ADDR_OWVAR 20
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// uc_nation = 0 ;
 354: LD_ADDR_OWVAR 21
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// nat_area := natureArea ;
 362: LD_ADDR_VAR 0 4
 366: PUSH
 367: LD_INT 1
 369: ST_TO_ADDR
// InitHc ;
 370: CALL_OW 19
// for i = 1 to 4 do
 374: LD_ADDR_VAR 0 2
 378: PUSH
 379: DOUBLE
 380: LD_INT 1
 382: DEC
 383: ST_TO_ADDR
 384: LD_INT 4
 386: PUSH
 387: FOR_TO
 388: IFFALSE 443
// begin hc_class = 18 ;
 390: LD_ADDR_OWVAR 28
 394: PUSH
 395: LD_INT 18
 397: ST_TO_ADDR
// hc_gallery =  ;
 398: LD_ADDR_OWVAR 33
 402: PUSH
 403: LD_STRING 
 405: ST_TO_ADDR
// hc_face_number = 1 ;
 406: LD_ADDR_OWVAR 34
 410: PUSH
 411: LD_INT 1
 413: ST_TO_ADDR
// animal := CreateHuman ;
 414: LD_ADDR_VAR 0 3
 418: PUSH
 419: CALL_OW 44
 423: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 424: LD_VAR 0 3
 428: PPUSH
 429: LD_VAR 0 4
 433: PPUSH
 434: LD_INT 0
 436: PPUSH
 437: CALL_OW 49
// end ;
 441: GO 387
 443: POP
 444: POP
// for i = 1 to 4 do
 445: LD_ADDR_VAR 0 2
 449: PUSH
 450: DOUBLE
 451: LD_INT 1
 453: DEC
 454: ST_TO_ADDR
 455: LD_INT 4
 457: PUSH
 458: FOR_TO
 459: IFFALSE 531
// begin hc_class = class_tiger ;
 461: LD_ADDR_OWVAR 28
 465: PUSH
 466: LD_INT 14
 468: ST_TO_ADDR
// hc_gallery =  ;
 469: LD_ADDR_OWVAR 33
 473: PUSH
 474: LD_STRING 
 476: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 477: LD_ADDR_OWVAR 35
 481: PUSH
 482: LD_INT 5
 484: NEG
 485: PPUSH
 486: LD_INT 5
 488: PPUSH
 489: CALL_OW 12
 493: ST_TO_ADDR
// hc_face_number = 3 ;
 494: LD_ADDR_OWVAR 34
 498: PUSH
 499: LD_INT 3
 501: ST_TO_ADDR
// animal := CreateHuman ;
 502: LD_ADDR_VAR 0 3
 506: PUSH
 507: CALL_OW 44
 511: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 512: LD_VAR 0 3
 516: PPUSH
 517: LD_VAR 0 4
 521: PPUSH
 522: LD_INT 0
 524: PPUSH
 525: CALL_OW 49
// end ;
 529: GO 458
 531: POP
 532: POP
// for i = 1 to 6 do
 533: LD_ADDR_VAR 0 2
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_INT 6
 545: PUSH
 546: FOR_TO
 547: IFFALSE 611
// begin hc_class = class_apeman ;
 549: LD_ADDR_OWVAR 28
 553: PUSH
 554: LD_INT 12
 556: ST_TO_ADDR
// hc_gallery =  ;
 557: LD_ADDR_OWVAR 33
 561: PUSH
 562: LD_STRING 
 564: ST_TO_ADDR
// hc_agressivity = rand ( - 10 , 10 ) ;
 565: LD_ADDR_OWVAR 35
 569: PUSH
 570: LD_INT 10
 572: NEG
 573: PPUSH
 574: LD_INT 10
 576: PPUSH
 577: CALL_OW 12
 581: ST_TO_ADDR
// animal := CreateHuman ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: CALL_OW 44
 591: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 592: LD_VAR 0 3
 596: PPUSH
 597: LD_VAR 0 4
 601: PPUSH
 602: LD_INT 0
 604: PPUSH
 605: CALL_OW 49
// end ;
 609: GO 546
 611: POP
 612: POP
// for i = 1 to 6 do
 613: LD_ADDR_VAR 0 2
 617: PUSH
 618: DOUBLE
 619: LD_INT 1
 621: DEC
 622: ST_TO_ADDR
 623: LD_INT 6
 625: PUSH
 626: FOR_TO
 627: IFFALSE 682
// begin hc_class = 13 ;
 629: LD_ADDR_OWVAR 28
 633: PUSH
 634: LD_INT 13
 636: ST_TO_ADDR
// hc_gallery =  ;
 637: LD_ADDR_OWVAR 33
 641: PUSH
 642: LD_STRING 
 644: ST_TO_ADDR
// hc_face_number = 4 ;
 645: LD_ADDR_OWVAR 34
 649: PUSH
 650: LD_INT 4
 652: ST_TO_ADDR
// animal := CreateHuman ;
 653: LD_ADDR_VAR 0 3
 657: PUSH
 658: CALL_OW 44
 662: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 663: LD_VAR 0 3
 667: PPUSH
 668: LD_VAR 0 4
 672: PPUSH
 673: LD_INT 0
 675: PPUSH
 676: CALL_OW 49
// end ;
 680: GO 626
 682: POP
 683: POP
// for i = 1 to 1 do
 684: LD_ADDR_VAR 0 2
 688: PUSH
 689: DOUBLE
 690: LD_INT 1
 692: DEC
 693: ST_TO_ADDR
 694: LD_INT 1
 696: PUSH
 697: FOR_TO
 698: IFFALSE 746
// begin vc_chassis := 31 ;
 700: LD_ADDR_OWVAR 37
 704: PUSH
 705: LD_INT 31
 707: ST_TO_ADDR
// vc_control := control_rider ;
 708: LD_ADDR_OWVAR 38
 712: PUSH
 713: LD_INT 4
 715: ST_TO_ADDR
// animal := CreateVehicle ;
 716: LD_ADDR_VAR 0 3
 720: PUSH
 721: CALL_OW 45
 725: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 726: LD_VAR 0 3
 730: PPUSH
 731: LD_INT 21
 733: PPUSH
 734: LD_INT 22
 736: PPUSH
 737: LD_INT 0
 739: PPUSH
 740: CALL_OW 48
// end ;
 744: GO 697
 746: POP
 747: POP
// end ;
 748: LD_VAR 0 1
 752: RET
// export function GetTerminalCargo ; begin
 753: LD_INT 0
 755: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 756: LD_ADDR_VAR 0 1
 760: PUSH
 761: LD_EXP 3
 765: PPUSH
 766: CALL_OW 274
 770: PPUSH
 771: LD_INT 3
 773: PPUSH
 774: CALL_OW 275
 778: ST_TO_ADDR
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 784: LD_INT 0
 786: PPUSH
 787: PPUSH
 788: PPUSH
// result := 0 ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 0
 796: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 797: LD_ADDR_VAR 0 4
 801: PUSH
 802: LD_INT 22
 804: PUSH
 805: LD_VAR 0 1
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 2
 816: PUSH
 817: LD_INT 30
 819: PUSH
 820: LD_INT 0
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: PUSH
 827: LD_INT 30
 829: PUSH
 830: LD_INT 1
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL_OW 69
 850: ST_TO_ADDR
// if not tmp then
 851: LD_VAR 0 4
 855: NOT
 856: IFFALSE 860
// exit ;
 858: GO 906
// for i in tmp do
 860: LD_ADDR_VAR 0 3
 864: PUSH
 865: LD_VAR 0 4
 869: PUSH
 870: FOR_IN
 871: IFFALSE 904
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 873: LD_ADDR_VAR 0 2
 877: PUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_VAR 0 3
 887: PPUSH
 888: CALL_OW 274
 892: PPUSH
 893: LD_INT 3
 895: PPUSH
 896: CALL_OW 275
 900: PLUS
 901: ST_TO_ADDR
 902: GO 870
 904: POP
 905: POP
// end ;
 906: LD_VAR 0 2
 910: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
// area = ListEnvironmentArea ( area ) ;
 915: LD_ADDR_VAR 0 2
 919: PUSH
 920: LD_VAR 0 2
 924: PPUSH
 925: CALL_OW 353
 929: ST_TO_ADDR
// if bulldozer > 0 then
 930: LD_VAR 0 1
 934: PUSH
 935: LD_INT 0
 937: GREATER
 938: IFFALSE 1049
// for i = area downto 1 do
 940: LD_ADDR_VAR 0 4
 944: PUSH
 945: DOUBLE
 946: LD_VAR 0 2
 950: INC
 951: ST_TO_ADDR
 952: LD_INT 1
 954: PUSH
 955: FOR_DOWNTO
 956: IFFALSE 1047
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 958: LD_VAR 0 2
 962: PUSH
 963: LD_VAR 0 4
 967: ARRAY
 968: PUSH
 969: LD_INT 1
 971: ARRAY
 972: PPUSH
 973: LD_VAR 0 2
 977: PUSH
 978: LD_VAR 0 4
 982: ARRAY
 983: PUSH
 984: LD_INT 2
 986: ARRAY
 987: PPUSH
 988: CALL_OW 351
 992: IFFALSE 1045
// if not HasTask ( bulldozer ) then
 994: LD_VAR 0 1
 998: PPUSH
 999: CALL_OW 314
1003: NOT
1004: IFFALSE 1045
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1006: LD_VAR 0 1
1010: PPUSH
1011: LD_VAR 0 2
1015: PUSH
1016: LD_VAR 0 4
1020: ARRAY
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: LD_VAR 0 2
1030: PUSH
1031: LD_VAR 0 4
1035: ARRAY
1036: PUSH
1037: LD_INT 2
1039: ARRAY
1040: PPUSH
1041: CALL_OW 171
1045: GO 955
1047: POP
1048: POP
// end ; end_of_file
1049: LD_VAR 0 3
1053: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1054: LD_INT 0
1056: PPUSH
1057: PPUSH
1058: PPUSH
1059: PPUSH
1060: PPUSH
// uc_side := 1 ;
1061: LD_ADDR_OWVAR 20
1065: PUSH
1066: LD_INT 1
1068: ST_TO_ADDR
// uc_nation := 1 ;
1069: LD_ADDR_OWVAR 21
1073: PUSH
1074: LD_INT 1
1076: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1077: LD_ADDR_EXP 17
1081: PUSH
1082: LD_STRING JMM
1084: PPUSH
1085: LD_EXP 2
1089: NOT
1090: PPUSH
1091: LD_STRING 08_
1093: PPUSH
1094: CALL 189 0 3
1098: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1099: LD_ADDR_VAR 0 4
1103: PUSH
1104: LD_INT 1
1106: PPUSH
1107: LD_INT 1
1109: PPUSH
1110: LD_INT 3
1112: PPUSH
1113: LD_INT 2
1115: PPUSH
1116: LD_INT 1
1118: PPUSH
1119: LD_INT 5
1121: PPUSH
1122: LD_INT 55
1124: PPUSH
1125: CALL 252 0 7
1129: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1130: LD_VAR 0 4
1134: PPUSH
1135: LD_INT 3
1137: PPUSH
1138: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1142: LD_VAR 0 4
1146: PPUSH
1147: LD_INT 43
1149: PPUSH
1150: LD_INT 3
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1160: LD_EXP 17
1164: PPUSH
1165: LD_VAR 0 4
1169: PPUSH
1170: CALL_OW 52
// tmp := [ ] ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: EMPTY
1180: ST_TO_ADDR
// uc_side := 4 ;
1181: LD_ADDR_OWVAR 20
1185: PUSH
1186: LD_INT 4
1188: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1189: LD_ADDR_OWVAR 33
1193: PUSH
1194: LD_STRING SecondCharsGal
1196: ST_TO_ADDR
// hc_class := 2 ;
1197: LD_ADDR_OWVAR 28
1201: PUSH
1202: LD_INT 2
1204: ST_TO_ADDR
// hc_sex := sex_female ;
1205: LD_ADDR_OWVAR 27
1209: PUSH
1210: LD_INT 2
1212: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1213: LD_ADDR_OWVAR 30
1217: PUSH
1218: LD_INT 0
1220: PUSH
1221: LD_INT 1
1223: PUSH
1224: LD_INT 1
1226: PUSH
1227: LD_INT 0
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1236: LD_ADDR_OWVAR 31
1240: PUSH
1241: LD_INT 3
1243: PUSH
1244: LD_INT 4
1246: PUSH
1247: LD_INT 2
1249: PUSH
1250: LD_INT 1
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1259: LD_ADDR_OWVAR 29
1263: PUSH
1264: LD_INT 10
1266: PUSH
1267: LD_INT 11
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING Naoma Goichman
1281: ST_TO_ADDR
// hc_face_number := 43 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 43
1289: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1290: LD_ADDR_VAR 0 2
1294: PUSH
1295: LD_VAR 0 2
1299: PUSH
1300: CALL_OW 44
1304: ADD
1305: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1306: LD_ADDR_OWVAR 30
1310: PUSH
1311: LD_INT 0
1313: PUSH
1314: LD_INT 2
1316: PUSH
1317: LD_INT 0
1319: PUSH
1320: LD_INT 1
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1329: LD_ADDR_OWVAR 31
1333: PUSH
1334: LD_INT 0
1336: PUSH
1337: LD_INT 5
1339: PUSH
1340: LD_INT 3
1342: PUSH
1343: LD_INT 1
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1352: LD_ADDR_OWVAR 29
1356: PUSH
1357: LD_INT 10
1359: PUSH
1360: LD_INT 10
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1367: LD_ADDR_OWVAR 26
1371: PUSH
1372: LD_STRING Magdalene Glance
1374: ST_TO_ADDR
// hc_face_number := 44 ;
1375: LD_ADDR_OWVAR 34
1379: PUSH
1380: LD_INT 44
1382: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1383: LD_ADDR_VAR 0 2
1387: PUSH
1388: LD_VAR 0 2
1392: PUSH
1393: CALL_OW 44
1397: ADD
1398: ST_TO_ADDR
// hc_sex := sex_male ;
1399: LD_ADDR_OWVAR 27
1403: PUSH
1404: LD_INT 1
1406: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1407: LD_ADDR_OWVAR 30
1411: PUSH
1412: LD_INT 2
1414: PUSH
1415: LD_INT 2
1417: PUSH
1418: LD_INT 0
1420: PUSH
1421: LD_INT 0
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1430: LD_ADDR_OWVAR 31
1434: PUSH
1435: LD_INT 3
1437: PUSH
1438: LD_INT 4
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: LD_INT 0
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1453: LD_ADDR_OWVAR 29
1457: PUSH
1458: LD_INT 12
1460: PUSH
1461: LD_INT 10
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: ST_TO_ADDR
// hc_name := Steve Holland ;
1468: LD_ADDR_OWVAR 26
1472: PUSH
1473: LD_STRING Steve Holland
1475: ST_TO_ADDR
// hc_face_number := 60 ;
1476: LD_ADDR_OWVAR 34
1480: PUSH
1481: LD_INT 60
1483: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1484: LD_ADDR_VAR 0 2
1488: PUSH
1489: LD_VAR 0 2
1493: PUSH
1494: CALL_OW 44
1498: ADD
1499: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1500: LD_ADDR_EXP 22
1504: PUSH
1505: LD_VAR 0 2
1509: PUSH
1510: LD_INT 0
1512: DIFF
1513: ST_TO_ADDR
// for un in alpha_engs do
1514: LD_ADDR_VAR 0 3
1518: PUSH
1519: LD_EXP 22
1523: PUSH
1524: FOR_IN
1525: IFFALSE 1550
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1527: LD_VAR 0 3
1531: PPUSH
1532: LD_INT 52
1534: PPUSH
1535: LD_INT 35
1537: PPUSH
1538: LD_INT 3
1540: PPUSH
1541: LD_INT 0
1543: PPUSH
1544: CALL_OW 50
1548: GO 1524
1550: POP
1551: POP
// for tmp = 1 to 4 do
1552: LD_ADDR_VAR 0 2
1556: PUSH
1557: DOUBLE
1558: LD_INT 1
1560: DEC
1561: ST_TO_ADDR
1562: LD_INT 4
1564: PUSH
1565: FOR_TO
1566: IFFALSE 1592
// CreateResourcesXYR ( mat_cans , 5 , 54 , 40 , 2 , false ) ;
1568: LD_INT 1
1570: PPUSH
1571: LD_INT 5
1573: PPUSH
1574: LD_INT 54
1576: PPUSH
1577: LD_INT 40
1579: PPUSH
1580: LD_INT 2
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 60
1590: GO 1565
1592: POP
1593: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1594: LD_STRING gamma_commander
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 30
1604: PUSH
1605: LD_INT 3
1607: LESS
1608: IFFALSE 1666
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1610: LD_ADDR_EXP 21
1614: PUSH
1615: LD_STRING VanHouten
1617: PPUSH
1618: LD_INT 0
1620: PPUSH
1621: LD_STRING 
1623: PPUSH
1624: CALL 189 0 3
1628: ST_TO_ADDR
// for i = 1 to 4 do
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_INT 4
1641: PUSH
1642: FOR_TO
1643: IFFALSE 1664
// AddExperience ( Houten , i , 10000 ) ;
1645: LD_EXP 21
1649: PPUSH
1650: LD_VAR 0 5
1654: PPUSH
1655: LD_INT 10000
1657: PPUSH
1658: CALL_OW 492
1662: GO 1642
1664: POP
1665: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1666: LD_ADDR_EXP 24
1670: PUSH
1671: LD_STRING Powell
1673: PPUSH
1674: LD_INT 0
1676: PPUSH
1677: LD_STRING 
1679: PPUSH
1680: CALL 189 0 3
1684: ST_TO_ADDR
// InitHc ;
1685: CALL_OW 19
// InitUc ;
1689: CALL_OW 18
// end ;
1693: LD_VAR 0 1
1697: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1698: LD_INT 0
1700: PPUSH
1701: PPUSH
1702: PPUSH
1703: PPUSH
1704: PPUSH
// uc_side := 4 ;
1705: LD_ADDR_OWVAR 20
1709: PUSH
1710: LD_INT 4
1712: ST_TO_ADDR
// uc_nation := 3 ;
1713: LD_ADDR_OWVAR 21
1717: PUSH
1718: LD_INT 3
1720: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 ] , [ b_breastwork , 109 , 114 , 4 ] , [ b_breastwork , 115 , 132 , 5 ] , [ b_breastwork , 98 , 120 , 1 ] ] ) ;
1721: LD_ADDR_VAR 0 4
1725: PUSH
1726: LD_STRING 09_ovsyenko_base
1728: PPUSH
1729: LD_INT 0
1731: PUSH
1732: LD_INT 101
1734: PUSH
1735: LD_INT 118
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: EMPTY
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: PUSH
1747: LD_INT 31
1749: PUSH
1750: LD_INT 109
1752: PUSH
1753: LD_INT 114
1755: PUSH
1756: LD_INT 4
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: LIST
1763: LIST
1764: PUSH
1765: LD_INT 31
1767: PUSH
1768: LD_INT 115
1770: PUSH
1771: LD_INT 132
1773: PUSH
1774: LD_INT 5
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 98
1788: PUSH
1789: LD_INT 120
1791: PUSH
1792: LD_INT 1
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: PPUSH
1807: CALL_OW 30
1811: ST_TO_ADDR
// for i in tmp do
1812: LD_ADDR_VAR 0 2
1816: PUSH
1817: LD_VAR 0 4
1821: PUSH
1822: FOR_IN
1823: IFFALSE 1979
// begin bc_type := i [ 1 ] ;
1825: LD_ADDR_OWVAR 42
1829: PUSH
1830: LD_VAR 0 2
1834: PUSH
1835: LD_INT 1
1837: ARRAY
1838: ST_TO_ADDR
// bc_level := 3 ;
1839: LD_ADDR_OWVAR 43
1843: PUSH
1844: LD_INT 3
1846: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1847: LD_ADDR_VAR 0 3
1851: PUSH
1852: LD_VAR 0 2
1856: PUSH
1857: LD_INT 2
1859: ARRAY
1860: PPUSH
1861: LD_VAR 0 2
1865: PUSH
1866: LD_INT 3
1868: ARRAY
1869: PPUSH
1870: LD_VAR 0 2
1874: PUSH
1875: LD_INT 4
1877: ARRAY
1878: PPUSH
1879: CALL_OW 47
1883: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1884: LD_VAR 0 3
1888: PPUSH
1889: CALL_OW 266
1893: PUSH
1894: LD_INT 0
1896: EQUAL
1897: IFFALSE 1931
// begin SetBName ( b , ovsyenko ) ;
1899: LD_VAR 0 3
1903: PPUSH
1904: LD_STRING ovsyenko
1906: PPUSH
1907: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1911: LD_VAR 0 3
1915: PPUSH
1916: CALL_OW 274
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 50
1926: PPUSH
1927: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1931: LD_VAR 0 2
1935: PUSH
1936: LD_INT 5
1938: ARRAY
1939: PUSH
1940: LD_INT 250
1942: LESS
1943: IFFALSE 1959
// SetLives ( b , 333 ) else
1945: LD_VAR 0 3
1949: PPUSH
1950: LD_INT 333
1952: PPUSH
1953: CALL_OW 234
1957: GO 1977
// SetLives ( b , i [ 5 ] ) ;
1959: LD_VAR 0 3
1963: PPUSH
1964: LD_VAR 0 2
1968: PUSH
1969: LD_INT 5
1971: ARRAY
1972: PPUSH
1973: CALL_OW 234
// end ;
1977: GO 1822
1979: POP
1980: POP
// uc_nation := 1 ;
1981: LD_ADDR_OWVAR 21
1985: PUSH
1986: LD_INT 1
1988: ST_TO_ADDR
// tmp := [ ] ;
1989: LD_ADDR_VAR 0 4
1993: PUSH
1994: EMPTY
1995: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
1996: LD_ADDR_EXP 18
2000: PUSH
2001: LD_STRING Gary
2003: PPUSH
2004: LD_EXP 2
2008: NOT
2009: PPUSH
2010: LD_STRING 
2012: PPUSH
2013: CALL 189 0 3
2017: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2018: LD_ADDR_VAR 0 4
2022: PUSH
2023: LD_VAR 0 4
2027: PUSH
2028: LD_EXP 18
2032: ADD
2033: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2034: LD_ADDR_EXP 19
2038: PUSH
2039: LD_STRING Bobby
2041: PPUSH
2042: LD_EXP 2
2046: NOT
2047: PPUSH
2048: LD_STRING 03_
2050: PPUSH
2051: CALL 189 0 3
2055: ST_TO_ADDR
// if Bobby then
2056: LD_EXP 19
2060: IFFALSE 2078
// tmp := tmp ^ Bobby ;
2062: LD_ADDR_VAR 0 4
2066: PUSH
2067: LD_VAR 0 4
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2078: LD_ADDR_EXP 20
2082: PUSH
2083: LD_STRING Cyrus
2085: PPUSH
2086: LD_EXP 2
2090: NOT
2091: PPUSH
2092: LD_STRING 03_
2094: PPUSH
2095: CALL 189 0 3
2099: ST_TO_ADDR
// if Cyrus then
2100: LD_EXP 20
2104: IFFALSE 2122
// tmp := tmp ^ Cyrus ;
2106: LD_ADDR_VAR 0 4
2110: PUSH
2111: LD_VAR 0 4
2115: PUSH
2116: LD_EXP 20
2120: ADD
2121: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2122: LD_ADDR_VAR 0 4
2126: PUSH
2127: LD_VAR 0 4
2131: PUSH
2132: LD_STRING 09_prev_squad
2134: PPUSH
2135: CALL_OW 31
2139: ADD
2140: ST_TO_ADDR
// tmp := tmp diff 0 ;
2141: LD_ADDR_VAR 0 4
2145: PUSH
2146: LD_VAR 0 4
2150: PUSH
2151: LD_INT 0
2153: DIFF
2154: ST_TO_ADDR
// if tmp < 4 then
2155: LD_VAR 0 4
2159: PUSH
2160: LD_INT 4
2162: LESS
2163: IFFALSE 2243
// begin for i = 1 to 3 do
2165: LD_ADDR_VAR 0 2
2169: PUSH
2170: DOUBLE
2171: LD_INT 1
2173: DEC
2174: ST_TO_ADDR
2175: LD_INT 3
2177: PUSH
2178: FOR_TO
2179: IFFALSE 2212
// begin PrepareHuman ( false , 1 , 5 ) ;
2181: LD_INT 0
2183: PPUSH
2184: LD_INT 1
2186: PPUSH
2187: LD_INT 5
2189: PPUSH
2190: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ADD
2209: ST_TO_ADDR
// end ;
2210: GO 2178
2212: POP
2213: POP
// PrepareHuman ( false , 4 , 5 ) ;
2214: LD_INT 0
2216: PPUSH
2217: LD_INT 4
2219: PPUSH
2220: LD_INT 5
2222: PPUSH
2223: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2227: LD_ADDR_VAR 0 4
2231: PUSH
2232: LD_VAR 0 4
2236: PUSH
2237: CALL_OW 44
2241: ADD
2242: ST_TO_ADDR
// end ; for i in tmp do
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: LD_VAR 0 4
2252: PUSH
2253: FOR_IN
2254: IFFALSE 2279
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2256: LD_VAR 0 2
2260: PPUSH
2261: LD_INT 106
2263: PPUSH
2264: LD_INT 122
2266: PPUSH
2267: LD_INT 5
2269: PPUSH
2270: LD_INT 0
2272: PPUSH
2273: CALL_OW 50
2277: GO 2253
2279: POP
2280: POP
// tmp := tmp diff Gary ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: LD_EXP 18
2295: DIFF
2296: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2297: LD_ADDR_VAR 0 3
2301: PUSH
2302: LD_INT 22
2304: PUSH
2305: LD_INT 4
2307: PUSH
2308: EMPTY
2309: LIST
2310: LIST
2311: PUSH
2312: LD_INT 30
2314: PUSH
2315: LD_INT 31
2317: PUSH
2318: EMPTY
2319: LIST
2320: LIST
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: PPUSH
2326: CALL_OW 69
2330: ST_TO_ADDR
// for i = 1 to b do
2331: LD_ADDR_VAR 0 2
2335: PUSH
2336: DOUBLE
2337: LD_INT 1
2339: DEC
2340: ST_TO_ADDR
2341: LD_VAR 0 3
2345: PUSH
2346: FOR_TO
2347: IFFALSE 2377
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2349: LD_VAR 0 4
2353: PUSH
2354: LD_VAR 0 2
2358: ARRAY
2359: PPUSH
2360: LD_VAR 0 3
2364: PUSH
2365: LD_VAR 0 2
2369: ARRAY
2370: PPUSH
2371: CALL_OW 120
// end ;
2375: GO 2346
2377: POP
2378: POP
// InitHc ;
2379: CALL_OW 19
// InitUc ;
2383: CALL_OW 18
// end ;
2387: LD_VAR 0 1
2391: RET
// export function PowellTransport ; var i , un ; begin
2392: LD_INT 0
2394: PPUSH
2395: PPUSH
2396: PPUSH
// uc_side := 4 ;
2397: LD_ADDR_OWVAR 20
2401: PUSH
2402: LD_INT 4
2404: ST_TO_ADDR
// uc_nation := 1 ;
2405: LD_ADDR_OWVAR 21
2409: PUSH
2410: LD_INT 1
2412: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2413: LD_INT 1
2415: PPUSH
2416: LD_INT 3
2418: PPUSH
2419: LD_INT 6
2421: PPUSH
2422: CALL_OW 380
// hc_name :=  ;
2426: LD_ADDR_OWVAR 26
2430: PUSH
2431: LD_STRING 
2433: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2434: LD_ADDR_OWVAR 33
2438: PUSH
2439: LD_STRING SecondCharsGal
2441: ST_TO_ADDR
// hc_face_number := 30 ;
2442: LD_ADDR_OWVAR 34
2446: PUSH
2447: LD_INT 30
2449: ST_TO_ADDR
// powell_trans := CreateHuman ;
2450: LD_ADDR_EXP 23
2454: PUSH
2455: CALL_OW 44
2459: ST_TO_ADDR
// hc_face_number := 31 ;
2460: LD_ADDR_OWVAR 34
2464: PUSH
2465: LD_INT 31
2467: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2468: LD_ADDR_EXP 23
2472: PUSH
2473: LD_EXP 23
2477: PUSH
2478: CALL_OW 44
2482: ADD
2483: ST_TO_ADDR
// for i = 1 to 2 do
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: DOUBLE
2490: LD_INT 1
2492: DEC
2493: ST_TO_ADDR
2494: LD_INT 2
2496: PUSH
2497: FOR_TO
2498: IFFALSE 2549
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2500: LD_ADDR_VAR 0 3
2504: PUSH
2505: LD_INT 4
2507: PPUSH
2508: LD_INT 1
2510: PPUSH
2511: LD_INT 3
2513: PPUSH
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 1
2519: PPUSH
2520: LD_INT 12
2522: PPUSH
2523: LD_INT 66
2525: PPUSH
2526: CALL 252 0 7
2530: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2531: LD_ADDR_EXP 23
2535: PUSH
2536: LD_EXP 23
2540: PUSH
2541: LD_VAR 0 3
2545: ADD
2546: ST_TO_ADDR
// end ;
2547: GO 2497
2549: POP
2550: POP
// end ; end_of_file
2551: LD_VAR 0 1
2555: RET
// export function Action ; var i , veh ; begin
2556: LD_INT 0
2558: PPUSH
2559: PPUSH
2560: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2561: LD_EXP 22
2565: PPUSH
2566: LD_INT 0
2568: PPUSH
2569: LD_INT 50
2571: PPUSH
2572: LD_INT 38
2574: PPUSH
2575: LD_INT 2
2577: PPUSH
2578: CALL_OW 145
// InGameOn ;
2582: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2586: LD_INT 43
2588: PPUSH
2589: LD_INT 9
2591: PPUSH
2592: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2596: LD_EXP 17
2600: PPUSH
2601: LD_INT 54
2603: PPUSH
2604: LD_INT 34
2606: PPUSH
2607: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2611: LD_EXP 17
2615: PPUSH
2616: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2620: LD_EXP 17
2624: PPUSH
2625: LD_EXP 22
2629: PUSH
2630: LD_INT 1
2632: ARRAY
2633: PPUSH
2634: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2638: LD_INT 35
2640: PPUSH
2641: CALL_OW 67
// until See ( 4 , JMM ) ;
2645: LD_INT 4
2647: PPUSH
2648: LD_EXP 17
2652: PPUSH
2653: CALL_OW 292
2657: IFFALSE 2638
// CenterNowOnUnits ( JMM ) ;
2659: LD_EXP 17
2663: PPUSH
2664: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2668: LD_EXP 17
2672: PPUSH
2673: LD_STRING D2-JMM-1
2675: PPUSH
2676: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2680: LD_EXP 22
2684: PUSH
2685: LD_INT 3
2687: ARRAY
2688: PPUSH
2689: LD_EXP 17
2693: PPUSH
2694: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2698: LD_EXP 22
2702: PUSH
2703: LD_INT 3
2705: ARRAY
2706: PPUSH
2707: LD_STRING D2-Eng1-1
2709: PPUSH
2710: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2714: LD_EXP 17
2718: PPUSH
2719: LD_STRING D2-JMM-2
2721: PPUSH
2722: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2726: LD_EXP 22
2730: PUSH
2731: LD_INT 3
2733: ARRAY
2734: PPUSH
2735: LD_STRING D2-Eng1-2
2737: PPUSH
2738: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2742: LD_EXP 17
2746: PPUSH
2747: LD_STRING D2-JMM-3
2749: PPUSH
2750: CALL_OW 88
// if Houten then
2754: LD_EXP 21
2758: IFFALSE 2956
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2760: LD_ADDR_VAR 0 3
2764: PUSH
2765: LD_INT 4
2767: PPUSH
2768: LD_INT 1
2770: PPUSH
2771: LD_INT 3
2773: PPUSH
2774: LD_INT 2
2776: PPUSH
2777: LD_INT 1
2779: PPUSH
2780: LD_INT 4
2782: PPUSH
2783: LD_INT 55
2785: PPUSH
2786: CALL 252 0 7
2790: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2791: LD_VAR 0 3
2795: PPUSH
2796: LD_INT 3
2798: PPUSH
2799: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2803: LD_VAR 0 3
2807: PPUSH
2808: LD_INT 46
2810: PPUSH
2811: LD_INT 19
2813: PPUSH
2814: LD_INT 0
2816: PPUSH
2817: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2821: LD_EXP 21
2825: PPUSH
2826: LD_VAR 0 3
2830: PPUSH
2831: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2835: LD_EXP 21
2839: PPUSH
2840: LD_INT 49
2842: PPUSH
2843: LD_INT 33
2845: PPUSH
2846: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2850: LD_EXP 21
2854: PPUSH
2855: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2859: LD_EXP 21
2863: PPUSH
2864: LD_EXP 17
2868: PPUSH
2869: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2873: LD_INT 35
2875: PPUSH
2876: CALL_OW 67
// until See ( 1 , Houten ) ;
2880: LD_INT 1
2882: PPUSH
2883: LD_EXP 21
2887: PPUSH
2888: CALL_OW 292
2892: IFFALSE 2873
// ComTurnUnit ( JMM , Houten ) ;
2894: LD_EXP 17
2898: PPUSH
2899: LD_EXP 21
2903: PPUSH
2904: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2908: LD_EXP 17
2912: PPUSH
2913: LD_STRING D1d-JMM-1
2915: PPUSH
2916: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2920: LD_EXP 21
2924: PPUSH
2925: LD_STRING D1-VanH-1
2927: PPUSH
2928: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2932: LD_EXP 17
2936: PPUSH
2937: LD_STRING D1-JMM-1v
2939: PPUSH
2940: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2944: LD_EXP 17
2948: PPUSH
2949: LD_STRING D1-JMM-2v
2951: PPUSH
2952: CALL_OW 88
// end ; InGameOff ;
2956: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2960: LD_STRING M1
2962: PPUSH
2963: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2967: LD_INT 22
2969: PUSH
2970: LD_INT 4
2972: PUSH
2973: EMPTY
2974: LIST
2975: LIST
2976: PUSH
2977: LD_INT 92
2979: PUSH
2980: LD_EXP 17
2984: PPUSH
2985: CALL_OW 250
2989: PUSH
2990: LD_EXP 17
2994: PPUSH
2995: CALL_OW 251
2999: PUSH
3000: LD_INT 15
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: PPUSH
3013: CALL_OW 69
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3025: LD_EXP 22
3029: PUSH
3030: LD_EXP 17
3034: ADD
3035: PUSH
3036: LD_EXP 21
3040: ADD
3041: PPUSH
3042: CALL_OW 141
// end ;
3046: LD_VAR 0 1
3050: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3051: LD_INT 1
3053: PPUSH
3054: LD_EXP 18
3058: PPUSH
3059: CALL_OW 292
3063: PUSH
3064: LD_EXP 17
3068: PPUSH
3069: LD_EXP 18
3073: PPUSH
3074: CALL_OW 296
3078: PUSH
3079: LD_INT 6
3081: LESS
3082: AND
3083: IFFALSE 3846
3085: GO 3087
3087: DISABLE
3088: LD_INT 0
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
3094: PPUSH
// begin InGameOn ;
3095: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3099: LD_INT 22
3101: PUSH
3102: LD_INT 4
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PPUSH
3109: CALL_OW 69
3113: PPUSH
3114: LD_INT 1
3116: PPUSH
3117: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3121: LD_ADDR_VAR 0 4
3125: PUSH
3126: LD_INT 22
3128: PUSH
3129: LD_INT 1
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 25
3141: PUSH
3142: LD_INT 1
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 25
3151: PUSH
3152: LD_INT 2
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: LD_INT 25
3161: PUSH
3162: LD_INT 3
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PPUSH
3190: CALL_OW 69
3194: ST_TO_ADDR
// ComHold ( tmp ) ;
3195: LD_VAR 0 4
3199: PPUSH
3200: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3204: LD_EXP 17
3208: PPUSH
3209: LD_STRING D2-JMM-3a
3211: PPUSH
3212: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3216: LD_EXP 18
3220: PPUSH
3221: LD_EXP 17
3225: PPUSH
3226: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3230: LD_EXP 18
3234: PPUSH
3235: LD_STRING D2-Gary-3
3237: PPUSH
3238: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3242: LD_EXP 17
3246: PPUSH
3247: LD_EXP 18
3251: PPUSH
3252: CALL_OW 119
// for i in tmp do
3256: LD_ADDR_VAR 0 5
3260: PUSH
3261: LD_VAR 0 4
3265: PUSH
3266: FOR_IN
3267: IFFALSE 3312
// begin if IsInUnit ( i ) then
3269: LD_VAR 0 5
3273: PPUSH
3274: CALL_OW 310
3278: IFFALSE 3289
// ComExitBuilding ( i ) ;
3280: LD_VAR 0 5
3284: PPUSH
3285: CALL_OW 122
// wait ( 1 ) ;
3289: LD_INT 1
3291: PPUSH
3292: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3296: LD_VAR 0 5
3300: PPUSH
3301: LD_EXP 17
3305: PPUSH
3306: CALL_OW 119
// end ;
3310: GO 3266
3312: POP
3313: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3314: LD_ADDR_VAR 0 4
3318: PUSH
3319: LD_VAR 0 4
3323: PUSH
3324: LD_EXP 17
3328: PUSH
3329: LD_EXP 21
3333: PUSH
3334: LD_EXP 18
3338: PUSH
3339: LD_EXP 20
3343: PUSH
3344: LD_EXP 19
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: PUSH
3356: LD_EXP 22
3360: ADD
3361: DIFF
3362: ST_TO_ADDR
// if Bobby then
3363: LD_EXP 19
3367: IFFALSE 3381
// Say ( Bobby , D2-Bobby-3 ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_STRING D2-Bobby-3
3376: PPUSH
3377: CALL_OW 88
// if Cyrus then
3381: LD_EXP 20
3385: IFFALSE 3399
// Say ( Cyrus , D2-Cyrus-3 ) ;
3387: LD_EXP 20
3391: PPUSH
3392: LD_STRING D2-Cyrus-3
3394: PPUSH
3395: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3399: LD_EXP 17
3403: PPUSH
3404: LD_STRING D2-JMM-4
3406: PPUSH
3407: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3411: LD_EXP 18
3415: PPUSH
3416: LD_STRING D2-Gary-4
3418: PPUSH
3419: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3423: LD_ADDR_VAR 0 1
3427: PUSH
3428: LD_VAR 0 4
3432: PPUSH
3433: LD_INT 26
3435: PUSH
3436: LD_INT 1
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PPUSH
3443: CALL_OW 72
3447: PUSH
3448: LD_INT 1
3450: ARRAY
3451: ST_TO_ADDR
// if Cyrus then
3452: LD_EXP 20
3456: IFFALSE 3472
// Say ( Cyrus , D2-Cyrus-4 ) else
3458: LD_EXP 20
3462: PPUSH
3463: LD_STRING D2-Cyrus-4
3465: PPUSH
3466: CALL_OW 88
3470: GO 3484
// Say ( un1 , D2-Sol1-4 ) ;
3472: LD_VAR 0 1
3476: PPUSH
3477: LD_STRING D2-Sol1-4
3479: PPUSH
3480: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3484: LD_EXP 17
3488: PPUSH
3489: LD_STRING D2-JMM-5
3491: PPUSH
3492: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3496: LD_ADDR_VAR 0 2
3500: PUSH
3501: LD_EXP 22
3505: PPUSH
3506: LD_INT 91
3508: PUSH
3509: LD_EXP 17
3513: PUSH
3514: LD_INT 10
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: PUSH
3522: LD_INT 26
3524: PUSH
3525: LD_INT 2
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: PUSH
3532: EMPTY
3533: LIST
3534: LIST
3535: PPUSH
3536: CALL_OW 72
3540: ST_TO_ADDR
// if un2 then
3541: LD_VAR 0 2
3545: IFFALSE 3599
// begin un2 := un2 [ un2 ] ;
3547: LD_ADDR_VAR 0 2
3551: PUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_VAR 0 2
3561: ARRAY
3562: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3563: LD_VAR 0 2
3567: PPUSH
3568: LD_STRING D2-FEng1-5
3570: PPUSH
3571: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3575: LD_EXP 17
3579: PPUSH
3580: LD_STRING D2-JMM-6
3582: PPUSH
3583: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3587: LD_VAR 0 2
3591: PPUSH
3592: LD_STRING D2-FEng1-6
3594: PPUSH
3595: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3599: LD_ADDR_VAR 0 3
3603: PUSH
3604: LD_EXP 22
3608: PPUSH
3609: LD_INT 91
3611: PUSH
3612: LD_EXP 17
3616: PUSH
3617: LD_INT 10
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 26
3627: PUSH
3628: LD_INT 1
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: PPUSH
3639: CALL_OW 72
3643: ST_TO_ADDR
// if un3 then
3644: LD_VAR 0 3
3648: IFFALSE 3703
// begin un3 := un3 [ 1 ] ;
3650: LD_ADDR_VAR 0 3
3654: PUSH
3655: LD_VAR 0 3
3659: PUSH
3660: LD_INT 1
3662: ARRAY
3663: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3664: LD_VAR 0 3
3668: PPUSH
3669: LD_INT 114
3671: PPUSH
3672: LD_INT 122
3674: PPUSH
3675: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3679: LD_VAR 0 3
3683: PPUSH
3684: LD_STRING D2-Eng1-6
3686: PPUSH
3687: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3691: LD_EXP 17
3695: PPUSH
3696: LD_STRING D2-JMM-7
3698: PPUSH
3699: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3703: LD_EXP 18
3707: PPUSH
3708: LD_STRING D2-Gary-7
3710: PPUSH
3711: CALL_OW 88
// if un2 then
3715: LD_VAR 0 2
3719: IFFALSE 3733
// Say ( un2 , D2-FEng1-7 ) ;
3721: LD_VAR 0 2
3725: PPUSH
3726: LD_STRING D2-FEng1-7
3728: PPUSH
3729: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3733: LD_VAR 0 1
3737: PPUSH
3738: LD_STRING D2-Sol1-7
3740: PPUSH
3741: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3745: LD_EXP 17
3749: PPUSH
3750: LD_STRING D2-JMM-8
3752: PPUSH
3753: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3757: LD_INT 22
3759: PUSH
3760: LD_INT 1
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PPUSH
3767: CALL_OW 69
3771: PPUSH
3772: CALL_OW 141
// InGameOff ;
3776: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3780: LD_STRING M1a
3782: PPUSH
3783: CALL_OW 337
// jmm_in_ovsyenko := true ;
3787: LD_ADDR_EXP 4
3791: PUSH
3792: LD_INT 1
3794: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3795: LD_INT 1050
3797: PPUSH
3798: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3802: LD_ADDR_VAR 0 4
3806: PUSH
3807: LD_INT 25
3809: PUSH
3810: LD_INT 14
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL_OW 69
3821: ST_TO_ADDR
// if not tmp then
3822: LD_VAR 0 4
3826: NOT
3827: IFFALSE 3831
// exit ;
3829: GO 3846
// ComMoveXY ( tmp , 75 , 75 ) ;
3831: LD_VAR 0 4
3835: PPUSH
3836: LD_INT 75
3838: PPUSH
3839: LD_INT 75
3841: PPUSH
3842: CALL_OW 111
// end ;
3846: PPOPN 5
3848: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) do var tmp ;
3849: LD_INT 22
3851: PUSH
3852: LD_INT 1
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PUSH
3859: LD_INT 30
3861: PUSH
3862: LD_INT 30
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: PPUSH
3873: CALL_OW 69
3877: IFFALSE 3919
3879: GO 3881
3881: DISABLE
3882: LD_INT 0
3884: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3885: LD_ADDR_VAR 0 1
3889: PUSH
3890: LD_STRING M2easy
3892: PUSH
3893: LD_STRING M2
3895: PUSH
3896: LD_STRING M2hard
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: LIST
3903: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3904: LD_VAR 0 1
3908: PUSH
3909: LD_OWVAR 67
3913: ARRAY
3914: PPUSH
3915: CALL_OW 337
// end ;
3919: PPOPN 1
3921: END
// every 3 3$00 do
3922: GO 3924
3924: DISABLE
// begin DialogueOn ;
3925: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3929: LD_EXP 24
3933: PPUSH
3934: LD_STRING D3-Pow-1
3936: PPUSH
3937: CALL_OW 94
// if jmm_in_ovsyenko then
3941: LD_EXP 4
3945: IFFALSE 3973
// begin Say ( JMM , D3-JMM-1 ) ;
3947: LD_EXP 17
3951: PPUSH
3952: LD_STRING D3-JMM-1
3954: PPUSH
3955: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
3959: LD_EXP 17
3963: PPUSH
3964: LD_STRING D3-JMM-1b
3966: PPUSH
3967: CALL_OW 88
// end else
3971: GO 3985
// Say ( JMM , D3-JMM-1a ) ;
3973: LD_EXP 17
3977: PPUSH
3978: LD_STRING D3-JMM-1a
3980: PPUSH
3981: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
3985: LD_EXP 24
3989: PPUSH
3990: LD_STRING D3-Pow-2
3992: PPUSH
3993: CALL_OW 94
// DialogueOff ;
3997: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4001: LD_STRING M3
4003: PPUSH
4004: CALL_OW 337
// powell_want_sib := true ;
4008: LD_ADDR_EXP 5
4012: PUSH
4013: LD_INT 1
4015: ST_TO_ADDR
// end ;
4016: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo ;
4017: LD_EXP 6
4021: PUSH
4022: LD_INT 0
4024: EQUAL
4025: IFFALSE 5300
4027: GO 4029
4029: DISABLE
4030: LD_INT 0
4032: PPUSH
4033: PPUSH
4034: PPUSH
4035: PPUSH
4036: PPUSH
4037: PPUSH
4038: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4039: LD_INT 4
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: CALL_OW 343
// PowellTransport ;
4049: CALL 2392 0 0
// for i = 1 to 3 do
4053: LD_ADDR_VAR 0 4
4057: PUSH
4058: DOUBLE
4059: LD_INT 1
4061: DEC
4062: ST_TO_ADDR
4063: LD_INT 3
4065: PUSH
4066: FOR_TO
4067: IFFALSE 4134
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4069: LD_ADDR_VAR 0 1
4073: PUSH
4074: LD_INT 6
4076: PPUSH
4077: LD_VAR 0 4
4081: PPUSH
4082: CALL_OW 287
4086: ST_TO_ADDR
// if not tmp then
4087: LD_VAR 0 1
4091: NOT
4092: IFFALSE 4096
// continue ;
4094: GO 4066
// EraseResourceArea ( terminalArea , i ) ;
4096: LD_INT 6
4098: PPUSH
4099: LD_VAR 0 4
4103: PPUSH
4104: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4108: LD_EXP 3
4112: PPUSH
4113: CALL_OW 274
4117: PPUSH
4118: LD_VAR 0 4
4122: PPUSH
4123: LD_VAR 0 1
4127: PPUSH
4128: CALL_OW 276
// end ;
4132: GO 4066
4134: POP
4135: POP
// x := 43 ;
4136: LD_ADDR_VAR 0 2
4140: PUSH
4141: LD_INT 43
4143: ST_TO_ADDR
// y := 3 ;
4144: LD_ADDR_VAR 0 3
4148: PUSH
4149: LD_INT 3
4151: ST_TO_ADDR
// for i = 3 to 4 do
4152: LD_ADDR_VAR 0 4
4156: PUSH
4157: DOUBLE
4158: LD_INT 3
4160: DEC
4161: ST_TO_ADDR
4162: LD_INT 4
4164: PUSH
4165: FOR_TO
4166: IFFALSE 4376
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4168: LD_EXP 23
4172: PUSH
4173: LD_VAR 0 4
4177: ARRAY
4178: PPUSH
4179: LD_INT 4
4181: PPUSH
4182: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4186: LD_EXP 23
4190: PUSH
4191: LD_VAR 0 4
4195: ARRAY
4196: PPUSH
4197: LD_VAR 0 2
4201: PPUSH
4202: LD_VAR 0 3
4206: PPUSH
4207: LD_INT 0
4209: PPUSH
4210: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4214: LD_EXP 23
4218: PUSH
4219: LD_VAR 0 4
4223: PUSH
4224: LD_INT 2
4226: MINUS
4227: ARRAY
4228: PPUSH
4229: LD_EXP 23
4233: PUSH
4234: LD_VAR 0 4
4238: ARRAY
4239: PPUSH
4240: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4244: LD_EXP 23
4248: PUSH
4249: LD_VAR 0 4
4253: ARRAY
4254: PPUSH
4255: LD_INT 1
4257: PPUSH
4258: LD_INT 100
4260: PPUSH
4261: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4265: LD_EXP 23
4269: PUSH
4270: LD_VAR 0 4
4274: PUSH
4275: LD_INT 2
4277: MINUS
4278: ARRAY
4279: PPUSH
4280: LD_INT 54
4282: PPUSH
4283: LD_INT 42
4285: PPUSH
4286: CALL_OW 111
// AddComUnload ( powell_trans [ i - 2 ] ) ;
4290: LD_EXP 23
4294: PUSH
4295: LD_VAR 0 4
4299: PUSH
4300: LD_INT 2
4302: MINUS
4303: ARRAY
4304: PPUSH
4305: CALL_OW 219
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4309: LD_EXP 23
4313: PUSH
4314: LD_VAR 0 4
4318: PUSH
4319: LD_INT 2
4321: MINUS
4322: ARRAY
4323: PPUSH
4324: LD_EXP 3
4328: PPUSH
4329: CALL_OW 250
4333: PPUSH
4334: LD_EXP 3
4338: PPUSH
4339: CALL_OW 251
4343: PPUSH
4344: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4348: LD_EXP 23
4352: PUSH
4353: LD_VAR 0 4
4357: PUSH
4358: LD_INT 2
4360: MINUS
4361: ARRAY
4362: PPUSH
4363: CALL_OW 200
// Wait ( 0 0$02 ) ;
4367: LD_INT 70
4369: PPUSH
4370: CALL_OW 67
// end ;
4374: GO 4165
4376: POP
4377: POP
// repeat wait ( 0 0$01 ) ;
4378: LD_INT 35
4380: PPUSH
4381: CALL_OW 67
// for i = 3 to 4 do
4385: LD_ADDR_VAR 0 4
4389: PUSH
4390: DOUBLE
4391: LD_INT 3
4393: DEC
4394: ST_TO_ADDR
4395: LD_INT 4
4397: PUSH
4398: FOR_TO
4399: IFFALSE 4549
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4401: LD_EXP 23
4405: PUSH
4406: LD_VAR 0 4
4410: ARRAY
4411: PPUSH
4412: LD_INT 1
4414: PPUSH
4415: CALL_OW 289
4419: PUSH
4420: LD_INT 0
4422: GREATER
4423: PUSH
4424: LD_EXP 23
4428: PUSH
4429: LD_VAR 0 4
4433: ARRAY
4434: PPUSH
4435: CALL_OW 314
4439: NOT
4440: AND
4441: IFFALSE 4547
// begin ComUnload ( powell_trans [ i ] ) ;
4443: LD_EXP 23
4447: PUSH
4448: LD_VAR 0 4
4452: ARRAY
4453: PPUSH
4454: CALL_OW 159
// x := rand ( 0 , 5 ) ;
4458: LD_ADDR_VAR 0 2
4462: PUSH
4463: LD_INT 0
4465: PPUSH
4466: LD_INT 5
4468: PPUSH
4469: CALL_OW 12
4473: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4474: LD_EXP 23
4478: PUSH
4479: LD_VAR 0 4
4483: ARRAY
4484: PPUSH
4485: LD_EXP 23
4489: PUSH
4490: LD_VAR 0 4
4494: ARRAY
4495: PPUSH
4496: CALL_OW 250
4500: PPUSH
4501: LD_VAR 0 2
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: CALL_OW 272
4513: PPUSH
4514: LD_EXP 23
4518: PUSH
4519: LD_VAR 0 4
4523: ARRAY
4524: PPUSH
4525: CALL_OW 251
4529: PPUSH
4530: LD_VAR 0 2
4534: PPUSH
4535: LD_INT 3
4537: PPUSH
4538: CALL_OW 273
4542: PPUSH
4543: CALL_OW 171
// end ;
4547: GO 4398
4549: POP
4550: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 and ( GetCargo ( powell_trans [ 3 ] , mat_cans ) = 0 ) and ( GetCargo ( powell_trans [ 4 ] , mat_cans ) = 0 ) ;
4551: LD_EXP 23
4555: PUSH
4556: LD_INT 1
4558: ARRAY
4559: PPUSH
4560: LD_INT 54
4562: PPUSH
4563: LD_INT 42
4565: PPUSH
4566: CALL_OW 297
4570: PUSH
4571: LD_INT 4
4573: LESS
4574: PUSH
4575: LD_EXP 23
4579: PUSH
4580: LD_INT 3
4582: ARRAY
4583: PPUSH
4584: LD_INT 1
4586: PPUSH
4587: CALL_OW 289
4591: PUSH
4592: LD_INT 0
4594: EQUAL
4595: AND
4596: PUSH
4597: LD_EXP 23
4601: PUSH
4602: LD_INT 4
4604: ARRAY
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: CALL_OW 289
4613: PUSH
4614: LD_INT 0
4616: EQUAL
4617: AND
4618: IFFALSE 4378
// DialogueOn ;
4620: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4624: LD_INT 53
4626: PPUSH
4627: LD_INT 35
4629: PPUSH
4630: CALL_OW 86
// un := powell_trans [ 1 ] ;
4634: LD_ADDR_VAR 0 5
4638: PUSH
4639: LD_EXP 23
4643: PUSH
4644: LD_INT 1
4646: ARRAY
4647: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4648: LD_VAR 0 5
4652: PPUSH
4653: LD_STRING D4-Mech1-1
4655: PPUSH
4656: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4660: LD_EXP 17
4664: PPUSH
4665: LD_STRING D4-JMM-1
4667: PPUSH
4668: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4672: LD_VAR 0 5
4676: PPUSH
4677: LD_STRING D4-Mech1-2
4679: PPUSH
4680: CALL_OW 88
// powell_happy := false ;
4684: LD_ADDR_VAR 0 6
4688: PUSH
4689: LD_INT 0
4691: ST_TO_ADDR
// take_cargo := false ;
4692: LD_ADDR_VAR 0 7
4696: PUSH
4697: LD_INT 0
4699: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4700: CALL 753 0 0
4704: PUSH
4705: LD_INT 60
4707: GREATEREQUAL
4708: IFFALSE 4756
// begin Say ( JMM , D5-JMM-1 ) ;
4710: LD_EXP 17
4714: PPUSH
4715: LD_STRING D5-JMM-1
4717: PPUSH
4718: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4722: LD_VAR 0 5
4726: PPUSH
4727: LD_STRING D6-Mech1-1
4729: PPUSH
4730: CALL_OW 88
// powell_happy := true ;
4734: LD_ADDR_VAR 0 6
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// take_cargo := true ;
4742: LD_ADDR_VAR 0 7
4746: PUSH
4747: LD_INT 1
4749: ST_TO_ADDR
// DialogueOff ;
4750: CALL_OW 7
// end else
4754: GO 4990
// if GetTerminalCargo > 0 then
4756: CALL 753 0 0
4760: PUSH
4761: LD_INT 0
4763: GREATER
4764: IFFALSE 4962
// begin case Query ( QWait ) of 1 :
4766: LD_STRING QWait
4768: PPUSH
4769: CALL_OW 97
4773: PUSH
4774: LD_INT 1
4776: DOUBLE
4777: EQUAL
4778: IFTRUE 4782
4780: GO 4873
4782: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4783: LD_EXP 17
4787: PPUSH
4788: LD_STRING D5b-JMM-1
4790: PPUSH
4791: CALL_OW 88
// DialogueOff ;
4795: CALL_OW 7
// wait ( 5 5$00 ) ;
4799: LD_INT 10500
4801: PPUSH
4802: CALL_OW 67
// if GetTerminalCargo < 60 then
4806: CALL 753 0 0
4810: PUSH
4811: LD_INT 60
4813: LESS
4814: IFFALSE 4855
// begin DialogueOn ;
4816: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4820: LD_EXP 3
4824: PPUSH
4825: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4829: LD_VAR 0 5
4833: PPUSH
4834: LD_STRING D6-Mech1-1a
4836: PPUSH
4837: CALL_OW 88
// DialogueOff ;
4841: CALL_OW 7
// powell_happy := false ;
4845: LD_ADDR_VAR 0 6
4849: PUSH
4850: LD_INT 0
4852: ST_TO_ADDR
// end else
4853: GO 4871
// begin powell_happy := true ;
4855: LD_ADDR_VAR 0 6
4859: PUSH
4860: LD_INT 1
4862: ST_TO_ADDR
// take_cargo := true ;
4863: LD_ADDR_VAR 0 7
4867: PUSH
4868: LD_INT 1
4870: ST_TO_ADDR
// end ; end ; 2 :
4871: GO 4960
4873: LD_INT 2
4875: DOUBLE
4876: EQUAL
4877: IFTRUE 4881
4879: GO 4920
4881: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4882: LD_EXP 17
4886: PPUSH
4887: LD_STRING D5b-JMM-1
4889: PPUSH
4890: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4894: LD_VAR 0 5
4898: PPUSH
4899: LD_STRING D6-Mech1-1a
4901: PPUSH
4902: CALL_OW 88
// DialogueOff ;
4906: CALL_OW 7
// take_cargo := true ;
4910: LD_ADDR_VAR 0 7
4914: PUSH
4915: LD_INT 1
4917: ST_TO_ADDR
// end ; 3 :
4918: GO 4960
4920: LD_INT 3
4922: DOUBLE
4923: EQUAL
4924: IFTRUE 4928
4926: GO 4959
4928: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4929: LD_EXP 17
4933: PPUSH
4934: LD_STRING D5c-JMM-1
4936: PPUSH
4937: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4941: LD_VAR 0 5
4945: PPUSH
4946: LD_STRING D6-Mech1-1b
4948: PPUSH
4949: CALL_OW 88
// DialogueOff ;
4953: CALL_OW 7
// end ; end ;
4957: GO 4960
4959: POP
// end else
4960: GO 4990
// begin Say ( JMM , D5c-JMM-1 ) ;
4962: LD_EXP 17
4966: PPUSH
4967: LD_STRING D5c-JMM-1
4969: PPUSH
4970: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4974: LD_VAR 0 5
4978: PPUSH
4979: LD_STRING D6-Mech1-1b
4981: PPUSH
4982: CALL_OW 88
// DialogueOff ;
4986: CALL_OW 7
// end ; if take_cargo then
4990: LD_VAR 0 7
4994: IFFALSE 5073
// begin x := GetTerminalCargo ;
4996: LD_ADDR_VAR 0 2
5000: PUSH
5001: CALL 753 0 0
5005: ST_TO_ADDR
// if x > 60 then
5006: LD_VAR 0 2
5010: PUSH
5011: LD_INT 60
5013: GREATER
5014: IFFALSE 5024
// x := 60 ;
5016: LD_ADDR_VAR 0 2
5020: PUSH
5021: LD_INT 60
5023: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5024: LD_EXP 3
5028: PPUSH
5029: CALL_OW 274
5033: PPUSH
5034: LD_INT 3
5036: PPUSH
5037: CALL 753 0 0
5041: PUSH
5042: LD_VAR 0 2
5046: MINUS
5047: PPUSH
5048: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5052: LD_EXP 23
5056: PUSH
5057: LD_INT 3
5059: ARRAY
5060: PPUSH
5061: LD_INT 3
5063: PPUSH
5064: LD_VAR 0 2
5068: PPUSH
5069: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5073: LD_EXP 23
5077: PPUSH
5078: LD_INT 43
5080: PPUSH
5081: LD_INT 3
5083: PPUSH
5084: CALL_OW 171
// x := 0 0$20 ;
5088: LD_ADDR_VAR 0 2
5092: PUSH
5093: LD_INT 700
5095: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5096: LD_INT 35
5098: PPUSH
5099: CALL_OW 67
// x := x - 0 0$01 ;
5103: LD_ADDR_VAR 0 2
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 35
5115: MINUS
5116: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 0
5124: EQUAL
5125: PUSH
5126: LD_EXP 23
5130: PUSH
5131: LD_INT 3
5133: ARRAY
5134: PPUSH
5135: LD_INT 43
5137: PPUSH
5138: LD_INT 3
5140: PPUSH
5141: CALL_OW 297
5145: PUSH
5146: LD_INT 4
5148: LESS
5149: PUSH
5150: LD_EXP 23
5154: PUSH
5155: LD_INT 3
5157: ARRAY
5158: PPUSH
5159: LD_INT 43
5161: PPUSH
5162: LD_INT 3
5164: PPUSH
5165: CALL_OW 297
5169: PUSH
5170: LD_INT 4
5172: LESS
5173: AND
5174: OR
5175: IFFALSE 5096
// for i in powell_trans do
5177: LD_ADDR_VAR 0 4
5181: PUSH
5182: LD_EXP 23
5186: PUSH
5187: FOR_IN
5188: IFFALSE 5201
// RemoveUnit ( i ) ;
5190: LD_VAR 0 4
5194: PPUSH
5195: CALL_OW 64
5199: GO 5187
5201: POP
5202: POP
// if not powell_happy then
5203: LD_VAR 0 6
5207: NOT
5208: IFFALSE 5219
// powell_happy := - 1 ;
5210: LD_ADDR_VAR 0 6
5214: PUSH
5215: LD_INT 1
5217: NEG
5218: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5219: LD_VAR 0 6
5223: PPUSH
5224: LD_STRING EarlySiberite
5226: PPUSH
5227: CALL_OW 101
// if powell_happy then
5231: LD_VAR 0 6
5235: IFFALSE 5246
// ChangeMissionObjectives ( M3a ) else
5237: LD_STRING M3a
5239: PPUSH
5240: CALL_OW 337
5244: GO 5253
// ChangeMissionObjectives ( M3b ) ;
5246: LD_STRING M3b
5248: PPUSH
5249: CALL_OW 337
// ru_can_attack_terminal := true ;
5253: LD_ADDR_EXP 9
5257: PUSH
5258: LD_INT 1
5260: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5261: LD_INT 12600
5263: PPUSH
5264: CALL_OW 67
// repeat wait ( 0 0$03 ) ;
5268: LD_INT 105
5270: PPUSH
5271: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5275: LD_EXP 8
5279: NOT
5280: PUSH
5281: LD_EXP 33
5285: PUSH
5286: LD_INT 3
5288: LESS
5289: OR
5290: IFFALSE 5268
// ar_can_arrive := true ;
5292: LD_ADDR_EXP 10
5296: PUSH
5297: LD_INT 1
5299: ST_TO_ADDR
// end ;
5300: PPOPN 7
5302: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 20
5308: PPUSH
5309: CALL_OW 325
5313: IFFALSE 5454
5315: GO 5317
5317: DISABLE
5318: LD_INT 0
5320: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5321: LD_ADDR_VAR 0 1
5325: PUSH
5326: LD_INT 22
5328: PUSH
5329: LD_INT 1
5331: PUSH
5332: EMPTY
5333: LIST
5334: LIST
5335: PUSH
5336: LD_INT 26
5338: PUSH
5339: LD_INT 1
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PUSH
5346: LD_INT 25
5348: PUSH
5349: LD_INT 4
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: LIST
5360: PPUSH
5361: CALL_OW 69
5365: PUSH
5366: LD_EXP 17
5370: PUSH
5371: LD_EXP 20
5375: PUSH
5376: LD_EXP 19
5380: PUSH
5381: LD_EXP 21
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: LIST
5390: LIST
5391: DIFF
5392: ST_TO_ADDR
// if not un then
5393: LD_VAR 0 1
5397: NOT
5398: IFFALSE 5402
// exit ;
5400: GO 5454
// DialogueOn ;
5402: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5406: LD_VAR 0 1
5410: PUSH
5411: LD_INT 1
5413: ARRAY
5414: PPUSH
5415: LD_STRING D13-Sci1-1
5417: PPUSH
5418: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5422: LD_EXP 17
5426: PPUSH
5427: LD_STRING D13-JMM-1
5429: PPUSH
5430: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5434: LD_VAR 0 1
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: LD_STRING D13-Sci1-2
5445: PPUSH
5446: CALL_OW 88
// DialogueOff ;
5450: CALL_OW 7
// end ;
5454: PPOPN 1
5456: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5457: LD_INT 1
5459: PPUSH
5460: CALL 784 0 1
5464: PUSH
5465: LD_INT 77
5467: GREATER
5468: PUSH
5469: LD_EXP 8
5473: NOT
5474: AND
5475: PUSH
5476: LD_INT 22
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: LD_INT 25
5488: PUSH
5489: LD_INT 4
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 26
5498: PUSH
5499: LD_INT 1
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL_OW 69
5515: PUSH
5516: LD_EXP 17
5520: PUSH
5521: LD_EXP 19
5525: PUSH
5526: LD_EXP 20
5530: PUSH
5531: LD_EXP 18
5535: PUSH
5536: LD_EXP 21
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: LIST
5546: LIST
5547: DIFF
5548: AND
5549: IFFALSE 5727
5551: GO 5553
5553: DISABLE
5554: LD_INT 0
5556: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5557: LD_ADDR_VAR 0 1
5561: PUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PUSH
5572: LD_INT 25
5574: PUSH
5575: LD_INT 4
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 26
5584: PUSH
5585: LD_INT 1
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: LIST
5596: PPUSH
5597: CALL_OW 69
5601: PUSH
5602: LD_EXP 17
5606: PUSH
5607: LD_EXP 19
5611: PUSH
5612: LD_EXP 20
5616: PUSH
5617: LD_EXP 18
5621: PUSH
5622: LD_EXP 21
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: DIFF
5634: ST_TO_ADDR
// DialogueOn ;
5635: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5639: LD_VAR 0 1
5643: PUSH
5644: LD_INT 1
5646: ARRAY
5647: PPUSH
5648: LD_STRING D7-Sci1-1
5650: PPUSH
5651: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5655: LD_EXP 17
5659: PPUSH
5660: LD_STRING D7-JMM-1
5662: PPUSH
5663: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5667: LD_VAR 0 1
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PPUSH
5676: LD_STRING D7-Sci1-2
5678: PPUSH
5679: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5683: LD_EXP 17
5687: PPUSH
5688: LD_STRING D7-JMM-2
5690: PPUSH
5691: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5695: LD_VAR 0 1
5699: PUSH
5700: LD_INT 1
5702: ARRAY
5703: PPUSH
5704: LD_STRING D7-Sci1-3
5706: PPUSH
5707: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5711: LD_EXP 17
5715: PPUSH
5716: LD_STRING D7-JMM-3
5718: PPUSH
5719: CALL_OW 88
// DialogueOff ;
5723: CALL_OW 7
// end ;
5727: PPOPN 1
5729: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5730: LD_EXP 10
5734: IFFALSE 8960
5736: GO 5738
5738: DISABLE
5739: LD_INT 0
5741: PPUSH
5742: PPUSH
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
5747: PPUSH
5748: PPUSH
// begin PrepareArabian ;
5749: CALL 11069 0 0
// repeat wait ( 0 0$01 ) ;
5753: LD_INT 35
5755: PPUSH
5756: CALL_OW 67
// until ar_spawned ;
5760: LD_EXP 11
5764: IFFALSE 5753
// DialogueOn ;
5766: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5770: LD_EXP 25
5774: PPUSH
5775: LD_STRING D8-Ar1-1
5777: PPUSH
5778: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5782: LD_EXP 17
5786: PPUSH
5787: LD_STRING D8-JMM-1
5789: PPUSH
5790: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5794: LD_EXP 25
5798: PPUSH
5799: LD_STRING D8-Ar1-2
5801: PPUSH
5802: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
5806: LD_EXP 17
5810: PPUSH
5811: LD_STRING D8-JMM-2
5813: PPUSH
5814: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
5818: LD_EXP 25
5822: PPUSH
5823: LD_STRING D8-Ar1-3
5825: PPUSH
5826: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
5830: LD_EXP 17
5834: PPUSH
5835: LD_STRING D8-JMM-3
5837: PPUSH
5838: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
5842: LD_EXP 25
5846: PPUSH
5847: LD_STRING D8-Ar1-4
5849: PPUSH
5850: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
5854: LD_EXP 17
5858: PPUSH
5859: LD_STRING D8-JMM-4
5861: PPUSH
5862: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
5866: LD_EXP 25
5870: PPUSH
5871: LD_STRING D8-Ar1-5
5873: PPUSH
5874: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
5878: LD_EXP 17
5882: PPUSH
5883: LD_STRING D8-JMM-5
5885: PPUSH
5886: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
5890: LD_EXP 25
5894: PPUSH
5895: LD_STRING D8-Ar1-6
5897: PPUSH
5898: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
5902: LD_EXP 26
5906: PPUSH
5907: LD_STRING D8-Ar2-6
5909: PPUSH
5910: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
5914: LD_EXP 17
5918: PPUSH
5919: LD_STRING D8-JMM-6
5921: PPUSH
5922: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
5926: LD_EXP 26
5930: PPUSH
5931: LD_STRING D8-Ar2-7
5933: PPUSH
5934: CALL_OW 94
// case Query ( QBarracks ) of 1 :
5938: LD_STRING QBarracks
5940: PPUSH
5941: CALL_OW 97
5945: PUSH
5946: LD_INT 1
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5954
5952: GO 5989
5954: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
5955: LD_EXP 17
5959: PPUSH
5960: LD_STRING D8a-JMM-1
5962: PPUSH
5963: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
5967: LD_EXP 25
5971: PPUSH
5972: LD_STRING D8a-Ar1-1
5974: PPUSH
5975: CALL_OW 94
// player_want_mortar := true ;
5979: LD_ADDR_EXP 12
5983: PUSH
5984: LD_INT 1
5986: ST_TO_ADDR
// end ; 2 :
5987: GO 6147
5989: LD_INT 2
5991: DOUBLE
5992: EQUAL
5993: IFTRUE 5997
5995: GO 6111
5997: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
5998: LD_EXP 17
6002: PPUSH
6003: LD_STRING D8b-JMM-1
6005: PPUSH
6006: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6010: LD_EXP 25
6014: PPUSH
6015: LD_STRING D8b-Ar1-1
6017: PPUSH
6018: CALL_OW 94
// case Query ( QInfo ) of 1 :
6022: LD_STRING QInfo
6024: PPUSH
6025: CALL_OW 97
6029: PUSH
6030: LD_INT 1
6032: DOUBLE
6033: EQUAL
6034: IFTRUE 6038
6036: GO 6073
6038: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6039: LD_EXP 17
6043: PPUSH
6044: LD_STRING D8b1-JMM-1
6046: PPUSH
6047: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6051: LD_EXP 25
6055: PPUSH
6056: LD_STRING D8b1-Ar1-1
6058: PPUSH
6059: CALL_OW 94
// player_want_info := 2 ;
6063: LD_ADDR_EXP 13
6067: PUSH
6068: LD_INT 2
6070: ST_TO_ADDR
// end ; 2 :
6071: GO 6109
6073: LD_INT 2
6075: DOUBLE
6076: EQUAL
6077: IFTRUE 6081
6079: GO 6108
6081: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6082: LD_EXP 17
6086: PPUSH
6087: LD_STRING D8b2-JMM-1
6089: PPUSH
6090: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6094: LD_EXP 25
6098: PPUSH
6099: LD_STRING D8b2-Ar1-1
6101: PPUSH
6102: CALL_OW 94
// end ; end ;
6106: GO 6109
6108: POP
// end ; 3 :
6109: GO 6147
6111: LD_INT 3
6113: DOUBLE
6114: EQUAL
6115: IFTRUE 6119
6117: GO 6146
6119: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6120: LD_EXP 17
6124: PPUSH
6125: LD_STRING D8c-JMM-1
6127: PPUSH
6128: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6132: LD_EXP 25
6136: PPUSH
6137: LD_STRING D8c-Ar1-1
6139: PPUSH
6140: CALL_OW 94
// end ; end ;
6144: GO 6147
6146: POP
// DialogueOff ;
6147: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6151: LD_ADDR_VAR 0 4
6155: PUSH
6156: LD_INT 22
6158: PUSH
6159: LD_INT 1
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 2
6168: PUSH
6169: LD_INT 30
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 30
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PPUSH
6198: CALL_OW 69
6202: PPUSH
6203: LD_EXP 26
6207: PPUSH
6208: CALL_OW 74
6212: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6213: LD_ADDR_VAR 0 3
6217: PUSH
6218: LD_INT 22
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 21
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: PPUSH
6242: CALL_OW 69
6246: ST_TO_ADDR
// time := 1 1$35 ;
6247: LD_ADDR_VAR 0 5
6251: PUSH
6252: LD_INT 3325
6254: ST_TO_ADDR
// no_oil_gain := false ;
6255: LD_ADDR_VAR 0 6
6259: PUSH
6260: LD_INT 0
6262: ST_TO_ADDR
// first_warn := false ;
6263: LD_ADDR_VAR 0 7
6267: PUSH
6268: LD_INT 0
6270: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6271: LD_EXP 12
6275: PUSH
6276: LD_EXP 13
6280: OR
6281: IFFALSE 6386
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6283: LD_EXP 32
6287: PPUSH
6288: LD_INT 25
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PPUSH
6298: CALL_OW 72
6302: PPUSH
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL_OW 250
6312: PPUSH
6313: LD_VAR 0 4
6317: PPUSH
6318: CALL_OW 251
6322: PPUSH
6323: LD_VAR 0 4
6327: PPUSH
6328: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6332: LD_EXP 32
6336: PPUSH
6337: LD_INT 25
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: EMPTY
6344: LIST
6345: LIST
6346: PPUSH
6347: CALL_OW 72
6351: PPUSH
6352: LD_INT 86
6354: PPUSH
6355: LD_INT 121
6357: PPUSH
6358: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6362: LD_EXP 32
6366: PPUSH
6367: LD_INT 25
6369: PUSH
6370: LD_INT 1
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PPUSH
6377: CALL_OW 72
6381: PPUSH
6382: CALL_OW 200
// end ; if player_attacked_ar then
6386: LD_EXP 16
6390: IFFALSE 6394
// exit ;
6392: GO 8960
// if player_want_mortar then
6394: LD_EXP 12
6398: IFFALSE 7790
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6400: LD_EXP 26
6404: PPUSH
6405: LD_VAR 0 4
6409: PPUSH
6410: CALL_OW 250
6414: PUSH
6415: LD_INT 1
6417: PLUS
6418: PPUSH
6419: LD_VAR 0 4
6423: PPUSH
6424: CALL_OW 251
6428: PUSH
6429: LD_INT 1
6431: PLUS
6432: PPUSH
6433: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6437: LD_INT 35
6439: PPUSH
6440: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6444: LD_EXP 26
6448: PPUSH
6449: LD_VAR 0 4
6453: PPUSH
6454: CALL_OW 296
6458: PUSH
6459: LD_INT 4
6461: LESS
6462: IFFALSE 6437
// for i = 1 to 6 do
6464: LD_ADDR_VAR 0 1
6468: PUSH
6469: DOUBLE
6470: LD_INT 1
6472: DEC
6473: ST_TO_ADDR
6474: LD_INT 6
6476: PUSH
6477: FOR_TO
6478: IFFALSE 6675
// begin if player_attacked_ar then
6480: LD_EXP 16
6484: IFFALSE 6490
// exit ;
6486: POP
6487: POP
6488: GO 8960
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 274
6499: PPUSH
6500: LD_INT 2
6502: PPUSH
6503: CALL_OW 275
6507: PUSH
6508: LD_INT 10
6510: LESS
6511: PUSH
6512: LD_VAR 0 7
6516: NOT
6517: AND
6518: IFFALSE 6581
// begin first_warn := true ;
6520: LD_ADDR_VAR 0 7
6524: PUSH
6525: LD_INT 1
6527: ST_TO_ADDR
// DialogueOn ;
6528: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6532: LD_EXP 27
6536: PPUSH
6537: LD_STRING D9a-FAr1-1
6539: PPUSH
6540: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6544: LD_EXP 17
6548: PPUSH
6549: LD_STRING D9a-JMM-1
6551: PPUSH
6552: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6556: LD_EXP 25
6560: PPUSH
6561: LD_STRING D9a2-Ar1-1
6563: PPUSH
6564: CALL_OW 88
// DialogueOff ;
6568: CALL_OW 7
// wait ( time ) ;
6572: LD_VAR 0 5
6576: PPUSH
6577: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6581: LD_VAR 0 4
6585: PPUSH
6586: CALL_OW 274
6590: PPUSH
6591: LD_INT 2
6593: PPUSH
6594: CALL_OW 275
6598: PUSH
6599: LD_INT 10
6601: LESS
6602: IFFALSE 6628
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6604: LD_EXP 25
6608: PPUSH
6609: LD_STRING D9a3-Ar1-1
6611: PPUSH
6612: CALL_OW 88
// no_oil_gain := true ;
6616: LD_ADDR_VAR 0 6
6620: PUSH
6621: LD_INT 1
6623: ST_TO_ADDR
// break ;
6624: GO 6675
// end else
6626: GO 6673
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6628: LD_EXP 26
6632: PPUSH
6633: LD_VAR 0 4
6637: PPUSH
6638: LD_INT 2
6640: PPUSH
6641: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6645: LD_EXP 26
6649: PPUSH
6650: LD_VAR 0 3
6654: PUSH
6655: LD_VAR 0 1
6659: PUSH
6660: LD_INT 3
6662: MOD
6663: PUSH
6664: LD_INT 1
6666: PLUS
6667: ARRAY
6668: PPUSH
6669: CALL_OW 210
// end ; end ;
6673: GO 6477
6675: POP
6676: POP
// if not no_oil_gain then
6677: LD_VAR 0 6
6681: NOT
6682: IFFALSE 7790
// begin repeat wait ( 0 0$01 ) ;
6684: LD_INT 35
6686: PPUSH
6687: CALL_OW 67
// if player_attacked_ar then
6691: LD_EXP 16
6695: IFFALSE 6699
// exit ;
6697: GO 8960
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6699: LD_VAR 0 3
6703: PUSH
6704: LD_INT 1
6706: ARRAY
6707: PPUSH
6708: CALL_OW 261
6712: PUSH
6713: LD_INT 80
6715: GREATER
6716: PUSH
6717: LD_VAR 0 3
6721: PUSH
6722: LD_INT 2
6724: ARRAY
6725: PPUSH
6726: CALL_OW 261
6730: PUSH
6731: LD_INT 80
6733: GREATER
6734: AND
6735: PUSH
6736: LD_VAR 0 3
6740: PUSH
6741: LD_INT 3
6743: ARRAY
6744: PPUSH
6745: CALL_OW 261
6749: PUSH
6750: LD_INT 80
6752: GREATER
6753: AND
6754: IFFALSE 6684
// ComMoveXY ( Gali , 105 , 127 ) ;
6756: LD_EXP 26
6760: PPUSH
6761: LD_INT 105
6763: PPUSH
6764: LD_INT 127
6766: PPUSH
6767: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6771: LD_EXP 26
6775: PPUSH
6776: LD_INT 2
6778: PPUSH
6779: CALL_OW 173
// AddComHold ( Gali ) ;
6783: LD_EXP 26
6787: PPUSH
6788: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6792: LD_INT 35
6794: PPUSH
6795: CALL_OW 67
// if player_attacked_ar then
6799: LD_EXP 16
6803: IFFALSE 6807
// exit ;
6805: GO 8960
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
6807: LD_EXP 26
6811: PPUSH
6812: LD_INT 105
6814: PPUSH
6815: LD_INT 127
6817: PPUSH
6818: CALL_OW 297
6822: PUSH
6823: LD_INT 4
6825: LESS
6826: IFFALSE 6792
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6828: LD_VAR 0 4
6832: PPUSH
6833: CALL_OW 274
6837: PPUSH
6838: LD_INT 1
6840: PPUSH
6841: CALL_OW 275
6845: PUSH
6846: LD_INT 50
6848: LESS
6849: IFFALSE 7145
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
6851: LD_VAR 0 4
6855: PPUSH
6856: CALL_OW 274
6860: PPUSH
6861: LD_INT 1
6863: PPUSH
6864: CALL_OW 275
6868: PUSH
6869: LD_INT 0
6871: DOUBLE
6872: GREATEREQUAL
6873: IFFALSE 6881
6875: LD_INT 24
6877: DOUBLE
6878: LESSEQUAL
6879: IFTRUE 6883
6881: GO 6898
6883: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
6884: LD_EXP 26
6888: PPUSH
6889: LD_STRING D9b-Ar2-1
6891: PPUSH
6892: CALL_OW 88
6896: GO 6928
6898: LD_INT 25
6900: DOUBLE
6901: GREATEREQUAL
6902: IFFALSE 6910
6904: LD_INT 49
6906: DOUBLE
6907: LESSEQUAL
6908: IFTRUE 6912
6910: GO 6927
6912: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
6913: LD_EXP 26
6917: PPUSH
6918: LD_STRING D9b-Ar2-1a
6920: PPUSH
6921: CALL_OW 88
6925: GO 6928
6927: POP
// Say ( JMM , D9b-JMM-1 ) ;
6928: LD_EXP 17
6932: PPUSH
6933: LD_STRING D9b-JMM-1
6935: PPUSH
6936: CALL_OW 88
// x := 0 0$0 ;
6940: LD_ADDR_VAR 0 2
6944: PUSH
6945: LD_INT 0
6947: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6948: LD_INT 35
6950: PPUSH
6951: CALL_OW 67
// x := x + 0 0$1 ;
6955: LD_ADDR_VAR 0 2
6959: PUSH
6960: LD_VAR 0 2
6964: PUSH
6965: LD_INT 35
6967: PLUS
6968: ST_TO_ADDR
// if player_attacked_ar then
6969: LD_EXP 16
6973: IFFALSE 6977
// exit ;
6975: GO 8960
// until x >= time ;
6977: LD_VAR 0 2
6981: PUSH
6982: LD_VAR 0 5
6986: GREATEREQUAL
6987: IFFALSE 6948
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6989: LD_VAR 0 4
6993: PPUSH
6994: CALL_OW 274
6998: PPUSH
6999: LD_INT 1
7001: PPUSH
7002: CALL_OW 275
7006: PUSH
7007: LD_INT 50
7009: LESS
7010: IFFALSE 7143
// begin DialogueOn ;
7012: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7016: LD_EXP 25
7020: PPUSH
7021: LD_STRING D9c-Ar1-1
7023: PPUSH
7024: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7028: LD_EXP 17
7032: PPUSH
7033: LD_STRING D9c-JMM-1
7035: PPUSH
7036: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7040: LD_EXP 25
7044: PPUSH
7045: LD_STRING D9c-Ar1-2
7047: PPUSH
7048: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7052: LD_EXP 27
7056: PPUSH
7057: LD_STRING D9c-FAr1-2
7059: PPUSH
7060: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7064: LD_EXP 25
7068: PPUSH
7069: LD_STRING D9c-Ar1-3
7071: PPUSH
7072: CALL_OW 88
// case Query ( QInfo ) of 1 :
7076: LD_STRING QInfo
7078: PPUSH
7079: CALL_OW 97
7083: PUSH
7084: LD_INT 1
7086: DOUBLE
7087: EQUAL
7088: IFTRUE 7092
7090: GO 7115
7092: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7093: LD_EXP 17
7097: PPUSH
7098: LD_STRING D8b1-JMM-1
7100: PPUSH
7101: CALL_OW 88
// player_want_info := 2 ;
7105: LD_ADDR_EXP 13
7109: PUSH
7110: LD_INT 2
7112: ST_TO_ADDR
// end ; 2 :
7113: GO 7139
7115: LD_INT 2
7117: DOUBLE
7118: EQUAL
7119: IFTRUE 7123
7121: GO 7138
7123: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7124: LD_EXP 25
7128: PPUSH
7129: LD_STRING D8b2-Ar1-1
7131: PPUSH
7132: CALL_OW 88
// end ; end ;
7136: GO 7139
7138: POP
// DialogueOff ;
7139: CALL_OW 7
// end ; end else
7143: GO 7790
// begin RemoveEnvironmentArea ( mortarArea ) ;
7145: LD_INT 2
7147: PPUSH
7148: CALL_OW 355
// wait ( 1 ) ;
7152: LD_INT 1
7154: PPUSH
7155: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7159: LD_EXP 26
7163: PPUSH
7164: LD_INT 1
7166: PPUSH
7167: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 130 , 0 ) ;
7171: LD_EXP 26
7175: PPUSH
7176: LD_INT 4
7178: PPUSH
7179: LD_INT 107
7181: PPUSH
7182: LD_INT 130
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 145
// repeat wait ( 1 ) ;
7192: LD_INT 1
7194: PPUSH
7195: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7199: LD_INT 30
7201: PUSH
7202: LD_INT 4
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: LD_INT 23
7211: PUSH
7212: LD_INT 2
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PPUSH
7223: CALL_OW 69
7227: IFFALSE 7192
// SetSide ( Gali , 2 ) ;
7229: LD_EXP 26
7233: PPUSH
7234: LD_INT 2
7236: PPUSH
7237: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7241: LD_ADDR_VAR 0 8
7245: PUSH
7246: LD_INT 30
7248: PUSH
7249: LD_INT 4
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: LD_INT 23
7258: PUSH
7259: LD_INT 2
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PPUSH
7270: CALL_OW 69
7274: PUSH
7275: LD_INT 1
7277: ARRAY
7278: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7279: LD_INT 35
7281: PPUSH
7282: CALL_OW 67
// if player_attacked_ar then
7286: LD_EXP 16
7290: IFFALSE 7294
// exit ;
7292: GO 8960
// until BuildingStatus ( b ) <> bs_build ;
7294: LD_VAR 0 8
7298: PPUSH
7299: CALL_OW 461
7303: PUSH
7304: LD_INT 1
7306: NONEQUAL
7307: IFFALSE 7279
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7309: LD_VAR 0 8
7313: PPUSH
7314: CALL_OW 302
7318: PUSH
7319: LD_VAR 0 4
7323: PPUSH
7324: CALL_OW 274
7328: PPUSH
7329: LD_INT 1
7331: PPUSH
7332: CALL_OW 275
7336: PUSH
7337: LD_INT 25
7339: GREATEREQUAL
7340: AND
7341: IFFALSE 7440
// begin ComUpgrade ( b ) ;
7343: LD_VAR 0 8
7347: PPUSH
7348: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7352: LD_EXP 26
7356: PPUSH
7357: LD_STRING h
7359: PUSH
7360: LD_VAR 0 8
7364: PPUSH
7365: CALL_OW 250
7369: PUSH
7370: LD_VAR 0 8
7374: PPUSH
7375: CALL_OW 251
7379: PUSH
7380: LD_VAR 0 8
7384: PUSH
7385: LD_INT 0
7387: PUSH
7388: LD_INT 0
7390: PUSH
7391: LD_INT 0
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: LIST
7402: PUSH
7403: EMPTY
7404: LIST
7405: PPUSH
7406: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7410: LD_INT 35
7412: PPUSH
7413: CALL_OW 67
// if player_attacked_ar then
7417: LD_EXP 16
7421: IFFALSE 7425
// exit ;
7423: GO 8960
// until BuildingStatus ( b ) <> bs_build ;
7425: LD_VAR 0 8
7429: PPUSH
7430: CALL_OW 461
7434: PUSH
7435: LD_INT 1
7437: NONEQUAL
7438: IFFALSE 7410
// end ; if b then
7440: LD_VAR 0 8
7444: IFFALSE 7455
// CenterNowOnUnits ( b ) ;
7446: LD_VAR 0 8
7450: PPUSH
7451: CALL_OW 87
// DialogueOn ;
7455: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7459: LD_EXP 26
7463: PPUSH
7464: LD_STRING D9d-Ar2-1
7466: PPUSH
7467: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7471: LD_EXP 25
7475: PPUSH
7476: LD_STRING D9d-Ar1-1
7478: PPUSH
7479: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7483: LD_EXP 17
7487: PPUSH
7488: LD_STRING D9d-JMM-1
7490: PPUSH
7491: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7495: LD_EXP 25
7499: PPUSH
7500: LD_STRING D9d-Ar1-2
7502: PPUSH
7503: CALL_OW 88
// DialogueOff ;
7507: CALL_OW 7
// i := [ ] ;
7511: LD_ADDR_VAR 0 1
7515: PUSH
7516: EMPTY
7517: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7518: LD_VAR 0 4
7522: PPUSH
7523: CALL_OW 274
7527: PPUSH
7528: LD_INT 3
7530: PPUSH
7531: CALL_OW 275
7535: PUSH
7536: LD_INT 20
7538: GREATEREQUAL
7539: IFFALSE 7558
// i := i ^ [ 1 ] ;
7541: LD_ADDR_VAR 0 1
7545: PUSH
7546: LD_VAR 0 1
7550: PUSH
7551: LD_INT 1
7553: PUSH
7554: EMPTY
7555: LIST
7556: ADD
7557: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7558: LD_VAR 0 4
7562: PPUSH
7563: CALL_OW 274
7567: PPUSH
7568: LD_INT 1
7570: PPUSH
7571: CALL_OW 275
7575: PUSH
7576: LD_INT 50
7578: GREATEREQUAL
7579: IFFALSE 7598
// i := i ^ [ 2 ] ;
7581: LD_ADDR_VAR 0 1
7585: PUSH
7586: LD_VAR 0 1
7590: PUSH
7591: LD_INT 2
7593: PUSH
7594: EMPTY
7595: LIST
7596: ADD
7597: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7598: LD_VAR 0 4
7602: PPUSH
7603: CALL_OW 274
7607: PPUSH
7608: LD_INT 2
7610: PPUSH
7611: CALL_OW 275
7615: PUSH
7616: LD_INT 80
7618: GREATEREQUAL
7619: IFFALSE 7638
// i := i ^ [ 3 ] ;
7621: LD_ADDR_VAR 0 1
7625: PUSH
7626: LD_VAR 0 1
7630: PUSH
7631: LD_INT 3
7633: PUSH
7634: EMPTY
7635: LIST
7636: ADD
7637: ST_TO_ADDR
// i := i diff 0 ;
7638: LD_ADDR_VAR 0 1
7642: PUSH
7643: LD_VAR 0 1
7647: PUSH
7648: LD_INT 0
7650: DIFF
7651: ST_TO_ADDR
// if i then
7652: LD_VAR 0 1
7656: IFFALSE 7762
// begin i := i ^ [ 4 ] ;
7658: LD_ADDR_VAR 0 1
7662: PUSH
7663: LD_VAR 0 1
7667: PUSH
7668: LD_INT 4
7670: PUSH
7671: EMPTY
7672: LIST
7673: ADD
7674: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7675: LD_STRING QInfo2
7677: PPUSH
7678: CALL_OW 97
7682: PUSH
7683: LD_INT 1
7685: DOUBLE
7686: EQUAL
7687: IFTRUE 7691
7689: GO 7702
7691: POP
// player_want_info := 3 ; 2 :
7692: LD_ADDR_EXP 13
7696: PUSH
7697: LD_INT 3
7699: ST_TO_ADDR
7700: GO 7760
7702: LD_INT 2
7704: DOUBLE
7705: EQUAL
7706: IFTRUE 7710
7708: GO 7721
7710: POP
// player_want_info := 1 ; 3 :
7711: LD_ADDR_EXP 13
7715: PUSH
7716: LD_INT 1
7718: ST_TO_ADDR
7719: GO 7760
7721: LD_INT 3
7723: DOUBLE
7724: EQUAL
7725: IFTRUE 7729
7727: GO 7740
7729: POP
// player_want_info := 2 ; 4 :
7730: LD_ADDR_EXP 13
7734: PUSH
7735: LD_INT 2
7737: ST_TO_ADDR
7738: GO 7760
7740: LD_INT 4
7742: DOUBLE
7743: EQUAL
7744: IFTRUE 7748
7746: GO 7759
7748: POP
// player_want_info := 0 ; end ;
7749: LD_ADDR_EXP 13
7753: PUSH
7754: LD_INT 0
7756: ST_TO_ADDR
7757: GO 7760
7759: POP
// end else
7760: GO 7790
// case Query ( QInfoNothing ) of 1 :
7762: LD_STRING QInfoNothing
7764: PPUSH
7765: CALL_OW 97
7769: PUSH
7770: LD_INT 1
7772: DOUBLE
7773: EQUAL
7774: IFTRUE 7778
7776: GO 7789
7778: POP
// player_want_info := 0 ; end ;
7779: LD_ADDR_EXP 13
7783: PUSH
7784: LD_INT 0
7786: ST_TO_ADDR
7787: GO 7790
7789: POP
// end ; end ; end ; if player_want_info then
7790: LD_EXP 13
7794: IFFALSE 8780
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7796: LD_ADDR_VAR 0 3
7800: PUSH
7801: LD_VAR 0 3
7805: PPUSH
7806: LD_INT 34
7808: PUSH
7809: LD_INT 32
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 72
7820: ST_TO_ADDR
// if player_want_mortar then
7821: LD_EXP 12
7825: IFFALSE 8119
// begin case player_want_info of 1 :
7827: LD_EXP 13
7831: PUSH
7832: LD_INT 1
7834: DOUBLE
7835: EQUAL
7836: IFTRUE 7840
7838: GO 7851
7840: POP
// x := 5 ; 2 :
7841: LD_ADDR_VAR 0 2
7845: PUSH
7846: LD_INT 5
7848: ST_TO_ADDR
7849: GO 7890
7851: LD_INT 2
7853: DOUBLE
7854: EQUAL
7855: IFTRUE 7859
7857: GO 7870
7859: POP
// x := 8 ; 3 :
7860: LD_ADDR_VAR 0 2
7864: PUSH
7865: LD_INT 8
7867: ST_TO_ADDR
7868: GO 7890
7870: LD_INT 3
7872: DOUBLE
7873: EQUAL
7874: IFTRUE 7878
7876: GO 7889
7878: POP
// x := 2 ; end ;
7879: LD_ADDR_VAR 0 2
7883: PUSH
7884: LD_INT 2
7886: ST_TO_ADDR
7887: GO 7890
7889: POP
// for i = 1 to x do
7890: LD_ADDR_VAR 0 1
7894: PUSH
7895: DOUBLE
7896: LD_INT 1
7898: DEC
7899: ST_TO_ADDR
7900: LD_VAR 0 2
7904: PUSH
7905: FOR_TO
7906: IFFALSE 8062
// begin AddComTransport ( Gali , dep , player_want_info ) ;
7908: LD_EXP 26
7912: PPUSH
7913: LD_VAR 0 4
7917: PPUSH
7918: LD_EXP 13
7922: PPUSH
7923: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
7927: LD_EXP 26
7931: PPUSH
7932: LD_VAR 0 3
7936: PUSH
7937: LD_INT 1
7939: ARRAY
7940: PPUSH
7941: CALL_OW 172
// repeat wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// if player_attacked_ar then
7952: LD_EXP 16
7956: IFFALSE 7962
// exit ;
7958: POP
7959: POP
7960: GO 8960
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
7962: LD_EXP 26
7966: PPUSH
7967: LD_VAR 0 3
7971: PUSH
7972: LD_INT 1
7974: ARRAY
7975: PPUSH
7976: CALL_OW 296
7980: PUSH
7981: LD_INT 4
7983: LESS
7984: PUSH
7985: LD_EXP 26
7989: PPUSH
7990: LD_EXP 13
7994: PPUSH
7995: CALL_OW 289
7999: AND
8000: IFFALSE 7945
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8002: LD_VAR 0 3
8006: PUSH
8007: LD_INT 1
8009: ARRAY
8010: PPUSH
8011: LD_EXP 13
8015: PPUSH
8016: LD_VAR 0 3
8020: PUSH
8021: LD_INT 1
8023: ARRAY
8024: PPUSH
8025: LD_EXP 13
8029: PPUSH
8030: CALL_OW 289
8034: PUSH
8035: LD_INT 10
8037: PLUS
8038: PPUSH
8039: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8043: LD_EXP 26
8047: PPUSH
8048: LD_EXP 13
8052: PPUSH
8053: LD_INT 0
8055: PPUSH
8056: CALL_OW 290
// end ;
8060: GO 7905
8062: POP
8063: POP
// repeat wait ( 0 0$1 ) ;
8064: LD_INT 35
8066: PPUSH
8067: CALL_OW 67
// if player_attacked_ar then
8071: LD_EXP 16
8075: IFFALSE 8079
// exit ;
8077: GO 8960
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8079: LD_VAR 0 3
8083: PUSH
8084: LD_INT 1
8086: ARRAY
8087: PPUSH
8088: LD_EXP 13
8092: PPUSH
8093: CALL_OW 289
8097: PUSH
8098: LD_VAR 0 2
8102: PUSH
8103: LD_INT 10
8105: MUL
8106: EQUAL
8107: IFFALSE 8064
// no_oil_gain := false ;
8109: LD_ADDR_VAR 0 6
8113: PUSH
8114: LD_INT 0
8116: ST_TO_ADDR
// end else
8117: GO 8601
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8119: LD_ADDR_VAR 0 3
8123: PUSH
8124: LD_INT 22
8126: PUSH
8127: LD_INT 2
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: LD_INT 21
8136: PUSH
8137: LD_INT 2
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 69
8152: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8153: LD_EXP 26
8157: PPUSH
8158: LD_VAR 0 4
8162: PPUSH
8163: CALL_OW 250
8167: PUSH
8168: LD_INT 1
8170: PLUS
8171: PPUSH
8172: LD_VAR 0 4
8176: PPUSH
8177: CALL_OW 251
8181: PUSH
8182: LD_INT 1
8184: PLUS
8185: PPUSH
8186: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8190: LD_INT 35
8192: PPUSH
8193: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8197: LD_EXP 26
8201: PPUSH
8202: LD_VAR 0 4
8206: PPUSH
8207: CALL_OW 296
8211: PUSH
8212: LD_INT 4
8214: LESS
8215: IFFALSE 8190
// for i = 1 to 6 do
8217: LD_ADDR_VAR 0 1
8221: PUSH
8222: DOUBLE
8223: LD_INT 1
8225: DEC
8226: ST_TO_ADDR
8227: LD_INT 6
8229: PUSH
8230: FOR_TO
8231: IFFALSE 8428
// begin if player_attacked_ar then
8233: LD_EXP 16
8237: IFFALSE 8243
// exit ;
8239: POP
8240: POP
8241: GO 8960
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8243: LD_VAR 0 4
8247: PPUSH
8248: CALL_OW 274
8252: PPUSH
8253: LD_INT 2
8255: PPUSH
8256: CALL_OW 275
8260: PUSH
8261: LD_INT 10
8263: LESS
8264: PUSH
8265: LD_VAR 0 7
8269: NOT
8270: AND
8271: IFFALSE 8334
// begin first_warn := true ;
8273: LD_ADDR_VAR 0 7
8277: PUSH
8278: LD_INT 1
8280: ST_TO_ADDR
// DialogueOn ;
8281: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8285: LD_EXP 27
8289: PPUSH
8290: LD_STRING D9a-FAr1-1
8292: PPUSH
8293: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8297: LD_EXP 17
8301: PPUSH
8302: LD_STRING D9a-JMM-1
8304: PPUSH
8305: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8309: LD_EXP 25
8313: PPUSH
8314: LD_STRING D9a2-Ar1-1
8316: PPUSH
8317: CALL_OW 88
// DialogueOff ;
8321: CALL_OW 7
// wait ( time ) ;
8325: LD_VAR 0 5
8329: PPUSH
8330: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8334: LD_VAR 0 4
8338: PPUSH
8339: CALL_OW 274
8343: PPUSH
8344: LD_INT 2
8346: PPUSH
8347: CALL_OW 275
8351: PUSH
8352: LD_INT 10
8354: LESS
8355: IFFALSE 8381
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8357: LD_EXP 25
8361: PPUSH
8362: LD_STRING D9a3-Ar1-1
8364: PPUSH
8365: CALL_OW 88
// no_oil_gain := true ;
8369: LD_ADDR_VAR 0 6
8373: PUSH
8374: LD_INT 1
8376: ST_TO_ADDR
// break ;
8377: GO 8428
// end else
8379: GO 8426
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8381: LD_EXP 26
8385: PPUSH
8386: LD_VAR 0 4
8390: PPUSH
8391: LD_INT 2
8393: PPUSH
8394: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8398: LD_EXP 26
8402: PPUSH
8403: LD_VAR 0 3
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_INT 3
8415: MOD
8416: PUSH
8417: LD_INT 1
8419: PLUS
8420: ARRAY
8421: PPUSH
8422: CALL_OW 210
// end ; end ;
8426: GO 8230
8428: POP
8429: POP
// repeat wait ( 0 0$1 ) ;
8430: LD_INT 35
8432: PPUSH
8433: CALL_OW 67
// if player_attacked_ar then
8437: LD_EXP 16
8441: IFFALSE 8445
// exit ;
8443: GO 8960
// for i in tmp do
8445: LD_ADDR_VAR 0 1
8449: PUSH
8450: LD_VAR 0 3
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8487
// if GetFuel ( i ) < 100 then
8458: LD_VAR 0 1
8462: PPUSH
8463: CALL_OW 261
8467: PUSH
8468: LD_INT 100
8470: LESS
8471: IFFALSE 8485
// begin x := i ;
8473: LD_ADDR_VAR 0 2
8477: PUSH
8478: LD_VAR 0 1
8482: ST_TO_ADDR
// break ;
8483: GO 8487
// end ;
8485: GO 8455
8487: POP
8488: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8489: LD_EXP 26
8493: PPUSH
8494: CALL_OW 314
8498: NOT
8499: PUSH
8500: LD_EXP 26
8504: PPUSH
8505: CALL_OW 281
8509: NOT
8510: AND
8511: IFFALSE 8544
// begin ComTransport ( Gali , dep , mat_oil ) ;
8513: LD_EXP 26
8517: PPUSH
8518: LD_VAR 0 4
8522: PPUSH
8523: LD_INT 2
8525: PPUSH
8526: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8530: LD_EXP 26
8534: PPUSH
8535: LD_VAR 0 2
8539: PPUSH
8540: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8544: LD_VAR 0 3
8548: PUSH
8549: LD_INT 1
8551: ARRAY
8552: PPUSH
8553: CALL_OW 261
8557: PUSH
8558: LD_INT 80
8560: GREATER
8561: PUSH
8562: LD_VAR 0 3
8566: PUSH
8567: LD_INT 2
8569: ARRAY
8570: PPUSH
8571: CALL_OW 261
8575: PUSH
8576: LD_INT 80
8578: GREATER
8579: AND
8580: PUSH
8581: LD_VAR 0 3
8585: PUSH
8586: LD_INT 3
8588: ARRAY
8589: PPUSH
8590: CALL_OW 261
8594: PUSH
8595: LD_INT 80
8597: GREATER
8598: AND
8599: IFFALSE 8430
// end ; ComHold ( Gali ) ;
8601: LD_EXP 26
8605: PPUSH
8606: CALL_OW 140
// if not no_oil_gain then
8610: LD_VAR 0 6
8614: NOT
8615: IFFALSE 8780
// begin DialogueOn ;
8617: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8621: LD_EXP 25
8625: PPUSH
8626: CALL_OW 87
// if player_want_mortar then
8630: LD_EXP 12
8634: IFFALSE 8660
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8636: LD_EXP 25
8640: PPUSH
8641: LD_STRING D9e-Ar1-1
8643: PPUSH
8644: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8648: LD_EXP 17
8652: PPUSH
8653: LD_STRING D10a-JMM-1
8655: PPUSH
8656: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8660: LD_EXP 25
8664: PPUSH
8665: LD_STRING D10a-Ar1-1
8667: PPUSH
8668: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8672: LD_EXP 26
8676: PPUSH
8677: LD_STRING D10a-Ar2-1
8679: PPUSH
8680: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8684: LD_EXP 27
8688: PPUSH
8689: LD_STRING D10a-FAr1-1
8691: PPUSH
8692: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8696: LD_EXP 26
8700: PPUSH
8701: LD_STRING D10a-Ar2-2
8703: PPUSH
8704: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8708: LD_EXP 27
8712: PPUSH
8713: LD_STRING D10a-FAr1-2
8715: PPUSH
8716: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8720: LD_EXP 25
8724: PPUSH
8725: LD_STRING D10a-Ar1-2
8727: PPUSH
8728: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8732: LD_EXP 17
8736: PPUSH
8737: LD_STRING D10a-JMM-2
8739: PPUSH
8740: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8744: LD_EXP 25
8748: PPUSH
8749: LD_STRING D10a-Ar1-3
8751: PPUSH
8752: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8756: LD_EXP 17
8760: PPUSH
8761: LD_STRING D10a-JMM-3
8763: PPUSH
8764: CALL_OW 88
// player_get_info := true ;
8768: LD_ADDR_EXP 15
8772: PUSH
8773: LD_INT 1
8775: ST_TO_ADDR
// DialogueOff ;
8776: CALL_OW 7
// end ; end ; if player_attacked_ar then
8780: LD_EXP 16
8784: IFFALSE 8788
// exit ;
8786: GO 8960
// if player_want_mortar or player_want_info then
8788: LD_EXP 12
8792: PUSH
8793: LD_EXP 13
8797: OR
8798: IFFALSE 8812
// Say ( Vervecken , D9f-Ar1-1 ) ;
8800: LD_EXP 25
8804: PPUSH
8805: LD_STRING D9f-Ar1-1
8807: PPUSH
8808: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8812: LD_INT 22
8814: PUSH
8815: LD_INT 2
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: PPUSH
8822: CALL_OW 69
8826: PPUSH
8827: LD_INT 51
8829: PPUSH
8830: LD_INT 99
8832: PPUSH
8833: CALL_OW 111
// wait ( 0 0$1 ) ;
8837: LD_INT 35
8839: PPUSH
8840: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
8844: LD_INT 22
8846: PUSH
8847: LD_INT 2
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 92
8856: PUSH
8857: LD_INT 51
8859: PUSH
8860: LD_INT 99
8862: PUSH
8863: LD_INT 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PPUSH
8876: CALL_OW 69
8880: IFFALSE 8940
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
8882: LD_ADDR_VAR 0 1
8886: PUSH
8887: LD_INT 22
8889: PUSH
8890: LD_INT 2
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 92
8899: PUSH
8900: LD_INT 51
8902: PUSH
8903: LD_INT 99
8905: PUSH
8906: LD_INT 2
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: LIST
8913: LIST
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PPUSH
8919: CALL_OW 69
8923: PUSH
8924: FOR_IN
8925: IFFALSE 8938
// RemoveUnit ( i ) ;
8927: LD_VAR 0 1
8931: PPUSH
8932: CALL_OW 64
8936: GO 8924
8938: POP
8939: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
8940: LD_INT 22
8942: PUSH
8943: LD_INT 2
8945: PUSH
8946: EMPTY
8947: LIST
8948: LIST
8949: PPUSH
8950: CALL_OW 69
8954: PUSH
8955: LD_INT 0
8957: EQUAL
8958: IFFALSE 8812
// end ;
8960: PPOPN 8
8962: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
8963: LD_EXP 16
8967: IFFALSE 9320
8969: GO 8971
8971: DISABLE
8972: LD_INT 0
8974: PPUSH
8975: PPUSH
8976: PPUSH
8977: PPUSH
// begin ru_can_attack := true ;
8978: LD_ADDR_EXP 8
8982: PUSH
8983: LD_INT 1
8985: ST_TO_ADDR
// mine_launched := false ;
8986: LD_ADDR_VAR 0 3
8990: PUSH
8991: LD_INT 0
8993: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8994: LD_INT 22
8996: PUSH
8997: LD_INT 2
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PPUSH
9004: CALL_OW 69
9008: PPUSH
9009: LD_INT 51
9011: PPUSH
9012: LD_INT 99
9014: PPUSH
9015: CALL_OW 111
// if IsOk ( Vervecken ) then
9019: LD_EXP 25
9023: PPUSH
9024: CALL_OW 302
9028: IFFALSE 9042
// Say ( Vervecken , D11a-Ar1-1 ) ;
9030: LD_EXP 25
9034: PPUSH
9035: LD_STRING D11a-Ar1-1
9037: PPUSH
9038: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9042: LD_ADDR_VAR 0 2
9046: PUSH
9047: LD_EXP 32
9051: PPUSH
9052: LD_INT 25
9054: PUSH
9055: LD_INT 1
9057: PUSH
9058: EMPTY
9059: LIST
9060: LIST
9061: PPUSH
9062: CALL_OW 72
9066: ST_TO_ADDR
// for i in tmp do
9067: LD_ADDR_VAR 0 1
9071: PUSH
9072: LD_VAR 0 2
9076: PUSH
9077: FOR_IN
9078: IFFALSE 9141
// if MineOfUnit ( i ) then
9080: LD_VAR 0 1
9084: PPUSH
9085: CALL_OW 459
9089: IFFALSE 9139
// begin x := MineOfUnit ( i ) ;
9091: LD_ADDR_VAR 0 4
9095: PUSH
9096: LD_VAR 0 1
9100: PPUSH
9101: CALL_OW 459
9105: ST_TO_ADDR
// mine_launched := true ;
9106: LD_ADDR_VAR 0 3
9110: PUSH
9111: LD_INT 1
9113: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9114: LD_VAR 0 4
9118: PUSH
9119: LD_INT 1
9121: ARRAY
9122: PPUSH
9123: LD_VAR 0 4
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PPUSH
9132: LD_INT 2
9134: PPUSH
9135: CALL_OW 456
// end ;
9139: GO 9077
9141: POP
9142: POP
// if mine_launched and IsOk ( Vervecken ) then
9143: LD_VAR 0 3
9147: PUSH
9148: LD_EXP 25
9152: PPUSH
9153: CALL_OW 302
9157: AND
9158: IFFALSE 9172
// Say ( Vervecken , D11b-Ar1-1 ) ;
9160: LD_EXP 25
9164: PPUSH
9165: LD_STRING D11b-Ar1-1
9167: PPUSH
9168: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9172: LD_INT 22
9174: PUSH
9175: LD_INT 2
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PPUSH
9182: CALL_OW 69
9186: PPUSH
9187: LD_INT 51
9189: PPUSH
9190: LD_INT 99
9192: PPUSH
9193: CALL_OW 111
// wait ( 0 0$1 ) ;
9197: LD_INT 35
9199: PPUSH
9200: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9204: LD_INT 22
9206: PUSH
9207: LD_INT 2
9209: PUSH
9210: EMPTY
9211: LIST
9212: LIST
9213: PUSH
9214: LD_INT 92
9216: PUSH
9217: LD_INT 51
9219: PUSH
9220: LD_INT 99
9222: PUSH
9223: LD_INT 2
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PPUSH
9236: CALL_OW 69
9240: IFFALSE 9300
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9242: LD_ADDR_VAR 0 1
9246: PUSH
9247: LD_INT 22
9249: PUSH
9250: LD_INT 2
9252: PUSH
9253: EMPTY
9254: LIST
9255: LIST
9256: PUSH
9257: LD_INT 92
9259: PUSH
9260: LD_INT 51
9262: PUSH
9263: LD_INT 99
9265: PUSH
9266: LD_INT 2
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: LIST
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: PPUSH
9279: CALL_OW 69
9283: PUSH
9284: FOR_IN
9285: IFFALSE 9298
// RemoveUnit ( i ) ;
9287: LD_VAR 0 1
9291: PPUSH
9292: CALL_OW 64
9296: GO 9284
9298: POP
9299: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9300: LD_INT 22
9302: PUSH
9303: LD_INT 2
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: PPUSH
9310: CALL_OW 69
9314: PUSH
9315: LD_INT 0
9317: EQUAL
9318: IFFALSE 9172
// end ;
9320: PPOPN 4
9322: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9323: LD_EXP 10
9327: IFFALSE 9506
9329: GO 9331
9331: DISABLE
9332: LD_INT 0
9334: PPUSH
// begin Wait ( 10 10$00 ) ;
9335: LD_INT 21000
9337: PPUSH
9338: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9342: LD_INT 22
9344: PUSH
9345: LD_INT 2
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL_OW 69
9356: IFFALSE 9506
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9358: LD_INT 22
9360: PUSH
9361: LD_INT 2
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PPUSH
9368: CALL_OW 69
9372: PPUSH
9373: LD_INT 51
9375: PPUSH
9376: LD_INT 99
9378: PPUSH
9379: CALL_OW 114
// wait ( 0 0$1 ) ;
9383: LD_INT 35
9385: PPUSH
9386: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9390: LD_INT 22
9392: PUSH
9393: LD_INT 2
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: PUSH
9400: LD_INT 92
9402: PUSH
9403: LD_INT 51
9405: PUSH
9406: LD_INT 99
9408: PUSH
9409: LD_INT 2
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: LIST
9416: LIST
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PPUSH
9422: CALL_OW 69
9426: IFFALSE 9486
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9428: LD_ADDR_VAR 0 1
9432: PUSH
9433: LD_INT 22
9435: PUSH
9436: LD_INT 2
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: PUSH
9443: LD_INT 92
9445: PUSH
9446: LD_INT 51
9448: PUSH
9449: LD_INT 99
9451: PUSH
9452: LD_INT 2
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: PPUSH
9465: CALL_OW 69
9469: PUSH
9470: FOR_IN
9471: IFFALSE 9484
// RemoveUnit ( i ) ;
9473: LD_VAR 0 1
9477: PPUSH
9478: CALL_OW 64
9482: GO 9470
9484: POP
9485: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9486: LD_INT 22
9488: PUSH
9489: LD_INT 2
9491: PUSH
9492: EMPTY
9493: LIST
9494: LIST
9495: PPUSH
9496: CALL_OW 69
9500: PUSH
9501: LD_INT 0
9503: EQUAL
9504: IFFALSE 9358
// end ; end ;
9506: PPOPN 1
9508: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9509: LD_EXP 4
9513: IFFALSE 10295
9515: GO 9517
9517: DISABLE
9518: LD_INT 0
9520: PPUSH
9521: PPUSH
9522: PPUSH
// begin Wait ( game_time ) ;
9523: LD_EXP 7
9527: PPUSH
9528: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9532: LD_INT 35
9534: PPUSH
9535: CALL_OW 67
// until ( not ru_can_attack ) ;
9539: LD_EXP 8
9543: NOT
9544: IFFALSE 9532
// Wait ( 0 0$35 ) ;
9546: LD_INT 1225
9548: PPUSH
9549: CALL_OW 67
// DialogueOn ;
9553: CALL_OW 6
// InGameOn ;
9557: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9561: LD_EXP 24
9565: PPUSH
9566: LD_STRING D12-Pow-1
9568: PPUSH
9569: CALL_OW 94
// InGameOff ;
9573: CALL_OW 9
// DialogueOff ;
9577: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9581: LD_STRING M4
9583: PPUSH
9584: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9588: LD_INT 5
9590: PPUSH
9591: LD_INT 1
9593: PPUSH
9594: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
9598: LD_INT 35
9600: PPUSH
9601: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_driving ] ] ] ) ;
9605: LD_INT 22
9607: PUSH
9608: LD_INT 1
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: PUSH
9615: LD_INT 21
9617: PUSH
9618: LD_INT 1
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PPUSH
9629: CALL_OW 69
9633: PUSH
9634: LD_INT 5
9636: PPUSH
9637: LD_INT 22
9639: PUSH
9640: LD_INT 1
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 2
9649: PUSH
9650: LD_INT 21
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: LD_INT 55
9662: PUSH
9663: EMPTY
9664: LIST
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PPUSH
9675: CALL_OW 70
9679: EQUAL
9680: IFFALSE 9598
// if not player_get_info then
9682: LD_EXP 15
9686: NOT
9687: IFFALSE 9698
// player_get_info := - 1 ;
9689: LD_ADDR_EXP 15
9693: PUSH
9694: LD_INT 1
9696: NEG
9697: ST_TO_ADDR
// AddMedal ( player_get_info , Information ) ;
9698: LD_EXP 15
9702: PPUSH
9703: LD_STRING Information
9705: PPUSH
9706: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9710: LD_ADDR_VAR 0 2
9714: PUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PUSH
9725: LD_INT 2
9727: PUSH
9728: LD_INT 25
9730: PUSH
9731: LD_INT 2
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PUSH
9738: LD_INT 25
9740: PUSH
9741: LD_INT 16
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: PUSH
9748: LD_INT 34
9750: PUSH
9751: LD_INT 12
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: PUSH
9758: EMPTY
9759: LIST
9760: LIST
9761: LIST
9762: LIST
9763: PUSH
9764: EMPTY
9765: LIST
9766: LIST
9767: PPUSH
9768: CALL_OW 69
9772: ST_TO_ADDR
// sib := GetTerminalCargo ;
9773: LD_ADDR_VAR 0 3
9777: PUSH
9778: CALL 753 0 0
9782: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
9783: LD_ADDR_VAR 0 3
9787: PUSH
9788: LD_VAR 0 3
9792: PUSH
9793: LD_INT 6
9795: PPUSH
9796: LD_INT 3
9798: PPUSH
9799: CALL_OW 287
9803: PLUS
9804: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
9805: LD_ADDR_VAR 0 3
9809: PUSH
9810: LD_VAR 0 3
9814: PUSH
9815: LD_VAR 0 2
9819: PPUSH
9820: LD_INT 3
9822: PPUSH
9823: CALL_OW 289
9827: PLUS
9828: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
9829: LD_VAR 0 3
9833: PUSH
9834: LD_INT 2
9836: PUSH
9837: LD_OWVAR 67
9841: PLUS
9842: PUSH
9843: LD_INT 50
9845: MUL
9846: LESS
9847: IFFALSE 9872
// AddMedal ( - 2 * Difficulty + 1 , MuchSiberite ) else
9849: LD_INT 2
9851: NEG
9852: PUSH
9853: LD_OWVAR 67
9857: MUL
9858: PUSH
9859: LD_INT 1
9861: PLUS
9862: PPUSH
9863: LD_STRING MuchSiberite
9865: PPUSH
9866: CALL_OW 101
9870: GO 9882
// AddMedal ( 1 , MuchSiberite ) ;
9872: LD_INT 1
9874: PPUSH
9875: LD_STRING MuchSiberite
9877: PPUSH
9878: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
9882: LD_INT 22
9884: PUSH
9885: LD_INT 1
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: PUSH
9892: LD_INT 2
9894: PUSH
9895: LD_INT 25
9897: PUSH
9898: LD_INT 1
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: PUSH
9905: LD_INT 25
9907: PUSH
9908: LD_INT 2
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: PUSH
9915: LD_INT 25
9917: PUSH
9918: LD_INT 3
9920: PUSH
9921: EMPTY
9922: LIST
9923: LIST
9924: PUSH
9925: LD_INT 25
9927: PUSH
9928: LD_INT 4
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PUSH
9935: LD_INT 25
9937: PUSH
9938: LD_INT 8
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PUSH
9945: EMPTY
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PPUSH
9957: CALL_OW 69
9961: PPUSH
9962: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
9966: LD_ADDR_VAR 0 2
9970: PUSH
9971: LD_INT 22
9973: PUSH
9974: LD_INT 1
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PUSH
9981: LD_INT 25
9983: PUSH
9984: LD_INT 8
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PUSH
9991: EMPTY
9992: LIST
9993: LIST
9994: PPUSH
9995: CALL_OW 69
9999: ST_TO_ADDR
// if tmp then
10000: LD_VAR 0 2
10004: IFFALSE 10035
// for i in tmp do
10006: LD_ADDR_VAR 0 1
10010: PUSH
10011: LD_VAR 0 2
10015: PUSH
10016: FOR_IN
10017: IFFALSE 10033
// SetClass ( i , 1 ) ;
10019: LD_VAR 0 1
10023: PPUSH
10024: LD_INT 1
10026: PPUSH
10027: CALL_OW 336
10031: GO 10016
10033: POP
10034: POP
// SaveVariable ( sib , 09_sibRes ) ;
10035: LD_VAR 0 3
10039: PPUSH
10040: LD_STRING 09_sibRes
10042: PPUSH
10043: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10047: LD_EXP 15
10051: PPUSH
10052: LD_STRING 09_arInfo
10054: PPUSH
10055: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10059: LD_EXP 17
10063: PPUSH
10064: LD_EXP 1
10068: PUSH
10069: LD_STRING JMM
10071: STR
10072: PPUSH
10073: CALL_OW 38
// if IsLive ( Gary ) then
10077: LD_EXP 18
10081: PPUSH
10082: CALL_OW 300
10086: IFFALSE 10106
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10088: LD_EXP 18
10092: PPUSH
10093: LD_EXP 1
10097: PUSH
10098: LD_STRING Gary
10100: STR
10101: PPUSH
10102: CALL_OW 38
// if IsLive ( Bobby ) then
10106: LD_EXP 19
10110: PPUSH
10111: CALL_OW 300
10115: IFFALSE 10135
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10117: LD_EXP 19
10121: PPUSH
10122: LD_EXP 1
10126: PUSH
10127: LD_STRING Bobby
10129: STR
10130: PPUSH
10131: CALL_OW 38
// if IsLive ( Cyrus ) then
10135: LD_EXP 20
10139: PPUSH
10140: CALL_OW 300
10144: IFFALSE 10164
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10146: LD_EXP 20
10150: PPUSH
10151: LD_EXP 1
10155: PUSH
10156: LD_STRING Cyrus
10158: STR
10159: PPUSH
10160: CALL_OW 38
// if IsLive ( Houten ) then
10164: LD_EXP 21
10168: PPUSH
10169: CALL_OW 300
10173: IFFALSE 10193
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10175: LD_EXP 21
10179: PPUSH
10180: LD_EXP 1
10184: PUSH
10185: LD_STRING Houten
10187: STR
10188: PPUSH
10189: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10193: LD_ADDR_VAR 0 2
10197: PUSH
10198: LD_INT 22
10200: PUSH
10201: LD_INT 1
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: LD_INT 2
10210: PUSH
10211: LD_INT 25
10213: PUSH
10214: LD_INT 1
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 25
10223: PUSH
10224: LD_INT 2
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: PUSH
10231: LD_INT 25
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: PUSH
10241: LD_INT 25
10243: PUSH
10244: LD_INT 4
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: PPUSH
10262: CALL_OW 69
10266: ST_TO_ADDR
// if tmp then
10267: LD_VAR 0 2
10271: IFFALSE 10291
// SaveCharacters ( tmp , mission_prefix & others ) ;
10273: LD_VAR 0 2
10277: PPUSH
10278: LD_EXP 1
10282: PUSH
10283: LD_STRING others
10285: STR
10286: PPUSH
10287: CALL_OW 38
// YouWin ;
10291: CALL_OW 103
// end ; end_of_file
10295: PPOPN 3
10297: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10298: LD_VAR 0 1
10302: PPUSH
10303: CALL_OW 266
10307: PUSH
10308: LD_INT 0
10310: EQUAL
10311: PUSH
10312: LD_EXP 3
10316: NOT
10317: AND
10318: IFFALSE 10342
// begin terminal := b ;
10320: LD_ADDR_EXP 3
10324: PUSH
10325: LD_VAR 0 1
10329: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10330: LD_EXP 3
10334: PPUSH
10335: LD_STRING terminal
10337: PPUSH
10338: CALL_OW 500
// end ; end ;
10342: PPOPN 2
10344: END
// on BuildingComplete ( b ) do var i ;
10345: LD_INT 0
10347: PPUSH
// begin if GetSide ( b ) = 3 then
10348: LD_VAR 0 1
10352: PPUSH
10353: CALL_OW 255
10357: PUSH
10358: LD_INT 3
10360: EQUAL
10361: IFFALSE 10401
// for i = 1 to 4 do
10363: LD_ADDR_VAR 0 2
10367: PUSH
10368: DOUBLE
10369: LD_INT 1
10371: DEC
10372: ST_TO_ADDR
10373: LD_INT 4
10375: PUSH
10376: FOR_TO
10377: IFFALSE 10399
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10379: LD_ADDR_EXP 34
10383: PUSH
10384: LD_EXP 34
10388: PPUSH
10389: LD_INT 1
10391: PPUSH
10392: CALL_OW 3
10396: ST_TO_ADDR
10397: GO 10376
10399: POP
10400: POP
// end ;
10401: PPOPN 2
10403: END
// on VehicleConstructed ( veh , fac ) do var i ;
10404: LD_INT 0
10406: PPUSH
// begin if GetSide ( veh ) = 3 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 255
10416: PUSH
10417: LD_INT 3
10419: EQUAL
10420: IFFALSE 10545
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10422: LD_VAR 0 1
10426: PPUSH
10427: CALL_OW 264
10431: PUSH
10432: LD_INT 53
10434: PUSH
10435: LD_INT 52
10437: PUSH
10438: LD_INT 51
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: LIST
10445: IN
10446: NOT
10447: IFFALSE 10465
// ru_force := ru_force ^ veh ;
10449: LD_ADDR_EXP 33
10453: PUSH
10454: LD_EXP 33
10458: PUSH
10459: LD_VAR 0 1
10463: ADD
10464: ST_TO_ADDR
// for i = 1 to 4 do
10465: LD_ADDR_VAR 0 3
10469: PUSH
10470: DOUBLE
10471: LD_INT 1
10473: DEC
10474: ST_TO_ADDR
10475: LD_INT 4
10477: PUSH
10478: FOR_TO
10479: IFFALSE 10501
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10481: LD_ADDR_EXP 35
10485: PUSH
10486: LD_EXP 35
10490: PPUSH
10491: LD_INT 1
10493: PPUSH
10494: CALL_OW 3
10498: ST_TO_ADDR
10499: GO 10478
10501: POP
10502: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10503: LD_VAR 0 1
10507: PPUSH
10508: CALL_OW 264
10512: PUSH
10513: LD_INT 53
10515: EQUAL
10516: IFFALSE 10545
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10518: LD_VAR 0 1
10522: PPUSH
10523: LD_INT 7
10525: PPUSH
10526: CALL 911 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10530: LD_VAR 0 1
10534: PPUSH
10535: LD_INT 170
10537: PPUSH
10538: LD_INT 235
10540: PPUSH
10541: CALL_OW 171
// end ; end ; end ;
10545: PPOPN 3
10547: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10548: LD_VAR 0 1
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_VAR 0 2
10561: PUSH
10562: LD_INT 2
10564: EQUAL
10565: AND
10566: PUSH
10567: LD_VAR 0 1
10571: PUSH
10572: LD_INT 2
10574: EQUAL
10575: PUSH
10576: LD_VAR 0 2
10580: PUSH
10581: LD_INT 1
10583: EQUAL
10584: AND
10585: OR
10586: IFFALSE 10596
// player_attacked_ar := true ;
10588: LD_ADDR_EXP 16
10592: PUSH
10593: LD_INT 1
10595: ST_TO_ADDR
// end ;
10596: PPOPN 2
10598: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10599: LD_VAR 0 1
10603: PUSH
10604: LD_EXP 17
10608: EQUAL
10609: IFFALSE 10618
// YouLost ( JMM ) ;
10611: LD_STRING JMM
10613: PPUSH
10614: CALL_OW 104
// if un = terminal then
10618: LD_VAR 0 1
10622: PUSH
10623: LD_EXP 3
10627: EQUAL
10628: IFFALSE 10637
// YouLost ( Terminal ) ;
10630: LD_STRING Terminal
10632: PPUSH
10633: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10637: LD_VAR 0 1
10641: PUSH
10642: LD_INT 22
10644: PUSH
10645: LD_INT 3
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: PUSH
10652: LD_INT 21
10654: PUSH
10655: LD_INT 3
10657: PUSH
10658: EMPTY
10659: LIST
10660: LIST
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: IN
10671: IFFALSE 10817
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10673: LD_VAR 0 1
10677: PPUSH
10678: CALL_OW 266
10682: PUSH
10683: LD_INT 33
10685: PUSH
10686: LD_INT 26
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: IN
10693: IFFALSE 10752
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10695: LD_ADDR_EXP 34
10699: PUSH
10700: LD_EXP 34
10704: PUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 266
10714: PUSH
10715: LD_VAR 0 1
10719: PPUSH
10720: CALL_OW 250
10724: PUSH
10725: LD_VAR 0 1
10729: PPUSH
10730: CALL_OW 251
10734: PUSH
10735: LD_VAR 0 1
10739: PPUSH
10740: CALL_OW 254
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: ADD
10751: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10752: LD_VAR 0 1
10756: PPUSH
10757: CALL_OW 266
10761: PUSH
10762: LD_INT 5
10764: EQUAL
10765: IFFALSE 10817
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10767: LD_ADDR_EXP 34
10771: PUSH
10772: LD_EXP 34
10776: PUSH
10777: LD_INT 4
10779: PUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 250
10789: PUSH
10790: LD_VAR 0 1
10794: PPUSH
10795: CALL_OW 251
10799: PUSH
10800: LD_VAR 0 1
10804: PPUSH
10805: CALL_OW 254
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: LIST
10814: LIST
10815: ADD
10816: ST_TO_ADDR
// end ; if un in ru_force then
10817: LD_VAR 0 1
10821: PUSH
10822: LD_EXP 33
10826: IN
10827: IFFALSE 10860
// begin ru_force := ru_force diff un ;
10829: LD_ADDR_EXP 33
10833: PUSH
10834: LD_EXP 33
10838: PUSH
10839: LD_VAR 0 1
10843: DIFF
10844: ST_TO_ADDR
// if not ru_force then
10845: LD_EXP 33
10849: NOT
10850: IFFALSE 10860
// ru_can_attack := false ;
10852: LD_ADDR_EXP 8
10856: PUSH
10857: LD_INT 0
10859: ST_TO_ADDR
// end ; end ; end_of_file
10860: PPOPN 1
10862: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
10863: LD_EXP 5
10867: PUSH
10868: LD_EXP 6
10872: AND
10873: IFFALSE 10951
10875: GO 10877
10877: DISABLE
10878: LD_INT 0
10880: PPUSH
// begin enable ;
10881: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
10882: LD_ADDR_VAR 0 1
10886: PUSH
10887: LD_INT 60
10889: PUSH
10890: CALL 753 0 0
10894: MINUS
10895: ST_TO_ADDR
// if sib < 0 then
10896: LD_VAR 0 1
10900: PUSH
10901: LD_INT 0
10903: LESS
10904: IFFALSE 10914
// sib := 0 ;
10906: LD_ADDR_VAR 0 1
10910: PUSH
10911: LD_INT 0
10913: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
10914: LD_ADDR_OWVAR 47
10918: PUSH
10919: LD_STRING #Am09-1
10921: PUSH
10922: LD_VAR 0 1
10926: PUSH
10927: LD_EXP 6
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: LIST
10936: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
10937: LD_ADDR_EXP 6
10941: PUSH
10942: LD_EXP 6
10946: PUSH
10947: LD_INT 35
10949: MINUS
10950: ST_TO_ADDR
// end ;
10951: PPOPN 1
10953: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
10954: LD_EXP 6
10958: PUSH
10959: LD_INT 0
10961: EQUAL
10962: IFFALSE 10974
10964: GO 10966
10966: DISABLE
// display_strings := [ ] ;
10967: LD_ADDR_OWVAR 47
10971: PUSH
10972: EMPTY
10973: ST_TO_ADDR
10974: END
// every 0 0$35 + 1 1$0 marked 01 do
10975: GO 10977
10977: DISABLE
// begin enable ;
10978: ENABLE
// CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
10979: LD_INT 1
10981: PPUSH
10982: LD_INT 5
10984: PPUSH
10985: CALL_OW 12
10989: PPUSH
10990: LD_INT 75
10992: PPUSH
10993: LD_INT 75
10995: PPUSH
10996: LD_INT 20
10998: PPUSH
10999: LD_INT 1
11001: PPUSH
11002: CALL_OW 56
// if tick > [ 9 9$0 , 8 8$0 , 7 7$0 ] [ Difficulty ] then
11006: LD_OWVAR 1
11010: PUSH
11011: LD_INT 18900
11013: PUSH
11014: LD_INT 16800
11016: PUSH
11017: LD_INT 14700
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: LIST
11024: PUSH
11025: LD_OWVAR 67
11029: ARRAY
11030: GREATER
11031: IFFALSE 11036
// disable ( 01 ) ;
11033: LD_INT 1
11035: DISABLE_MARKED
// end ;
11036: END
// every 2 2$30 trigger jmm_in_ovsyenko do
11037: LD_EXP 4
11041: IFFALSE 11068
11043: GO 11045
11045: DISABLE
// begin enable ;
11046: ENABLE
// CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11047: LD_INT 2
11049: PPUSH
11050: LD_INT 5
11052: PPUSH
11053: CALL_OW 12
11057: PPUSH
11058: LD_INT 8
11060: PPUSH
11061: LD_INT 1
11063: PPUSH
11064: CALL_OW 55
// end ; end_of_file
11068: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11069: LD_INT 0
11071: PPUSH
11072: PPUSH
11073: PPUSH
11074: PPUSH
11075: PPUSH
11076: PPUSH
// x := 76 ;
11077: LD_ADDR_VAR 0 5
11081: PUSH
11082: LD_INT 76
11084: ST_TO_ADDR
// y := 147 ;
11085: LD_ADDR_VAR 0 6
11089: PUSH
11090: LD_INT 147
11092: ST_TO_ADDR
// uc_side := 2 ;
11093: LD_ADDR_OWVAR 20
11097: PUSH
11098: LD_INT 2
11100: ST_TO_ADDR
// uc_nation := 2 ;
11101: LD_ADDR_OWVAR 21
11105: PUSH
11106: LD_INT 2
11108: ST_TO_ADDR
// InitHc ;
11109: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11113: LD_INT 1
11115: PPUSH
11116: LD_INT 1
11118: PPUSH
11119: LD_INT 6
11121: PPUSH
11122: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11126: LD_ADDR_OWVAR 26
11130: PUSH
11131: LD_STRING Nicolas Vervecken
11133: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11134: LD_ADDR_OWVAR 33
11138: PUSH
11139: LD_STRING SecondCharsGal
11141: ST_TO_ADDR
// hc_face_number := 3 ;
11142: LD_ADDR_OWVAR 34
11146: PUSH
11147: LD_INT 3
11149: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11150: LD_ADDR_OWVAR 29
11154: PUSH
11155: LD_INT 11
11157: PUSH
11158: LD_INT 10
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: ST_TO_ADDR
// Vervecken := CreateHuman ;
11165: LD_ADDR_EXP 25
11169: PUSH
11170: CALL_OW 44
11174: ST_TO_ADDR
// ar_force := Vervecken ;
11175: LD_ADDR_EXP 32
11179: PUSH
11180: LD_EXP 25
11184: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11185: LD_INT 1
11187: PPUSH
11188: LD_INT 2
11190: PPUSH
11191: LD_INT 6
11193: PPUSH
11194: CALL_OW 380
// hc_name := Louis Gali ;
11198: LD_ADDR_OWVAR 26
11202: PUSH
11203: LD_STRING Louis Gali
11205: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11206: LD_ADDR_OWVAR 33
11210: PUSH
11211: LD_STRING SecondCharsGal
11213: ST_TO_ADDR
// hc_face_number := 2 ;
11214: LD_ADDR_OWVAR 34
11218: PUSH
11219: LD_INT 2
11221: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11222: LD_ADDR_OWVAR 29
11226: PUSH
11227: LD_INT 10
11229: PUSH
11230: LD_INT 11
11232: PUSH
11233: EMPTY
11234: LIST
11235: LIST
11236: ST_TO_ADDR
// Gali := CreateHuman ;
11237: LD_ADDR_EXP 26
11241: PUSH
11242: CALL_OW 44
11246: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11247: LD_ADDR_EXP 32
11251: PUSH
11252: LD_EXP 32
11256: PUSH
11257: LD_EXP 26
11261: ADD
11262: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11263: LD_INT 2
11265: PPUSH
11266: LD_INT 1
11268: PPUSH
11269: LD_INT 6
11271: PPUSH
11272: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11276: LD_ADDR_OWVAR 26
11280: PUSH
11281: LD_STRING Maria Bogdanovic
11283: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11284: LD_ADDR_OWVAR 33
11288: PUSH
11289: LD_STRING SecondCharsGal
11291: ST_TO_ADDR
// hc_face_number := 14 ;
11292: LD_ADDR_OWVAR 34
11296: PUSH
11297: LD_INT 14
11299: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11300: LD_ADDR_OWVAR 29
11304: PUSH
11305: LD_INT 12
11307: PUSH
11308: LD_INT 9
11310: PUSH
11311: EMPTY
11312: LIST
11313: LIST
11314: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11315: LD_ADDR_EXP 27
11319: PUSH
11320: CALL_OW 44
11324: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11325: LD_ADDR_EXP 32
11329: PUSH
11330: LD_EXP 32
11334: PUSH
11335: LD_EXP 27
11339: ADD
11340: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11341: LD_INT 1
11343: PPUSH
11344: LD_INT 3
11346: PPUSH
11347: LD_INT 6
11349: PPUSH
11350: CALL_OW 380
// hc_name = Kntor Radomr ;
11354: LD_ADDR_OWVAR 26
11358: PUSH
11359: LD_STRING Kntor Radomr
11361: ST_TO_ADDR
// hc_gallery = sandar ;
11362: LD_ADDR_OWVAR 33
11366: PUSH
11367: LD_STRING sandar
11369: ST_TO_ADDR
// hc_face_number = 12 ;
11370: LD_ADDR_OWVAR 34
11374: PUSH
11375: LD_INT 12
11377: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11378: LD_ADDR_OWVAR 29
11382: PUSH
11383: LD_INT 9
11385: PUSH
11386: LD_INT 9
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: ST_TO_ADDR
// Kantor = CreateHuman ;
11393: LD_ADDR_EXP 28
11397: PUSH
11398: CALL_OW 44
11402: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11403: LD_ADDR_EXP 32
11407: PUSH
11408: LD_EXP 32
11412: PUSH
11413: LD_EXP 28
11417: ADD
11418: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11419: LD_INT 1
11421: PPUSH
11422: LD_INT 3
11424: PPUSH
11425: LD_INT 6
11427: PPUSH
11428: CALL_OW 380
// hc_name = Herczeg Farkas ;
11432: LD_ADDR_OWVAR 26
11436: PUSH
11437: LD_STRING Herczeg Farkas
11439: ST_TO_ADDR
// hc_gallery = sandar ;
11440: LD_ADDR_OWVAR 33
11444: PUSH
11445: LD_STRING sandar
11447: ST_TO_ADDR
// hc_face_number = 28 ;
11448: LD_ADDR_OWVAR 34
11452: PUSH
11453: LD_INT 28
11455: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11456: LD_ADDR_OWVAR 29
11460: PUSH
11461: LD_INT 10
11463: PUSH
11464: LD_INT 9
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: ST_TO_ADDR
// Herczeg = CreateHuman ;
11471: LD_ADDR_EXP 29
11475: PUSH
11476: CALL_OW 44
11480: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11481: LD_ADDR_EXP 32
11485: PUSH
11486: LD_EXP 32
11490: PUSH
11491: LD_EXP 29
11495: ADD
11496: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11497: LD_INT 1
11499: PPUSH
11500: LD_INT 1
11502: PPUSH
11503: LD_INT 6
11505: PPUSH
11506: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11510: LD_ADDR_OWVAR 26
11514: PUSH
11515: LD_STRING Ronn Horntvedt
11517: ST_TO_ADDR
// hc_gallery = sandar ;
11518: LD_ADDR_OWVAR 33
11522: PUSH
11523: LD_STRING sandar
11525: ST_TO_ADDR
// hc_face_number = 29 ;
11526: LD_ADDR_OWVAR 34
11530: PUSH
11531: LD_INT 29
11533: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11534: LD_ADDR_OWVAR 29
11538: PUSH
11539: LD_INT 11
11541: PUSH
11542: LD_INT 11
11544: PUSH
11545: EMPTY
11546: LIST
11547: LIST
11548: ST_TO_ADDR
// Ronn = CreateHuman ;
11549: LD_ADDR_EXP 30
11553: PUSH
11554: CALL_OW 44
11558: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11559: LD_ADDR_EXP 32
11563: PUSH
11564: LD_EXP 32
11568: PUSH
11569: LD_EXP 30
11573: ADD
11574: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11575: LD_INT 2
11577: PPUSH
11578: LD_INT 3
11580: PPUSH
11581: LD_INT 6
11583: PPUSH
11584: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11588: LD_ADDR_OWVAR 26
11592: PUSH
11593: LD_STRING Mia D. Mathiasen
11595: ST_TO_ADDR
// hc_gallery = sandar ;
11596: LD_ADDR_OWVAR 33
11600: PUSH
11601: LD_STRING sandar
11603: ST_TO_ADDR
// hc_face_number = 31 ;
11604: LD_ADDR_OWVAR 34
11608: PUSH
11609: LD_INT 31
11611: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
11612: LD_ADDR_OWVAR 29
11616: PUSH
11617: LD_INT 10
11619: PUSH
11620: LD_INT 10
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: ST_TO_ADDR
// Mia = CreateHuman ;
11627: LD_ADDR_EXP 31
11631: PUSH
11632: CALL_OW 44
11636: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
11637: LD_ADDR_EXP 32
11641: PUSH
11642: LD_EXP 32
11646: PUSH
11647: LD_EXP 31
11651: ADD
11652: ST_TO_ADDR
// for i = 1 to 2 do
11653: LD_ADDR_VAR 0 4
11657: PUSH
11658: DOUBLE
11659: LD_INT 1
11661: DEC
11662: ST_TO_ADDR
11663: LD_INT 2
11665: PUSH
11666: FOR_TO
11667: IFFALSE 11708
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
11669: LD_ADDR_VAR 0 3
11673: PUSH
11674: LD_VAR 0 3
11678: PUSH
11679: LD_INT 2
11681: PPUSH
11682: LD_INT 2
11684: PPUSH
11685: LD_INT 14
11687: PPUSH
11688: LD_INT 1
11690: PPUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 32
11696: PPUSH
11697: LD_INT 30
11699: PPUSH
11700: CALL 252 0 7
11704: ADD
11705: ST_TO_ADDR
11706: GO 11666
11708: POP
11709: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
11710: LD_ADDR_VAR 0 3
11714: PUSH
11715: LD_VAR 0 3
11719: PUSH
11720: LD_INT 2
11722: PPUSH
11723: LD_INT 2
11725: PPUSH
11726: LD_INT 14
11728: PPUSH
11729: LD_INT 1
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: LD_INT 26
11737: PPUSH
11738: LD_INT 33
11740: PPUSH
11741: CALL 252 0 7
11745: ADD
11746: ST_TO_ADDR
// tmp := tmp diff 0 ;
11747: LD_ADDR_VAR 0 3
11751: PUSH
11752: LD_VAR 0 3
11756: PUSH
11757: LD_INT 0
11759: DIFF
11760: ST_TO_ADDR
// for i in ar_force do
11761: LD_ADDR_VAR 0 4
11765: PUSH
11766: LD_EXP 32
11770: PUSH
11771: FOR_IN
11772: IFFALSE 11915
// begin if GetClass ( i ) = 3 then
11774: LD_VAR 0 4
11778: PPUSH
11779: CALL_OW 257
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: IFFALSE 11869
// begin SetDir ( tmp [ 1 ] , 1 ) ;
11789: LD_VAR 0 3
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_INT 1
11800: PPUSH
11801: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
11805: LD_VAR 0 3
11809: PUSH
11810: LD_INT 1
11812: ARRAY
11813: PPUSH
11814: LD_VAR 0 5
11818: PPUSH
11819: LD_VAR 0 6
11823: PPUSH
11824: LD_INT 0
11826: PPUSH
11827: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
11831: LD_VAR 0 4
11835: PPUSH
11836: LD_VAR 0 3
11840: PUSH
11841: LD_INT 1
11843: ARRAY
11844: PPUSH
11845: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
11849: LD_ADDR_VAR 0 3
11853: PUSH
11854: LD_VAR 0 3
11858: PPUSH
11859: LD_INT 1
11861: PPUSH
11862: CALL_OW 3
11866: ST_TO_ADDR
// end else
11867: GO 11891
// PlaceUnitXY ( i , x , y , false ) ;
11869: LD_VAR 0 4
11873: PPUSH
11874: LD_VAR 0 5
11878: PPUSH
11879: LD_VAR 0 6
11883: PPUSH
11884: LD_INT 0
11886: PPUSH
11887: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
11891: LD_VAR 0 4
11895: PPUSH
11896: LD_INT 86
11898: PPUSH
11899: LD_INT 121
11901: PPUSH
11902: CALL_OW 111
// wait ( 0 0$2 ) ;
11906: LD_INT 70
11908: PPUSH
11909: CALL_OW 67
// end ;
11913: GO 11771
11915: POP
11916: POP
// ar_force := ar_force ^ tmp ;
11917: LD_ADDR_EXP 32
11921: PUSH
11922: LD_EXP 32
11926: PUSH
11927: LD_VAR 0 3
11931: ADD
11932: ST_TO_ADDR
// ar_spawned := true ;
11933: LD_ADDR_EXP 11
11937: PUSH
11938: LD_INT 1
11940: ST_TO_ADDR
// end ; end_of_file
11941: LD_VAR 0 1
11945: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
11946: LD_INT 0
11948: PPUSH
11949: PPUSH
11950: PPUSH
11951: PPUSH
11952: PPUSH
11953: PPUSH
11954: PPUSH
// InitHc ;
11955: CALL_OW 19
// uc_side := 3 ;
11959: LD_ADDR_OWVAR 20
11963: PUSH
11964: LD_INT 3
11966: ST_TO_ADDR
// uc_nation := 3 ;
11967: LD_ADDR_OWVAR 21
11971: PUSH
11972: LD_INT 3
11974: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
11975: LD_ADDR_VAR 0 5
11979: PUSH
11980: LD_INT 5
11982: PUSH
11983: LD_INT 6
11985: PUSH
11986: LD_INT 7
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: LIST
11993: PUSH
11994: LD_OWVAR 67
11998: ARRAY
11999: ST_TO_ADDR
// ru_force := [ ] ;
12000: LD_ADDR_EXP 33
12004: PUSH
12005: EMPTY
12006: ST_TO_ADDR
// ru_rebuild := [ ] ;
12007: LD_ADDR_EXP 34
12011: PUSH
12012: EMPTY
12013: ST_TO_ADDR
// ru_produce_list := [ ] ;
12014: LD_ADDR_EXP 35
12018: PUSH
12019: EMPTY
12020: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12021: LD_ADDR_VAR 0 6
12025: PUSH
12026: LD_INT 22
12028: PUSH
12029: LD_INT 3
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: LD_INT 30
12038: PUSH
12039: LD_INT 8
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PPUSH
12050: CALL_OW 69
12054: PUSH
12055: LD_INT 1
12057: ARRAY
12058: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12059: LD_ADDR_VAR 0 4
12063: PUSH
12064: LD_INT 43
12066: PUSH
12067: LD_INT 46
12069: PUSH
12070: LD_INT 45
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12078: LD_ADDR_VAR 0 7
12082: PUSH
12083: LD_INT 22
12085: PUSH
12086: LD_INT 3
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: LD_INT 1
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PPUSH
12107: CALL_OW 69
12111: PUSH
12112: LD_INT 1
12114: ARRAY
12115: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12116: LD_VAR 0 7
12120: PPUSH
12121: CALL_OW 274
12125: PPUSH
12126: LD_INT 1
12128: PPUSH
12129: LD_INT 5000
12131: PPUSH
12132: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12136: LD_VAR 0 7
12140: PPUSH
12141: CALL_OW 274
12145: PPUSH
12146: LD_INT 2
12148: PPUSH
12149: LD_INT 1000
12151: PPUSH
12152: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12156: LD_VAR 0 7
12160: PPUSH
12161: CALL_OW 274
12165: PPUSH
12166: LD_INT 3
12168: PPUSH
12169: LD_INT 30
12171: PPUSH
12172: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12176: LD_ADDR_VAR 0 2
12180: PUSH
12181: LD_INT 22
12183: PUSH
12184: LD_INT 3
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: PUSH
12191: LD_INT 30
12193: PUSH
12194: LD_INT 33
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PUSH
12201: EMPTY
12202: LIST
12203: LIST
12204: PPUSH
12205: CALL_OW 69
12209: PUSH
12210: FOR_IN
12211: IFFALSE 12243
// begin PlaceWeaponTurret ( i , tmp [ rand ( 1 , tmp ) ] ) ;
12213: LD_VAR 0 2
12217: PPUSH
12218: LD_VAR 0 4
12222: PUSH
12223: LD_INT 1
12225: PPUSH
12226: LD_VAR 0 4
12230: PPUSH
12231: CALL_OW 12
12235: ARRAY
12236: PPUSH
12237: CALL_OW 431
// end ;
12241: GO 12210
12243: POP
12244: POP
// for i = 1 to 4 do
12245: LD_ADDR_VAR 0 2
12249: PUSH
12250: DOUBLE
12251: LD_INT 1
12253: DEC
12254: ST_TO_ADDR
12255: LD_INT 4
12257: PUSH
12258: FOR_TO
12259: IFFALSE 12320
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12261: LD_INT 0
12263: PPUSH
12264: LD_INT 9
12266: PPUSH
12267: LD_VAR 0 5
12271: PPUSH
12272: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12276: CALL_OW 44
12280: PPUSH
12281: LD_INT 22
12283: PUSH
12284: LD_INT 3
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: PUSH
12291: LD_INT 30
12293: PUSH
12294: LD_INT 5
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PPUSH
12305: CALL_OW 69
12309: PUSH
12310: LD_INT 1
12312: ARRAY
12313: PPUSH
12314: CALL_OW 52
// end ;
12318: GO 12258
12320: POP
12321: POP
// for i = 1 to 5 do
12322: LD_ADDR_VAR 0 2
12326: PUSH
12327: DOUBLE
12328: LD_INT 1
12330: DEC
12331: ST_TO_ADDR
12332: LD_INT 5
12334: PUSH
12335: FOR_TO
12336: IFFALSE 12397
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12338: LD_INT 0
12340: PPUSH
12341: LD_INT 3
12343: PPUSH
12344: LD_VAR 0 5
12348: PPUSH
12349: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12353: CALL_OW 44
12357: PPUSH
12358: LD_INT 22
12360: PUSH
12361: LD_INT 3
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: LD_INT 30
12370: PUSH
12371: LD_INT 3
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PPUSH
12382: CALL_OW 69
12386: PUSH
12387: LD_INT 1
12389: ARRAY
12390: PPUSH
12391: CALL_OW 52
// end ;
12395: GO 12335
12397: POP
12398: POP
// for i = 1 to 4 do
12399: LD_ADDR_VAR 0 2
12403: PUSH
12404: DOUBLE
12405: LD_INT 1
12407: DEC
12408: ST_TO_ADDR
12409: LD_INT 4
12411: PUSH
12412: FOR_TO
12413: IFFALSE 12474
// begin PrepareHuman ( false , class_engineer , skill ) ;
12415: LD_INT 0
12417: PPUSH
12418: LD_INT 2
12420: PPUSH
12421: LD_VAR 0 5
12425: PPUSH
12426: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12430: CALL_OW 44
12434: PPUSH
12435: LD_INT 22
12437: PUSH
12438: LD_INT 3
12440: PUSH
12441: EMPTY
12442: LIST
12443: LIST
12444: PUSH
12445: LD_INT 30
12447: PUSH
12448: LD_INT 1
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PPUSH
12459: CALL_OW 69
12463: PUSH
12464: LD_INT 1
12466: ARRAY
12467: PPUSH
12468: CALL_OW 52
// end ;
12472: GO 12412
12474: POP
12475: POP
// for i = 1 to 3 do
12476: LD_ADDR_VAR 0 2
12480: PUSH
12481: DOUBLE
12482: LD_INT 1
12484: DEC
12485: ST_TO_ADDR
12486: LD_INT 3
12488: PUSH
12489: FOR_TO
12490: IFFALSE 12523
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12492: LD_INT 0
12494: PPUSH
12495: LD_INT 4
12497: PPUSH
12498: LD_VAR 0 5
12502: PPUSH
12503: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12507: CALL_OW 44
12511: PPUSH
12512: LD_VAR 0 6
12516: PPUSH
12517: CALL_OW 52
// end ;
12521: GO 12489
12523: POP
12524: POP
// AddComResearch ( lab , tech_tech2 ) ;
12525: LD_VAR 0 6
12529: PPUSH
12530: LD_INT 49
12532: PPUSH
12533: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12537: LD_VAR 0 6
12541: PPUSH
12542: LD_INT 50
12544: PPUSH
12545: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12549: LD_VAR 0 6
12553: PPUSH
12554: LD_INT 51
12556: PPUSH
12557: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12561: LD_VAR 0 6
12565: PPUSH
12566: LD_INT 52
12568: PPUSH
12569: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12573: LD_VAR 0 6
12577: PPUSH
12578: LD_INT 69
12580: PPUSH
12581: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12585: LD_VAR 0 6
12589: PPUSH
12590: LD_INT 39
12592: PPUSH
12593: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
12597: LD_VAR 0 6
12601: PPUSH
12602: LD_INT 34
12604: PPUSH
12605: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
12609: LD_VAR 0 6
12613: PPUSH
12614: LD_INT 40
12616: PPUSH
12617: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
12621: LD_VAR 0 6
12625: PPUSH
12626: LD_INT 57
12628: PPUSH
12629: CALL_OW 184
// if Difficulty > 1 then
12633: LD_OWVAR 67
12637: PUSH
12638: LD_INT 1
12640: GREATER
12641: IFFALSE 12655
// AddComResearch ( lab , tech_comp2 ) ;
12643: LD_VAR 0 6
12647: PPUSH
12648: LD_INT 58
12650: PPUSH
12651: CALL_OW 184
// end ;
12655: LD_VAR 0 1
12659: RET
// every 7 7$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 do
12660: LD_INT 7
12662: PPUSH
12663: CALL_OW 353
12667: PUSH
12668: LD_INT 3
12670: GREATER
12671: IFFALSE 12706
12673: GO 12675
12675: DISABLE
// begin enable ;
12676: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
12677: LD_ADDR_EXP 35
12681: PUSH
12682: LD_EXP 35
12686: PUSH
12687: LD_INT 24
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: LD_INT 3
12695: PUSH
12696: LD_INT 53
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: ADD
12705: ST_TO_ADDR
// end ;
12706: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
12707: LD_INT 22
12709: PUSH
12710: LD_INT 3
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 21
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: PPUSH
12731: CALL_OW 69
12735: IFFALSE 13513
12737: GO 12739
12739: DISABLE
12740: LD_INT 0
12742: PPUSH
12743: PPUSH
12744: PPUSH
12745: PPUSH
12746: PPUSH
12747: PPUSH
12748: PPUSH
12749: PPUSH
// begin enable ;
12750: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12751: LD_ADDR_VAR 0 3
12755: PUSH
12756: LD_INT 22
12758: PUSH
12759: LD_INT 3
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PUSH
12766: LD_INT 21
12768: PUSH
12769: LD_INT 3
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: LD_INT 3
12778: PUSH
12779: LD_INT 24
12781: PUSH
12782: LD_INT 1000
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: LIST
12797: PPUSH
12798: CALL_OW 69
12802: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12803: LD_ADDR_VAR 0 4
12807: PUSH
12808: LD_INT 22
12810: PUSH
12811: LD_INT 3
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: LD_INT 25
12820: PUSH
12821: LD_INT 2
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PPUSH
12832: CALL_OW 69
12836: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12837: LD_ADDR_VAR 0 5
12841: PUSH
12842: LD_INT 22
12844: PUSH
12845: LD_INT 3
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: LD_INT 30
12854: PUSH
12855: LD_INT 1
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PPUSH
12866: CALL_OW 69
12870: PUSH
12871: LD_INT 1
12873: ARRAY
12874: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
12875: LD_ADDR_VAR 0 8
12879: PUSH
12880: LD_INT 22
12882: PUSH
12883: LD_INT 3
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: PUSH
12890: LD_INT 2
12892: PUSH
12893: LD_INT 30
12895: PUSH
12896: LD_INT 6
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 30
12905: PUSH
12906: LD_INT 7
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: PUSH
12913: LD_INT 30
12915: PUSH
12916: LD_INT 8
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PPUSH
12933: CALL_OW 69
12937: PUSH
12938: LD_INT 1
12940: ARRAY
12941: ST_TO_ADDR
// if not engs then
12942: LD_VAR 0 4
12946: NOT
12947: IFFALSE 12951
// exit ;
12949: GO 13513
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
12951: LD_ADDR_VAR 0 6
12955: PUSH
12956: LD_VAR 0 4
12960: PPUSH
12961: LD_INT 3
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 600
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PPUSH
12978: CALL_OW 72
12982: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
12983: LD_ADDR_VAR 0 7
12987: PUSH
12988: LD_INT 22
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: LD_INT 25
13000: PUSH
13001: LD_INT 4
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PPUSH
13012: CALL_OW 69
13016: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13017: LD_VAR 0 3
13021: NOT
13022: PUSH
13023: LD_EXP 34
13027: NOT
13028: AND
13029: IFFALSE 13089
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13031: LD_VAR 0 4
13035: PPUSH
13036: LD_INT 3
13038: PUSH
13039: LD_INT 54
13041: PUSH
13042: EMPTY
13043: LIST
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: PPUSH
13049: CALL_OW 72
13053: IFFALSE 13087
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13055: LD_VAR 0 4
13059: PPUSH
13060: LD_INT 3
13062: PUSH
13063: LD_INT 54
13065: PUSH
13066: EMPTY
13067: LIST
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PPUSH
13073: CALL_OW 72
13077: PPUSH
13078: LD_VAR 0 5
13082: PPUSH
13083: CALL_OW 120
// exit ;
13087: GO 13513
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13089: LD_VAR 0 4
13093: PPUSH
13094: LD_INT 54
13096: PUSH
13097: EMPTY
13098: LIST
13099: PPUSH
13100: CALL_OW 72
13104: IFFALSE 13126
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13106: LD_VAR 0 4
13110: PPUSH
13111: LD_INT 54
13113: PUSH
13114: EMPTY
13115: LIST
13116: PPUSH
13117: CALL_OW 72
13121: PPUSH
13122: CALL_OW 122
// if not tmp then
13126: LD_VAR 0 3
13130: NOT
13131: IFFALSE 13263
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13133: LD_INT 81
13135: PUSH
13136: LD_INT 3
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 92
13145: PUSH
13146: LD_INT 147
13148: PUSH
13149: LD_INT 212
13151: PUSH
13152: LD_INT 30
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PPUSH
13165: CALL_OW 69
13169: NOT
13170: IFFALSE 13263
// begin if not HasTask ( engs [ 1 ] ) then
13172: LD_VAR 0 4
13176: PUSH
13177: LD_INT 1
13179: ARRAY
13180: PPUSH
13181: CALL_OW 314
13185: NOT
13186: IFFALSE 13263
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13188: LD_ADDR_VAR 0 2
13192: PUSH
13193: LD_VAR 0 4
13197: PPUSH
13198: LD_EXP 34
13202: PUSH
13203: LD_INT 1
13205: ARRAY
13206: PPUSH
13207: LD_EXP 34
13211: PUSH
13212: LD_INT 2
13214: ARRAY
13215: PPUSH
13216: LD_EXP 34
13220: PUSH
13221: LD_INT 3
13223: ARRAY
13224: PPUSH
13225: LD_EXP 34
13229: PUSH
13230: LD_INT 4
13232: ARRAY
13233: PPUSH
13234: CALL_OW 145
13238: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13239: LD_VAR 0 2
13243: PPUSH
13244: CALL_OW 266
13248: PUSH
13249: LD_INT 4
13251: EQUAL
13252: IFFALSE 13263
// AddComUpgrade ( i ) ;
13254: LD_VAR 0 2
13258: PPUSH
13259: CALL_OW 206
// end ; end ; end ; for i in engs do
13263: LD_ADDR_VAR 0 2
13267: PUSH
13268: LD_VAR 0 4
13272: PUSH
13273: FOR_IN
13274: IFFALSE 13392
// begin if i in to_heal and sci then
13276: LD_VAR 0 2
13280: PUSH
13281: LD_VAR 0 6
13285: IN
13286: PUSH
13287: LD_VAR 0 7
13291: AND
13292: IFFALSE 13343
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13294: LD_VAR 0 2
13298: PPUSH
13299: LD_INT 149
13301: PPUSH
13302: LD_INT 220
13304: PPUSH
13305: CALL_OW 297
13309: PUSH
13310: LD_INT 5
13312: LESS
13313: IFFALSE 13317
// continue ;
13315: GO 13273
// ComMoveXY ( i , 149 , 220 ) ;
13317: LD_VAR 0 2
13321: PPUSH
13322: LD_INT 149
13324: PPUSH
13325: LD_INT 220
13327: PPUSH
13328: CALL_OW 111
// AddComHold ( i ) ;
13332: LD_VAR 0 2
13336: PPUSH
13337: CALL_OW 200
// end else
13341: GO 13390
// if not HasTask ( i ) or WantsToAttack ( i ) then
13343: LD_VAR 0 2
13347: PPUSH
13348: CALL_OW 314
13352: NOT
13353: PUSH
13354: LD_VAR 0 2
13358: PPUSH
13359: CALL_OW 319
13363: OR
13364: IFFALSE 13390
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13366: LD_VAR 0 2
13370: PPUSH
13371: LD_VAR 0 3
13375: PPUSH
13376: LD_VAR 0 2
13380: PPUSH
13381: CALL_OW 74
13385: PPUSH
13386: CALL_OW 130
// end ;
13390: GO 13273
13392: POP
13393: POP
// if to_heal and sci then
13394: LD_VAR 0 6
13398: PUSH
13399: LD_VAR 0 7
13403: AND
13404: IFFALSE 13465
// begin if UnitFilter ( sci , [ f_inside ] ) then
13406: LD_VAR 0 7
13410: PPUSH
13411: LD_INT 54
13413: PUSH
13414: EMPTY
13415: LIST
13416: PPUSH
13417: CALL_OW 72
13421: IFFALSE 13445
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13423: LD_VAR 0 7
13427: PPUSH
13428: LD_INT 54
13430: PUSH
13431: EMPTY
13432: LIST
13433: PPUSH
13434: CALL_OW 72
13438: PPUSH
13439: CALL_OW 122
13443: GO 13463
// ComHeal ( sci , to_heal [ 1 ] ) ;
13445: LD_VAR 0 7
13449: PPUSH
13450: LD_VAR 0 6
13454: PUSH
13455: LD_INT 1
13457: ARRAY
13458: PPUSH
13459: CALL_OW 128
// end else
13463: GO 13513
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13465: LD_VAR 0 7
13469: PPUSH
13470: LD_INT 56
13472: PUSH
13473: EMPTY
13474: LIST
13475: PPUSH
13476: CALL_OW 72
13480: PUSH
13481: LD_VAR 0 8
13485: AND
13486: IFFALSE 13513
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13488: LD_VAR 0 7
13492: PPUSH
13493: LD_INT 56
13495: PUSH
13496: EMPTY
13497: LIST
13498: PPUSH
13499: CALL_OW 72
13503: PPUSH
13504: LD_VAR 0 8
13508: PPUSH
13509: CALL_OW 120
// end ;
13513: PPOPN 8
13515: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13516: LD_INT 22
13518: PUSH
13519: LD_INT 3
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: PUSH
13526: LD_INT 30
13528: PUSH
13529: LD_INT 3
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: PPUSH
13540: CALL_OW 69
13544: PUSH
13545: LD_EXP 35
13549: AND
13550: IFFALSE 13676
13552: GO 13554
13554: DISABLE
13555: LD_INT 0
13557: PPUSH
13558: PPUSH
13559: PPUSH
// begin enable ;
13560: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13561: LD_ADDR_VAR 0 3
13565: PUSH
13566: LD_INT 22
13568: PUSH
13569: LD_INT 3
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 30
13578: PUSH
13579: LD_INT 3
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PPUSH
13590: CALL_OW 69
13594: PUSH
13595: LD_INT 1
13597: ARRAY
13598: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
13599: LD_VAR 0 3
13603: PPUSH
13604: CALL_OW 313
13608: PUSH
13609: LD_INT 0
13611: EQUAL
13612: IFFALSE 13616
// exit ;
13614: GO 13676
// if BuildingStatus ( fac ) = bs_idle then
13616: LD_VAR 0 3
13620: PPUSH
13621: CALL_OW 461
13625: PUSH
13626: LD_INT 2
13628: EQUAL
13629: IFFALSE 13676
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_EXP 35
13640: PUSH
13641: LD_INT 1
13643: ARRAY
13644: PPUSH
13645: LD_EXP 35
13649: PUSH
13650: LD_INT 2
13652: ARRAY
13653: PPUSH
13654: LD_EXP 35
13658: PUSH
13659: LD_INT 3
13661: ARRAY
13662: PPUSH
13663: LD_EXP 35
13667: PUSH
13668: LD_INT 4
13670: ARRAY
13671: PPUSH
13672: CALL_OW 125
// end ;
13676: PPOPN 3
13678: END
// export function PrepareAttack ( wave ) ; var i , un , tmp ; begin
13679: LD_INT 0
13681: PPUSH
13682: PPUSH
13683: PPUSH
13684: PPUSH
// uc_side := 3 ;
13685: LD_ADDR_OWVAR 20
13689: PUSH
13690: LD_INT 3
13692: ST_TO_ADDR
// uc_nation := 3 ;
13693: LD_ADDR_OWVAR 21
13697: PUSH
13698: LD_INT 3
13700: ST_TO_ADDR
// ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
13701: LD_ADDR_EXP 35
13705: PUSH
13706: LD_INT 24
13708: PUSH
13709: LD_INT 1
13711: PUSH
13712: LD_INT 3
13714: PUSH
13715: LD_INT 43
13717: PUSH
13718: EMPTY
13719: LIST
13720: LIST
13721: LIST
13722: LIST
13723: ST_TO_ADDR
// for i = 1 to Difficulty do
13724: LD_ADDR_VAR 0 3
13728: PUSH
13729: DOUBLE
13730: LD_INT 1
13732: DEC
13733: ST_TO_ADDR
13734: LD_OWVAR 67
13738: PUSH
13739: FOR_TO
13740: IFFALSE 13789
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher , ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ;
13742: LD_ADDR_EXP 35
13746: PUSH
13747: LD_EXP 35
13751: PUSH
13752: LD_INT 24
13754: PUSH
13755: LD_INT 1
13757: PUSH
13758: LD_INT 3
13760: PUSH
13761: LD_INT 45
13763: PUSH
13764: LD_INT 24
13766: PUSH
13767: LD_INT 1
13769: PUSH
13770: LD_INT 3
13772: PUSH
13773: LD_INT 46
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: ADD
13786: ST_TO_ADDR
13787: GO 13739
13789: POP
13790: POP
// repeat wait ( 0 0$1 ) ;
13791: LD_INT 35
13793: PPUSH
13794: CALL_OW 67
// until ru_produce_list < 4 ;
13798: LD_EXP 35
13802: PUSH
13803: LD_INT 4
13805: LESS
13806: IFFALSE 13791
// case wave of 1 :
13808: LD_VAR 0 1
13812: PUSH
13813: LD_INT 1
13815: DOUBLE
13816: EQUAL
13817: IFTRUE 13821
13819: GO 13906
13821: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
13822: LD_ADDR_VAR 0 3
13826: PUSH
13827: DOUBLE
13828: LD_INT 1
13830: DEC
13831: ST_TO_ADDR
13832: LD_INT 4
13834: PUSH
13835: LD_INT 5
13837: PUSH
13838: LD_INT 6
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: LIST
13845: PUSH
13846: LD_OWVAR 67
13850: ARRAY
13851: PUSH
13852: FOR_TO
13853: IFFALSE 13861
// Sold ;
13855: CALL 14031 0 0
13859: GO 13852
13861: POP
13862: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
13863: LD_ADDR_VAR 0 3
13867: PUSH
13868: DOUBLE
13869: LD_INT 1
13871: DEC
13872: ST_TO_ADDR
13873: LD_INT 2
13875: PUSH
13876: LD_INT 3
13878: PUSH
13879: LD_INT 3
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: LIST
13886: PUSH
13887: LD_OWVAR 67
13891: ARRAY
13892: PUSH
13893: FOR_TO
13894: IFFALSE 13902
// Tank ;
13896: CALL 14145 0 0
13900: GO 13893
13902: POP
13903: POP
// end ; 2 .. 9 :
13904: GO 14026
13906: LD_INT 2
13908: DOUBLE
13909: GREATEREQUAL
13910: IFFALSE 13918
13912: LD_INT 9
13914: DOUBLE
13915: LESSEQUAL
13916: IFTRUE 13920
13918: GO 14025
13920: POP
// begin for i = 1 to [ 6 , 6 , 8 ] [ Difficulty ] + ( wave div 2 ) do
13921: LD_ADDR_VAR 0 3
13925: PUSH
13926: DOUBLE
13927: LD_INT 1
13929: DEC
13930: ST_TO_ADDR
13931: LD_INT 6
13933: PUSH
13934: LD_INT 6
13936: PUSH
13937: LD_INT 8
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: LIST
13944: PUSH
13945: LD_OWVAR 67
13949: ARRAY
13950: PUSH
13951: LD_VAR 0 1
13955: PUSH
13956: LD_INT 2
13958: DIV
13959: PLUS
13960: PUSH
13961: FOR_TO
13962: IFFALSE 13970
// Sold ;
13964: CALL 14031 0 0
13968: GO 13961
13970: POP
13971: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
13972: LD_ADDR_VAR 0 3
13976: PUSH
13977: DOUBLE
13978: LD_INT 1
13980: DEC
13981: ST_TO_ADDR
13982: LD_INT 3
13984: PUSH
13985: LD_INT 4
13987: PUSH
13988: LD_INT 4
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: LIST
13995: PUSH
13996: LD_OWVAR 67
14000: ARRAY
14001: PUSH
14002: LD_VAR 0 1
14006: PUSH
14007: LD_INT 2
14009: DIV
14010: PLUS
14011: PUSH
14012: FOR_TO
14013: IFFALSE 14021
// Tank ;
14015: CALL 14145 0 0
14019: GO 14012
14021: POP
14022: POP
// end ; end ;
14023: GO 14026
14025: POP
// end ;
14026: LD_VAR 0 2
14030: RET
// function Sold ( ) ; var un , skill ; begin
14031: LD_INT 0
14033: PPUSH
14034: PPUSH
14035: PPUSH
// InitHc ;
14036: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14040: LD_ADDR_VAR 0 3
14044: PUSH
14045: LD_INT 6
14047: PUSH
14048: LD_INT 7
14050: PUSH
14051: LD_INT 7
14053: PUSH
14054: EMPTY
14055: LIST
14056: LIST
14057: LIST
14058: PUSH
14059: LD_OWVAR 67
14063: ARRAY
14064: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14065: LD_INT 0
14067: PPUSH
14068: LD_INT 1
14070: PUSH
14071: LD_INT 9
14073: PUSH
14074: EMPTY
14075: LIST
14076: LIST
14077: PUSH
14078: LD_INT 1
14080: PPUSH
14081: LD_INT 2
14083: PPUSH
14084: CALL_OW 12
14088: ARRAY
14089: PPUSH
14090: LD_VAR 0 3
14094: PPUSH
14095: CALL_OW 380
// un := CreateHuman ;
14099: LD_ADDR_VAR 0 2
14103: PUSH
14104: CALL_OW 44
14108: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14109: LD_VAR 0 2
14113: PPUSH
14114: LD_INT 4
14116: PPUSH
14117: LD_INT 0
14119: PPUSH
14120: CALL_OW 49
// ru_force := ru_force ^ un ;
14124: LD_ADDR_EXP 33
14128: PUSH
14129: LD_EXP 33
14133: PUSH
14134: LD_VAR 0 2
14138: ADD
14139: ST_TO_ADDR
// end ;
14140: LD_VAR 0 1
14144: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14145: LD_INT 0
14147: PPUSH
14148: PPUSH
14149: PPUSH
14150: PPUSH
14151: PPUSH
// InitHc ;
14152: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14156: LD_ADDR_VAR 0 5
14160: PUSH
14161: LD_INT 5
14163: PUSH
14164: LD_INT 6
14166: PUSH
14167: LD_INT 7
14169: PUSH
14170: EMPTY
14171: LIST
14172: LIST
14173: LIST
14174: PUSH
14175: LD_OWVAR 67
14179: ARRAY
14180: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14181: LD_ADDR_VAR 0 3
14185: PUSH
14186: LD_INT 22
14188: PUSH
14189: LD_INT 24
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: LD_INT 1
14198: PPUSH
14199: LD_INT 2
14201: PPUSH
14202: CALL_OW 12
14206: ARRAY
14207: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14208: LD_VAR 0 3
14212: PUSH
14213: LD_INT 22
14215: EQUAL
14216: IFFALSE 14251
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14218: LD_ADDR_VAR 0 4
14222: PUSH
14223: LD_INT 45
14225: PUSH
14226: LD_INT 43
14228: PUSH
14229: LD_INT 44
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: LIST
14236: PUSH
14237: LD_INT 1
14239: PPUSH
14240: LD_INT 3
14242: PPUSH
14243: CALL_OW 12
14247: ARRAY
14248: ST_TO_ADDR
14249: GO 14282
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14251: LD_ADDR_VAR 0 4
14255: PUSH
14256: LD_INT 46
14258: PUSH
14259: LD_INT 44
14261: PUSH
14262: LD_INT 45
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 1
14272: PPUSH
14273: LD_INT 3
14275: PPUSH
14276: CALL_OW 12
14280: ARRAY
14281: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14282: LD_ADDR_VAR 0 2
14286: PUSH
14287: LD_INT 3
14289: PPUSH
14290: LD_INT 3
14292: PPUSH
14293: LD_VAR 0 3
14297: PPUSH
14298: LD_INT 1
14300: PPUSH
14301: LD_INT 3
14303: PUSH
14304: LD_INT 3
14306: PUSH
14307: LD_INT 3
14309: PUSH
14310: LD_INT 1
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: PUSH
14319: LD_INT 1
14321: PPUSH
14322: LD_INT 4
14324: PPUSH
14325: CALL_OW 12
14329: ARRAY
14330: PPUSH
14331: LD_VAR 0 4
14335: PPUSH
14336: LD_INT 99
14338: PPUSH
14339: CALL 252 0 7
14343: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14344: LD_VAR 0 2
14348: PPUSH
14349: CALL_OW 263
14353: PUSH
14354: LD_INT 1
14356: EQUAL
14357: IFFALSE 14388
// begin PrepareHuman ( false , 3 , skill ) ;
14359: LD_INT 0
14361: PPUSH
14362: LD_INT 3
14364: PPUSH
14365: LD_VAR 0 5
14369: PPUSH
14370: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
14374: CALL_OW 44
14378: PPUSH
14379: LD_VAR 0 2
14383: PPUSH
14384: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
14388: LD_VAR 0 2
14392: PPUSH
14393: LD_INT 3
14395: PPUSH
14396: LD_INT 0
14398: PPUSH
14399: CALL_OW 49
// ru_force := ru_force ^ un ;
14403: LD_ADDR_EXP 33
14407: PUSH
14408: LD_EXP 33
14412: PUSH
14413: LD_VAR 0 2
14417: ADD
14418: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
14419: LD_VAR 0 2
14423: PPUSH
14424: LD_INT 126
14426: PPUSH
14427: LD_INT 158
14429: PPUSH
14430: CALL_OW 111
// Wait ( 0 0$3 ) ;
14434: LD_INT 105
14436: PPUSH
14437: CALL_OW 67
// ComStop ( un ) ;
14441: LD_VAR 0 2
14445: PPUSH
14446: CALL_OW 141
// end ;
14450: LD_VAR 0 1
14454: RET
// every 0 0$1 do var i , time , wave ;
14455: GO 14457
14457: DISABLE
14458: LD_INT 0
14460: PPUSH
14461: PPUSH
14462: PPUSH
// begin time := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
14463: LD_ADDR_VAR 0 2
14467: PUSH
14468: LD_INT 25200
14470: PUSH
14471: LD_INT 23100
14473: PUSH
14474: LD_INT 21000
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: LIST
14481: PUSH
14482: LD_OWVAR 67
14486: ARRAY
14487: ST_TO_ADDR
// wait ( time ) ;
14488: LD_VAR 0 2
14492: PPUSH
14493: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
14497: LD_ADDR_VAR 0 2
14501: PUSH
14502: LD_INT 17850
14504: PUSH
14505: LD_INT 16450
14507: PUSH
14508: LD_INT 15750
14510: PUSH
14511: EMPTY
14512: LIST
14513: LIST
14514: LIST
14515: PUSH
14516: LD_OWVAR 67
14520: ARRAY
14521: ST_TO_ADDR
// wave := 0 ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: LD_INT 0
14529: ST_TO_ADDR
// while true do
14530: LD_INT 1
14532: IFFALSE 14629
// begin wave := wave + 1 ;
14534: LD_ADDR_VAR 0 3
14538: PUSH
14539: LD_VAR 0 3
14543: PUSH
14544: LD_INT 1
14546: PLUS
14547: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
14548: LD_INT 22
14550: PUSH
14551: LD_INT 2
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 69
14562: IFFALSE 14591
// repeat wait ( 0 0$1 ) ;
14564: LD_INT 35
14566: PPUSH
14567: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
14571: LD_INT 22
14573: PUSH
14574: LD_INT 2
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 69
14585: PUSH
14586: LD_INT 0
14588: EQUAL
14589: IFFALSE 14564
// if ru_force < 20 then
14591: LD_EXP 33
14595: PUSH
14596: LD_INT 20
14598: LESS
14599: IFFALSE 14610
// PrepareAttack ( wave ) ;
14601: LD_VAR 0 3
14605: PPUSH
14606: CALL 13679 0 1
// ru_can_attack := true ;
14610: LD_ADDR_EXP 8
14614: PUSH
14615: LD_INT 1
14617: ST_TO_ADDR
// wait ( time ) ;
14618: LD_VAR 0 2
14622: PPUSH
14623: CALL_OW 67
// end ;
14627: GO 14530
// end ;
14629: PPOPN 3
14631: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
14632: LD_EXP 8
14636: PUSH
14637: LD_EXP 33
14641: AND
14642: IFFALSE 15384
14644: GO 14646
14646: DISABLE
14647: LD_INT 0
14649: PPUSH
14650: PPUSH
14651: PPUSH
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
// begin enable ;
14658: ENABLE
// points1 := [ 107 , 123 ] ;
14659: LD_ADDR_VAR 0 4
14663: PUSH
14664: LD_INT 107
14666: PUSH
14667: LD_INT 123
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: LD_INT 55
14681: PUSH
14682: LD_INT 42
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
14689: LD_ADDR_VAR 0 6
14693: PUSH
14694: LD_INT 102
14696: PUSH
14697: LD_INT 140
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: PUSH
14704: LD_INT 105
14706: PUSH
14707: LD_INT 142
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 129
14716: PUSH
14717: LD_INT 131
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: LIST
14728: ST_TO_ADDR
// for i in ru_force do
14729: LD_ADDR_VAR 0 1
14733: PUSH
14734: LD_EXP 33
14738: PUSH
14739: FOR_IN
14740: IFFALSE 15382
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
14742: LD_ADDR_VAR 0 3
14746: PUSH
14747: LD_INT 81
14749: PUSH
14750: LD_INT 3
14752: PUSH
14753: EMPTY
14754: LIST
14755: LIST
14756: PPUSH
14757: CALL_OW 69
14761: PPUSH
14762: LD_VAR 0 1
14766: PPUSH
14767: CALL_OW 74
14771: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 10 then
14772: LD_VAR 0 1
14776: PPUSH
14777: LD_VAR 0 3
14781: PPUSH
14782: CALL_OW 296
14786: PUSH
14787: LD_INT 10
14789: LESS
14790: IFFALSE 14935
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
14792: LD_VAR 0 1
14796: PPUSH
14797: CALL_OW 247
14801: PUSH
14802: LD_INT 1
14804: EQUAL
14805: PUSH
14806: LD_VAR 0 1
14810: PPUSH
14811: CALL_OW 257
14815: PUSH
14816: LD_INT 1
14818: EQUAL
14819: AND
14820: PUSH
14821: LD_VAR 0 3
14825: PUSH
14826: LD_INT 21
14828: PUSH
14829: LD_INT 2
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: PUSH
14836: LD_INT 58
14838: PUSH
14839: EMPTY
14840: LIST
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: PPUSH
14846: CALL_OW 69
14850: IN
14851: AND
14852: IFFALSE 14870
// ComEnterUnit ( i , un ) else
14854: LD_VAR 0 1
14858: PPUSH
14859: LD_VAR 0 3
14863: PPUSH
14864: CALL_OW 120
14868: GO 14933
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
14870: LD_VAR 0 3
14874: PUSH
14875: LD_INT 21
14877: PUSH
14878: LD_INT 2
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 58
14887: PUSH
14888: EMPTY
14889: LIST
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PPUSH
14895: CALL_OW 69
14899: IN
14900: NOT
14901: IFFALSE 14919
// ComAttackUnit ( i , un ) else
14903: LD_VAR 0 1
14907: PPUSH
14908: LD_VAR 0 3
14912: PPUSH
14913: CALL_OW 115
14917: GO 14933
// ComAttackUnit ( i , JMM ) ;
14919: LD_VAR 0 1
14923: PPUSH
14924: LD_EXP 17
14928: PPUSH
14929: CALL_OW 115
// end else
14933: GO 15380
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
14935: LD_VAR 0 1
14939: PPUSH
14940: LD_VAR 0 4
14944: PUSH
14945: LD_INT 1
14947: ARRAY
14948: PPUSH
14949: LD_VAR 0 4
14953: PUSH
14954: LD_INT 2
14956: ARRAY
14957: PPUSH
14958: CALL_OW 297
14962: PUSH
14963: LD_VAR 0 1
14967: PPUSH
14968: LD_VAR 0 5
14972: PUSH
14973: LD_INT 1
14975: ARRAY
14976: PPUSH
14977: LD_VAR 0 5
14981: PUSH
14982: LD_INT 2
14984: ARRAY
14985: PPUSH
14986: CALL_OW 297
14990: GREATER
14991: PUSH
14992: LD_EXP 9
14996: AND
14997: PUSH
14998: LD_INT 9
15000: PPUSH
15001: LD_INT 22
15003: PUSH
15004: LD_INT 1
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PPUSH
15011: CALL_OW 70
15015: PUSH
15016: LD_INT 0
15018: EQUAL
15019: OR
15020: IFFALSE 15051
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15022: LD_VAR 0 1
15026: PPUSH
15027: LD_VAR 0 5
15031: PUSH
15032: LD_INT 1
15034: ARRAY
15035: PPUSH
15036: LD_VAR 0 5
15040: PUSH
15041: LD_INT 2
15043: ARRAY
15044: PPUSH
15045: CALL_OW 114
15049: GO 15380
// begin if GetWeapon ( i ) = ru_rocket_launcher then
15051: LD_VAR 0 1
15055: PPUSH
15056: CALL_OW 264
15060: PUSH
15061: LD_INT 45
15063: EQUAL
15064: IFFALSE 15245
// begin dist := 9999 ;
15066: LD_ADDR_VAR 0 8
15070: PUSH
15071: LD_INT 9999
15073: ST_TO_ADDR
// xy := 0 ;
15074: LD_ADDR_VAR 0 9
15078: PUSH
15079: LD_INT 0
15081: ST_TO_ADDR
// for x in pointsr do
15082: LD_ADDR_VAR 0 7
15086: PUSH
15087: LD_VAR 0 6
15091: PUSH
15092: FOR_IN
15093: IFFALSE 15241
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15095: LD_VAR 0 1
15099: PPUSH
15100: LD_VAR 0 7
15104: PUSH
15105: LD_INT 1
15107: ARRAY
15108: PPUSH
15109: LD_VAR 0 7
15113: PUSH
15114: LD_INT 2
15116: ARRAY
15117: PPUSH
15118: CALL_OW 297
15122: PUSH
15123: LD_VAR 0 8
15127: LESS
15128: IFFALSE 15173
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15130: LD_ADDR_VAR 0 8
15134: PUSH
15135: LD_VAR 0 1
15139: PPUSH
15140: LD_VAR 0 7
15144: PUSH
15145: LD_INT 1
15147: ARRAY
15148: PPUSH
15149: LD_VAR 0 7
15153: PUSH
15154: LD_INT 2
15156: ARRAY
15157: PPUSH
15158: CALL_OW 297
15162: ST_TO_ADDR
// xy := x ;
15163: LD_ADDR_VAR 0 9
15167: PUSH
15168: LD_VAR 0 7
15172: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15173: LD_VAR 0 9
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_VAR 0 9
15187: PUSH
15188: LD_INT 1
15190: ARRAY
15191: PPUSH
15192: LD_VAR 0 9
15196: PUSH
15197: LD_INT 2
15199: ARRAY
15200: PPUSH
15201: CALL_OW 297
15205: PUSH
15206: LD_INT 9
15208: GREATER
15209: AND
15210: IFFALSE 15239
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15212: LD_VAR 0 1
15216: PPUSH
15217: LD_VAR 0 9
15221: PUSH
15222: LD_INT 1
15224: ARRAY
15225: PPUSH
15226: LD_VAR 0 9
15230: PUSH
15231: LD_INT 2
15233: ARRAY
15234: PPUSH
15235: CALL_OW 114
// end ;
15239: GO 15092
15241: POP
15242: POP
// end else
15243: GO 15380
// begin un := NearestUnitToUnit ( un , all_units diff un ) ;
15245: LD_ADDR_VAR 0 3
15249: PUSH
15250: LD_VAR 0 3
15254: PPUSH
15255: LD_OWVAR 3
15259: PUSH
15260: LD_VAR 0 3
15264: DIFF
15265: PPUSH
15266: CALL_OW 74
15270: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15271: LD_VAR 0 3
15275: PUSH
15276: LD_INT 21
15278: PUSH
15279: LD_INT 2
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 58
15288: PUSH
15289: EMPTY
15290: LIST
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PPUSH
15296: CALL_OW 69
15300: IN
15301: PUSH
15302: LD_VAR 0 3
15306: PUSH
15307: LD_INT 22
15309: PUSH
15310: LD_INT 3
15312: PUSH
15313: EMPTY
15314: LIST
15315: LIST
15316: PUSH
15317: LD_INT 24
15319: PUSH
15320: LD_INT 249
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: PUSH
15327: EMPTY
15328: LIST
15329: LIST
15330: PPUSH
15331: CALL_OW 69
15335: IN
15336: OR
15337: IFFALSE 15353
// ComAttackUnit ( i , un ) ;
15339: LD_VAR 0 1
15343: PPUSH
15344: LD_VAR 0 3
15348: PPUSH
15349: CALL_OW 115
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
15353: LD_VAR 0 1
15357: PPUSH
15358: LD_VAR 0 4
15362: PUSH
15363: LD_INT 1
15365: ARRAY
15366: PPUSH
15367: LD_VAR 0 4
15371: PUSH
15372: LD_INT 2
15374: ARRAY
15375: PPUSH
15376: CALL_OW 114
// end ; end ; end ; end ;
15380: GO 14739
15382: POP
15383: POP
// end ;
15384: PPOPN 9
15386: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
15387: LD_INT 22
15389: PUSH
15390: LD_INT 3
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: PUSH
15397: LD_INT 32
15399: PUSH
15400: LD_INT 1
15402: PUSH
15403: EMPTY
15404: LIST
15405: LIST
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PPUSH
15411: CALL_OW 69
15415: IFFALSE 15503
15417: GO 15419
15419: DISABLE
15420: LD_INT 0
15422: PPUSH
15423: PPUSH
// begin enable ;
15424: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
15425: LD_ADDR_VAR 0 2
15429: PUSH
15430: LD_INT 22
15432: PUSH
15433: LD_INT 3
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: PUSH
15440: LD_INT 32
15442: PUSH
15443: LD_INT 1
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PPUSH
15454: CALL_OW 69
15458: ST_TO_ADDR
// for i in tmp do
15459: LD_ADDR_VAR 0 1
15463: PUSH
15464: LD_VAR 0 2
15468: PUSH
15469: FOR_IN
15470: IFFALSE 15501
// if GetFuel ( i ) < 12 then
15472: LD_VAR 0 1
15476: PPUSH
15477: CALL_OW 261
15481: PUSH
15482: LD_INT 12
15484: LESS
15485: IFFALSE 15499
// SetFuel ( i , 12 ) ;
15487: LD_VAR 0 1
15491: PPUSH
15492: LD_INT 12
15494: PPUSH
15495: CALL_OW 240
15499: GO 15469
15501: POP
15502: POP
// end ;
15503: PPOPN 2
15505: END
