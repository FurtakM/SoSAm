// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 37 0 0
// DebugMode ;
   8: CALL 165 0 0
// PrepareNature ;
  12: CALL 340 0 0
// PrepareRussian ;
  16: CALL 11945 0 0
// PrepareAmerican ;
  20: CALL 1053 0 0
// PrepareOvsyenko ;
  24: CALL 1697 0 0
// Action ;
  28: CALL 2555 0 0
// SaveForQuickRestart ;
  32: CALL_OW 22
// end ;
  36: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar ; function Init ; begin
  37: LD_INT 0
  39: PPUSH
// debug := false ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  48: LD_ADDR_EXP 4
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// mission_prefix := 09_ ;
  56: LD_ADDR_EXP 1
  60: PUSH
  61: LD_STRING 09_
  63: ST_TO_ADDR
// powell_want_sib := false ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  72: LD_ADDR_EXP 6
  76: PUSH
  77: LD_INT 31500
  79: ST_TO_ADDR
// game_time := 47 47$00 ;
  80: LD_ADDR_EXP 7
  84: PUSH
  85: LD_INT 98700
  87: ST_TO_ADDR
// ru_can_attack := false ;
  88: LD_ADDR_EXP 8
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// ru_can_attack_terminal := false ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// ar_can_arrive := false ;
 104: LD_ADDR_EXP 10
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ar_spawned := false ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// player_want_mortar := false ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// player_want_info := false ;
 128: LD_ADDR_EXP 13
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// player_get_mortar := false ;
 136: LD_ADDR_EXP 14
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// player_get_info := false ;
 144: LD_ADDR_EXP 15
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// player_attacked_ar := false ;
 152: LD_ADDR_EXP 16
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// end ;
 160: LD_VAR 0 1
 164: RET
// function DebugMode ; begin
 165: LD_INT 0
 167: PPUSH
// if not debug then
 168: LD_EXP 2
 172: NOT
 173: IFFALSE 177
// exit ;
 175: GO 184
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 222
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 199: LD_ADDR_VAR 0 5
 203: PUSH
 204: LD_VAR 0 3
 208: PUSH
 209: LD_VAR 0 1
 213: STR
 214: PPUSH
 215: CALL_OW 34
 219: ST_TO_ADDR
 220: GO 237
// unit := NewCharacter ( ident ) ;
 222: LD_ADDR_VAR 0 5
 226: PUSH
 227: LD_VAR 0 1
 231: PPUSH
 232: CALL_OW 25
 236: ST_TO_ADDR
// result := unit ;
 237: LD_ADDR_VAR 0 4
 241: PUSH
 242: LD_VAR 0 5
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 4
 251: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 252: LD_INT 0
 254: PPUSH
// uc_side := side ;
 255: LD_ADDR_OWVAR 20
 259: PUSH
 260: LD_VAR 0 1
 264: ST_TO_ADDR
// uc_nation := nation ;
 265: LD_ADDR_OWVAR 21
 269: PUSH
 270: LD_VAR 0 2
 274: ST_TO_ADDR
// vc_chassis := chassis ;
 275: LD_ADDR_OWVAR 37
 279: PUSH
 280: LD_VAR 0 3
 284: ST_TO_ADDR
// vc_engine := engine ;
 285: LD_ADDR_OWVAR 39
 289: PUSH
 290: LD_VAR 0 4
 294: ST_TO_ADDR
// vc_control := control ;
 295: LD_ADDR_OWVAR 38
 299: PUSH
 300: LD_VAR 0 5
 304: ST_TO_ADDR
// vc_weapon := weapon ;
 305: LD_ADDR_OWVAR 40
 309: PUSH
 310: LD_VAR 0 6
 314: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 315: LD_ADDR_OWVAR 41
 319: PUSH
 320: LD_VAR 0 7
 324: ST_TO_ADDR
// result := CreateVehicle ;
 325: LD_ADDR_VAR 0 8
 329: PUSH
 330: CALL_OW 45
 334: ST_TO_ADDR
// end ;
 335: LD_VAR 0 8
 339: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 340: LD_INT 0
 342: PPUSH
 343: PPUSH
 344: PPUSH
 345: PPUSH
// uc_side = 0 ;
 346: LD_ADDR_OWVAR 20
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// uc_nation = 0 ;
 354: LD_ADDR_OWVAR 21
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// nat_area := natureArea ;
 362: LD_ADDR_VAR 0 4
 366: PUSH
 367: LD_INT 1
 369: ST_TO_ADDR
// InitHc ;
 370: CALL_OW 19
// for i = 1 to 4 do
 374: LD_ADDR_VAR 0 2
 378: PUSH
 379: DOUBLE
 380: LD_INT 1
 382: DEC
 383: ST_TO_ADDR
 384: LD_INT 4
 386: PUSH
 387: FOR_TO
 388: IFFALSE 443
// begin hc_class = 18 ;
 390: LD_ADDR_OWVAR 28
 394: PUSH
 395: LD_INT 18
 397: ST_TO_ADDR
// hc_gallery =  ;
 398: LD_ADDR_OWVAR 33
 402: PUSH
 403: LD_STRING 
 405: ST_TO_ADDR
// hc_face_number = 1 ;
 406: LD_ADDR_OWVAR 34
 410: PUSH
 411: LD_INT 1
 413: ST_TO_ADDR
// animal := CreateHuman ;
 414: LD_ADDR_VAR 0 3
 418: PUSH
 419: CALL_OW 44
 423: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 424: LD_VAR 0 3
 428: PPUSH
 429: LD_VAR 0 4
 433: PPUSH
 434: LD_INT 0
 436: PPUSH
 437: CALL_OW 49
// end ;
 441: GO 387
 443: POP
 444: POP
// for i = 1 to 4 do
 445: LD_ADDR_VAR 0 2
 449: PUSH
 450: DOUBLE
 451: LD_INT 1
 453: DEC
 454: ST_TO_ADDR
 455: LD_INT 4
 457: PUSH
 458: FOR_TO
 459: IFFALSE 530
// begin hc_class = class_tiger ;
 461: LD_ADDR_OWVAR 28
 465: PUSH
 466: LD_INT 14
 468: ST_TO_ADDR
// hc_gallery =  ;
 469: LD_ADDR_OWVAR 33
 473: PUSH
 474: LD_STRING 
 476: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
 477: LD_ADDR_OWVAR 35
 481: PUSH
 482: LD_INT 0
 484: PPUSH
 485: LD_INT 50
 487: PPUSH
 488: CALL_OW 12
 492: ST_TO_ADDR
// hc_face_number = 3 ;
 493: LD_ADDR_OWVAR 34
 497: PUSH
 498: LD_INT 3
 500: ST_TO_ADDR
// animal := CreateHuman ;
 501: LD_ADDR_VAR 0 3
 505: PUSH
 506: CALL_OW 44
 510: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 511: LD_VAR 0 3
 515: PPUSH
 516: LD_VAR 0 4
 520: PPUSH
 521: LD_INT 0
 523: PPUSH
 524: CALL_OW 49
// end ;
 528: GO 458
 530: POP
 531: POP
// for i = 1 to 6 do
 532: LD_ADDR_VAR 0 2
 536: PUSH
 537: DOUBLE
 538: LD_INT 1
 540: DEC
 541: ST_TO_ADDR
 542: LD_INT 6
 544: PUSH
 545: FOR_TO
 546: IFFALSE 610
// begin hc_class = class_apeman ;
 548: LD_ADDR_OWVAR 28
 552: PUSH
 553: LD_INT 12
 555: ST_TO_ADDR
// hc_gallery =  ;
 556: LD_ADDR_OWVAR 33
 560: PUSH
 561: LD_STRING 
 563: ST_TO_ADDR
// hc_agressivity = rand ( - 10 , 10 ) ;
 564: LD_ADDR_OWVAR 35
 568: PUSH
 569: LD_INT 10
 571: NEG
 572: PPUSH
 573: LD_INT 10
 575: PPUSH
 576: CALL_OW 12
 580: ST_TO_ADDR
// animal := CreateHuman ;
 581: LD_ADDR_VAR 0 3
 585: PUSH
 586: CALL_OW 44
 590: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 591: LD_VAR 0 3
 595: PPUSH
 596: LD_VAR 0 4
 600: PPUSH
 601: LD_INT 0
 603: PPUSH
 604: CALL_OW 49
// end ;
 608: GO 545
 610: POP
 611: POP
// for i = 1 to 6 do
 612: LD_ADDR_VAR 0 2
 616: PUSH
 617: DOUBLE
 618: LD_INT 1
 620: DEC
 621: ST_TO_ADDR
 622: LD_INT 6
 624: PUSH
 625: FOR_TO
 626: IFFALSE 681
// begin hc_class = 13 ;
 628: LD_ADDR_OWVAR 28
 632: PUSH
 633: LD_INT 13
 635: ST_TO_ADDR
// hc_gallery =  ;
 636: LD_ADDR_OWVAR 33
 640: PUSH
 641: LD_STRING 
 643: ST_TO_ADDR
// hc_face_number = 4 ;
 644: LD_ADDR_OWVAR 34
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// animal := CreateHuman ;
 652: LD_ADDR_VAR 0 3
 656: PUSH
 657: CALL_OW 44
 661: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 662: LD_VAR 0 3
 666: PPUSH
 667: LD_VAR 0 4
 671: PPUSH
 672: LD_INT 0
 674: PPUSH
 675: CALL_OW 49
// end ;
 679: GO 625
 681: POP
 682: POP
// for i = 1 to 1 do
 683: LD_ADDR_VAR 0 2
 687: PUSH
 688: DOUBLE
 689: LD_INT 1
 691: DEC
 692: ST_TO_ADDR
 693: LD_INT 1
 695: PUSH
 696: FOR_TO
 697: IFFALSE 745
// begin vc_chassis := 31 ;
 699: LD_ADDR_OWVAR 37
 703: PUSH
 704: LD_INT 31
 706: ST_TO_ADDR
// vc_control := control_rider ;
 707: LD_ADDR_OWVAR 38
 711: PUSH
 712: LD_INT 4
 714: ST_TO_ADDR
// animal := CreateVehicle ;
 715: LD_ADDR_VAR 0 3
 719: PUSH
 720: CALL_OW 45
 724: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 725: LD_VAR 0 3
 729: PPUSH
 730: LD_INT 21
 732: PPUSH
 733: LD_INT 22
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 48
// end ;
 743: GO 696
 745: POP
 746: POP
// end ;
 747: LD_VAR 0 1
 751: RET
// export function GetTerminalCargo ; begin
 752: LD_INT 0
 754: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 755: LD_ADDR_VAR 0 1
 759: PUSH
 760: LD_EXP 3
 764: PPUSH
 765: CALL_OW 274
 769: PPUSH
 770: LD_INT 3
 772: PPUSH
 773: CALL_OW 275
 777: ST_TO_ADDR
// end ;
 778: LD_VAR 0 1
 782: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 783: LD_INT 0
 785: PPUSH
 786: PPUSH
 787: PPUSH
// result := 0 ;
 788: LD_ADDR_VAR 0 2
 792: PUSH
 793: LD_INT 0
 795: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 796: LD_ADDR_VAR 0 4
 800: PUSH
 801: LD_INT 22
 803: PUSH
 804: LD_VAR 0 1
 808: PUSH
 809: EMPTY
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 2
 815: PUSH
 816: LD_INT 30
 818: PUSH
 819: LD_INT 0
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PUSH
 826: LD_INT 30
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: EMPTY
 833: LIST
 834: LIST
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PPUSH
 845: CALL_OW 69
 849: ST_TO_ADDR
// if not tmp then
 850: LD_VAR 0 4
 854: NOT
 855: IFFALSE 859
// exit ;
 857: GO 905
// for i in tmp do
 859: LD_ADDR_VAR 0 3
 863: PUSH
 864: LD_VAR 0 4
 868: PUSH
 869: FOR_IN
 870: IFFALSE 903
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 872: LD_ADDR_VAR 0 2
 876: PUSH
 877: LD_VAR 0 2
 881: PUSH
 882: LD_VAR 0 3
 886: PPUSH
 887: CALL_OW 274
 891: PPUSH
 892: LD_INT 3
 894: PPUSH
 895: CALL_OW 275
 899: PLUS
 900: ST_TO_ADDR
 901: GO 869
 903: POP
 904: POP
// end ;
 905: LD_VAR 0 2
 909: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 910: LD_INT 0
 912: PPUSH
 913: PPUSH
// area = ListEnvironmentArea ( area ) ;
 914: LD_ADDR_VAR 0 2
 918: PUSH
 919: LD_VAR 0 2
 923: PPUSH
 924: CALL_OW 353
 928: ST_TO_ADDR
// if bulldozer > 0 then
 929: LD_VAR 0 1
 933: PUSH
 934: LD_INT 0
 936: GREATER
 937: IFFALSE 1048
// for i = area downto 1 do
 939: LD_ADDR_VAR 0 4
 943: PUSH
 944: DOUBLE
 945: LD_VAR 0 2
 949: INC
 950: ST_TO_ADDR
 951: LD_INT 1
 953: PUSH
 954: FOR_DOWNTO
 955: IFFALSE 1046
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 957: LD_VAR 0 2
 961: PUSH
 962: LD_VAR 0 4
 966: ARRAY
 967: PUSH
 968: LD_INT 1
 970: ARRAY
 971: PPUSH
 972: LD_VAR 0 2
 976: PUSH
 977: LD_VAR 0 4
 981: ARRAY
 982: PUSH
 983: LD_INT 2
 985: ARRAY
 986: PPUSH
 987: CALL_OW 351
 991: IFFALSE 1044
// if not HasTask ( bulldozer ) then
 993: LD_VAR 0 1
 997: PPUSH
 998: CALL_OW 314
1002: NOT
1003: IFFALSE 1044
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1005: LD_VAR 0 1
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_VAR 0 4
1019: ARRAY
1020: PUSH
1021: LD_INT 1
1023: ARRAY
1024: PPUSH
1025: LD_VAR 0 2
1029: PUSH
1030: LD_VAR 0 4
1034: ARRAY
1035: PUSH
1036: LD_INT 2
1038: ARRAY
1039: PPUSH
1040: CALL_OW 171
1044: GO 954
1046: POP
1047: POP
// end ; end_of_file
1048: LD_VAR 0 3
1052: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1053: LD_INT 0
1055: PPUSH
1056: PPUSH
1057: PPUSH
1058: PPUSH
1059: PPUSH
// uc_side := 1 ;
1060: LD_ADDR_OWVAR 20
1064: PUSH
1065: LD_INT 1
1067: ST_TO_ADDR
// uc_nation := 1 ;
1068: LD_ADDR_OWVAR 21
1072: PUSH
1073: LD_INT 1
1075: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1076: LD_ADDR_EXP 17
1080: PUSH
1081: LD_STRING JMM
1083: PPUSH
1084: LD_EXP 2
1088: NOT
1089: PPUSH
1090: LD_STRING 08_
1092: PPUSH
1093: CALL 189 0 3
1097: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1098: LD_ADDR_VAR 0 4
1102: PUSH
1103: LD_INT 1
1105: PPUSH
1106: LD_INT 1
1108: PPUSH
1109: LD_INT 3
1111: PPUSH
1112: LD_INT 2
1114: PPUSH
1115: LD_INT 1
1117: PPUSH
1118: LD_INT 5
1120: PPUSH
1121: LD_INT 55
1123: PPUSH
1124: CALL 252 0 7
1128: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1129: LD_VAR 0 4
1133: PPUSH
1134: LD_INT 3
1136: PPUSH
1137: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1141: LD_VAR 0 4
1145: PPUSH
1146: LD_INT 43
1148: PPUSH
1149: LD_INT 3
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1159: LD_EXP 17
1163: PPUSH
1164: LD_VAR 0 4
1168: PPUSH
1169: CALL_OW 52
// tmp := [ ] ;
1173: LD_ADDR_VAR 0 2
1177: PUSH
1178: EMPTY
1179: ST_TO_ADDR
// uc_side := 4 ;
1180: LD_ADDR_OWVAR 20
1184: PUSH
1185: LD_INT 4
1187: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1188: LD_ADDR_OWVAR 33
1192: PUSH
1193: LD_STRING SecondCharsGal
1195: ST_TO_ADDR
// hc_class := 2 ;
1196: LD_ADDR_OWVAR 28
1200: PUSH
1201: LD_INT 2
1203: ST_TO_ADDR
// hc_sex := sex_female ;
1204: LD_ADDR_OWVAR 27
1208: PUSH
1209: LD_INT 2
1211: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1212: LD_ADDR_OWVAR 30
1216: PUSH
1217: LD_INT 0
1219: PUSH
1220: LD_INT 1
1222: PUSH
1223: LD_INT 1
1225: PUSH
1226: LD_INT 0
1228: PUSH
1229: EMPTY
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1235: LD_ADDR_OWVAR 31
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 4
1245: PUSH
1246: LD_INT 2
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1258: LD_ADDR_OWVAR 29
1262: PUSH
1263: LD_INT 10
1265: PUSH
1266: LD_INT 11
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1273: LD_ADDR_OWVAR 26
1277: PUSH
1278: LD_STRING Naoma Goichman
1280: ST_TO_ADDR
// hc_face_number := 43 ;
1281: LD_ADDR_OWVAR 34
1285: PUSH
1286: LD_INT 43
1288: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1289: LD_ADDR_VAR 0 2
1293: PUSH
1294: LD_VAR 0 2
1298: PUSH
1299: CALL_OW 44
1303: ADD
1304: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1305: LD_ADDR_OWVAR 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 2
1315: PUSH
1316: LD_INT 0
1318: PUSH
1319: LD_INT 1
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1328: LD_ADDR_OWVAR 31
1332: PUSH
1333: LD_INT 0
1335: PUSH
1336: LD_INT 5
1338: PUSH
1339: LD_INT 3
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1351: LD_ADDR_OWVAR 29
1355: PUSH
1356: LD_INT 10
1358: PUSH
1359: LD_INT 10
1361: PUSH
1362: EMPTY
1363: LIST
1364: LIST
1365: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1366: LD_ADDR_OWVAR 26
1370: PUSH
1371: LD_STRING Magdalene Glance
1373: ST_TO_ADDR
// hc_face_number := 44 ;
1374: LD_ADDR_OWVAR 34
1378: PUSH
1379: LD_INT 44
1381: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1382: LD_ADDR_VAR 0 2
1386: PUSH
1387: LD_VAR 0 2
1391: PUSH
1392: CALL_OW 44
1396: ADD
1397: ST_TO_ADDR
// hc_sex := sex_male ;
1398: LD_ADDR_OWVAR 27
1402: PUSH
1403: LD_INT 1
1405: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1406: LD_ADDR_OWVAR 30
1410: PUSH
1411: LD_INT 2
1413: PUSH
1414: LD_INT 2
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: LD_INT 0
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1429: LD_ADDR_OWVAR 31
1433: PUSH
1434: LD_INT 3
1436: PUSH
1437: LD_INT 4
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: LD_INT 0
1445: PUSH
1446: EMPTY
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1452: LD_ADDR_OWVAR 29
1456: PUSH
1457: LD_INT 12
1459: PUSH
1460: LD_INT 10
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: ST_TO_ADDR
// hc_name := Steve Holland ;
1467: LD_ADDR_OWVAR 26
1471: PUSH
1472: LD_STRING Steve Holland
1474: ST_TO_ADDR
// hc_face_number := 60 ;
1475: LD_ADDR_OWVAR 34
1479: PUSH
1480: LD_INT 60
1482: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1483: LD_ADDR_VAR 0 2
1487: PUSH
1488: LD_VAR 0 2
1492: PUSH
1493: CALL_OW 44
1497: ADD
1498: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1499: LD_ADDR_EXP 22
1503: PUSH
1504: LD_VAR 0 2
1508: PUSH
1509: LD_INT 0
1511: DIFF
1512: ST_TO_ADDR
// for un in alpha_engs do
1513: LD_ADDR_VAR 0 3
1517: PUSH
1518: LD_EXP 22
1522: PUSH
1523: FOR_IN
1524: IFFALSE 1549
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1526: LD_VAR 0 3
1530: PPUSH
1531: LD_INT 52
1533: PPUSH
1534: LD_INT 35
1536: PPUSH
1537: LD_INT 3
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 50
1547: GO 1523
1549: POP
1550: POP
// for tmp = 1 to 4 do
1551: LD_ADDR_VAR 0 2
1555: PUSH
1556: DOUBLE
1557: LD_INT 1
1559: DEC
1560: ST_TO_ADDR
1561: LD_INT 4
1563: PUSH
1564: FOR_TO
1565: IFFALSE 1591
// CreateResourcesXYR ( mat_cans , 5 , 54 , 40 , 2 , false ) ;
1567: LD_INT 1
1569: PPUSH
1570: LD_INT 5
1572: PPUSH
1573: LD_INT 54
1575: PPUSH
1576: LD_INT 40
1578: PPUSH
1579: LD_INT 2
1581: PPUSH
1582: LD_INT 0
1584: PPUSH
1585: CALL_OW 60
1589: GO 1564
1591: POP
1592: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1593: LD_STRING gamma_commander
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: PUSH
1604: LD_INT 3
1606: LESS
1607: IFFALSE 1665
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1609: LD_ADDR_EXP 21
1613: PUSH
1614: LD_STRING VanHouten
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: LD_STRING 
1622: PPUSH
1623: CALL 189 0 3
1627: ST_TO_ADDR
// for i = 1 to 4 do
1628: LD_ADDR_VAR 0 5
1632: PUSH
1633: DOUBLE
1634: LD_INT 1
1636: DEC
1637: ST_TO_ADDR
1638: LD_INT 4
1640: PUSH
1641: FOR_TO
1642: IFFALSE 1663
// AddExperience ( Houten , i , 10000 ) ;
1644: LD_EXP 21
1648: PPUSH
1649: LD_VAR 0 5
1653: PPUSH
1654: LD_INT 10000
1656: PPUSH
1657: CALL_OW 492
1661: GO 1641
1663: POP
1664: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1665: LD_ADDR_EXP 24
1669: PUSH
1670: LD_STRING Powell
1672: PPUSH
1673: LD_INT 0
1675: PPUSH
1676: LD_STRING 
1678: PPUSH
1679: CALL 189 0 3
1683: ST_TO_ADDR
// InitHc ;
1684: CALL_OW 19
// InitUc ;
1688: CALL_OW 18
// end ;
1692: LD_VAR 0 1
1696: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1697: LD_INT 0
1699: PPUSH
1700: PPUSH
1701: PPUSH
1702: PPUSH
1703: PPUSH
// uc_side := 4 ;
1704: LD_ADDR_OWVAR 20
1708: PUSH
1709: LD_INT 4
1711: ST_TO_ADDR
// uc_nation := 3 ;
1712: LD_ADDR_OWVAR 21
1716: PUSH
1717: LD_INT 3
1719: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 ] , [ b_breastwork , 109 , 114 , 4 ] , [ b_breastwork , 115 , 132 , 5 ] , [ b_breastwork , 98 , 120 , 1 ] ] ) ;
1720: LD_ADDR_VAR 0 4
1724: PUSH
1725: LD_STRING 09_ovsyenko_base
1727: PPUSH
1728: LD_INT 0
1730: PUSH
1731: LD_INT 101
1733: PUSH
1734: LD_INT 118
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: PUSH
1746: LD_INT 31
1748: PUSH
1749: LD_INT 109
1751: PUSH
1752: LD_INT 114
1754: PUSH
1755: LD_INT 4
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_INT 31
1766: PUSH
1767: LD_INT 115
1769: PUSH
1770: LD_INT 132
1772: PUSH
1773: LD_INT 5
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: PUSH
1782: LD_INT 31
1784: PUSH
1785: LD_INT 98
1787: PUSH
1788: LD_INT 120
1790: PUSH
1791: LD_INT 1
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: LIST
1804: LIST
1805: PPUSH
1806: CALL_OW 30
1810: ST_TO_ADDR
// for i in tmp do
1811: LD_ADDR_VAR 0 2
1815: PUSH
1816: LD_VAR 0 4
1820: PUSH
1821: FOR_IN
1822: IFFALSE 1978
// begin bc_type := i [ 1 ] ;
1824: LD_ADDR_OWVAR 42
1828: PUSH
1829: LD_VAR 0 2
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: ST_TO_ADDR
// bc_level := 3 ;
1838: LD_ADDR_OWVAR 43
1842: PUSH
1843: LD_INT 3
1845: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1846: LD_ADDR_VAR 0 3
1850: PUSH
1851: LD_VAR 0 2
1855: PUSH
1856: LD_INT 2
1858: ARRAY
1859: PPUSH
1860: LD_VAR 0 2
1864: PUSH
1865: LD_INT 3
1867: ARRAY
1868: PPUSH
1869: LD_VAR 0 2
1873: PUSH
1874: LD_INT 4
1876: ARRAY
1877: PPUSH
1878: CALL_OW 47
1882: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1883: LD_VAR 0 3
1887: PPUSH
1888: CALL_OW 266
1892: PUSH
1893: LD_INT 0
1895: EQUAL
1896: IFFALSE 1930
// begin SetBName ( b , ovsyenko ) ;
1898: LD_VAR 0 3
1902: PPUSH
1903: LD_STRING ovsyenko
1905: PPUSH
1906: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 274
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 277
// end ; if i [ 4 ] < 250 then
1930: LD_VAR 0 2
1934: PUSH
1935: LD_INT 4
1937: ARRAY
1938: PUSH
1939: LD_INT 250
1941: LESS
1942: IFFALSE 1958
// SetLives ( b , 251 ) else
1944: LD_VAR 0 3
1948: PPUSH
1949: LD_INT 251
1951: PPUSH
1952: CALL_OW 234
1956: GO 1976
// SetLives ( b , i [ 4 ] ) ;
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 2
1967: PUSH
1968: LD_INT 4
1970: ARRAY
1971: PPUSH
1972: CALL_OW 234
// end ;
1976: GO 1821
1978: POP
1979: POP
// uc_nation := 1 ;
1980: LD_ADDR_OWVAR 21
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// tmp := [ ] ;
1988: LD_ADDR_VAR 0 4
1992: PUSH
1993: EMPTY
1994: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
1995: LD_ADDR_EXP 18
1999: PUSH
2000: LD_STRING Gary
2002: PPUSH
2003: LD_EXP 2
2007: NOT
2008: PPUSH
2009: LD_STRING 
2011: PPUSH
2012: CALL 189 0 3
2016: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2017: LD_ADDR_VAR 0 4
2021: PUSH
2022: LD_VAR 0 4
2026: PUSH
2027: LD_EXP 18
2031: ADD
2032: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2033: LD_ADDR_EXP 19
2037: PUSH
2038: LD_STRING Bobby
2040: PPUSH
2041: LD_EXP 2
2045: NOT
2046: PPUSH
2047: LD_STRING 03_
2049: PPUSH
2050: CALL 189 0 3
2054: ST_TO_ADDR
// if Bobby then
2055: LD_EXP 19
2059: IFFALSE 2077
// tmp := tmp ^ Bobby ;
2061: LD_ADDR_VAR 0 4
2065: PUSH
2066: LD_VAR 0 4
2070: PUSH
2071: LD_EXP 19
2075: ADD
2076: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2077: LD_ADDR_EXP 20
2081: PUSH
2082: LD_STRING Cyrus
2084: PPUSH
2085: LD_EXP 2
2089: NOT
2090: PPUSH
2091: LD_STRING 03_
2093: PPUSH
2094: CALL 189 0 3
2098: ST_TO_ADDR
// if Cyrus then
2099: LD_EXP 20
2103: IFFALSE 2121
// tmp := tmp ^ Cyrus ;
2105: LD_ADDR_VAR 0 4
2109: PUSH
2110: LD_VAR 0 4
2114: PUSH
2115: LD_EXP 20
2119: ADD
2120: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2121: LD_ADDR_VAR 0 4
2125: PUSH
2126: LD_VAR 0 4
2130: PUSH
2131: LD_STRING 09_prev_squad
2133: PPUSH
2134: CALL_OW 31
2138: ADD
2139: ST_TO_ADDR
// tmp := tmp diff 0 ;
2140: LD_ADDR_VAR 0 4
2144: PUSH
2145: LD_VAR 0 4
2149: PUSH
2150: LD_INT 0
2152: DIFF
2153: ST_TO_ADDR
// if tmp < 4 then
2154: LD_VAR 0 4
2158: PUSH
2159: LD_INT 4
2161: LESS
2162: IFFALSE 2242
// begin for i = 1 to 3 do
2164: LD_ADDR_VAR 0 2
2168: PUSH
2169: DOUBLE
2170: LD_INT 1
2172: DEC
2173: ST_TO_ADDR
2174: LD_INT 3
2176: PUSH
2177: FOR_TO
2178: IFFALSE 2211
// begin PrepareHuman ( false , 1 , 5 ) ;
2180: LD_INT 0
2182: PPUSH
2183: LD_INT 1
2185: PPUSH
2186: LD_INT 5
2188: PPUSH
2189: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2193: LD_ADDR_VAR 0 4
2197: PUSH
2198: LD_VAR 0 4
2202: PUSH
2203: CALL_OW 44
2207: ADD
2208: ST_TO_ADDR
// end ;
2209: GO 2177
2211: POP
2212: POP
// PrepareHuman ( false , 4 , 5 ) ;
2213: LD_INT 0
2215: PPUSH
2216: LD_INT 4
2218: PPUSH
2219: LD_INT 5
2221: PPUSH
2222: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2226: LD_ADDR_VAR 0 4
2230: PUSH
2231: LD_VAR 0 4
2235: PUSH
2236: CALL_OW 44
2240: ADD
2241: ST_TO_ADDR
// end ; for i in tmp do
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: LD_VAR 0 4
2251: PUSH
2252: FOR_IN
2253: IFFALSE 2278
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2255: LD_VAR 0 2
2259: PPUSH
2260: LD_INT 106
2262: PPUSH
2263: LD_INT 122
2265: PPUSH
2266: LD_INT 5
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 50
2276: GO 2252
2278: POP
2279: POP
// tmp := tmp diff Gary ;
2280: LD_ADDR_VAR 0 4
2284: PUSH
2285: LD_VAR 0 4
2289: PUSH
2290: LD_EXP 18
2294: DIFF
2295: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2296: LD_ADDR_VAR 0 3
2300: PUSH
2301: LD_INT 22
2303: PUSH
2304: LD_INT 4
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: LD_INT 30
2313: PUSH
2314: LD_INT 31
2316: PUSH
2317: EMPTY
2318: LIST
2319: LIST
2320: PUSH
2321: EMPTY
2322: LIST
2323: LIST
2324: PPUSH
2325: CALL_OW 69
2329: ST_TO_ADDR
// for i = 1 to b do
2330: LD_ADDR_VAR 0 2
2334: PUSH
2335: DOUBLE
2336: LD_INT 1
2338: DEC
2339: ST_TO_ADDR
2340: LD_VAR 0 3
2344: PUSH
2345: FOR_TO
2346: IFFALSE 2376
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2348: LD_VAR 0 4
2352: PUSH
2353: LD_VAR 0 2
2357: ARRAY
2358: PPUSH
2359: LD_VAR 0 3
2363: PUSH
2364: LD_VAR 0 2
2368: ARRAY
2369: PPUSH
2370: CALL_OW 120
// end ;
2374: GO 2345
2376: POP
2377: POP
// InitHc ;
2378: CALL_OW 19
// InitUc ;
2382: CALL_OW 18
// end ;
2386: LD_VAR 0 1
2390: RET
// export function PowellTransport ; var i , un ; begin
2391: LD_INT 0
2393: PPUSH
2394: PPUSH
2395: PPUSH
// uc_side := 4 ;
2396: LD_ADDR_OWVAR 20
2400: PUSH
2401: LD_INT 4
2403: ST_TO_ADDR
// uc_nation := 1 ;
2404: LD_ADDR_OWVAR 21
2408: PUSH
2409: LD_INT 1
2411: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2412: LD_INT 1
2414: PPUSH
2415: LD_INT 3
2417: PPUSH
2418: LD_INT 6
2420: PPUSH
2421: CALL_OW 380
// hc_name :=  ;
2425: LD_ADDR_OWVAR 26
2429: PUSH
2430: LD_STRING 
2432: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2433: LD_ADDR_OWVAR 33
2437: PUSH
2438: LD_STRING SecondCharsGal
2440: ST_TO_ADDR
// hc_face_number := 30 ;
2441: LD_ADDR_OWVAR 34
2445: PUSH
2446: LD_INT 30
2448: ST_TO_ADDR
// powell_trans := CreateHuman ;
2449: LD_ADDR_EXP 23
2453: PUSH
2454: CALL_OW 44
2458: ST_TO_ADDR
// hc_face_number := 31 ;
2459: LD_ADDR_OWVAR 34
2463: PUSH
2464: LD_INT 31
2466: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2467: LD_ADDR_EXP 23
2471: PUSH
2472: LD_EXP 23
2476: PUSH
2477: CALL_OW 44
2481: ADD
2482: ST_TO_ADDR
// for i = 1 to 2 do
2483: LD_ADDR_VAR 0 2
2487: PUSH
2488: DOUBLE
2489: LD_INT 1
2491: DEC
2492: ST_TO_ADDR
2493: LD_INT 2
2495: PUSH
2496: FOR_TO
2497: IFFALSE 2548
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2499: LD_ADDR_VAR 0 3
2503: PUSH
2504: LD_INT 4
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: LD_INT 3
2512: PPUSH
2513: LD_INT 1
2515: PPUSH
2516: LD_INT 1
2518: PPUSH
2519: LD_INT 12
2521: PPUSH
2522: LD_INT 66
2524: PPUSH
2525: CALL 252 0 7
2529: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2530: LD_ADDR_EXP 23
2534: PUSH
2535: LD_EXP 23
2539: PUSH
2540: LD_VAR 0 3
2544: ADD
2545: ST_TO_ADDR
// end ;
2546: GO 2496
2548: POP
2549: POP
// end ; end_of_file
2550: LD_VAR 0 1
2554: RET
// export function Action ; var i , veh ; begin
2555: LD_INT 0
2557: PPUSH
2558: PPUSH
2559: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2560: LD_EXP 22
2564: PPUSH
2565: LD_INT 0
2567: PPUSH
2568: LD_INT 50
2570: PPUSH
2571: LD_INT 38
2573: PPUSH
2574: LD_INT 2
2576: PPUSH
2577: CALL_OW 145
// InGameOn ;
2581: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2585: LD_INT 43
2587: PPUSH
2588: LD_INT 9
2590: PPUSH
2591: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2595: LD_EXP 17
2599: PPUSH
2600: LD_INT 54
2602: PPUSH
2603: LD_INT 34
2605: PPUSH
2606: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2610: LD_EXP 17
2614: PPUSH
2615: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2619: LD_EXP 17
2623: PPUSH
2624: LD_EXP 22
2628: PUSH
2629: LD_INT 1
2631: ARRAY
2632: PPUSH
2633: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2637: LD_INT 35
2639: PPUSH
2640: CALL_OW 67
// until See ( 4 , JMM ) ;
2644: LD_INT 4
2646: PPUSH
2647: LD_EXP 17
2651: PPUSH
2652: CALL_OW 292
2656: IFFALSE 2637
// CenterNowOnUnits ( JMM ) ;
2658: LD_EXP 17
2662: PPUSH
2663: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2667: LD_EXP 17
2671: PPUSH
2672: LD_STRING D2-JMM-1
2674: PPUSH
2675: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2679: LD_EXP 22
2683: PUSH
2684: LD_INT 3
2686: ARRAY
2687: PPUSH
2688: LD_EXP 17
2692: PPUSH
2693: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2697: LD_EXP 22
2701: PUSH
2702: LD_INT 3
2704: ARRAY
2705: PPUSH
2706: LD_STRING D2-Eng1-1
2708: PPUSH
2709: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2713: LD_EXP 17
2717: PPUSH
2718: LD_STRING D2-JMM-2
2720: PPUSH
2721: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2725: LD_EXP 22
2729: PUSH
2730: LD_INT 3
2732: ARRAY
2733: PPUSH
2734: LD_STRING D2-Eng1-2
2736: PPUSH
2737: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2741: LD_EXP 17
2745: PPUSH
2746: LD_STRING D2-JMM-3
2748: PPUSH
2749: CALL_OW 88
// if Houten then
2753: LD_EXP 21
2757: IFFALSE 2955
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2759: LD_ADDR_VAR 0 3
2763: PUSH
2764: LD_INT 4
2766: PPUSH
2767: LD_INT 1
2769: PPUSH
2770: LD_INT 3
2772: PPUSH
2773: LD_INT 2
2775: PPUSH
2776: LD_INT 1
2778: PPUSH
2779: LD_INT 4
2781: PPUSH
2782: LD_INT 55
2784: PPUSH
2785: CALL 252 0 7
2789: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2790: LD_VAR 0 3
2794: PPUSH
2795: LD_INT 3
2797: PPUSH
2798: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2802: LD_VAR 0 3
2806: PPUSH
2807: LD_INT 46
2809: PPUSH
2810: LD_INT 19
2812: PPUSH
2813: LD_INT 0
2815: PPUSH
2816: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2820: LD_EXP 21
2824: PPUSH
2825: LD_VAR 0 3
2829: PPUSH
2830: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2834: LD_EXP 21
2838: PPUSH
2839: LD_INT 49
2841: PPUSH
2842: LD_INT 33
2844: PPUSH
2845: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2849: LD_EXP 21
2853: PPUSH
2854: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2858: LD_EXP 21
2862: PPUSH
2863: LD_EXP 17
2867: PPUSH
2868: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2872: LD_INT 35
2874: PPUSH
2875: CALL_OW 67
// until See ( 1 , Houten ) ;
2879: LD_INT 1
2881: PPUSH
2882: LD_EXP 21
2886: PPUSH
2887: CALL_OW 292
2891: IFFALSE 2872
// ComTurnUnit ( JMM , Houten ) ;
2893: LD_EXP 17
2897: PPUSH
2898: LD_EXP 21
2902: PPUSH
2903: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2907: LD_EXP 17
2911: PPUSH
2912: LD_STRING D1d-JMM-1
2914: PPUSH
2915: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2919: LD_EXP 21
2923: PPUSH
2924: LD_STRING D1-VanH-1
2926: PPUSH
2927: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2931: LD_EXP 17
2935: PPUSH
2936: LD_STRING D1-JMM-1v
2938: PPUSH
2939: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2943: LD_EXP 17
2947: PPUSH
2948: LD_STRING D1-JMM-2v
2950: PPUSH
2951: CALL_OW 88
// end ; InGameOff ;
2955: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2959: LD_STRING M1
2961: PPUSH
2962: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2966: LD_INT 22
2968: PUSH
2969: LD_INT 4
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: LD_INT 92
2978: PUSH
2979: LD_EXP 17
2983: PPUSH
2984: CALL_OW 250
2988: PUSH
2989: LD_EXP 17
2993: PPUSH
2994: CALL_OW 251
2998: PUSH
2999: LD_INT 15
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: PUSH
3008: EMPTY
3009: LIST
3010: LIST
3011: PPUSH
3012: CALL_OW 69
3016: PPUSH
3017: LD_INT 1
3019: PPUSH
3020: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3024: LD_EXP 22
3028: PUSH
3029: LD_EXP 17
3033: ADD
3034: PUSH
3035: LD_EXP 21
3039: ADD
3040: PPUSH
3041: CALL_OW 141
// end ;
3045: LD_VAR 0 1
3049: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3050: LD_INT 1
3052: PPUSH
3053: LD_EXP 18
3057: PPUSH
3058: CALL_OW 292
3062: PUSH
3063: LD_EXP 17
3067: PPUSH
3068: LD_EXP 18
3072: PPUSH
3073: CALL_OW 296
3077: PUSH
3078: LD_INT 6
3080: LESS
3081: AND
3082: IFFALSE 3845
3084: GO 3086
3086: DISABLE
3087: LD_INT 0
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
// begin InGameOn ;
3094: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3098: LD_INT 22
3100: PUSH
3101: LD_INT 4
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: PPUSH
3108: CALL_OW 69
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3120: LD_ADDR_VAR 0 4
3124: PUSH
3125: LD_INT 22
3127: PUSH
3128: LD_INT 1
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: LD_INT 25
3140: PUSH
3141: LD_INT 1
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: LD_INT 25
3150: PUSH
3151: LD_INT 2
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: PUSH
3158: LD_INT 25
3160: PUSH
3161: LD_INT 3
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PUSH
3168: LD_INT 25
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: EMPTY
3175: LIST
3176: LIST
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 69
3193: ST_TO_ADDR
// ComHold ( tmp ) ;
3194: LD_VAR 0 4
3198: PPUSH
3199: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3203: LD_EXP 17
3207: PPUSH
3208: LD_STRING D2-JMM-3a
3210: PPUSH
3211: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3215: LD_EXP 18
3219: PPUSH
3220: LD_EXP 17
3224: PPUSH
3225: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3229: LD_EXP 18
3233: PPUSH
3234: LD_STRING D2-Gary-3
3236: PPUSH
3237: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3241: LD_EXP 17
3245: PPUSH
3246: LD_EXP 18
3250: PPUSH
3251: CALL_OW 119
// for i in tmp do
3255: LD_ADDR_VAR 0 5
3259: PUSH
3260: LD_VAR 0 4
3264: PUSH
3265: FOR_IN
3266: IFFALSE 3311
// begin if IsInUnit ( i ) then
3268: LD_VAR 0 5
3272: PPUSH
3273: CALL_OW 310
3277: IFFALSE 3288
// ComExitBuilding ( i ) ;
3279: LD_VAR 0 5
3283: PPUSH
3284: CALL_OW 122
// wait ( 1 ) ;
3288: LD_INT 1
3290: PPUSH
3291: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3295: LD_VAR 0 5
3299: PPUSH
3300: LD_EXP 17
3304: PPUSH
3305: CALL_OW 119
// end ;
3309: GO 3265
3311: POP
3312: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3313: LD_ADDR_VAR 0 4
3317: PUSH
3318: LD_VAR 0 4
3322: PUSH
3323: LD_EXP 17
3327: PUSH
3328: LD_EXP 21
3332: PUSH
3333: LD_EXP 18
3337: PUSH
3338: LD_EXP 20
3342: PUSH
3343: LD_EXP 19
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: PUSH
3355: LD_EXP 22
3359: ADD
3360: DIFF
3361: ST_TO_ADDR
// if Bobby then
3362: LD_EXP 19
3366: IFFALSE 3380
// Say ( Bobby , D2-Bobby-3 ) ;
3368: LD_EXP 19
3372: PPUSH
3373: LD_STRING D2-Bobby-3
3375: PPUSH
3376: CALL_OW 88
// if Cyrus then
3380: LD_EXP 20
3384: IFFALSE 3398
// Say ( Cyrus , D2-Cyrus-3 ) ;
3386: LD_EXP 20
3390: PPUSH
3391: LD_STRING D2-Cyrus-3
3393: PPUSH
3394: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3398: LD_EXP 17
3402: PPUSH
3403: LD_STRING D2-JMM-4
3405: PPUSH
3406: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3410: LD_EXP 18
3414: PPUSH
3415: LD_STRING D2-Gary-4
3417: PPUSH
3418: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3422: LD_ADDR_VAR 0 1
3426: PUSH
3427: LD_VAR 0 4
3431: PPUSH
3432: LD_INT 26
3434: PUSH
3435: LD_INT 1
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PPUSH
3442: CALL_OW 72
3446: PUSH
3447: LD_INT 1
3449: ARRAY
3450: ST_TO_ADDR
// if Cyrus then
3451: LD_EXP 20
3455: IFFALSE 3471
// Say ( Cyrus , D2-Cyrus-4 ) else
3457: LD_EXP 20
3461: PPUSH
3462: LD_STRING D2-Cyrus-4
3464: PPUSH
3465: CALL_OW 88
3469: GO 3483
// Say ( un1 , D2-Sol1-4 ) ;
3471: LD_VAR 0 1
3475: PPUSH
3476: LD_STRING D2-Sol1-4
3478: PPUSH
3479: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3483: LD_EXP 17
3487: PPUSH
3488: LD_STRING D2-JMM-5
3490: PPUSH
3491: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3495: LD_ADDR_VAR 0 2
3499: PUSH
3500: LD_EXP 22
3504: PPUSH
3505: LD_INT 91
3507: PUSH
3508: LD_EXP 17
3512: PUSH
3513: LD_INT 10
3515: PUSH
3516: EMPTY
3517: LIST
3518: LIST
3519: LIST
3520: PUSH
3521: LD_INT 26
3523: PUSH
3524: LD_INT 2
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: ST_TO_ADDR
// if un2 then
3540: LD_VAR 0 2
3544: IFFALSE 3598
// begin un2 := un2 [ un2 ] ;
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 2
3555: PUSH
3556: LD_VAR 0 2
3560: ARRAY
3561: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3562: LD_VAR 0 2
3566: PPUSH
3567: LD_STRING D2-FEng1-5
3569: PPUSH
3570: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3574: LD_EXP 17
3578: PPUSH
3579: LD_STRING D2-JMM-6
3581: PPUSH
3582: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3586: LD_VAR 0 2
3590: PPUSH
3591: LD_STRING D2-FEng1-6
3593: PPUSH
3594: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3598: LD_ADDR_VAR 0 3
3602: PUSH
3603: LD_EXP 22
3607: PPUSH
3608: LD_INT 91
3610: PUSH
3611: LD_EXP 17
3615: PUSH
3616: LD_INT 10
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 26
3626: PUSH
3627: LD_INT 1
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: PPUSH
3638: CALL_OW 72
3642: ST_TO_ADDR
// if un3 then
3643: LD_VAR 0 3
3647: IFFALSE 3702
// begin un3 := un3 [ 1 ] ;
3649: LD_ADDR_VAR 0 3
3653: PUSH
3654: LD_VAR 0 3
3658: PUSH
3659: LD_INT 1
3661: ARRAY
3662: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3663: LD_VAR 0 3
3667: PPUSH
3668: LD_INT 114
3670: PPUSH
3671: LD_INT 122
3673: PPUSH
3674: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3678: LD_VAR 0 3
3682: PPUSH
3683: LD_STRING D2-Eng1-6
3685: PPUSH
3686: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3690: LD_EXP 17
3694: PPUSH
3695: LD_STRING D2-JMM-7
3697: PPUSH
3698: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3702: LD_EXP 18
3706: PPUSH
3707: LD_STRING D2-Gary-7
3709: PPUSH
3710: CALL_OW 88
// if un2 then
3714: LD_VAR 0 2
3718: IFFALSE 3732
// Say ( un2 , D2-FEng1-7 ) ;
3720: LD_VAR 0 2
3724: PPUSH
3725: LD_STRING D2-FEng1-7
3727: PPUSH
3728: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3732: LD_VAR 0 1
3736: PPUSH
3737: LD_STRING D2-Sol1-7
3739: PPUSH
3740: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3744: LD_EXP 17
3748: PPUSH
3749: LD_STRING D2-JMM-8
3751: PPUSH
3752: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3756: LD_INT 22
3758: PUSH
3759: LD_INT 1
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: PPUSH
3766: CALL_OW 69
3770: PPUSH
3771: CALL_OW 141
// InGameOff ;
3775: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3779: LD_STRING M1a
3781: PPUSH
3782: CALL_OW 337
// jmm_in_ovsyenko := true ;
3786: LD_ADDR_EXP 4
3790: PUSH
3791: LD_INT 1
3793: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3794: LD_INT 1050
3796: PPUSH
3797: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3801: LD_ADDR_VAR 0 4
3805: PUSH
3806: LD_INT 25
3808: PUSH
3809: LD_INT 14
3811: PUSH
3812: EMPTY
3813: LIST
3814: LIST
3815: PPUSH
3816: CALL_OW 69
3820: ST_TO_ADDR
// if not tmp then
3821: LD_VAR 0 4
3825: NOT
3826: IFFALSE 3830
// exit ;
3828: GO 3845
// ComMoveXY ( tmp , 75 , 75 ) ;
3830: LD_VAR 0 4
3834: PPUSH
3835: LD_INT 75
3837: PPUSH
3838: LD_INT 75
3840: PPUSH
3841: CALL_OW 111
// end ;
3845: PPOPN 5
3847: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) do var tmp ;
3848: LD_INT 22
3850: PUSH
3851: LD_INT 1
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: PUSH
3858: LD_INT 30
3860: PUSH
3861: LD_INT 30
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PPUSH
3872: CALL_OW 69
3876: IFFALSE 3918
3878: GO 3880
3880: DISABLE
3881: LD_INT 0
3883: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3884: LD_ADDR_VAR 0 1
3888: PUSH
3889: LD_STRING M2easy
3891: PUSH
3892: LD_STRING M2
3894: PUSH
3895: LD_STRING M2hard
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: LIST
3902: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3903: LD_VAR 0 1
3907: PUSH
3908: LD_OWVAR 67
3912: ARRAY
3913: PPUSH
3914: CALL_OW 337
// end ;
3918: PPOPN 1
3920: END
// every 3 3$00 do
3921: GO 3923
3923: DISABLE
// begin DialogueOn ;
3924: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3928: LD_EXP 24
3932: PPUSH
3933: LD_STRING D3-Pow-1
3935: PPUSH
3936: CALL_OW 94
// if jmm_in_ovsyenko then
3940: LD_EXP 4
3944: IFFALSE 3972
// begin Say ( JMM , D3-JMM-1 ) ;
3946: LD_EXP 17
3950: PPUSH
3951: LD_STRING D3-JMM-1
3953: PPUSH
3954: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
3958: LD_EXP 17
3962: PPUSH
3963: LD_STRING D3-JMM-1b
3965: PPUSH
3966: CALL_OW 88
// end else
3970: GO 3984
// Say ( JMM , D3-JMM-1a ) ;
3972: LD_EXP 17
3976: PPUSH
3977: LD_STRING D3-JMM-1a
3979: PPUSH
3980: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
3984: LD_EXP 24
3988: PPUSH
3989: LD_STRING D3-Pow-2
3991: PPUSH
3992: CALL_OW 94
// DialogueOff ;
3996: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4000: LD_STRING M3
4002: PPUSH
4003: CALL_OW 337
// powell_want_sib := true ;
4007: LD_ADDR_EXP 5
4011: PUSH
4012: LD_INT 1
4014: ST_TO_ADDR
// end ;
4015: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo ;
4016: LD_EXP 6
4020: PUSH
4021: LD_INT 0
4023: EQUAL
4024: IFFALSE 5299
4026: GO 4028
4028: DISABLE
4029: LD_INT 0
4031: PPUSH
4032: PPUSH
4033: PPUSH
4034: PPUSH
4035: PPUSH
4036: PPUSH
4037: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4038: LD_INT 4
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: CALL_OW 343
// PowellTransport ;
4048: CALL 2391 0 0
// for i = 1 to 3 do
4052: LD_ADDR_VAR 0 4
4056: PUSH
4057: DOUBLE
4058: LD_INT 1
4060: DEC
4061: ST_TO_ADDR
4062: LD_INT 3
4064: PUSH
4065: FOR_TO
4066: IFFALSE 4133
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4068: LD_ADDR_VAR 0 1
4072: PUSH
4073: LD_INT 6
4075: PPUSH
4076: LD_VAR 0 4
4080: PPUSH
4081: CALL_OW 287
4085: ST_TO_ADDR
// if not tmp then
4086: LD_VAR 0 1
4090: NOT
4091: IFFALSE 4095
// continue ;
4093: GO 4065
// EraseResourceArea ( terminalArea , i ) ;
4095: LD_INT 6
4097: PPUSH
4098: LD_VAR 0 4
4102: PPUSH
4103: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4107: LD_EXP 3
4111: PPUSH
4112: CALL_OW 274
4116: PPUSH
4117: LD_VAR 0 4
4121: PPUSH
4122: LD_VAR 0 1
4126: PPUSH
4127: CALL_OW 276
// end ;
4131: GO 4065
4133: POP
4134: POP
// x := 43 ;
4135: LD_ADDR_VAR 0 2
4139: PUSH
4140: LD_INT 43
4142: ST_TO_ADDR
// y := 3 ;
4143: LD_ADDR_VAR 0 3
4147: PUSH
4148: LD_INT 3
4150: ST_TO_ADDR
// for i = 3 to 4 do
4151: LD_ADDR_VAR 0 4
4155: PUSH
4156: DOUBLE
4157: LD_INT 3
4159: DEC
4160: ST_TO_ADDR
4161: LD_INT 4
4163: PUSH
4164: FOR_TO
4165: IFFALSE 4375
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4167: LD_EXP 23
4171: PUSH
4172: LD_VAR 0 4
4176: ARRAY
4177: PPUSH
4178: LD_INT 4
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4185: LD_EXP 23
4189: PUSH
4190: LD_VAR 0 4
4194: ARRAY
4195: PPUSH
4196: LD_VAR 0 2
4200: PPUSH
4201: LD_VAR 0 3
4205: PPUSH
4206: LD_INT 0
4208: PPUSH
4209: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4213: LD_EXP 23
4217: PUSH
4218: LD_VAR 0 4
4222: PUSH
4223: LD_INT 2
4225: MINUS
4226: ARRAY
4227: PPUSH
4228: LD_EXP 23
4232: PUSH
4233: LD_VAR 0 4
4237: ARRAY
4238: PPUSH
4239: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4243: LD_EXP 23
4247: PUSH
4248: LD_VAR 0 4
4252: ARRAY
4253: PPUSH
4254: LD_INT 1
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4264: LD_EXP 23
4268: PUSH
4269: LD_VAR 0 4
4273: PUSH
4274: LD_INT 2
4276: MINUS
4277: ARRAY
4278: PPUSH
4279: LD_INT 54
4281: PPUSH
4282: LD_INT 42
4284: PPUSH
4285: CALL_OW 111
// AddComUnload ( powell_trans [ i - 2 ] ) ;
4289: LD_EXP 23
4293: PUSH
4294: LD_VAR 0 4
4298: PUSH
4299: LD_INT 2
4301: MINUS
4302: ARRAY
4303: PPUSH
4304: CALL_OW 219
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4308: LD_EXP 23
4312: PUSH
4313: LD_VAR 0 4
4317: PUSH
4318: LD_INT 2
4320: MINUS
4321: ARRAY
4322: PPUSH
4323: LD_EXP 3
4327: PPUSH
4328: CALL_OW 250
4332: PPUSH
4333: LD_EXP 3
4337: PPUSH
4338: CALL_OW 251
4342: PPUSH
4343: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4347: LD_EXP 23
4351: PUSH
4352: LD_VAR 0 4
4356: PUSH
4357: LD_INT 2
4359: MINUS
4360: ARRAY
4361: PPUSH
4362: CALL_OW 200
// Wait ( 0 0$02 ) ;
4366: LD_INT 70
4368: PPUSH
4369: CALL_OW 67
// end ;
4373: GO 4164
4375: POP
4376: POP
// repeat wait ( 0 0$01 ) ;
4377: LD_INT 35
4379: PPUSH
4380: CALL_OW 67
// for i = 3 to 4 do
4384: LD_ADDR_VAR 0 4
4388: PUSH
4389: DOUBLE
4390: LD_INT 3
4392: DEC
4393: ST_TO_ADDR
4394: LD_INT 4
4396: PUSH
4397: FOR_TO
4398: IFFALSE 4548
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4400: LD_EXP 23
4404: PUSH
4405: LD_VAR 0 4
4409: ARRAY
4410: PPUSH
4411: LD_INT 1
4413: PPUSH
4414: CALL_OW 289
4418: PUSH
4419: LD_INT 0
4421: GREATER
4422: PUSH
4423: LD_EXP 23
4427: PUSH
4428: LD_VAR 0 4
4432: ARRAY
4433: PPUSH
4434: CALL_OW 314
4438: NOT
4439: AND
4440: IFFALSE 4546
// begin ComUnload ( powell_trans [ i ] ) ;
4442: LD_EXP 23
4446: PUSH
4447: LD_VAR 0 4
4451: ARRAY
4452: PPUSH
4453: CALL_OW 159
// x := rand ( 0 , 5 ) ;
4457: LD_ADDR_VAR 0 2
4461: PUSH
4462: LD_INT 0
4464: PPUSH
4465: LD_INT 5
4467: PPUSH
4468: CALL_OW 12
4472: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4473: LD_EXP 23
4477: PUSH
4478: LD_VAR 0 4
4482: ARRAY
4483: PPUSH
4484: LD_EXP 23
4488: PUSH
4489: LD_VAR 0 4
4493: ARRAY
4494: PPUSH
4495: CALL_OW 250
4499: PPUSH
4500: LD_VAR 0 2
4504: PPUSH
4505: LD_INT 3
4507: PPUSH
4508: CALL_OW 272
4512: PPUSH
4513: LD_EXP 23
4517: PUSH
4518: LD_VAR 0 4
4522: ARRAY
4523: PPUSH
4524: CALL_OW 251
4528: PPUSH
4529: LD_VAR 0 2
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 273
4541: PPUSH
4542: CALL_OW 171
// end ;
4546: GO 4397
4548: POP
4549: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 and ( GetCargo ( powell_trans [ 3 ] , mat_cans ) = 0 ) and ( GetCargo ( powell_trans [ 4 ] , mat_cans ) = 0 ) ;
4550: LD_EXP 23
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 54
4561: PPUSH
4562: LD_INT 42
4564: PPUSH
4565: CALL_OW 297
4569: PUSH
4570: LD_INT 4
4572: LESS
4573: PUSH
4574: LD_EXP 23
4578: PUSH
4579: LD_INT 3
4581: ARRAY
4582: PPUSH
4583: LD_INT 1
4585: PPUSH
4586: CALL_OW 289
4590: PUSH
4591: LD_INT 0
4593: EQUAL
4594: AND
4595: PUSH
4596: LD_EXP 23
4600: PUSH
4601: LD_INT 4
4603: ARRAY
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL_OW 289
4612: PUSH
4613: LD_INT 0
4615: EQUAL
4616: AND
4617: IFFALSE 4377
// DialogueOn ;
4619: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4623: LD_INT 53
4625: PPUSH
4626: LD_INT 35
4628: PPUSH
4629: CALL_OW 86
// un := powell_trans [ 1 ] ;
4633: LD_ADDR_VAR 0 5
4637: PUSH
4638: LD_EXP 23
4642: PUSH
4643: LD_INT 1
4645: ARRAY
4646: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4647: LD_VAR 0 5
4651: PPUSH
4652: LD_STRING D4-Mech1-1
4654: PPUSH
4655: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4659: LD_EXP 17
4663: PPUSH
4664: LD_STRING D4-JMM-1
4666: PPUSH
4667: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4671: LD_VAR 0 5
4675: PPUSH
4676: LD_STRING D4-Mech1-2
4678: PPUSH
4679: CALL_OW 88
// powell_happy := false ;
4683: LD_ADDR_VAR 0 6
4687: PUSH
4688: LD_INT 0
4690: ST_TO_ADDR
// take_cargo := false ;
4691: LD_ADDR_VAR 0 7
4695: PUSH
4696: LD_INT 0
4698: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4699: CALL 752 0 0
4703: PUSH
4704: LD_INT 60
4706: GREATEREQUAL
4707: IFFALSE 4755
// begin Say ( JMM , D5-JMM-1 ) ;
4709: LD_EXP 17
4713: PPUSH
4714: LD_STRING D5-JMM-1
4716: PPUSH
4717: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4721: LD_VAR 0 5
4725: PPUSH
4726: LD_STRING D6-Mech1-1
4728: PPUSH
4729: CALL_OW 88
// powell_happy := true ;
4733: LD_ADDR_VAR 0 6
4737: PUSH
4738: LD_INT 1
4740: ST_TO_ADDR
// take_cargo := true ;
4741: LD_ADDR_VAR 0 7
4745: PUSH
4746: LD_INT 1
4748: ST_TO_ADDR
// DialogueOff ;
4749: CALL_OW 7
// end else
4753: GO 4989
// if GetTerminalCargo > 0 then
4755: CALL 752 0 0
4759: PUSH
4760: LD_INT 0
4762: GREATER
4763: IFFALSE 4961
// begin case Query ( QWait ) of 1 :
4765: LD_STRING QWait
4767: PPUSH
4768: CALL_OW 97
4772: PUSH
4773: LD_INT 1
4775: DOUBLE
4776: EQUAL
4777: IFTRUE 4781
4779: GO 4872
4781: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4782: LD_EXP 17
4786: PPUSH
4787: LD_STRING D5b-JMM-1
4789: PPUSH
4790: CALL_OW 88
// DialogueOff ;
4794: CALL_OW 7
// wait ( 5 5$00 ) ;
4798: LD_INT 10500
4800: PPUSH
4801: CALL_OW 67
// if GetTerminalCargo < 60 then
4805: CALL 752 0 0
4809: PUSH
4810: LD_INT 60
4812: LESS
4813: IFFALSE 4854
// begin DialogueOn ;
4815: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4819: LD_EXP 3
4823: PPUSH
4824: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4828: LD_VAR 0 5
4832: PPUSH
4833: LD_STRING D6-Mech1-1a
4835: PPUSH
4836: CALL_OW 88
// DialogueOff ;
4840: CALL_OW 7
// powell_happy := false ;
4844: LD_ADDR_VAR 0 6
4848: PUSH
4849: LD_INT 0
4851: ST_TO_ADDR
// end else
4852: GO 4870
// begin powell_happy := true ;
4854: LD_ADDR_VAR 0 6
4858: PUSH
4859: LD_INT 1
4861: ST_TO_ADDR
// take_cargo := true ;
4862: LD_ADDR_VAR 0 7
4866: PUSH
4867: LD_INT 1
4869: ST_TO_ADDR
// end ; end ; 2 :
4870: GO 4959
4872: LD_INT 2
4874: DOUBLE
4875: EQUAL
4876: IFTRUE 4880
4878: GO 4919
4880: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4881: LD_EXP 17
4885: PPUSH
4886: LD_STRING D5b-JMM-1
4888: PPUSH
4889: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4893: LD_VAR 0 5
4897: PPUSH
4898: LD_STRING D6-Mech1-1a
4900: PPUSH
4901: CALL_OW 88
// DialogueOff ;
4905: CALL_OW 7
// take_cargo := true ;
4909: LD_ADDR_VAR 0 7
4913: PUSH
4914: LD_INT 1
4916: ST_TO_ADDR
// end ; 3 :
4917: GO 4959
4919: LD_INT 3
4921: DOUBLE
4922: EQUAL
4923: IFTRUE 4927
4925: GO 4958
4927: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4928: LD_EXP 17
4932: PPUSH
4933: LD_STRING D5c-JMM-1
4935: PPUSH
4936: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4940: LD_VAR 0 5
4944: PPUSH
4945: LD_STRING D6-Mech1-1b
4947: PPUSH
4948: CALL_OW 88
// DialogueOff ;
4952: CALL_OW 7
// end ; end ;
4956: GO 4959
4958: POP
// end else
4959: GO 4989
// begin Say ( JMM , D5c-JMM-1 ) ;
4961: LD_EXP 17
4965: PPUSH
4966: LD_STRING D5c-JMM-1
4968: PPUSH
4969: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4973: LD_VAR 0 5
4977: PPUSH
4978: LD_STRING D6-Mech1-1b
4980: PPUSH
4981: CALL_OW 88
// DialogueOff ;
4985: CALL_OW 7
// end ; if take_cargo then
4989: LD_VAR 0 7
4993: IFFALSE 5072
// begin x := GetTerminalCargo ;
4995: LD_ADDR_VAR 0 2
4999: PUSH
5000: CALL 752 0 0
5004: ST_TO_ADDR
// if x > 60 then
5005: LD_VAR 0 2
5009: PUSH
5010: LD_INT 60
5012: GREATER
5013: IFFALSE 5023
// x := 60 ;
5015: LD_ADDR_VAR 0 2
5019: PUSH
5020: LD_INT 60
5022: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5023: LD_EXP 3
5027: PPUSH
5028: CALL_OW 274
5032: PPUSH
5033: LD_INT 3
5035: PPUSH
5036: CALL 752 0 0
5040: PUSH
5041: LD_VAR 0 2
5045: MINUS
5046: PPUSH
5047: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5051: LD_EXP 23
5055: PUSH
5056: LD_INT 3
5058: ARRAY
5059: PPUSH
5060: LD_INT 3
5062: PPUSH
5063: LD_VAR 0 2
5067: PPUSH
5068: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5072: LD_EXP 23
5076: PPUSH
5077: LD_INT 43
5079: PPUSH
5080: LD_INT 3
5082: PPUSH
5083: CALL_OW 171
// x := 0 0$20 ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: LD_INT 700
5094: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5095: LD_INT 35
5097: PPUSH
5098: CALL_OW 67
// x := x - 0 0$01 ;
5102: LD_ADDR_VAR 0 2
5106: PUSH
5107: LD_VAR 0 2
5111: PUSH
5112: LD_INT 35
5114: MINUS
5115: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5116: LD_VAR 0 2
5120: PUSH
5121: LD_INT 0
5123: EQUAL
5124: PUSH
5125: LD_EXP 23
5129: PUSH
5130: LD_INT 3
5132: ARRAY
5133: PPUSH
5134: LD_INT 43
5136: PPUSH
5137: LD_INT 3
5139: PPUSH
5140: CALL_OW 297
5144: PUSH
5145: LD_INT 4
5147: LESS
5148: PUSH
5149: LD_EXP 23
5153: PUSH
5154: LD_INT 3
5156: ARRAY
5157: PPUSH
5158: LD_INT 43
5160: PPUSH
5161: LD_INT 3
5163: PPUSH
5164: CALL_OW 297
5168: PUSH
5169: LD_INT 4
5171: LESS
5172: AND
5173: OR
5174: IFFALSE 5095
// for i in powell_trans do
5176: LD_ADDR_VAR 0 4
5180: PUSH
5181: LD_EXP 23
5185: PUSH
5186: FOR_IN
5187: IFFALSE 5200
// RemoveUnit ( i ) ;
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 64
5198: GO 5186
5200: POP
5201: POP
// if not powell_happy then
5202: LD_VAR 0 6
5206: NOT
5207: IFFALSE 5218
// powell_happy := - 1 ;
5209: LD_ADDR_VAR 0 6
5213: PUSH
5214: LD_INT 1
5216: NEG
5217: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5218: LD_VAR 0 6
5222: PPUSH
5223: LD_STRING EarlySiberite
5225: PPUSH
5226: CALL_OW 101
// if powell_happy then
5230: LD_VAR 0 6
5234: IFFALSE 5245
// ChangeMissionObjectives ( M3a ) else
5236: LD_STRING M3a
5238: PPUSH
5239: CALL_OW 337
5243: GO 5252
// ChangeMissionObjectives ( M3b ) ;
5245: LD_STRING M3b
5247: PPUSH
5248: CALL_OW 337
// ru_can_attack_terminal := true ;
5252: LD_ADDR_EXP 9
5256: PUSH
5257: LD_INT 1
5259: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5260: LD_INT 12600
5262: PPUSH
5263: CALL_OW 67
// repeat wait ( 0 0$03 ) ;
5267: LD_INT 105
5269: PPUSH
5270: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5274: LD_EXP 8
5278: NOT
5279: PUSH
5280: LD_EXP 33
5284: PUSH
5285: LD_INT 3
5287: LESS
5288: OR
5289: IFFALSE 5267
// ar_can_arrive := true ;
5291: LD_ADDR_EXP 10
5295: PUSH
5296: LD_INT 1
5298: ST_TO_ADDR
// end ;
5299: PPOPN 7
5301: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5302: LD_INT 1
5304: PPUSH
5305: LD_INT 20
5307: PPUSH
5308: CALL_OW 325
5312: IFFALSE 5453
5314: GO 5316
5316: DISABLE
5317: LD_INT 0
5319: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5320: LD_ADDR_VAR 0 1
5324: PUSH
5325: LD_INT 22
5327: PUSH
5328: LD_INT 1
5330: PUSH
5331: EMPTY
5332: LIST
5333: LIST
5334: PUSH
5335: LD_INT 26
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PUSH
5345: LD_INT 25
5347: PUSH
5348: LD_INT 4
5350: PUSH
5351: EMPTY
5352: LIST
5353: LIST
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: LIST
5359: PPUSH
5360: CALL_OW 69
5364: PUSH
5365: LD_EXP 17
5369: PUSH
5370: LD_EXP 20
5374: PUSH
5375: LD_EXP 19
5379: PUSH
5380: LD_EXP 21
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: LIST
5389: LIST
5390: DIFF
5391: ST_TO_ADDR
// if not un then
5392: LD_VAR 0 1
5396: NOT
5397: IFFALSE 5401
// exit ;
5399: GO 5453
// DialogueOn ;
5401: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5405: LD_VAR 0 1
5409: PUSH
5410: LD_INT 1
5412: ARRAY
5413: PPUSH
5414: LD_STRING D13-Sci1-1
5416: PPUSH
5417: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5421: LD_EXP 17
5425: PPUSH
5426: LD_STRING D13-JMM-1
5428: PPUSH
5429: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: LD_STRING D13-Sci1-2
5444: PPUSH
5445: CALL_OW 88
// DialogueOff ;
5449: CALL_OW 7
// end ;
5453: PPOPN 1
5455: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5456: LD_INT 1
5458: PPUSH
5459: CALL 783 0 1
5463: PUSH
5464: LD_INT 77
5466: GREATER
5467: PUSH
5468: LD_EXP 8
5472: NOT
5473: AND
5474: PUSH
5475: LD_INT 22
5477: PUSH
5478: LD_INT 1
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PUSH
5485: LD_INT 25
5487: PUSH
5488: LD_INT 4
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: PUSH
5495: LD_INT 26
5497: PUSH
5498: LD_INT 1
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: PPUSH
5510: CALL_OW 69
5514: PUSH
5515: LD_EXP 17
5519: PUSH
5520: LD_EXP 19
5524: PUSH
5525: LD_EXP 20
5529: PUSH
5530: LD_EXP 18
5534: PUSH
5535: LD_EXP 21
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: LIST
5545: LIST
5546: DIFF
5547: AND
5548: IFFALSE 5726
5550: GO 5552
5552: DISABLE
5553: LD_INT 0
5555: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5556: LD_ADDR_VAR 0 1
5560: PUSH
5561: LD_INT 22
5563: PUSH
5564: LD_INT 1
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 25
5573: PUSH
5574: LD_INT 4
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: PUSH
5581: LD_INT 26
5583: PUSH
5584: LD_INT 1
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PPUSH
5596: CALL_OW 69
5600: PUSH
5601: LD_EXP 17
5605: PUSH
5606: LD_EXP 19
5610: PUSH
5611: LD_EXP 20
5615: PUSH
5616: LD_EXP 18
5620: PUSH
5621: LD_EXP 21
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: LIST
5632: DIFF
5633: ST_TO_ADDR
// DialogueOn ;
5634: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5638: LD_VAR 0 1
5642: PUSH
5643: LD_INT 1
5645: ARRAY
5646: PPUSH
5647: LD_STRING D7-Sci1-1
5649: PPUSH
5650: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5654: LD_EXP 17
5658: PPUSH
5659: LD_STRING D7-JMM-1
5661: PPUSH
5662: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5666: LD_VAR 0 1
5670: PUSH
5671: LD_INT 1
5673: ARRAY
5674: PPUSH
5675: LD_STRING D7-Sci1-2
5677: PPUSH
5678: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5682: LD_EXP 17
5686: PPUSH
5687: LD_STRING D7-JMM-2
5689: PPUSH
5690: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5694: LD_VAR 0 1
5698: PUSH
5699: LD_INT 1
5701: ARRAY
5702: PPUSH
5703: LD_STRING D7-Sci1-3
5705: PPUSH
5706: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5710: LD_EXP 17
5714: PPUSH
5715: LD_STRING D7-JMM-3
5717: PPUSH
5718: CALL_OW 88
// DialogueOff ;
5722: CALL_OW 7
// end ;
5726: PPOPN 1
5728: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5729: LD_EXP 10
5733: IFFALSE 8959
5735: GO 5737
5737: DISABLE
5738: LD_INT 0
5740: PPUSH
5741: PPUSH
5742: PPUSH
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
5747: PPUSH
// begin PrepareArabian ;
5748: CALL 11068 0 0
// repeat wait ( 0 0$01 ) ;
5752: LD_INT 35
5754: PPUSH
5755: CALL_OW 67
// until ar_spawned ;
5759: LD_EXP 11
5763: IFFALSE 5752
// DialogueOn ;
5765: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5769: LD_EXP 25
5773: PPUSH
5774: LD_STRING D8-Ar1-1
5776: PPUSH
5777: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5781: LD_EXP 17
5785: PPUSH
5786: LD_STRING D8-JMM-1
5788: PPUSH
5789: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5793: LD_EXP 25
5797: PPUSH
5798: LD_STRING D8-Ar1-2
5800: PPUSH
5801: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
5805: LD_EXP 17
5809: PPUSH
5810: LD_STRING D8-JMM-2
5812: PPUSH
5813: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
5817: LD_EXP 25
5821: PPUSH
5822: LD_STRING D8-Ar1-3
5824: PPUSH
5825: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
5829: LD_EXP 17
5833: PPUSH
5834: LD_STRING D8-JMM-3
5836: PPUSH
5837: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
5841: LD_EXP 25
5845: PPUSH
5846: LD_STRING D8-Ar1-4
5848: PPUSH
5849: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
5853: LD_EXP 17
5857: PPUSH
5858: LD_STRING D8-JMM-4
5860: PPUSH
5861: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
5865: LD_EXP 25
5869: PPUSH
5870: LD_STRING D8-Ar1-5
5872: PPUSH
5873: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
5877: LD_EXP 17
5881: PPUSH
5882: LD_STRING D8-JMM-5
5884: PPUSH
5885: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
5889: LD_EXP 25
5893: PPUSH
5894: LD_STRING D8-Ar1-6
5896: PPUSH
5897: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
5901: LD_EXP 26
5905: PPUSH
5906: LD_STRING D8-Ar2-6
5908: PPUSH
5909: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
5913: LD_EXP 17
5917: PPUSH
5918: LD_STRING D8-JMM-6
5920: PPUSH
5921: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
5925: LD_EXP 26
5929: PPUSH
5930: LD_STRING D8-Ar2-7
5932: PPUSH
5933: CALL_OW 94
// case Query ( QBarracks ) of 1 :
5937: LD_STRING QBarracks
5939: PPUSH
5940: CALL_OW 97
5944: PUSH
5945: LD_INT 1
5947: DOUBLE
5948: EQUAL
5949: IFTRUE 5953
5951: GO 5988
5953: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
5954: LD_EXP 17
5958: PPUSH
5959: LD_STRING D8a-JMM-1
5961: PPUSH
5962: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
5966: LD_EXP 25
5970: PPUSH
5971: LD_STRING D8a-Ar1-1
5973: PPUSH
5974: CALL_OW 94
// player_want_mortar := true ;
5978: LD_ADDR_EXP 12
5982: PUSH
5983: LD_INT 1
5985: ST_TO_ADDR
// end ; 2 :
5986: GO 6146
5988: LD_INT 2
5990: DOUBLE
5991: EQUAL
5992: IFTRUE 5996
5994: GO 6110
5996: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
5997: LD_EXP 17
6001: PPUSH
6002: LD_STRING D8b-JMM-1
6004: PPUSH
6005: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6009: LD_EXP 25
6013: PPUSH
6014: LD_STRING D8b-Ar1-1
6016: PPUSH
6017: CALL_OW 94
// case Query ( QInfo ) of 1 :
6021: LD_STRING QInfo
6023: PPUSH
6024: CALL_OW 97
6028: PUSH
6029: LD_INT 1
6031: DOUBLE
6032: EQUAL
6033: IFTRUE 6037
6035: GO 6072
6037: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6038: LD_EXP 17
6042: PPUSH
6043: LD_STRING D8b1-JMM-1
6045: PPUSH
6046: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6050: LD_EXP 25
6054: PPUSH
6055: LD_STRING D8b1-Ar1-1
6057: PPUSH
6058: CALL_OW 94
// player_want_info := 2 ;
6062: LD_ADDR_EXP 13
6066: PUSH
6067: LD_INT 2
6069: ST_TO_ADDR
// end ; 2 :
6070: GO 6108
6072: LD_INT 2
6074: DOUBLE
6075: EQUAL
6076: IFTRUE 6080
6078: GO 6107
6080: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6081: LD_EXP 17
6085: PPUSH
6086: LD_STRING D8b2-JMM-1
6088: PPUSH
6089: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6093: LD_EXP 25
6097: PPUSH
6098: LD_STRING D8b2-Ar1-1
6100: PPUSH
6101: CALL_OW 94
// end ; end ;
6105: GO 6108
6107: POP
// end ; 3 :
6108: GO 6146
6110: LD_INT 3
6112: DOUBLE
6113: EQUAL
6114: IFTRUE 6118
6116: GO 6145
6118: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6119: LD_EXP 17
6123: PPUSH
6124: LD_STRING D8c-JMM-1
6126: PPUSH
6127: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6131: LD_EXP 25
6135: PPUSH
6136: LD_STRING D8c-Ar1-1
6138: PPUSH
6139: CALL_OW 94
// end ; end ;
6143: GO 6146
6145: POP
// DialogueOff ;
6146: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6150: LD_ADDR_VAR 0 4
6154: PUSH
6155: LD_INT 22
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: LD_INT 30
6170: PUSH
6171: LD_INT 0
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: LD_INT 30
6180: PUSH
6181: LD_INT 1
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PPUSH
6197: CALL_OW 69
6201: PPUSH
6202: LD_EXP 26
6206: PPUSH
6207: CALL_OW 74
6211: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6212: LD_ADDR_VAR 0 3
6216: PUSH
6217: LD_INT 22
6219: PUSH
6220: LD_INT 2
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 21
6229: PUSH
6230: LD_INT 2
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PPUSH
6241: CALL_OW 69
6245: ST_TO_ADDR
// time := 1 1$35 ;
6246: LD_ADDR_VAR 0 5
6250: PUSH
6251: LD_INT 3325
6253: ST_TO_ADDR
// no_oil_gain := false ;
6254: LD_ADDR_VAR 0 6
6258: PUSH
6259: LD_INT 0
6261: ST_TO_ADDR
// first_warn := false ;
6262: LD_ADDR_VAR 0 7
6266: PUSH
6267: LD_INT 0
6269: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6270: LD_EXP 12
6274: PUSH
6275: LD_EXP 13
6279: OR
6280: IFFALSE 6385
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6282: LD_EXP 32
6286: PPUSH
6287: LD_INT 25
6289: PUSH
6290: LD_INT 1
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: PPUSH
6302: LD_VAR 0 4
6306: PPUSH
6307: CALL_OW 250
6311: PPUSH
6312: LD_VAR 0 4
6316: PPUSH
6317: CALL_OW 251
6321: PPUSH
6322: LD_VAR 0 4
6326: PPUSH
6327: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6331: LD_EXP 32
6335: PPUSH
6336: LD_INT 25
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: PPUSH
6346: CALL_OW 72
6350: PPUSH
6351: LD_INT 86
6353: PPUSH
6354: LD_INT 121
6356: PPUSH
6357: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6361: LD_EXP 32
6365: PPUSH
6366: LD_INT 25
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PPUSH
6376: CALL_OW 72
6380: PPUSH
6381: CALL_OW 200
// end ; if player_attacked_ar then
6385: LD_EXP 16
6389: IFFALSE 6393
// exit ;
6391: GO 8959
// if player_want_mortar then
6393: LD_EXP 12
6397: IFFALSE 7789
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6399: LD_EXP 26
6403: PPUSH
6404: LD_VAR 0 4
6408: PPUSH
6409: CALL_OW 250
6413: PUSH
6414: LD_INT 1
6416: PLUS
6417: PPUSH
6418: LD_VAR 0 4
6422: PPUSH
6423: CALL_OW 251
6427: PUSH
6428: LD_INT 1
6430: PLUS
6431: PPUSH
6432: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6436: LD_INT 35
6438: PPUSH
6439: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6443: LD_EXP 26
6447: PPUSH
6448: LD_VAR 0 4
6452: PPUSH
6453: CALL_OW 296
6457: PUSH
6458: LD_INT 4
6460: LESS
6461: IFFALSE 6436
// for i = 1 to 6 do
6463: LD_ADDR_VAR 0 1
6467: PUSH
6468: DOUBLE
6469: LD_INT 1
6471: DEC
6472: ST_TO_ADDR
6473: LD_INT 6
6475: PUSH
6476: FOR_TO
6477: IFFALSE 6674
// begin if player_attacked_ar then
6479: LD_EXP 16
6483: IFFALSE 6489
// exit ;
6485: POP
6486: POP
6487: GO 8959
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6489: LD_VAR 0 4
6493: PPUSH
6494: CALL_OW 274
6498: PPUSH
6499: LD_INT 2
6501: PPUSH
6502: CALL_OW 275
6506: PUSH
6507: LD_INT 10
6509: LESS
6510: PUSH
6511: LD_VAR 0 7
6515: NOT
6516: AND
6517: IFFALSE 6580
// begin first_warn := true ;
6519: LD_ADDR_VAR 0 7
6523: PUSH
6524: LD_INT 1
6526: ST_TO_ADDR
// DialogueOn ;
6527: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6531: LD_EXP 27
6535: PPUSH
6536: LD_STRING D9a-FAr1-1
6538: PPUSH
6539: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6543: LD_EXP 17
6547: PPUSH
6548: LD_STRING D9a-JMM-1
6550: PPUSH
6551: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6555: LD_EXP 25
6559: PPUSH
6560: LD_STRING D9a2-Ar1-1
6562: PPUSH
6563: CALL_OW 88
// DialogueOff ;
6567: CALL_OW 7
// wait ( time ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6580: LD_VAR 0 4
6584: PPUSH
6585: CALL_OW 274
6589: PPUSH
6590: LD_INT 2
6592: PPUSH
6593: CALL_OW 275
6597: PUSH
6598: LD_INT 10
6600: LESS
6601: IFFALSE 6627
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6603: LD_EXP 25
6607: PPUSH
6608: LD_STRING D9a3-Ar1-1
6610: PPUSH
6611: CALL_OW 88
// no_oil_gain := true ;
6615: LD_ADDR_VAR 0 6
6619: PUSH
6620: LD_INT 1
6622: ST_TO_ADDR
// break ;
6623: GO 6674
// end else
6625: GO 6672
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6627: LD_EXP 26
6631: PPUSH
6632: LD_VAR 0 4
6636: PPUSH
6637: LD_INT 2
6639: PPUSH
6640: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6644: LD_EXP 26
6648: PPUSH
6649: LD_VAR 0 3
6653: PUSH
6654: LD_VAR 0 1
6658: PUSH
6659: LD_INT 3
6661: MOD
6662: PUSH
6663: LD_INT 1
6665: PLUS
6666: ARRAY
6667: PPUSH
6668: CALL_OW 210
// end ; end ;
6672: GO 6476
6674: POP
6675: POP
// if not no_oil_gain then
6676: LD_VAR 0 6
6680: NOT
6681: IFFALSE 7789
// begin repeat wait ( 0 0$01 ) ;
6683: LD_INT 35
6685: PPUSH
6686: CALL_OW 67
// if player_attacked_ar then
6690: LD_EXP 16
6694: IFFALSE 6698
// exit ;
6696: GO 8959
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6698: LD_VAR 0 3
6702: PUSH
6703: LD_INT 1
6705: ARRAY
6706: PPUSH
6707: CALL_OW 261
6711: PUSH
6712: LD_INT 80
6714: GREATER
6715: PUSH
6716: LD_VAR 0 3
6720: PUSH
6721: LD_INT 2
6723: ARRAY
6724: PPUSH
6725: CALL_OW 261
6729: PUSH
6730: LD_INT 80
6732: GREATER
6733: AND
6734: PUSH
6735: LD_VAR 0 3
6739: PUSH
6740: LD_INT 3
6742: ARRAY
6743: PPUSH
6744: CALL_OW 261
6748: PUSH
6749: LD_INT 80
6751: GREATER
6752: AND
6753: IFFALSE 6683
// ComMoveXY ( Gali , 105 , 127 ) ;
6755: LD_EXP 26
6759: PPUSH
6760: LD_INT 105
6762: PPUSH
6763: LD_INT 127
6765: PPUSH
6766: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6770: LD_EXP 26
6774: PPUSH
6775: LD_INT 2
6777: PPUSH
6778: CALL_OW 173
// AddComHold ( Gali ) ;
6782: LD_EXP 26
6786: PPUSH
6787: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6791: LD_INT 35
6793: PPUSH
6794: CALL_OW 67
// if player_attacked_ar then
6798: LD_EXP 16
6802: IFFALSE 6806
// exit ;
6804: GO 8959
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
6806: LD_EXP 26
6810: PPUSH
6811: LD_INT 105
6813: PPUSH
6814: LD_INT 127
6816: PPUSH
6817: CALL_OW 297
6821: PUSH
6822: LD_INT 4
6824: LESS
6825: IFFALSE 6791
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6827: LD_VAR 0 4
6831: PPUSH
6832: CALL_OW 274
6836: PPUSH
6837: LD_INT 1
6839: PPUSH
6840: CALL_OW 275
6844: PUSH
6845: LD_INT 50
6847: LESS
6848: IFFALSE 7144
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
6850: LD_VAR 0 4
6854: PPUSH
6855: CALL_OW 274
6859: PPUSH
6860: LD_INT 1
6862: PPUSH
6863: CALL_OW 275
6867: PUSH
6868: LD_INT 0
6870: DOUBLE
6871: GREATEREQUAL
6872: IFFALSE 6880
6874: LD_INT 24
6876: DOUBLE
6877: LESSEQUAL
6878: IFTRUE 6882
6880: GO 6897
6882: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
6883: LD_EXP 26
6887: PPUSH
6888: LD_STRING D9b-Ar2-1
6890: PPUSH
6891: CALL_OW 88
6895: GO 6927
6897: LD_INT 25
6899: DOUBLE
6900: GREATEREQUAL
6901: IFFALSE 6909
6903: LD_INT 49
6905: DOUBLE
6906: LESSEQUAL
6907: IFTRUE 6911
6909: GO 6926
6911: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
6912: LD_EXP 26
6916: PPUSH
6917: LD_STRING D9b-Ar2-1a
6919: PPUSH
6920: CALL_OW 88
6924: GO 6927
6926: POP
// Say ( JMM , D9b-JMM-1 ) ;
6927: LD_EXP 17
6931: PPUSH
6932: LD_STRING D9b-JMM-1
6934: PPUSH
6935: CALL_OW 88
// x := 0 0$0 ;
6939: LD_ADDR_VAR 0 2
6943: PUSH
6944: LD_INT 0
6946: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6947: LD_INT 35
6949: PPUSH
6950: CALL_OW 67
// x := x + 0 0$1 ;
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 35
6966: PLUS
6967: ST_TO_ADDR
// if player_attacked_ar then
6968: LD_EXP 16
6972: IFFALSE 6976
// exit ;
6974: GO 8959
// until x >= time ;
6976: LD_VAR 0 2
6980: PUSH
6981: LD_VAR 0 5
6985: GREATEREQUAL
6986: IFFALSE 6947
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6988: LD_VAR 0 4
6992: PPUSH
6993: CALL_OW 274
6997: PPUSH
6998: LD_INT 1
7000: PPUSH
7001: CALL_OW 275
7005: PUSH
7006: LD_INT 50
7008: LESS
7009: IFFALSE 7142
// begin DialogueOn ;
7011: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7015: LD_EXP 25
7019: PPUSH
7020: LD_STRING D9c-Ar1-1
7022: PPUSH
7023: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7027: LD_EXP 17
7031: PPUSH
7032: LD_STRING D9c-JMM-1
7034: PPUSH
7035: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7039: LD_EXP 25
7043: PPUSH
7044: LD_STRING D9c-Ar1-2
7046: PPUSH
7047: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7051: LD_EXP 27
7055: PPUSH
7056: LD_STRING D9c-FAr1-2
7058: PPUSH
7059: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7063: LD_EXP 25
7067: PPUSH
7068: LD_STRING D9c-Ar1-3
7070: PPUSH
7071: CALL_OW 88
// case Query ( QInfo ) of 1 :
7075: LD_STRING QInfo
7077: PPUSH
7078: CALL_OW 97
7082: PUSH
7083: LD_INT 1
7085: DOUBLE
7086: EQUAL
7087: IFTRUE 7091
7089: GO 7114
7091: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7092: LD_EXP 17
7096: PPUSH
7097: LD_STRING D8b1-JMM-1
7099: PPUSH
7100: CALL_OW 88
// player_want_info := 2 ;
7104: LD_ADDR_EXP 13
7108: PUSH
7109: LD_INT 2
7111: ST_TO_ADDR
// end ; 2 :
7112: GO 7138
7114: LD_INT 2
7116: DOUBLE
7117: EQUAL
7118: IFTRUE 7122
7120: GO 7137
7122: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7123: LD_EXP 25
7127: PPUSH
7128: LD_STRING D8b2-Ar1-1
7130: PPUSH
7131: CALL_OW 88
// end ; end ;
7135: GO 7138
7137: POP
// DialogueOff ;
7138: CALL_OW 7
// end ; end else
7142: GO 7789
// begin RemoveEnvironmentArea ( mortarArea ) ;
7144: LD_INT 2
7146: PPUSH
7147: CALL_OW 355
// wait ( 1 ) ;
7151: LD_INT 1
7153: PPUSH
7154: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7158: LD_EXP 26
7162: PPUSH
7163: LD_INT 1
7165: PPUSH
7166: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 130 , 0 ) ;
7170: LD_EXP 26
7174: PPUSH
7175: LD_INT 4
7177: PPUSH
7178: LD_INT 107
7180: PPUSH
7181: LD_INT 130
7183: PPUSH
7184: LD_INT 0
7186: PPUSH
7187: CALL_OW 145
// repeat wait ( 1 ) ;
7191: LD_INT 1
7193: PPUSH
7194: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7198: LD_INT 30
7200: PUSH
7201: LD_INT 4
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 23
7210: PUSH
7211: LD_INT 2
7213: PUSH
7214: EMPTY
7215: LIST
7216: LIST
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PPUSH
7222: CALL_OW 69
7226: IFFALSE 7191
// SetSide ( Gali , 2 ) ;
7228: LD_EXP 26
7232: PPUSH
7233: LD_INT 2
7235: PPUSH
7236: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7240: LD_ADDR_VAR 0 8
7244: PUSH
7245: LD_INT 30
7247: PUSH
7248: LD_INT 4
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PUSH
7255: LD_INT 23
7257: PUSH
7258: LD_INT 2
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PPUSH
7269: CALL_OW 69
7273: PUSH
7274: LD_INT 1
7276: ARRAY
7277: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7278: LD_INT 35
7280: PPUSH
7281: CALL_OW 67
// if player_attacked_ar then
7285: LD_EXP 16
7289: IFFALSE 7293
// exit ;
7291: GO 8959
// until BuildingStatus ( b ) <> bs_build ;
7293: LD_VAR 0 8
7297: PPUSH
7298: CALL_OW 461
7302: PUSH
7303: LD_INT 1
7305: NONEQUAL
7306: IFFALSE 7278
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7308: LD_VAR 0 8
7312: PPUSH
7313: CALL_OW 302
7317: PUSH
7318: LD_VAR 0 4
7322: PPUSH
7323: CALL_OW 274
7327: PPUSH
7328: LD_INT 1
7330: PPUSH
7331: CALL_OW 275
7335: PUSH
7336: LD_INT 25
7338: GREATEREQUAL
7339: AND
7340: IFFALSE 7439
// begin ComUpgrade ( b ) ;
7342: LD_VAR 0 8
7346: PPUSH
7347: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7351: LD_EXP 26
7355: PPUSH
7356: LD_STRING h
7358: PUSH
7359: LD_VAR 0 8
7363: PPUSH
7364: CALL_OW 250
7368: PUSH
7369: LD_VAR 0 8
7373: PPUSH
7374: CALL_OW 251
7378: PUSH
7379: LD_VAR 0 8
7383: PUSH
7384: LD_INT 0
7386: PUSH
7387: LD_INT 0
7389: PUSH
7390: LD_INT 0
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: PUSH
7402: EMPTY
7403: LIST
7404: PPUSH
7405: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7409: LD_INT 35
7411: PPUSH
7412: CALL_OW 67
// if player_attacked_ar then
7416: LD_EXP 16
7420: IFFALSE 7424
// exit ;
7422: GO 8959
// until BuildingStatus ( b ) <> bs_build ;
7424: LD_VAR 0 8
7428: PPUSH
7429: CALL_OW 461
7433: PUSH
7434: LD_INT 1
7436: NONEQUAL
7437: IFFALSE 7409
// end ; if b then
7439: LD_VAR 0 8
7443: IFFALSE 7454
// CenterNowOnUnits ( b ) ;
7445: LD_VAR 0 8
7449: PPUSH
7450: CALL_OW 87
// DialogueOn ;
7454: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7458: LD_EXP 26
7462: PPUSH
7463: LD_STRING D9d-Ar2-1
7465: PPUSH
7466: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7470: LD_EXP 25
7474: PPUSH
7475: LD_STRING D9d-Ar1-1
7477: PPUSH
7478: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7482: LD_EXP 17
7486: PPUSH
7487: LD_STRING D9d-JMM-1
7489: PPUSH
7490: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7494: LD_EXP 25
7498: PPUSH
7499: LD_STRING D9d-Ar1-2
7501: PPUSH
7502: CALL_OW 88
// DialogueOff ;
7506: CALL_OW 7
// i := [ ] ;
7510: LD_ADDR_VAR 0 1
7514: PUSH
7515: EMPTY
7516: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7517: LD_VAR 0 4
7521: PPUSH
7522: CALL_OW 274
7526: PPUSH
7527: LD_INT 3
7529: PPUSH
7530: CALL_OW 275
7534: PUSH
7535: LD_INT 20
7537: GREATEREQUAL
7538: IFFALSE 7557
// i := i ^ [ 1 ] ;
7540: LD_ADDR_VAR 0 1
7544: PUSH
7545: LD_VAR 0 1
7549: PUSH
7550: LD_INT 1
7552: PUSH
7553: EMPTY
7554: LIST
7555: ADD
7556: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7557: LD_VAR 0 4
7561: PPUSH
7562: CALL_OW 274
7566: PPUSH
7567: LD_INT 1
7569: PPUSH
7570: CALL_OW 275
7574: PUSH
7575: LD_INT 50
7577: GREATEREQUAL
7578: IFFALSE 7597
// i := i ^ [ 2 ] ;
7580: LD_ADDR_VAR 0 1
7584: PUSH
7585: LD_VAR 0 1
7589: PUSH
7590: LD_INT 2
7592: PUSH
7593: EMPTY
7594: LIST
7595: ADD
7596: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7597: LD_VAR 0 4
7601: PPUSH
7602: CALL_OW 274
7606: PPUSH
7607: LD_INT 2
7609: PPUSH
7610: CALL_OW 275
7614: PUSH
7615: LD_INT 80
7617: GREATEREQUAL
7618: IFFALSE 7637
// i := i ^ [ 3 ] ;
7620: LD_ADDR_VAR 0 1
7624: PUSH
7625: LD_VAR 0 1
7629: PUSH
7630: LD_INT 3
7632: PUSH
7633: EMPTY
7634: LIST
7635: ADD
7636: ST_TO_ADDR
// i := i diff 0 ;
7637: LD_ADDR_VAR 0 1
7641: PUSH
7642: LD_VAR 0 1
7646: PUSH
7647: LD_INT 0
7649: DIFF
7650: ST_TO_ADDR
// if i then
7651: LD_VAR 0 1
7655: IFFALSE 7761
// begin i := i ^ [ 4 ] ;
7657: LD_ADDR_VAR 0 1
7661: PUSH
7662: LD_VAR 0 1
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: EMPTY
7671: LIST
7672: ADD
7673: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7674: LD_STRING QInfo2
7676: PPUSH
7677: CALL_OW 97
7681: PUSH
7682: LD_INT 1
7684: DOUBLE
7685: EQUAL
7686: IFTRUE 7690
7688: GO 7701
7690: POP
// player_want_info := 3 ; 2 :
7691: LD_ADDR_EXP 13
7695: PUSH
7696: LD_INT 3
7698: ST_TO_ADDR
7699: GO 7759
7701: LD_INT 2
7703: DOUBLE
7704: EQUAL
7705: IFTRUE 7709
7707: GO 7720
7709: POP
// player_want_info := 1 ; 3 :
7710: LD_ADDR_EXP 13
7714: PUSH
7715: LD_INT 1
7717: ST_TO_ADDR
7718: GO 7759
7720: LD_INT 3
7722: DOUBLE
7723: EQUAL
7724: IFTRUE 7728
7726: GO 7739
7728: POP
// player_want_info := 2 ; 4 :
7729: LD_ADDR_EXP 13
7733: PUSH
7734: LD_INT 2
7736: ST_TO_ADDR
7737: GO 7759
7739: LD_INT 4
7741: DOUBLE
7742: EQUAL
7743: IFTRUE 7747
7745: GO 7758
7747: POP
// player_want_info := 0 ; end ;
7748: LD_ADDR_EXP 13
7752: PUSH
7753: LD_INT 0
7755: ST_TO_ADDR
7756: GO 7759
7758: POP
// end else
7759: GO 7789
// case Query ( QInfoNothing ) of 1 :
7761: LD_STRING QInfoNothing
7763: PPUSH
7764: CALL_OW 97
7768: PUSH
7769: LD_INT 1
7771: DOUBLE
7772: EQUAL
7773: IFTRUE 7777
7775: GO 7788
7777: POP
// player_want_info := 0 ; end ;
7778: LD_ADDR_EXP 13
7782: PUSH
7783: LD_INT 0
7785: ST_TO_ADDR
7786: GO 7789
7788: POP
// end ; end ; end ; if player_want_info then
7789: LD_EXP 13
7793: IFFALSE 8779
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7795: LD_ADDR_VAR 0 3
7799: PUSH
7800: LD_VAR 0 3
7804: PPUSH
7805: LD_INT 34
7807: PUSH
7808: LD_INT 32
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PPUSH
7815: CALL_OW 72
7819: ST_TO_ADDR
// if player_want_mortar then
7820: LD_EXP 12
7824: IFFALSE 8118
// begin case player_want_info of 1 :
7826: LD_EXP 13
7830: PUSH
7831: LD_INT 1
7833: DOUBLE
7834: EQUAL
7835: IFTRUE 7839
7837: GO 7850
7839: POP
// x := 5 ; 2 :
7840: LD_ADDR_VAR 0 2
7844: PUSH
7845: LD_INT 5
7847: ST_TO_ADDR
7848: GO 7889
7850: LD_INT 2
7852: DOUBLE
7853: EQUAL
7854: IFTRUE 7858
7856: GO 7869
7858: POP
// x := 8 ; 3 :
7859: LD_ADDR_VAR 0 2
7863: PUSH
7864: LD_INT 8
7866: ST_TO_ADDR
7867: GO 7889
7869: LD_INT 3
7871: DOUBLE
7872: EQUAL
7873: IFTRUE 7877
7875: GO 7888
7877: POP
// x := 2 ; end ;
7878: LD_ADDR_VAR 0 2
7882: PUSH
7883: LD_INT 2
7885: ST_TO_ADDR
7886: GO 7889
7888: POP
// for i = 1 to x do
7889: LD_ADDR_VAR 0 1
7893: PUSH
7894: DOUBLE
7895: LD_INT 1
7897: DEC
7898: ST_TO_ADDR
7899: LD_VAR 0 2
7903: PUSH
7904: FOR_TO
7905: IFFALSE 8061
// begin AddComTransport ( Gali , dep , player_want_info ) ;
7907: LD_EXP 26
7911: PPUSH
7912: LD_VAR 0 4
7916: PPUSH
7917: LD_EXP 13
7921: PPUSH
7922: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
7926: LD_EXP 26
7930: PPUSH
7931: LD_VAR 0 3
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: CALL_OW 172
// repeat wait ( 0 0$1 ) ;
7944: LD_INT 35
7946: PPUSH
7947: CALL_OW 67
// if player_attacked_ar then
7951: LD_EXP 16
7955: IFFALSE 7961
// exit ;
7957: POP
7958: POP
7959: GO 8959
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
7961: LD_EXP 26
7965: PPUSH
7966: LD_VAR 0 3
7970: PUSH
7971: LD_INT 1
7973: ARRAY
7974: PPUSH
7975: CALL_OW 296
7979: PUSH
7980: LD_INT 4
7982: LESS
7983: PUSH
7984: LD_EXP 26
7988: PPUSH
7989: LD_EXP 13
7993: PPUSH
7994: CALL_OW 289
7998: AND
7999: IFFALSE 7944
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8001: LD_VAR 0 3
8005: PUSH
8006: LD_INT 1
8008: ARRAY
8009: PPUSH
8010: LD_EXP 13
8014: PPUSH
8015: LD_VAR 0 3
8019: PUSH
8020: LD_INT 1
8022: ARRAY
8023: PPUSH
8024: LD_EXP 13
8028: PPUSH
8029: CALL_OW 289
8033: PUSH
8034: LD_INT 10
8036: PLUS
8037: PPUSH
8038: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8042: LD_EXP 26
8046: PPUSH
8047: LD_EXP 13
8051: PPUSH
8052: LD_INT 0
8054: PPUSH
8055: CALL_OW 290
// end ;
8059: GO 7904
8061: POP
8062: POP
// repeat wait ( 0 0$1 ) ;
8063: LD_INT 35
8065: PPUSH
8066: CALL_OW 67
// if player_attacked_ar then
8070: LD_EXP 16
8074: IFFALSE 8078
// exit ;
8076: GO 8959
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8078: LD_VAR 0 3
8082: PUSH
8083: LD_INT 1
8085: ARRAY
8086: PPUSH
8087: LD_EXP 13
8091: PPUSH
8092: CALL_OW 289
8096: PUSH
8097: LD_VAR 0 2
8101: PUSH
8102: LD_INT 10
8104: MUL
8105: EQUAL
8106: IFFALSE 8063
// no_oil_gain := false ;
8108: LD_ADDR_VAR 0 6
8112: PUSH
8113: LD_INT 0
8115: ST_TO_ADDR
// end else
8116: GO 8600
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8118: LD_ADDR_VAR 0 3
8122: PUSH
8123: LD_INT 22
8125: PUSH
8126: LD_INT 2
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: PUSH
8133: LD_INT 21
8135: PUSH
8136: LD_INT 2
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 69
8151: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8152: LD_EXP 26
8156: PPUSH
8157: LD_VAR 0 4
8161: PPUSH
8162: CALL_OW 250
8166: PUSH
8167: LD_INT 1
8169: PLUS
8170: PPUSH
8171: LD_VAR 0 4
8175: PPUSH
8176: CALL_OW 251
8180: PUSH
8181: LD_INT 1
8183: PLUS
8184: PPUSH
8185: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8189: LD_INT 35
8191: PPUSH
8192: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8196: LD_EXP 26
8200: PPUSH
8201: LD_VAR 0 4
8205: PPUSH
8206: CALL_OW 296
8210: PUSH
8211: LD_INT 4
8213: LESS
8214: IFFALSE 8189
// for i = 1 to 6 do
8216: LD_ADDR_VAR 0 1
8220: PUSH
8221: DOUBLE
8222: LD_INT 1
8224: DEC
8225: ST_TO_ADDR
8226: LD_INT 6
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8427
// begin if player_attacked_ar then
8232: LD_EXP 16
8236: IFFALSE 8242
// exit ;
8238: POP
8239: POP
8240: GO 8959
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8242: LD_VAR 0 4
8246: PPUSH
8247: CALL_OW 274
8251: PPUSH
8252: LD_INT 2
8254: PPUSH
8255: CALL_OW 275
8259: PUSH
8260: LD_INT 10
8262: LESS
8263: PUSH
8264: LD_VAR 0 7
8268: NOT
8269: AND
8270: IFFALSE 8333
// begin first_warn := true ;
8272: LD_ADDR_VAR 0 7
8276: PUSH
8277: LD_INT 1
8279: ST_TO_ADDR
// DialogueOn ;
8280: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8284: LD_EXP 27
8288: PPUSH
8289: LD_STRING D9a-FAr1-1
8291: PPUSH
8292: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8296: LD_EXP 17
8300: PPUSH
8301: LD_STRING D9a-JMM-1
8303: PPUSH
8304: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8308: LD_EXP 25
8312: PPUSH
8313: LD_STRING D9a2-Ar1-1
8315: PPUSH
8316: CALL_OW 88
// DialogueOff ;
8320: CALL_OW 7
// wait ( time ) ;
8324: LD_VAR 0 5
8328: PPUSH
8329: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8333: LD_VAR 0 4
8337: PPUSH
8338: CALL_OW 274
8342: PPUSH
8343: LD_INT 2
8345: PPUSH
8346: CALL_OW 275
8350: PUSH
8351: LD_INT 10
8353: LESS
8354: IFFALSE 8380
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8356: LD_EXP 25
8360: PPUSH
8361: LD_STRING D9a3-Ar1-1
8363: PPUSH
8364: CALL_OW 88
// no_oil_gain := true ;
8368: LD_ADDR_VAR 0 6
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// break ;
8376: GO 8427
// end else
8378: GO 8425
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8380: LD_EXP 26
8384: PPUSH
8385: LD_VAR 0 4
8389: PPUSH
8390: LD_INT 2
8392: PPUSH
8393: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8397: LD_EXP 26
8401: PPUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_VAR 0 1
8411: PUSH
8412: LD_INT 3
8414: MOD
8415: PUSH
8416: LD_INT 1
8418: PLUS
8419: ARRAY
8420: PPUSH
8421: CALL_OW 210
// end ; end ;
8425: GO 8229
8427: POP
8428: POP
// repeat wait ( 0 0$1 ) ;
8429: LD_INT 35
8431: PPUSH
8432: CALL_OW 67
// if player_attacked_ar then
8436: LD_EXP 16
8440: IFFALSE 8444
// exit ;
8442: GO 8959
// for i in tmp do
8444: LD_ADDR_VAR 0 1
8448: PUSH
8449: LD_VAR 0 3
8453: PUSH
8454: FOR_IN
8455: IFFALSE 8486
// if GetFuel ( i ) < 100 then
8457: LD_VAR 0 1
8461: PPUSH
8462: CALL_OW 261
8466: PUSH
8467: LD_INT 100
8469: LESS
8470: IFFALSE 8484
// begin x := i ;
8472: LD_ADDR_VAR 0 2
8476: PUSH
8477: LD_VAR 0 1
8481: ST_TO_ADDR
// break ;
8482: GO 8486
// end ;
8484: GO 8454
8486: POP
8487: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8488: LD_EXP 26
8492: PPUSH
8493: CALL_OW 314
8497: NOT
8498: PUSH
8499: LD_EXP 26
8503: PPUSH
8504: CALL_OW 281
8508: NOT
8509: AND
8510: IFFALSE 8543
// begin ComTransport ( Gali , dep , mat_oil ) ;
8512: LD_EXP 26
8516: PPUSH
8517: LD_VAR 0 4
8521: PPUSH
8522: LD_INT 2
8524: PPUSH
8525: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8529: LD_EXP 26
8533: PPUSH
8534: LD_VAR 0 2
8538: PPUSH
8539: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8543: LD_VAR 0 3
8547: PUSH
8548: LD_INT 1
8550: ARRAY
8551: PPUSH
8552: CALL_OW 261
8556: PUSH
8557: LD_INT 80
8559: GREATER
8560: PUSH
8561: LD_VAR 0 3
8565: PUSH
8566: LD_INT 2
8568: ARRAY
8569: PPUSH
8570: CALL_OW 261
8574: PUSH
8575: LD_INT 80
8577: GREATER
8578: AND
8579: PUSH
8580: LD_VAR 0 3
8584: PUSH
8585: LD_INT 3
8587: ARRAY
8588: PPUSH
8589: CALL_OW 261
8593: PUSH
8594: LD_INT 80
8596: GREATER
8597: AND
8598: IFFALSE 8429
// end ; ComHold ( Gali ) ;
8600: LD_EXP 26
8604: PPUSH
8605: CALL_OW 140
// if not no_oil_gain then
8609: LD_VAR 0 6
8613: NOT
8614: IFFALSE 8779
// begin DialogueOn ;
8616: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8620: LD_EXP 25
8624: PPUSH
8625: CALL_OW 87
// if player_want_mortar then
8629: LD_EXP 12
8633: IFFALSE 8659
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8635: LD_EXP 25
8639: PPUSH
8640: LD_STRING D9e-Ar1-1
8642: PPUSH
8643: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8647: LD_EXP 17
8651: PPUSH
8652: LD_STRING D10a-JMM-1
8654: PPUSH
8655: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8659: LD_EXP 25
8663: PPUSH
8664: LD_STRING D10a-Ar1-1
8666: PPUSH
8667: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8671: LD_EXP 26
8675: PPUSH
8676: LD_STRING D10a-Ar2-1
8678: PPUSH
8679: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8683: LD_EXP 27
8687: PPUSH
8688: LD_STRING D10a-FAr1-1
8690: PPUSH
8691: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8695: LD_EXP 26
8699: PPUSH
8700: LD_STRING D10a-Ar2-2
8702: PPUSH
8703: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8707: LD_EXP 27
8711: PPUSH
8712: LD_STRING D10a-FAr1-2
8714: PPUSH
8715: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8719: LD_EXP 25
8723: PPUSH
8724: LD_STRING D10a-Ar1-2
8726: PPUSH
8727: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8731: LD_EXP 17
8735: PPUSH
8736: LD_STRING D10a-JMM-2
8738: PPUSH
8739: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8743: LD_EXP 25
8747: PPUSH
8748: LD_STRING D10a-Ar1-3
8750: PPUSH
8751: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8755: LD_EXP 17
8759: PPUSH
8760: LD_STRING D10a-JMM-3
8762: PPUSH
8763: CALL_OW 88
// player_get_info := true ;
8767: LD_ADDR_EXP 15
8771: PUSH
8772: LD_INT 1
8774: ST_TO_ADDR
// DialogueOff ;
8775: CALL_OW 7
// end ; end ; if player_attacked_ar then
8779: LD_EXP 16
8783: IFFALSE 8787
// exit ;
8785: GO 8959
// if player_want_mortar or player_want_info then
8787: LD_EXP 12
8791: PUSH
8792: LD_EXP 13
8796: OR
8797: IFFALSE 8811
// Say ( Vervecken , D9f-Ar1-1 ) ;
8799: LD_EXP 25
8803: PPUSH
8804: LD_STRING D9f-Ar1-1
8806: PPUSH
8807: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8811: LD_INT 22
8813: PUSH
8814: LD_INT 2
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: PPUSH
8826: LD_INT 51
8828: PPUSH
8829: LD_INT 99
8831: PPUSH
8832: CALL_OW 111
// wait ( 0 0$1 ) ;
8836: LD_INT 35
8838: PPUSH
8839: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
8843: LD_INT 22
8845: PUSH
8846: LD_INT 2
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: LD_INT 92
8855: PUSH
8856: LD_INT 51
8858: PUSH
8859: LD_INT 99
8861: PUSH
8862: LD_INT 2
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PPUSH
8875: CALL_OW 69
8879: IFFALSE 8939
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
8881: LD_ADDR_VAR 0 1
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_INT 2
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: LD_INT 92
8898: PUSH
8899: LD_INT 51
8901: PUSH
8902: LD_INT 99
8904: PUSH
8905: LD_INT 2
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: LIST
8912: LIST
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PPUSH
8918: CALL_OW 69
8922: PUSH
8923: FOR_IN
8924: IFFALSE 8937
// RemoveUnit ( i ) ;
8926: LD_VAR 0 1
8930: PPUSH
8931: CALL_OW 64
8935: GO 8923
8937: POP
8938: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
8939: LD_INT 22
8941: PUSH
8942: LD_INT 2
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: PPUSH
8949: CALL_OW 69
8953: PUSH
8954: LD_INT 0
8956: EQUAL
8957: IFFALSE 8811
// end ;
8959: PPOPN 8
8961: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
8962: LD_EXP 16
8966: IFFALSE 9319
8968: GO 8970
8970: DISABLE
8971: LD_INT 0
8973: PPUSH
8974: PPUSH
8975: PPUSH
8976: PPUSH
// begin ru_can_attack := true ;
8977: LD_ADDR_EXP 8
8981: PUSH
8982: LD_INT 1
8984: ST_TO_ADDR
// mine_launched := false ;
8985: LD_ADDR_VAR 0 3
8989: PUSH
8990: LD_INT 0
8992: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8993: LD_INT 22
8995: PUSH
8996: LD_INT 2
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: PPUSH
9003: CALL_OW 69
9007: PPUSH
9008: LD_INT 51
9010: PPUSH
9011: LD_INT 99
9013: PPUSH
9014: CALL_OW 111
// if IsOk ( Vervecken ) then
9018: LD_EXP 25
9022: PPUSH
9023: CALL_OW 302
9027: IFFALSE 9041
// Say ( Vervecken , D11a-Ar1-1 ) ;
9029: LD_EXP 25
9033: PPUSH
9034: LD_STRING D11a-Ar1-1
9036: PPUSH
9037: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9041: LD_ADDR_VAR 0 2
9045: PUSH
9046: LD_EXP 32
9050: PPUSH
9051: LD_INT 25
9053: PUSH
9054: LD_INT 1
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: PPUSH
9061: CALL_OW 72
9065: ST_TO_ADDR
// for i in tmp do
9066: LD_ADDR_VAR 0 1
9070: PUSH
9071: LD_VAR 0 2
9075: PUSH
9076: FOR_IN
9077: IFFALSE 9140
// if MineOfUnit ( i ) then
9079: LD_VAR 0 1
9083: PPUSH
9084: CALL_OW 459
9088: IFFALSE 9138
// begin x := MineOfUnit ( i ) ;
9090: LD_ADDR_VAR 0 4
9094: PUSH
9095: LD_VAR 0 1
9099: PPUSH
9100: CALL_OW 459
9104: ST_TO_ADDR
// mine_launched := true ;
9105: LD_ADDR_VAR 0 3
9109: PUSH
9110: LD_INT 1
9112: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9113: LD_VAR 0 4
9117: PUSH
9118: LD_INT 1
9120: ARRAY
9121: PPUSH
9122: LD_VAR 0 4
9126: PUSH
9127: LD_INT 2
9129: ARRAY
9130: PPUSH
9131: LD_INT 2
9133: PPUSH
9134: CALL_OW 456
// end ;
9138: GO 9076
9140: POP
9141: POP
// if mine_launched and IsOk ( Vervecken ) then
9142: LD_VAR 0 3
9146: PUSH
9147: LD_EXP 25
9151: PPUSH
9152: CALL_OW 302
9156: AND
9157: IFFALSE 9171
// Say ( Vervecken , D11b-Ar1-1 ) ;
9159: LD_EXP 25
9163: PPUSH
9164: LD_STRING D11b-Ar1-1
9166: PPUSH
9167: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9171: LD_INT 22
9173: PUSH
9174: LD_INT 2
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PPUSH
9181: CALL_OW 69
9185: PPUSH
9186: LD_INT 51
9188: PPUSH
9189: LD_INT 99
9191: PPUSH
9192: CALL_OW 111
// wait ( 0 0$1 ) ;
9196: LD_INT 35
9198: PPUSH
9199: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9203: LD_INT 22
9205: PUSH
9206: LD_INT 2
9208: PUSH
9209: EMPTY
9210: LIST
9211: LIST
9212: PUSH
9213: LD_INT 92
9215: PUSH
9216: LD_INT 51
9218: PUSH
9219: LD_INT 99
9221: PUSH
9222: LD_INT 2
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PPUSH
9235: CALL_OW 69
9239: IFFALSE 9299
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9241: LD_ADDR_VAR 0 1
9245: PUSH
9246: LD_INT 22
9248: PUSH
9249: LD_INT 2
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: PUSH
9256: LD_INT 92
9258: PUSH
9259: LD_INT 51
9261: PUSH
9262: LD_INT 99
9264: PUSH
9265: LD_INT 2
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: PUSH
9283: FOR_IN
9284: IFFALSE 9297
// RemoveUnit ( i ) ;
9286: LD_VAR 0 1
9290: PPUSH
9291: CALL_OW 64
9295: GO 9283
9297: POP
9298: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9299: LD_INT 22
9301: PUSH
9302: LD_INT 2
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: IFFALSE 9171
// end ;
9319: PPOPN 4
9321: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9322: LD_EXP 10
9326: IFFALSE 9505
9328: GO 9330
9330: DISABLE
9331: LD_INT 0
9333: PPUSH
// begin Wait ( 10 10$00 ) ;
9334: LD_INT 21000
9336: PPUSH
9337: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9341: LD_INT 22
9343: PUSH
9344: LD_INT 2
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: PPUSH
9351: CALL_OW 69
9355: IFFALSE 9505
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9357: LD_INT 22
9359: PUSH
9360: LD_INT 2
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: PPUSH
9367: CALL_OW 69
9371: PPUSH
9372: LD_INT 51
9374: PPUSH
9375: LD_INT 99
9377: PPUSH
9378: CALL_OW 114
// wait ( 0 0$1 ) ;
9382: LD_INT 35
9384: PPUSH
9385: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 2
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 92
9401: PUSH
9402: LD_INT 51
9404: PUSH
9405: LD_INT 99
9407: PUSH
9408: LD_INT 2
9410: PUSH
9411: EMPTY
9412: LIST
9413: LIST
9414: LIST
9415: LIST
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PPUSH
9421: CALL_OW 69
9425: IFFALSE 9485
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9427: LD_ADDR_VAR 0 1
9431: PUSH
9432: LD_INT 22
9434: PUSH
9435: LD_INT 2
9437: PUSH
9438: EMPTY
9439: LIST
9440: LIST
9441: PUSH
9442: LD_INT 92
9444: PUSH
9445: LD_INT 51
9447: PUSH
9448: LD_INT 99
9450: PUSH
9451: LD_INT 2
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: EMPTY
9461: LIST
9462: LIST
9463: PPUSH
9464: CALL_OW 69
9468: PUSH
9469: FOR_IN
9470: IFFALSE 9483
// RemoveUnit ( i ) ;
9472: LD_VAR 0 1
9476: PPUSH
9477: CALL_OW 64
9481: GO 9469
9483: POP
9484: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9485: LD_INT 22
9487: PUSH
9488: LD_INT 2
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PPUSH
9495: CALL_OW 69
9499: PUSH
9500: LD_INT 0
9502: EQUAL
9503: IFFALSE 9357
// end ; end ;
9505: PPOPN 1
9507: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9508: LD_EXP 4
9512: IFFALSE 10294
9514: GO 9516
9516: DISABLE
9517: LD_INT 0
9519: PPUSH
9520: PPUSH
9521: PPUSH
// begin Wait ( game_time ) ;
9522: LD_EXP 7
9526: PPUSH
9527: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9531: LD_INT 35
9533: PPUSH
9534: CALL_OW 67
// until ( not ru_can_attack ) ;
9538: LD_EXP 8
9542: NOT
9543: IFFALSE 9531
// Wait ( 0 0$35 ) ;
9545: LD_INT 1225
9547: PPUSH
9548: CALL_OW 67
// DialogueOn ;
9552: CALL_OW 6
// InGameOn ;
9556: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9560: LD_EXP 24
9564: PPUSH
9565: LD_STRING D12-Pow-1
9567: PPUSH
9568: CALL_OW 94
// InGameOff ;
9572: CALL_OW 9
// DialogueOff ;
9576: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9580: LD_STRING M4
9582: PPUSH
9583: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9587: LD_INT 5
9589: PPUSH
9590: LD_INT 1
9592: PPUSH
9593: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
9597: LD_INT 35
9599: PPUSH
9600: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_driving ] ] ] ) ;
9604: LD_INT 22
9606: PUSH
9607: LD_INT 1
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 21
9616: PUSH
9617: LD_INT 1
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: PPUSH
9628: CALL_OW 69
9632: PUSH
9633: LD_INT 5
9635: PPUSH
9636: LD_INT 22
9638: PUSH
9639: LD_INT 1
9641: PUSH
9642: EMPTY
9643: LIST
9644: LIST
9645: PUSH
9646: LD_INT 2
9648: PUSH
9649: LD_INT 21
9651: PUSH
9652: LD_INT 1
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: PUSH
9659: LD_INT 55
9661: PUSH
9662: EMPTY
9663: LIST
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PPUSH
9674: CALL_OW 70
9678: EQUAL
9679: IFFALSE 9597
// if not player_get_info then
9681: LD_EXP 15
9685: NOT
9686: IFFALSE 9697
// player_get_info := - 1 ;
9688: LD_ADDR_EXP 15
9692: PUSH
9693: LD_INT 1
9695: NEG
9696: ST_TO_ADDR
// AddMedal ( player_get_info , Information ) ;
9697: LD_EXP 15
9701: PPUSH
9702: LD_STRING Information
9704: PPUSH
9705: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9709: LD_ADDR_VAR 0 2
9713: PUSH
9714: LD_INT 22
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: LD_INT 2
9726: PUSH
9727: LD_INT 25
9729: PUSH
9730: LD_INT 2
9732: PUSH
9733: EMPTY
9734: LIST
9735: LIST
9736: PUSH
9737: LD_INT 25
9739: PUSH
9740: LD_INT 16
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: PUSH
9747: LD_INT 34
9749: PUSH
9750: LD_INT 12
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: ST_TO_ADDR
// sib := GetTerminalCargo ;
9772: LD_ADDR_VAR 0 3
9776: PUSH
9777: CALL 752 0 0
9781: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
9782: LD_ADDR_VAR 0 3
9786: PUSH
9787: LD_VAR 0 3
9791: PUSH
9792: LD_INT 6
9794: PPUSH
9795: LD_INT 3
9797: PPUSH
9798: CALL_OW 287
9802: PLUS
9803: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
9804: LD_ADDR_VAR 0 3
9808: PUSH
9809: LD_VAR 0 3
9813: PUSH
9814: LD_VAR 0 2
9818: PPUSH
9819: LD_INT 3
9821: PPUSH
9822: CALL_OW 289
9826: PLUS
9827: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
9828: LD_VAR 0 3
9832: PUSH
9833: LD_INT 2
9835: PUSH
9836: LD_OWVAR 67
9840: PLUS
9841: PUSH
9842: LD_INT 50
9844: MUL
9845: LESS
9846: IFFALSE 9871
// AddMedal ( - 2 * Difficulty + 1 , MuchSiberite ) else
9848: LD_INT 2
9850: NEG
9851: PUSH
9852: LD_OWVAR 67
9856: MUL
9857: PUSH
9858: LD_INT 1
9860: PLUS
9861: PPUSH
9862: LD_STRING MuchSiberite
9864: PPUSH
9865: CALL_OW 101
9869: GO 9881
// AddMedal ( 1 , MuchSiberite ) ;
9871: LD_INT 1
9873: PPUSH
9874: LD_STRING MuchSiberite
9876: PPUSH
9877: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
9881: LD_INT 22
9883: PUSH
9884: LD_INT 1
9886: PUSH
9887: EMPTY
9888: LIST
9889: LIST
9890: PUSH
9891: LD_INT 2
9893: PUSH
9894: LD_INT 25
9896: PUSH
9897: LD_INT 1
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 25
9906: PUSH
9907: LD_INT 2
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 25
9916: PUSH
9917: LD_INT 3
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: LD_INT 25
9926: PUSH
9927: LD_INT 4
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 25
9936: PUSH
9937: LD_INT 8
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: PUSH
9952: EMPTY
9953: LIST
9954: LIST
9955: PPUSH
9956: CALL_OW 69
9960: PPUSH
9961: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
9965: LD_ADDR_VAR 0 2
9969: PUSH
9970: LD_INT 22
9972: PUSH
9973: LD_INT 1
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 8
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: PPUSH
9994: CALL_OW 69
9998: ST_TO_ADDR
// if tmp then
9999: LD_VAR 0 2
10003: IFFALSE 10034
// for i in tmp do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_VAR 0 2
10014: PUSH
10015: FOR_IN
10016: IFFALSE 10032
// SetClass ( i , 1 ) ;
10018: LD_VAR 0 1
10022: PPUSH
10023: LD_INT 1
10025: PPUSH
10026: CALL_OW 336
10030: GO 10015
10032: POP
10033: POP
// SaveVariable ( sib , 09_sibRes ) ;
10034: LD_VAR 0 3
10038: PPUSH
10039: LD_STRING 09_sibRes
10041: PPUSH
10042: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10046: LD_EXP 15
10050: PPUSH
10051: LD_STRING 09_arInfo
10053: PPUSH
10054: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10058: LD_EXP 17
10062: PPUSH
10063: LD_EXP 1
10067: PUSH
10068: LD_STRING JMM
10070: STR
10071: PPUSH
10072: CALL_OW 38
// if IsLive ( Gary ) then
10076: LD_EXP 18
10080: PPUSH
10081: CALL_OW 300
10085: IFFALSE 10105
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10087: LD_EXP 18
10091: PPUSH
10092: LD_EXP 1
10096: PUSH
10097: LD_STRING Gary
10099: STR
10100: PPUSH
10101: CALL_OW 38
// if IsLive ( Bobby ) then
10105: LD_EXP 19
10109: PPUSH
10110: CALL_OW 300
10114: IFFALSE 10134
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10116: LD_EXP 19
10120: PPUSH
10121: LD_EXP 1
10125: PUSH
10126: LD_STRING Bobby
10128: STR
10129: PPUSH
10130: CALL_OW 38
// if IsLive ( Cyrus ) then
10134: LD_EXP 20
10138: PPUSH
10139: CALL_OW 300
10143: IFFALSE 10163
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10145: LD_EXP 20
10149: PPUSH
10150: LD_EXP 1
10154: PUSH
10155: LD_STRING Cyrus
10157: STR
10158: PPUSH
10159: CALL_OW 38
// if IsLive ( Houten ) then
10163: LD_EXP 21
10167: PPUSH
10168: CALL_OW 300
10172: IFFALSE 10192
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10174: LD_EXP 21
10178: PPUSH
10179: LD_EXP 1
10183: PUSH
10184: LD_STRING Houten
10186: STR
10187: PPUSH
10188: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10192: LD_ADDR_VAR 0 2
10196: PUSH
10197: LD_INT 22
10199: PUSH
10200: LD_INT 1
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 2
10209: PUSH
10210: LD_INT 25
10212: PUSH
10213: LD_INT 1
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 25
10222: PUSH
10223: LD_INT 2
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 25
10232: PUSH
10233: LD_INT 3
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: PUSH
10240: LD_INT 25
10242: PUSH
10243: LD_INT 4
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PPUSH
10261: CALL_OW 69
10265: ST_TO_ADDR
// if tmp then
10266: LD_VAR 0 2
10270: IFFALSE 10290
// SaveCharacters ( tmp , mission_prefix & others ) ;
10272: LD_VAR 0 2
10276: PPUSH
10277: LD_EXP 1
10281: PUSH
10282: LD_STRING others
10284: STR
10285: PPUSH
10286: CALL_OW 38
// YouWin ;
10290: CALL_OW 103
// end ; end_of_file
10294: PPOPN 3
10296: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10297: LD_VAR 0 1
10301: PPUSH
10302: CALL_OW 266
10306: PUSH
10307: LD_INT 0
10309: EQUAL
10310: PUSH
10311: LD_EXP 3
10315: NOT
10316: AND
10317: IFFALSE 10341
// begin terminal := b ;
10319: LD_ADDR_EXP 3
10323: PUSH
10324: LD_VAR 0 1
10328: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10329: LD_EXP 3
10333: PPUSH
10334: LD_STRING terminal
10336: PPUSH
10337: CALL_OW 500
// end ; end ;
10341: PPOPN 2
10343: END
// on BuildingComplete ( b ) do var i ;
10344: LD_INT 0
10346: PPUSH
// begin if GetSide ( b ) = 3 then
10347: LD_VAR 0 1
10351: PPUSH
10352: CALL_OW 255
10356: PUSH
10357: LD_INT 3
10359: EQUAL
10360: IFFALSE 10400
// for i = 1 to 4 do
10362: LD_ADDR_VAR 0 2
10366: PUSH
10367: DOUBLE
10368: LD_INT 1
10370: DEC
10371: ST_TO_ADDR
10372: LD_INT 4
10374: PUSH
10375: FOR_TO
10376: IFFALSE 10398
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10378: LD_ADDR_EXP 34
10382: PUSH
10383: LD_EXP 34
10387: PPUSH
10388: LD_INT 1
10390: PPUSH
10391: CALL_OW 3
10395: ST_TO_ADDR
10396: GO 10375
10398: POP
10399: POP
// end ;
10400: PPOPN 2
10402: END
// on VehicleConstructed ( veh , fac ) do var i ;
10403: LD_INT 0
10405: PPUSH
// begin if GetSide ( veh ) = 3 then
10406: LD_VAR 0 1
10410: PPUSH
10411: CALL_OW 255
10415: PUSH
10416: LD_INT 3
10418: EQUAL
10419: IFFALSE 10544
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10421: LD_VAR 0 1
10425: PPUSH
10426: CALL_OW 264
10430: PUSH
10431: LD_INT 53
10433: PUSH
10434: LD_INT 52
10436: PUSH
10437: LD_INT 51
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: LIST
10444: IN
10445: NOT
10446: IFFALSE 10464
// ru_force := ru_force ^ veh ;
10448: LD_ADDR_EXP 33
10452: PUSH
10453: LD_EXP 33
10457: PUSH
10458: LD_VAR 0 1
10462: ADD
10463: ST_TO_ADDR
// for i = 1 to 4 do
10464: LD_ADDR_VAR 0 3
10468: PUSH
10469: DOUBLE
10470: LD_INT 1
10472: DEC
10473: ST_TO_ADDR
10474: LD_INT 4
10476: PUSH
10477: FOR_TO
10478: IFFALSE 10500
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10480: LD_ADDR_EXP 35
10484: PUSH
10485: LD_EXP 35
10489: PPUSH
10490: LD_INT 1
10492: PPUSH
10493: CALL_OW 3
10497: ST_TO_ADDR
10498: GO 10477
10500: POP
10501: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10502: LD_VAR 0 1
10506: PPUSH
10507: CALL_OW 264
10511: PUSH
10512: LD_INT 53
10514: EQUAL
10515: IFFALSE 10544
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 7
10524: PPUSH
10525: CALL 910 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10529: LD_VAR 0 1
10533: PPUSH
10534: LD_INT 170
10536: PPUSH
10537: LD_INT 235
10539: PPUSH
10540: CALL_OW 171
// end ; end ; end ;
10544: PPOPN 3
10546: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10547: LD_VAR 0 1
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_INT 2
10563: EQUAL
10564: AND
10565: PUSH
10566: LD_VAR 0 1
10570: PUSH
10571: LD_INT 2
10573: EQUAL
10574: PUSH
10575: LD_VAR 0 2
10579: PUSH
10580: LD_INT 1
10582: EQUAL
10583: AND
10584: OR
10585: IFFALSE 10595
// player_attacked_ar := true ;
10587: LD_ADDR_EXP 16
10591: PUSH
10592: LD_INT 1
10594: ST_TO_ADDR
// end ;
10595: PPOPN 2
10597: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10598: LD_VAR 0 1
10602: PUSH
10603: LD_EXP 17
10607: EQUAL
10608: IFFALSE 10617
// YouLost ( JMM ) ;
10610: LD_STRING JMM
10612: PPUSH
10613: CALL_OW 104
// if un = terminal then
10617: LD_VAR 0 1
10621: PUSH
10622: LD_EXP 3
10626: EQUAL
10627: IFFALSE 10636
// YouLost ( Terminal ) ;
10629: LD_STRING Terminal
10631: PPUSH
10632: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10636: LD_VAR 0 1
10640: PUSH
10641: LD_INT 22
10643: PUSH
10644: LD_INT 3
10646: PUSH
10647: EMPTY
10648: LIST
10649: LIST
10650: PUSH
10651: LD_INT 21
10653: PUSH
10654: LD_INT 3
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PPUSH
10665: CALL_OW 69
10669: IN
10670: IFFALSE 10816
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10672: LD_VAR 0 1
10676: PPUSH
10677: CALL_OW 266
10681: PUSH
10682: LD_INT 33
10684: PUSH
10685: LD_INT 26
10687: PUSH
10688: EMPTY
10689: LIST
10690: LIST
10691: IN
10692: IFFALSE 10751
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10694: LD_ADDR_EXP 34
10698: PUSH
10699: LD_EXP 34
10703: PUSH
10704: LD_VAR 0 1
10708: PPUSH
10709: CALL_OW 266
10713: PUSH
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL_OW 250
10723: PUSH
10724: LD_VAR 0 1
10728: PPUSH
10729: CALL_OW 251
10733: PUSH
10734: LD_VAR 0 1
10738: PPUSH
10739: CALL_OW 254
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: ADD
10750: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10751: LD_VAR 0 1
10755: PPUSH
10756: CALL_OW 266
10760: PUSH
10761: LD_INT 5
10763: EQUAL
10764: IFFALSE 10816
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10766: LD_ADDR_EXP 34
10770: PUSH
10771: LD_EXP 34
10775: PUSH
10776: LD_INT 4
10778: PUSH
10779: LD_VAR 0 1
10783: PPUSH
10784: CALL_OW 250
10788: PUSH
10789: LD_VAR 0 1
10793: PPUSH
10794: CALL_OW 251
10798: PUSH
10799: LD_VAR 0 1
10803: PPUSH
10804: CALL_OW 254
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: LIST
10813: LIST
10814: ADD
10815: ST_TO_ADDR
// end ; if un in ru_force then
10816: LD_VAR 0 1
10820: PUSH
10821: LD_EXP 33
10825: IN
10826: IFFALSE 10859
// begin ru_force := ru_force diff un ;
10828: LD_ADDR_EXP 33
10832: PUSH
10833: LD_EXP 33
10837: PUSH
10838: LD_VAR 0 1
10842: DIFF
10843: ST_TO_ADDR
// if not ru_force then
10844: LD_EXP 33
10848: NOT
10849: IFFALSE 10859
// ru_can_attack := false ;
10851: LD_ADDR_EXP 8
10855: PUSH
10856: LD_INT 0
10858: ST_TO_ADDR
// end ; end ; end_of_file
10859: PPOPN 1
10861: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
10862: LD_EXP 5
10866: PUSH
10867: LD_EXP 6
10871: AND
10872: IFFALSE 10950
10874: GO 10876
10876: DISABLE
10877: LD_INT 0
10879: PPUSH
// begin enable ;
10880: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
10881: LD_ADDR_VAR 0 1
10885: PUSH
10886: LD_INT 60
10888: PUSH
10889: CALL 752 0 0
10893: MINUS
10894: ST_TO_ADDR
// if sib < 0 then
10895: LD_VAR 0 1
10899: PUSH
10900: LD_INT 0
10902: LESS
10903: IFFALSE 10913
// sib := 0 ;
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_INT 0
10912: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
10913: LD_ADDR_OWVAR 47
10917: PUSH
10918: LD_STRING #Am09-1
10920: PUSH
10921: LD_VAR 0 1
10925: PUSH
10926: LD_EXP 6
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
10936: LD_ADDR_EXP 6
10940: PUSH
10941: LD_EXP 6
10945: PUSH
10946: LD_INT 35
10948: MINUS
10949: ST_TO_ADDR
// end ;
10950: PPOPN 1
10952: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
10953: LD_EXP 6
10957: PUSH
10958: LD_INT 0
10960: EQUAL
10961: IFFALSE 10973
10963: GO 10965
10965: DISABLE
// display_strings := [ ] ;
10966: LD_ADDR_OWVAR 47
10970: PUSH
10971: EMPTY
10972: ST_TO_ADDR
10973: END
// every 0 0$35 + 1 1$0 marked 01 do
10974: GO 10976
10976: DISABLE
// begin enable ;
10977: ENABLE
// CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
10978: LD_INT 1
10980: PPUSH
10981: LD_INT 5
10983: PPUSH
10984: CALL_OW 12
10988: PPUSH
10989: LD_INT 75
10991: PPUSH
10992: LD_INT 75
10994: PPUSH
10995: LD_INT 20
10997: PPUSH
10998: LD_INT 1
11000: PPUSH
11001: CALL_OW 56
// if tick > [ 9 9$0 , 8 8$0 , 7 7$0 ] [ Difficulty ] then
11005: LD_OWVAR 1
11009: PUSH
11010: LD_INT 18900
11012: PUSH
11013: LD_INT 16800
11015: PUSH
11016: LD_INT 14700
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: LIST
11023: PUSH
11024: LD_OWVAR 67
11028: ARRAY
11029: GREATER
11030: IFFALSE 11035
// disable ( 01 ) ;
11032: LD_INT 1
11034: DISABLE_MARKED
// end ;
11035: END
// every 2 2$30 trigger jmm_in_ovsyenko do
11036: LD_EXP 4
11040: IFFALSE 11067
11042: GO 11044
11044: DISABLE
// begin enable ;
11045: ENABLE
// CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11046: LD_INT 2
11048: PPUSH
11049: LD_INT 5
11051: PPUSH
11052: CALL_OW 12
11056: PPUSH
11057: LD_INT 8
11059: PPUSH
11060: LD_INT 1
11062: PPUSH
11063: CALL_OW 55
// end ; end_of_file
11067: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11068: LD_INT 0
11070: PPUSH
11071: PPUSH
11072: PPUSH
11073: PPUSH
11074: PPUSH
11075: PPUSH
// x := 76 ;
11076: LD_ADDR_VAR 0 5
11080: PUSH
11081: LD_INT 76
11083: ST_TO_ADDR
// y := 147 ;
11084: LD_ADDR_VAR 0 6
11088: PUSH
11089: LD_INT 147
11091: ST_TO_ADDR
// uc_side := 2 ;
11092: LD_ADDR_OWVAR 20
11096: PUSH
11097: LD_INT 2
11099: ST_TO_ADDR
// uc_nation := 2 ;
11100: LD_ADDR_OWVAR 21
11104: PUSH
11105: LD_INT 2
11107: ST_TO_ADDR
// InitHc ;
11108: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11112: LD_INT 1
11114: PPUSH
11115: LD_INT 1
11117: PPUSH
11118: LD_INT 6
11120: PPUSH
11121: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11125: LD_ADDR_OWVAR 26
11129: PUSH
11130: LD_STRING Nicolas Vervecken
11132: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11133: LD_ADDR_OWVAR 33
11137: PUSH
11138: LD_STRING SecondCharsGal
11140: ST_TO_ADDR
// hc_face_number := 3 ;
11141: LD_ADDR_OWVAR 34
11145: PUSH
11146: LD_INT 3
11148: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11149: LD_ADDR_OWVAR 29
11153: PUSH
11154: LD_INT 11
11156: PUSH
11157: LD_INT 10
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: ST_TO_ADDR
// Vervecken := CreateHuman ;
11164: LD_ADDR_EXP 25
11168: PUSH
11169: CALL_OW 44
11173: ST_TO_ADDR
// ar_force := Vervecken ;
11174: LD_ADDR_EXP 32
11178: PUSH
11179: LD_EXP 25
11183: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11184: LD_INT 1
11186: PPUSH
11187: LD_INT 2
11189: PPUSH
11190: LD_INT 6
11192: PPUSH
11193: CALL_OW 380
// hc_name := Louis Gali ;
11197: LD_ADDR_OWVAR 26
11201: PUSH
11202: LD_STRING Louis Gali
11204: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11205: LD_ADDR_OWVAR 33
11209: PUSH
11210: LD_STRING SecondCharsGal
11212: ST_TO_ADDR
// hc_face_number := 2 ;
11213: LD_ADDR_OWVAR 34
11217: PUSH
11218: LD_INT 2
11220: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11221: LD_ADDR_OWVAR 29
11225: PUSH
11226: LD_INT 10
11228: PUSH
11229: LD_INT 11
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: ST_TO_ADDR
// Gali := CreateHuman ;
11236: LD_ADDR_EXP 26
11240: PUSH
11241: CALL_OW 44
11245: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11246: LD_ADDR_EXP 32
11250: PUSH
11251: LD_EXP 32
11255: PUSH
11256: LD_EXP 26
11260: ADD
11261: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11262: LD_INT 2
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 6
11270: PPUSH
11271: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11275: LD_ADDR_OWVAR 26
11279: PUSH
11280: LD_STRING Maria Bogdanovic
11282: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11283: LD_ADDR_OWVAR 33
11287: PUSH
11288: LD_STRING SecondCharsGal
11290: ST_TO_ADDR
// hc_face_number := 14 ;
11291: LD_ADDR_OWVAR 34
11295: PUSH
11296: LD_INT 14
11298: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11299: LD_ADDR_OWVAR 29
11303: PUSH
11304: LD_INT 12
11306: PUSH
11307: LD_INT 9
11309: PUSH
11310: EMPTY
11311: LIST
11312: LIST
11313: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11314: LD_ADDR_EXP 27
11318: PUSH
11319: CALL_OW 44
11323: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11324: LD_ADDR_EXP 32
11328: PUSH
11329: LD_EXP 32
11333: PUSH
11334: LD_EXP 27
11338: ADD
11339: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11340: LD_INT 1
11342: PPUSH
11343: LD_INT 3
11345: PPUSH
11346: LD_INT 6
11348: PPUSH
11349: CALL_OW 380
// hc_name = Kntor Radomr ;
11353: LD_ADDR_OWVAR 26
11357: PUSH
11358: LD_STRING Kntor Radomr
11360: ST_TO_ADDR
// hc_gallery = sandar ;
11361: LD_ADDR_OWVAR 33
11365: PUSH
11366: LD_STRING sandar
11368: ST_TO_ADDR
// hc_face_number = 12 ;
11369: LD_ADDR_OWVAR 34
11373: PUSH
11374: LD_INT 12
11376: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11377: LD_ADDR_OWVAR 29
11381: PUSH
11382: LD_INT 9
11384: PUSH
11385: LD_INT 9
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: ST_TO_ADDR
// Kantor = CreateHuman ;
11392: LD_ADDR_EXP 28
11396: PUSH
11397: CALL_OW 44
11401: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11402: LD_ADDR_EXP 32
11406: PUSH
11407: LD_EXP 32
11411: PUSH
11412: LD_EXP 28
11416: ADD
11417: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11418: LD_INT 1
11420: PPUSH
11421: LD_INT 3
11423: PPUSH
11424: LD_INT 6
11426: PPUSH
11427: CALL_OW 380
// hc_name = Herczeg Farkas ;
11431: LD_ADDR_OWVAR 26
11435: PUSH
11436: LD_STRING Herczeg Farkas
11438: ST_TO_ADDR
// hc_gallery = sandar ;
11439: LD_ADDR_OWVAR 33
11443: PUSH
11444: LD_STRING sandar
11446: ST_TO_ADDR
// hc_face_number = 28 ;
11447: LD_ADDR_OWVAR 34
11451: PUSH
11452: LD_INT 28
11454: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11455: LD_ADDR_OWVAR 29
11459: PUSH
11460: LD_INT 10
11462: PUSH
11463: LD_INT 9
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: ST_TO_ADDR
// Herczeg = CreateHuman ;
11470: LD_ADDR_EXP 29
11474: PUSH
11475: CALL_OW 44
11479: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11480: LD_ADDR_EXP 32
11484: PUSH
11485: LD_EXP 32
11489: PUSH
11490: LD_EXP 29
11494: ADD
11495: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11496: LD_INT 1
11498: PPUSH
11499: LD_INT 1
11501: PPUSH
11502: LD_INT 6
11504: PPUSH
11505: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11509: LD_ADDR_OWVAR 26
11513: PUSH
11514: LD_STRING Ronn Horntvedt
11516: ST_TO_ADDR
// hc_gallery = sandar ;
11517: LD_ADDR_OWVAR 33
11521: PUSH
11522: LD_STRING sandar
11524: ST_TO_ADDR
// hc_face_number = 29 ;
11525: LD_ADDR_OWVAR 34
11529: PUSH
11530: LD_INT 29
11532: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11533: LD_ADDR_OWVAR 29
11537: PUSH
11538: LD_INT 11
11540: PUSH
11541: LD_INT 11
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: ST_TO_ADDR
// Ronn = CreateHuman ;
11548: LD_ADDR_EXP 30
11552: PUSH
11553: CALL_OW 44
11557: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11558: LD_ADDR_EXP 32
11562: PUSH
11563: LD_EXP 32
11567: PUSH
11568: LD_EXP 30
11572: ADD
11573: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11574: LD_INT 2
11576: PPUSH
11577: LD_INT 3
11579: PPUSH
11580: LD_INT 6
11582: PPUSH
11583: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11587: LD_ADDR_OWVAR 26
11591: PUSH
11592: LD_STRING Mia D. Mathiasen
11594: ST_TO_ADDR
// hc_gallery = sandar ;
11595: LD_ADDR_OWVAR 33
11599: PUSH
11600: LD_STRING sandar
11602: ST_TO_ADDR
// hc_face_number = 31 ;
11603: LD_ADDR_OWVAR 34
11607: PUSH
11608: LD_INT 31
11610: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
11611: LD_ADDR_OWVAR 29
11615: PUSH
11616: LD_INT 10
11618: PUSH
11619: LD_INT 10
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: ST_TO_ADDR
// Mia = CreateHuman ;
11626: LD_ADDR_EXP 31
11630: PUSH
11631: CALL_OW 44
11635: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
11636: LD_ADDR_EXP 32
11640: PUSH
11641: LD_EXP 32
11645: PUSH
11646: LD_EXP 31
11650: ADD
11651: ST_TO_ADDR
// for i = 1 to 2 do
11652: LD_ADDR_VAR 0 4
11656: PUSH
11657: DOUBLE
11658: LD_INT 1
11660: DEC
11661: ST_TO_ADDR
11662: LD_INT 2
11664: PUSH
11665: FOR_TO
11666: IFFALSE 11707
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
11668: LD_ADDR_VAR 0 3
11672: PUSH
11673: LD_VAR 0 3
11677: PUSH
11678: LD_INT 2
11680: PPUSH
11681: LD_INT 2
11683: PPUSH
11684: LD_INT 14
11686: PPUSH
11687: LD_INT 1
11689: PPUSH
11690: LD_INT 1
11692: PPUSH
11693: LD_INT 32
11695: PPUSH
11696: LD_INT 30
11698: PPUSH
11699: CALL 252 0 7
11703: ADD
11704: ST_TO_ADDR
11705: GO 11665
11707: POP
11708: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
11709: LD_ADDR_VAR 0 3
11713: PUSH
11714: LD_VAR 0 3
11718: PUSH
11719: LD_INT 2
11721: PPUSH
11722: LD_INT 2
11724: PPUSH
11725: LD_INT 14
11727: PPUSH
11728: LD_INT 1
11730: PPUSH
11731: LD_INT 1
11733: PPUSH
11734: LD_INT 26
11736: PPUSH
11737: LD_INT 33
11739: PPUSH
11740: CALL 252 0 7
11744: ADD
11745: ST_TO_ADDR
// tmp := tmp diff 0 ;
11746: LD_ADDR_VAR 0 3
11750: PUSH
11751: LD_VAR 0 3
11755: PUSH
11756: LD_INT 0
11758: DIFF
11759: ST_TO_ADDR
// for i in ar_force do
11760: LD_ADDR_VAR 0 4
11764: PUSH
11765: LD_EXP 32
11769: PUSH
11770: FOR_IN
11771: IFFALSE 11914
// begin if GetClass ( i ) = 3 then
11773: LD_VAR 0 4
11777: PPUSH
11778: CALL_OW 257
11782: PUSH
11783: LD_INT 3
11785: EQUAL
11786: IFFALSE 11868
// begin SetDir ( tmp [ 1 ] , 1 ) ;
11788: LD_VAR 0 3
11792: PUSH
11793: LD_INT 1
11795: ARRAY
11796: PPUSH
11797: LD_INT 1
11799: PPUSH
11800: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
11804: LD_VAR 0 3
11808: PUSH
11809: LD_INT 1
11811: ARRAY
11812: PPUSH
11813: LD_VAR 0 5
11817: PPUSH
11818: LD_VAR 0 6
11822: PPUSH
11823: LD_INT 0
11825: PPUSH
11826: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
11830: LD_VAR 0 4
11834: PPUSH
11835: LD_VAR 0 3
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PPUSH
11844: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
11848: LD_ADDR_VAR 0 3
11852: PUSH
11853: LD_VAR 0 3
11857: PPUSH
11858: LD_INT 1
11860: PPUSH
11861: CALL_OW 3
11865: ST_TO_ADDR
// end else
11866: GO 11890
// PlaceUnitXY ( i , x , y , false ) ;
11868: LD_VAR 0 4
11872: PPUSH
11873: LD_VAR 0 5
11877: PPUSH
11878: LD_VAR 0 6
11882: PPUSH
11883: LD_INT 0
11885: PPUSH
11886: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
11890: LD_VAR 0 4
11894: PPUSH
11895: LD_INT 86
11897: PPUSH
11898: LD_INT 121
11900: PPUSH
11901: CALL_OW 111
// wait ( 0 0$2 ) ;
11905: LD_INT 70
11907: PPUSH
11908: CALL_OW 67
// end ;
11912: GO 11770
11914: POP
11915: POP
// ar_force := ar_force ^ tmp ;
11916: LD_ADDR_EXP 32
11920: PUSH
11921: LD_EXP 32
11925: PUSH
11926: LD_VAR 0 3
11930: ADD
11931: ST_TO_ADDR
// ar_spawned := true ;
11932: LD_ADDR_EXP 11
11936: PUSH
11937: LD_INT 1
11939: ST_TO_ADDR
// end ; end_of_file
11940: LD_VAR 0 1
11944: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
11945: LD_INT 0
11947: PPUSH
11948: PPUSH
11949: PPUSH
11950: PPUSH
11951: PPUSH
11952: PPUSH
11953: PPUSH
// InitHc ;
11954: CALL_OW 19
// uc_side := 3 ;
11958: LD_ADDR_OWVAR 20
11962: PUSH
11963: LD_INT 3
11965: ST_TO_ADDR
// uc_nation := 3 ;
11966: LD_ADDR_OWVAR 21
11970: PUSH
11971: LD_INT 3
11973: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
11974: LD_ADDR_VAR 0 5
11978: PUSH
11979: LD_INT 5
11981: PUSH
11982: LD_INT 6
11984: PUSH
11985: LD_INT 7
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: LIST
11992: PUSH
11993: LD_OWVAR 67
11997: ARRAY
11998: ST_TO_ADDR
// ru_force := [ ] ;
11999: LD_ADDR_EXP 33
12003: PUSH
12004: EMPTY
12005: ST_TO_ADDR
// ru_rebuild := [ ] ;
12006: LD_ADDR_EXP 34
12010: PUSH
12011: EMPTY
12012: ST_TO_ADDR
// ru_produce_list := [ ] ;
12013: LD_ADDR_EXP 35
12017: PUSH
12018: EMPTY
12019: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12020: LD_ADDR_VAR 0 6
12024: PUSH
12025: LD_INT 22
12027: PUSH
12028: LD_INT 3
12030: PUSH
12031: EMPTY
12032: LIST
12033: LIST
12034: PUSH
12035: LD_INT 30
12037: PUSH
12038: LD_INT 8
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: PPUSH
12049: CALL_OW 69
12053: PUSH
12054: LD_INT 1
12056: ARRAY
12057: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12058: LD_ADDR_VAR 0 4
12062: PUSH
12063: LD_INT 43
12065: PUSH
12066: LD_INT 46
12068: PUSH
12069: LD_INT 45
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: LIST
12076: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12077: LD_ADDR_VAR 0 7
12081: PUSH
12082: LD_INT 22
12084: PUSH
12085: LD_INT 3
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: LD_INT 30
12094: PUSH
12095: LD_INT 1
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PPUSH
12106: CALL_OW 69
12110: PUSH
12111: LD_INT 1
12113: ARRAY
12114: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12115: LD_VAR 0 7
12119: PPUSH
12120: CALL_OW 274
12124: PPUSH
12125: LD_INT 1
12127: PPUSH
12128: LD_INT 5000
12130: PPUSH
12131: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12135: LD_VAR 0 7
12139: PPUSH
12140: CALL_OW 274
12144: PPUSH
12145: LD_INT 2
12147: PPUSH
12148: LD_INT 1000
12150: PPUSH
12151: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12155: LD_VAR 0 7
12159: PPUSH
12160: CALL_OW 274
12164: PPUSH
12165: LD_INT 3
12167: PPUSH
12168: LD_INT 30
12170: PPUSH
12171: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12175: LD_ADDR_VAR 0 2
12179: PUSH
12180: LD_INT 22
12182: PUSH
12183: LD_INT 3
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: LD_INT 30
12192: PUSH
12193: LD_INT 33
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PPUSH
12204: CALL_OW 69
12208: PUSH
12209: FOR_IN
12210: IFFALSE 12242
// begin PlaceWeaponTurret ( i , tmp [ rand ( 1 , tmp ) ] ) ;
12212: LD_VAR 0 2
12216: PPUSH
12217: LD_VAR 0 4
12221: PUSH
12222: LD_INT 1
12224: PPUSH
12225: LD_VAR 0 4
12229: PPUSH
12230: CALL_OW 12
12234: ARRAY
12235: PPUSH
12236: CALL_OW 431
// end ;
12240: GO 12209
12242: POP
12243: POP
// for i = 1 to 4 do
12244: LD_ADDR_VAR 0 2
12248: PUSH
12249: DOUBLE
12250: LD_INT 1
12252: DEC
12253: ST_TO_ADDR
12254: LD_INT 4
12256: PUSH
12257: FOR_TO
12258: IFFALSE 12319
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12260: LD_INT 0
12262: PPUSH
12263: LD_INT 9
12265: PPUSH
12266: LD_VAR 0 5
12270: PPUSH
12271: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12275: CALL_OW 44
12279: PPUSH
12280: LD_INT 22
12282: PUSH
12283: LD_INT 3
12285: PUSH
12286: EMPTY
12287: LIST
12288: LIST
12289: PUSH
12290: LD_INT 30
12292: PUSH
12293: LD_INT 5
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: PPUSH
12304: CALL_OW 69
12308: PUSH
12309: LD_INT 1
12311: ARRAY
12312: PPUSH
12313: CALL_OW 52
// end ;
12317: GO 12257
12319: POP
12320: POP
// for i = 1 to 5 do
12321: LD_ADDR_VAR 0 2
12325: PUSH
12326: DOUBLE
12327: LD_INT 1
12329: DEC
12330: ST_TO_ADDR
12331: LD_INT 5
12333: PUSH
12334: FOR_TO
12335: IFFALSE 12396
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12337: LD_INT 0
12339: PPUSH
12340: LD_INT 3
12342: PPUSH
12343: LD_VAR 0 5
12347: PPUSH
12348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12352: CALL_OW 44
12356: PPUSH
12357: LD_INT 22
12359: PUSH
12360: LD_INT 3
12362: PUSH
12363: EMPTY
12364: LIST
12365: LIST
12366: PUSH
12367: LD_INT 30
12369: PUSH
12370: LD_INT 3
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PPUSH
12381: CALL_OW 69
12385: PUSH
12386: LD_INT 1
12388: ARRAY
12389: PPUSH
12390: CALL_OW 52
// end ;
12394: GO 12334
12396: POP
12397: POP
// for i = 1 to 4 do
12398: LD_ADDR_VAR 0 2
12402: PUSH
12403: DOUBLE
12404: LD_INT 1
12406: DEC
12407: ST_TO_ADDR
12408: LD_INT 4
12410: PUSH
12411: FOR_TO
12412: IFFALSE 12473
// begin PrepareHuman ( false , class_engineer , skill ) ;
12414: LD_INT 0
12416: PPUSH
12417: LD_INT 2
12419: PPUSH
12420: LD_VAR 0 5
12424: PPUSH
12425: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12429: CALL_OW 44
12433: PPUSH
12434: LD_INT 22
12436: PUSH
12437: LD_INT 3
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: LD_INT 30
12446: PUSH
12447: LD_INT 1
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PPUSH
12458: CALL_OW 69
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PPUSH
12467: CALL_OW 52
// end ;
12471: GO 12411
12473: POP
12474: POP
// for i = 1 to 3 do
12475: LD_ADDR_VAR 0 2
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_INT 3
12487: PUSH
12488: FOR_TO
12489: IFFALSE 12522
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12491: LD_INT 0
12493: PPUSH
12494: LD_INT 4
12496: PPUSH
12497: LD_VAR 0 5
12501: PPUSH
12502: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12506: CALL_OW 44
12510: PPUSH
12511: LD_VAR 0 6
12515: PPUSH
12516: CALL_OW 52
// end ;
12520: GO 12488
12522: POP
12523: POP
// AddComResearch ( lab , tech_tech2 ) ;
12524: LD_VAR 0 6
12528: PPUSH
12529: LD_INT 49
12531: PPUSH
12532: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12536: LD_VAR 0 6
12540: PPUSH
12541: LD_INT 50
12543: PPUSH
12544: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12548: LD_VAR 0 6
12552: PPUSH
12553: LD_INT 51
12555: PPUSH
12556: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12560: LD_VAR 0 6
12564: PPUSH
12565: LD_INT 52
12567: PPUSH
12568: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12572: LD_VAR 0 6
12576: PPUSH
12577: LD_INT 69
12579: PPUSH
12580: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12584: LD_VAR 0 6
12588: PPUSH
12589: LD_INT 39
12591: PPUSH
12592: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
12596: LD_VAR 0 6
12600: PPUSH
12601: LD_INT 34
12603: PPUSH
12604: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
12608: LD_VAR 0 6
12612: PPUSH
12613: LD_INT 40
12615: PPUSH
12616: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
12620: LD_VAR 0 6
12624: PPUSH
12625: LD_INT 57
12627: PPUSH
12628: CALL_OW 184
// if Difficulty > 1 then
12632: LD_OWVAR 67
12636: PUSH
12637: LD_INT 1
12639: GREATER
12640: IFFALSE 12654
// AddComResearch ( lab , tech_comp2 ) ;
12642: LD_VAR 0 6
12646: PPUSH
12647: LD_INT 58
12649: PPUSH
12650: CALL_OW 184
// end ;
12654: LD_VAR 0 1
12658: RET
// every 7 7$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 do
12659: LD_INT 7
12661: PPUSH
12662: CALL_OW 353
12666: PUSH
12667: LD_INT 3
12669: GREATER
12670: IFFALSE 12705
12672: GO 12674
12674: DISABLE
// begin enable ;
12675: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
12676: LD_ADDR_EXP 35
12680: PUSH
12681: LD_EXP 35
12685: PUSH
12686: LD_INT 24
12688: PUSH
12689: LD_INT 1
12691: PUSH
12692: LD_INT 3
12694: PUSH
12695: LD_INT 53
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: LIST
12702: LIST
12703: ADD
12704: ST_TO_ADDR
// end ;
12705: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
12706: LD_INT 22
12708: PUSH
12709: LD_INT 3
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: PUSH
12716: LD_INT 21
12718: PUSH
12719: LD_INT 3
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PPUSH
12730: CALL_OW 69
12734: IFFALSE 13512
12736: GO 12738
12738: DISABLE
12739: LD_INT 0
12741: PPUSH
12742: PPUSH
12743: PPUSH
12744: PPUSH
12745: PPUSH
12746: PPUSH
12747: PPUSH
12748: PPUSH
// begin enable ;
12749: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12750: LD_ADDR_VAR 0 3
12754: PUSH
12755: LD_INT 22
12757: PUSH
12758: LD_INT 3
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 21
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 3
12777: PUSH
12778: LD_INT 24
12780: PUSH
12781: LD_INT 1000
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: LIST
12796: PPUSH
12797: CALL_OW 69
12801: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12802: LD_ADDR_VAR 0 4
12806: PUSH
12807: LD_INT 22
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 25
12819: PUSH
12820: LD_INT 2
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PPUSH
12831: CALL_OW 69
12835: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12836: LD_ADDR_VAR 0 5
12840: PUSH
12841: LD_INT 22
12843: PUSH
12844: LD_INT 3
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 30
12853: PUSH
12854: LD_INT 1
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: PPUSH
12865: CALL_OW 69
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
12874: LD_ADDR_VAR 0 8
12878: PUSH
12879: LD_INT 22
12881: PUSH
12882: LD_INT 3
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: PUSH
12889: LD_INT 2
12891: PUSH
12892: LD_INT 30
12894: PUSH
12895: LD_INT 6
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 30
12904: PUSH
12905: LD_INT 7
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: LD_INT 30
12914: PUSH
12915: LD_INT 8
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PPUSH
12932: CALL_OW 69
12936: PUSH
12937: LD_INT 1
12939: ARRAY
12940: ST_TO_ADDR
// if not engs then
12941: LD_VAR 0 4
12945: NOT
12946: IFFALSE 12950
// exit ;
12948: GO 13512
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
12950: LD_ADDR_VAR 0 6
12954: PUSH
12955: LD_VAR 0 4
12959: PPUSH
12960: LD_INT 3
12962: PUSH
12963: LD_INT 24
12965: PUSH
12966: LD_INT 600
12968: PUSH
12969: EMPTY
12970: LIST
12971: LIST
12972: PUSH
12973: EMPTY
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 72
12981: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
12982: LD_ADDR_VAR 0 7
12986: PUSH
12987: LD_INT 22
12989: PUSH
12990: LD_INT 3
12992: PUSH
12993: EMPTY
12994: LIST
12995: LIST
12996: PUSH
12997: LD_INT 25
12999: PUSH
13000: LD_INT 4
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PPUSH
13011: CALL_OW 69
13015: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13016: LD_VAR 0 3
13020: NOT
13021: PUSH
13022: LD_EXP 34
13026: NOT
13027: AND
13028: IFFALSE 13088
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13030: LD_VAR 0 4
13034: PPUSH
13035: LD_INT 3
13037: PUSH
13038: LD_INT 54
13040: PUSH
13041: EMPTY
13042: LIST
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PPUSH
13048: CALL_OW 72
13052: IFFALSE 13086
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13054: LD_VAR 0 4
13058: PPUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 54
13064: PUSH
13065: EMPTY
13066: LIST
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PPUSH
13072: CALL_OW 72
13076: PPUSH
13077: LD_VAR 0 5
13081: PPUSH
13082: CALL_OW 120
// exit ;
13086: GO 13512
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13088: LD_VAR 0 4
13092: PPUSH
13093: LD_INT 54
13095: PUSH
13096: EMPTY
13097: LIST
13098: PPUSH
13099: CALL_OW 72
13103: IFFALSE 13125
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13105: LD_VAR 0 4
13109: PPUSH
13110: LD_INT 54
13112: PUSH
13113: EMPTY
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PPUSH
13121: CALL_OW 122
// if not tmp then
13125: LD_VAR 0 3
13129: NOT
13130: IFFALSE 13262
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13132: LD_INT 81
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 92
13144: PUSH
13145: LD_INT 147
13147: PUSH
13148: LD_INT 212
13150: PUSH
13151: LD_INT 30
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PPUSH
13164: CALL_OW 69
13168: NOT
13169: IFFALSE 13262
// begin if not HasTask ( engs [ 1 ] ) then
13171: LD_VAR 0 4
13175: PUSH
13176: LD_INT 1
13178: ARRAY
13179: PPUSH
13180: CALL_OW 314
13184: NOT
13185: IFFALSE 13262
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13187: LD_ADDR_VAR 0 2
13191: PUSH
13192: LD_VAR 0 4
13196: PPUSH
13197: LD_EXP 34
13201: PUSH
13202: LD_INT 1
13204: ARRAY
13205: PPUSH
13206: LD_EXP 34
13210: PUSH
13211: LD_INT 2
13213: ARRAY
13214: PPUSH
13215: LD_EXP 34
13219: PUSH
13220: LD_INT 3
13222: ARRAY
13223: PPUSH
13224: LD_EXP 34
13228: PUSH
13229: LD_INT 4
13231: ARRAY
13232: PPUSH
13233: CALL_OW 145
13237: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13238: LD_VAR 0 2
13242: PPUSH
13243: CALL_OW 266
13247: PUSH
13248: LD_INT 4
13250: EQUAL
13251: IFFALSE 13262
// AddComUpgrade ( i ) ;
13253: LD_VAR 0 2
13257: PPUSH
13258: CALL_OW 206
// end ; end ; end ; for i in engs do
13262: LD_ADDR_VAR 0 2
13266: PUSH
13267: LD_VAR 0 4
13271: PUSH
13272: FOR_IN
13273: IFFALSE 13391
// begin if i in to_heal and sci then
13275: LD_VAR 0 2
13279: PUSH
13280: LD_VAR 0 6
13284: IN
13285: PUSH
13286: LD_VAR 0 7
13290: AND
13291: IFFALSE 13342
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13293: LD_VAR 0 2
13297: PPUSH
13298: LD_INT 149
13300: PPUSH
13301: LD_INT 220
13303: PPUSH
13304: CALL_OW 297
13308: PUSH
13309: LD_INT 5
13311: LESS
13312: IFFALSE 13316
// continue ;
13314: GO 13272
// ComMoveXY ( i , 149 , 220 ) ;
13316: LD_VAR 0 2
13320: PPUSH
13321: LD_INT 149
13323: PPUSH
13324: LD_INT 220
13326: PPUSH
13327: CALL_OW 111
// AddComHold ( i ) ;
13331: LD_VAR 0 2
13335: PPUSH
13336: CALL_OW 200
// end else
13340: GO 13389
// if not HasTask ( i ) or WantsToAttack ( i ) then
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL_OW 314
13351: NOT
13352: PUSH
13353: LD_VAR 0 2
13357: PPUSH
13358: CALL_OW 319
13362: OR
13363: IFFALSE 13389
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13365: LD_VAR 0 2
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: LD_VAR 0 2
13379: PPUSH
13380: CALL_OW 74
13384: PPUSH
13385: CALL_OW 130
// end ;
13389: GO 13272
13391: POP
13392: POP
// if to_heal and sci then
13393: LD_VAR 0 6
13397: PUSH
13398: LD_VAR 0 7
13402: AND
13403: IFFALSE 13464
// begin if UnitFilter ( sci , [ f_inside ] ) then
13405: LD_VAR 0 7
13409: PPUSH
13410: LD_INT 54
13412: PUSH
13413: EMPTY
13414: LIST
13415: PPUSH
13416: CALL_OW 72
13420: IFFALSE 13444
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13422: LD_VAR 0 7
13426: PPUSH
13427: LD_INT 54
13429: PUSH
13430: EMPTY
13431: LIST
13432: PPUSH
13433: CALL_OW 72
13437: PPUSH
13438: CALL_OW 122
13442: GO 13462
// ComHeal ( sci , to_heal [ 1 ] ) ;
13444: LD_VAR 0 7
13448: PPUSH
13449: LD_VAR 0 6
13453: PUSH
13454: LD_INT 1
13456: ARRAY
13457: PPUSH
13458: CALL_OW 128
// end else
13462: GO 13512
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13464: LD_VAR 0 7
13468: PPUSH
13469: LD_INT 56
13471: PUSH
13472: EMPTY
13473: LIST
13474: PPUSH
13475: CALL_OW 72
13479: PUSH
13480: LD_VAR 0 8
13484: AND
13485: IFFALSE 13512
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13487: LD_VAR 0 7
13491: PPUSH
13492: LD_INT 56
13494: PUSH
13495: EMPTY
13496: LIST
13497: PPUSH
13498: CALL_OW 72
13502: PPUSH
13503: LD_VAR 0 8
13507: PPUSH
13508: CALL_OW 120
// end ;
13512: PPOPN 8
13514: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13515: LD_INT 22
13517: PUSH
13518: LD_INT 3
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 30
13527: PUSH
13528: LD_INT 3
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: PPUSH
13539: CALL_OW 69
13543: PUSH
13544: LD_EXP 35
13548: AND
13549: IFFALSE 13675
13551: GO 13553
13553: DISABLE
13554: LD_INT 0
13556: PPUSH
13557: PPUSH
13558: PPUSH
// begin enable ;
13559: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13560: LD_ADDR_VAR 0 3
13564: PUSH
13565: LD_INT 22
13567: PUSH
13568: LD_INT 3
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: LD_INT 30
13577: PUSH
13578: LD_INT 3
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: PUSH
13585: EMPTY
13586: LIST
13587: LIST
13588: PPUSH
13589: CALL_OW 69
13593: PUSH
13594: LD_INT 1
13596: ARRAY
13597: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
13598: LD_VAR 0 3
13602: PPUSH
13603: CALL_OW 313
13607: PUSH
13608: LD_INT 0
13610: EQUAL
13611: IFFALSE 13615
// exit ;
13613: GO 13675
// if BuildingStatus ( fac ) = bs_idle then
13615: LD_VAR 0 3
13619: PPUSH
13620: CALL_OW 461
13624: PUSH
13625: LD_INT 2
13627: EQUAL
13628: IFFALSE 13675
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
13630: LD_VAR 0 3
13634: PPUSH
13635: LD_EXP 35
13639: PUSH
13640: LD_INT 1
13642: ARRAY
13643: PPUSH
13644: LD_EXP 35
13648: PUSH
13649: LD_INT 2
13651: ARRAY
13652: PPUSH
13653: LD_EXP 35
13657: PUSH
13658: LD_INT 3
13660: ARRAY
13661: PPUSH
13662: LD_EXP 35
13666: PUSH
13667: LD_INT 4
13669: ARRAY
13670: PPUSH
13671: CALL_OW 125
// end ;
13675: PPOPN 3
13677: END
// export function PrepareAttack ( wave ) ; var i , un , tmp ; begin
13678: LD_INT 0
13680: PPUSH
13681: PPUSH
13682: PPUSH
13683: PPUSH
// uc_side := 3 ;
13684: LD_ADDR_OWVAR 20
13688: PUSH
13689: LD_INT 3
13691: ST_TO_ADDR
// uc_nation := 3 ;
13692: LD_ADDR_OWVAR 21
13696: PUSH
13697: LD_INT 3
13699: ST_TO_ADDR
// ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
13700: LD_ADDR_EXP 35
13704: PUSH
13705: LD_INT 24
13707: PUSH
13708: LD_INT 1
13710: PUSH
13711: LD_INT 3
13713: PUSH
13714: LD_INT 43
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: LIST
13721: LIST
13722: ST_TO_ADDR
// for i = 1 to Difficulty do
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: DOUBLE
13729: LD_INT 1
13731: DEC
13732: ST_TO_ADDR
13733: LD_OWVAR 67
13737: PUSH
13738: FOR_TO
13739: IFFALSE 13788
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher , ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ;
13741: LD_ADDR_EXP 35
13745: PUSH
13746: LD_EXP 35
13750: PUSH
13751: LD_INT 24
13753: PUSH
13754: LD_INT 1
13756: PUSH
13757: LD_INT 3
13759: PUSH
13760: LD_INT 45
13762: PUSH
13763: LD_INT 24
13765: PUSH
13766: LD_INT 1
13768: PUSH
13769: LD_INT 3
13771: PUSH
13772: LD_INT 46
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: ADD
13785: ST_TO_ADDR
13786: GO 13738
13788: POP
13789: POP
// repeat wait ( 0 0$1 ) ;
13790: LD_INT 35
13792: PPUSH
13793: CALL_OW 67
// until ru_produce_list < 4 ;
13797: LD_EXP 35
13801: PUSH
13802: LD_INT 4
13804: LESS
13805: IFFALSE 13790
// case wave of 1 :
13807: LD_VAR 0 1
13811: PUSH
13812: LD_INT 1
13814: DOUBLE
13815: EQUAL
13816: IFTRUE 13820
13818: GO 13905
13820: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
13821: LD_ADDR_VAR 0 3
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_INT 4
13833: PUSH
13834: LD_INT 5
13836: PUSH
13837: LD_INT 6
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: PUSH
13845: LD_OWVAR 67
13849: ARRAY
13850: PUSH
13851: FOR_TO
13852: IFFALSE 13860
// Sold ;
13854: CALL 14030 0 0
13858: GO 13851
13860: POP
13861: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
13862: LD_ADDR_VAR 0 3
13866: PUSH
13867: DOUBLE
13868: LD_INT 1
13870: DEC
13871: ST_TO_ADDR
13872: LD_INT 2
13874: PUSH
13875: LD_INT 3
13877: PUSH
13878: LD_INT 3
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: LIST
13885: PUSH
13886: LD_OWVAR 67
13890: ARRAY
13891: PUSH
13892: FOR_TO
13893: IFFALSE 13901
// Tank ;
13895: CALL 14144 0 0
13899: GO 13892
13901: POP
13902: POP
// end ; 2 .. 9 :
13903: GO 14025
13905: LD_INT 2
13907: DOUBLE
13908: GREATEREQUAL
13909: IFFALSE 13917
13911: LD_INT 9
13913: DOUBLE
13914: LESSEQUAL
13915: IFTRUE 13919
13917: GO 14024
13919: POP
// begin for i = 1 to [ 6 , 6 , 8 ] [ Difficulty ] + ( wave div 2 ) do
13920: LD_ADDR_VAR 0 3
13924: PUSH
13925: DOUBLE
13926: LD_INT 1
13928: DEC
13929: ST_TO_ADDR
13930: LD_INT 6
13932: PUSH
13933: LD_INT 6
13935: PUSH
13936: LD_INT 8
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: LIST
13943: PUSH
13944: LD_OWVAR 67
13948: ARRAY
13949: PUSH
13950: LD_VAR 0 1
13954: PUSH
13955: LD_INT 2
13957: DIV
13958: PLUS
13959: PUSH
13960: FOR_TO
13961: IFFALSE 13969
// Sold ;
13963: CALL 14030 0 0
13967: GO 13960
13969: POP
13970: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
13971: LD_ADDR_VAR 0 3
13975: PUSH
13976: DOUBLE
13977: LD_INT 1
13979: DEC
13980: ST_TO_ADDR
13981: LD_INT 3
13983: PUSH
13984: LD_INT 4
13986: PUSH
13987: LD_INT 4
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: LIST
13994: PUSH
13995: LD_OWVAR 67
13999: ARRAY
14000: PUSH
14001: LD_VAR 0 1
14005: PUSH
14006: LD_INT 2
14008: DIV
14009: PLUS
14010: PUSH
14011: FOR_TO
14012: IFFALSE 14020
// Tank ;
14014: CALL 14144 0 0
14018: GO 14011
14020: POP
14021: POP
// end ; end ;
14022: GO 14025
14024: POP
// end ;
14025: LD_VAR 0 2
14029: RET
// function Sold ( ) ; var un , skill ; begin
14030: LD_INT 0
14032: PPUSH
14033: PPUSH
14034: PPUSH
// InitHc ;
14035: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14039: LD_ADDR_VAR 0 3
14043: PUSH
14044: LD_INT 6
14046: PUSH
14047: LD_INT 7
14049: PUSH
14050: LD_INT 7
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: LIST
14057: PUSH
14058: LD_OWVAR 67
14062: ARRAY
14063: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14064: LD_INT 0
14066: PPUSH
14067: LD_INT 1
14069: PUSH
14070: LD_INT 9
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: PUSH
14077: LD_INT 1
14079: PPUSH
14080: LD_INT 2
14082: PPUSH
14083: CALL_OW 12
14087: ARRAY
14088: PPUSH
14089: LD_VAR 0 3
14093: PPUSH
14094: CALL_OW 380
// un := CreateHuman ;
14098: LD_ADDR_VAR 0 2
14102: PUSH
14103: CALL_OW 44
14107: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14108: LD_VAR 0 2
14112: PPUSH
14113: LD_INT 4
14115: PPUSH
14116: LD_INT 0
14118: PPUSH
14119: CALL_OW 49
// ru_force := ru_force ^ un ;
14123: LD_ADDR_EXP 33
14127: PUSH
14128: LD_EXP 33
14132: PUSH
14133: LD_VAR 0 2
14137: ADD
14138: ST_TO_ADDR
// end ;
14139: LD_VAR 0 1
14143: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14144: LD_INT 0
14146: PPUSH
14147: PPUSH
14148: PPUSH
14149: PPUSH
14150: PPUSH
// InitHc ;
14151: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14155: LD_ADDR_VAR 0 5
14159: PUSH
14160: LD_INT 5
14162: PUSH
14163: LD_INT 6
14165: PUSH
14166: LD_INT 7
14168: PUSH
14169: EMPTY
14170: LIST
14171: LIST
14172: LIST
14173: PUSH
14174: LD_OWVAR 67
14178: ARRAY
14179: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14180: LD_ADDR_VAR 0 3
14184: PUSH
14185: LD_INT 22
14187: PUSH
14188: LD_INT 24
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: PUSH
14195: LD_INT 1
14197: PPUSH
14198: LD_INT 2
14200: PPUSH
14201: CALL_OW 12
14205: ARRAY
14206: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14207: LD_VAR 0 3
14211: PUSH
14212: LD_INT 22
14214: EQUAL
14215: IFFALSE 14250
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14217: LD_ADDR_VAR 0 4
14221: PUSH
14222: LD_INT 45
14224: PUSH
14225: LD_INT 43
14227: PUSH
14228: LD_INT 44
14230: PUSH
14231: EMPTY
14232: LIST
14233: LIST
14234: LIST
14235: PUSH
14236: LD_INT 1
14238: PPUSH
14239: LD_INT 3
14241: PPUSH
14242: CALL_OW 12
14246: ARRAY
14247: ST_TO_ADDR
14248: GO 14281
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14250: LD_ADDR_VAR 0 4
14254: PUSH
14255: LD_INT 46
14257: PUSH
14258: LD_INT 44
14260: PUSH
14261: LD_INT 45
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: PUSH
14269: LD_INT 1
14271: PPUSH
14272: LD_INT 3
14274: PPUSH
14275: CALL_OW 12
14279: ARRAY
14280: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14281: LD_ADDR_VAR 0 2
14285: PUSH
14286: LD_INT 3
14288: PPUSH
14289: LD_INT 3
14291: PPUSH
14292: LD_VAR 0 3
14296: PPUSH
14297: LD_INT 1
14299: PPUSH
14300: LD_INT 3
14302: PUSH
14303: LD_INT 3
14305: PUSH
14306: LD_INT 3
14308: PUSH
14309: LD_INT 1
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: PUSH
14318: LD_INT 1
14320: PPUSH
14321: LD_INT 4
14323: PPUSH
14324: CALL_OW 12
14328: ARRAY
14329: PPUSH
14330: LD_VAR 0 4
14334: PPUSH
14335: LD_INT 99
14337: PPUSH
14338: CALL 252 0 7
14342: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14343: LD_VAR 0 2
14347: PPUSH
14348: CALL_OW 263
14352: PUSH
14353: LD_INT 1
14355: EQUAL
14356: IFFALSE 14387
// begin PrepareHuman ( false , 3 , skill ) ;
14358: LD_INT 0
14360: PPUSH
14361: LD_INT 3
14363: PPUSH
14364: LD_VAR 0 5
14368: PPUSH
14369: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
14373: CALL_OW 44
14377: PPUSH
14378: LD_VAR 0 2
14382: PPUSH
14383: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
14387: LD_VAR 0 2
14391: PPUSH
14392: LD_INT 3
14394: PPUSH
14395: LD_INT 0
14397: PPUSH
14398: CALL_OW 49
// ru_force := ru_force ^ un ;
14402: LD_ADDR_EXP 33
14406: PUSH
14407: LD_EXP 33
14411: PUSH
14412: LD_VAR 0 2
14416: ADD
14417: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
14418: LD_VAR 0 2
14422: PPUSH
14423: LD_INT 126
14425: PPUSH
14426: LD_INT 158
14428: PPUSH
14429: CALL_OW 111
// Wait ( 0 0$3 ) ;
14433: LD_INT 105
14435: PPUSH
14436: CALL_OW 67
// ComStop ( un ) ;
14440: LD_VAR 0 2
14444: PPUSH
14445: CALL_OW 141
// end ;
14449: LD_VAR 0 1
14453: RET
// every 0 0$1 do var i , time , wave ;
14454: GO 14456
14456: DISABLE
14457: LD_INT 0
14459: PPUSH
14460: PPUSH
14461: PPUSH
// begin time := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
14462: LD_ADDR_VAR 0 2
14466: PUSH
14467: LD_INT 25200
14469: PUSH
14470: LD_INT 23100
14472: PUSH
14473: LD_INT 21000
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: LIST
14480: PUSH
14481: LD_OWVAR 67
14485: ARRAY
14486: ST_TO_ADDR
// wait ( time ) ;
14487: LD_VAR 0 2
14491: PPUSH
14492: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_INT 17850
14503: PUSH
14504: LD_INT 16450
14506: PUSH
14507: LD_INT 15750
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: LIST
14514: PUSH
14515: LD_OWVAR 67
14519: ARRAY
14520: ST_TO_ADDR
// wave := 0 ;
14521: LD_ADDR_VAR 0 3
14525: PUSH
14526: LD_INT 0
14528: ST_TO_ADDR
// while true do
14529: LD_INT 1
14531: IFFALSE 14628
// begin wave := wave + 1 ;
14533: LD_ADDR_VAR 0 3
14537: PUSH
14538: LD_VAR 0 3
14542: PUSH
14543: LD_INT 1
14545: PLUS
14546: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
14547: LD_INT 22
14549: PUSH
14550: LD_INT 2
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PPUSH
14557: CALL_OW 69
14561: IFFALSE 14590
// repeat wait ( 0 0$1 ) ;
14563: LD_INT 35
14565: PPUSH
14566: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
14570: LD_INT 22
14572: PUSH
14573: LD_INT 2
14575: PUSH
14576: EMPTY
14577: LIST
14578: LIST
14579: PPUSH
14580: CALL_OW 69
14584: PUSH
14585: LD_INT 0
14587: EQUAL
14588: IFFALSE 14563
// if ru_force < 20 then
14590: LD_EXP 33
14594: PUSH
14595: LD_INT 20
14597: LESS
14598: IFFALSE 14609
// PrepareAttack ( wave ) ;
14600: LD_VAR 0 3
14604: PPUSH
14605: CALL 13678 0 1
// ru_can_attack := true ;
14609: LD_ADDR_EXP 8
14613: PUSH
14614: LD_INT 1
14616: ST_TO_ADDR
// wait ( time ) ;
14617: LD_VAR 0 2
14621: PPUSH
14622: CALL_OW 67
// end ;
14626: GO 14529
// end ;
14628: PPOPN 3
14630: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
14631: LD_EXP 8
14635: PUSH
14636: LD_EXP 33
14640: AND
14641: IFFALSE 15383
14643: GO 14645
14645: DISABLE
14646: LD_INT 0
14648: PPUSH
14649: PPUSH
14650: PPUSH
14651: PPUSH
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
// begin enable ;
14657: ENABLE
// points1 := [ 107 , 123 ] ;
14658: LD_ADDR_VAR 0 4
14662: PUSH
14663: LD_INT 107
14665: PUSH
14666: LD_INT 123
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
14673: LD_ADDR_VAR 0 5
14677: PUSH
14678: LD_INT 55
14680: PUSH
14681: LD_INT 42
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
14688: LD_ADDR_VAR 0 6
14692: PUSH
14693: LD_INT 102
14695: PUSH
14696: LD_INT 140
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: LD_INT 105
14705: PUSH
14706: LD_INT 142
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 129
14715: PUSH
14716: LD_INT 131
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: LIST
14727: ST_TO_ADDR
// for i in ru_force do
14728: LD_ADDR_VAR 0 1
14732: PUSH
14733: LD_EXP 33
14737: PUSH
14738: FOR_IN
14739: IFFALSE 15381
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
14741: LD_ADDR_VAR 0 3
14745: PUSH
14746: LD_INT 81
14748: PUSH
14749: LD_INT 3
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PPUSH
14756: CALL_OW 69
14760: PPUSH
14761: LD_VAR 0 1
14765: PPUSH
14766: CALL_OW 74
14770: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 10 then
14771: LD_VAR 0 1
14775: PPUSH
14776: LD_VAR 0 3
14780: PPUSH
14781: CALL_OW 296
14785: PUSH
14786: LD_INT 10
14788: LESS
14789: IFFALSE 14934
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
14791: LD_VAR 0 1
14795: PPUSH
14796: CALL_OW 247
14800: PUSH
14801: LD_INT 1
14803: EQUAL
14804: PUSH
14805: LD_VAR 0 1
14809: PPUSH
14810: CALL_OW 257
14814: PUSH
14815: LD_INT 1
14817: EQUAL
14818: AND
14819: PUSH
14820: LD_VAR 0 3
14824: PUSH
14825: LD_INT 21
14827: PUSH
14828: LD_INT 2
14830: PUSH
14831: EMPTY
14832: LIST
14833: LIST
14834: PUSH
14835: LD_INT 58
14837: PUSH
14838: EMPTY
14839: LIST
14840: PUSH
14841: EMPTY
14842: LIST
14843: LIST
14844: PPUSH
14845: CALL_OW 69
14849: IN
14850: AND
14851: IFFALSE 14869
// ComEnterUnit ( i , un ) else
14853: LD_VAR 0 1
14857: PPUSH
14858: LD_VAR 0 3
14862: PPUSH
14863: CALL_OW 120
14867: GO 14932
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
14869: LD_VAR 0 3
14873: PUSH
14874: LD_INT 21
14876: PUSH
14877: LD_INT 2
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: LD_INT 58
14886: PUSH
14887: EMPTY
14888: LIST
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: PPUSH
14894: CALL_OW 69
14898: IN
14899: NOT
14900: IFFALSE 14918
// ComAttackUnit ( i , un ) else
14902: LD_VAR 0 1
14906: PPUSH
14907: LD_VAR 0 3
14911: PPUSH
14912: CALL_OW 115
14916: GO 14932
// ComAttackUnit ( i , JMM ) ;
14918: LD_VAR 0 1
14922: PPUSH
14923: LD_EXP 17
14927: PPUSH
14928: CALL_OW 115
// end else
14932: GO 15379
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
14934: LD_VAR 0 1
14938: PPUSH
14939: LD_VAR 0 4
14943: PUSH
14944: LD_INT 1
14946: ARRAY
14947: PPUSH
14948: LD_VAR 0 4
14952: PUSH
14953: LD_INT 2
14955: ARRAY
14956: PPUSH
14957: CALL_OW 297
14961: PUSH
14962: LD_VAR 0 1
14966: PPUSH
14967: LD_VAR 0 5
14971: PUSH
14972: LD_INT 1
14974: ARRAY
14975: PPUSH
14976: LD_VAR 0 5
14980: PUSH
14981: LD_INT 2
14983: ARRAY
14984: PPUSH
14985: CALL_OW 297
14989: GREATER
14990: PUSH
14991: LD_EXP 9
14995: AND
14996: PUSH
14997: LD_INT 9
14999: PPUSH
15000: LD_INT 22
15002: PUSH
15003: LD_INT 1
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PPUSH
15010: CALL_OW 70
15014: PUSH
15015: LD_INT 0
15017: EQUAL
15018: OR
15019: IFFALSE 15050
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15021: LD_VAR 0 1
15025: PPUSH
15026: LD_VAR 0 5
15030: PUSH
15031: LD_INT 1
15033: ARRAY
15034: PPUSH
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 2
15042: ARRAY
15043: PPUSH
15044: CALL_OW 114
15048: GO 15379
// begin if GetWeapon ( i ) = ru_rocket_launcher then
15050: LD_VAR 0 1
15054: PPUSH
15055: CALL_OW 264
15059: PUSH
15060: LD_INT 45
15062: EQUAL
15063: IFFALSE 15244
// begin dist := 9999 ;
15065: LD_ADDR_VAR 0 8
15069: PUSH
15070: LD_INT 9999
15072: ST_TO_ADDR
// xy := 0 ;
15073: LD_ADDR_VAR 0 9
15077: PUSH
15078: LD_INT 0
15080: ST_TO_ADDR
// for x in pointsr do
15081: LD_ADDR_VAR 0 7
15085: PUSH
15086: LD_VAR 0 6
15090: PUSH
15091: FOR_IN
15092: IFFALSE 15240
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15094: LD_VAR 0 1
15098: PPUSH
15099: LD_VAR 0 7
15103: PUSH
15104: LD_INT 1
15106: ARRAY
15107: PPUSH
15108: LD_VAR 0 7
15112: PUSH
15113: LD_INT 2
15115: ARRAY
15116: PPUSH
15117: CALL_OW 297
15121: PUSH
15122: LD_VAR 0 8
15126: LESS
15127: IFFALSE 15172
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15129: LD_ADDR_VAR 0 8
15133: PUSH
15134: LD_VAR 0 1
15138: PPUSH
15139: LD_VAR 0 7
15143: PUSH
15144: LD_INT 1
15146: ARRAY
15147: PPUSH
15148: LD_VAR 0 7
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PPUSH
15157: CALL_OW 297
15161: ST_TO_ADDR
// xy := x ;
15162: LD_ADDR_VAR 0 9
15166: PUSH
15167: LD_VAR 0 7
15171: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15172: LD_VAR 0 9
15176: PUSH
15177: LD_VAR 0 1
15181: PPUSH
15182: LD_VAR 0 9
15186: PUSH
15187: LD_INT 1
15189: ARRAY
15190: PPUSH
15191: LD_VAR 0 9
15195: PUSH
15196: LD_INT 2
15198: ARRAY
15199: PPUSH
15200: CALL_OW 297
15204: PUSH
15205: LD_INT 9
15207: GREATER
15208: AND
15209: IFFALSE 15238
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15211: LD_VAR 0 1
15215: PPUSH
15216: LD_VAR 0 9
15220: PUSH
15221: LD_INT 1
15223: ARRAY
15224: PPUSH
15225: LD_VAR 0 9
15229: PUSH
15230: LD_INT 2
15232: ARRAY
15233: PPUSH
15234: CALL_OW 114
// end ;
15238: GO 15091
15240: POP
15241: POP
// end else
15242: GO 15379
// begin un := NearestUnitToUnit ( un , all_units diff un ) ;
15244: LD_ADDR_VAR 0 3
15248: PUSH
15249: LD_VAR 0 3
15253: PPUSH
15254: LD_OWVAR 3
15258: PUSH
15259: LD_VAR 0 3
15263: DIFF
15264: PPUSH
15265: CALL_OW 74
15269: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15270: LD_VAR 0 3
15274: PUSH
15275: LD_INT 21
15277: PUSH
15278: LD_INT 2
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: PUSH
15285: LD_INT 58
15287: PUSH
15288: EMPTY
15289: LIST
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: PPUSH
15295: CALL_OW 69
15299: IN
15300: PUSH
15301: LD_VAR 0 3
15305: PUSH
15306: LD_INT 22
15308: PUSH
15309: LD_INT 3
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PUSH
15316: LD_INT 24
15318: PUSH
15319: LD_INT 249
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: PPUSH
15330: CALL_OW 69
15334: IN
15335: OR
15336: IFFALSE 15352
// ComAttackUnit ( i , un ) ;
15338: LD_VAR 0 1
15342: PPUSH
15343: LD_VAR 0 3
15347: PPUSH
15348: CALL_OW 115
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
15352: LD_VAR 0 1
15356: PPUSH
15357: LD_VAR 0 4
15361: PUSH
15362: LD_INT 1
15364: ARRAY
15365: PPUSH
15366: LD_VAR 0 4
15370: PUSH
15371: LD_INT 2
15373: ARRAY
15374: PPUSH
15375: CALL_OW 114
// end ; end ; end ; end ;
15379: GO 14738
15381: POP
15382: POP
// end ;
15383: PPOPN 9
15385: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
15386: LD_INT 22
15388: PUSH
15389: LD_INT 3
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: PUSH
15396: LD_INT 32
15398: PUSH
15399: LD_INT 1
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PPUSH
15410: CALL_OW 69
15414: IFFALSE 15502
15416: GO 15418
15418: DISABLE
15419: LD_INT 0
15421: PPUSH
15422: PPUSH
// begin enable ;
15423: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
15424: LD_ADDR_VAR 0 2
15428: PUSH
15429: LD_INT 22
15431: PUSH
15432: LD_INT 3
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: PUSH
15439: LD_INT 32
15441: PUSH
15442: LD_INT 1
15444: PUSH
15445: EMPTY
15446: LIST
15447: LIST
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: PPUSH
15453: CALL_OW 69
15457: ST_TO_ADDR
// for i in tmp do
15458: LD_ADDR_VAR 0 1
15462: PUSH
15463: LD_VAR 0 2
15467: PUSH
15468: FOR_IN
15469: IFFALSE 15500
// if GetFuel ( i ) < 12 then
15471: LD_VAR 0 1
15475: PPUSH
15476: CALL_OW 261
15480: PUSH
15481: LD_INT 12
15483: LESS
15484: IFFALSE 15498
// SetFuel ( i , 12 ) ;
15486: LD_VAR 0 1
15490: PPUSH
15491: LD_INT 12
15493: PPUSH
15494: CALL_OW 240
15498: GO 15468
15500: POP
15501: POP
// end ;
15502: PPOPN 2
15504: END
