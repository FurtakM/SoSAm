// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 37 0 0
// DebugMode ;
   8: CALL 165 0 0
// PrepareNature ;
  12: CALL 340 0 0
// PrepareRussian ;
  16: CALL 11960 0 0
// PrepareAmerican ;
  20: CALL 1054 0 0
// PrepareOvsyenko ;
  24: CALL 1698 0 0
// Action ;
  28: CALL 2556 0 0
// SaveForQuickRestart ;
  32: CALL_OW 22
// end ;
  36: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar ; function Init ; begin
  37: LD_INT 0
  39: PPUSH
// debug := false ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  48: LD_ADDR_EXP 4
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// mission_prefix := 09_ ;
  56: LD_ADDR_EXP 1
  60: PUSH
  61: LD_STRING 09_
  63: ST_TO_ADDR
// powell_want_sib := false ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  72: LD_ADDR_EXP 6
  76: PUSH
  77: LD_INT 31500
  79: ST_TO_ADDR
// game_time := 47 47$00 ;
  80: LD_ADDR_EXP 7
  84: PUSH
  85: LD_INT 98700
  87: ST_TO_ADDR
// ru_can_attack := false ;
  88: LD_ADDR_EXP 8
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// ru_can_attack_terminal := false ;
  96: LD_ADDR_EXP 9
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// ar_can_arrive := false ;
 104: LD_ADDR_EXP 10
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// ar_spawned := false ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// player_want_mortar := false ;
 120: LD_ADDR_EXP 12
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// player_want_info := false ;
 128: LD_ADDR_EXP 13
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// player_get_mortar := false ;
 136: LD_ADDR_EXP 14
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// player_get_info := false ;
 144: LD_ADDR_EXP 15
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// player_attacked_ar := false ;
 152: LD_ADDR_EXP 16
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// end ;
 160: LD_VAR 0 1
 164: RET
// function DebugMode ; begin
 165: LD_INT 0
 167: PPUSH
// if not debug then
 168: LD_EXP 2
 172: NOT
 173: IFFALSE 177
// exit ;
 175: GO 184
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 222
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 199: LD_ADDR_VAR 0 5
 203: PUSH
 204: LD_VAR 0 3
 208: PUSH
 209: LD_VAR 0 1
 213: STR
 214: PPUSH
 215: CALL_OW 34
 219: ST_TO_ADDR
 220: GO 237
// unit := NewCharacter ( ident ) ;
 222: LD_ADDR_VAR 0 5
 226: PUSH
 227: LD_VAR 0 1
 231: PPUSH
 232: CALL_OW 25
 236: ST_TO_ADDR
// result := unit ;
 237: LD_ADDR_VAR 0 4
 241: PUSH
 242: LD_VAR 0 5
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 4
 251: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 252: LD_INT 0
 254: PPUSH
// uc_side := side ;
 255: LD_ADDR_OWVAR 20
 259: PUSH
 260: LD_VAR 0 1
 264: ST_TO_ADDR
// uc_nation := nation ;
 265: LD_ADDR_OWVAR 21
 269: PUSH
 270: LD_VAR 0 2
 274: ST_TO_ADDR
// vc_chassis := chassis ;
 275: LD_ADDR_OWVAR 37
 279: PUSH
 280: LD_VAR 0 3
 284: ST_TO_ADDR
// vc_engine := engine ;
 285: LD_ADDR_OWVAR 39
 289: PUSH
 290: LD_VAR 0 4
 294: ST_TO_ADDR
// vc_control := control ;
 295: LD_ADDR_OWVAR 38
 299: PUSH
 300: LD_VAR 0 5
 304: ST_TO_ADDR
// vc_weapon := weapon ;
 305: LD_ADDR_OWVAR 40
 309: PUSH
 310: LD_VAR 0 6
 314: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 315: LD_ADDR_OWVAR 41
 319: PUSH
 320: LD_VAR 0 7
 324: ST_TO_ADDR
// result := CreateVehicle ;
 325: LD_ADDR_VAR 0 8
 329: PUSH
 330: CALL_OW 45
 334: ST_TO_ADDR
// end ;
 335: LD_VAR 0 8
 339: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 340: LD_INT 0
 342: PPUSH
 343: PPUSH
 344: PPUSH
 345: PPUSH
// uc_side = 0 ;
 346: LD_ADDR_OWVAR 20
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// uc_nation = 0 ;
 354: LD_ADDR_OWVAR 21
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// nat_area := natureArea ;
 362: LD_ADDR_VAR 0 4
 366: PUSH
 367: LD_INT 1
 369: ST_TO_ADDR
// InitHc ;
 370: CALL_OW 19
// for i = 1 to 4 do
 374: LD_ADDR_VAR 0 2
 378: PUSH
 379: DOUBLE
 380: LD_INT 1
 382: DEC
 383: ST_TO_ADDR
 384: LD_INT 4
 386: PUSH
 387: FOR_TO
 388: IFFALSE 443
// begin hc_class = 18 ;
 390: LD_ADDR_OWVAR 28
 394: PUSH
 395: LD_INT 18
 397: ST_TO_ADDR
// hc_gallery =  ;
 398: LD_ADDR_OWVAR 33
 402: PUSH
 403: LD_STRING 
 405: ST_TO_ADDR
// hc_face_number = 1 ;
 406: LD_ADDR_OWVAR 34
 410: PUSH
 411: LD_INT 1
 413: ST_TO_ADDR
// animal := CreateHuman ;
 414: LD_ADDR_VAR 0 3
 418: PUSH
 419: CALL_OW 44
 423: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 424: LD_VAR 0 3
 428: PPUSH
 429: LD_VAR 0 4
 433: PPUSH
 434: LD_INT 0
 436: PPUSH
 437: CALL_OW 49
// end ;
 441: GO 387
 443: POP
 444: POP
// for i = 1 to 4 do
 445: LD_ADDR_VAR 0 2
 449: PUSH
 450: DOUBLE
 451: LD_INT 1
 453: DEC
 454: ST_TO_ADDR
 455: LD_INT 4
 457: PUSH
 458: FOR_TO
 459: IFFALSE 531
// begin hc_class = class_tiger ;
 461: LD_ADDR_OWVAR 28
 465: PUSH
 466: LD_INT 14
 468: ST_TO_ADDR
// hc_gallery =  ;
 469: LD_ADDR_OWVAR 33
 473: PUSH
 474: LD_STRING 
 476: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 477: LD_ADDR_OWVAR 35
 481: PUSH
 482: LD_INT 5
 484: NEG
 485: PPUSH
 486: LD_INT 5
 488: PPUSH
 489: CALL_OW 12
 493: ST_TO_ADDR
// hc_face_number = 3 ;
 494: LD_ADDR_OWVAR 34
 498: PUSH
 499: LD_INT 3
 501: ST_TO_ADDR
// animal := CreateHuman ;
 502: LD_ADDR_VAR 0 3
 506: PUSH
 507: CALL_OW 44
 511: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 512: LD_VAR 0 3
 516: PPUSH
 517: LD_VAR 0 4
 521: PPUSH
 522: LD_INT 0
 524: PPUSH
 525: CALL_OW 49
// end ;
 529: GO 458
 531: POP
 532: POP
// for i = 1 to 6 do
 533: LD_ADDR_VAR 0 2
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_INT 6
 545: PUSH
 546: FOR_TO
 547: IFFALSE 611
// begin hc_class = class_apeman ;
 549: LD_ADDR_OWVAR 28
 553: PUSH
 554: LD_INT 12
 556: ST_TO_ADDR
// hc_gallery =  ;
 557: LD_ADDR_OWVAR 33
 561: PUSH
 562: LD_STRING 
 564: ST_TO_ADDR
// hc_agressivity = rand ( - 10 , 10 ) ;
 565: LD_ADDR_OWVAR 35
 569: PUSH
 570: LD_INT 10
 572: NEG
 573: PPUSH
 574: LD_INT 10
 576: PPUSH
 577: CALL_OW 12
 581: ST_TO_ADDR
// animal := CreateHuman ;
 582: LD_ADDR_VAR 0 3
 586: PUSH
 587: CALL_OW 44
 591: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 592: LD_VAR 0 3
 596: PPUSH
 597: LD_VAR 0 4
 601: PPUSH
 602: LD_INT 0
 604: PPUSH
 605: CALL_OW 49
// end ;
 609: GO 546
 611: POP
 612: POP
// for i = 1 to 6 do
 613: LD_ADDR_VAR 0 2
 617: PUSH
 618: DOUBLE
 619: LD_INT 1
 621: DEC
 622: ST_TO_ADDR
 623: LD_INT 6
 625: PUSH
 626: FOR_TO
 627: IFFALSE 682
// begin hc_class = 13 ;
 629: LD_ADDR_OWVAR 28
 633: PUSH
 634: LD_INT 13
 636: ST_TO_ADDR
// hc_gallery =  ;
 637: LD_ADDR_OWVAR 33
 641: PUSH
 642: LD_STRING 
 644: ST_TO_ADDR
// hc_face_number = 4 ;
 645: LD_ADDR_OWVAR 34
 649: PUSH
 650: LD_INT 4
 652: ST_TO_ADDR
// animal := CreateHuman ;
 653: LD_ADDR_VAR 0 3
 657: PUSH
 658: CALL_OW 44
 662: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 663: LD_VAR 0 3
 667: PPUSH
 668: LD_VAR 0 4
 672: PPUSH
 673: LD_INT 0
 675: PPUSH
 676: CALL_OW 49
// end ;
 680: GO 626
 682: POP
 683: POP
// for i = 1 to 1 do
 684: LD_ADDR_VAR 0 2
 688: PUSH
 689: DOUBLE
 690: LD_INT 1
 692: DEC
 693: ST_TO_ADDR
 694: LD_INT 1
 696: PUSH
 697: FOR_TO
 698: IFFALSE 746
// begin vc_chassis := 31 ;
 700: LD_ADDR_OWVAR 37
 704: PUSH
 705: LD_INT 31
 707: ST_TO_ADDR
// vc_control := control_rider ;
 708: LD_ADDR_OWVAR 38
 712: PUSH
 713: LD_INT 4
 715: ST_TO_ADDR
// animal := CreateVehicle ;
 716: LD_ADDR_VAR 0 3
 720: PUSH
 721: CALL_OW 45
 725: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 726: LD_VAR 0 3
 730: PPUSH
 731: LD_INT 21
 733: PPUSH
 734: LD_INT 22
 736: PPUSH
 737: LD_INT 0
 739: PPUSH
 740: CALL_OW 48
// end ;
 744: GO 697
 746: POP
 747: POP
// end ;
 748: LD_VAR 0 1
 752: RET
// export function GetTerminalCargo ; begin
 753: LD_INT 0
 755: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 756: LD_ADDR_VAR 0 1
 760: PUSH
 761: LD_EXP 3
 765: PPUSH
 766: CALL_OW 274
 770: PPUSH
 771: LD_INT 3
 773: PPUSH
 774: CALL_OW 275
 778: ST_TO_ADDR
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 784: LD_INT 0
 786: PPUSH
 787: PPUSH
 788: PPUSH
// result := 0 ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 0
 796: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 797: LD_ADDR_VAR 0 4
 801: PUSH
 802: LD_INT 22
 804: PUSH
 805: LD_VAR 0 1
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 2
 816: PUSH
 817: LD_INT 30
 819: PUSH
 820: LD_INT 0
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: PUSH
 827: LD_INT 30
 829: PUSH
 830: LD_INT 1
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL_OW 69
 850: ST_TO_ADDR
// if not tmp then
 851: LD_VAR 0 4
 855: NOT
 856: IFFALSE 860
// exit ;
 858: GO 906
// for i in tmp do
 860: LD_ADDR_VAR 0 3
 864: PUSH
 865: LD_VAR 0 4
 869: PUSH
 870: FOR_IN
 871: IFFALSE 904
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 873: LD_ADDR_VAR 0 2
 877: PUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_VAR 0 3
 887: PPUSH
 888: CALL_OW 274
 892: PPUSH
 893: LD_INT 3
 895: PPUSH
 896: CALL_OW 275
 900: PLUS
 901: ST_TO_ADDR
 902: GO 870
 904: POP
 905: POP
// end ;
 906: LD_VAR 0 2
 910: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
// area = ListEnvironmentArea ( area ) ;
 915: LD_ADDR_VAR 0 2
 919: PUSH
 920: LD_VAR 0 2
 924: PPUSH
 925: CALL_OW 353
 929: ST_TO_ADDR
// if bulldozer > 0 then
 930: LD_VAR 0 1
 934: PUSH
 935: LD_INT 0
 937: GREATER
 938: IFFALSE 1049
// for i = area downto 1 do
 940: LD_ADDR_VAR 0 4
 944: PUSH
 945: DOUBLE
 946: LD_VAR 0 2
 950: INC
 951: ST_TO_ADDR
 952: LD_INT 1
 954: PUSH
 955: FOR_DOWNTO
 956: IFFALSE 1047
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 958: LD_VAR 0 2
 962: PUSH
 963: LD_VAR 0 4
 967: ARRAY
 968: PUSH
 969: LD_INT 1
 971: ARRAY
 972: PPUSH
 973: LD_VAR 0 2
 977: PUSH
 978: LD_VAR 0 4
 982: ARRAY
 983: PUSH
 984: LD_INT 2
 986: ARRAY
 987: PPUSH
 988: CALL_OW 351
 992: IFFALSE 1045
// if not HasTask ( bulldozer ) then
 994: LD_VAR 0 1
 998: PPUSH
 999: CALL_OW 314
1003: NOT
1004: IFFALSE 1045
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1006: LD_VAR 0 1
1010: PPUSH
1011: LD_VAR 0 2
1015: PUSH
1016: LD_VAR 0 4
1020: ARRAY
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: PPUSH
1026: LD_VAR 0 2
1030: PUSH
1031: LD_VAR 0 4
1035: ARRAY
1036: PUSH
1037: LD_INT 2
1039: ARRAY
1040: PPUSH
1041: CALL_OW 171
1045: GO 955
1047: POP
1048: POP
// end ; end_of_file
1049: LD_VAR 0 3
1053: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1054: LD_INT 0
1056: PPUSH
1057: PPUSH
1058: PPUSH
1059: PPUSH
1060: PPUSH
// uc_side := 1 ;
1061: LD_ADDR_OWVAR 20
1065: PUSH
1066: LD_INT 1
1068: ST_TO_ADDR
// uc_nation := 1 ;
1069: LD_ADDR_OWVAR 21
1073: PUSH
1074: LD_INT 1
1076: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1077: LD_ADDR_EXP 17
1081: PUSH
1082: LD_STRING JMM
1084: PPUSH
1085: LD_EXP 2
1089: NOT
1090: PPUSH
1091: LD_STRING 08_
1093: PPUSH
1094: CALL 189 0 3
1098: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1099: LD_ADDR_VAR 0 4
1103: PUSH
1104: LD_INT 1
1106: PPUSH
1107: LD_INT 1
1109: PPUSH
1110: LD_INT 3
1112: PPUSH
1113: LD_INT 2
1115: PPUSH
1116: LD_INT 1
1118: PPUSH
1119: LD_INT 5
1121: PPUSH
1122: LD_INT 55
1124: PPUSH
1125: CALL 252 0 7
1129: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1130: LD_VAR 0 4
1134: PPUSH
1135: LD_INT 3
1137: PPUSH
1138: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1142: LD_VAR 0 4
1146: PPUSH
1147: LD_INT 43
1149: PPUSH
1150: LD_INT 3
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1160: LD_EXP 17
1164: PPUSH
1165: LD_VAR 0 4
1169: PPUSH
1170: CALL_OW 52
// tmp := [ ] ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: EMPTY
1180: ST_TO_ADDR
// uc_side := 4 ;
1181: LD_ADDR_OWVAR 20
1185: PUSH
1186: LD_INT 4
1188: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1189: LD_ADDR_OWVAR 33
1193: PUSH
1194: LD_STRING SecondCharsGal
1196: ST_TO_ADDR
// hc_class := 2 ;
1197: LD_ADDR_OWVAR 28
1201: PUSH
1202: LD_INT 2
1204: ST_TO_ADDR
// hc_sex := sex_female ;
1205: LD_ADDR_OWVAR 27
1209: PUSH
1210: LD_INT 2
1212: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1213: LD_ADDR_OWVAR 30
1217: PUSH
1218: LD_INT 0
1220: PUSH
1221: LD_INT 1
1223: PUSH
1224: LD_INT 1
1226: PUSH
1227: LD_INT 0
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1236: LD_ADDR_OWVAR 31
1240: PUSH
1241: LD_INT 3
1243: PUSH
1244: LD_INT 4
1246: PUSH
1247: LD_INT 2
1249: PUSH
1250: LD_INT 1
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1259: LD_ADDR_OWVAR 29
1263: PUSH
1264: LD_INT 10
1266: PUSH
1267: LD_INT 11
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1274: LD_ADDR_OWVAR 26
1278: PUSH
1279: LD_STRING Naoma Goichman
1281: ST_TO_ADDR
// hc_face_number := 43 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 43
1289: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1290: LD_ADDR_VAR 0 2
1294: PUSH
1295: LD_VAR 0 2
1299: PUSH
1300: CALL_OW 44
1304: ADD
1305: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1306: LD_ADDR_OWVAR 30
1310: PUSH
1311: LD_INT 0
1313: PUSH
1314: LD_INT 2
1316: PUSH
1317: LD_INT 0
1319: PUSH
1320: LD_INT 1
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1329: LD_ADDR_OWVAR 31
1333: PUSH
1334: LD_INT 0
1336: PUSH
1337: LD_INT 5
1339: PUSH
1340: LD_INT 3
1342: PUSH
1343: LD_INT 1
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1352: LD_ADDR_OWVAR 29
1356: PUSH
1357: LD_INT 10
1359: PUSH
1360: LD_INT 10
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1367: LD_ADDR_OWVAR 26
1371: PUSH
1372: LD_STRING Magdalene Glance
1374: ST_TO_ADDR
// hc_face_number := 44 ;
1375: LD_ADDR_OWVAR 34
1379: PUSH
1380: LD_INT 44
1382: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1383: LD_ADDR_VAR 0 2
1387: PUSH
1388: LD_VAR 0 2
1392: PUSH
1393: CALL_OW 44
1397: ADD
1398: ST_TO_ADDR
// hc_sex := sex_male ;
1399: LD_ADDR_OWVAR 27
1403: PUSH
1404: LD_INT 1
1406: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1407: LD_ADDR_OWVAR 30
1411: PUSH
1412: LD_INT 2
1414: PUSH
1415: LD_INT 2
1417: PUSH
1418: LD_INT 0
1420: PUSH
1421: LD_INT 0
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1430: LD_ADDR_OWVAR 31
1434: PUSH
1435: LD_INT 3
1437: PUSH
1438: LD_INT 4
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: LD_INT 0
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1453: LD_ADDR_OWVAR 29
1457: PUSH
1458: LD_INT 12
1460: PUSH
1461: LD_INT 10
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: ST_TO_ADDR
// hc_name := Steve Holland ;
1468: LD_ADDR_OWVAR 26
1472: PUSH
1473: LD_STRING Steve Holland
1475: ST_TO_ADDR
// hc_face_number := 60 ;
1476: LD_ADDR_OWVAR 34
1480: PUSH
1481: LD_INT 60
1483: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1484: LD_ADDR_VAR 0 2
1488: PUSH
1489: LD_VAR 0 2
1493: PUSH
1494: CALL_OW 44
1498: ADD
1499: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1500: LD_ADDR_EXP 22
1504: PUSH
1505: LD_VAR 0 2
1509: PUSH
1510: LD_INT 0
1512: DIFF
1513: ST_TO_ADDR
// for un in alpha_engs do
1514: LD_ADDR_VAR 0 3
1518: PUSH
1519: LD_EXP 22
1523: PUSH
1524: FOR_IN
1525: IFFALSE 1550
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1527: LD_VAR 0 3
1531: PPUSH
1532: LD_INT 52
1534: PPUSH
1535: LD_INT 35
1537: PPUSH
1538: LD_INT 3
1540: PPUSH
1541: LD_INT 0
1543: PPUSH
1544: CALL_OW 50
1548: GO 1524
1550: POP
1551: POP
// for tmp = 1 to 4 do
1552: LD_ADDR_VAR 0 2
1556: PUSH
1557: DOUBLE
1558: LD_INT 1
1560: DEC
1561: ST_TO_ADDR
1562: LD_INT 4
1564: PUSH
1565: FOR_TO
1566: IFFALSE 1592
// CreateResourcesXYR ( mat_cans , 5 , 54 , 40 , 2 , false ) ;
1568: LD_INT 1
1570: PPUSH
1571: LD_INT 5
1573: PPUSH
1574: LD_INT 54
1576: PPUSH
1577: LD_INT 40
1579: PPUSH
1580: LD_INT 2
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 60
1590: GO 1565
1592: POP
1593: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1594: LD_STRING gamma_commander
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 30
1604: PUSH
1605: LD_INT 3
1607: LESS
1608: IFFALSE 1666
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1610: LD_ADDR_EXP 21
1614: PUSH
1615: LD_STRING VanHouten
1617: PPUSH
1618: LD_INT 0
1620: PPUSH
1621: LD_STRING 
1623: PPUSH
1624: CALL 189 0 3
1628: ST_TO_ADDR
// for i = 1 to 4 do
1629: LD_ADDR_VAR 0 5
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_INT 4
1641: PUSH
1642: FOR_TO
1643: IFFALSE 1664
// AddExperience ( Houten , i , 10000 ) ;
1645: LD_EXP 21
1649: PPUSH
1650: LD_VAR 0 5
1654: PPUSH
1655: LD_INT 10000
1657: PPUSH
1658: CALL_OW 492
1662: GO 1642
1664: POP
1665: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1666: LD_ADDR_EXP 24
1670: PUSH
1671: LD_STRING Powell
1673: PPUSH
1674: LD_INT 0
1676: PPUSH
1677: LD_STRING 
1679: PPUSH
1680: CALL 189 0 3
1684: ST_TO_ADDR
// InitHc ;
1685: CALL_OW 19
// InitUc ;
1689: CALL_OW 18
// end ;
1693: LD_VAR 0 1
1697: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1698: LD_INT 0
1700: PPUSH
1701: PPUSH
1702: PPUSH
1703: PPUSH
1704: PPUSH
// uc_side := 4 ;
1705: LD_ADDR_OWVAR 20
1709: PUSH
1710: LD_INT 4
1712: ST_TO_ADDR
// uc_nation := 3 ;
1713: LD_ADDR_OWVAR 21
1717: PUSH
1718: LD_INT 3
1720: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 ] , [ b_breastwork , 109 , 114 , 4 ] , [ b_breastwork , 115 , 132 , 5 ] , [ b_breastwork , 98 , 120 , 1 ] ] ) ;
1721: LD_ADDR_VAR 0 4
1725: PUSH
1726: LD_STRING 09_ovsyenko_base
1728: PPUSH
1729: LD_INT 0
1731: PUSH
1732: LD_INT 101
1734: PUSH
1735: LD_INT 118
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: EMPTY
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: PUSH
1747: LD_INT 31
1749: PUSH
1750: LD_INT 109
1752: PUSH
1753: LD_INT 114
1755: PUSH
1756: LD_INT 4
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: LIST
1763: LIST
1764: PUSH
1765: LD_INT 31
1767: PUSH
1768: LD_INT 115
1770: PUSH
1771: LD_INT 132
1773: PUSH
1774: LD_INT 5
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 98
1788: PUSH
1789: LD_INT 120
1791: PUSH
1792: LD_INT 1
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: PPUSH
1807: CALL_OW 30
1811: ST_TO_ADDR
// for i in tmp do
1812: LD_ADDR_VAR 0 2
1816: PUSH
1817: LD_VAR 0 4
1821: PUSH
1822: FOR_IN
1823: IFFALSE 1979
// begin bc_type := i [ 1 ] ;
1825: LD_ADDR_OWVAR 42
1829: PUSH
1830: LD_VAR 0 2
1834: PUSH
1835: LD_INT 1
1837: ARRAY
1838: ST_TO_ADDR
// bc_level := 3 ;
1839: LD_ADDR_OWVAR 43
1843: PUSH
1844: LD_INT 3
1846: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1847: LD_ADDR_VAR 0 3
1851: PUSH
1852: LD_VAR 0 2
1856: PUSH
1857: LD_INT 2
1859: ARRAY
1860: PPUSH
1861: LD_VAR 0 2
1865: PUSH
1866: LD_INT 3
1868: ARRAY
1869: PPUSH
1870: LD_VAR 0 2
1874: PUSH
1875: LD_INT 4
1877: ARRAY
1878: PPUSH
1879: CALL_OW 47
1883: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1884: LD_VAR 0 3
1888: PPUSH
1889: CALL_OW 266
1893: PUSH
1894: LD_INT 0
1896: EQUAL
1897: IFFALSE 1931
// begin SetBName ( b , ovsyenko ) ;
1899: LD_VAR 0 3
1903: PPUSH
1904: LD_STRING ovsyenko
1906: PPUSH
1907: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1911: LD_VAR 0 3
1915: PPUSH
1916: CALL_OW 274
1920: PPUSH
1921: LD_INT 1
1923: PPUSH
1924: LD_INT 50
1926: PPUSH
1927: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1931: LD_VAR 0 2
1935: PUSH
1936: LD_INT 5
1938: ARRAY
1939: PUSH
1940: LD_INT 250
1942: LESS
1943: IFFALSE 1959
// SetLives ( b , 333 ) else
1945: LD_VAR 0 3
1949: PPUSH
1950: LD_INT 333
1952: PPUSH
1953: CALL_OW 234
1957: GO 1977
// SetLives ( b , i [ 5 ] ) ;
1959: LD_VAR 0 3
1963: PPUSH
1964: LD_VAR 0 2
1968: PUSH
1969: LD_INT 5
1971: ARRAY
1972: PPUSH
1973: CALL_OW 234
// end ;
1977: GO 1822
1979: POP
1980: POP
// uc_nation := 1 ;
1981: LD_ADDR_OWVAR 21
1985: PUSH
1986: LD_INT 1
1988: ST_TO_ADDR
// tmp := [ ] ;
1989: LD_ADDR_VAR 0 4
1993: PUSH
1994: EMPTY
1995: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
1996: LD_ADDR_EXP 18
2000: PUSH
2001: LD_STRING Gary
2003: PPUSH
2004: LD_EXP 2
2008: NOT
2009: PPUSH
2010: LD_STRING 
2012: PPUSH
2013: CALL 189 0 3
2017: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2018: LD_ADDR_VAR 0 4
2022: PUSH
2023: LD_VAR 0 4
2027: PUSH
2028: LD_EXP 18
2032: ADD
2033: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2034: LD_ADDR_EXP 19
2038: PUSH
2039: LD_STRING Bobby
2041: PPUSH
2042: LD_EXP 2
2046: NOT
2047: PPUSH
2048: LD_STRING 03_
2050: PPUSH
2051: CALL 189 0 3
2055: ST_TO_ADDR
// if Bobby then
2056: LD_EXP 19
2060: IFFALSE 2078
// tmp := tmp ^ Bobby ;
2062: LD_ADDR_VAR 0 4
2066: PUSH
2067: LD_VAR 0 4
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2078: LD_ADDR_EXP 20
2082: PUSH
2083: LD_STRING Cyrus
2085: PPUSH
2086: LD_EXP 2
2090: NOT
2091: PPUSH
2092: LD_STRING 03_
2094: PPUSH
2095: CALL 189 0 3
2099: ST_TO_ADDR
// if Cyrus then
2100: LD_EXP 20
2104: IFFALSE 2122
// tmp := tmp ^ Cyrus ;
2106: LD_ADDR_VAR 0 4
2110: PUSH
2111: LD_VAR 0 4
2115: PUSH
2116: LD_EXP 20
2120: ADD
2121: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2122: LD_ADDR_VAR 0 4
2126: PUSH
2127: LD_VAR 0 4
2131: PUSH
2132: LD_STRING 09_prev_squad
2134: PPUSH
2135: CALL_OW 31
2139: ADD
2140: ST_TO_ADDR
// tmp := tmp diff 0 ;
2141: LD_ADDR_VAR 0 4
2145: PUSH
2146: LD_VAR 0 4
2150: PUSH
2151: LD_INT 0
2153: DIFF
2154: ST_TO_ADDR
// if tmp < 4 then
2155: LD_VAR 0 4
2159: PUSH
2160: LD_INT 4
2162: LESS
2163: IFFALSE 2243
// begin for i = 1 to 3 do
2165: LD_ADDR_VAR 0 2
2169: PUSH
2170: DOUBLE
2171: LD_INT 1
2173: DEC
2174: ST_TO_ADDR
2175: LD_INT 3
2177: PUSH
2178: FOR_TO
2179: IFFALSE 2212
// begin PrepareHuman ( false , 1 , 5 ) ;
2181: LD_INT 0
2183: PPUSH
2184: LD_INT 1
2186: PPUSH
2187: LD_INT 5
2189: PPUSH
2190: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ADD
2209: ST_TO_ADDR
// end ;
2210: GO 2178
2212: POP
2213: POP
// PrepareHuman ( false , 4 , 5 ) ;
2214: LD_INT 0
2216: PPUSH
2217: LD_INT 4
2219: PPUSH
2220: LD_INT 5
2222: PPUSH
2223: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2227: LD_ADDR_VAR 0 4
2231: PUSH
2232: LD_VAR 0 4
2236: PUSH
2237: CALL_OW 44
2241: ADD
2242: ST_TO_ADDR
// end ; for i in tmp do
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: LD_VAR 0 4
2252: PUSH
2253: FOR_IN
2254: IFFALSE 2279
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2256: LD_VAR 0 2
2260: PPUSH
2261: LD_INT 106
2263: PPUSH
2264: LD_INT 122
2266: PPUSH
2267: LD_INT 5
2269: PPUSH
2270: LD_INT 0
2272: PPUSH
2273: CALL_OW 50
2277: GO 2253
2279: POP
2280: POP
// tmp := tmp diff Gary ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: LD_EXP 18
2295: DIFF
2296: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2297: LD_ADDR_VAR 0 3
2301: PUSH
2302: LD_INT 22
2304: PUSH
2305: LD_INT 4
2307: PUSH
2308: EMPTY
2309: LIST
2310: LIST
2311: PUSH
2312: LD_INT 30
2314: PUSH
2315: LD_INT 31
2317: PUSH
2318: EMPTY
2319: LIST
2320: LIST
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: PPUSH
2326: CALL_OW 69
2330: ST_TO_ADDR
// for i = 1 to b do
2331: LD_ADDR_VAR 0 2
2335: PUSH
2336: DOUBLE
2337: LD_INT 1
2339: DEC
2340: ST_TO_ADDR
2341: LD_VAR 0 3
2345: PUSH
2346: FOR_TO
2347: IFFALSE 2377
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2349: LD_VAR 0 4
2353: PUSH
2354: LD_VAR 0 2
2358: ARRAY
2359: PPUSH
2360: LD_VAR 0 3
2364: PUSH
2365: LD_VAR 0 2
2369: ARRAY
2370: PPUSH
2371: CALL_OW 120
// end ;
2375: GO 2346
2377: POP
2378: POP
// InitHc ;
2379: CALL_OW 19
// InitUc ;
2383: CALL_OW 18
// end ;
2387: LD_VAR 0 1
2391: RET
// export function PowellTransport ; var i , un ; begin
2392: LD_INT 0
2394: PPUSH
2395: PPUSH
2396: PPUSH
// uc_side := 4 ;
2397: LD_ADDR_OWVAR 20
2401: PUSH
2402: LD_INT 4
2404: ST_TO_ADDR
// uc_nation := 1 ;
2405: LD_ADDR_OWVAR 21
2409: PUSH
2410: LD_INT 1
2412: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2413: LD_INT 1
2415: PPUSH
2416: LD_INT 3
2418: PPUSH
2419: LD_INT 6
2421: PPUSH
2422: CALL_OW 380
// hc_name :=  ;
2426: LD_ADDR_OWVAR 26
2430: PUSH
2431: LD_STRING 
2433: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2434: LD_ADDR_OWVAR 33
2438: PUSH
2439: LD_STRING SecondCharsGal
2441: ST_TO_ADDR
// hc_face_number := 30 ;
2442: LD_ADDR_OWVAR 34
2446: PUSH
2447: LD_INT 30
2449: ST_TO_ADDR
// powell_trans := CreateHuman ;
2450: LD_ADDR_EXP 23
2454: PUSH
2455: CALL_OW 44
2459: ST_TO_ADDR
// hc_face_number := 31 ;
2460: LD_ADDR_OWVAR 34
2464: PUSH
2465: LD_INT 31
2467: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2468: LD_ADDR_EXP 23
2472: PUSH
2473: LD_EXP 23
2477: PUSH
2478: CALL_OW 44
2482: ADD
2483: ST_TO_ADDR
// for i = 1 to 2 do
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: DOUBLE
2490: LD_INT 1
2492: DEC
2493: ST_TO_ADDR
2494: LD_INT 2
2496: PUSH
2497: FOR_TO
2498: IFFALSE 2549
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2500: LD_ADDR_VAR 0 3
2504: PUSH
2505: LD_INT 4
2507: PPUSH
2508: LD_INT 1
2510: PPUSH
2511: LD_INT 3
2513: PPUSH
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 1
2519: PPUSH
2520: LD_INT 12
2522: PPUSH
2523: LD_INT 66
2525: PPUSH
2526: CALL 252 0 7
2530: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2531: LD_ADDR_EXP 23
2535: PUSH
2536: LD_EXP 23
2540: PUSH
2541: LD_VAR 0 3
2545: ADD
2546: ST_TO_ADDR
// end ;
2547: GO 2497
2549: POP
2550: POP
// end ; end_of_file
2551: LD_VAR 0 1
2555: RET
// export function Action ; var i , veh ; begin
2556: LD_INT 0
2558: PPUSH
2559: PPUSH
2560: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2561: LD_EXP 22
2565: PPUSH
2566: LD_INT 0
2568: PPUSH
2569: LD_INT 50
2571: PPUSH
2572: LD_INT 38
2574: PPUSH
2575: LD_INT 2
2577: PPUSH
2578: CALL_OW 145
// InGameOn ;
2582: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2586: LD_INT 43
2588: PPUSH
2589: LD_INT 9
2591: PPUSH
2592: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2596: LD_EXP 17
2600: PPUSH
2601: LD_INT 54
2603: PPUSH
2604: LD_INT 34
2606: PPUSH
2607: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2611: LD_EXP 17
2615: PPUSH
2616: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2620: LD_EXP 17
2624: PPUSH
2625: LD_EXP 22
2629: PUSH
2630: LD_INT 1
2632: ARRAY
2633: PPUSH
2634: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2638: LD_INT 35
2640: PPUSH
2641: CALL_OW 67
// until See ( 4 , JMM ) ;
2645: LD_INT 4
2647: PPUSH
2648: LD_EXP 17
2652: PPUSH
2653: CALL_OW 292
2657: IFFALSE 2638
// CenterNowOnUnits ( JMM ) ;
2659: LD_EXP 17
2663: PPUSH
2664: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2668: LD_EXP 17
2672: PPUSH
2673: LD_STRING D2-JMM-1
2675: PPUSH
2676: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2680: LD_EXP 22
2684: PUSH
2685: LD_INT 3
2687: ARRAY
2688: PPUSH
2689: LD_EXP 17
2693: PPUSH
2694: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2698: LD_EXP 22
2702: PUSH
2703: LD_INT 3
2705: ARRAY
2706: PPUSH
2707: LD_STRING D2-Eng1-1
2709: PPUSH
2710: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2714: LD_EXP 17
2718: PPUSH
2719: LD_STRING D2-JMM-2
2721: PPUSH
2722: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2726: LD_EXP 22
2730: PUSH
2731: LD_INT 3
2733: ARRAY
2734: PPUSH
2735: LD_STRING D2-Eng1-2
2737: PPUSH
2738: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2742: LD_EXP 17
2746: PPUSH
2747: LD_STRING D2-JMM-3
2749: PPUSH
2750: CALL_OW 88
// if Houten then
2754: LD_EXP 21
2758: IFFALSE 2956
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2760: LD_ADDR_VAR 0 3
2764: PUSH
2765: LD_INT 4
2767: PPUSH
2768: LD_INT 1
2770: PPUSH
2771: LD_INT 3
2773: PPUSH
2774: LD_INT 2
2776: PPUSH
2777: LD_INT 1
2779: PPUSH
2780: LD_INT 4
2782: PPUSH
2783: LD_INT 55
2785: PPUSH
2786: CALL 252 0 7
2790: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2791: LD_VAR 0 3
2795: PPUSH
2796: LD_INT 3
2798: PPUSH
2799: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2803: LD_VAR 0 3
2807: PPUSH
2808: LD_INT 46
2810: PPUSH
2811: LD_INT 19
2813: PPUSH
2814: LD_INT 0
2816: PPUSH
2817: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2821: LD_EXP 21
2825: PPUSH
2826: LD_VAR 0 3
2830: PPUSH
2831: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2835: LD_EXP 21
2839: PPUSH
2840: LD_INT 49
2842: PPUSH
2843: LD_INT 33
2845: PPUSH
2846: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2850: LD_EXP 21
2854: PPUSH
2855: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2859: LD_EXP 21
2863: PPUSH
2864: LD_EXP 17
2868: PPUSH
2869: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2873: LD_INT 35
2875: PPUSH
2876: CALL_OW 67
// until See ( 1 , Houten ) ;
2880: LD_INT 1
2882: PPUSH
2883: LD_EXP 21
2887: PPUSH
2888: CALL_OW 292
2892: IFFALSE 2873
// ComTurnUnit ( JMM , Houten ) ;
2894: LD_EXP 17
2898: PPUSH
2899: LD_EXP 21
2903: PPUSH
2904: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2908: LD_EXP 17
2912: PPUSH
2913: LD_STRING D1d-JMM-1
2915: PPUSH
2916: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2920: LD_EXP 21
2924: PPUSH
2925: LD_STRING D1-VanH-1
2927: PPUSH
2928: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2932: LD_EXP 17
2936: PPUSH
2937: LD_STRING D1-JMM-1v
2939: PPUSH
2940: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2944: LD_EXP 17
2948: PPUSH
2949: LD_STRING D1-JMM-2v
2951: PPUSH
2952: CALL_OW 88
// end ; InGameOff ;
2956: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2960: LD_STRING M1
2962: PPUSH
2963: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2967: LD_INT 22
2969: PUSH
2970: LD_INT 4
2972: PUSH
2973: EMPTY
2974: LIST
2975: LIST
2976: PUSH
2977: LD_INT 92
2979: PUSH
2980: LD_EXP 17
2984: PPUSH
2985: CALL_OW 250
2989: PUSH
2990: LD_EXP 17
2994: PPUSH
2995: CALL_OW 251
2999: PUSH
3000: LD_INT 15
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: PPUSH
3013: CALL_OW 69
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3025: LD_EXP 22
3029: PUSH
3030: LD_EXP 17
3034: ADD
3035: PUSH
3036: LD_EXP 21
3040: ADD
3041: PPUSH
3042: CALL_OW 141
// end ;
3046: LD_VAR 0 1
3050: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3051: LD_INT 1
3053: PPUSH
3054: LD_EXP 18
3058: PPUSH
3059: CALL_OW 292
3063: PUSH
3064: LD_EXP 17
3068: PPUSH
3069: LD_EXP 18
3073: PPUSH
3074: CALL_OW 296
3078: PUSH
3079: LD_INT 6
3081: LESS
3082: AND
3083: IFFALSE 3846
3085: GO 3087
3087: DISABLE
3088: LD_INT 0
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
3094: PPUSH
// begin InGameOn ;
3095: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3099: LD_INT 22
3101: PUSH
3102: LD_INT 4
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PPUSH
3109: CALL_OW 69
3113: PPUSH
3114: LD_INT 1
3116: PPUSH
3117: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3121: LD_ADDR_VAR 0 4
3125: PUSH
3126: LD_INT 22
3128: PUSH
3129: LD_INT 1
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 25
3141: PUSH
3142: LD_INT 1
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 25
3151: PUSH
3152: LD_INT 2
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: LD_INT 25
3161: PUSH
3162: LD_INT 3
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PPUSH
3190: CALL_OW 69
3194: ST_TO_ADDR
// ComHold ( tmp ) ;
3195: LD_VAR 0 4
3199: PPUSH
3200: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3204: LD_EXP 17
3208: PPUSH
3209: LD_STRING D2-JMM-3a
3211: PPUSH
3212: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3216: LD_EXP 18
3220: PPUSH
3221: LD_EXP 17
3225: PPUSH
3226: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3230: LD_EXP 18
3234: PPUSH
3235: LD_STRING D2-Gary-3
3237: PPUSH
3238: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3242: LD_EXP 17
3246: PPUSH
3247: LD_EXP 18
3251: PPUSH
3252: CALL_OW 119
// for i in tmp do
3256: LD_ADDR_VAR 0 5
3260: PUSH
3261: LD_VAR 0 4
3265: PUSH
3266: FOR_IN
3267: IFFALSE 3312
// begin if IsInUnit ( i ) then
3269: LD_VAR 0 5
3273: PPUSH
3274: CALL_OW 310
3278: IFFALSE 3289
// ComExitBuilding ( i ) ;
3280: LD_VAR 0 5
3284: PPUSH
3285: CALL_OW 122
// wait ( 1 ) ;
3289: LD_INT 1
3291: PPUSH
3292: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3296: LD_VAR 0 5
3300: PPUSH
3301: LD_EXP 17
3305: PPUSH
3306: CALL_OW 119
// end ;
3310: GO 3266
3312: POP
3313: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3314: LD_ADDR_VAR 0 4
3318: PUSH
3319: LD_VAR 0 4
3323: PUSH
3324: LD_EXP 17
3328: PUSH
3329: LD_EXP 21
3333: PUSH
3334: LD_EXP 18
3338: PUSH
3339: LD_EXP 20
3343: PUSH
3344: LD_EXP 19
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: PUSH
3356: LD_EXP 22
3360: ADD
3361: DIFF
3362: ST_TO_ADDR
// if Bobby then
3363: LD_EXP 19
3367: IFFALSE 3381
// Say ( Bobby , D2-Bobby-3 ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_STRING D2-Bobby-3
3376: PPUSH
3377: CALL_OW 88
// if Cyrus then
3381: LD_EXP 20
3385: IFFALSE 3399
// Say ( Cyrus , D2-Cyrus-3 ) ;
3387: LD_EXP 20
3391: PPUSH
3392: LD_STRING D2-Cyrus-3
3394: PPUSH
3395: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3399: LD_EXP 17
3403: PPUSH
3404: LD_STRING D2-JMM-4
3406: PPUSH
3407: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3411: LD_EXP 18
3415: PPUSH
3416: LD_STRING D2-Gary-4
3418: PPUSH
3419: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3423: LD_ADDR_VAR 0 1
3427: PUSH
3428: LD_VAR 0 4
3432: PPUSH
3433: LD_INT 26
3435: PUSH
3436: LD_INT 1
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PPUSH
3443: CALL_OW 72
3447: PUSH
3448: LD_INT 1
3450: ARRAY
3451: ST_TO_ADDR
// if Cyrus then
3452: LD_EXP 20
3456: IFFALSE 3472
// Say ( Cyrus , D2-Cyrus-4 ) else
3458: LD_EXP 20
3462: PPUSH
3463: LD_STRING D2-Cyrus-4
3465: PPUSH
3466: CALL_OW 88
3470: GO 3484
// Say ( un1 , D2-Sol1-4 ) ;
3472: LD_VAR 0 1
3476: PPUSH
3477: LD_STRING D2-Sol1-4
3479: PPUSH
3480: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3484: LD_EXP 17
3488: PPUSH
3489: LD_STRING D2-JMM-5
3491: PPUSH
3492: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3496: LD_ADDR_VAR 0 2
3500: PUSH
3501: LD_EXP 22
3505: PPUSH
3506: LD_INT 91
3508: PUSH
3509: LD_EXP 17
3513: PUSH
3514: LD_INT 10
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: PUSH
3522: LD_INT 26
3524: PUSH
3525: LD_INT 2
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: PUSH
3532: EMPTY
3533: LIST
3534: LIST
3535: PPUSH
3536: CALL_OW 72
3540: ST_TO_ADDR
// if un2 then
3541: LD_VAR 0 2
3545: IFFALSE 3599
// begin un2 := un2 [ un2 ] ;
3547: LD_ADDR_VAR 0 2
3551: PUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_VAR 0 2
3561: ARRAY
3562: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3563: LD_VAR 0 2
3567: PPUSH
3568: LD_STRING D2-FEng1-5
3570: PPUSH
3571: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3575: LD_EXP 17
3579: PPUSH
3580: LD_STRING D2-JMM-6
3582: PPUSH
3583: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3587: LD_VAR 0 2
3591: PPUSH
3592: LD_STRING D2-FEng1-6
3594: PPUSH
3595: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3599: LD_ADDR_VAR 0 3
3603: PUSH
3604: LD_EXP 22
3608: PPUSH
3609: LD_INT 91
3611: PUSH
3612: LD_EXP 17
3616: PUSH
3617: LD_INT 10
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 26
3627: PUSH
3628: LD_INT 1
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: PPUSH
3639: CALL_OW 72
3643: ST_TO_ADDR
// if un3 then
3644: LD_VAR 0 3
3648: IFFALSE 3703
// begin un3 := un3 [ 1 ] ;
3650: LD_ADDR_VAR 0 3
3654: PUSH
3655: LD_VAR 0 3
3659: PUSH
3660: LD_INT 1
3662: ARRAY
3663: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3664: LD_VAR 0 3
3668: PPUSH
3669: LD_INT 114
3671: PPUSH
3672: LD_INT 122
3674: PPUSH
3675: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3679: LD_VAR 0 3
3683: PPUSH
3684: LD_STRING D2-Eng1-6
3686: PPUSH
3687: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3691: LD_EXP 17
3695: PPUSH
3696: LD_STRING D2-JMM-7
3698: PPUSH
3699: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3703: LD_EXP 18
3707: PPUSH
3708: LD_STRING D2-Gary-7
3710: PPUSH
3711: CALL_OW 88
// if un2 then
3715: LD_VAR 0 2
3719: IFFALSE 3733
// Say ( un2 , D2-FEng1-7 ) ;
3721: LD_VAR 0 2
3725: PPUSH
3726: LD_STRING D2-FEng1-7
3728: PPUSH
3729: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3733: LD_VAR 0 1
3737: PPUSH
3738: LD_STRING D2-Sol1-7
3740: PPUSH
3741: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3745: LD_EXP 17
3749: PPUSH
3750: LD_STRING D2-JMM-8
3752: PPUSH
3753: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3757: LD_INT 22
3759: PUSH
3760: LD_INT 1
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PPUSH
3767: CALL_OW 69
3771: PPUSH
3772: CALL_OW 141
// InGameOff ;
3776: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3780: LD_STRING M1a
3782: PPUSH
3783: CALL_OW 337
// jmm_in_ovsyenko := true ;
3787: LD_ADDR_EXP 4
3791: PUSH
3792: LD_INT 1
3794: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3795: LD_INT 1050
3797: PPUSH
3798: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3802: LD_ADDR_VAR 0 4
3806: PUSH
3807: LD_INT 25
3809: PUSH
3810: LD_INT 14
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL_OW 69
3821: ST_TO_ADDR
// if not tmp then
3822: LD_VAR 0 4
3826: NOT
3827: IFFALSE 3831
// exit ;
3829: GO 3846
// ComMoveXY ( tmp , 75 , 75 ) ;
3831: LD_VAR 0 4
3835: PPUSH
3836: LD_INT 75
3838: PPUSH
3839: LD_INT 75
3841: PPUSH
3842: CALL_OW 111
// end ;
3846: PPOPN 5
3848: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3849: LD_INT 22
3851: PUSH
3852: LD_INT 1
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PUSH
3859: LD_INT 30
3861: PUSH
3862: LD_INT 30
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: PUSH
3869: LD_INT 3
3871: PUSH
3872: LD_INT 57
3874: PUSH
3875: EMPTY
3876: LIST
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: LIST
3886: PPUSH
3887: CALL_OW 69
3891: IFFALSE 3933
3893: GO 3895
3895: DISABLE
3896: LD_INT 0
3898: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3899: LD_ADDR_VAR 0 1
3903: PUSH
3904: LD_STRING M2easy
3906: PUSH
3907: LD_STRING M2
3909: PUSH
3910: LD_STRING M2hard
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: LIST
3917: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3918: LD_VAR 0 1
3922: PUSH
3923: LD_OWVAR 67
3927: ARRAY
3928: PPUSH
3929: CALL_OW 337
// end ;
3933: PPOPN 1
3935: END
// every 3 3$00 do
3936: GO 3938
3938: DISABLE
// begin DialogueOn ;
3939: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3943: LD_EXP 24
3947: PPUSH
3948: LD_STRING D3-Pow-1
3950: PPUSH
3951: CALL_OW 94
// if jmm_in_ovsyenko then
3955: LD_EXP 4
3959: IFFALSE 3987
// begin Say ( JMM , D3-JMM-1 ) ;
3961: LD_EXP 17
3965: PPUSH
3966: LD_STRING D3-JMM-1
3968: PPUSH
3969: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
3973: LD_EXP 17
3977: PPUSH
3978: LD_STRING D3-JMM-1b
3980: PPUSH
3981: CALL_OW 88
// end else
3985: GO 3999
// Say ( JMM , D3-JMM-1a ) ;
3987: LD_EXP 17
3991: PPUSH
3992: LD_STRING D3-JMM-1a
3994: PPUSH
3995: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
3999: LD_EXP 24
4003: PPUSH
4004: LD_STRING D3-Pow-2
4006: PPUSH
4007: CALL_OW 94
// DialogueOff ;
4011: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4015: LD_STRING M3
4017: PPUSH
4018: CALL_OW 337
// powell_want_sib := true ;
4022: LD_ADDR_EXP 5
4026: PUSH
4027: LD_INT 1
4029: ST_TO_ADDR
// end ;
4030: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo ;
4031: LD_EXP 6
4035: PUSH
4036: LD_INT 0
4038: EQUAL
4039: IFFALSE 5314
4041: GO 4043
4043: DISABLE
4044: LD_INT 0
4046: PPUSH
4047: PPUSH
4048: PPUSH
4049: PPUSH
4050: PPUSH
4051: PPUSH
4052: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4053: LD_INT 4
4055: PPUSH
4056: LD_INT 1
4058: PPUSH
4059: CALL_OW 343
// PowellTransport ;
4063: CALL 2392 0 0
// for i = 1 to 3 do
4067: LD_ADDR_VAR 0 4
4071: PUSH
4072: DOUBLE
4073: LD_INT 1
4075: DEC
4076: ST_TO_ADDR
4077: LD_INT 3
4079: PUSH
4080: FOR_TO
4081: IFFALSE 4148
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4083: LD_ADDR_VAR 0 1
4087: PUSH
4088: LD_INT 6
4090: PPUSH
4091: LD_VAR 0 4
4095: PPUSH
4096: CALL_OW 287
4100: ST_TO_ADDR
// if not tmp then
4101: LD_VAR 0 1
4105: NOT
4106: IFFALSE 4110
// continue ;
4108: GO 4080
// EraseResourceArea ( terminalArea , i ) ;
4110: LD_INT 6
4112: PPUSH
4113: LD_VAR 0 4
4117: PPUSH
4118: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4122: LD_EXP 3
4126: PPUSH
4127: CALL_OW 274
4131: PPUSH
4132: LD_VAR 0 4
4136: PPUSH
4137: LD_VAR 0 1
4141: PPUSH
4142: CALL_OW 276
// end ;
4146: GO 4080
4148: POP
4149: POP
// x := 43 ;
4150: LD_ADDR_VAR 0 2
4154: PUSH
4155: LD_INT 43
4157: ST_TO_ADDR
// y := 3 ;
4158: LD_ADDR_VAR 0 3
4162: PUSH
4163: LD_INT 3
4165: ST_TO_ADDR
// for i = 3 to 4 do
4166: LD_ADDR_VAR 0 4
4170: PUSH
4171: DOUBLE
4172: LD_INT 3
4174: DEC
4175: ST_TO_ADDR
4176: LD_INT 4
4178: PUSH
4179: FOR_TO
4180: IFFALSE 4390
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4182: LD_EXP 23
4186: PUSH
4187: LD_VAR 0 4
4191: ARRAY
4192: PPUSH
4193: LD_INT 4
4195: PPUSH
4196: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4200: LD_EXP 23
4204: PUSH
4205: LD_VAR 0 4
4209: ARRAY
4210: PPUSH
4211: LD_VAR 0 2
4215: PPUSH
4216: LD_VAR 0 3
4220: PPUSH
4221: LD_INT 0
4223: PPUSH
4224: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4228: LD_EXP 23
4232: PUSH
4233: LD_VAR 0 4
4237: PUSH
4238: LD_INT 2
4240: MINUS
4241: ARRAY
4242: PPUSH
4243: LD_EXP 23
4247: PUSH
4248: LD_VAR 0 4
4252: ARRAY
4253: PPUSH
4254: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4258: LD_EXP 23
4262: PUSH
4263: LD_VAR 0 4
4267: ARRAY
4268: PPUSH
4269: LD_INT 1
4271: PPUSH
4272: LD_INT 100
4274: PPUSH
4275: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4279: LD_EXP 23
4283: PUSH
4284: LD_VAR 0 4
4288: PUSH
4289: LD_INT 2
4291: MINUS
4292: ARRAY
4293: PPUSH
4294: LD_INT 54
4296: PPUSH
4297: LD_INT 42
4299: PPUSH
4300: CALL_OW 111
// AddComUnload ( powell_trans [ i - 2 ] ) ;
4304: LD_EXP 23
4308: PUSH
4309: LD_VAR 0 4
4313: PUSH
4314: LD_INT 2
4316: MINUS
4317: ARRAY
4318: PPUSH
4319: CALL_OW 219
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4323: LD_EXP 23
4327: PUSH
4328: LD_VAR 0 4
4332: PUSH
4333: LD_INT 2
4335: MINUS
4336: ARRAY
4337: PPUSH
4338: LD_EXP 3
4342: PPUSH
4343: CALL_OW 250
4347: PPUSH
4348: LD_EXP 3
4352: PPUSH
4353: CALL_OW 251
4357: PPUSH
4358: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4362: LD_EXP 23
4366: PUSH
4367: LD_VAR 0 4
4371: PUSH
4372: LD_INT 2
4374: MINUS
4375: ARRAY
4376: PPUSH
4377: CALL_OW 200
// Wait ( 0 0$02 ) ;
4381: LD_INT 70
4383: PPUSH
4384: CALL_OW 67
// end ;
4388: GO 4179
4390: POP
4391: POP
// repeat wait ( 0 0$01 ) ;
4392: LD_INT 35
4394: PPUSH
4395: CALL_OW 67
// for i = 3 to 4 do
4399: LD_ADDR_VAR 0 4
4403: PUSH
4404: DOUBLE
4405: LD_INT 3
4407: DEC
4408: ST_TO_ADDR
4409: LD_INT 4
4411: PUSH
4412: FOR_TO
4413: IFFALSE 4563
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4415: LD_EXP 23
4419: PUSH
4420: LD_VAR 0 4
4424: ARRAY
4425: PPUSH
4426: LD_INT 1
4428: PPUSH
4429: CALL_OW 289
4433: PUSH
4434: LD_INT 0
4436: GREATER
4437: PUSH
4438: LD_EXP 23
4442: PUSH
4443: LD_VAR 0 4
4447: ARRAY
4448: PPUSH
4449: CALL_OW 314
4453: NOT
4454: AND
4455: IFFALSE 4561
// begin ComUnload ( powell_trans [ i ] ) ;
4457: LD_EXP 23
4461: PUSH
4462: LD_VAR 0 4
4466: ARRAY
4467: PPUSH
4468: CALL_OW 159
// x := rand ( 0 , 5 ) ;
4472: LD_ADDR_VAR 0 2
4476: PUSH
4477: LD_INT 0
4479: PPUSH
4480: LD_INT 5
4482: PPUSH
4483: CALL_OW 12
4487: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4488: LD_EXP 23
4492: PUSH
4493: LD_VAR 0 4
4497: ARRAY
4498: PPUSH
4499: LD_EXP 23
4503: PUSH
4504: LD_VAR 0 4
4508: ARRAY
4509: PPUSH
4510: CALL_OW 250
4514: PPUSH
4515: LD_VAR 0 2
4519: PPUSH
4520: LD_INT 3
4522: PPUSH
4523: CALL_OW 272
4527: PPUSH
4528: LD_EXP 23
4532: PUSH
4533: LD_VAR 0 4
4537: ARRAY
4538: PPUSH
4539: CALL_OW 251
4543: PPUSH
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: CALL_OW 273
4556: PPUSH
4557: CALL_OW 171
// end ;
4561: GO 4412
4563: POP
4564: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 and ( GetCargo ( powell_trans [ 3 ] , mat_cans ) = 0 ) and ( GetCargo ( powell_trans [ 4 ] , mat_cans ) = 0 ) ;
4565: LD_EXP 23
4569: PUSH
4570: LD_INT 1
4572: ARRAY
4573: PPUSH
4574: LD_INT 54
4576: PPUSH
4577: LD_INT 42
4579: PPUSH
4580: CALL_OW 297
4584: PUSH
4585: LD_INT 4
4587: LESS
4588: PUSH
4589: LD_EXP 23
4593: PUSH
4594: LD_INT 3
4596: ARRAY
4597: PPUSH
4598: LD_INT 1
4600: PPUSH
4601: CALL_OW 289
4605: PUSH
4606: LD_INT 0
4608: EQUAL
4609: AND
4610: PUSH
4611: LD_EXP 23
4615: PUSH
4616: LD_INT 4
4618: ARRAY
4619: PPUSH
4620: LD_INT 1
4622: PPUSH
4623: CALL_OW 289
4627: PUSH
4628: LD_INT 0
4630: EQUAL
4631: AND
4632: IFFALSE 4392
// DialogueOn ;
4634: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4638: LD_INT 53
4640: PPUSH
4641: LD_INT 35
4643: PPUSH
4644: CALL_OW 86
// un := powell_trans [ 1 ] ;
4648: LD_ADDR_VAR 0 5
4652: PUSH
4653: LD_EXP 23
4657: PUSH
4658: LD_INT 1
4660: ARRAY
4661: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4662: LD_VAR 0 5
4666: PPUSH
4667: LD_STRING D4-Mech1-1
4669: PPUSH
4670: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4674: LD_EXP 17
4678: PPUSH
4679: LD_STRING D4-JMM-1
4681: PPUSH
4682: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4686: LD_VAR 0 5
4690: PPUSH
4691: LD_STRING D4-Mech1-2
4693: PPUSH
4694: CALL_OW 88
// powell_happy := false ;
4698: LD_ADDR_VAR 0 6
4702: PUSH
4703: LD_INT 0
4705: ST_TO_ADDR
// take_cargo := false ;
4706: LD_ADDR_VAR 0 7
4710: PUSH
4711: LD_INT 0
4713: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4714: CALL 753 0 0
4718: PUSH
4719: LD_INT 60
4721: GREATEREQUAL
4722: IFFALSE 4770
// begin Say ( JMM , D5-JMM-1 ) ;
4724: LD_EXP 17
4728: PPUSH
4729: LD_STRING D5-JMM-1
4731: PPUSH
4732: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4736: LD_VAR 0 5
4740: PPUSH
4741: LD_STRING D6-Mech1-1
4743: PPUSH
4744: CALL_OW 88
// powell_happy := true ;
4748: LD_ADDR_VAR 0 6
4752: PUSH
4753: LD_INT 1
4755: ST_TO_ADDR
// take_cargo := true ;
4756: LD_ADDR_VAR 0 7
4760: PUSH
4761: LD_INT 1
4763: ST_TO_ADDR
// DialogueOff ;
4764: CALL_OW 7
// end else
4768: GO 5004
// if GetTerminalCargo > 0 then
4770: CALL 753 0 0
4774: PUSH
4775: LD_INT 0
4777: GREATER
4778: IFFALSE 4976
// begin case Query ( QWait ) of 1 :
4780: LD_STRING QWait
4782: PPUSH
4783: CALL_OW 97
4787: PUSH
4788: LD_INT 1
4790: DOUBLE
4791: EQUAL
4792: IFTRUE 4796
4794: GO 4887
4796: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4797: LD_EXP 17
4801: PPUSH
4802: LD_STRING D5b-JMM-1
4804: PPUSH
4805: CALL_OW 88
// DialogueOff ;
4809: CALL_OW 7
// wait ( 5 5$00 ) ;
4813: LD_INT 10500
4815: PPUSH
4816: CALL_OW 67
// if GetTerminalCargo < 60 then
4820: CALL 753 0 0
4824: PUSH
4825: LD_INT 60
4827: LESS
4828: IFFALSE 4869
// begin DialogueOn ;
4830: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4834: LD_EXP 3
4838: PPUSH
4839: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4843: LD_VAR 0 5
4847: PPUSH
4848: LD_STRING D6-Mech1-1a
4850: PPUSH
4851: CALL_OW 88
// DialogueOff ;
4855: CALL_OW 7
// powell_happy := false ;
4859: LD_ADDR_VAR 0 6
4863: PUSH
4864: LD_INT 0
4866: ST_TO_ADDR
// end else
4867: GO 4885
// begin powell_happy := true ;
4869: LD_ADDR_VAR 0 6
4873: PUSH
4874: LD_INT 1
4876: ST_TO_ADDR
// take_cargo := true ;
4877: LD_ADDR_VAR 0 7
4881: PUSH
4882: LD_INT 1
4884: ST_TO_ADDR
// end ; end ; 2 :
4885: GO 4974
4887: LD_INT 2
4889: DOUBLE
4890: EQUAL
4891: IFTRUE 4895
4893: GO 4934
4895: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4896: LD_EXP 17
4900: PPUSH
4901: LD_STRING D5b-JMM-1
4903: PPUSH
4904: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4908: LD_VAR 0 5
4912: PPUSH
4913: LD_STRING D6-Mech1-1a
4915: PPUSH
4916: CALL_OW 88
// DialogueOff ;
4920: CALL_OW 7
// take_cargo := true ;
4924: LD_ADDR_VAR 0 7
4928: PUSH
4929: LD_INT 1
4931: ST_TO_ADDR
// end ; 3 :
4932: GO 4974
4934: LD_INT 3
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4973
4942: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4943: LD_EXP 17
4947: PPUSH
4948: LD_STRING D5c-JMM-1
4950: PPUSH
4951: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4955: LD_VAR 0 5
4959: PPUSH
4960: LD_STRING D6-Mech1-1b
4962: PPUSH
4963: CALL_OW 88
// DialogueOff ;
4967: CALL_OW 7
// end ; end ;
4971: GO 4974
4973: POP
// end else
4974: GO 5004
// begin Say ( JMM , D5c-JMM-1 ) ;
4976: LD_EXP 17
4980: PPUSH
4981: LD_STRING D5c-JMM-1
4983: PPUSH
4984: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4988: LD_VAR 0 5
4992: PPUSH
4993: LD_STRING D6-Mech1-1b
4995: PPUSH
4996: CALL_OW 88
// DialogueOff ;
5000: CALL_OW 7
// end ; if take_cargo then
5004: LD_VAR 0 7
5008: IFFALSE 5087
// begin x := GetTerminalCargo ;
5010: LD_ADDR_VAR 0 2
5014: PUSH
5015: CALL 753 0 0
5019: ST_TO_ADDR
// if x > 60 then
5020: LD_VAR 0 2
5024: PUSH
5025: LD_INT 60
5027: GREATER
5028: IFFALSE 5038
// x := 60 ;
5030: LD_ADDR_VAR 0 2
5034: PUSH
5035: LD_INT 60
5037: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5038: LD_EXP 3
5042: PPUSH
5043: CALL_OW 274
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL 753 0 0
5055: PUSH
5056: LD_VAR 0 2
5060: MINUS
5061: PPUSH
5062: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5066: LD_EXP 23
5070: PUSH
5071: LD_INT 3
5073: ARRAY
5074: PPUSH
5075: LD_INT 3
5077: PPUSH
5078: LD_VAR 0 2
5082: PPUSH
5083: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5087: LD_EXP 23
5091: PPUSH
5092: LD_INT 43
5094: PPUSH
5095: LD_INT 3
5097: PPUSH
5098: CALL_OW 171
// x := 0 0$20 ;
5102: LD_ADDR_VAR 0 2
5106: PUSH
5107: LD_INT 700
5109: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5110: LD_INT 35
5112: PPUSH
5113: CALL_OW 67
// x := x - 0 0$01 ;
5117: LD_ADDR_VAR 0 2
5121: PUSH
5122: LD_VAR 0 2
5126: PUSH
5127: LD_INT 35
5129: MINUS
5130: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5131: LD_VAR 0 2
5135: PUSH
5136: LD_INT 0
5138: EQUAL
5139: PUSH
5140: LD_EXP 23
5144: PUSH
5145: LD_INT 3
5147: ARRAY
5148: PPUSH
5149: LD_INT 43
5151: PPUSH
5152: LD_INT 3
5154: PPUSH
5155: CALL_OW 297
5159: PUSH
5160: LD_INT 4
5162: LESS
5163: PUSH
5164: LD_EXP 23
5168: PUSH
5169: LD_INT 3
5171: ARRAY
5172: PPUSH
5173: LD_INT 43
5175: PPUSH
5176: LD_INT 3
5178: PPUSH
5179: CALL_OW 297
5183: PUSH
5184: LD_INT 4
5186: LESS
5187: AND
5188: OR
5189: IFFALSE 5110
// for i in powell_trans do
5191: LD_ADDR_VAR 0 4
5195: PUSH
5196: LD_EXP 23
5200: PUSH
5201: FOR_IN
5202: IFFALSE 5215
// RemoveUnit ( i ) ;
5204: LD_VAR 0 4
5208: PPUSH
5209: CALL_OW 64
5213: GO 5201
5215: POP
5216: POP
// if not powell_happy then
5217: LD_VAR 0 6
5221: NOT
5222: IFFALSE 5233
// powell_happy := - 1 ;
5224: LD_ADDR_VAR 0 6
5228: PUSH
5229: LD_INT 1
5231: NEG
5232: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5233: LD_VAR 0 6
5237: PPUSH
5238: LD_STRING EarlySiberite
5240: PPUSH
5241: CALL_OW 101
// if powell_happy then
5245: LD_VAR 0 6
5249: IFFALSE 5260
// ChangeMissionObjectives ( M3a ) else
5251: LD_STRING M3a
5253: PPUSH
5254: CALL_OW 337
5258: GO 5267
// ChangeMissionObjectives ( M3b ) ;
5260: LD_STRING M3b
5262: PPUSH
5263: CALL_OW 337
// ru_can_attack_terminal := true ;
5267: LD_ADDR_EXP 9
5271: PUSH
5272: LD_INT 1
5274: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5275: LD_INT 12600
5277: PPUSH
5278: CALL_OW 67
// repeat wait ( 0 0$03 ) ;
5282: LD_INT 105
5284: PPUSH
5285: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5289: LD_EXP 8
5293: NOT
5294: PUSH
5295: LD_EXP 33
5299: PUSH
5300: LD_INT 3
5302: LESS
5303: OR
5304: IFFALSE 5282
// ar_can_arrive := true ;
5306: LD_ADDR_EXP 10
5310: PUSH
5311: LD_INT 1
5313: ST_TO_ADDR
// end ;
5314: PPOPN 7
5316: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5317: LD_INT 1
5319: PPUSH
5320: LD_INT 20
5322: PPUSH
5323: CALL_OW 325
5327: IFFALSE 5468
5329: GO 5331
5331: DISABLE
5332: LD_INT 0
5334: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5335: LD_ADDR_VAR 0 1
5339: PUSH
5340: LD_INT 22
5342: PUSH
5343: LD_INT 1
5345: PUSH
5346: EMPTY
5347: LIST
5348: LIST
5349: PUSH
5350: LD_INT 26
5352: PUSH
5353: LD_INT 1
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 25
5362: PUSH
5363: LD_INT 4
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: PUSH
5380: LD_EXP 17
5384: PUSH
5385: LD_EXP 20
5389: PUSH
5390: LD_EXP 19
5394: PUSH
5395: LD_EXP 21
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: LIST
5404: LIST
5405: DIFF
5406: ST_TO_ADDR
// if not un then
5407: LD_VAR 0 1
5411: NOT
5412: IFFALSE 5416
// exit ;
5414: GO 5468
// DialogueOn ;
5416: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5420: LD_VAR 0 1
5424: PUSH
5425: LD_INT 1
5427: ARRAY
5428: PPUSH
5429: LD_STRING D13-Sci1-1
5431: PPUSH
5432: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5436: LD_EXP 17
5440: PPUSH
5441: LD_STRING D13-JMM-1
5443: PPUSH
5444: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5448: LD_VAR 0 1
5452: PUSH
5453: LD_INT 1
5455: ARRAY
5456: PPUSH
5457: LD_STRING D13-Sci1-2
5459: PPUSH
5460: CALL_OW 88
// DialogueOff ;
5464: CALL_OW 7
// end ;
5468: PPOPN 1
5470: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5471: LD_INT 1
5473: PPUSH
5474: CALL 784 0 1
5478: PUSH
5479: LD_INT 77
5481: GREATER
5482: PUSH
5483: LD_EXP 8
5487: NOT
5488: AND
5489: PUSH
5490: LD_INT 22
5492: PUSH
5493: LD_INT 1
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: PUSH
5500: LD_INT 25
5502: PUSH
5503: LD_INT 4
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 26
5512: PUSH
5513: LD_INT 1
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: LIST
5524: PPUSH
5525: CALL_OW 69
5529: PUSH
5530: LD_EXP 17
5534: PUSH
5535: LD_EXP 19
5539: PUSH
5540: LD_EXP 20
5544: PUSH
5545: LD_EXP 18
5549: PUSH
5550: LD_EXP 21
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: DIFF
5562: AND
5563: IFFALSE 5741
5565: GO 5567
5567: DISABLE
5568: LD_INT 0
5570: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5571: LD_ADDR_VAR 0 1
5575: PUSH
5576: LD_INT 22
5578: PUSH
5579: LD_INT 1
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 25
5588: PUSH
5589: LD_INT 4
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PUSH
5596: LD_INT 26
5598: PUSH
5599: LD_INT 1
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: PUSH
5616: LD_EXP 17
5620: PUSH
5621: LD_EXP 19
5625: PUSH
5626: LD_EXP 20
5630: PUSH
5631: LD_EXP 18
5635: PUSH
5636: LD_EXP 21
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: DIFF
5648: ST_TO_ADDR
// DialogueOn ;
5649: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5653: LD_VAR 0 1
5657: PUSH
5658: LD_INT 1
5660: ARRAY
5661: PPUSH
5662: LD_STRING D7-Sci1-1
5664: PPUSH
5665: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5669: LD_EXP 17
5673: PPUSH
5674: LD_STRING D7-JMM-1
5676: PPUSH
5677: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5681: LD_VAR 0 1
5685: PUSH
5686: LD_INT 1
5688: ARRAY
5689: PPUSH
5690: LD_STRING D7-Sci1-2
5692: PPUSH
5693: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5697: LD_EXP 17
5701: PPUSH
5702: LD_STRING D7-JMM-2
5704: PPUSH
5705: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5709: LD_VAR 0 1
5713: PUSH
5714: LD_INT 1
5716: ARRAY
5717: PPUSH
5718: LD_STRING D7-Sci1-3
5720: PPUSH
5721: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5725: LD_EXP 17
5729: PPUSH
5730: LD_STRING D7-JMM-3
5732: PPUSH
5733: CALL_OW 88
// DialogueOff ;
5737: CALL_OW 7
// end ;
5741: PPOPN 1
5743: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5744: LD_EXP 10
5748: IFFALSE 8974
5750: GO 5752
5752: DISABLE
5753: LD_INT 0
5755: PPUSH
5756: PPUSH
5757: PPUSH
5758: PPUSH
5759: PPUSH
5760: PPUSH
5761: PPUSH
5762: PPUSH
// begin PrepareArabian ;
5763: CALL 11083 0 0
// repeat wait ( 0 0$01 ) ;
5767: LD_INT 35
5769: PPUSH
5770: CALL_OW 67
// until ar_spawned ;
5774: LD_EXP 11
5778: IFFALSE 5767
// DialogueOn ;
5780: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5784: LD_EXP 25
5788: PPUSH
5789: LD_STRING D8-Ar1-1
5791: PPUSH
5792: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5796: LD_EXP 17
5800: PPUSH
5801: LD_STRING D8-JMM-1
5803: PPUSH
5804: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5808: LD_EXP 25
5812: PPUSH
5813: LD_STRING D8-Ar1-2
5815: PPUSH
5816: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
5820: LD_EXP 17
5824: PPUSH
5825: LD_STRING D8-JMM-2
5827: PPUSH
5828: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
5832: LD_EXP 25
5836: PPUSH
5837: LD_STRING D8-Ar1-3
5839: PPUSH
5840: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
5844: LD_EXP 17
5848: PPUSH
5849: LD_STRING D8-JMM-3
5851: PPUSH
5852: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
5856: LD_EXP 25
5860: PPUSH
5861: LD_STRING D8-Ar1-4
5863: PPUSH
5864: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
5868: LD_EXP 17
5872: PPUSH
5873: LD_STRING D8-JMM-4
5875: PPUSH
5876: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
5880: LD_EXP 25
5884: PPUSH
5885: LD_STRING D8-Ar1-5
5887: PPUSH
5888: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
5892: LD_EXP 17
5896: PPUSH
5897: LD_STRING D8-JMM-5
5899: PPUSH
5900: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
5904: LD_EXP 25
5908: PPUSH
5909: LD_STRING D8-Ar1-6
5911: PPUSH
5912: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
5916: LD_EXP 26
5920: PPUSH
5921: LD_STRING D8-Ar2-6
5923: PPUSH
5924: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
5928: LD_EXP 17
5932: PPUSH
5933: LD_STRING D8-JMM-6
5935: PPUSH
5936: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
5940: LD_EXP 26
5944: PPUSH
5945: LD_STRING D8-Ar2-7
5947: PPUSH
5948: CALL_OW 94
// case Query ( QBarracks ) of 1 :
5952: LD_STRING QBarracks
5954: PPUSH
5955: CALL_OW 97
5959: PUSH
5960: LD_INT 1
5962: DOUBLE
5963: EQUAL
5964: IFTRUE 5968
5966: GO 6003
5968: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
5969: LD_EXP 17
5973: PPUSH
5974: LD_STRING D8a-JMM-1
5976: PPUSH
5977: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
5981: LD_EXP 25
5985: PPUSH
5986: LD_STRING D8a-Ar1-1
5988: PPUSH
5989: CALL_OW 94
// player_want_mortar := true ;
5993: LD_ADDR_EXP 12
5997: PUSH
5998: LD_INT 1
6000: ST_TO_ADDR
// end ; 2 :
6001: GO 6161
6003: LD_INT 2
6005: DOUBLE
6006: EQUAL
6007: IFTRUE 6011
6009: GO 6125
6011: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6012: LD_EXP 17
6016: PPUSH
6017: LD_STRING D8b-JMM-1
6019: PPUSH
6020: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6024: LD_EXP 25
6028: PPUSH
6029: LD_STRING D8b-Ar1-1
6031: PPUSH
6032: CALL_OW 94
// case Query ( QInfo ) of 1 :
6036: LD_STRING QInfo
6038: PPUSH
6039: CALL_OW 97
6043: PUSH
6044: LD_INT 1
6046: DOUBLE
6047: EQUAL
6048: IFTRUE 6052
6050: GO 6087
6052: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6053: LD_EXP 17
6057: PPUSH
6058: LD_STRING D8b1-JMM-1
6060: PPUSH
6061: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6065: LD_EXP 25
6069: PPUSH
6070: LD_STRING D8b1-Ar1-1
6072: PPUSH
6073: CALL_OW 94
// player_want_info := 2 ;
6077: LD_ADDR_EXP 13
6081: PUSH
6082: LD_INT 2
6084: ST_TO_ADDR
// end ; 2 :
6085: GO 6123
6087: LD_INT 2
6089: DOUBLE
6090: EQUAL
6091: IFTRUE 6095
6093: GO 6122
6095: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6096: LD_EXP 17
6100: PPUSH
6101: LD_STRING D8b2-JMM-1
6103: PPUSH
6104: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6108: LD_EXP 25
6112: PPUSH
6113: LD_STRING D8b2-Ar1-1
6115: PPUSH
6116: CALL_OW 94
// end ; end ;
6120: GO 6123
6122: POP
// end ; 3 :
6123: GO 6161
6125: LD_INT 3
6127: DOUBLE
6128: EQUAL
6129: IFTRUE 6133
6131: GO 6160
6133: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6134: LD_EXP 17
6138: PPUSH
6139: LD_STRING D8c-JMM-1
6141: PPUSH
6142: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6146: LD_EXP 25
6150: PPUSH
6151: LD_STRING D8c-Ar1-1
6153: PPUSH
6154: CALL_OW 94
// end ; end ;
6158: GO 6161
6160: POP
// DialogueOff ;
6161: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6165: LD_ADDR_VAR 0 4
6169: PUSH
6170: LD_INT 22
6172: PUSH
6173: LD_INT 1
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: LD_INT 2
6182: PUSH
6183: LD_INT 30
6185: PUSH
6186: LD_INT 0
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: PUSH
6193: LD_INT 30
6195: PUSH
6196: LD_INT 1
6198: PUSH
6199: EMPTY
6200: LIST
6201: LIST
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: PPUSH
6217: LD_EXP 26
6221: PPUSH
6222: CALL_OW 74
6226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6227: LD_ADDR_VAR 0 3
6231: PUSH
6232: LD_INT 22
6234: PUSH
6235: LD_INT 2
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: PUSH
6242: LD_INT 21
6244: PUSH
6245: LD_INT 2
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL_OW 69
6260: ST_TO_ADDR
// time := 1 1$35 ;
6261: LD_ADDR_VAR 0 5
6265: PUSH
6266: LD_INT 3325
6268: ST_TO_ADDR
// no_oil_gain := false ;
6269: LD_ADDR_VAR 0 6
6273: PUSH
6274: LD_INT 0
6276: ST_TO_ADDR
// first_warn := false ;
6277: LD_ADDR_VAR 0 7
6281: PUSH
6282: LD_INT 0
6284: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6285: LD_EXP 12
6289: PUSH
6290: LD_EXP 13
6294: OR
6295: IFFALSE 6400
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6297: LD_EXP 32
6301: PPUSH
6302: LD_INT 25
6304: PUSH
6305: LD_INT 1
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL_OW 72
6316: PPUSH
6317: LD_VAR 0 4
6321: PPUSH
6322: CALL_OW 250
6326: PPUSH
6327: LD_VAR 0 4
6331: PPUSH
6332: CALL_OW 251
6336: PPUSH
6337: LD_VAR 0 4
6341: PPUSH
6342: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6346: LD_EXP 32
6350: PPUSH
6351: LD_INT 25
6353: PUSH
6354: LD_INT 1
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PPUSH
6361: CALL_OW 72
6365: PPUSH
6366: LD_INT 86
6368: PPUSH
6369: LD_INT 121
6371: PPUSH
6372: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6376: LD_EXP 32
6380: PPUSH
6381: LD_INT 25
6383: PUSH
6384: LD_INT 1
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: PPUSH
6391: CALL_OW 72
6395: PPUSH
6396: CALL_OW 200
// end ; if player_attacked_ar then
6400: LD_EXP 16
6404: IFFALSE 6408
// exit ;
6406: GO 8974
// if player_want_mortar then
6408: LD_EXP 12
6412: IFFALSE 7804
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6414: LD_EXP 26
6418: PPUSH
6419: LD_VAR 0 4
6423: PPUSH
6424: CALL_OW 250
6428: PUSH
6429: LD_INT 1
6431: PLUS
6432: PPUSH
6433: LD_VAR 0 4
6437: PPUSH
6438: CALL_OW 251
6442: PUSH
6443: LD_INT 1
6445: PLUS
6446: PPUSH
6447: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6451: LD_INT 35
6453: PPUSH
6454: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6458: LD_EXP 26
6462: PPUSH
6463: LD_VAR 0 4
6467: PPUSH
6468: CALL_OW 296
6472: PUSH
6473: LD_INT 4
6475: LESS
6476: IFFALSE 6451
// for i = 1 to 6 do
6478: LD_ADDR_VAR 0 1
6482: PUSH
6483: DOUBLE
6484: LD_INT 1
6486: DEC
6487: ST_TO_ADDR
6488: LD_INT 6
6490: PUSH
6491: FOR_TO
6492: IFFALSE 6689
// begin if player_attacked_ar then
6494: LD_EXP 16
6498: IFFALSE 6504
// exit ;
6500: POP
6501: POP
6502: GO 8974
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6504: LD_VAR 0 4
6508: PPUSH
6509: CALL_OW 274
6513: PPUSH
6514: LD_INT 2
6516: PPUSH
6517: CALL_OW 275
6521: PUSH
6522: LD_INT 10
6524: LESS
6525: PUSH
6526: LD_VAR 0 7
6530: NOT
6531: AND
6532: IFFALSE 6595
// begin first_warn := true ;
6534: LD_ADDR_VAR 0 7
6538: PUSH
6539: LD_INT 1
6541: ST_TO_ADDR
// DialogueOn ;
6542: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6546: LD_EXP 27
6550: PPUSH
6551: LD_STRING D9a-FAr1-1
6553: PPUSH
6554: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6558: LD_EXP 17
6562: PPUSH
6563: LD_STRING D9a-JMM-1
6565: PPUSH
6566: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6570: LD_EXP 25
6574: PPUSH
6575: LD_STRING D9a2-Ar1-1
6577: PPUSH
6578: CALL_OW 88
// DialogueOff ;
6582: CALL_OW 7
// wait ( time ) ;
6586: LD_VAR 0 5
6590: PPUSH
6591: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6595: LD_VAR 0 4
6599: PPUSH
6600: CALL_OW 274
6604: PPUSH
6605: LD_INT 2
6607: PPUSH
6608: CALL_OW 275
6612: PUSH
6613: LD_INT 10
6615: LESS
6616: IFFALSE 6642
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6618: LD_EXP 25
6622: PPUSH
6623: LD_STRING D9a3-Ar1-1
6625: PPUSH
6626: CALL_OW 88
// no_oil_gain := true ;
6630: LD_ADDR_VAR 0 6
6634: PUSH
6635: LD_INT 1
6637: ST_TO_ADDR
// break ;
6638: GO 6689
// end else
6640: GO 6687
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6642: LD_EXP 26
6646: PPUSH
6647: LD_VAR 0 4
6651: PPUSH
6652: LD_INT 2
6654: PPUSH
6655: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6659: LD_EXP 26
6663: PPUSH
6664: LD_VAR 0 3
6668: PUSH
6669: LD_VAR 0 1
6673: PUSH
6674: LD_INT 3
6676: MOD
6677: PUSH
6678: LD_INT 1
6680: PLUS
6681: ARRAY
6682: PPUSH
6683: CALL_OW 210
// end ; end ;
6687: GO 6491
6689: POP
6690: POP
// if not no_oil_gain then
6691: LD_VAR 0 6
6695: NOT
6696: IFFALSE 7804
// begin repeat wait ( 0 0$01 ) ;
6698: LD_INT 35
6700: PPUSH
6701: CALL_OW 67
// if player_attacked_ar then
6705: LD_EXP 16
6709: IFFALSE 6713
// exit ;
6711: GO 8974
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6713: LD_VAR 0 3
6717: PUSH
6718: LD_INT 1
6720: ARRAY
6721: PPUSH
6722: CALL_OW 261
6726: PUSH
6727: LD_INT 80
6729: GREATER
6730: PUSH
6731: LD_VAR 0 3
6735: PUSH
6736: LD_INT 2
6738: ARRAY
6739: PPUSH
6740: CALL_OW 261
6744: PUSH
6745: LD_INT 80
6747: GREATER
6748: AND
6749: PUSH
6750: LD_VAR 0 3
6754: PUSH
6755: LD_INT 3
6757: ARRAY
6758: PPUSH
6759: CALL_OW 261
6763: PUSH
6764: LD_INT 80
6766: GREATER
6767: AND
6768: IFFALSE 6698
// ComMoveXY ( Gali , 105 , 127 ) ;
6770: LD_EXP 26
6774: PPUSH
6775: LD_INT 105
6777: PPUSH
6778: LD_INT 127
6780: PPUSH
6781: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6785: LD_EXP 26
6789: PPUSH
6790: LD_INT 2
6792: PPUSH
6793: CALL_OW 173
// AddComHold ( Gali ) ;
6797: LD_EXP 26
6801: PPUSH
6802: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6806: LD_INT 35
6808: PPUSH
6809: CALL_OW 67
// if player_attacked_ar then
6813: LD_EXP 16
6817: IFFALSE 6821
// exit ;
6819: GO 8974
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
6821: LD_EXP 26
6825: PPUSH
6826: LD_INT 105
6828: PPUSH
6829: LD_INT 127
6831: PPUSH
6832: CALL_OW 297
6836: PUSH
6837: LD_INT 4
6839: LESS
6840: IFFALSE 6806
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6842: LD_VAR 0 4
6846: PPUSH
6847: CALL_OW 274
6851: PPUSH
6852: LD_INT 1
6854: PPUSH
6855: CALL_OW 275
6859: PUSH
6860: LD_INT 50
6862: LESS
6863: IFFALSE 7159
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
6865: LD_VAR 0 4
6869: PPUSH
6870: CALL_OW 274
6874: PPUSH
6875: LD_INT 1
6877: PPUSH
6878: CALL_OW 275
6882: PUSH
6883: LD_INT 0
6885: DOUBLE
6886: GREATEREQUAL
6887: IFFALSE 6895
6889: LD_INT 24
6891: DOUBLE
6892: LESSEQUAL
6893: IFTRUE 6897
6895: GO 6912
6897: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
6898: LD_EXP 26
6902: PPUSH
6903: LD_STRING D9b-Ar2-1
6905: PPUSH
6906: CALL_OW 88
6910: GO 6942
6912: LD_INT 25
6914: DOUBLE
6915: GREATEREQUAL
6916: IFFALSE 6924
6918: LD_INT 49
6920: DOUBLE
6921: LESSEQUAL
6922: IFTRUE 6926
6924: GO 6941
6926: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
6927: LD_EXP 26
6931: PPUSH
6932: LD_STRING D9b-Ar2-1a
6934: PPUSH
6935: CALL_OW 88
6939: GO 6942
6941: POP
// Say ( JMM , D9b-JMM-1 ) ;
6942: LD_EXP 17
6946: PPUSH
6947: LD_STRING D9b-JMM-1
6949: PPUSH
6950: CALL_OW 88
// x := 0 0$0 ;
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 0
6961: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6962: LD_INT 35
6964: PPUSH
6965: CALL_OW 67
// x := x + 0 0$1 ;
6969: LD_ADDR_VAR 0 2
6973: PUSH
6974: LD_VAR 0 2
6978: PUSH
6979: LD_INT 35
6981: PLUS
6982: ST_TO_ADDR
// if player_attacked_ar then
6983: LD_EXP 16
6987: IFFALSE 6991
// exit ;
6989: GO 8974
// until x >= time ;
6991: LD_VAR 0 2
6995: PUSH
6996: LD_VAR 0 5
7000: GREATEREQUAL
7001: IFFALSE 6962
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7003: LD_VAR 0 4
7007: PPUSH
7008: CALL_OW 274
7012: PPUSH
7013: LD_INT 1
7015: PPUSH
7016: CALL_OW 275
7020: PUSH
7021: LD_INT 50
7023: LESS
7024: IFFALSE 7157
// begin DialogueOn ;
7026: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7030: LD_EXP 25
7034: PPUSH
7035: LD_STRING D9c-Ar1-1
7037: PPUSH
7038: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7042: LD_EXP 17
7046: PPUSH
7047: LD_STRING D9c-JMM-1
7049: PPUSH
7050: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7054: LD_EXP 25
7058: PPUSH
7059: LD_STRING D9c-Ar1-2
7061: PPUSH
7062: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7066: LD_EXP 27
7070: PPUSH
7071: LD_STRING D9c-FAr1-2
7073: PPUSH
7074: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7078: LD_EXP 25
7082: PPUSH
7083: LD_STRING D9c-Ar1-3
7085: PPUSH
7086: CALL_OW 88
// case Query ( QInfo ) of 1 :
7090: LD_STRING QInfo
7092: PPUSH
7093: CALL_OW 97
7097: PUSH
7098: LD_INT 1
7100: DOUBLE
7101: EQUAL
7102: IFTRUE 7106
7104: GO 7129
7106: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7107: LD_EXP 17
7111: PPUSH
7112: LD_STRING D8b1-JMM-1
7114: PPUSH
7115: CALL_OW 88
// player_want_info := 2 ;
7119: LD_ADDR_EXP 13
7123: PUSH
7124: LD_INT 2
7126: ST_TO_ADDR
// end ; 2 :
7127: GO 7153
7129: LD_INT 2
7131: DOUBLE
7132: EQUAL
7133: IFTRUE 7137
7135: GO 7152
7137: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7138: LD_EXP 25
7142: PPUSH
7143: LD_STRING D8b2-Ar1-1
7145: PPUSH
7146: CALL_OW 88
// end ; end ;
7150: GO 7153
7152: POP
// DialogueOff ;
7153: CALL_OW 7
// end ; end else
7157: GO 7804
// begin RemoveEnvironmentArea ( mortarArea ) ;
7159: LD_INT 2
7161: PPUSH
7162: CALL_OW 355
// wait ( 1 ) ;
7166: LD_INT 1
7168: PPUSH
7169: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7173: LD_EXP 26
7177: PPUSH
7178: LD_INT 1
7180: PPUSH
7181: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 130 , 0 ) ;
7185: LD_EXP 26
7189: PPUSH
7190: LD_INT 4
7192: PPUSH
7193: LD_INT 107
7195: PPUSH
7196: LD_INT 130
7198: PPUSH
7199: LD_INT 0
7201: PPUSH
7202: CALL_OW 145
// repeat wait ( 1 ) ;
7206: LD_INT 1
7208: PPUSH
7209: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7213: LD_INT 30
7215: PUSH
7216: LD_INT 4
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 23
7225: PUSH
7226: LD_INT 2
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PUSH
7233: EMPTY
7234: LIST
7235: LIST
7236: PPUSH
7237: CALL_OW 69
7241: IFFALSE 7206
// SetSide ( Gali , 2 ) ;
7243: LD_EXP 26
7247: PPUSH
7248: LD_INT 2
7250: PPUSH
7251: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7255: LD_ADDR_VAR 0 8
7259: PUSH
7260: LD_INT 30
7262: PUSH
7263: LD_INT 4
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PUSH
7270: LD_INT 23
7272: PUSH
7273: LD_INT 2
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PPUSH
7284: CALL_OW 69
7288: PUSH
7289: LD_INT 1
7291: ARRAY
7292: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7293: LD_INT 35
7295: PPUSH
7296: CALL_OW 67
// if player_attacked_ar then
7300: LD_EXP 16
7304: IFFALSE 7308
// exit ;
7306: GO 8974
// until BuildingStatus ( b ) <> bs_build ;
7308: LD_VAR 0 8
7312: PPUSH
7313: CALL_OW 461
7317: PUSH
7318: LD_INT 1
7320: NONEQUAL
7321: IFFALSE 7293
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7323: LD_VAR 0 8
7327: PPUSH
7328: CALL_OW 302
7332: PUSH
7333: LD_VAR 0 4
7337: PPUSH
7338: CALL_OW 274
7342: PPUSH
7343: LD_INT 1
7345: PPUSH
7346: CALL_OW 275
7350: PUSH
7351: LD_INT 25
7353: GREATEREQUAL
7354: AND
7355: IFFALSE 7454
// begin ComUpgrade ( b ) ;
7357: LD_VAR 0 8
7361: PPUSH
7362: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7366: LD_EXP 26
7370: PPUSH
7371: LD_STRING h
7373: PUSH
7374: LD_VAR 0 8
7378: PPUSH
7379: CALL_OW 250
7383: PUSH
7384: LD_VAR 0 8
7388: PPUSH
7389: CALL_OW 251
7393: PUSH
7394: LD_VAR 0 8
7398: PUSH
7399: LD_INT 0
7401: PUSH
7402: LD_INT 0
7404: PUSH
7405: LD_INT 0
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: LIST
7416: PUSH
7417: EMPTY
7418: LIST
7419: PPUSH
7420: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7424: LD_INT 35
7426: PPUSH
7427: CALL_OW 67
// if player_attacked_ar then
7431: LD_EXP 16
7435: IFFALSE 7439
// exit ;
7437: GO 8974
// until BuildingStatus ( b ) <> bs_build ;
7439: LD_VAR 0 8
7443: PPUSH
7444: CALL_OW 461
7448: PUSH
7449: LD_INT 1
7451: NONEQUAL
7452: IFFALSE 7424
// end ; if b then
7454: LD_VAR 0 8
7458: IFFALSE 7469
// CenterNowOnUnits ( b ) ;
7460: LD_VAR 0 8
7464: PPUSH
7465: CALL_OW 87
// DialogueOn ;
7469: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7473: LD_EXP 26
7477: PPUSH
7478: LD_STRING D9d-Ar2-1
7480: PPUSH
7481: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7485: LD_EXP 25
7489: PPUSH
7490: LD_STRING D9d-Ar1-1
7492: PPUSH
7493: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7497: LD_EXP 17
7501: PPUSH
7502: LD_STRING D9d-JMM-1
7504: PPUSH
7505: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7509: LD_EXP 25
7513: PPUSH
7514: LD_STRING D9d-Ar1-2
7516: PPUSH
7517: CALL_OW 88
// DialogueOff ;
7521: CALL_OW 7
// i := [ ] ;
7525: LD_ADDR_VAR 0 1
7529: PUSH
7530: EMPTY
7531: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7532: LD_VAR 0 4
7536: PPUSH
7537: CALL_OW 274
7541: PPUSH
7542: LD_INT 3
7544: PPUSH
7545: CALL_OW 275
7549: PUSH
7550: LD_INT 20
7552: GREATEREQUAL
7553: IFFALSE 7572
// i := i ^ [ 1 ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_VAR 0 1
7564: PUSH
7565: LD_INT 1
7567: PUSH
7568: EMPTY
7569: LIST
7570: ADD
7571: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7572: LD_VAR 0 4
7576: PPUSH
7577: CALL_OW 274
7581: PPUSH
7582: LD_INT 1
7584: PPUSH
7585: CALL_OW 275
7589: PUSH
7590: LD_INT 50
7592: GREATEREQUAL
7593: IFFALSE 7612
// i := i ^ [ 2 ] ;
7595: LD_ADDR_VAR 0 1
7599: PUSH
7600: LD_VAR 0 1
7604: PUSH
7605: LD_INT 2
7607: PUSH
7608: EMPTY
7609: LIST
7610: ADD
7611: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7612: LD_VAR 0 4
7616: PPUSH
7617: CALL_OW 274
7621: PPUSH
7622: LD_INT 2
7624: PPUSH
7625: CALL_OW 275
7629: PUSH
7630: LD_INT 80
7632: GREATEREQUAL
7633: IFFALSE 7652
// i := i ^ [ 3 ] ;
7635: LD_ADDR_VAR 0 1
7639: PUSH
7640: LD_VAR 0 1
7644: PUSH
7645: LD_INT 3
7647: PUSH
7648: EMPTY
7649: LIST
7650: ADD
7651: ST_TO_ADDR
// i := i diff 0 ;
7652: LD_ADDR_VAR 0 1
7656: PUSH
7657: LD_VAR 0 1
7661: PUSH
7662: LD_INT 0
7664: DIFF
7665: ST_TO_ADDR
// if i then
7666: LD_VAR 0 1
7670: IFFALSE 7776
// begin i := i ^ [ 4 ] ;
7672: LD_ADDR_VAR 0 1
7676: PUSH
7677: LD_VAR 0 1
7681: PUSH
7682: LD_INT 4
7684: PUSH
7685: EMPTY
7686: LIST
7687: ADD
7688: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7689: LD_STRING QInfo2
7691: PPUSH
7692: CALL_OW 97
7696: PUSH
7697: LD_INT 1
7699: DOUBLE
7700: EQUAL
7701: IFTRUE 7705
7703: GO 7716
7705: POP
// player_want_info := 3 ; 2 :
7706: LD_ADDR_EXP 13
7710: PUSH
7711: LD_INT 3
7713: ST_TO_ADDR
7714: GO 7774
7716: LD_INT 2
7718: DOUBLE
7719: EQUAL
7720: IFTRUE 7724
7722: GO 7735
7724: POP
// player_want_info := 1 ; 3 :
7725: LD_ADDR_EXP 13
7729: PUSH
7730: LD_INT 1
7732: ST_TO_ADDR
7733: GO 7774
7735: LD_INT 3
7737: DOUBLE
7738: EQUAL
7739: IFTRUE 7743
7741: GO 7754
7743: POP
// player_want_info := 2 ; 4 :
7744: LD_ADDR_EXP 13
7748: PUSH
7749: LD_INT 2
7751: ST_TO_ADDR
7752: GO 7774
7754: LD_INT 4
7756: DOUBLE
7757: EQUAL
7758: IFTRUE 7762
7760: GO 7773
7762: POP
// player_want_info := 0 ; end ;
7763: LD_ADDR_EXP 13
7767: PUSH
7768: LD_INT 0
7770: ST_TO_ADDR
7771: GO 7774
7773: POP
// end else
7774: GO 7804
// case Query ( QInfoNothing ) of 1 :
7776: LD_STRING QInfoNothing
7778: PPUSH
7779: CALL_OW 97
7783: PUSH
7784: LD_INT 1
7786: DOUBLE
7787: EQUAL
7788: IFTRUE 7792
7790: GO 7803
7792: POP
// player_want_info := 0 ; end ;
7793: LD_ADDR_EXP 13
7797: PUSH
7798: LD_INT 0
7800: ST_TO_ADDR
7801: GO 7804
7803: POP
// end ; end ; end ; if player_want_info then
7804: LD_EXP 13
7808: IFFALSE 8794
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7810: LD_ADDR_VAR 0 3
7814: PUSH
7815: LD_VAR 0 3
7819: PPUSH
7820: LD_INT 34
7822: PUSH
7823: LD_INT 32
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PPUSH
7830: CALL_OW 72
7834: ST_TO_ADDR
// if player_want_mortar then
7835: LD_EXP 12
7839: IFFALSE 8133
// begin case player_want_info of 1 :
7841: LD_EXP 13
7845: PUSH
7846: LD_INT 1
7848: DOUBLE
7849: EQUAL
7850: IFTRUE 7854
7852: GO 7865
7854: POP
// x := 5 ; 2 :
7855: LD_ADDR_VAR 0 2
7859: PUSH
7860: LD_INT 5
7862: ST_TO_ADDR
7863: GO 7904
7865: LD_INT 2
7867: DOUBLE
7868: EQUAL
7869: IFTRUE 7873
7871: GO 7884
7873: POP
// x := 8 ; 3 :
7874: LD_ADDR_VAR 0 2
7878: PUSH
7879: LD_INT 8
7881: ST_TO_ADDR
7882: GO 7904
7884: LD_INT 3
7886: DOUBLE
7887: EQUAL
7888: IFTRUE 7892
7890: GO 7903
7892: POP
// x := 2 ; end ;
7893: LD_ADDR_VAR 0 2
7897: PUSH
7898: LD_INT 2
7900: ST_TO_ADDR
7901: GO 7904
7903: POP
// for i = 1 to x do
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: DOUBLE
7910: LD_INT 1
7912: DEC
7913: ST_TO_ADDR
7914: LD_VAR 0 2
7918: PUSH
7919: FOR_TO
7920: IFFALSE 8076
// begin AddComTransport ( Gali , dep , player_want_info ) ;
7922: LD_EXP 26
7926: PPUSH
7927: LD_VAR 0 4
7931: PPUSH
7932: LD_EXP 13
7936: PPUSH
7937: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
7941: LD_EXP 26
7945: PPUSH
7946: LD_VAR 0 3
7950: PUSH
7951: LD_INT 1
7953: ARRAY
7954: PPUSH
7955: CALL_OW 172
// repeat wait ( 0 0$1 ) ;
7959: LD_INT 35
7961: PPUSH
7962: CALL_OW 67
// if player_attacked_ar then
7966: LD_EXP 16
7970: IFFALSE 7976
// exit ;
7972: POP
7973: POP
7974: GO 8974
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
7976: LD_EXP 26
7980: PPUSH
7981: LD_VAR 0 3
7985: PUSH
7986: LD_INT 1
7988: ARRAY
7989: PPUSH
7990: CALL_OW 296
7994: PUSH
7995: LD_INT 4
7997: LESS
7998: PUSH
7999: LD_EXP 26
8003: PPUSH
8004: LD_EXP 13
8008: PPUSH
8009: CALL_OW 289
8013: AND
8014: IFFALSE 7959
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8016: LD_VAR 0 3
8020: PUSH
8021: LD_INT 1
8023: ARRAY
8024: PPUSH
8025: LD_EXP 13
8029: PPUSH
8030: LD_VAR 0 3
8034: PUSH
8035: LD_INT 1
8037: ARRAY
8038: PPUSH
8039: LD_EXP 13
8043: PPUSH
8044: CALL_OW 289
8048: PUSH
8049: LD_INT 10
8051: PLUS
8052: PPUSH
8053: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8057: LD_EXP 26
8061: PPUSH
8062: LD_EXP 13
8066: PPUSH
8067: LD_INT 0
8069: PPUSH
8070: CALL_OW 290
// end ;
8074: GO 7919
8076: POP
8077: POP
// repeat wait ( 0 0$1 ) ;
8078: LD_INT 35
8080: PPUSH
8081: CALL_OW 67
// if player_attacked_ar then
8085: LD_EXP 16
8089: IFFALSE 8093
// exit ;
8091: GO 8974
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8093: LD_VAR 0 3
8097: PUSH
8098: LD_INT 1
8100: ARRAY
8101: PPUSH
8102: LD_EXP 13
8106: PPUSH
8107: CALL_OW 289
8111: PUSH
8112: LD_VAR 0 2
8116: PUSH
8117: LD_INT 10
8119: MUL
8120: EQUAL
8121: IFFALSE 8078
// no_oil_gain := false ;
8123: LD_ADDR_VAR 0 6
8127: PUSH
8128: LD_INT 0
8130: ST_TO_ADDR
// end else
8131: GO 8615
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8133: LD_ADDR_VAR 0 3
8137: PUSH
8138: LD_INT 22
8140: PUSH
8141: LD_INT 2
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 21
8150: PUSH
8151: LD_INT 2
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8167: LD_EXP 26
8171: PPUSH
8172: LD_VAR 0 4
8176: PPUSH
8177: CALL_OW 250
8181: PUSH
8182: LD_INT 1
8184: PLUS
8185: PPUSH
8186: LD_VAR 0 4
8190: PPUSH
8191: CALL_OW 251
8195: PUSH
8196: LD_INT 1
8198: PLUS
8199: PPUSH
8200: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8204: LD_INT 35
8206: PPUSH
8207: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8211: LD_EXP 26
8215: PPUSH
8216: LD_VAR 0 4
8220: PPUSH
8221: CALL_OW 296
8225: PUSH
8226: LD_INT 4
8228: LESS
8229: IFFALSE 8204
// for i = 1 to 6 do
8231: LD_ADDR_VAR 0 1
8235: PUSH
8236: DOUBLE
8237: LD_INT 1
8239: DEC
8240: ST_TO_ADDR
8241: LD_INT 6
8243: PUSH
8244: FOR_TO
8245: IFFALSE 8442
// begin if player_attacked_ar then
8247: LD_EXP 16
8251: IFFALSE 8257
// exit ;
8253: POP
8254: POP
8255: GO 8974
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8257: LD_VAR 0 4
8261: PPUSH
8262: CALL_OW 274
8266: PPUSH
8267: LD_INT 2
8269: PPUSH
8270: CALL_OW 275
8274: PUSH
8275: LD_INT 10
8277: LESS
8278: PUSH
8279: LD_VAR 0 7
8283: NOT
8284: AND
8285: IFFALSE 8348
// begin first_warn := true ;
8287: LD_ADDR_VAR 0 7
8291: PUSH
8292: LD_INT 1
8294: ST_TO_ADDR
// DialogueOn ;
8295: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8299: LD_EXP 27
8303: PPUSH
8304: LD_STRING D9a-FAr1-1
8306: PPUSH
8307: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8311: LD_EXP 17
8315: PPUSH
8316: LD_STRING D9a-JMM-1
8318: PPUSH
8319: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8323: LD_EXP 25
8327: PPUSH
8328: LD_STRING D9a2-Ar1-1
8330: PPUSH
8331: CALL_OW 88
// DialogueOff ;
8335: CALL_OW 7
// wait ( time ) ;
8339: LD_VAR 0 5
8343: PPUSH
8344: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8348: LD_VAR 0 4
8352: PPUSH
8353: CALL_OW 274
8357: PPUSH
8358: LD_INT 2
8360: PPUSH
8361: CALL_OW 275
8365: PUSH
8366: LD_INT 10
8368: LESS
8369: IFFALSE 8395
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8371: LD_EXP 25
8375: PPUSH
8376: LD_STRING D9a3-Ar1-1
8378: PPUSH
8379: CALL_OW 88
// no_oil_gain := true ;
8383: LD_ADDR_VAR 0 6
8387: PUSH
8388: LD_INT 1
8390: ST_TO_ADDR
// break ;
8391: GO 8442
// end else
8393: GO 8440
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8395: LD_EXP 26
8399: PPUSH
8400: LD_VAR 0 4
8404: PPUSH
8405: LD_INT 2
8407: PPUSH
8408: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8412: LD_EXP 26
8416: PPUSH
8417: LD_VAR 0 3
8421: PUSH
8422: LD_VAR 0 1
8426: PUSH
8427: LD_INT 3
8429: MOD
8430: PUSH
8431: LD_INT 1
8433: PLUS
8434: ARRAY
8435: PPUSH
8436: CALL_OW 210
// end ; end ;
8440: GO 8244
8442: POP
8443: POP
// repeat wait ( 0 0$1 ) ;
8444: LD_INT 35
8446: PPUSH
8447: CALL_OW 67
// if player_attacked_ar then
8451: LD_EXP 16
8455: IFFALSE 8459
// exit ;
8457: GO 8974
// for i in tmp do
8459: LD_ADDR_VAR 0 1
8463: PUSH
8464: LD_VAR 0 3
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8501
// if GetFuel ( i ) < 100 then
8472: LD_VAR 0 1
8476: PPUSH
8477: CALL_OW 261
8481: PUSH
8482: LD_INT 100
8484: LESS
8485: IFFALSE 8499
// begin x := i ;
8487: LD_ADDR_VAR 0 2
8491: PUSH
8492: LD_VAR 0 1
8496: ST_TO_ADDR
// break ;
8497: GO 8501
// end ;
8499: GO 8469
8501: POP
8502: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8503: LD_EXP 26
8507: PPUSH
8508: CALL_OW 314
8512: NOT
8513: PUSH
8514: LD_EXP 26
8518: PPUSH
8519: CALL_OW 281
8523: NOT
8524: AND
8525: IFFALSE 8558
// begin ComTransport ( Gali , dep , mat_oil ) ;
8527: LD_EXP 26
8531: PPUSH
8532: LD_VAR 0 4
8536: PPUSH
8537: LD_INT 2
8539: PPUSH
8540: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8544: LD_EXP 26
8548: PPUSH
8549: LD_VAR 0 2
8553: PPUSH
8554: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 1
8565: ARRAY
8566: PPUSH
8567: CALL_OW 261
8571: PUSH
8572: LD_INT 80
8574: GREATER
8575: PUSH
8576: LD_VAR 0 3
8580: PUSH
8581: LD_INT 2
8583: ARRAY
8584: PPUSH
8585: CALL_OW 261
8589: PUSH
8590: LD_INT 80
8592: GREATER
8593: AND
8594: PUSH
8595: LD_VAR 0 3
8599: PUSH
8600: LD_INT 3
8602: ARRAY
8603: PPUSH
8604: CALL_OW 261
8608: PUSH
8609: LD_INT 80
8611: GREATER
8612: AND
8613: IFFALSE 8444
// end ; ComHold ( Gali ) ;
8615: LD_EXP 26
8619: PPUSH
8620: CALL_OW 140
// if not no_oil_gain then
8624: LD_VAR 0 6
8628: NOT
8629: IFFALSE 8794
// begin DialogueOn ;
8631: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8635: LD_EXP 25
8639: PPUSH
8640: CALL_OW 87
// if player_want_mortar then
8644: LD_EXP 12
8648: IFFALSE 8674
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8650: LD_EXP 25
8654: PPUSH
8655: LD_STRING D9e-Ar1-1
8657: PPUSH
8658: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8662: LD_EXP 17
8666: PPUSH
8667: LD_STRING D10a-JMM-1
8669: PPUSH
8670: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8674: LD_EXP 25
8678: PPUSH
8679: LD_STRING D10a-Ar1-1
8681: PPUSH
8682: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8686: LD_EXP 26
8690: PPUSH
8691: LD_STRING D10a-Ar2-1
8693: PPUSH
8694: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8698: LD_EXP 27
8702: PPUSH
8703: LD_STRING D10a-FAr1-1
8705: PPUSH
8706: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8710: LD_EXP 26
8714: PPUSH
8715: LD_STRING D10a-Ar2-2
8717: PPUSH
8718: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8722: LD_EXP 27
8726: PPUSH
8727: LD_STRING D10a-FAr1-2
8729: PPUSH
8730: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8734: LD_EXP 25
8738: PPUSH
8739: LD_STRING D10a-Ar1-2
8741: PPUSH
8742: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8746: LD_EXP 17
8750: PPUSH
8751: LD_STRING D10a-JMM-2
8753: PPUSH
8754: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8758: LD_EXP 25
8762: PPUSH
8763: LD_STRING D10a-Ar1-3
8765: PPUSH
8766: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8770: LD_EXP 17
8774: PPUSH
8775: LD_STRING D10a-JMM-3
8777: PPUSH
8778: CALL_OW 88
// player_get_info := true ;
8782: LD_ADDR_EXP 15
8786: PUSH
8787: LD_INT 1
8789: ST_TO_ADDR
// DialogueOff ;
8790: CALL_OW 7
// end ; end ; if player_attacked_ar then
8794: LD_EXP 16
8798: IFFALSE 8802
// exit ;
8800: GO 8974
// if player_want_mortar or player_want_info then
8802: LD_EXP 12
8806: PUSH
8807: LD_EXP 13
8811: OR
8812: IFFALSE 8826
// Say ( Vervecken , D9f-Ar1-1 ) ;
8814: LD_EXP 25
8818: PPUSH
8819: LD_STRING D9f-Ar1-1
8821: PPUSH
8822: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8826: LD_INT 22
8828: PUSH
8829: LD_INT 2
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PPUSH
8836: CALL_OW 69
8840: PPUSH
8841: LD_INT 51
8843: PPUSH
8844: LD_INT 99
8846: PPUSH
8847: CALL_OW 111
// wait ( 0 0$1 ) ;
8851: LD_INT 35
8853: PPUSH
8854: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
8858: LD_INT 22
8860: PUSH
8861: LD_INT 2
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: LD_INT 92
8870: PUSH
8871: LD_INT 51
8873: PUSH
8874: LD_INT 99
8876: PUSH
8877: LD_INT 2
8879: PUSH
8880: EMPTY
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: PPUSH
8890: CALL_OW 69
8894: IFFALSE 8954
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
8896: LD_ADDR_VAR 0 1
8900: PUSH
8901: LD_INT 22
8903: PUSH
8904: LD_INT 2
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PUSH
8911: LD_INT 92
8913: PUSH
8914: LD_INT 51
8916: PUSH
8917: LD_INT 99
8919: PUSH
8920: LD_INT 2
8922: PUSH
8923: EMPTY
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: PPUSH
8933: CALL_OW 69
8937: PUSH
8938: FOR_IN
8939: IFFALSE 8952
// RemoveUnit ( i ) ;
8941: LD_VAR 0 1
8945: PPUSH
8946: CALL_OW 64
8950: GO 8938
8952: POP
8953: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
8954: LD_INT 22
8956: PUSH
8957: LD_INT 2
8959: PUSH
8960: EMPTY
8961: LIST
8962: LIST
8963: PPUSH
8964: CALL_OW 69
8968: PUSH
8969: LD_INT 0
8971: EQUAL
8972: IFFALSE 8826
// end ;
8974: PPOPN 8
8976: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
8977: LD_EXP 16
8981: IFFALSE 9334
8983: GO 8985
8985: DISABLE
8986: LD_INT 0
8988: PPUSH
8989: PPUSH
8990: PPUSH
8991: PPUSH
// begin ru_can_attack := true ;
8992: LD_ADDR_EXP 8
8996: PUSH
8997: LD_INT 1
8999: ST_TO_ADDR
// mine_launched := false ;
9000: LD_ADDR_VAR 0 3
9004: PUSH
9005: LD_INT 0
9007: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9008: LD_INT 22
9010: PUSH
9011: LD_INT 2
9013: PUSH
9014: EMPTY
9015: LIST
9016: LIST
9017: PPUSH
9018: CALL_OW 69
9022: PPUSH
9023: LD_INT 51
9025: PPUSH
9026: LD_INT 99
9028: PPUSH
9029: CALL_OW 111
// if IsOk ( Vervecken ) then
9033: LD_EXP 25
9037: PPUSH
9038: CALL_OW 302
9042: IFFALSE 9056
// Say ( Vervecken , D11a-Ar1-1 ) ;
9044: LD_EXP 25
9048: PPUSH
9049: LD_STRING D11a-Ar1-1
9051: PPUSH
9052: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9056: LD_ADDR_VAR 0 2
9060: PUSH
9061: LD_EXP 32
9065: PPUSH
9066: LD_INT 25
9068: PUSH
9069: LD_INT 1
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: PPUSH
9076: CALL_OW 72
9080: ST_TO_ADDR
// for i in tmp do
9081: LD_ADDR_VAR 0 1
9085: PUSH
9086: LD_VAR 0 2
9090: PUSH
9091: FOR_IN
9092: IFFALSE 9155
// if MineOfUnit ( i ) then
9094: LD_VAR 0 1
9098: PPUSH
9099: CALL_OW 459
9103: IFFALSE 9153
// begin x := MineOfUnit ( i ) ;
9105: LD_ADDR_VAR 0 4
9109: PUSH
9110: LD_VAR 0 1
9114: PPUSH
9115: CALL_OW 459
9119: ST_TO_ADDR
// mine_launched := true ;
9120: LD_ADDR_VAR 0 3
9124: PUSH
9125: LD_INT 1
9127: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9128: LD_VAR 0 4
9132: PUSH
9133: LD_INT 1
9135: ARRAY
9136: PPUSH
9137: LD_VAR 0 4
9141: PUSH
9142: LD_INT 2
9144: ARRAY
9145: PPUSH
9146: LD_INT 2
9148: PPUSH
9149: CALL_OW 456
// end ;
9153: GO 9091
9155: POP
9156: POP
// if mine_launched and IsOk ( Vervecken ) then
9157: LD_VAR 0 3
9161: PUSH
9162: LD_EXP 25
9166: PPUSH
9167: CALL_OW 302
9171: AND
9172: IFFALSE 9186
// Say ( Vervecken , D11b-Ar1-1 ) ;
9174: LD_EXP 25
9178: PPUSH
9179: LD_STRING D11b-Ar1-1
9181: PPUSH
9182: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9186: LD_INT 22
9188: PUSH
9189: LD_INT 2
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PPUSH
9196: CALL_OW 69
9200: PPUSH
9201: LD_INT 51
9203: PPUSH
9204: LD_INT 99
9206: PPUSH
9207: CALL_OW 111
// wait ( 0 0$1 ) ;
9211: LD_INT 35
9213: PPUSH
9214: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9218: LD_INT 22
9220: PUSH
9221: LD_INT 2
9223: PUSH
9224: EMPTY
9225: LIST
9226: LIST
9227: PUSH
9228: LD_INT 92
9230: PUSH
9231: LD_INT 51
9233: PUSH
9234: LD_INT 99
9236: PUSH
9237: LD_INT 2
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: PPUSH
9250: CALL_OW 69
9254: IFFALSE 9314
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9256: LD_ADDR_VAR 0 1
9260: PUSH
9261: LD_INT 22
9263: PUSH
9264: LD_INT 2
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: PUSH
9271: LD_INT 92
9273: PUSH
9274: LD_INT 51
9276: PUSH
9277: LD_INT 99
9279: PUSH
9280: LD_INT 2
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: LIST
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: PPUSH
9293: CALL_OW 69
9297: PUSH
9298: FOR_IN
9299: IFFALSE 9312
// RemoveUnit ( i ) ;
9301: LD_VAR 0 1
9305: PPUSH
9306: CALL_OW 64
9310: GO 9298
9312: POP
9313: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9314: LD_INT 22
9316: PUSH
9317: LD_INT 2
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: PUSH
9329: LD_INT 0
9331: EQUAL
9332: IFFALSE 9186
// end ;
9334: PPOPN 4
9336: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9337: LD_EXP 10
9341: IFFALSE 9520
9343: GO 9345
9345: DISABLE
9346: LD_INT 0
9348: PPUSH
// begin Wait ( 10 10$00 ) ;
9349: LD_INT 21000
9351: PPUSH
9352: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9356: LD_INT 22
9358: PUSH
9359: LD_INT 2
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PPUSH
9366: CALL_OW 69
9370: IFFALSE 9520
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9372: LD_INT 22
9374: PUSH
9375: LD_INT 2
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: PPUSH
9382: CALL_OW 69
9386: PPUSH
9387: LD_INT 51
9389: PPUSH
9390: LD_INT 99
9392: PPUSH
9393: CALL_OW 114
// wait ( 0 0$1 ) ;
9397: LD_INT 35
9399: PPUSH
9400: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9404: LD_INT 22
9406: PUSH
9407: LD_INT 2
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: LD_INT 92
9416: PUSH
9417: LD_INT 51
9419: PUSH
9420: LD_INT 99
9422: PUSH
9423: LD_INT 2
9425: PUSH
9426: EMPTY
9427: LIST
9428: LIST
9429: LIST
9430: LIST
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PPUSH
9436: CALL_OW 69
9440: IFFALSE 9500
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9442: LD_ADDR_VAR 0 1
9446: PUSH
9447: LD_INT 22
9449: PUSH
9450: LD_INT 2
9452: PUSH
9453: EMPTY
9454: LIST
9455: LIST
9456: PUSH
9457: LD_INT 92
9459: PUSH
9460: LD_INT 51
9462: PUSH
9463: LD_INT 99
9465: PUSH
9466: LD_INT 2
9468: PUSH
9469: EMPTY
9470: LIST
9471: LIST
9472: LIST
9473: LIST
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PPUSH
9479: CALL_OW 69
9483: PUSH
9484: FOR_IN
9485: IFFALSE 9498
// RemoveUnit ( i ) ;
9487: LD_VAR 0 1
9491: PPUSH
9492: CALL_OW 64
9496: GO 9484
9498: POP
9499: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9500: LD_INT 22
9502: PUSH
9503: LD_INT 2
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: PPUSH
9510: CALL_OW 69
9514: PUSH
9515: LD_INT 0
9517: EQUAL
9518: IFFALSE 9372
// end ; end ;
9520: PPOPN 1
9522: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9523: LD_EXP 4
9527: IFFALSE 10309
9529: GO 9531
9531: DISABLE
9532: LD_INT 0
9534: PPUSH
9535: PPUSH
9536: PPUSH
// begin Wait ( game_time ) ;
9537: LD_EXP 7
9541: PPUSH
9542: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9546: LD_INT 35
9548: PPUSH
9549: CALL_OW 67
// until ( not ru_can_attack ) ;
9553: LD_EXP 8
9557: NOT
9558: IFFALSE 9546
// Wait ( 0 0$35 ) ;
9560: LD_INT 1225
9562: PPUSH
9563: CALL_OW 67
// DialogueOn ;
9567: CALL_OW 6
// InGameOn ;
9571: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9575: LD_EXP 24
9579: PPUSH
9580: LD_STRING D12-Pow-1
9582: PPUSH
9583: CALL_OW 94
// InGameOff ;
9587: CALL_OW 9
// DialogueOff ;
9591: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9595: LD_STRING M4
9597: PPUSH
9598: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9602: LD_INT 5
9604: PPUSH
9605: LD_INT 1
9607: PPUSH
9608: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
9612: LD_INT 35
9614: PPUSH
9615: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_driving ] ] ] ) ;
9619: LD_INT 22
9621: PUSH
9622: LD_INT 1
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 21
9631: PUSH
9632: LD_INT 1
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: PPUSH
9643: CALL_OW 69
9647: PUSH
9648: LD_INT 5
9650: PPUSH
9651: LD_INT 22
9653: PUSH
9654: LD_INT 1
9656: PUSH
9657: EMPTY
9658: LIST
9659: LIST
9660: PUSH
9661: LD_INT 2
9663: PUSH
9664: LD_INT 21
9666: PUSH
9667: LD_INT 1
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 55
9676: PUSH
9677: EMPTY
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: LIST
9684: PUSH
9685: EMPTY
9686: LIST
9687: LIST
9688: PPUSH
9689: CALL_OW 70
9693: EQUAL
9694: IFFALSE 9612
// if not player_get_info then
9696: LD_EXP 15
9700: NOT
9701: IFFALSE 9712
// player_get_info := - 1 ;
9703: LD_ADDR_EXP 15
9707: PUSH
9708: LD_INT 1
9710: NEG
9711: ST_TO_ADDR
// AddMedal ( player_get_info , Information ) ;
9712: LD_EXP 15
9716: PPUSH
9717: LD_STRING Information
9719: PPUSH
9720: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9724: LD_ADDR_VAR 0 2
9728: PUSH
9729: LD_INT 22
9731: PUSH
9732: LD_INT 1
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: PUSH
9739: LD_INT 2
9741: PUSH
9742: LD_INT 25
9744: PUSH
9745: LD_INT 2
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: PUSH
9752: LD_INT 25
9754: PUSH
9755: LD_INT 16
9757: PUSH
9758: EMPTY
9759: LIST
9760: LIST
9761: PUSH
9762: LD_INT 34
9764: PUSH
9765: LD_INT 12
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: LIST
9776: LIST
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PPUSH
9782: CALL_OW 69
9786: ST_TO_ADDR
// sib := GetTerminalCargo ;
9787: LD_ADDR_VAR 0 3
9791: PUSH
9792: CALL 753 0 0
9796: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
9797: LD_ADDR_VAR 0 3
9801: PUSH
9802: LD_VAR 0 3
9806: PUSH
9807: LD_INT 6
9809: PPUSH
9810: LD_INT 3
9812: PPUSH
9813: CALL_OW 287
9817: PLUS
9818: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
9819: LD_ADDR_VAR 0 3
9823: PUSH
9824: LD_VAR 0 3
9828: PUSH
9829: LD_VAR 0 2
9833: PPUSH
9834: LD_INT 3
9836: PPUSH
9837: CALL_OW 289
9841: PLUS
9842: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
9843: LD_VAR 0 3
9847: PUSH
9848: LD_INT 2
9850: PUSH
9851: LD_OWVAR 67
9855: PLUS
9856: PUSH
9857: LD_INT 50
9859: MUL
9860: LESS
9861: IFFALSE 9886
// AddMedal ( - 2 * Difficulty + 1 , MuchSiberite ) else
9863: LD_INT 2
9865: NEG
9866: PUSH
9867: LD_OWVAR 67
9871: MUL
9872: PUSH
9873: LD_INT 1
9875: PLUS
9876: PPUSH
9877: LD_STRING MuchSiberite
9879: PPUSH
9880: CALL_OW 101
9884: GO 9896
// AddMedal ( 1 , MuchSiberite ) ;
9886: LD_INT 1
9888: PPUSH
9889: LD_STRING MuchSiberite
9891: PPUSH
9892: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
9896: LD_INT 22
9898: PUSH
9899: LD_INT 1
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: LD_INT 25
9911: PUSH
9912: LD_INT 1
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 25
9921: PUSH
9922: LD_INT 2
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: LD_INT 25
9931: PUSH
9932: LD_INT 3
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PUSH
9939: LD_INT 25
9941: PUSH
9942: LD_INT 4
9944: PUSH
9945: EMPTY
9946: LIST
9947: LIST
9948: PUSH
9949: LD_INT 25
9951: PUSH
9952: LD_INT 8
9954: PUSH
9955: EMPTY
9956: LIST
9957: LIST
9958: PUSH
9959: EMPTY
9960: LIST
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: PPUSH
9976: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
9980: LD_ADDR_VAR 0 2
9984: PUSH
9985: LD_INT 22
9987: PUSH
9988: LD_INT 1
9990: PUSH
9991: EMPTY
9992: LIST
9993: LIST
9994: PUSH
9995: LD_INT 25
9997: PUSH
9998: LD_INT 8
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PPUSH
10009: CALL_OW 69
10013: ST_TO_ADDR
// if tmp then
10014: LD_VAR 0 2
10018: IFFALSE 10049
// for i in tmp do
10020: LD_ADDR_VAR 0 1
10024: PUSH
10025: LD_VAR 0 2
10029: PUSH
10030: FOR_IN
10031: IFFALSE 10047
// SetClass ( i , 1 ) ;
10033: LD_VAR 0 1
10037: PPUSH
10038: LD_INT 1
10040: PPUSH
10041: CALL_OW 336
10045: GO 10030
10047: POP
10048: POP
// SaveVariable ( sib , 09_sibRes ) ;
10049: LD_VAR 0 3
10053: PPUSH
10054: LD_STRING 09_sibRes
10056: PPUSH
10057: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10061: LD_EXP 15
10065: PPUSH
10066: LD_STRING 09_arInfo
10068: PPUSH
10069: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10073: LD_EXP 17
10077: PPUSH
10078: LD_EXP 1
10082: PUSH
10083: LD_STRING JMM
10085: STR
10086: PPUSH
10087: CALL_OW 38
// if IsLive ( Gary ) then
10091: LD_EXP 18
10095: PPUSH
10096: CALL_OW 300
10100: IFFALSE 10120
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10102: LD_EXP 18
10106: PPUSH
10107: LD_EXP 1
10111: PUSH
10112: LD_STRING Gary
10114: STR
10115: PPUSH
10116: CALL_OW 38
// if IsLive ( Bobby ) then
10120: LD_EXP 19
10124: PPUSH
10125: CALL_OW 300
10129: IFFALSE 10149
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10131: LD_EXP 19
10135: PPUSH
10136: LD_EXP 1
10140: PUSH
10141: LD_STRING Bobby
10143: STR
10144: PPUSH
10145: CALL_OW 38
// if IsLive ( Cyrus ) then
10149: LD_EXP 20
10153: PPUSH
10154: CALL_OW 300
10158: IFFALSE 10178
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10160: LD_EXP 20
10164: PPUSH
10165: LD_EXP 1
10169: PUSH
10170: LD_STRING Cyrus
10172: STR
10173: PPUSH
10174: CALL_OW 38
// if IsLive ( Houten ) then
10178: LD_EXP 21
10182: PPUSH
10183: CALL_OW 300
10187: IFFALSE 10207
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10189: LD_EXP 21
10193: PPUSH
10194: LD_EXP 1
10198: PUSH
10199: LD_STRING Houten
10201: STR
10202: PPUSH
10203: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10207: LD_ADDR_VAR 0 2
10211: PUSH
10212: LD_INT 22
10214: PUSH
10215: LD_INT 1
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 2
10224: PUSH
10225: LD_INT 25
10227: PUSH
10228: LD_INT 1
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: LD_INT 25
10237: PUSH
10238: LD_INT 2
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 25
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: LD_INT 25
10257: PUSH
10258: LD_INT 4
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PPUSH
10276: CALL_OW 69
10280: ST_TO_ADDR
// if tmp then
10281: LD_VAR 0 2
10285: IFFALSE 10305
// SaveCharacters ( tmp , mission_prefix & others ) ;
10287: LD_VAR 0 2
10291: PPUSH
10292: LD_EXP 1
10296: PUSH
10297: LD_STRING others
10299: STR
10300: PPUSH
10301: CALL_OW 38
// YouWin ;
10305: CALL_OW 103
// end ; end_of_file
10309: PPOPN 3
10311: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10312: LD_VAR 0 1
10316: PPUSH
10317: CALL_OW 266
10321: PUSH
10322: LD_INT 0
10324: EQUAL
10325: PUSH
10326: LD_EXP 3
10330: NOT
10331: AND
10332: IFFALSE 10356
// begin terminal := b ;
10334: LD_ADDR_EXP 3
10338: PUSH
10339: LD_VAR 0 1
10343: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10344: LD_EXP 3
10348: PPUSH
10349: LD_STRING terminal
10351: PPUSH
10352: CALL_OW 500
// end ; end ;
10356: PPOPN 2
10358: END
// on BuildingComplete ( b ) do var i ;
10359: LD_INT 0
10361: PPUSH
// begin if GetSide ( b ) = 3 then
10362: LD_VAR 0 1
10366: PPUSH
10367: CALL_OW 255
10371: PUSH
10372: LD_INT 3
10374: EQUAL
10375: IFFALSE 10415
// for i = 1 to 4 do
10377: LD_ADDR_VAR 0 2
10381: PUSH
10382: DOUBLE
10383: LD_INT 1
10385: DEC
10386: ST_TO_ADDR
10387: LD_INT 4
10389: PUSH
10390: FOR_TO
10391: IFFALSE 10413
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10393: LD_ADDR_EXP 34
10397: PUSH
10398: LD_EXP 34
10402: PPUSH
10403: LD_INT 1
10405: PPUSH
10406: CALL_OW 3
10410: ST_TO_ADDR
10411: GO 10390
10413: POP
10414: POP
// end ;
10415: PPOPN 2
10417: END
// on VehicleConstructed ( veh , fac ) do var i ;
10418: LD_INT 0
10420: PPUSH
// begin if GetSide ( veh ) = 3 then
10421: LD_VAR 0 1
10425: PPUSH
10426: CALL_OW 255
10430: PUSH
10431: LD_INT 3
10433: EQUAL
10434: IFFALSE 10559
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10436: LD_VAR 0 1
10440: PPUSH
10441: CALL_OW 264
10445: PUSH
10446: LD_INT 53
10448: PUSH
10449: LD_INT 52
10451: PUSH
10452: LD_INT 51
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: LIST
10459: IN
10460: NOT
10461: IFFALSE 10479
// ru_force := ru_force ^ veh ;
10463: LD_ADDR_EXP 33
10467: PUSH
10468: LD_EXP 33
10472: PUSH
10473: LD_VAR 0 1
10477: ADD
10478: ST_TO_ADDR
// for i = 1 to 4 do
10479: LD_ADDR_VAR 0 3
10483: PUSH
10484: DOUBLE
10485: LD_INT 1
10487: DEC
10488: ST_TO_ADDR
10489: LD_INT 4
10491: PUSH
10492: FOR_TO
10493: IFFALSE 10515
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10495: LD_ADDR_EXP 35
10499: PUSH
10500: LD_EXP 35
10504: PPUSH
10505: LD_INT 1
10507: PPUSH
10508: CALL_OW 3
10512: ST_TO_ADDR
10513: GO 10492
10515: POP
10516: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10517: LD_VAR 0 1
10521: PPUSH
10522: CALL_OW 264
10526: PUSH
10527: LD_INT 53
10529: EQUAL
10530: IFFALSE 10559
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10532: LD_VAR 0 1
10536: PPUSH
10537: LD_INT 7
10539: PPUSH
10540: CALL 911 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10544: LD_VAR 0 1
10548: PPUSH
10549: LD_INT 170
10551: PPUSH
10552: LD_INT 235
10554: PPUSH
10555: CALL_OW 171
// end ; end ; end ;
10559: PPOPN 3
10561: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 1
10569: EQUAL
10570: PUSH
10571: LD_VAR 0 2
10575: PUSH
10576: LD_INT 2
10578: EQUAL
10579: AND
10580: PUSH
10581: LD_VAR 0 1
10585: PUSH
10586: LD_INT 2
10588: EQUAL
10589: PUSH
10590: LD_VAR 0 2
10594: PUSH
10595: LD_INT 1
10597: EQUAL
10598: AND
10599: OR
10600: IFFALSE 10610
// player_attacked_ar := true ;
10602: LD_ADDR_EXP 16
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
// end ;
10610: PPOPN 2
10612: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10613: LD_VAR 0 1
10617: PUSH
10618: LD_EXP 17
10622: EQUAL
10623: IFFALSE 10632
// YouLost ( JMM ) ;
10625: LD_STRING JMM
10627: PPUSH
10628: CALL_OW 104
// if un = terminal then
10632: LD_VAR 0 1
10636: PUSH
10637: LD_EXP 3
10641: EQUAL
10642: IFFALSE 10651
// YouLost ( Terminal ) ;
10644: LD_STRING Terminal
10646: PPUSH
10647: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10651: LD_VAR 0 1
10655: PUSH
10656: LD_INT 22
10658: PUSH
10659: LD_INT 3
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PUSH
10666: LD_INT 21
10668: PUSH
10669: LD_INT 3
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: PPUSH
10680: CALL_OW 69
10684: IN
10685: IFFALSE 10831
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10687: LD_VAR 0 1
10691: PPUSH
10692: CALL_OW 266
10696: PUSH
10697: LD_INT 33
10699: PUSH
10700: LD_INT 26
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: IN
10707: IFFALSE 10766
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10709: LD_ADDR_EXP 34
10713: PUSH
10714: LD_EXP 34
10718: PUSH
10719: LD_VAR 0 1
10723: PPUSH
10724: CALL_OW 266
10728: PUSH
10729: LD_VAR 0 1
10733: PPUSH
10734: CALL_OW 250
10738: PUSH
10739: LD_VAR 0 1
10743: PPUSH
10744: CALL_OW 251
10748: PUSH
10749: LD_VAR 0 1
10753: PPUSH
10754: CALL_OW 254
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: LIST
10763: LIST
10764: ADD
10765: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL_OW 266
10775: PUSH
10776: LD_INT 5
10778: EQUAL
10779: IFFALSE 10831
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10781: LD_ADDR_EXP 34
10785: PUSH
10786: LD_EXP 34
10790: PUSH
10791: LD_INT 4
10793: PUSH
10794: LD_VAR 0 1
10798: PPUSH
10799: CALL_OW 250
10803: PUSH
10804: LD_VAR 0 1
10808: PPUSH
10809: CALL_OW 251
10813: PUSH
10814: LD_VAR 0 1
10818: PPUSH
10819: CALL_OW 254
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: LIST
10828: LIST
10829: ADD
10830: ST_TO_ADDR
// end ; if un in ru_force then
10831: LD_VAR 0 1
10835: PUSH
10836: LD_EXP 33
10840: IN
10841: IFFALSE 10874
// begin ru_force := ru_force diff un ;
10843: LD_ADDR_EXP 33
10847: PUSH
10848: LD_EXP 33
10852: PUSH
10853: LD_VAR 0 1
10857: DIFF
10858: ST_TO_ADDR
// if not ru_force then
10859: LD_EXP 33
10863: NOT
10864: IFFALSE 10874
// ru_can_attack := false ;
10866: LD_ADDR_EXP 8
10870: PUSH
10871: LD_INT 0
10873: ST_TO_ADDR
// end ; end ; end_of_file
10874: PPOPN 1
10876: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
10877: LD_EXP 5
10881: PUSH
10882: LD_EXP 6
10886: AND
10887: IFFALSE 10965
10889: GO 10891
10891: DISABLE
10892: LD_INT 0
10894: PPUSH
// begin enable ;
10895: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
10896: LD_ADDR_VAR 0 1
10900: PUSH
10901: LD_INT 60
10903: PUSH
10904: CALL 753 0 0
10908: MINUS
10909: ST_TO_ADDR
// if sib < 0 then
10910: LD_VAR 0 1
10914: PUSH
10915: LD_INT 0
10917: LESS
10918: IFFALSE 10928
// sib := 0 ;
10920: LD_ADDR_VAR 0 1
10924: PUSH
10925: LD_INT 0
10927: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
10928: LD_ADDR_OWVAR 47
10932: PUSH
10933: LD_STRING #Am09-1
10935: PUSH
10936: LD_VAR 0 1
10940: PUSH
10941: LD_EXP 6
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: LIST
10950: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
10951: LD_ADDR_EXP 6
10955: PUSH
10956: LD_EXP 6
10960: PUSH
10961: LD_INT 35
10963: MINUS
10964: ST_TO_ADDR
// end ;
10965: PPOPN 1
10967: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
10968: LD_EXP 6
10972: PUSH
10973: LD_INT 0
10975: EQUAL
10976: IFFALSE 10988
10978: GO 10980
10980: DISABLE
// display_strings := [ ] ;
10981: LD_ADDR_OWVAR 47
10985: PUSH
10986: EMPTY
10987: ST_TO_ADDR
10988: END
// every 0 0$35 + 1 1$0 marked 01 do
10989: GO 10991
10991: DISABLE
// begin enable ;
10992: ENABLE
// CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
10993: LD_INT 1
10995: PPUSH
10996: LD_INT 5
10998: PPUSH
10999: CALL_OW 12
11003: PPUSH
11004: LD_INT 75
11006: PPUSH
11007: LD_INT 75
11009: PPUSH
11010: LD_INT 20
11012: PPUSH
11013: LD_INT 1
11015: PPUSH
11016: CALL_OW 56
// if tick > [ 9 9$0 , 8 8$0 , 7 7$0 ] [ Difficulty ] then
11020: LD_OWVAR 1
11024: PUSH
11025: LD_INT 18900
11027: PUSH
11028: LD_INT 16800
11030: PUSH
11031: LD_INT 14700
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: LIST
11038: PUSH
11039: LD_OWVAR 67
11043: ARRAY
11044: GREATER
11045: IFFALSE 11050
// disable ( 01 ) ;
11047: LD_INT 1
11049: DISABLE_MARKED
// end ;
11050: END
// every 2 2$30 trigger jmm_in_ovsyenko do
11051: LD_EXP 4
11055: IFFALSE 11082
11057: GO 11059
11059: DISABLE
// begin enable ;
11060: ENABLE
// CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11061: LD_INT 2
11063: PPUSH
11064: LD_INT 5
11066: PPUSH
11067: CALL_OW 12
11071: PPUSH
11072: LD_INT 8
11074: PPUSH
11075: LD_INT 1
11077: PPUSH
11078: CALL_OW 55
// end ; end_of_file
11082: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11083: LD_INT 0
11085: PPUSH
11086: PPUSH
11087: PPUSH
11088: PPUSH
11089: PPUSH
11090: PPUSH
// x := 76 ;
11091: LD_ADDR_VAR 0 5
11095: PUSH
11096: LD_INT 76
11098: ST_TO_ADDR
// y := 147 ;
11099: LD_ADDR_VAR 0 6
11103: PUSH
11104: LD_INT 147
11106: ST_TO_ADDR
// uc_side := 2 ;
11107: LD_ADDR_OWVAR 20
11111: PUSH
11112: LD_INT 2
11114: ST_TO_ADDR
// uc_nation := 2 ;
11115: LD_ADDR_OWVAR 21
11119: PUSH
11120: LD_INT 2
11122: ST_TO_ADDR
// InitHc ;
11123: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11127: LD_INT 1
11129: PPUSH
11130: LD_INT 1
11132: PPUSH
11133: LD_INT 6
11135: PPUSH
11136: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11140: LD_ADDR_OWVAR 26
11144: PUSH
11145: LD_STRING Nicolas Vervecken
11147: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11148: LD_ADDR_OWVAR 33
11152: PUSH
11153: LD_STRING SecondCharsGal
11155: ST_TO_ADDR
// hc_face_number := 3 ;
11156: LD_ADDR_OWVAR 34
11160: PUSH
11161: LD_INT 3
11163: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11164: LD_ADDR_OWVAR 29
11168: PUSH
11169: LD_INT 11
11171: PUSH
11172: LD_INT 10
11174: PUSH
11175: EMPTY
11176: LIST
11177: LIST
11178: ST_TO_ADDR
// Vervecken := CreateHuman ;
11179: LD_ADDR_EXP 25
11183: PUSH
11184: CALL_OW 44
11188: ST_TO_ADDR
// ar_force := Vervecken ;
11189: LD_ADDR_EXP 32
11193: PUSH
11194: LD_EXP 25
11198: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11199: LD_INT 1
11201: PPUSH
11202: LD_INT 2
11204: PPUSH
11205: LD_INT 6
11207: PPUSH
11208: CALL_OW 380
// hc_name := Louis Gali ;
11212: LD_ADDR_OWVAR 26
11216: PUSH
11217: LD_STRING Louis Gali
11219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11220: LD_ADDR_OWVAR 33
11224: PUSH
11225: LD_STRING SecondCharsGal
11227: ST_TO_ADDR
// hc_face_number := 2 ;
11228: LD_ADDR_OWVAR 34
11232: PUSH
11233: LD_INT 2
11235: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11236: LD_ADDR_OWVAR 29
11240: PUSH
11241: LD_INT 10
11243: PUSH
11244: LD_INT 11
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: ST_TO_ADDR
// Gali := CreateHuman ;
11251: LD_ADDR_EXP 26
11255: PUSH
11256: CALL_OW 44
11260: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11261: LD_ADDR_EXP 32
11265: PUSH
11266: LD_EXP 32
11270: PUSH
11271: LD_EXP 26
11275: ADD
11276: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11277: LD_INT 2
11279: PPUSH
11280: LD_INT 1
11282: PPUSH
11283: LD_INT 6
11285: PPUSH
11286: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11290: LD_ADDR_OWVAR 26
11294: PUSH
11295: LD_STRING Maria Bogdanovic
11297: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11298: LD_ADDR_OWVAR 33
11302: PUSH
11303: LD_STRING SecondCharsGal
11305: ST_TO_ADDR
// hc_face_number := 14 ;
11306: LD_ADDR_OWVAR 34
11310: PUSH
11311: LD_INT 14
11313: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11314: LD_ADDR_OWVAR 29
11318: PUSH
11319: LD_INT 12
11321: PUSH
11322: LD_INT 9
11324: PUSH
11325: EMPTY
11326: LIST
11327: LIST
11328: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11329: LD_ADDR_EXP 27
11333: PUSH
11334: CALL_OW 44
11338: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11339: LD_ADDR_EXP 32
11343: PUSH
11344: LD_EXP 32
11348: PUSH
11349: LD_EXP 27
11353: ADD
11354: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11355: LD_INT 1
11357: PPUSH
11358: LD_INT 3
11360: PPUSH
11361: LD_INT 6
11363: PPUSH
11364: CALL_OW 380
// hc_name = Kntor Radomr ;
11368: LD_ADDR_OWVAR 26
11372: PUSH
11373: LD_STRING Kntor Radomr
11375: ST_TO_ADDR
// hc_gallery = sandar ;
11376: LD_ADDR_OWVAR 33
11380: PUSH
11381: LD_STRING sandar
11383: ST_TO_ADDR
// hc_face_number = 12 ;
11384: LD_ADDR_OWVAR 34
11388: PUSH
11389: LD_INT 12
11391: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11392: LD_ADDR_OWVAR 29
11396: PUSH
11397: LD_INT 9
11399: PUSH
11400: LD_INT 9
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: ST_TO_ADDR
// Kantor = CreateHuman ;
11407: LD_ADDR_EXP 28
11411: PUSH
11412: CALL_OW 44
11416: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11417: LD_ADDR_EXP 32
11421: PUSH
11422: LD_EXP 32
11426: PUSH
11427: LD_EXP 28
11431: ADD
11432: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11433: LD_INT 1
11435: PPUSH
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 6
11441: PPUSH
11442: CALL_OW 380
// hc_name = Herczeg Farkas ;
11446: LD_ADDR_OWVAR 26
11450: PUSH
11451: LD_STRING Herczeg Farkas
11453: ST_TO_ADDR
// hc_gallery = sandar ;
11454: LD_ADDR_OWVAR 33
11458: PUSH
11459: LD_STRING sandar
11461: ST_TO_ADDR
// hc_face_number = 28 ;
11462: LD_ADDR_OWVAR 34
11466: PUSH
11467: LD_INT 28
11469: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11470: LD_ADDR_OWVAR 29
11474: PUSH
11475: LD_INT 10
11477: PUSH
11478: LD_INT 9
11480: PUSH
11481: EMPTY
11482: LIST
11483: LIST
11484: ST_TO_ADDR
// Herczeg = CreateHuman ;
11485: LD_ADDR_EXP 29
11489: PUSH
11490: CALL_OW 44
11494: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11495: LD_ADDR_EXP 32
11499: PUSH
11500: LD_EXP 32
11504: PUSH
11505: LD_EXP 29
11509: ADD
11510: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11511: LD_INT 1
11513: PPUSH
11514: LD_INT 1
11516: PPUSH
11517: LD_INT 6
11519: PPUSH
11520: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11524: LD_ADDR_OWVAR 26
11528: PUSH
11529: LD_STRING Ronn Horntvedt
11531: ST_TO_ADDR
// hc_gallery = sandar ;
11532: LD_ADDR_OWVAR 33
11536: PUSH
11537: LD_STRING sandar
11539: ST_TO_ADDR
// hc_face_number = 29 ;
11540: LD_ADDR_OWVAR 34
11544: PUSH
11545: LD_INT 29
11547: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11548: LD_ADDR_OWVAR 29
11552: PUSH
11553: LD_INT 11
11555: PUSH
11556: LD_INT 11
11558: PUSH
11559: EMPTY
11560: LIST
11561: LIST
11562: ST_TO_ADDR
// Ronn = CreateHuman ;
11563: LD_ADDR_EXP 30
11567: PUSH
11568: CALL_OW 44
11572: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11573: LD_ADDR_EXP 32
11577: PUSH
11578: LD_EXP 32
11582: PUSH
11583: LD_EXP 30
11587: ADD
11588: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11589: LD_INT 2
11591: PPUSH
11592: LD_INT 3
11594: PPUSH
11595: LD_INT 6
11597: PPUSH
11598: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11602: LD_ADDR_OWVAR 26
11606: PUSH
11607: LD_STRING Mia D. Mathiasen
11609: ST_TO_ADDR
// hc_gallery = sandar ;
11610: LD_ADDR_OWVAR 33
11614: PUSH
11615: LD_STRING sandar
11617: ST_TO_ADDR
// hc_face_number = 31 ;
11618: LD_ADDR_OWVAR 34
11622: PUSH
11623: LD_INT 31
11625: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
11626: LD_ADDR_OWVAR 29
11630: PUSH
11631: LD_INT 10
11633: PUSH
11634: LD_INT 10
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: ST_TO_ADDR
// Mia = CreateHuman ;
11641: LD_ADDR_EXP 31
11645: PUSH
11646: CALL_OW 44
11650: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
11651: LD_ADDR_EXP 32
11655: PUSH
11656: LD_EXP 32
11660: PUSH
11661: LD_EXP 31
11665: ADD
11666: ST_TO_ADDR
// for i = 1 to 2 do
11667: LD_ADDR_VAR 0 4
11671: PUSH
11672: DOUBLE
11673: LD_INT 1
11675: DEC
11676: ST_TO_ADDR
11677: LD_INT 2
11679: PUSH
11680: FOR_TO
11681: IFFALSE 11722
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
11683: LD_ADDR_VAR 0 3
11687: PUSH
11688: LD_VAR 0 3
11692: PUSH
11693: LD_INT 2
11695: PPUSH
11696: LD_INT 2
11698: PPUSH
11699: LD_INT 14
11701: PPUSH
11702: LD_INT 1
11704: PPUSH
11705: LD_INT 1
11707: PPUSH
11708: LD_INT 32
11710: PPUSH
11711: LD_INT 30
11713: PPUSH
11714: CALL 252 0 7
11718: ADD
11719: ST_TO_ADDR
11720: GO 11680
11722: POP
11723: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
11724: LD_ADDR_VAR 0 3
11728: PUSH
11729: LD_VAR 0 3
11733: PUSH
11734: LD_INT 2
11736: PPUSH
11737: LD_INT 2
11739: PPUSH
11740: LD_INT 14
11742: PPUSH
11743: LD_INT 1
11745: PPUSH
11746: LD_INT 1
11748: PPUSH
11749: LD_INT 26
11751: PPUSH
11752: LD_INT 33
11754: PPUSH
11755: CALL 252 0 7
11759: ADD
11760: ST_TO_ADDR
// tmp := tmp diff 0 ;
11761: LD_ADDR_VAR 0 3
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: LD_INT 0
11773: DIFF
11774: ST_TO_ADDR
// for i in ar_force do
11775: LD_ADDR_VAR 0 4
11779: PUSH
11780: LD_EXP 32
11784: PUSH
11785: FOR_IN
11786: IFFALSE 11929
// begin if GetClass ( i ) = 3 then
11788: LD_VAR 0 4
11792: PPUSH
11793: CALL_OW 257
11797: PUSH
11798: LD_INT 3
11800: EQUAL
11801: IFFALSE 11883
// begin SetDir ( tmp [ 1 ] , 1 ) ;
11803: LD_VAR 0 3
11807: PUSH
11808: LD_INT 1
11810: ARRAY
11811: PPUSH
11812: LD_INT 1
11814: PPUSH
11815: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
11819: LD_VAR 0 3
11823: PUSH
11824: LD_INT 1
11826: ARRAY
11827: PPUSH
11828: LD_VAR 0 5
11832: PPUSH
11833: LD_VAR 0 6
11837: PPUSH
11838: LD_INT 0
11840: PPUSH
11841: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
11845: LD_VAR 0 4
11849: PPUSH
11850: LD_VAR 0 3
11854: PUSH
11855: LD_INT 1
11857: ARRAY
11858: PPUSH
11859: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
11863: LD_ADDR_VAR 0 3
11867: PUSH
11868: LD_VAR 0 3
11872: PPUSH
11873: LD_INT 1
11875: PPUSH
11876: CALL_OW 3
11880: ST_TO_ADDR
// end else
11881: GO 11905
// PlaceUnitXY ( i , x , y , false ) ;
11883: LD_VAR 0 4
11887: PPUSH
11888: LD_VAR 0 5
11892: PPUSH
11893: LD_VAR 0 6
11897: PPUSH
11898: LD_INT 0
11900: PPUSH
11901: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
11905: LD_VAR 0 4
11909: PPUSH
11910: LD_INT 86
11912: PPUSH
11913: LD_INT 121
11915: PPUSH
11916: CALL_OW 111
// wait ( 0 0$2 ) ;
11920: LD_INT 70
11922: PPUSH
11923: CALL_OW 67
// end ;
11927: GO 11785
11929: POP
11930: POP
// ar_force := ar_force ^ tmp ;
11931: LD_ADDR_EXP 32
11935: PUSH
11936: LD_EXP 32
11940: PUSH
11941: LD_VAR 0 3
11945: ADD
11946: ST_TO_ADDR
// ar_spawned := true ;
11947: LD_ADDR_EXP 11
11951: PUSH
11952: LD_INT 1
11954: ST_TO_ADDR
// end ; end_of_file
11955: LD_VAR 0 1
11959: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
11960: LD_INT 0
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
11966: PPUSH
11967: PPUSH
11968: PPUSH
// InitHc ;
11969: CALL_OW 19
// uc_side := 3 ;
11973: LD_ADDR_OWVAR 20
11977: PUSH
11978: LD_INT 3
11980: ST_TO_ADDR
// uc_nation := 3 ;
11981: LD_ADDR_OWVAR 21
11985: PUSH
11986: LD_INT 3
11988: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
11989: LD_ADDR_VAR 0 5
11993: PUSH
11994: LD_INT 5
11996: PUSH
11997: LD_INT 6
11999: PUSH
12000: LD_INT 7
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PUSH
12008: LD_OWVAR 67
12012: ARRAY
12013: ST_TO_ADDR
// ru_force := [ ] ;
12014: LD_ADDR_EXP 33
12018: PUSH
12019: EMPTY
12020: ST_TO_ADDR
// ru_rebuild := [ ] ;
12021: LD_ADDR_EXP 34
12025: PUSH
12026: EMPTY
12027: ST_TO_ADDR
// ru_produce_list := [ ] ;
12028: LD_ADDR_EXP 35
12032: PUSH
12033: EMPTY
12034: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12035: LD_ADDR_VAR 0 6
12039: PUSH
12040: LD_INT 22
12042: PUSH
12043: LD_INT 3
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 30
12052: PUSH
12053: LD_INT 8
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: PUSH
12069: LD_INT 1
12071: ARRAY
12072: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12073: LD_ADDR_VAR 0 4
12077: PUSH
12078: LD_INT 43
12080: PUSH
12081: LD_INT 46
12083: PUSH
12084: LD_INT 45
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: LIST
12091: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12092: LD_ADDR_VAR 0 7
12096: PUSH
12097: LD_INT 22
12099: PUSH
12100: LD_INT 3
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 30
12109: PUSH
12110: LD_INT 1
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: EMPTY
12118: LIST
12119: LIST
12120: PPUSH
12121: CALL_OW 69
12125: PUSH
12126: LD_INT 1
12128: ARRAY
12129: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12130: LD_VAR 0 7
12134: PPUSH
12135: CALL_OW 274
12139: PPUSH
12140: LD_INT 1
12142: PPUSH
12143: LD_INT 5000
12145: PPUSH
12146: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12150: LD_VAR 0 7
12154: PPUSH
12155: CALL_OW 274
12159: PPUSH
12160: LD_INT 2
12162: PPUSH
12163: LD_INT 1000
12165: PPUSH
12166: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12170: LD_VAR 0 7
12174: PPUSH
12175: CALL_OW 274
12179: PPUSH
12180: LD_INT 3
12182: PPUSH
12183: LD_INT 30
12185: PPUSH
12186: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12190: LD_ADDR_VAR 0 2
12194: PUSH
12195: LD_INT 22
12197: PUSH
12198: LD_INT 3
12200: PUSH
12201: EMPTY
12202: LIST
12203: LIST
12204: PUSH
12205: LD_INT 30
12207: PUSH
12208: LD_INT 33
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PUSH
12215: EMPTY
12216: LIST
12217: LIST
12218: PPUSH
12219: CALL_OW 69
12223: PUSH
12224: FOR_IN
12225: IFFALSE 12257
// begin PlaceWeaponTurret ( i , tmp [ rand ( 1 , tmp ) ] ) ;
12227: LD_VAR 0 2
12231: PPUSH
12232: LD_VAR 0 4
12236: PUSH
12237: LD_INT 1
12239: PPUSH
12240: LD_VAR 0 4
12244: PPUSH
12245: CALL_OW 12
12249: ARRAY
12250: PPUSH
12251: CALL_OW 431
// end ;
12255: GO 12224
12257: POP
12258: POP
// for i = 1 to 4 do
12259: LD_ADDR_VAR 0 2
12263: PUSH
12264: DOUBLE
12265: LD_INT 1
12267: DEC
12268: ST_TO_ADDR
12269: LD_INT 4
12271: PUSH
12272: FOR_TO
12273: IFFALSE 12334
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12275: LD_INT 0
12277: PPUSH
12278: LD_INT 9
12280: PPUSH
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12290: CALL_OW 44
12294: PPUSH
12295: LD_INT 22
12297: PUSH
12298: LD_INT 3
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 30
12307: PUSH
12308: LD_INT 5
12310: PUSH
12311: EMPTY
12312: LIST
12313: LIST
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PPUSH
12319: CALL_OW 69
12323: PUSH
12324: LD_INT 1
12326: ARRAY
12327: PPUSH
12328: CALL_OW 52
// end ;
12332: GO 12272
12334: POP
12335: POP
// for i = 1 to 5 do
12336: LD_ADDR_VAR 0 2
12340: PUSH
12341: DOUBLE
12342: LD_INT 1
12344: DEC
12345: ST_TO_ADDR
12346: LD_INT 5
12348: PUSH
12349: FOR_TO
12350: IFFALSE 12411
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12352: LD_INT 0
12354: PPUSH
12355: LD_INT 3
12357: PPUSH
12358: LD_VAR 0 5
12362: PPUSH
12363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12367: CALL_OW 44
12371: PPUSH
12372: LD_INT 22
12374: PUSH
12375: LD_INT 3
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 30
12384: PUSH
12385: LD_INT 3
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PPUSH
12396: CALL_OW 69
12400: PUSH
12401: LD_INT 1
12403: ARRAY
12404: PPUSH
12405: CALL_OW 52
// end ;
12409: GO 12349
12411: POP
12412: POP
// for i = 1 to 4 do
12413: LD_ADDR_VAR 0 2
12417: PUSH
12418: DOUBLE
12419: LD_INT 1
12421: DEC
12422: ST_TO_ADDR
12423: LD_INT 4
12425: PUSH
12426: FOR_TO
12427: IFFALSE 12488
// begin PrepareHuman ( false , class_engineer , skill ) ;
12429: LD_INT 0
12431: PPUSH
12432: LD_INT 2
12434: PPUSH
12435: LD_VAR 0 5
12439: PPUSH
12440: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12444: CALL_OW 44
12448: PPUSH
12449: LD_INT 22
12451: PUSH
12452: LD_INT 3
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PUSH
12459: LD_INT 30
12461: PUSH
12462: LD_INT 1
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PPUSH
12473: CALL_OW 69
12477: PUSH
12478: LD_INT 1
12480: ARRAY
12481: PPUSH
12482: CALL_OW 52
// end ;
12486: GO 12426
12488: POP
12489: POP
// for i = 1 to 3 do
12490: LD_ADDR_VAR 0 2
12494: PUSH
12495: DOUBLE
12496: LD_INT 1
12498: DEC
12499: ST_TO_ADDR
12500: LD_INT 3
12502: PUSH
12503: FOR_TO
12504: IFFALSE 12537
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12506: LD_INT 0
12508: PPUSH
12509: LD_INT 4
12511: PPUSH
12512: LD_VAR 0 5
12516: PPUSH
12517: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12521: CALL_OW 44
12525: PPUSH
12526: LD_VAR 0 6
12530: PPUSH
12531: CALL_OW 52
// end ;
12535: GO 12503
12537: POP
12538: POP
// AddComResearch ( lab , tech_tech2 ) ;
12539: LD_VAR 0 6
12543: PPUSH
12544: LD_INT 49
12546: PPUSH
12547: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12551: LD_VAR 0 6
12555: PPUSH
12556: LD_INT 50
12558: PPUSH
12559: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12563: LD_VAR 0 6
12567: PPUSH
12568: LD_INT 51
12570: PPUSH
12571: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12575: LD_VAR 0 6
12579: PPUSH
12580: LD_INT 52
12582: PPUSH
12583: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12587: LD_VAR 0 6
12591: PPUSH
12592: LD_INT 69
12594: PPUSH
12595: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12599: LD_VAR 0 6
12603: PPUSH
12604: LD_INT 39
12606: PPUSH
12607: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
12611: LD_VAR 0 6
12615: PPUSH
12616: LD_INT 34
12618: PPUSH
12619: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
12623: LD_VAR 0 6
12627: PPUSH
12628: LD_INT 40
12630: PPUSH
12631: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
12635: LD_VAR 0 6
12639: PPUSH
12640: LD_INT 57
12642: PPUSH
12643: CALL_OW 184
// if Difficulty > 1 then
12647: LD_OWVAR 67
12651: PUSH
12652: LD_INT 1
12654: GREATER
12655: IFFALSE 12669
// AddComResearch ( lab , tech_comp2 ) ;
12657: LD_VAR 0 6
12661: PPUSH
12662: LD_INT 58
12664: PPUSH
12665: CALL_OW 184
// end ;
12669: LD_VAR 0 1
12673: RET
// every 7 7$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 do
12674: LD_INT 7
12676: PPUSH
12677: CALL_OW 353
12681: PUSH
12682: LD_INT 3
12684: GREATER
12685: IFFALSE 12720
12687: GO 12689
12689: DISABLE
// begin enable ;
12690: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
12691: LD_ADDR_EXP 35
12695: PUSH
12696: LD_EXP 35
12700: PUSH
12701: LD_INT 24
12703: PUSH
12704: LD_INT 1
12706: PUSH
12707: LD_INT 3
12709: PUSH
12710: LD_INT 53
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: LIST
12717: LIST
12718: ADD
12719: ST_TO_ADDR
// end ;
12720: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
12721: LD_INT 22
12723: PUSH
12724: LD_INT 3
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: PUSH
12731: LD_INT 21
12733: PUSH
12734: LD_INT 3
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PPUSH
12745: CALL_OW 69
12749: IFFALSE 13527
12751: GO 12753
12753: DISABLE
12754: LD_INT 0
12756: PPUSH
12757: PPUSH
12758: PPUSH
12759: PPUSH
12760: PPUSH
12761: PPUSH
12762: PPUSH
12763: PPUSH
// begin enable ;
12764: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12765: LD_ADDR_VAR 0 3
12769: PUSH
12770: LD_INT 22
12772: PUSH
12773: LD_INT 3
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 21
12782: PUSH
12783: LD_INT 3
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 3
12792: PUSH
12793: LD_INT 24
12795: PUSH
12796: LD_INT 1000
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: LIST
12811: PPUSH
12812: CALL_OW 69
12816: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12817: LD_ADDR_VAR 0 4
12821: PUSH
12822: LD_INT 22
12824: PUSH
12825: LD_INT 3
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: LD_INT 25
12834: PUSH
12835: LD_INT 2
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PPUSH
12846: CALL_OW 69
12850: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12851: LD_ADDR_VAR 0 5
12855: PUSH
12856: LD_INT 22
12858: PUSH
12859: LD_INT 3
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: LD_INT 30
12868: PUSH
12869: LD_INT 1
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PPUSH
12880: CALL_OW 69
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
12889: LD_ADDR_VAR 0 8
12893: PUSH
12894: LD_INT 22
12896: PUSH
12897: LD_INT 3
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: PUSH
12904: LD_INT 2
12906: PUSH
12907: LD_INT 30
12909: PUSH
12910: LD_INT 6
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PUSH
12917: LD_INT 30
12919: PUSH
12920: LD_INT 7
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 30
12929: PUSH
12930: LD_INT 8
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: LIST
12941: LIST
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PPUSH
12947: CALL_OW 69
12951: PUSH
12952: LD_INT 1
12954: ARRAY
12955: ST_TO_ADDR
// if not engs then
12956: LD_VAR 0 4
12960: NOT
12961: IFFALSE 12965
// exit ;
12963: GO 13527
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
12965: LD_ADDR_VAR 0 6
12969: PUSH
12970: LD_VAR 0 4
12974: PPUSH
12975: LD_INT 3
12977: PUSH
12978: LD_INT 24
12980: PUSH
12981: LD_INT 600
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PPUSH
12992: CALL_OW 72
12996: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
12997: LD_ADDR_VAR 0 7
13001: PUSH
13002: LD_INT 22
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: LD_INT 25
13014: PUSH
13015: LD_INT 4
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PPUSH
13026: CALL_OW 69
13030: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13031: LD_VAR 0 3
13035: NOT
13036: PUSH
13037: LD_EXP 34
13041: NOT
13042: AND
13043: IFFALSE 13103
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13045: LD_VAR 0 4
13049: PPUSH
13050: LD_INT 3
13052: PUSH
13053: LD_INT 54
13055: PUSH
13056: EMPTY
13057: LIST
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PPUSH
13063: CALL_OW 72
13067: IFFALSE 13101
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13069: LD_VAR 0 4
13073: PPUSH
13074: LD_INT 3
13076: PUSH
13077: LD_INT 54
13079: PUSH
13080: EMPTY
13081: LIST
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: PPUSH
13087: CALL_OW 72
13091: PPUSH
13092: LD_VAR 0 5
13096: PPUSH
13097: CALL_OW 120
// exit ;
13101: GO 13527
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13103: LD_VAR 0 4
13107: PPUSH
13108: LD_INT 54
13110: PUSH
13111: EMPTY
13112: LIST
13113: PPUSH
13114: CALL_OW 72
13118: IFFALSE 13140
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13120: LD_VAR 0 4
13124: PPUSH
13125: LD_INT 54
13127: PUSH
13128: EMPTY
13129: LIST
13130: PPUSH
13131: CALL_OW 72
13135: PPUSH
13136: CALL_OW 122
// if not tmp then
13140: LD_VAR 0 3
13144: NOT
13145: IFFALSE 13277
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13147: LD_INT 81
13149: PUSH
13150: LD_INT 3
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: PUSH
13157: LD_INT 92
13159: PUSH
13160: LD_INT 147
13162: PUSH
13163: LD_INT 212
13165: PUSH
13166: LD_INT 30
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: PPUSH
13179: CALL_OW 69
13183: NOT
13184: IFFALSE 13277
// begin if not HasTask ( engs [ 1 ] ) then
13186: LD_VAR 0 4
13190: PUSH
13191: LD_INT 1
13193: ARRAY
13194: PPUSH
13195: CALL_OW 314
13199: NOT
13200: IFFALSE 13277
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13202: LD_ADDR_VAR 0 2
13206: PUSH
13207: LD_VAR 0 4
13211: PPUSH
13212: LD_EXP 34
13216: PUSH
13217: LD_INT 1
13219: ARRAY
13220: PPUSH
13221: LD_EXP 34
13225: PUSH
13226: LD_INT 2
13228: ARRAY
13229: PPUSH
13230: LD_EXP 34
13234: PUSH
13235: LD_INT 3
13237: ARRAY
13238: PPUSH
13239: LD_EXP 34
13243: PUSH
13244: LD_INT 4
13246: ARRAY
13247: PPUSH
13248: CALL_OW 145
13252: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13253: LD_VAR 0 2
13257: PPUSH
13258: CALL_OW 266
13262: PUSH
13263: LD_INT 4
13265: EQUAL
13266: IFFALSE 13277
// AddComUpgrade ( i ) ;
13268: LD_VAR 0 2
13272: PPUSH
13273: CALL_OW 206
// end ; end ; end ; for i in engs do
13277: LD_ADDR_VAR 0 2
13281: PUSH
13282: LD_VAR 0 4
13286: PUSH
13287: FOR_IN
13288: IFFALSE 13406
// begin if i in to_heal and sci then
13290: LD_VAR 0 2
13294: PUSH
13295: LD_VAR 0 6
13299: IN
13300: PUSH
13301: LD_VAR 0 7
13305: AND
13306: IFFALSE 13357
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13308: LD_VAR 0 2
13312: PPUSH
13313: LD_INT 149
13315: PPUSH
13316: LD_INT 220
13318: PPUSH
13319: CALL_OW 297
13323: PUSH
13324: LD_INT 5
13326: LESS
13327: IFFALSE 13331
// continue ;
13329: GO 13287
// ComMoveXY ( i , 149 , 220 ) ;
13331: LD_VAR 0 2
13335: PPUSH
13336: LD_INT 149
13338: PPUSH
13339: LD_INT 220
13341: PPUSH
13342: CALL_OW 111
// AddComHold ( i ) ;
13346: LD_VAR 0 2
13350: PPUSH
13351: CALL_OW 200
// end else
13355: GO 13404
// if not HasTask ( i ) or WantsToAttack ( i ) then
13357: LD_VAR 0 2
13361: PPUSH
13362: CALL_OW 314
13366: NOT
13367: PUSH
13368: LD_VAR 0 2
13372: PPUSH
13373: CALL_OW 319
13377: OR
13378: IFFALSE 13404
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13380: LD_VAR 0 2
13384: PPUSH
13385: LD_VAR 0 3
13389: PPUSH
13390: LD_VAR 0 2
13394: PPUSH
13395: CALL_OW 74
13399: PPUSH
13400: CALL_OW 130
// end ;
13404: GO 13287
13406: POP
13407: POP
// if to_heal and sci then
13408: LD_VAR 0 6
13412: PUSH
13413: LD_VAR 0 7
13417: AND
13418: IFFALSE 13479
// begin if UnitFilter ( sci , [ f_inside ] ) then
13420: LD_VAR 0 7
13424: PPUSH
13425: LD_INT 54
13427: PUSH
13428: EMPTY
13429: LIST
13430: PPUSH
13431: CALL_OW 72
13435: IFFALSE 13459
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13437: LD_VAR 0 7
13441: PPUSH
13442: LD_INT 54
13444: PUSH
13445: EMPTY
13446: LIST
13447: PPUSH
13448: CALL_OW 72
13452: PPUSH
13453: CALL_OW 122
13457: GO 13477
// ComHeal ( sci , to_heal [ 1 ] ) ;
13459: LD_VAR 0 7
13463: PPUSH
13464: LD_VAR 0 6
13468: PUSH
13469: LD_INT 1
13471: ARRAY
13472: PPUSH
13473: CALL_OW 128
// end else
13477: GO 13527
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13479: LD_VAR 0 7
13483: PPUSH
13484: LD_INT 56
13486: PUSH
13487: EMPTY
13488: LIST
13489: PPUSH
13490: CALL_OW 72
13494: PUSH
13495: LD_VAR 0 8
13499: AND
13500: IFFALSE 13527
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13502: LD_VAR 0 7
13506: PPUSH
13507: LD_INT 56
13509: PUSH
13510: EMPTY
13511: LIST
13512: PPUSH
13513: CALL_OW 72
13517: PPUSH
13518: LD_VAR 0 8
13522: PPUSH
13523: CALL_OW 120
// end ;
13527: PPOPN 8
13529: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13530: LD_INT 22
13532: PUSH
13533: LD_INT 3
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: PUSH
13540: LD_INT 30
13542: PUSH
13543: LD_INT 3
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PUSH
13550: EMPTY
13551: LIST
13552: LIST
13553: PPUSH
13554: CALL_OW 69
13558: PUSH
13559: LD_EXP 35
13563: AND
13564: IFFALSE 13690
13566: GO 13568
13568: DISABLE
13569: LD_INT 0
13571: PPUSH
13572: PPUSH
13573: PPUSH
// begin enable ;
13574: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13575: LD_ADDR_VAR 0 3
13579: PUSH
13580: LD_INT 22
13582: PUSH
13583: LD_INT 3
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: LD_INT 30
13592: PUSH
13593: LD_INT 3
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PPUSH
13604: CALL_OW 69
13608: PUSH
13609: LD_INT 1
13611: ARRAY
13612: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
13613: LD_VAR 0 3
13617: PPUSH
13618: CALL_OW 313
13622: PUSH
13623: LD_INT 0
13625: EQUAL
13626: IFFALSE 13630
// exit ;
13628: GO 13690
// if BuildingStatus ( fac ) = bs_idle then
13630: LD_VAR 0 3
13634: PPUSH
13635: CALL_OW 461
13639: PUSH
13640: LD_INT 2
13642: EQUAL
13643: IFFALSE 13690
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
13645: LD_VAR 0 3
13649: PPUSH
13650: LD_EXP 35
13654: PUSH
13655: LD_INT 1
13657: ARRAY
13658: PPUSH
13659: LD_EXP 35
13663: PUSH
13664: LD_INT 2
13666: ARRAY
13667: PPUSH
13668: LD_EXP 35
13672: PUSH
13673: LD_INT 3
13675: ARRAY
13676: PPUSH
13677: LD_EXP 35
13681: PUSH
13682: LD_INT 4
13684: ARRAY
13685: PPUSH
13686: CALL_OW 125
// end ;
13690: PPOPN 3
13692: END
// export function PrepareAttack ( wave ) ; var i , un , tmp ; begin
13693: LD_INT 0
13695: PPUSH
13696: PPUSH
13697: PPUSH
13698: PPUSH
// uc_side := 3 ;
13699: LD_ADDR_OWVAR 20
13703: PUSH
13704: LD_INT 3
13706: ST_TO_ADDR
// uc_nation := 3 ;
13707: LD_ADDR_OWVAR 21
13711: PUSH
13712: LD_INT 3
13714: ST_TO_ADDR
// ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
13715: LD_ADDR_EXP 35
13719: PUSH
13720: LD_INT 24
13722: PUSH
13723: LD_INT 1
13725: PUSH
13726: LD_INT 3
13728: PUSH
13729: LD_INT 43
13731: PUSH
13732: EMPTY
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: ST_TO_ADDR
// for i = 1 to Difficulty do
13738: LD_ADDR_VAR 0 3
13742: PUSH
13743: DOUBLE
13744: LD_INT 1
13746: DEC
13747: ST_TO_ADDR
13748: LD_OWVAR 67
13752: PUSH
13753: FOR_TO
13754: IFFALSE 13803
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher , ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ;
13756: LD_ADDR_EXP 35
13760: PUSH
13761: LD_EXP 35
13765: PUSH
13766: LD_INT 24
13768: PUSH
13769: LD_INT 1
13771: PUSH
13772: LD_INT 3
13774: PUSH
13775: LD_INT 45
13777: PUSH
13778: LD_INT 24
13780: PUSH
13781: LD_INT 1
13783: PUSH
13784: LD_INT 3
13786: PUSH
13787: LD_INT 46
13789: PUSH
13790: EMPTY
13791: LIST
13792: LIST
13793: LIST
13794: LIST
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: ADD
13800: ST_TO_ADDR
13801: GO 13753
13803: POP
13804: POP
// repeat wait ( 0 0$1 ) ;
13805: LD_INT 35
13807: PPUSH
13808: CALL_OW 67
// until ru_produce_list < 4 ;
13812: LD_EXP 35
13816: PUSH
13817: LD_INT 4
13819: LESS
13820: IFFALSE 13805
// case wave of 1 :
13822: LD_VAR 0 1
13826: PUSH
13827: LD_INT 1
13829: DOUBLE
13830: EQUAL
13831: IFTRUE 13835
13833: GO 13920
13835: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
13836: LD_ADDR_VAR 0 3
13840: PUSH
13841: DOUBLE
13842: LD_INT 1
13844: DEC
13845: ST_TO_ADDR
13846: LD_INT 4
13848: PUSH
13849: LD_INT 5
13851: PUSH
13852: LD_INT 6
13854: PUSH
13855: EMPTY
13856: LIST
13857: LIST
13858: LIST
13859: PUSH
13860: LD_OWVAR 67
13864: ARRAY
13865: PUSH
13866: FOR_TO
13867: IFFALSE 13875
// Sold ;
13869: CALL 14045 0 0
13873: GO 13866
13875: POP
13876: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
13877: LD_ADDR_VAR 0 3
13881: PUSH
13882: DOUBLE
13883: LD_INT 1
13885: DEC
13886: ST_TO_ADDR
13887: LD_INT 2
13889: PUSH
13890: LD_INT 3
13892: PUSH
13893: LD_INT 3
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: LIST
13900: PUSH
13901: LD_OWVAR 67
13905: ARRAY
13906: PUSH
13907: FOR_TO
13908: IFFALSE 13916
// Tank ;
13910: CALL 14159 0 0
13914: GO 13907
13916: POP
13917: POP
// end ; 2 .. 9 :
13918: GO 14040
13920: LD_INT 2
13922: DOUBLE
13923: GREATEREQUAL
13924: IFFALSE 13932
13926: LD_INT 9
13928: DOUBLE
13929: LESSEQUAL
13930: IFTRUE 13934
13932: GO 14039
13934: POP
// begin for i = 1 to [ 6 , 6 , 8 ] [ Difficulty ] + ( wave div 2 ) do
13935: LD_ADDR_VAR 0 3
13939: PUSH
13940: DOUBLE
13941: LD_INT 1
13943: DEC
13944: ST_TO_ADDR
13945: LD_INT 6
13947: PUSH
13948: LD_INT 6
13950: PUSH
13951: LD_INT 8
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: LIST
13958: PUSH
13959: LD_OWVAR 67
13963: ARRAY
13964: PUSH
13965: LD_VAR 0 1
13969: PUSH
13970: LD_INT 2
13972: DIV
13973: PLUS
13974: PUSH
13975: FOR_TO
13976: IFFALSE 13984
// Sold ;
13978: CALL 14045 0 0
13982: GO 13975
13984: POP
13985: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
13986: LD_ADDR_VAR 0 3
13990: PUSH
13991: DOUBLE
13992: LD_INT 1
13994: DEC
13995: ST_TO_ADDR
13996: LD_INT 3
13998: PUSH
13999: LD_INT 4
14001: PUSH
14002: LD_INT 4
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: LIST
14009: PUSH
14010: LD_OWVAR 67
14014: ARRAY
14015: PUSH
14016: LD_VAR 0 1
14020: PUSH
14021: LD_INT 2
14023: DIV
14024: PLUS
14025: PUSH
14026: FOR_TO
14027: IFFALSE 14035
// Tank ;
14029: CALL 14159 0 0
14033: GO 14026
14035: POP
14036: POP
// end ; end ;
14037: GO 14040
14039: POP
// end ;
14040: LD_VAR 0 2
14044: RET
// function Sold ( ) ; var un , skill ; begin
14045: LD_INT 0
14047: PPUSH
14048: PPUSH
14049: PPUSH
// InitHc ;
14050: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14054: LD_ADDR_VAR 0 3
14058: PUSH
14059: LD_INT 6
14061: PUSH
14062: LD_INT 7
14064: PUSH
14065: LD_INT 7
14067: PUSH
14068: EMPTY
14069: LIST
14070: LIST
14071: LIST
14072: PUSH
14073: LD_OWVAR 67
14077: ARRAY
14078: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14079: LD_INT 0
14081: PPUSH
14082: LD_INT 1
14084: PUSH
14085: LD_INT 9
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: PUSH
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 2
14097: PPUSH
14098: CALL_OW 12
14102: ARRAY
14103: PPUSH
14104: LD_VAR 0 3
14108: PPUSH
14109: CALL_OW 380
// un := CreateHuman ;
14113: LD_ADDR_VAR 0 2
14117: PUSH
14118: CALL_OW 44
14122: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14123: LD_VAR 0 2
14127: PPUSH
14128: LD_INT 4
14130: PPUSH
14131: LD_INT 0
14133: PPUSH
14134: CALL_OW 49
// ru_force := ru_force ^ un ;
14138: LD_ADDR_EXP 33
14142: PUSH
14143: LD_EXP 33
14147: PUSH
14148: LD_VAR 0 2
14152: ADD
14153: ST_TO_ADDR
// end ;
14154: LD_VAR 0 1
14158: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14159: LD_INT 0
14161: PPUSH
14162: PPUSH
14163: PPUSH
14164: PPUSH
14165: PPUSH
// InitHc ;
14166: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14170: LD_ADDR_VAR 0 5
14174: PUSH
14175: LD_INT 5
14177: PUSH
14178: LD_INT 6
14180: PUSH
14181: LD_INT 7
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: LIST
14188: PUSH
14189: LD_OWVAR 67
14193: ARRAY
14194: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14195: LD_ADDR_VAR 0 3
14199: PUSH
14200: LD_INT 22
14202: PUSH
14203: LD_INT 24
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: PUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_INT 2
14215: PPUSH
14216: CALL_OW 12
14220: ARRAY
14221: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14222: LD_VAR 0 3
14226: PUSH
14227: LD_INT 22
14229: EQUAL
14230: IFFALSE 14265
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14232: LD_ADDR_VAR 0 4
14236: PUSH
14237: LD_INT 45
14239: PUSH
14240: LD_INT 43
14242: PUSH
14243: LD_INT 44
14245: PUSH
14246: EMPTY
14247: LIST
14248: LIST
14249: LIST
14250: PUSH
14251: LD_INT 1
14253: PPUSH
14254: LD_INT 3
14256: PPUSH
14257: CALL_OW 12
14261: ARRAY
14262: ST_TO_ADDR
14263: GO 14296
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14265: LD_ADDR_VAR 0 4
14269: PUSH
14270: LD_INT 46
14272: PUSH
14273: LD_INT 44
14275: PUSH
14276: LD_INT 45
14278: PUSH
14279: EMPTY
14280: LIST
14281: LIST
14282: LIST
14283: PUSH
14284: LD_INT 1
14286: PPUSH
14287: LD_INT 3
14289: PPUSH
14290: CALL_OW 12
14294: ARRAY
14295: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14296: LD_ADDR_VAR 0 2
14300: PUSH
14301: LD_INT 3
14303: PPUSH
14304: LD_INT 3
14306: PPUSH
14307: LD_VAR 0 3
14311: PPUSH
14312: LD_INT 1
14314: PPUSH
14315: LD_INT 3
14317: PUSH
14318: LD_INT 3
14320: PUSH
14321: LD_INT 3
14323: PUSH
14324: LD_INT 1
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 1
14335: PPUSH
14336: LD_INT 4
14338: PPUSH
14339: CALL_OW 12
14343: ARRAY
14344: PPUSH
14345: LD_VAR 0 4
14349: PPUSH
14350: LD_INT 99
14352: PPUSH
14353: CALL 252 0 7
14357: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14358: LD_VAR 0 2
14362: PPUSH
14363: CALL_OW 263
14367: PUSH
14368: LD_INT 1
14370: EQUAL
14371: IFFALSE 14402
// begin PrepareHuman ( false , 3 , skill ) ;
14373: LD_INT 0
14375: PPUSH
14376: LD_INT 3
14378: PPUSH
14379: LD_VAR 0 5
14383: PPUSH
14384: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
14388: CALL_OW 44
14392: PPUSH
14393: LD_VAR 0 2
14397: PPUSH
14398: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
14402: LD_VAR 0 2
14406: PPUSH
14407: LD_INT 3
14409: PPUSH
14410: LD_INT 0
14412: PPUSH
14413: CALL_OW 49
// ru_force := ru_force ^ un ;
14417: LD_ADDR_EXP 33
14421: PUSH
14422: LD_EXP 33
14426: PUSH
14427: LD_VAR 0 2
14431: ADD
14432: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
14433: LD_VAR 0 2
14437: PPUSH
14438: LD_INT 126
14440: PPUSH
14441: LD_INT 158
14443: PPUSH
14444: CALL_OW 111
// Wait ( 0 0$3 ) ;
14448: LD_INT 105
14450: PPUSH
14451: CALL_OW 67
// ComStop ( un ) ;
14455: LD_VAR 0 2
14459: PPUSH
14460: CALL_OW 141
// end ;
14464: LD_VAR 0 1
14468: RET
// every 0 0$1 do var i , time , wave ;
14469: GO 14471
14471: DISABLE
14472: LD_INT 0
14474: PPUSH
14475: PPUSH
14476: PPUSH
// begin time := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
14477: LD_ADDR_VAR 0 2
14481: PUSH
14482: LD_INT 25200
14484: PUSH
14485: LD_INT 23100
14487: PUSH
14488: LD_INT 21000
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: LIST
14495: PUSH
14496: LD_OWVAR 67
14500: ARRAY
14501: ST_TO_ADDR
// wait ( time ) ;
14502: LD_VAR 0 2
14506: PPUSH
14507: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
14511: LD_ADDR_VAR 0 2
14515: PUSH
14516: LD_INT 17850
14518: PUSH
14519: LD_INT 16450
14521: PUSH
14522: LD_INT 15750
14524: PUSH
14525: EMPTY
14526: LIST
14527: LIST
14528: LIST
14529: PUSH
14530: LD_OWVAR 67
14534: ARRAY
14535: ST_TO_ADDR
// wave := 0 ;
14536: LD_ADDR_VAR 0 3
14540: PUSH
14541: LD_INT 0
14543: ST_TO_ADDR
// while true do
14544: LD_INT 1
14546: IFFALSE 14643
// begin wave := wave + 1 ;
14548: LD_ADDR_VAR 0 3
14552: PUSH
14553: LD_VAR 0 3
14557: PUSH
14558: LD_INT 1
14560: PLUS
14561: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
14562: LD_INT 22
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PPUSH
14572: CALL_OW 69
14576: IFFALSE 14605
// repeat wait ( 0 0$1 ) ;
14578: LD_INT 35
14580: PPUSH
14581: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
14585: LD_INT 22
14587: PUSH
14588: LD_INT 2
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: PPUSH
14595: CALL_OW 69
14599: PUSH
14600: LD_INT 0
14602: EQUAL
14603: IFFALSE 14578
// if ru_force < 20 then
14605: LD_EXP 33
14609: PUSH
14610: LD_INT 20
14612: LESS
14613: IFFALSE 14624
// PrepareAttack ( wave ) ;
14615: LD_VAR 0 3
14619: PPUSH
14620: CALL 13693 0 1
// ru_can_attack := true ;
14624: LD_ADDR_EXP 8
14628: PUSH
14629: LD_INT 1
14631: ST_TO_ADDR
// wait ( time ) ;
14632: LD_VAR 0 2
14636: PPUSH
14637: CALL_OW 67
// end ;
14641: GO 14544
// end ;
14643: PPOPN 3
14645: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
14646: LD_EXP 8
14650: PUSH
14651: LD_EXP 33
14655: AND
14656: IFFALSE 15398
14658: GO 14660
14660: DISABLE
14661: LD_INT 0
14663: PPUSH
14664: PPUSH
14665: PPUSH
14666: PPUSH
14667: PPUSH
14668: PPUSH
14669: PPUSH
14670: PPUSH
14671: PPUSH
// begin enable ;
14672: ENABLE
// points1 := [ 107 , 123 ] ;
14673: LD_ADDR_VAR 0 4
14677: PUSH
14678: LD_INT 107
14680: PUSH
14681: LD_INT 123
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
14688: LD_ADDR_VAR 0 5
14692: PUSH
14693: LD_INT 55
14695: PUSH
14696: LD_INT 42
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
14703: LD_ADDR_VAR 0 6
14707: PUSH
14708: LD_INT 102
14710: PUSH
14711: LD_INT 140
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: LD_INT 105
14720: PUSH
14721: LD_INT 142
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: LD_INT 129
14730: PUSH
14731: LD_INT 131
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: LIST
14742: ST_TO_ADDR
// for i in ru_force do
14743: LD_ADDR_VAR 0 1
14747: PUSH
14748: LD_EXP 33
14752: PUSH
14753: FOR_IN
14754: IFFALSE 15396
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
14756: LD_ADDR_VAR 0 3
14760: PUSH
14761: LD_INT 81
14763: PUSH
14764: LD_INT 3
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PPUSH
14776: LD_VAR 0 1
14780: PPUSH
14781: CALL_OW 74
14785: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 10 then
14786: LD_VAR 0 1
14790: PPUSH
14791: LD_VAR 0 3
14795: PPUSH
14796: CALL_OW 296
14800: PUSH
14801: LD_INT 10
14803: LESS
14804: IFFALSE 14949
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
14806: LD_VAR 0 1
14810: PPUSH
14811: CALL_OW 247
14815: PUSH
14816: LD_INT 1
14818: EQUAL
14819: PUSH
14820: LD_VAR 0 1
14824: PPUSH
14825: CALL_OW 257
14829: PUSH
14830: LD_INT 1
14832: EQUAL
14833: AND
14834: PUSH
14835: LD_VAR 0 3
14839: PUSH
14840: LD_INT 21
14842: PUSH
14843: LD_INT 2
14845: PUSH
14846: EMPTY
14847: LIST
14848: LIST
14849: PUSH
14850: LD_INT 58
14852: PUSH
14853: EMPTY
14854: LIST
14855: PUSH
14856: EMPTY
14857: LIST
14858: LIST
14859: PPUSH
14860: CALL_OW 69
14864: IN
14865: AND
14866: IFFALSE 14884
// ComEnterUnit ( i , un ) else
14868: LD_VAR 0 1
14872: PPUSH
14873: LD_VAR 0 3
14877: PPUSH
14878: CALL_OW 120
14882: GO 14947
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 21
14891: PUSH
14892: LD_INT 2
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: PUSH
14899: LD_INT 58
14901: PUSH
14902: EMPTY
14903: LIST
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: PPUSH
14909: CALL_OW 69
14913: IN
14914: NOT
14915: IFFALSE 14933
// ComAttackUnit ( i , un ) else
14917: LD_VAR 0 1
14921: PPUSH
14922: LD_VAR 0 3
14926: PPUSH
14927: CALL_OW 115
14931: GO 14947
// ComAttackUnit ( i , JMM ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_EXP 17
14942: PPUSH
14943: CALL_OW 115
// end else
14947: GO 15394
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
14949: LD_VAR 0 1
14953: PPUSH
14954: LD_VAR 0 4
14958: PUSH
14959: LD_INT 1
14961: ARRAY
14962: PPUSH
14963: LD_VAR 0 4
14967: PUSH
14968: LD_INT 2
14970: ARRAY
14971: PPUSH
14972: CALL_OW 297
14976: PUSH
14977: LD_VAR 0 1
14981: PPUSH
14982: LD_VAR 0 5
14986: PUSH
14987: LD_INT 1
14989: ARRAY
14990: PPUSH
14991: LD_VAR 0 5
14995: PUSH
14996: LD_INT 2
14998: ARRAY
14999: PPUSH
15000: CALL_OW 297
15004: GREATER
15005: PUSH
15006: LD_EXP 9
15010: AND
15011: PUSH
15012: LD_INT 9
15014: PPUSH
15015: LD_INT 22
15017: PUSH
15018: LD_INT 1
15020: PUSH
15021: EMPTY
15022: LIST
15023: LIST
15024: PPUSH
15025: CALL_OW 70
15029: PUSH
15030: LD_INT 0
15032: EQUAL
15033: OR
15034: IFFALSE 15065
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15036: LD_VAR 0 1
15040: PPUSH
15041: LD_VAR 0 5
15045: PUSH
15046: LD_INT 1
15048: ARRAY
15049: PPUSH
15050: LD_VAR 0 5
15054: PUSH
15055: LD_INT 2
15057: ARRAY
15058: PPUSH
15059: CALL_OW 114
15063: GO 15394
// begin if GetWeapon ( i ) = ru_rocket_launcher then
15065: LD_VAR 0 1
15069: PPUSH
15070: CALL_OW 264
15074: PUSH
15075: LD_INT 45
15077: EQUAL
15078: IFFALSE 15259
// begin dist := 9999 ;
15080: LD_ADDR_VAR 0 8
15084: PUSH
15085: LD_INT 9999
15087: ST_TO_ADDR
// xy := 0 ;
15088: LD_ADDR_VAR 0 9
15092: PUSH
15093: LD_INT 0
15095: ST_TO_ADDR
// for x in pointsr do
15096: LD_ADDR_VAR 0 7
15100: PUSH
15101: LD_VAR 0 6
15105: PUSH
15106: FOR_IN
15107: IFFALSE 15255
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15109: LD_VAR 0 1
15113: PPUSH
15114: LD_VAR 0 7
15118: PUSH
15119: LD_INT 1
15121: ARRAY
15122: PPUSH
15123: LD_VAR 0 7
15127: PUSH
15128: LD_INT 2
15130: ARRAY
15131: PPUSH
15132: CALL_OW 297
15136: PUSH
15137: LD_VAR 0 8
15141: LESS
15142: IFFALSE 15187
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15144: LD_ADDR_VAR 0 8
15148: PUSH
15149: LD_VAR 0 1
15153: PPUSH
15154: LD_VAR 0 7
15158: PUSH
15159: LD_INT 1
15161: ARRAY
15162: PPUSH
15163: LD_VAR 0 7
15167: PUSH
15168: LD_INT 2
15170: ARRAY
15171: PPUSH
15172: CALL_OW 297
15176: ST_TO_ADDR
// xy := x ;
15177: LD_ADDR_VAR 0 9
15181: PUSH
15182: LD_VAR 0 7
15186: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15187: LD_VAR 0 9
15191: PUSH
15192: LD_VAR 0 1
15196: PPUSH
15197: LD_VAR 0 9
15201: PUSH
15202: LD_INT 1
15204: ARRAY
15205: PPUSH
15206: LD_VAR 0 9
15210: PUSH
15211: LD_INT 2
15213: ARRAY
15214: PPUSH
15215: CALL_OW 297
15219: PUSH
15220: LD_INT 9
15222: GREATER
15223: AND
15224: IFFALSE 15253
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15226: LD_VAR 0 1
15230: PPUSH
15231: LD_VAR 0 9
15235: PUSH
15236: LD_INT 1
15238: ARRAY
15239: PPUSH
15240: LD_VAR 0 9
15244: PUSH
15245: LD_INT 2
15247: ARRAY
15248: PPUSH
15249: CALL_OW 114
// end ;
15253: GO 15106
15255: POP
15256: POP
// end else
15257: GO 15394
// begin un := NearestUnitToUnit ( un , all_units diff un ) ;
15259: LD_ADDR_VAR 0 3
15263: PUSH
15264: LD_VAR 0 3
15268: PPUSH
15269: LD_OWVAR 3
15273: PUSH
15274: LD_VAR 0 3
15278: DIFF
15279: PPUSH
15280: CALL_OW 74
15284: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15285: LD_VAR 0 3
15289: PUSH
15290: LD_INT 21
15292: PUSH
15293: LD_INT 2
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: LD_INT 58
15302: PUSH
15303: EMPTY
15304: LIST
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PPUSH
15310: CALL_OW 69
15314: IN
15315: PUSH
15316: LD_VAR 0 3
15320: PUSH
15321: LD_INT 22
15323: PUSH
15324: LD_INT 3
15326: PUSH
15327: EMPTY
15328: LIST
15329: LIST
15330: PUSH
15331: LD_INT 24
15333: PUSH
15334: LD_INT 249
15336: PUSH
15337: EMPTY
15338: LIST
15339: LIST
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: PPUSH
15345: CALL_OW 69
15349: IN
15350: OR
15351: IFFALSE 15367
// ComAttackUnit ( i , un ) ;
15353: LD_VAR 0 1
15357: PPUSH
15358: LD_VAR 0 3
15362: PPUSH
15363: CALL_OW 115
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
15367: LD_VAR 0 1
15371: PPUSH
15372: LD_VAR 0 4
15376: PUSH
15377: LD_INT 1
15379: ARRAY
15380: PPUSH
15381: LD_VAR 0 4
15385: PUSH
15386: LD_INT 2
15388: ARRAY
15389: PPUSH
15390: CALL_OW 114
// end ; end ; end ; end ;
15394: GO 14753
15396: POP
15397: POP
// end ;
15398: PPOPN 9
15400: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
15401: LD_INT 22
15403: PUSH
15404: LD_INT 3
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PUSH
15411: LD_INT 32
15413: PUSH
15414: LD_INT 1
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: PPUSH
15425: CALL_OW 69
15429: IFFALSE 15517
15431: GO 15433
15433: DISABLE
15434: LD_INT 0
15436: PPUSH
15437: PPUSH
// begin enable ;
15438: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
15439: LD_ADDR_VAR 0 2
15443: PUSH
15444: LD_INT 22
15446: PUSH
15447: LD_INT 3
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: LD_INT 32
15456: PUSH
15457: LD_INT 1
15459: PUSH
15460: EMPTY
15461: LIST
15462: LIST
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PPUSH
15468: CALL_OW 69
15472: ST_TO_ADDR
// for i in tmp do
15473: LD_ADDR_VAR 0 1
15477: PUSH
15478: LD_VAR 0 2
15482: PUSH
15483: FOR_IN
15484: IFFALSE 15515
// if GetFuel ( i ) < 12 then
15486: LD_VAR 0 1
15490: PPUSH
15491: CALL_OW 261
15495: PUSH
15496: LD_INT 12
15498: LESS
15499: IFFALSE 15513
// SetFuel ( i , 12 ) ;
15501: LD_VAR 0 1
15505: PPUSH
15506: LD_INT 12
15508: PPUSH
15509: CALL_OW 240
15513: GO 15483
15515: POP
15516: POP
// end ;
15517: PPOPN 2
15519: END
