// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// InitVariables ;
   8: CALL 87 0 0
// InitMacro ;
  12: CALL 16684 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  29: LD_INT 8
  31: PPUSH
  32: LD_INT 1
  34: PPUSH
  35: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  39: LD_INT 4
  41: PPUSH
  42: LD_INT 3
  44: PPUSH
  45: LD_INT 6
  47: PPUSH
  48: LD_INT 3
  50: PPUSH
  51: LD_INT 2
  53: PPUSH
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 7
  59: PPUSH
  60: LD_INT 18
  62: PPUSH
  63: LD_INT 19
  65: PPUSH
  66: CALL 79353 0 9
// PrepareAmerican ;
  70: CALL 518 0 0
// PrepareArabian ;
  74: CALL 2190 0 0
// MC_Start ( ) ;
  78: CALL 17831 0 0
// Action ;
  82: CALL 7665 0 0
// end ;
  86: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected ; function InitVariables ; begin
  87: LD_INT 0
  89: PPUSH
// debug := false ;
  90: LD_ADDR_EXP 1
  94: PUSH
  95: LD_INT 0
  97: ST_TO_ADDR
// game := true ;
  98: LD_ADDR_EXP 2
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// mission_prefix := 11_ ;
 106: LD_ADDR_EXP 3
 110: PUSH
 111: LD_STRING 11_
 113: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 114: LD_ADDR_EXP 4
 118: PUSH
 119: LD_STRING 10c_
 121: ST_TO_ADDR
// ar_run := false ;
 122: LD_ADDR_EXP 5
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// ar_patrol := false ;
 130: LD_ADDR_EXP 7
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// base_captured := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// us_scout := 0 ;
 146: LD_ADDR_EXP 8
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: LD_INT 0
 167: PUSH
 168: LD_INT 0
 170: PUSH
 171: LD_INT 0
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: LIST
 180: ST_TO_ADDR
// kamikazed := false ;
 181: LD_ADDR_EXP 11
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// artifact_stolen := false ;
 189: LD_ADDR_EXP 12
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// artifact_get := false ;
 197: LD_ADDR_EXP 13
 201: PUSH
 202: LD_INT 0
 204: ST_TO_ADDR
// game_time := [ 110 110$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] ;
 205: LD_ADDR_EXP 15
 209: PUSH
 210: LD_INT 231000
 212: PUSH
 213: LD_INT 210000
 215: PUSH
 216: LD_INT 199500
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: PUSH
 224: LD_OWVAR 67
 228: ARRAY
 229: ST_TO_ADDR
// powell_warn := false ;
 230: LD_ADDR_EXP 16
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// loses_counter := 0 ;
 238: LD_ADDR_EXP 17
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// artifact_oncargo := false ;
 246: LD_ADDR_EXP 14
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 254: LD_ADDR_EXP 18
 258: PUSH
 259: LD_STRING 10_GensherEscape_1
 261: PPUSH
 262: LD_EXP 1
 266: PPUSH
 267: CALL_OW 30
 271: ST_TO_ADDR
// can_kamikazed := false ;
 272: LD_ADDR_EXP 10
 276: PUSH
 277: LD_INT 0
 279: ST_TO_ADDR
// end ;
 280: LD_VAR 0 1
 284: RET
// export function CustomInitMacro ; var i ; begin
 285: LD_INT 0
 287: PPUSH
 288: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 289: LD_ADDR_EXP 73
 293: PUSH
 294: LD_INT 20
 296: PUSH
 297: LD_INT 21
 299: PUSH
 300: LD_INT 22
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: LIST
 307: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 28
 315: PUSH
 316: LD_INT 24
 318: PUSH
 319: LD_INT 26
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 6
 332: PUSH
 333: LD_INT 8
 335: PUSH
 336: LD_INT 9
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: LD_OWVAR 67
 348: ARRAY
 349: PPUSH
 350: LD_INT 3
 352: PPUSH
 353: CALL 38632 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 357: LD_INT 2
 359: PPUSH
 360: LD_INT 6
 362: PUSH
 363: LD_INT 8
 365: PUSH
 366: LD_INT 9
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_OWVAR 67
 378: ARRAY
 379: PPUSH
 380: LD_INT 2
 382: PPUSH
 383: CALL 38632 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 387: LD_INT 3
 389: PPUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 7
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: PPUSH
 410: LD_INT 1
 412: PPUSH
 413: CALL 38632 0 3
// for i = 1 to mc_bases do
 417: LD_ADDR_VAR 0 2
 421: PUSH
 422: DOUBLE
 423: LD_INT 1
 425: DEC
 426: ST_TO_ADDR
 427: LD_EXP 49
 431: PUSH
 432: FOR_TO
 433: IFFALSE 457
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 435: LD_VAR 0 2
 439: PPUSH
 440: LD_EXP 42
 444: PUSH
 445: LD_VAR 0 2
 449: ARRAY
 450: PPUSH
 451: CALL 39058 0 2
 455: GO 432
 457: POP
 458: POP
// end ;
 459: LD_VAR 0 1
 463: RET
// function Debuger ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// if not debug then
 468: LD_EXP 1
 472: NOT
 473: IFFALSE 477
// exit ;
 475: GO 513
// game_speed := 5 ;
 477: LD_ADDR_OWVAR 65
 481: PUSH
 482: LD_INT 5
 484: ST_TO_ADDR
// uc_side := 1 ;
 485: LD_ADDR_OWVAR 20
 489: PUSH
 490: LD_INT 1
 492: ST_TO_ADDR
// uc_nation := 1 ;
 493: LD_ADDR_OWVAR 21
 497: PUSH
 498: LD_INT 1
 500: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 501: LD_EXP 35
 505: PPUSH
 506: LD_INT 1
 508: PPUSH
 509: CALL_OW 235
// end ; end_of_file
 513: LD_VAR 0 1
 517: RET
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 518: LD_INT 0
 520: PPUSH
 521: PPUSH
 522: PPUSH
 523: PPUSH
 524: PPUSH
 525: PPUSH
 526: PPUSH
 527: PPUSH
// uc_side := 4 ;
 528: LD_ADDR_OWVAR 20
 532: PUSH
 533: LD_INT 4
 535: ST_TO_ADDR
// uc_nation := 1 ;
 536: LD_ADDR_OWVAR 21
 540: PUSH
 541: LD_INT 1
 543: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 544: LD_ADDR_EXP 29
 548: PUSH
 549: LD_STRING Powell
 551: PPUSH
 552: LD_INT 0
 554: PPUSH
 555: LD_STRING 
 557: PPUSH
 558: CALL 44930 0 3
 562: ST_TO_ADDR
// uc_side := 1 ;
 563: LD_ADDR_OWVAR 20
 567: PUSH
 568: LD_INT 1
 570: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 571: LD_ADDR_EXP 20
 575: PUSH
 576: LD_STRING JMM
 578: PPUSH
 579: LD_EXP 1
 583: NOT
 584: PPUSH
 585: LD_EXP 4
 589: PPUSH
 590: CALL 44930 0 3
 594: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 595: LD_EXP 20
 599: PPUSH
 600: CALL_OW 257
 604: PUSH
 605: LD_INT 4
 607: GREATER
 608: IFFALSE 622
// SetClass ( JMM , 1 ) ;
 610: LD_EXP 20
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 622: LD_ADDR_EXP 21
 626: PUSH
 627: LD_STRING Lisa
 629: PPUSH
 630: LD_EXP 1
 634: NOT
 635: PPUSH
 636: LD_EXP 4
 640: PPUSH
 641: CALL 44930 0 3
 645: ST_TO_ADDR
// if not Lisa then
 646: LD_EXP 21
 650: NOT
 651: IFFALSE 666
// Lisa := CreateCharacter ( 10_Lisa ) ;
 653: LD_ADDR_EXP 21
 657: PUSH
 658: LD_STRING 10_Lisa
 660: PPUSH
 661: CALL_OW 34
 665: ST_TO_ADDR
// if not Lisa then
 666: LD_EXP 21
 670: NOT
 671: IFFALSE 686
// Lisa := CreateCharacter ( 09_Lisa ) ;
 673: LD_ADDR_EXP 21
 677: PUSH
 678: LD_STRING 09_Lisa
 680: PPUSH
 681: CALL_OW 34
 685: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 686: LD_ADDR_EXP 30
 690: PUSH
 691: LD_STRING Cornel
 693: PPUSH
 694: LD_EXP 1
 698: NOT
 699: PPUSH
 700: LD_EXP 4
 704: PPUSH
 705: CALL 44930 0 3
 709: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 710: LD_ADDR_EXP 22
 714: PUSH
 715: LD_STRING Donaldson
 717: PPUSH
 718: LD_EXP 1
 722: NOT
 723: PPUSH
 724: LD_EXP 4
 728: PPUSH
 729: CALL 44930 0 3
 733: ST_TO_ADDR
// if not Donaldson then
 734: LD_EXP 22
 738: NOT
 739: IFFALSE 754
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 741: LD_ADDR_EXP 22
 745: PUSH
 746: LD_STRING 10_Donaldson
 748: PPUSH
 749: CALL_OW 34
 753: ST_TO_ADDR
// if not Donaldson then
 754: LD_EXP 22
 758: NOT
 759: IFFALSE 774
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 761: LD_ADDR_EXP 22
 765: PUSH
 766: LD_STRING 09_Donaldson
 768: PPUSH
 769: CALL_OW 34
 773: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 774: LD_ADDR_EXP 23
 778: PUSH
 779: LD_STRING Bobby
 781: PPUSH
 782: LD_EXP 1
 786: NOT
 787: PPUSH
 788: LD_EXP 4
 792: PPUSH
 793: CALL 44930 0 3
 797: ST_TO_ADDR
// if not Bobby then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Bobby := CreateCharacter ( 10_Bobby ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 10_Bobby
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// if not Bobby then
 818: LD_EXP 23
 822: NOT
 823: IFFALSE 838
// Bobby := CreateCharacter ( 09_Bobby ) ;
 825: LD_ADDR_EXP 23
 829: PUSH
 830: LD_STRING 09_Bobby
 832: PPUSH
 833: CALL_OW 34
 837: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 838: LD_ADDR_EXP 24
 842: PUSH
 843: LD_STRING Cyrus
 845: PPUSH
 846: LD_EXP 1
 850: NOT
 851: PPUSH
 852: LD_EXP 4
 856: PPUSH
 857: CALL 44930 0 3
 861: ST_TO_ADDR
// if not Cyrus then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 10_Cyrus
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// if not Cyrus then
 882: LD_EXP 24
 886: NOT
 887: IFFALSE 902
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 889: LD_ADDR_EXP 24
 893: PUSH
 894: LD_STRING 09_Cyrus
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 902: LD_ADDR_EXP 25
 906: PUSH
 907: LD_STRING Denis
 909: PPUSH
 910: LD_EXP 1
 914: NOT
 915: PPUSH
 916: LD_EXP 4
 920: PPUSH
 921: CALL 44930 0 3
 925: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 926: LD_ADDR_EXP 26
 930: PUSH
 931: LD_STRING Brown
 933: PPUSH
 934: LD_EXP 1
 938: NOT
 939: PPUSH
 940: LD_EXP 4
 944: PPUSH
 945: CALL 44930 0 3
 949: ST_TO_ADDR
// if not Brown then
 950: LD_EXP 26
 954: NOT
 955: IFFALSE 970
// Brown := CreateCharacter ( 10_Brown ) ;
 957: LD_ADDR_EXP 26
 961: PUSH
 962: LD_STRING 10_Brown
 964: PPUSH
 965: CALL_OW 34
 969: ST_TO_ADDR
// if not Brown then
 970: LD_EXP 26
 974: NOT
 975: IFFALSE 990
// Brown := CreateCharacter ( 08_Brown ) ;
 977: LD_ADDR_EXP 26
 981: PUSH
 982: LD_STRING 08_Brown
 984: PPUSH
 985: CALL_OW 34
 989: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
 990: LD_ADDR_EXP 27
 994: PUSH
 995: LD_STRING Gladstone
 997: PPUSH
 998: LD_EXP 1
1002: NOT
1003: PPUSH
1004: LD_EXP 4
1008: PPUSH
1009: CALL 44930 0 3
1013: ST_TO_ADDR
// if not Gladstone then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 10_Gladstone
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// if not Gladstone then
1034: LD_EXP 27
1038: NOT
1039: IFFALSE 1054
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1041: LD_ADDR_EXP 27
1045: PUSH
1046: LD_STRING 08_Gladstone
1048: PPUSH
1049: CALL_OW 34
1053: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1054: LD_ADDR_EXP 28
1058: PUSH
1059: LD_STRING Houten
1061: PPUSH
1062: LD_EXP 1
1066: NOT
1067: PPUSH
1068: LD_EXP 4
1072: PPUSH
1073: CALL 44930 0 3
1077: ST_TO_ADDR
// if not Houten then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Houten := CreateCharacter ( 10_Houten ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 10_Houten
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// if not Houten then
1098: LD_EXP 28
1102: NOT
1103: IFFALSE 1118
// Houten := CreateCharacter ( 09_Houten ) ;
1105: LD_ADDR_EXP 28
1109: PUSH
1110: LD_STRING 09_Houten
1112: PPUSH
1113: CALL_OW 34
1117: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1118: LD_ADDR_EXP 30
1122: PUSH
1123: LD_STRING Cornell
1125: PPUSH
1126: LD_EXP 1
1130: NOT
1131: PPUSH
1132: LD_EXP 4
1136: PPUSH
1137: CALL 44930 0 3
1141: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1142: LD_ADDR_EXP 31
1146: PUSH
1147: LD_STRING Gary
1149: PPUSH
1150: LD_EXP 1
1154: NOT
1155: PPUSH
1156: LD_EXP 4
1160: PPUSH
1161: CALL 44930 0 3
1165: ST_TO_ADDR
// if not Gary then
1166: LD_EXP 31
1170: NOT
1171: IFFALSE 1186
// Gary := CreateCharacter ( 10_Gary ) ;
1173: LD_ADDR_EXP 31
1177: PUSH
1178: LD_STRING 10_Gary
1180: PPUSH
1181: CALL_OW 34
1185: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Frank
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 44930 0 3
1209: ST_TO_ADDR
// if not Frank then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Frank := CreateCharacter ( 08_Frank ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 08_Frank
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Kikuchi
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 44930 0 3
1253: ST_TO_ADDR
// if not Kikuchi then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Kikuchi
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1274: LD_ADDR_VAR 0 5
1278: PUSH
1279: LD_EXP 21
1283: PUSH
1284: LD_EXP 22
1288: PUSH
1289: LD_EXP 23
1293: PUSH
1294: LD_EXP 24
1298: PUSH
1299: LD_EXP 25
1303: PUSH
1304: LD_EXP 26
1308: PUSH
1309: LD_EXP 27
1313: PUSH
1314: LD_EXP 28
1318: PUSH
1319: LD_EXP 30
1323: PUSH
1324: LD_EXP 31
1328: PUSH
1329: LD_EXP 32
1333: PUSH
1334: LD_EXP 33
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// tmp := tmp diff 0 ;
1353: LD_ADDR_VAR 0 5
1357: PUSH
1358: LD_VAR 0 5
1362: PUSH
1363: LD_INT 0
1365: DIFF
1366: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1367: LD_ADDR_VAR 0 5
1371: PUSH
1372: LD_VAR 0 5
1376: PUSH
1377: LD_STRING 10_lock
1379: PPUSH
1380: CALL_OW 31
1384: UNION
1385: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1386: LD_ADDR_VAR 0 5
1390: PUSH
1391: LD_VAR 0 5
1395: PUSH
1396: LD_STRING 10c_lock
1398: PPUSH
1399: CALL_OW 31
1403: UNION
1404: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1405: LD_STRING 10_lock
1407: PPUSH
1408: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1412: LD_STRING 10c_lock
1414: PPUSH
1415: CALL_OW 40
// for i in tmp do
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_VAR 0 5
1428: PUSH
1429: FOR_IN
1430: IFFALSE 1468
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1432: LD_VAR 0 2
1436: PPUSH
1437: CALL_OW 257
1441: PUSH
1442: LD_INT 8
1444: PUSH
1445: LD_INT 2
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1466
// SetClass ( i , class_soldier ) ;
1454: LD_VAR 0 2
1458: PPUSH
1459: LD_INT 1
1461: PPUSH
1462: CALL_OW 336
1466: GO 1429
1468: POP
1469: POP
// if tmp < 12 then
1470: LD_VAR 0 5
1474: PUSH
1475: LD_INT 12
1477: LESS
1478: IFFALSE 1572
// begin k := 16 - tmp ;
1480: LD_ADDR_VAR 0 3
1484: PUSH
1485: LD_INT 16
1487: PUSH
1488: LD_VAR 0 5
1492: MINUS
1493: ST_TO_ADDR
// for i = 1 to k do
1494: LD_ADDR_VAR 0 2
1498: PUSH
1499: DOUBLE
1500: LD_INT 1
1502: DEC
1503: ST_TO_ADDR
1504: LD_VAR 0 3
1508: PUSH
1509: FOR_TO
1510: IFFALSE 1570
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1512: LD_INT 0
1514: PPUSH
1515: LD_INT 1
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 3
1523: PUSH
1524: LD_INT 4
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: PUSH
1533: LD_INT 1
1535: PPUSH
1536: LD_INT 4
1538: PPUSH
1539: CALL_OW 12
1543: ARRAY
1544: PPUSH
1545: LD_INT 6
1547: PPUSH
1548: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1552: LD_ADDR_VAR 0 5
1556: PUSH
1557: LD_VAR 0 5
1561: PUSH
1562: CALL_OW 44
1566: ADD
1567: ST_TO_ADDR
// end ;
1568: GO 1509
1570: POP
1571: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1572: LD_ADDR_EXP 19
1576: PUSH
1577: LD_STRING 1
1579: PPUSH
1580: LD_INT 12
1582: PPUSH
1583: LD_INT 12
1585: PPUSH
1586: LD_INT -5
1588: PUSH
1589: LD_EXP 20
1593: PUSH
1594: LD_INT -2
1596: PUSH
1597: LD_INT -3
1599: PUSH
1600: LD_INT -5
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: PUSH
1610: LD_VAR 0 5
1614: ADD
1615: PUSH
1616: LD_INT -6
1618: PUSH
1619: LD_INT -4
1621: PUSH
1622: LD_EXP 29
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: ADD
1632: PPUSH
1633: LD_INT 1
1635: PUSH
1636: LD_INT 4
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: LD_INT 3
1645: PUSH
1646: LD_INT 0
1648: PUSH
1649: LD_INT 5
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 4
1659: PUSH
1660: LD_INT 0
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_INT 5
1673: PUSH
1674: LD_INT 0
1676: PUSH
1677: LD_INT 2
1679: PUSH
1680: EMPTY
1681: LIST
1682: LIST
1683: LIST
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: PPUSH
1691: CALL_OW 42
1695: ST_TO_ADDR
// others := tmp diff selected ;
1696: LD_ADDR_VAR 0 8
1700: PUSH
1701: LD_VAR 0 5
1705: PUSH
1706: LD_EXP 19
1710: DIFF
1711: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1712: LD_ADDR_VAR 0 8
1716: PUSH
1717: LD_VAR 0 8
1721: PUSH
1722: LD_EXP 21
1726: PUSH
1727: LD_EXP 22
1731: PUSH
1732: LD_EXP 23
1736: PUSH
1737: LD_EXP 24
1741: PUSH
1742: LD_EXP 25
1746: PUSH
1747: LD_EXP 26
1751: PUSH
1752: LD_EXP 27
1756: PUSH
1757: LD_EXP 28
1761: PUSH
1762: LD_EXP 30
1766: PUSH
1767: LD_EXP 31
1771: PUSH
1772: LD_EXP 32
1776: PUSH
1777: LD_EXP 33
1781: PUSH
1782: EMPTY
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: DIFF
1796: ST_TO_ADDR
// if others then
1797: LD_VAR 0 8
1801: IFFALSE 1815
// SaveCharacters ( others , 11_others ) ;
1803: LD_VAR 0 8
1807: PPUSH
1808: LD_STRING 11_others
1810: PPUSH
1811: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1815: LD_ADDR_VAR 0 6
1819: PUSH
1820: LD_INT 3
1822: PUSH
1823: LD_INT 1
1825: PUSH
1826: LD_INT 1
1828: PUSH
1829: LD_INT 4
1831: PUSH
1832: EMPTY
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: PUSH
1838: LD_INT 2
1840: PUSH
1841: LD_INT 2
1843: PUSH
1844: LD_INT 1
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: PUSH
1856: LD_INT 4
1858: PUSH
1859: LD_INT 1
1861: PUSH
1862: LD_INT 1
1864: PUSH
1865: LD_INT 5
1867: PUSH
1868: EMPTY
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: PUSH
1874: LD_INT 2
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 7
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 3
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 7
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: EMPTY
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: ST_TO_ADDR
// for i in JMM ^ selected do
1917: LD_ADDR_VAR 0 2
1921: PUSH
1922: LD_EXP 20
1926: PUSH
1927: LD_EXP 19
1931: ADD
1932: PUSH
1933: FOR_IN
1934: IFFALSE 2123
// begin if GetClass ( i ) = 3 then
1936: LD_VAR 0 2
1940: PPUSH
1941: CALL_OW 257
1945: PUSH
1946: LD_INT 3
1948: EQUAL
1949: IFFALSE 2106
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1951: LD_ADDR_OWVAR 37
1955: PUSH
1956: LD_VAR 0 6
1960: PUSH
1961: LD_INT 1
1963: ARRAY
1964: PUSH
1965: LD_INT 1
1967: ARRAY
1968: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1969: LD_ADDR_OWVAR 39
1973: PUSH
1974: LD_VAR 0 6
1978: PUSH
1979: LD_INT 1
1981: ARRAY
1982: PUSH
1983: LD_INT 2
1985: ARRAY
1986: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1987: LD_ADDR_OWVAR 38
1991: PUSH
1992: LD_VAR 0 6
1996: PUSH
1997: LD_INT 1
1999: ARRAY
2000: PUSH
2001: LD_INT 3
2003: ARRAY
2004: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2005: LD_ADDR_OWVAR 40
2009: PUSH
2010: LD_VAR 0 6
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PUSH
2019: LD_INT 4
2021: ARRAY
2022: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2023: LD_ADDR_VAR 0 6
2027: PUSH
2028: LD_VAR 0 6
2032: PPUSH
2033: LD_INT 1
2035: PPUSH
2036: CALL_OW 3
2040: ST_TO_ADDR
// veh := CreateVehicle ;
2041: LD_ADDR_VAR 0 7
2045: PUSH
2046: CALL_OW 45
2050: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2051: LD_VAR 0 7
2055: PPUSH
2056: LD_INT 8
2058: PPUSH
2059: LD_INT 0
2061: PPUSH
2062: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2066: LD_VAR 0 2
2070: PPUSH
2071: LD_VAR 0 7
2075: PPUSH
2076: CALL_OW 52
// if i = JMM then
2080: LD_VAR 0 2
2084: PUSH
2085: LD_EXP 20
2089: EQUAL
2090: IFFALSE 2104
// SetMark ( veh , 1 ) ;
2092: LD_VAR 0 7
2096: PPUSH
2097: LD_INT 1
2099: PPUSH
2100: CALL_OW 242
// end else
2104: GO 2121
// PlaceUnitArea ( i , am_hum_start , false ) ;
2106: LD_VAR 0 2
2110: PPUSH
2111: LD_INT 9
2113: PPUSH
2114: LD_INT 0
2116: PPUSH
2117: CALL_OW 49
// end ;
2121: GO 1933
2123: POP
2124: POP
// vc_chassis := us_medium_tracked ;
2125: LD_ADDR_OWVAR 37
2129: PUSH
2130: LD_INT 3
2132: ST_TO_ADDR
// vc_engine := engine_solar ;
2133: LD_ADDR_OWVAR 39
2137: PUSH
2138: LD_INT 2
2140: ST_TO_ADDR
// vc_control := control_computer ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_INT 3
2148: ST_TO_ADDR
// vc_weapon := us_radar ;
2149: LD_ADDR_OWVAR 40
2153: PUSH
2154: LD_INT 11
2156: ST_TO_ADDR
// veh := CreateVehicle ;
2157: LD_ADDR_VAR 0 7
2161: PUSH
2162: CALL_OW 45
2166: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2167: LD_VAR 0 7
2171: PPUSH
2172: LD_INT 87
2174: PPUSH
2175: LD_INT 142
2177: PPUSH
2178: LD_INT 0
2180: PPUSH
2181: CALL_OW 48
// end ; end_of_file
2185: LD_VAR 0 1
2189: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2190: LD_INT 0
2192: PPUSH
2193: PPUSH
2194: PPUSH
2195: PPUSH
2196: PPUSH
2197: PPUSH
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_INT 6
2205: PUSH
2206: LD_INT 7
2208: PUSH
2209: LD_INT 7
2211: PUSH
2212: EMPTY
2213: LIST
2214: LIST
2215: LIST
2216: PUSH
2217: LD_OWVAR 67
2221: ARRAY
2222: ST_TO_ADDR
// uc_side := 2 ;
2223: LD_ADDR_OWVAR 20
2227: PUSH
2228: LD_INT 2
2230: ST_TO_ADDR
// uc_nation := 2 ;
2231: LD_ADDR_OWVAR 21
2235: PUSH
2236: LD_INT 2
2238: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2239: LD_ADDR_OWVAR 37
2243: PUSH
2244: LD_INT 14
2246: ST_TO_ADDR
// vc_engine := engine_siberite ;
2247: LD_ADDR_OWVAR 39
2251: PUSH
2252: LD_INT 3
2254: ST_TO_ADDR
// vc_control := control_manual ;
2255: LD_ADDR_OWVAR 38
2259: PUSH
2260: LD_INT 1
2262: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2263: LD_ADDR_OWVAR 40
2267: PUSH
2268: LD_INT 31
2270: ST_TO_ADDR
// for i = 1 to 3 do
2271: LD_ADDR_VAR 0 2
2275: PUSH
2276: DOUBLE
2277: LD_INT 1
2279: DEC
2280: ST_TO_ADDR
2281: LD_INT 3
2283: PUSH
2284: FOR_TO
2285: IFFALSE 2369
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2287: LD_INT 0
2289: PPUSH
2290: LD_INT 3
2292: PPUSH
2293: LD_VAR 0 5
2297: PPUSH
2298: CALL_OW 380
// un := CreateVehicle ;
2302: LD_ADDR_VAR 0 4
2306: PUSH
2307: CALL_OW 45
2311: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2312: LD_VAR 0 4
2316: PPUSH
2317: LD_INT 0
2319: PPUSH
2320: LD_INT 5
2322: PPUSH
2323: CALL_OW 12
2327: PPUSH
2328: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2332: LD_VAR 0 4
2336: PPUSH
2337: LD_INT 156
2339: PPUSH
2340: LD_INT 15
2342: PPUSH
2343: LD_INT 6
2345: PPUSH
2346: LD_INT 0
2348: PPUSH
2349: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2353: CALL_OW 44
2357: PPUSH
2358: LD_VAR 0 4
2362: PPUSH
2363: CALL_OW 52
// end ;
2367: GO 2284
2369: POP
2370: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , 5 , - 1 , 4 ] ) ;
2371: LD_ADDR_EXP 36
2375: PUSH
2376: LD_INT 94
2378: PPUSH
2379: LD_INT 28
2381: PPUSH
2382: LD_STRING dammam
2384: PPUSH
2385: LD_VAR 0 5
2389: PPUSH
2390: LD_INT 10000
2392: PUSH
2393: LD_INT 1000
2395: PUSH
2396: LD_INT 300
2398: PUSH
2399: EMPTY
2400: LIST
2401: LIST
2402: LIST
2403: PPUSH
2404: LD_INT 1
2406: NEG
2407: PUSH
2408: LD_INT 5
2410: PUSH
2411: LD_INT 1
2413: NEG
2414: PUSH
2415: LD_INT 4
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PPUSH
2424: CALL 54972 0 6
2428: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , 4 , 2 , 0 ] ) ;
2429: LD_ADDR_EXP 36
2433: PUSH
2434: LD_EXP 36
2438: PUSH
2439: LD_INT 122
2441: PPUSH
2442: LD_INT 25
2444: PPUSH
2445: LD_STRING 
2447: PPUSH
2448: LD_VAR 0 5
2452: PPUSH
2453: LD_INT 500
2455: PUSH
2456: LD_INT 60
2458: PUSH
2459: LD_INT 0
2461: PUSH
2462: EMPTY
2463: LIST
2464: LIST
2465: LIST
2466: PPUSH
2467: LD_INT 1
2469: NEG
2470: PUSH
2471: LD_INT 4
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: LD_INT 0
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: PPUSH
2486: CALL 54972 0 6
2490: UNION
2491: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2492: LD_ADDR_EXP 34
2496: PUSH
2497: LD_INT 45
2499: PPUSH
2500: LD_INT 24
2502: PPUSH
2503: LD_STRING jeddah
2505: PPUSH
2506: LD_VAR 0 5
2510: PPUSH
2511: LD_INT 700
2513: PUSH
2514: LD_INT 300
2516: PUSH
2517: LD_INT 10
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: PPUSH
2525: LD_INT 1
2527: NEG
2528: PUSH
2529: LD_INT 5
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 2
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: LIST
2542: LIST
2543: PPUSH
2544: CALL 54972 0 6
2548: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2549: LD_ADDR_EXP 35
2553: PUSH
2554: LD_INT 7
2556: PPUSH
2557: LD_INT 27
2559: PPUSH
2560: LD_STRING riyadh
2562: PPUSH
2563: LD_VAR 0 5
2567: PPUSH
2568: LD_INT 500
2570: PUSH
2571: LD_INT 60
2573: PUSH
2574: LD_INT 0
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: LIST
2581: PPUSH
2582: LD_INT 4
2584: PUSH
2585: LD_INT 2
2587: PUSH
2588: LD_INT 3
2590: PUSH
2591: LD_INT 1
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: PPUSH
2600: CALL 54972 0 6
2604: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2605: LD_ADDR_EXP 38
2609: PUSH
2610: LD_INT 204
2612: PPUSH
2613: LD_INT 26
2615: PPUSH
2616: LD_STRING 
2618: PPUSH
2619: LD_VAR 0 5
2623: PPUSH
2624: LD_INT 500
2626: PUSH
2627: LD_INT 50
2629: PUSH
2630: LD_INT 0
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: LIST
2637: PPUSH
2638: LD_INT 1
2640: NEG
2641: PUSH
2642: LD_INT 3
2644: PUSH
2645: LD_INT 3
2647: PUSH
2648: LD_INT 2
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: PPUSH
2657: CALL 54972 0 6
2661: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2662: LD_ADDR_EXP 49
2666: PUSH
2667: LD_EXP 36
2671: PUSH
2672: LD_EXP 34
2676: PUSH
2677: LD_EXP 38
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: LIST
2686: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2687: LD_ADDR_VAR 0 2
2691: PUSH
2692: LD_INT 22
2694: PUSH
2695: LD_INT 2
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: PUSH
2702: LD_INT 30
2704: PUSH
2705: LD_INT 31
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: LD_INT 58
2714: PUSH
2715: EMPTY
2716: LIST
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: LIST
2722: PPUSH
2723: CALL_OW 69
2727: PUSH
2728: FOR_IN
2729: IFFALSE 2854
// begin if GetBase ( i ) then
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 274
2740: IFFALSE 2744
// continue ;
2742: GO 2728
// d := GetDir ( i ) ;
2744: LD_ADDR_VAR 0 3
2748: PUSH
2749: LD_VAR 0 2
2753: PPUSH
2754: CALL_OW 254
2758: ST_TO_ADDR
// if d < 3 then
2759: LD_VAR 0 3
2763: PUSH
2764: LD_INT 3
2766: LESS
2767: IFFALSE 2785
// d := d + 3 else
2769: LD_ADDR_VAR 0 3
2773: PUSH
2774: LD_VAR 0 3
2778: PUSH
2779: LD_INT 3
2781: PLUS
2782: ST_TO_ADDR
2783: GO 2799
// d := d - 3 ;
2785: LD_ADDR_VAR 0 3
2789: PUSH
2790: LD_VAR 0 3
2794: PUSH
2795: LD_INT 3
2797: MINUS
2798: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2799: LD_INT 0
2801: PPUSH
2802: LD_INT 8
2804: PPUSH
2805: LD_VAR 0 5
2809: PPUSH
2810: CALL_OW 380
// un := CreateHuman ;
2814: LD_ADDR_VAR 0 4
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// SetDir ( un , d ) ;
2824: LD_VAR 0 4
2828: PPUSH
2829: LD_VAR 0 3
2833: PPUSH
2834: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2838: LD_VAR 0 4
2842: PPUSH
2843: LD_VAR 0 2
2847: PPUSH
2848: CALL_OW 52
// end ;
2852: GO 2728
2854: POP
2855: POP
// if Difficulty > 1 then
2856: LD_OWVAR 67
2860: PUSH
2861: LD_INT 1
2863: GREATER
2864: IFFALSE 3235
// begin ar_kamikadze := [ ] ;
2866: LD_ADDR_EXP 41
2870: PUSH
2871: EMPTY
2872: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
2873: LD_INT 0
2875: PPUSH
2876: LD_INT 1
2878: PPUSH
2879: LD_VAR 0 5
2883: PPUSH
2884: CALL_OW 380
// un := CreateHuman ;
2888: LD_ADDR_VAR 0 4
2892: PUSH
2893: CALL_OW 44
2897: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2898: LD_VAR 0 4
2902: PPUSH
2903: LD_INT 3
2905: PPUSH
2906: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
2910: LD_VAR 0 4
2914: PPUSH
2915: LD_INT 23
2917: PPUSH
2918: LD_INT 44
2920: PPUSH
2921: LD_INT 0
2923: PPUSH
2924: CALL_OW 48
// ComCrawl ( un ) ;
2928: LD_VAR 0 4
2932: PPUSH
2933: CALL_OW 137
// un := CreateHuman ;
2937: LD_ADDR_VAR 0 4
2941: PUSH
2942: CALL_OW 44
2946: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2947: LD_VAR 0 4
2951: PPUSH
2952: LD_INT 3
2954: PPUSH
2955: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
2959: LD_VAR 0 4
2963: PPUSH
2964: LD_INT 30
2966: PPUSH
2967: LD_INT 39
2969: PPUSH
2970: LD_INT 0
2972: PPUSH
2973: CALL_OW 48
// ComCrawl ( un ) ;
2977: LD_VAR 0 4
2981: PPUSH
2982: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
2986: LD_INT 0
2988: PPUSH
2989: LD_INT 17
2991: PPUSH
2992: LD_VAR 0 5
2996: PPUSH
2997: CALL_OW 380
// un := CreateHuman ;
3001: LD_ADDR_VAR 0 4
3005: PUSH
3006: CALL_OW 44
3010: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3011: LD_VAR 0 4
3015: PPUSH
3016: LD_INT 3
3018: PPUSH
3019: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3023: LD_VAR 0 4
3027: PPUSH
3028: LD_INT 45
3030: PPUSH
3031: LD_INT 86
3033: PPUSH
3034: LD_INT 0
3036: PPUSH
3037: CALL_OW 48
// ComHold ( un ) ;
3041: LD_VAR 0 4
3045: PPUSH
3046: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3050: LD_ADDR_EXP 41
3054: PUSH
3055: LD_EXP 41
3059: PPUSH
3060: LD_EXP 41
3064: PUSH
3065: LD_INT 1
3067: PLUS
3068: PPUSH
3069: LD_VAR 0 4
3073: PPUSH
3074: CALL_OW 1
3078: ST_TO_ADDR
// un := CreateHuman ;
3079: LD_ADDR_VAR 0 4
3083: PUSH
3084: CALL_OW 44
3088: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3089: LD_VAR 0 4
3093: PPUSH
3094: LD_INT 3
3096: PPUSH
3097: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3101: LD_VAR 0 4
3105: PPUSH
3106: LD_INT 60
3108: PPUSH
3109: LD_INT 85
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 48
// ComHold ( un ) ;
3119: LD_VAR 0 4
3123: PPUSH
3124: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3128: LD_ADDR_EXP 41
3132: PUSH
3133: LD_EXP 41
3137: PPUSH
3138: LD_EXP 41
3142: PUSH
3143: LD_INT 1
3145: PLUS
3146: PPUSH
3147: LD_VAR 0 4
3151: PPUSH
3152: CALL_OW 1
3156: ST_TO_ADDR
// un := CreateHuman ;
3157: LD_ADDR_VAR 0 4
3161: PUSH
3162: CALL_OW 44
3166: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3167: LD_VAR 0 4
3171: PPUSH
3172: LD_INT 3
3174: PPUSH
3175: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3179: LD_VAR 0 4
3183: PPUSH
3184: LD_INT 222
3186: PPUSH
3187: LD_INT 166
3189: PPUSH
3190: LD_INT 0
3192: PPUSH
3193: CALL_OW 48
// ComHold ( un ) ;
3197: LD_VAR 0 4
3201: PPUSH
3202: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3206: LD_ADDR_EXP 41
3210: PUSH
3211: LD_EXP 41
3215: PPUSH
3216: LD_EXP 41
3220: PUSH
3221: LD_INT 1
3223: PLUS
3224: PPUSH
3225: LD_VAR 0 4
3229: PPUSH
3230: CALL_OW 1
3234: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3235: LD_ADDR_EXP 39
3239: PUSH
3240: EMPTY
3241: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3242: LD_INT 1
3244: PPUSH
3245: LD_INT 1
3247: PPUSH
3248: LD_VAR 0 5
3252: PPUSH
3253: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3257: LD_ADDR_OWVAR 26
3261: PUSH
3262: LD_STRING Pavel Grigorovic
3264: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3265: LD_ADDR_OWVAR 33
3269: PUSH
3270: LD_STRING SecondCharsGal
3272: ST_TO_ADDR
// hc_face_number := 4 ;
3273: LD_ADDR_OWVAR 34
3277: PUSH
3278: LD_INT 4
3280: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3281: LD_ADDR_EXP 39
3285: PUSH
3286: LD_EXP 39
3290: PPUSH
3291: LD_INT 1
3293: PPUSH
3294: CALL_OW 44
3298: PPUSH
3299: CALL_OW 1
3303: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3304: LD_INT 2
3306: PPUSH
3307: LD_INT 4
3309: PPUSH
3310: LD_VAR 0 5
3314: PPUSH
3315: CALL_OW 380
// hc_name := Lucy Sebel ;
3319: LD_ADDR_OWVAR 26
3323: PUSH
3324: LD_STRING Lucy Sebel
3326: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3327: LD_ADDR_OWVAR 33
3331: PUSH
3332: LD_STRING SecondCharsGal
3334: ST_TO_ADDR
// hc_face_number := 15 ;
3335: LD_ADDR_OWVAR 34
3339: PUSH
3340: LD_INT 15
3342: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3343: LD_ADDR_EXP 39
3347: PUSH
3348: LD_EXP 39
3352: PPUSH
3353: LD_INT 2
3355: PPUSH
3356: CALL_OW 44
3360: PPUSH
3361: CALL_OW 1
3365: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3366: LD_INT 2
3368: PPUSH
3369: LD_INT 4
3371: PPUSH
3372: LD_VAR 0 5
3376: PPUSH
3377: CALL_OW 380
// hc_gallery :=  ;
3381: LD_ADDR_OWVAR 33
3385: PUSH
3386: LD_STRING 
3388: ST_TO_ADDR
// hc_name :=  ;
3389: LD_ADDR_OWVAR 26
3393: PUSH
3394: LD_STRING 
3396: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3397: LD_ADDR_EXP 39
3401: PUSH
3402: LD_EXP 39
3406: PPUSH
3407: LD_INT 3
3409: PPUSH
3410: CALL_OW 44
3414: PPUSH
3415: CALL_OW 1
3419: ST_TO_ADDR
// hc_sex := sex_male ;
3420: LD_ADDR_OWVAR 27
3424: PUSH
3425: LD_INT 1
3427: ST_TO_ADDR
// hc_class = 11 ;
3428: LD_ADDR_OWVAR 28
3432: PUSH
3433: LD_INT 11
3435: ST_TO_ADDR
// hc_gallery = sandar ;
3436: LD_ADDR_OWVAR 33
3440: PUSH
3441: LD_STRING sandar
3443: ST_TO_ADDR
// hc_face_number = 33 ;
3444: LD_ADDR_OWVAR 34
3448: PUSH
3449: LD_INT 33
3451: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3452: LD_ADDR_OWVAR 26
3456: PUSH
3457: LD_STRING Thabit Muhair Saliba
3459: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3460: LD_ADDR_OWVAR 31
3464: PUSH
3465: LD_INT 0
3467: PUSH
3468: LD_INT 0
3470: PUSH
3471: LD_INT 0
3473: PUSH
3474: LD_INT 0
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: ST_TO_ADDR
// Saliba = CreateHuman ;
3483: LD_ADDR_EXP 43
3487: PUSH
3488: CALL_OW 44
3492: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3493: LD_EXP 43
3497: PPUSH
3498: LD_INT 7
3500: PPUSH
3501: CALL_OW 52
// if gensher_active then
3505: LD_EXP 18
3509: IFFALSE 3536
// begin Gensher = NewCharacter ( Dietrich ) ;
3511: LD_ADDR_EXP 44
3515: PUSH
3516: LD_STRING Dietrich
3518: PPUSH
3519: CALL_OW 25
3523: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3524: LD_EXP 44
3528: PPUSH
3529: LD_INT 94
3531: PPUSH
3532: CALL_OW 52
// end ; InitHc ;
3536: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3540: LD_ADDR_EXP 40
3544: PUSH
3545: EMPTY
3546: ST_TO_ADDR
// for i = 1 to 5 do
3547: LD_ADDR_VAR 0 2
3551: PUSH
3552: DOUBLE
3553: LD_INT 1
3555: DEC
3556: ST_TO_ADDR
3557: LD_INT 5
3559: PUSH
3560: FOR_TO
3561: IFFALSE 3733
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3563: LD_INT 13
3565: PUSH
3566: LD_INT 14
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: PUSH
3573: LD_INT 1
3575: PPUSH
3576: LD_INT 2
3578: PPUSH
3579: CALL_OW 12
3583: ARRAY
3584: PPUSH
3585: LD_INT 1
3587: PUSH
3588: LD_INT 2
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 2
3600: PPUSH
3601: CALL_OW 12
3605: ARRAY
3606: PPUSH
3607: LD_INT 1
3609: PPUSH
3610: LD_INT 25
3612: PUSH
3613: LD_INT 27
3615: PUSH
3616: LD_INT 26
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 1
3626: PPUSH
3627: LD_INT 3
3629: PPUSH
3630: CALL_OW 12
3634: ARRAY
3635: PPUSH
3636: LD_INT 60
3638: PPUSH
3639: LD_INT 100
3641: PPUSH
3642: CALL_OW 12
3646: PPUSH
3647: CALL 51563 0 5
// un := CreateVehicle ;
3651: LD_ADDR_VAR 0 4
3655: PUSH
3656: CALL_OW 45
3660: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3661: LD_ADDR_EXP 40
3665: PUSH
3666: LD_EXP 40
3670: PPUSH
3671: LD_EXP 40
3675: PUSH
3676: LD_INT 1
3678: PLUS
3679: PPUSH
3680: LD_VAR 0 4
3684: PPUSH
3685: CALL_OW 1
3689: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3690: LD_VAR 0 4
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: LD_INT 5
3700: PPUSH
3701: CALL_OW 12
3705: PPUSH
3706: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3710: LD_VAR 0 4
3714: PPUSH
3715: LD_INT 124
3717: PPUSH
3718: LD_INT 141
3720: PPUSH
3721: LD_INT 8
3723: PPUSH
3724: LD_INT 0
3726: PPUSH
3727: CALL_OW 50
// end ;
3731: GO 3560
3733: POP
3734: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3735: LD_ADDR_EXP 42
3739: PUSH
3740: EMPTY
3741: PUSH
3742: EMPTY
3743: PUSH
3744: EMPTY
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: LIST
3750: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3751: LD_ADDR_VAR 0 3
3755: PUSH
3756: DOUBLE
3757: LD_INT 1
3759: DEC
3760: ST_TO_ADDR
3761: LD_INT 3
3763: PUSH
3764: LD_INT 3
3766: PUSH
3767: LD_INT 4
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: LIST
3774: PUSH
3775: LD_OWVAR 67
3779: ARRAY
3780: PUSH
3781: FOR_TO
3782: IFFALSE 3996
// for i = 1 to 3 do
3784: LD_ADDR_VAR 0 2
3788: PUSH
3789: DOUBLE
3790: LD_INT 1
3792: DEC
3793: ST_TO_ADDR
3794: LD_INT 3
3796: PUSH
3797: FOR_TO
3798: IFFALSE 3992
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3800: LD_INT 14
3802: PPUSH
3803: LD_INT 3
3805: PUSH
3806: LD_INT 2
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 1
3815: PPUSH
3816: LD_INT 2
3818: PPUSH
3819: CALL_OW 12
3823: ARRAY
3824: PPUSH
3825: LD_INT 1
3827: PUSH
3828: LD_INT 5
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PUSH
3835: LD_INT 1
3837: PPUSH
3838: LD_INT 2
3840: PPUSH
3841: CALL_OW 12
3845: ARRAY
3846: PPUSH
3847: LD_INT 25
3849: PUSH
3850: LD_INT 27
3852: PUSH
3853: LD_INT 26
3855: PUSH
3856: LD_INT 28
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: PUSH
3865: LD_INT 1
3867: PPUSH
3868: LD_INT 4
3870: PPUSH
3871: CALL_OW 12
3875: ARRAY
3876: PPUSH
3877: LD_INT 100
3879: PPUSH
3880: CALL 51563 0 5
// un := CreateVehicle ;
3884: LD_ADDR_VAR 0 4
3888: PUSH
3889: CALL_OW 45
3893: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
3894: LD_ADDR_EXP 42
3898: PUSH
3899: LD_EXP 42
3903: PPUSH
3904: LD_VAR 0 2
3908: PUSH
3909: LD_EXP 42
3913: PUSH
3914: LD_VAR 0 2
3918: ARRAY
3919: PUSH
3920: LD_INT 1
3922: PLUS
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PPUSH
3928: LD_VAR 0 4
3932: PPUSH
3933: CALL 51685 0 3
3937: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3938: LD_VAR 0 4
3942: PPUSH
3943: LD_INT 0
3945: PPUSH
3946: LD_INT 5
3948: PPUSH
3949: CALL_OW 12
3953: PPUSH
3954: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
3958: LD_VAR 0 4
3962: PPUSH
3963: LD_INT 20
3965: PUSH
3966: LD_INT 21
3968: PUSH
3969: LD_INT 22
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 2
3981: ARRAY
3982: PPUSH
3983: LD_INT 0
3985: PPUSH
3986: CALL_OW 49
// end ;
3990: GO 3797
3992: POP
3993: POP
3994: GO 3781
3996: POP
3997: POP
// InitHc ;
3998: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4002: LD_INT 4
4004: PPUSH
4005: LD_INT 5
4007: PPUSH
4008: LD_INT 10
4010: PPUSH
4011: LD_INT 5
4013: PPUSH
4014: LD_INT 0
4016: PPUSH
4017: CALL_OW 58
// end ;
4021: LD_VAR 0 1
4025: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4026: LD_EXP 41
4030: IFFALSE 4104
4032: GO 4034
4034: DISABLE
4035: LD_INT 0
4037: PPUSH
// begin enable ;
4038: ENABLE
// for i in ar_kamikadze do
4039: LD_ADDR_VAR 0 1
4043: PUSH
4044: LD_EXP 41
4048: PUSH
4049: FOR_IN
4050: IFFALSE 4102
// if See ( 1 , i ) then
4052: LD_INT 1
4054: PPUSH
4055: LD_VAR 0 1
4059: PPUSH
4060: CALL_OW 292
4064: IFFALSE 4100
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4066: LD_VAR 0 1
4070: PPUSH
4071: LD_INT 81
4073: PUSH
4074: LD_INT 2
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: PPUSH
4081: CALL_OW 69
4085: PPUSH
4086: LD_VAR 0 1
4090: PPUSH
4091: CALL_OW 74
4095: PPUSH
4096: CALL_OW 115
4100: GO 4049
4102: POP
4103: POP
// end ;
4104: PPOPN 1
4106: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4107: LD_EXP 13
4111: IFFALSE 4428
4113: GO 4115
4115: DISABLE
4116: LD_INT 0
4118: PPUSH
4119: PPUSH
4120: PPUSH
4121: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4122: LD_INT 35
4124: PPUSH
4125: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4129: LD_INT 1
4131: PPUSH
4132: CALL 39346 0 1
4136: PUSH
4137: LD_INT 0
4139: EQUAL
4140: IFFALSE 4122
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4142: LD_INT 1
4144: PPUSH
4145: LD_INT 14
4147: PUSH
4148: LD_INT 3
4150: PUSH
4151: LD_INT 2
4153: PUSH
4154: LD_INT 32
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: EMPTY
4164: LIST
4165: PPUSH
4166: CALL 38950 0 2
// repeat wait ( 0 0$1 ) ;
4170: LD_INT 35
4172: PPUSH
4173: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4177: LD_EXP 68
4181: PUSH
4182: LD_INT 1
4184: ARRAY
4185: PPUSH
4186: LD_INT 33
4188: PUSH
4189: LD_INT 2
4191: PUSH
4192: EMPTY
4193: LIST
4194: LIST
4195: PUSH
4196: LD_INT 34
4198: PUSH
4199: LD_INT 32
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PPUSH
4210: CALL_OW 72
4214: IFFALSE 4170
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4216: LD_ADDR_VAR 0 2
4220: PUSH
4221: LD_EXP 68
4225: PUSH
4226: LD_INT 1
4228: ARRAY
4229: PPUSH
4230: LD_INT 33
4232: PUSH
4233: LD_INT 2
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 34
4242: PUSH
4243: LD_INT 32
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 72
4258: PUSH
4259: LD_INT 1
4261: ARRAY
4262: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4263: LD_ADDR_VAR 0 4
4267: PUSH
4268: LD_INT 5
4270: PPUSH
4271: CALL_OW 469
4275: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4276: LD_INT 35
4278: PPUSH
4279: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4283: LD_ADDR_VAR 0 4
4287: PUSH
4288: LD_INT 5
4290: PPUSH
4291: CALL_OW 469
4295: ST_TO_ADDR
// tmp := 100 ;
4296: LD_ADDR_VAR 0 3
4300: PUSH
4301: LD_INT 100
4303: ST_TO_ADDR
// if pos then
4304: LD_VAR 0 4
4308: IFFALSE 4348
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4310: LD_ADDR_VAR 0 3
4314: PUSH
4315: LD_INT 2
4317: PPUSH
4318: LD_VAR 0 4
4322: PUSH
4323: LD_INT 1
4325: ARRAY
4326: PPUSH
4327: LD_VAR 0 4
4331: PUSH
4332: LD_INT 2
4334: ARRAY
4335: PPUSH
4336: LD_INT 20
4338: PPUSH
4339: CALL 52581 0 4
4343: PUSH
4344: LD_INT 4
4346: ARRAY
4347: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4348: LD_VAR 0 4
4352: PUSH
4353: LD_EXP 14
4357: NOT
4358: AND
4359: PUSH
4360: LD_VAR 0 3
4364: PUSH
4365: LD_INT 10
4367: LESS
4368: AND
4369: IFFALSE 4276
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4371: LD_VAR 0 2
4375: PPUSH
4376: LD_VAR 0 4
4380: PUSH
4381: LD_INT 1
4383: ARRAY
4384: PPUSH
4385: LD_VAR 0 4
4389: PUSH
4390: LD_INT 2
4392: ARRAY
4393: PPUSH
4394: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4398: LD_VAR 0 2
4402: PPUSH
4403: LD_INT 198
4405: PPUSH
4406: LD_INT 113
4408: PPUSH
4409: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4413: LD_VAR 0 2
4417: PPUSH
4418: LD_INT 124
4420: PPUSH
4421: LD_INT 7
4423: PPUSH
4424: CALL_OW 171
// end ;
4428: PPOPN 4
4430: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4431: LD_EXP 6
4435: IFFALSE 7092
4437: GO 4439
4439: DISABLE
4440: LD_INT 0
4442: PPUSH
4443: PPUSH
4444: PPUSH
4445: PPUSH
4446: PPUSH
4447: PPUSH
4448: PPUSH
4449: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4450: LD_ADDR_VAR 0 4
4454: PUSH
4455: LD_INT 5
4457: PUSH
4458: LD_INT 6
4460: PUSH
4461: LD_INT 7
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: PUSH
4469: LD_OWVAR 67
4473: ARRAY
4474: ST_TO_ADDR
// coords := [ ] ;
4475: LD_ADDR_VAR 0 5
4479: PUSH
4480: EMPTY
4481: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4482: LD_ADDR_VAR 0 6
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: LD_INT 0
4495: PUSH
4496: LD_INT 0
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 0
4504: PUSH
4505: LD_INT 0
4507: PUSH
4508: LD_INT 0
4510: PUSH
4511: LD_INT 1
4513: PUSH
4514: LD_INT 0
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4529: LD_INT 1
4531: PPUSH
4532: LD_INT 14
4534: PUSH
4535: LD_INT 1
4537: PUSH
4538: LD_INT 2
4540: PUSH
4541: LD_INT 28
4543: PUSH
4544: EMPTY
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: PUSH
4550: LD_INT 14
4552: PUSH
4553: LD_INT 1
4555: PUSH
4556: LD_INT 2
4558: PUSH
4559: LD_INT 25
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 14
4570: PUSH
4571: LD_INT 1
4573: PUSH
4574: LD_INT 2
4576: PUSH
4577: LD_INT 28
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 14
4588: PUSH
4589: LD_INT 1
4591: PUSH
4592: LD_INT 2
4594: PUSH
4595: LD_INT 29
4597: PUSH
4598: EMPTY
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: PPUSH
4610: CALL 38950 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4614: LD_INT 21000
4616: PUSH
4617: LD_INT 19950
4619: PUSH
4620: LD_INT 18900
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: PUSH
4628: LD_OWVAR 67
4632: ARRAY
4633: PPUSH
4634: CALL_OW 67
// InitHc ;
4638: CALL_OW 19
// InitUc ;
4642: CALL_OW 18
// uc_side := 2 ;
4646: LD_ADDR_OWVAR 20
4650: PUSH
4651: LD_INT 2
4653: ST_TO_ADDR
// uc_nation := 2 ;
4654: LD_ADDR_OWVAR 21
4658: PUSH
4659: LD_INT 2
4661: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4662: LD_ADDR_VAR 0 3
4666: PUSH
4667: EMPTY
4668: PUSH
4669: EMPTY
4670: PUSH
4671: EMPTY
4672: PUSH
4673: EMPTY
4674: PUSH
4675: EMPTY
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: LIST
4683: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4684: LD_ADDR_VAR 0 3
4688: PUSH
4689: LD_VAR 0 3
4693: PPUSH
4694: LD_INT 1
4696: PPUSH
4697: LD_EXP 68
4701: PUSH
4702: LD_INT 1
4704: ARRAY
4705: PUSH
4706: LD_INT 34
4708: PUSH
4709: LD_INT 32
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: PPUSH
4716: CALL_OW 69
4720: DIFF
4721: PPUSH
4722: CALL_OW 1
4726: ST_TO_ADDR
// for i = 1 to Difficulty do
4727: LD_ADDR_VAR 0 1
4731: PUSH
4732: DOUBLE
4733: LD_INT 1
4735: DEC
4736: ST_TO_ADDR
4737: LD_OWVAR 67
4741: PUSH
4742: FOR_TO
4743: IFFALSE 4881
// begin uc_side := 2 ;
4745: LD_ADDR_OWVAR 20
4749: PUSH
4750: LD_INT 2
4752: ST_TO_ADDR
// uc_nation := 2 ;
4753: LD_ADDR_OWVAR 21
4757: PUSH
4758: LD_INT 2
4760: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4761: LD_INT 13
4763: PPUSH
4764: LD_INT 3
4766: PPUSH
4767: LD_INT 5
4769: PPUSH
4770: LD_INT 29
4772: PPUSH
4773: LD_INT 100
4775: PPUSH
4776: CALL 51563 0 5
// un := CreateVehicle ;
4780: LD_ADDR_VAR 0 2
4784: PUSH
4785: CALL_OW 45
4789: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4790: LD_ADDR_VAR 0 3
4794: PUSH
4795: LD_VAR 0 3
4799: PPUSH
4800: LD_INT 1
4802: PUSH
4803: LD_VAR 0 3
4807: PUSH
4808: LD_INT 1
4810: ARRAY
4811: PUSH
4812: LD_INT 1
4814: PLUS
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: PPUSH
4820: LD_VAR 0 2
4824: PPUSH
4825: CALL 51685 0 3
4829: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4830: LD_VAR 0 2
4834: PPUSH
4835: LD_INT 3
4837: PPUSH
4838: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
4842: LD_VAR 0 2
4846: PPUSH
4847: LD_INT 16
4849: PPUSH
4850: LD_INT 0
4852: PPUSH
4853: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
4857: LD_VAR 0 2
4861: PPUSH
4862: LD_INT 51
4864: PPUSH
4865: LD_INT 10
4867: PPUSH
4868: CALL_OW 111
// wait ( 0 0$2 ) ;
4872: LD_INT 70
4874: PPUSH
4875: CALL_OW 67
// end ;
4879: GO 4742
4881: POP
4882: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
4883: LD_ADDR_VAR 0 5
4887: PUSH
4888: LD_INT 51
4890: PUSH
4891: LD_INT 24
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 75
4900: PUSH
4901: LD_INT 90
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
4912: LD_INT 1
4914: PPUSH
4915: LD_VAR 0 3
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_VAR 0 5
4928: PPUSH
4929: LD_VAR 0 6
4933: PPUSH
4934: CALL 39183 0 4
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
4938: LD_ADDR_VAR 0 1
4942: PUSH
4943: DOUBLE
4944: LD_INT 1
4946: DEC
4947: ST_TO_ADDR
4948: LD_INT 2
4950: PUSH
4951: LD_INT 3
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_OWVAR 67
4966: ARRAY
4967: PUSH
4968: FOR_TO
4969: IFFALSE 5069
// begin uc_side := 2 ;
4971: LD_ADDR_OWVAR 20
4975: PUSH
4976: LD_INT 2
4978: ST_TO_ADDR
// uc_nation := 2 ;
4979: LD_ADDR_OWVAR 21
4983: PUSH
4984: LD_INT 2
4986: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
4987: LD_INT 0
4989: PPUSH
4990: LD_INT 17
4992: PPUSH
4993: LD_VAR 0 4
4997: PPUSH
4998: CALL_OW 380
// un := CreateHuman ;
5002: LD_ADDR_VAR 0 2
5006: PUSH
5007: CALL_OW 44
5011: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5012: LD_ADDR_VAR 0 3
5016: PUSH
5017: LD_VAR 0 3
5021: PPUSH
5022: LD_INT 2
5024: PUSH
5025: LD_VAR 0 3
5029: PUSH
5030: LD_INT 2
5032: ARRAY
5033: PUSH
5034: LD_INT 1
5036: PLUS
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PPUSH
5042: LD_VAR 0 2
5046: PPUSH
5047: CALL 51685 0 3
5051: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 13
5059: PPUSH
5060: LD_INT 0
5062: PPUSH
5063: CALL_OW 49
// end ;
5067: GO 4968
5069: POP
5070: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5071: LD_ADDR_VAR 0 1
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 2
5083: PUSH
5084: LD_INT 3
5086: PUSH
5087: LD_INT 3
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: PUSH
5101: FOR_TO
5102: IFFALSE 5221
// begin uc_side := 2 ;
5104: LD_ADDR_OWVAR 20
5108: PUSH
5109: LD_INT 2
5111: ST_TO_ADDR
// uc_nation := 2 ;
5112: LD_ADDR_OWVAR 21
5116: PUSH
5117: LD_INT 2
5119: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5120: LD_INT 0
5122: PPUSH
5123: LD_INT 1
5125: PUSH
5126: LD_INT 8
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PUSH
5133: LD_INT 1
5135: PPUSH
5136: LD_INT 2
5138: PPUSH
5139: CALL_OW 12
5143: ARRAY
5144: PPUSH
5145: LD_VAR 0 4
5149: PPUSH
5150: CALL_OW 380
// un := CreateHuman ;
5154: LD_ADDR_VAR 0 2
5158: PUSH
5159: CALL_OW 44
5163: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5164: LD_ADDR_VAR 0 3
5168: PUSH
5169: LD_VAR 0 3
5173: PPUSH
5174: LD_INT 2
5176: PUSH
5177: LD_VAR 0 3
5181: PUSH
5182: LD_INT 2
5184: ARRAY
5185: PUSH
5186: LD_INT 1
5188: PLUS
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: PPUSH
5194: LD_VAR 0 2
5198: PPUSH
5199: CALL 51685 0 3
5203: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5204: LD_VAR 0 2
5208: PPUSH
5209: LD_INT 13
5211: PPUSH
5212: LD_INT 0
5214: PPUSH
5215: CALL_OW 49
// end ;
5219: GO 5101
5221: POP
5222: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5223: LD_ADDR_VAR 0 5
5227: PUSH
5228: LD_INT 67
5230: PUSH
5231: LD_INT 112
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PUSH
5238: LD_INT 85
5240: PUSH
5241: LD_INT 130
5243: PUSH
5244: EMPTY
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5252: LD_INT 2
5254: PPUSH
5255: LD_VAR 0 3
5259: PUSH
5260: LD_INT 2
5262: ARRAY
5263: PPUSH
5264: LD_VAR 0 5
5268: PPUSH
5269: LD_VAR 0 6
5273: PPUSH
5274: CALL 39183 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5278: LD_ADDR_VAR 0 1
5282: PUSH
5283: DOUBLE
5284: LD_INT 1
5286: DEC
5287: ST_TO_ADDR
5288: LD_INT 1
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: LD_INT 3
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: LIST
5301: PUSH
5302: LD_OWVAR 67
5306: ARRAY
5307: PUSH
5308: FOR_TO
5309: IFFALSE 5409
// begin uc_side := 2 ;
5311: LD_ADDR_OWVAR 20
5315: PUSH
5316: LD_INT 2
5318: ST_TO_ADDR
// uc_nation := 2 ;
5319: LD_ADDR_OWVAR 21
5323: PUSH
5324: LD_INT 2
5326: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5327: LD_INT 0
5329: PPUSH
5330: LD_INT 17
5332: PPUSH
5333: LD_VAR 0 4
5337: PPUSH
5338: CALL_OW 380
// un := CreateHuman ;
5342: LD_ADDR_VAR 0 2
5346: PUSH
5347: CALL_OW 44
5351: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5352: LD_ADDR_VAR 0 3
5356: PUSH
5357: LD_VAR 0 3
5361: PPUSH
5362: LD_INT 3
5364: PUSH
5365: LD_VAR 0 3
5369: PUSH
5370: LD_INT 3
5372: ARRAY
5373: PUSH
5374: LD_INT 1
5376: PLUS
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PPUSH
5382: LD_VAR 0 2
5386: PPUSH
5387: CALL 51685 0 3
5391: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5392: LD_VAR 0 2
5396: PPUSH
5397: LD_INT 14
5399: PPUSH
5400: LD_INT 0
5402: PPUSH
5403: CALL_OW 49
// end ;
5407: GO 5308
5409: POP
5410: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5411: LD_ADDR_VAR 0 5
5415: PUSH
5416: LD_INT 148
5418: PUSH
5419: LD_INT 158
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: PUSH
5426: LD_INT 148
5428: PUSH
5429: LD_INT 158
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5440: LD_INT 3
5442: PPUSH
5443: LD_VAR 0 3
5447: PUSH
5448: LD_INT 3
5450: ARRAY
5451: PPUSH
5452: LD_VAR 0 5
5456: PPUSH
5457: LD_VAR 0 6
5461: PPUSH
5462: CALL 39183 0 4
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5466: LD_ADDR_VAR 0 1
5470: PUSH
5471: DOUBLE
5472: LD_INT 1
5474: DEC
5475: ST_TO_ADDR
5476: LD_INT 3
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PUSH
5496: FOR_TO
5497: IFFALSE 5721
// begin uc_side := 2 ;
5499: LD_ADDR_OWVAR 20
5503: PUSH
5504: LD_INT 2
5506: ST_TO_ADDR
// uc_nation := 2 ;
5507: LD_ADDR_OWVAR 21
5511: PUSH
5512: LD_INT 2
5514: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5515: LD_INT 14
5517: PPUSH
5518: LD_INT 3
5520: PPUSH
5521: LD_INT 1
5523: PUSH
5524: LD_INT 5
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PPUSH
5537: CALL_OW 12
5541: ARRAY
5542: PPUSH
5543: LD_INT 27
5545: PUSH
5546: LD_INT 26
5548: PUSH
5549: LD_INT 28
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 1
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: CALL_OW 12
5567: ARRAY
5568: PPUSH
5569: LD_INT 100
5571: PPUSH
5572: CALL 51563 0 5
// un := CreateVehicle ;
5576: LD_ADDR_VAR 0 2
5580: PUSH
5581: CALL_OW 45
5585: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5586: LD_ADDR_VAR 0 3
5590: PUSH
5591: LD_VAR 0 3
5595: PPUSH
5596: LD_INT 4
5598: PUSH
5599: LD_VAR 0 3
5603: PUSH
5604: LD_INT 4
5606: ARRAY
5607: PUSH
5608: LD_INT 1
5610: PLUS
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PPUSH
5616: LD_VAR 0 2
5620: PPUSH
5621: CALL 51685 0 3
5625: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5626: LD_VAR 0 2
5630: PPUSH
5631: LD_INT 5
5633: PPUSH
5634: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5638: LD_VAR 0 2
5642: PPUSH
5643: LD_INT 15
5645: PPUSH
5646: LD_INT 0
5648: PPUSH
5649: CALL_OW 49
// if GetControl ( un ) = control_manual then
5653: LD_VAR 0 2
5657: PPUSH
5658: CALL_OW 263
5662: PUSH
5663: LD_INT 1
5665: EQUAL
5666: IFFALSE 5697
// begin PrepareHuman ( false , 3 , skill ) ;
5668: LD_INT 0
5670: PPUSH
5671: LD_INT 3
5673: PPUSH
5674: LD_VAR 0 4
5678: PPUSH
5679: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5683: CALL_OW 44
5687: PPUSH
5688: LD_VAR 0 2
5692: PPUSH
5693: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5697: LD_VAR 0 2
5701: PPUSH
5702: LD_INT 179
5704: PPUSH
5705: LD_INT 135
5707: PPUSH
5708: CALL_OW 111
// wait ( 0 0$2 ) ;
5712: LD_INT 70
5714: PPUSH
5715: CALL_OW 67
// end ;
5719: GO 5496
5721: POP
5722: POP
// vc_chassis := 15 ;
5723: LD_ADDR_OWVAR 37
5727: PUSH
5728: LD_INT 15
5730: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5731: LD_ADDR_VAR 0 3
5735: PUSH
5736: LD_VAR 0 3
5740: PPUSH
5741: LD_INT 4
5743: PUSH
5744: LD_VAR 0 3
5748: PUSH
5749: LD_INT 4
5751: ARRAY
5752: PUSH
5753: LD_INT 1
5755: PLUS
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: PPUSH
5761: CALL_OW 45
5765: PPUSH
5766: CALL 51685 0 3
5770: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5771: LD_VAR 0 3
5775: PUSH
5776: LD_INT 4
5778: ARRAY
5779: PUSH
5780: LD_VAR 0 3
5784: PUSH
5785: LD_INT 4
5787: ARRAY
5788: ARRAY
5789: PPUSH
5790: LD_INT 15
5792: PPUSH
5793: LD_INT 0
5795: PPUSH
5796: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5800: LD_INT 0
5802: PPUSH
5803: LD_INT 11
5805: PPUSH
5806: LD_VAR 0 4
5810: PPUSH
5811: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5815: LD_ADDR_VAR 0 3
5819: PUSH
5820: LD_VAR 0 3
5824: PPUSH
5825: LD_INT 4
5827: PUSH
5828: LD_VAR 0 3
5832: PUSH
5833: LD_INT 4
5835: ARRAY
5836: PUSH
5837: LD_INT 1
5839: PLUS
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PPUSH
5845: CALL_OW 44
5849: PPUSH
5850: CALL 51685 0 3
5854: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
5855: LD_VAR 0 3
5859: PUSH
5860: LD_INT 4
5862: ARRAY
5863: PUSH
5864: LD_VAR 0 3
5868: PUSH
5869: LD_INT 4
5871: ARRAY
5872: ARRAY
5873: PPUSH
5874: LD_VAR 0 3
5878: PUSH
5879: LD_INT 4
5881: ARRAY
5882: PUSH
5883: LD_VAR 0 3
5887: PUSH
5888: LD_INT 4
5890: ARRAY
5891: PUSH
5892: LD_INT 1
5894: MINUS
5895: ARRAY
5896: PPUSH
5897: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
5901: LD_ADDR_VAR 0 5
5905: PUSH
5906: LD_INT 148
5908: PUSH
5909: LD_INT 140
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PUSH
5916: EMPTY
5917: LIST
5918: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
5919: LD_INT 1
5921: PPUSH
5922: LD_VAR 0 3
5926: PUSH
5927: LD_INT 4
5929: ARRAY
5930: PPUSH
5931: LD_VAR 0 5
5935: PPUSH
5936: LD_VAR 0 6
5940: PPUSH
5941: CALL 39183 0 4
// if gensher_active then
5945: LD_EXP 18
5949: IFFALSE 6334
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
5951: LD_EXP 44
5955: PPUSH
5956: LD_STRING D10-Diet-1
5958: PPUSH
5959: CALL_OW 94
// for i = 1 to 2 do
5963: LD_ADDR_VAR 0 1
5967: PUSH
5968: DOUBLE
5969: LD_INT 1
5971: DEC
5972: ST_TO_ADDR
5973: LD_INT 2
5975: PUSH
5976: FOR_TO
5977: IFFALSE 6115
// begin uc_side := 2 ;
5979: LD_ADDR_OWVAR 20
5983: PUSH
5984: LD_INT 2
5986: ST_TO_ADDR
// uc_nation := 2 ;
5987: LD_ADDR_OWVAR 21
5991: PUSH
5992: LD_INT 2
5994: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5995: LD_INT 13
5997: PPUSH
5998: LD_INT 3
6000: PPUSH
6001: LD_INT 5
6003: PPUSH
6004: LD_INT 29
6006: PPUSH
6007: LD_INT 100
6009: PPUSH
6010: CALL 51563 0 5
// un := CreateVehicle ;
6014: LD_ADDR_VAR 0 2
6018: PUSH
6019: CALL_OW 45
6023: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6024: LD_ADDR_VAR 0 3
6028: PUSH
6029: LD_VAR 0 3
6033: PPUSH
6034: LD_INT 5
6036: PUSH
6037: LD_VAR 0 3
6041: PUSH
6042: LD_INT 5
6044: ARRAY
6045: PUSH
6046: LD_INT 1
6048: PLUS
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: LD_VAR 0 2
6058: PPUSH
6059: CALL 51685 0 3
6063: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6064: LD_VAR 0 2
6068: PPUSH
6069: LD_INT 0
6071: PPUSH
6072: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6076: LD_VAR 0 2
6080: PPUSH
6081: LD_INT 23
6083: PPUSH
6084: LD_INT 0
6086: PPUSH
6087: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 85
6098: PPUSH
6099: LD_INT 152
6101: PPUSH
6102: CALL_OW 111
// wait ( 0 0$2 ) ;
6106: LD_INT 70
6108: PPUSH
6109: CALL_OW 67
// end ;
6113: GO 5976
6115: POP
6116: POP
// for i = 1 to 3 do
6117: LD_ADDR_VAR 0 1
6121: PUSH
6122: DOUBLE
6123: LD_INT 1
6125: DEC
6126: ST_TO_ADDR
6127: LD_INT 3
6129: PUSH
6130: FOR_TO
6131: IFFALSE 6288
// begin uc_side := 2 ;
6133: LD_ADDR_OWVAR 20
6137: PUSH
6138: LD_INT 2
6140: ST_TO_ADDR
// uc_nation := 2 ;
6141: LD_ADDR_OWVAR 21
6145: PUSH
6146: LD_INT 2
6148: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6149: LD_INT 14
6151: PPUSH
6152: LD_INT 3
6154: PPUSH
6155: LD_INT 5
6157: PPUSH
6158: LD_INT 27
6160: PUSH
6161: LD_INT 28
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PUSH
6168: LD_INT 1
6170: PPUSH
6171: LD_INT 2
6173: PPUSH
6174: CALL_OW 12
6178: ARRAY
6179: PPUSH
6180: LD_INT 100
6182: PPUSH
6183: CALL 51563 0 5
// un := CreateVehicle ;
6187: LD_ADDR_VAR 0 2
6191: PUSH
6192: CALL_OW 45
6196: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6197: LD_ADDR_VAR 0 3
6201: PUSH
6202: LD_VAR 0 3
6206: PPUSH
6207: LD_INT 5
6209: PUSH
6210: LD_VAR 0 3
6214: PUSH
6215: LD_INT 5
6217: ARRAY
6218: PUSH
6219: LD_INT 1
6221: PLUS
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PPUSH
6227: LD_VAR 0 2
6231: PPUSH
6232: CALL 51685 0 3
6236: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6237: LD_VAR 0 2
6241: PPUSH
6242: LD_INT 0
6244: PPUSH
6245: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6249: LD_VAR 0 2
6253: PPUSH
6254: LD_INT 23
6256: PPUSH
6257: LD_INT 0
6259: PPUSH
6260: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6264: LD_VAR 0 2
6268: PPUSH
6269: LD_INT 85
6271: PPUSH
6272: LD_INT 152
6274: PPUSH
6275: CALL_OW 111
// wait ( 0 0$2 ) ;
6279: LD_INT 70
6281: PPUSH
6282: CALL_OW 67
// end ;
6286: GO 6130
6288: POP
6289: POP
// coords := [ [ 97 , 143 ] ] ;
6290: LD_ADDR_VAR 0 5
6294: PUSH
6295: LD_INT 97
6297: PUSH
6298: LD_INT 143
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: EMPTY
6306: LIST
6307: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6308: LD_INT 1
6310: PPUSH
6311: LD_VAR 0 3
6315: PUSH
6316: LD_INT 5
6318: ARRAY
6319: PPUSH
6320: LD_VAR 0 5
6324: PPUSH
6325: LD_VAR 0 6
6329: PPUSH
6330: CALL 39183 0 4
// end ; Wait ( 13 13$00 ) ;
6334: LD_INT 27300
6336: PPUSH
6337: CALL_OW 67
// tmp := [ ] ;
6341: LD_ADDR_VAR 0 3
6345: PUSH
6346: EMPTY
6347: ST_TO_ADDR
// w := 1 ;
6348: LD_ADDR_VAR 0 7
6352: PUSH
6353: LD_INT 1
6355: ST_TO_ADDR
// repeat tmp := [ ] ;
6356: LD_ADDR_VAR 0 3
6360: PUSH
6361: EMPTY
6362: ST_TO_ADDR
// if w mod 4 = 0 then
6363: LD_VAR 0 7
6367: PUSH
6368: LD_INT 4
6370: MOD
6371: PUSH
6372: LD_INT 0
6374: EQUAL
6375: IFFALSE 6462
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6377: LD_ADDR_VAR 0 8
6381: PUSH
6382: LD_INT 11
6384: PUSH
6385: LD_INT 1
6387: PUSH
6388: LD_INT 2
6390: PUSH
6391: LD_INT 24
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: PUSH
6400: LD_INT 11
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 2
6408: PUSH
6409: LD_INT 24
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: PUSH
6418: LD_INT 11
6420: PUSH
6421: LD_INT 1
6423: PUSH
6424: LD_INT 2
6426: PUSH
6427: LD_INT 24
6429: PUSH
6430: EMPTY
6431: LIST
6432: LIST
6433: LIST
6434: LIST
6435: PUSH
6436: LD_INT 11
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 24
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: ST_TO_ADDR
6460: GO 6564
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6462: LD_ADDR_VAR 0 8
6466: PUSH
6467: LD_INT 14
6469: PUSH
6470: LD_INT 1
6472: PUSH
6473: LD_INT 2
6475: PUSH
6476: LD_INT 28
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: PUSH
6485: LD_INT 14
6487: PUSH
6488: LD_INT 1
6490: PUSH
6491: LD_INT 2
6493: PUSH
6494: LD_INT 25
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_INT 14
6505: PUSH
6506: LD_INT 1
6508: PUSH
6509: LD_INT 2
6511: PUSH
6512: LD_INT 28
6514: PUSH
6515: EMPTY
6516: LIST
6517: LIST
6518: LIST
6519: LIST
6520: PUSH
6521: LD_INT 14
6523: PUSH
6524: LD_INT 1
6526: PUSH
6527: LD_INT 2
6529: PUSH
6530: LD_INT 29
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 11
6541: PUSH
6542: LD_INT 1
6544: PUSH
6545: LD_INT 2
6547: PUSH
6548: LD_INT 24
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: ST_TO_ADDR
// if w mod 3 = 0 then
6564: LD_VAR 0 7
6568: PUSH
6569: LD_INT 3
6571: MOD
6572: PUSH
6573: LD_INT 0
6575: EQUAL
6576: IFFALSE 6652
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6578: LD_ADDR_VAR 0 8
6582: PUSH
6583: LD_VAR 0 8
6587: PPUSH
6588: LD_INT 1
6590: PUSH
6591: LD_VAR 0 8
6595: PUSH
6596: LD_VAR 0 1
6600: ARRAY
6601: PUSH
6602: LD_INT 1
6604: PLUS
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: PPUSH
6610: LD_INT 14
6612: PUSH
6613: LD_INT 1
6615: PUSH
6616: LD_INT 2
6618: PUSH
6619: LD_INT 25
6621: PUSH
6622: LD_INT 28
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: PPUSH
6647: CALL 51685 0 3
6651: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6652: LD_INT 1
6654: PPUSH
6655: LD_VAR 0 8
6659: PPUSH
6660: CALL 38950 0 2
// if GetSide ( ar_dep_w ) = 2 then
6664: LD_INT 45
6666: PPUSH
6667: CALL_OW 255
6671: PUSH
6672: LD_INT 2
6674: EQUAL
6675: IFFALSE 6760
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6677: LD_ADDR_VAR 0 8
6681: PUSH
6682: LD_INT 14
6684: PUSH
6685: LD_INT 1
6687: PUSH
6688: LD_INT 2
6690: PUSH
6691: LD_INT 28
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: PUSH
6700: LD_INT 14
6702: PUSH
6703: LD_INT 1
6705: PUSH
6706: LD_INT 2
6708: PUSH
6709: LD_INT 27
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: PUSH
6718: LD_INT 14
6720: PUSH
6721: LD_INT 1
6723: PUSH
6724: LD_INT 2
6726: PUSH
6727: LD_INT 27
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: EMPTY
6737: LIST
6738: LIST
6739: LIST
6740: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6741: LD_INT 2
6743: PPUSH
6744: LD_VAR 0 8
6748: PPUSH
6749: CALL 38950 0 2
// wait ( 0 0$50 ) ;
6753: LD_INT 1750
6755: PPUSH
6756: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6760: LD_INT 35
6762: PPUSH
6763: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6767: LD_EXP 68
6771: PUSH
6772: LD_INT 1
6774: ARRAY
6775: PPUSH
6776: LD_INT 3
6778: PUSH
6779: LD_INT 34
6781: PUSH
6782: LD_INT 32
6784: PUSH
6785: EMPTY
6786: LIST
6787: LIST
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: PPUSH
6793: CALL_OW 72
6797: PUSH
6798: LD_INT 4
6800: GREATEREQUAL
6801: IFFALSE 6760
// wait ( 0 0$10 ) ;
6803: LD_INT 350
6805: PPUSH
6806: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
6810: LD_ADDR_VAR 0 3
6814: PUSH
6815: LD_EXP 68
6819: PUSH
6820: LD_INT 1
6822: ARRAY
6823: PPUSH
6824: LD_INT 3
6826: PUSH
6827: LD_INT 34
6829: PUSH
6830: LD_INT 32
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: PPUSH
6841: CALL_OW 72
6845: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
6846: LD_INT 100
6848: PPUSH
6849: CALL_OW 13
6853: PUSH
6854: LD_INT 50
6856: LESS
6857: IFFALSE 6890
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
6859: LD_ADDR_VAR 0 5
6863: PUSH
6864: LD_INT 55
6866: PUSH
6867: LD_INT 7
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 75
6876: PUSH
6877: LD_INT 90
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PUSH
6884: EMPTY
6885: LIST
6886: LIST
6887: ST_TO_ADDR
6888: GO 6919
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
6890: LD_ADDR_VAR 0 5
6894: PUSH
6895: LD_INT 128
6897: PUSH
6898: LD_INT 94
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PUSH
6905: LD_INT 180
6907: PUSH
6908: LD_INT 135
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: ST_TO_ADDR
// if w mod 4 = 0 then
6919: LD_VAR 0 7
6923: PUSH
6924: LD_INT 4
6926: MOD
6927: PUSH
6928: LD_INT 0
6930: EQUAL
6931: IFFALSE 6962
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
6933: LD_ADDR_VAR 0 5
6937: PUSH
6938: LD_INT 91
6940: PUSH
6941: LD_INT 58
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 117
6950: PUSH
6951: LD_INT 107
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
6962: LD_INT 1
6964: PPUSH
6965: LD_VAR 0 3
6969: PPUSH
6970: LD_VAR 0 5
6974: PPUSH
6975: LD_VAR 0 6
6979: PPUSH
6980: CALL 39183 0 4
// if mc_vehicles [ 2 ] then
6984: LD_EXP 68
6988: PUSH
6989: LD_INT 2
6991: ARRAY
6992: IFFALSE 7028
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
6994: LD_INT 2
6996: PPUSH
6997: LD_EXP 68
7001: PUSH
7002: LD_INT 2
7004: ARRAY
7005: PPUSH
7006: LD_INT 73
7008: PUSH
7009: LD_INT 115
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PUSH
7016: EMPTY
7017: LIST
7018: PPUSH
7019: LD_VAR 0 6
7023: PPUSH
7024: CALL 39183 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7028: LD_INT 22050
7030: PPUSH
7031: LD_INT 28350
7033: PPUSH
7034: CALL_OW 12
7038: PPUSH
7039: CALL_OW 67
// w := w + 1 ;
7043: LD_ADDR_VAR 0 7
7047: PUSH
7048: LD_VAR 0 7
7052: PUSH
7053: LD_INT 1
7055: PLUS
7056: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7057: LD_INT 94
7059: PPUSH
7060: CALL_OW 301
7064: PUSH
7065: LD_EXP 49
7069: PUSH
7070: LD_INT 1
7072: ARRAY
7073: PPUSH
7074: LD_INT 30
7076: PUSH
7077: LD_INT 3
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: PPUSH
7084: CALL_OW 72
7088: NOT
7089: OR
7090: IFFALSE 6356
// end ;
7092: PPOPN 8
7094: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7095: LD_INT 204
7097: IFFALSE 7571
7099: GO 7101
7101: DISABLE
7102: LD_INT 0
7104: PPUSH
7105: PPUSH
7106: PPUSH
7107: PPUSH
// begin enable ;
7108: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7109: LD_INT 35
7111: PPUSH
7112: LD_INT 1190
7114: PPUSH
7115: CALL_OW 12
7119: PPUSH
7120: CALL_OW 67
// tmp := [ ] ;
7124: LD_ADDR_VAR 0 2
7128: PUSH
7129: EMPTY
7130: ST_TO_ADDR
// uc_side := 8 ;
7131: LD_ADDR_OWVAR 20
7135: PUSH
7136: LD_INT 8
7138: ST_TO_ADDR
// uc_nation := 2 ;
7139: LD_ADDR_OWVAR 21
7143: PUSH
7144: LD_INT 2
7146: ST_TO_ADDR
// InitHc ;
7147: CALL_OW 19
// for i = 1 to 3 do
7151: LD_ADDR_VAR 0 1
7155: PUSH
7156: DOUBLE
7157: LD_INT 1
7159: DEC
7160: ST_TO_ADDR
7161: LD_INT 3
7163: PUSH
7164: FOR_TO
7165: IFFALSE 7292
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7167: LD_INT 13
7169: PUSH
7170: LD_INT 14
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 1
7179: PPUSH
7180: LD_INT 2
7182: PPUSH
7183: CALL_OW 12
7187: ARRAY
7188: PPUSH
7189: LD_INT 3
7191: PPUSH
7192: LD_INT 5
7194: PPUSH
7195: LD_INT 27
7197: PUSH
7198: LD_INT 28
7200: PUSH
7201: EMPTY
7202: LIST
7203: LIST
7204: PUSH
7205: LD_INT 1
7207: PPUSH
7208: LD_INT 2
7210: PPUSH
7211: CALL_OW 12
7215: ARRAY
7216: PPUSH
7217: LD_INT 100
7219: PPUSH
7220: CALL 51563 0 5
// un := CreateVehicle ;
7224: LD_ADDR_VAR 0 3
7228: PUSH
7229: CALL_OW 45
7233: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7234: LD_VAR 0 3
7238: PPUSH
7239: LD_INT 4
7241: PPUSH
7242: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7246: LD_VAR 0 3
7250: PPUSH
7251: LD_INT 15
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7261: LD_ADDR_VAR 0 2
7265: PUSH
7266: LD_VAR 0 2
7270: PPUSH
7271: LD_VAR 0 2
7275: PUSH
7276: LD_INT 1
7278: PLUS
7279: PPUSH
7280: LD_VAR 0 3
7284: PPUSH
7285: CALL_OW 1
7289: ST_TO_ADDR
// end ;
7290: GO 7164
7292: POP
7293: POP
// for i = 1 to 4 do
7294: LD_ADDR_VAR 0 1
7298: PUSH
7299: DOUBLE
7300: LD_INT 1
7302: DEC
7303: ST_TO_ADDR
7304: LD_INT 4
7306: PUSH
7307: FOR_TO
7308: IFFALSE 7387
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7310: LD_INT 0
7312: PPUSH
7313: LD_INT 1
7315: PPUSH
7316: LD_INT 4
7318: PPUSH
7319: CALL_OW 12
7323: PPUSH
7324: LD_INT 6
7326: PPUSH
7327: CALL_OW 380
// un := CreateHuman ;
7331: LD_ADDR_VAR 0 3
7335: PUSH
7336: CALL_OW 44
7340: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7341: LD_VAR 0 3
7345: PPUSH
7346: LD_INT 15
7348: PPUSH
7349: LD_INT 0
7351: PPUSH
7352: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7356: LD_ADDR_VAR 0 2
7360: PUSH
7361: LD_VAR 0 2
7365: PPUSH
7366: LD_VAR 0 2
7370: PUSH
7371: LD_INT 1
7373: PLUS
7374: PPUSH
7375: LD_VAR 0 3
7379: PPUSH
7380: CALL_OW 1
7384: ST_TO_ADDR
// end ;
7385: GO 7307
7387: POP
7388: POP
// wait ( 0 0$3 ) ;
7389: LD_INT 105
7391: PPUSH
7392: CALL_OW 67
// for i in tmp do
7396: LD_ADDR_VAR 0 1
7400: PUSH
7401: LD_VAR 0 2
7405: PUSH
7406: FOR_IN
7407: IFFALSE 7475
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7409: LD_VAR 0 1
7413: PPUSH
7414: CALL_OW 257
7418: PUSH
7419: LD_INT 1
7421: EQUAL
7422: PUSH
7423: LD_VAR 0 1
7427: PPUSH
7428: CALL_OW 247
7432: PUSH
7433: LD_INT 2
7435: EQUAL
7436: OR
7437: IFFALSE 7473
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7439: LD_VAR 0 1
7443: PPUSH
7444: LD_INT 81
7446: PUSH
7447: LD_INT 8
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PPUSH
7454: CALL_OW 69
7458: PPUSH
7459: LD_VAR 0 1
7463: PPUSH
7464: CALL_OW 74
7468: PPUSH
7469: CALL_OW 115
7473: GO 7406
7475: POP
7476: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7477: LD_VAR 0 2
7481: PPUSH
7482: LD_INT 210
7484: PPUSH
7485: LD_INT 178
7487: PPUSH
7488: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7492: LD_ADDR_VAR 0 4
7496: PUSH
7497: LD_INT 10
7499: PPUSH
7500: LD_INT 22
7502: PUSH
7503: LD_INT 8
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PPUSH
7510: CALL_OW 70
7514: ST_TO_ADDR
// if x then
7515: LD_VAR 0 4
7519: IFFALSE 7547
// for i in x do
7521: LD_ADDR_VAR 0 1
7525: PUSH
7526: LD_VAR 0 4
7530: PUSH
7531: FOR_IN
7532: IFFALSE 7545
// RemoveUnit ( i ) ;
7534: LD_VAR 0 1
7538: PPUSH
7539: CALL_OW 64
7543: GO 7531
7545: POP
7546: POP
// wait ( 0 0$1 ) ;
7547: LD_INT 35
7549: PPUSH
7550: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7554: LD_INT 22
7556: PUSH
7557: LD_INT 8
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 69
7568: NOT
7569: IFFALSE 7477
// end ;
7571: PPOPN 4
7573: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7574: LD_INT 22
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PUSH
7584: LD_INT 34
7586: PUSH
7587: LD_INT 31
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: PUSH
7594: LD_INT 3
7596: PUSH
7597: LD_INT 24
7599: PUSH
7600: LD_INT 1000
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: LIST
7615: PPUSH
7616: CALL_OW 69
7620: IFFALSE 7664
7622: GO 7624
7624: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7625: LD_INT 22
7627: PUSH
7628: LD_INT 2
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: PUSH
7635: LD_INT 34
7637: PUSH
7638: LD_INT 31
7640: PUSH
7641: EMPTY
7642: LIST
7643: LIST
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PPUSH
7649: CALL_OW 69
7653: PPUSH
7654: LD_INT 106
7656: PPUSH
7657: LD_INT 14
7659: PPUSH
7660: CALL_OW 111
// end ; end_of_file
7664: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7665: LD_INT 0
7667: PPUSH
7668: PPUSH
7669: PPUSH
7670: PPUSH
7671: PPUSH
7672: PPUSH
// InGameOn ;
7673: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7677: LD_EXP 20
7681: PPUSH
7682: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7686: LD_INT 2
7688: PPUSH
7689: LD_INT 1
7691: PPUSH
7692: LD_INT 1
7694: PPUSH
7695: LD_INT 1
7697: PPUSH
7698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7702: LD_ADDR_VAR 0 2
7706: PUSH
7707: LD_INT 22
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PUSH
7717: LD_INT 25
7719: PUSH
7720: LD_INT 1
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PPUSH
7731: CALL_OW 69
7735: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7736: LD_ADDR_VAR 0 4
7740: PUSH
7741: LD_INT 22
7743: PUSH
7744: LD_INT 1
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: PUSH
7751: LD_INT 34
7753: PUSH
7754: LD_INT 11
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PPUSH
7765: CALL_OW 69
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: ST_TO_ADDR
// for i = 1 to tmp do
7774: LD_ADDR_VAR 0 6
7778: PUSH
7779: DOUBLE
7780: LD_INT 1
7782: DEC
7783: ST_TO_ADDR
7784: LD_VAR 0 2
7788: PUSH
7789: FOR_TO
7790: IFFALSE 7837
// begin if i = 5 then
7792: LD_VAR 0 6
7796: PUSH
7797: LD_INT 5
7799: EQUAL
7800: IFFALSE 7804
// break ;
7802: GO 7837
// sols := Replace ( sols , i , tmp [ i ] ) ;
7804: LD_ADDR_VAR 0 5
7808: PUSH
7809: LD_VAR 0 5
7813: PPUSH
7814: LD_VAR 0 6
7818: PPUSH
7819: LD_VAR 0 2
7823: PUSH
7824: LD_VAR 0 6
7828: ARRAY
7829: PPUSH
7830: CALL_OW 1
7834: ST_TO_ADDR
// end ;
7835: GO 7789
7837: POP
7838: POP
// tmp := ar_force_tmp ;
7839: LD_ADDR_VAR 0 2
7843: PUSH
7844: LD_EXP 39
7848: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
7849: LD_VAR 0 2
7853: PUSH
7854: LD_INT 1
7856: ARRAY
7857: PPUSH
7858: LD_INT 108
7860: PPUSH
7861: LD_INT 139
7863: PPUSH
7864: LD_INT 0
7866: PPUSH
7867: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_INT 1
7878: ARRAY
7879: PPUSH
7880: LD_EXP 20
7884: PPUSH
7885: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
7889: LD_VAR 0 2
7893: PUSH
7894: LD_INT 2
7896: ARRAY
7897: PPUSH
7898: LD_INT 114
7900: PPUSH
7901: LD_INT 132
7903: PPUSH
7904: LD_INT 0
7906: PPUSH
7907: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
7911: LD_VAR 0 2
7915: PUSH
7916: LD_INT 3
7918: ARRAY
7919: PPUSH
7920: LD_INT 115
7922: PPUSH
7923: LD_INT 132
7925: PPUSH
7926: LD_INT 0
7928: PPUSH
7929: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
7933: LD_VAR 0 2
7937: PUSH
7938: LD_INT 2
7940: ARRAY
7941: PUSH
7942: LD_VAR 0 2
7946: PUSH
7947: LD_INT 3
7949: ARRAY
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PPUSH
7955: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
7959: LD_VAR 0 4
7963: PPUSH
7964: LD_INT 83
7966: PPUSH
7967: LD_INT 123
7969: PPUSH
7970: CALL_OW 111
// Wait ( 0 0$01 ) ;
7974: LD_INT 35
7976: PPUSH
7977: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
7981: LD_INT 90
7983: PPUSH
7984: LD_INT 144
7986: PPUSH
7987: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
7991: LD_VAR 0 5
7995: PPUSH
7996: LD_INT 88
7998: PPUSH
7999: LD_INT 129
8001: PPUSH
8002: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8006: LD_ADDR_VAR 0 3
8010: PUSH
8011: LD_INT 92
8013: PUSH
8014: LD_INT 131
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 88
8023: PUSH
8024: LD_INT 127
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: PUSH
8031: LD_INT 91
8033: PUSH
8034: LD_INT 132
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 92
8043: PUSH
8044: LD_INT 134
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: LIST
8055: LIST
8056: ST_TO_ADDR
// for i = 1 to sols do
8057: LD_ADDR_VAR 0 6
8061: PUSH
8062: DOUBLE
8063: LD_INT 1
8065: DEC
8066: ST_TO_ADDR
8067: LD_VAR 0 5
8071: PUSH
8072: FOR_TO
8073: IFFALSE 8146
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8075: LD_VAR 0 5
8079: PUSH
8080: LD_VAR 0 6
8084: ARRAY
8085: PPUSH
8086: LD_VAR 0 3
8090: PUSH
8091: LD_VAR 0 6
8095: ARRAY
8096: PUSH
8097: LD_INT 1
8099: ARRAY
8100: PPUSH
8101: LD_VAR 0 3
8105: PUSH
8106: LD_VAR 0 6
8110: ARRAY
8111: PUSH
8112: LD_INT 2
8114: ARRAY
8115: PPUSH
8116: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8120: LD_VAR 0 5
8124: PUSH
8125: LD_VAR 0 6
8129: ARRAY
8130: PPUSH
8131: CALL_OW 197
// AddComHold ( sols ) ;
8135: LD_VAR 0 5
8139: PPUSH
8140: CALL_OW 200
// end ;
8144: GO 8072
8146: POP
8147: POP
// repeat wait ( 0 0$1 ) ;
8148: LD_INT 35
8150: PPUSH
8151: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8155: LD_VAR 0 5
8159: PUSH
8160: LD_INT 1
8162: ARRAY
8163: PPUSH
8164: LD_INT 92
8166: PPUSH
8167: LD_INT 131
8169: PPUSH
8170: CALL_OW 297
8174: PUSH
8175: LD_INT 4
8177: LESS
8178: IFFALSE 8148
// CenterOnXY ( 96 , 139 ) ;
8180: LD_INT 96
8182: PPUSH
8183: LD_INT 139
8185: PPUSH
8186: CALL_OW 84
// wait ( 0 0$3 ) ;
8190: LD_INT 105
8192: PPUSH
8193: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8197: LD_INT 111
8199: PPUSH
8200: LD_INT 135
8202: PPUSH
8203: LD_INT 1
8205: PPUSH
8206: LD_INT 25
8208: NEG
8209: PPUSH
8210: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8214: LD_VAR 0 2
8218: PUSH
8219: LD_INT 2
8221: ARRAY
8222: PPUSH
8223: LD_VAR 0 2
8227: PUSH
8228: LD_INT 1
8230: ARRAY
8231: PPUSH
8232: CALL_OW 250
8236: PUSH
8237: LD_INT 3
8239: PLUS
8240: PPUSH
8241: LD_VAR 0 2
8245: PUSH
8246: LD_INT 1
8248: ARRAY
8249: PPUSH
8250: CALL_OW 251
8254: PPUSH
8255: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8259: LD_VAR 0 2
8263: PUSH
8264: LD_INT 3
8266: ARRAY
8267: PPUSH
8268: LD_INT 7
8270: PPUSH
8271: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8275: LD_VAR 0 2
8279: PUSH
8280: LD_INT 2
8282: ARRAY
8283: PPUSH
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: ARRAY
8292: PPUSH
8293: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8304: LD_VAR 0 2
8308: PUSH
8309: LD_INT 1
8311: ARRAY
8312: PPUSH
8313: LD_VAR 0 2
8317: PUSH
8318: LD_INT 2
8320: ARRAY
8321: PPUSH
8322: CALL_OW 296
8326: PUSH
8327: LD_INT 5
8329: LESS
8330: IFFALSE 8297
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8332: LD_VAR 0 2
8336: PUSH
8337: LD_INT 1
8339: ARRAY
8340: PPUSH
8341: LD_VAR 0 2
8345: PUSH
8346: LD_INT 2
8348: ARRAY
8349: PPUSH
8350: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8354: LD_VAR 0 2
8358: PUSH
8359: LD_INT 1
8361: ARRAY
8362: PPUSH
8363: LD_STRING D1a-Merc1-1
8365: PPUSH
8366: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 2
8377: ARRAY
8378: PPUSH
8379: LD_STRING D1a-FMerc2-1
8381: PPUSH
8382: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 2
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 1
8402: ARRAY
8403: PPUSH
8404: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8408: LD_VAR 0 2
8412: PUSH
8413: LD_INT 1
8415: ARRAY
8416: PPUSH
8417: LD_INT 500
8419: PPUSH
8420: CALL_OW 234
// wait ( 0 0$2 ) ;
8424: LD_INT 70
8426: PPUSH
8427: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8431: LD_VAR 0 2
8435: PUSH
8436: LD_INT 1
8438: ARRAY
8439: PPUSH
8440: LD_INT 2
8442: PPUSH
8443: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8447: LD_INT 10
8449: PPUSH
8450: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8454: LD_VAR 0 2
8458: PUSH
8459: LD_INT 1
8461: ARRAY
8462: PPUSH
8463: LD_STRING D1a-Merc1-2
8465: PPUSH
8466: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8470: LD_INT 7
8472: PPUSH
8473: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8477: LD_VAR 0 2
8481: PUSH
8482: LD_INT 1
8484: ARRAY
8485: PPUSH
8486: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8490: LD_VAR 0 2
8494: PUSH
8495: LD_INT 2
8497: ARRAY
8498: PPUSH
8499: LD_INT 10
8501: PPUSH
8502: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8506: LD_VAR 0 2
8510: PUSH
8511: LD_INT 2
8513: ARRAY
8514: PPUSH
8515: LD_STRING D1a-FMerc2-2
8517: PPUSH
8518: CALL_OW 88
// wait ( 0 0$1 ) ;
8522: LD_INT 35
8524: PPUSH
8525: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8529: LD_INT 7
8531: PPUSH
8532: CALL_OW 85
// wait ( 0 0$2 ) ;
8536: LD_INT 70
8538: PPUSH
8539: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8543: LD_EXP 43
8547: PPUSH
8548: LD_STRING D1a-Saliba-1
8550: PPUSH
8551: CALL_OW 91
// KillUnit ( Saliba ) ;
8555: LD_EXP 43
8559: PPUSH
8560: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8564: LD_VAR 0 2
8568: PUSH
8569: LD_INT 3
8571: ARRAY
8572: PPUSH
8573: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8577: LD_EXP 20
8581: PPUSH
8582: CALL_OW 85
// wait ( 0 0$1 ) ;
8586: LD_INT 35
8588: PPUSH
8589: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8593: LD_VAR 0 5
8597: PPUSH
8598: LD_INT 88
8600: PPUSH
8601: LD_INT 141
8603: PPUSH
8604: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8608: LD_VAR 0 5
8612: PPUSH
8613: LD_INT 70
8615: PPUSH
8616: CALL_OW 202
// wait ( 0 0$2 ) ;
8620: LD_INT 70
8622: PPUSH
8623: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8627: LD_INT 2
8629: PPUSH
8630: LD_INT 1
8632: PPUSH
8633: LD_INT 2
8635: PPUSH
8636: LD_INT 1
8638: PPUSH
8639: CALL_OW 80
// InGameOff ;
8643: CALL_OW 9
// ComWalk ( sols ) ;
8647: LD_VAR 0 5
8651: PPUSH
8652: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8656: LD_STRING M1
8658: PPUSH
8659: CALL_OW 337
// game_speed := 4 ;
8663: LD_ADDR_OWVAR 65
8667: PUSH
8668: LD_INT 4
8670: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8671: LD_INT 111
8673: PPUSH
8674: LD_INT 135
8676: PPUSH
8677: LD_INT 1
8679: PPUSH
8680: CALL_OW 331
// SaveForQuickRestart ;
8684: CALL_OW 22
// ar_run := true ;
8688: LD_ADDR_EXP 5
8692: PUSH
8693: LD_INT 1
8695: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8696: LD_INT 35
8698: PPUSH
8699: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8703: LD_INT 22
8705: PUSH
8706: LD_INT 1
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: LD_INT 91
8715: PUSH
8716: LD_INT 7
8718: PUSH
8719: LD_INT 10
8721: PUSH
8722: EMPTY
8723: LIST
8724: LIST
8725: LIST
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PPUSH
8731: CALL_OW 69
8735: PUSH
8736: LD_INT 7
8738: PPUSH
8739: CALL_OW 256
8743: PUSH
8744: LD_INT 999
8746: LESS
8747: OR
8748: IFFALSE 8696
// if GetSide ( ar_dep_s ) = 2 then
8750: LD_INT 7
8752: PPUSH
8753: CALL_OW 255
8757: PUSH
8758: LD_INT 2
8760: EQUAL
8761: IFFALSE 8773
// SetSide ( ar_dep_s , 1 ) ;
8763: LD_INT 7
8765: PPUSH
8766: LD_INT 1
8768: PPUSH
8769: CALL_OW 235
// end ;
8773: LD_VAR 0 1
8777: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8778: LD_EXP 5
8782: IFFALSE 9142
8784: GO 8786
8786: DISABLE
8787: LD_INT 0
8789: PPUSH
8790: PPUSH
8791: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8792: LD_ADDR_VAR 0 2
8796: PUSH
8797: LD_EXP 39
8801: PUSH
8802: LD_EXP 35
8806: PPUSH
8807: LD_INT 2
8809: PUSH
8810: LD_INT 21
8812: PUSH
8813: LD_INT 2
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 21
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: LIST
8834: PPUSH
8835: CALL_OW 72
8839: ADD
8840: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
8841: LD_VAR 0 2
8845: PPUSH
8846: LD_INT 5
8848: PPUSH
8849: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
8853: LD_INT 5
8855: PPUSH
8856: LD_INT 1
8858: PPUSH
8859: CALL_OW 343
// k := 1 ;
8863: LD_ADDR_VAR 0 3
8867: PUSH
8868: LD_INT 1
8870: ST_TO_ADDR
// for i in tmp do
8871: LD_ADDR_VAR 0 1
8875: PUSH
8876: LD_VAR 0 2
8880: PUSH
8881: FOR_IN
8882: IFFALSE 8967
// begin if IsInUnit ( i ) then
8884: LD_VAR 0 1
8888: PPUSH
8889: CALL_OW 310
8893: IFFALSE 8904
// ComExitBuilding ( i ) ;
8895: LD_VAR 0 1
8899: PPUSH
8900: CALL_OW 122
// if GetClass ( i ) = 3 then
8904: LD_VAR 0 1
8908: PPUSH
8909: CALL_OW 257
8913: PUSH
8914: LD_INT 3
8916: EQUAL
8917: IFFALSE 8953
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
8919: LD_VAR 0 1
8923: PPUSH
8924: LD_EXP 40
8928: PUSH
8929: LD_VAR 0 3
8933: ARRAY
8934: PPUSH
8935: CALL_OW 180
// k := k + 1 ;
8939: LD_ADDR_VAR 0 3
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 1
8951: PLUS
8952: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
8953: LD_VAR 0 1
8957: PPUSH
8958: LD_INT 10
8960: PPUSH
8961: CALL_OW 173
// end ;
8965: GO 8881
8967: POP
8968: POP
// ar_patrol := true ;
8969: LD_ADDR_EXP 7
8973: PUSH
8974: LD_INT 1
8976: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
8977: LD_INT 10
8979: PPUSH
8980: CALL_OW 67
// for i in tmp do
8984: LD_ADDR_VAR 0 1
8988: PUSH
8989: LD_VAR 0 2
8993: PUSH
8994: FOR_IN
8995: IFFALSE 9023
// if not HasTask ( i ) then
8997: LD_VAR 0 1
9001: PPUSH
9002: CALL_OW 314
9006: NOT
9007: IFFALSE 9021
// ComMoveToArea ( i , escape_area ) ;
9009: LD_VAR 0 1
9013: PPUSH
9014: LD_INT 10
9016: PPUSH
9017: CALL_OW 113
9021: GO 8994
9023: POP
9024: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9025: LD_ADDR_VAR 0 3
9029: PUSH
9030: LD_VAR 0 2
9034: PPUSH
9035: LD_INT 95
9037: PUSH
9038: LD_INT 10
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PPUSH
9045: CALL_OW 72
9049: ST_TO_ADDR
// if k then
9050: LD_VAR 0 3
9054: IFFALSE 9123
// for i in k do
9056: LD_ADDR_VAR 0 1
9060: PUSH
9061: LD_VAR 0 3
9065: PUSH
9066: FOR_IN
9067: IFFALSE 9121
// begin if IsInUnit ( i ) then
9069: LD_VAR 0 1
9073: PPUSH
9074: CALL_OW 310
9078: IFFALSE 9094
// RemoveUnit ( IsInUnit ( i ) ) ;
9080: LD_VAR 0 1
9084: PPUSH
9085: CALL_OW 310
9089: PPUSH
9090: CALL_OW 64
// RemoveUnit ( i ) ;
9094: LD_VAR 0 1
9098: PPUSH
9099: CALL_OW 64
// tmp := tmp diff i ;
9103: LD_ADDR_VAR 0 2
9107: PUSH
9108: LD_VAR 0 2
9112: PUSH
9113: LD_VAR 0 1
9117: DIFF
9118: ST_TO_ADDR
// end ;
9119: GO 9066
9121: POP
9122: POP
// until tmp = [ ] ;
9123: LD_VAR 0 2
9127: PUSH
9128: EMPTY
9129: EQUAL
9130: IFFALSE 8977
// ChangeSideFog ( 5 , 5 ) ;
9132: LD_INT 5
9134: PPUSH
9135: LD_INT 5
9137: PPUSH
9138: CALL_OW 343
// end ;
9142: PPOPN 3
9144: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9145: LD_EXP 7
9149: IFFALSE 9439
9151: GO 9153
9153: DISABLE
9154: LD_INT 0
9156: PPUSH
9157: PPUSH
9158: PPUSH
// begin uc_side := 2 ;
9159: LD_ADDR_OWVAR 20
9163: PUSH
9164: LD_INT 2
9166: ST_TO_ADDR
// uc_nation := 2 ;
9167: LD_ADDR_OWVAR 21
9171: PUSH
9172: LD_INT 2
9174: ST_TO_ADDR
// InitHc ;
9175: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9179: LD_INT 1
9181: PPUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 6
9187: PPUSH
9188: CALL_OW 380
// un := CreateHuman ;
9192: LD_ADDR_VAR 0 2
9196: PUSH
9197: CALL_OW 44
9201: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9202: LD_INT 14
9204: PPUSH
9205: LD_INT 1
9207: PPUSH
9208: LD_INT 1
9210: PPUSH
9211: LD_INT 27
9213: PPUSH
9214: LD_INT 98
9216: PPUSH
9217: CALL 51563 0 5
// veh := CreateVehicle ;
9221: LD_ADDR_VAR 0 3
9225: PUSH
9226: CALL_OW 45
9230: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9231: LD_VAR 0 3
9235: PPUSH
9236: LD_INT 4
9238: PPUSH
9239: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9243: LD_VAR 0 3
9247: PPUSH
9248: LD_INT 179
9250: PPUSH
9251: LD_INT 135
9253: PPUSH
9254: LD_INT 0
9256: PPUSH
9257: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9261: LD_VAR 0 2
9265: PPUSH
9266: LD_VAR 0 3
9270: PPUSH
9271: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9275: LD_VAR 0 2
9279: PPUSH
9280: LD_INT 126
9282: PPUSH
9283: LD_INT 133
9285: PPUSH
9286: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9290: LD_INT 10
9292: PPUSH
9293: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9297: LD_INT 1
9299: PPUSH
9300: LD_VAR 0 3
9304: PPUSH
9305: CALL_OW 292
9309: PUSH
9310: LD_VAR 0 3
9314: PPUSH
9315: LD_INT 7
9317: PPUSH
9318: CALL_OW 296
9322: PUSH
9323: LD_INT 9
9325: LESS
9326: OR
9327: IFFALSE 9290
// ComHold ( veh ) ;
9329: LD_VAR 0 3
9333: PPUSH
9334: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9338: LD_VAR 0 2
9342: PPUSH
9343: LD_STRING D2aa-Ar1-1
9345: PPUSH
9346: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9350: LD_VAR 0 2
9354: PPUSH
9355: LD_INT 177
9357: PPUSH
9358: LD_INT 96
9360: PPUSH
9361: CALL_OW 111
// AddComExitVehicle ( un ) ;
9365: LD_VAR 0 2
9369: PPUSH
9370: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9374: LD_INT 35
9376: PPUSH
9377: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9381: LD_VAR 0 2
9385: PPUSH
9386: LD_INT 204
9388: PPUSH
9389: CALL_OW 296
9393: PUSH
9394: LD_INT 15
9396: LESS
9397: IFFALSE 9374
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9399: LD_ADDR_EXP 49
9403: PUSH
9404: LD_EXP 49
9408: PPUSH
9409: LD_INT 3
9411: PUSH
9412: LD_EXP 49
9416: PUSH
9417: LD_INT 3
9419: ARRAY
9420: PUSH
9421: LD_INT 1
9423: PLUS
9424: PUSH
9425: EMPTY
9426: LIST
9427: LIST
9428: PPUSH
9429: LD_VAR 0 2
9433: PPUSH
9434: CALL 51685 0 3
9438: ST_TO_ADDR
// end ;
9439: PPOPN 3
9441: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9442: LD_INT 7
9444: PPUSH
9445: CALL_OW 255
9449: PUSH
9450: LD_INT 1
9452: EQUAL
9453: PUSH
9454: LD_INT 7
9456: PPUSH
9457: CALL_OW 301
9461: OR
9462: IFFALSE 11886
9464: GO 9466
9466: DISABLE
9467: LD_INT 0
9469: PPUSH
9470: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9471: LD_ADDR_VAR 0 1
9475: PUSH
9476: LD_EXP 35
9480: PPUSH
9481: LD_INT 21
9483: PUSH
9484: LD_INT 3
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: PPUSH
9491: CALL_OW 72
9495: PUSH
9496: FOR_IN
9497: IFFALSE 9513
// SetSide ( i , 1 ) ;
9499: LD_VAR 0 1
9503: PPUSH
9504: LD_INT 1
9506: PPUSH
9507: CALL_OW 235
9511: GO 9496
9513: POP
9514: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9515: LD_ADDR_VAR 0 2
9519: PUSH
9520: LD_INT 46
9522: PUSH
9523: LD_INT 41
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: PUSH
9530: LD_INT 50
9532: PUSH
9533: LD_INT 25
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 57
9542: PUSH
9543: LD_INT 75
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 75
9552: PUSH
9553: LD_INT 89
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: PUSH
9560: LD_INT 51
9562: PUSH
9563: LD_INT 45
9565: PUSH
9566: EMPTY
9567: LIST
9568: LIST
9569: PUSH
9570: LD_INT 95
9572: PUSH
9573: LD_INT 95
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 84
9582: PUSH
9583: LD_INT 77
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: PUSH
9590: LD_INT 101
9592: PUSH
9593: LD_INT 76
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 118
9602: PUSH
9603: LD_INT 81
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PUSH
9610: LD_INT 139
9612: PUSH
9613: LD_INT 97
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: PUSH
9620: LD_INT 129
9622: PUSH
9623: LD_INT 114
9625: PUSH
9626: EMPTY
9627: LIST
9628: LIST
9629: PUSH
9630: LD_INT 154
9632: PUSH
9633: LD_INT 111
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: ST_TO_ADDR
// base_captured := true ;
9654: LD_ADDR_EXP 6
9658: PUSH
9659: LD_INT 1
9661: ST_TO_ADDR
// DialogueOn ;
9662: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9666: LD_EXP 20
9670: PPUSH
9671: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9675: LD_EXP 20
9679: PPUSH
9680: LD_STRING D2-JMM-1
9682: PPUSH
9683: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9687: LD_EXP 29
9691: PPUSH
9692: LD_STRING D2-Pow-1
9694: PPUSH
9695: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9699: LD_EXP 20
9703: PPUSH
9704: LD_STRING D2-JMM-2
9706: PPUSH
9707: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9711: LD_EXP 29
9715: PPUSH
9716: LD_STRING D2-Pow-2
9718: PPUSH
9719: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9723: LD_EXP 20
9727: PPUSH
9728: LD_STRING D2-JMM-3
9730: PPUSH
9731: CALL_OW 88
// DialogueOff ;
9735: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9739: LD_STRING M2
9741: PPUSH
9742: CALL_OW 337
// Wait ( 0 0$2 ) ;
9746: LD_INT 70
9748: PPUSH
9749: CALL_OW 67
// if IsOk ( Gary ) then
9753: LD_EXP 31
9757: PPUSH
9758: CALL_OW 302
9762: IFFALSE 9776
// Say ( Gary , D2a-Gary-1 ) ;
9764: LD_EXP 31
9768: PPUSH
9769: LD_STRING D2a-Gary-1
9771: PPUSH
9772: CALL_OW 88
// if IsOk ( Bobby ) then
9776: LD_EXP 23
9780: PPUSH
9781: CALL_OW 302
9785: IFFALSE 9799
// Say ( Bobby , D2a-Bobby-1 ) ;
9787: LD_EXP 23
9791: PPUSH
9792: LD_STRING D2a-Bobby-1
9794: PPUSH
9795: CALL_OW 88
// if IsOk ( Cyrus ) then
9799: LD_EXP 24
9803: PPUSH
9804: CALL_OW 302
9808: IFFALSE 9822
// Say ( Cyrus , D2a-Cyrus-1 ) ;
9810: LD_EXP 24
9814: PPUSH
9815: LD_STRING D2a-Cyrus-1
9817: PPUSH
9818: CALL_OW 88
// if IsOk ( Lisa ) then
9822: LD_EXP 21
9826: PPUSH
9827: CALL_OW 302
9831: IFFALSE 9845
// Say ( Lisa , D2a-Lisa-1 ) ;
9833: LD_EXP 21
9837: PPUSH
9838: LD_STRING D2a-Lisa-1
9840: PPUSH
9841: CALL_OW 88
// if IsOk ( Frank ) then
9845: LD_EXP 32
9849: PPUSH
9850: CALL_OW 302
9854: IFFALSE 9868
// Say ( Frank , D2a-Frank-1 ) ;
9856: LD_EXP 32
9860: PPUSH
9861: LD_STRING D2a-Frank-1
9863: PPUSH
9864: CALL_OW 88
// if IsOk ( Cornel ) then
9868: LD_EXP 30
9872: PPUSH
9873: CALL_OW 302
9877: IFFALSE 9891
// Say ( Cornel , D2a-Corn-1 ) ;
9879: LD_EXP 30
9883: PPUSH
9884: LD_STRING D2a-Corn-1
9886: PPUSH
9887: CALL_OW 88
// if IsOk ( Donaldson ) then
9891: LD_EXP 22
9895: PPUSH
9896: CALL_OW 302
9900: IFFALSE 9914
// Say ( Donaldson , D2a-Don-1 ) ;
9902: LD_EXP 22
9906: PPUSH
9907: LD_STRING D2a-Don-1
9909: PPUSH
9910: CALL_OW 88
// if IsOk ( Brown ) then
9914: LD_EXP 26
9918: PPUSH
9919: CALL_OW 302
9923: IFFALSE 9937
// Say ( Brown , D2a-Brown-1 ) ;
9925: LD_EXP 26
9929: PPUSH
9930: LD_STRING D2a-Brown-1
9932: PPUSH
9933: CALL_OW 88
// Wait ( 0 0$30 ) ;
9937: LD_INT 1050
9939: PPUSH
9940: CALL_OW 67
// if IsOk ( Frank ) then
9944: LD_EXP 32
9948: PPUSH
9949: CALL_OW 302
9953: IFFALSE 10219
// begin DialogueOn ;
9955: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
9959: LD_EXP 20
9963: PUSH
9964: LD_EXP 32
9968: PUSH
9969: EMPTY
9970: LIST
9971: LIST
9972: PPUSH
9973: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
9977: LD_EXP 32
9981: PPUSH
9982: LD_STRING D3F-Frank-1
9984: PPUSH
9985: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
9989: LD_EXP 20
9993: PPUSH
9994: LD_STRING D3F-JMM-1
9996: PPUSH
9997: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10001: LD_EXP 32
10005: PPUSH
10006: LD_STRING D3F-Frank-2
10008: PPUSH
10009: CALL_OW 88
// case Query ( QFrank ) of 1 :
10013: LD_STRING QFrank
10015: PPUSH
10016: CALL_OW 97
10020: PUSH
10021: LD_INT 1
10023: DOUBLE
10024: EQUAL
10025: IFTRUE 10029
10027: GO 10052
10029: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10030: LD_EXP 20
10034: PPUSH
10035: LD_STRING D3Fa-JMM-1
10037: PPUSH
10038: CALL_OW 88
// us_scout := 1 ;
10042: LD_ADDR_EXP 8
10046: PUSH
10047: LD_INT 1
10049: ST_TO_ADDR
// end ; 2 :
10050: GO 10215
10052: LD_INT 2
10054: DOUBLE
10055: EQUAL
10056: IFTRUE 10060
10058: GO 10182
10060: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10061: LD_EXP 20
10065: PPUSH
10066: LD_STRING D3Fb-JMM-1
10068: PPUSH
10069: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10073: LD_EXP 32
10077: PPUSH
10078: LD_STRING D3Fb-Frank-1
10080: PPUSH
10081: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10085: LD_STRING QFrank2
10087: PPUSH
10088: CALL_OW 97
10092: PUSH
10093: LD_INT 1
10095: DOUBLE
10096: EQUAL
10097: IFTRUE 10101
10099: GO 10148
10101: POP
// begin us_scout := 2 ;
10102: LD_ADDR_EXP 8
10106: PUSH
10107: LD_INT 2
10109: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10110: LD_EXP 20
10114: PPUSH
10115: LD_STRING D3Fba-JMM-1
10117: PPUSH
10118: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10122: LD_EXP 32
10126: PPUSH
10127: LD_STRING D3Fba-Frank-1
10129: PPUSH
10130: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10134: LD_EXP 20
10138: PPUSH
10139: LD_STRING D3Fba-JMM-2
10141: PPUSH
10142: CALL_OW 88
// end ; 2 :
10146: GO 10180
10148: LD_INT 2
10150: DOUBLE
10151: EQUAL
10152: IFTRUE 10156
10154: GO 10179
10156: POP
// begin us_scout := 0 ;
10157: LD_ADDR_EXP 8
10161: PUSH
10162: LD_INT 0
10164: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10165: LD_EXP 20
10169: PPUSH
10170: LD_STRING D3Fbb-JMM-1
10172: PPUSH
10173: CALL_OW 88
// end ; end ;
10177: GO 10180
10179: POP
// end ; 3 :
10180: GO 10215
10182: LD_INT 3
10184: DOUBLE
10185: EQUAL
10186: IFTRUE 10190
10188: GO 10214
10190: POP
// begin us_scout := - 1 ;
10191: LD_ADDR_EXP 8
10195: PUSH
10196: LD_INT 1
10198: NEG
10199: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10200: LD_EXP 20
10204: PPUSH
10205: LD_STRING D3Fc-JMM-1
10207: PPUSH
10208: CALL_OW 88
// end ; end ;
10212: GO 10215
10214: POP
// DialogueOff ;
10215: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10219: LD_EXP 8
10223: PUSH
10224: LD_INT 1
10226: NEG
10227: PUSH
10228: LD_INT 0
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: IN
10235: IFFALSE 10239
// exit ;
10237: GO 11886
// if us_scout in [ 1 , 2 ] then
10239: LD_EXP 8
10243: PUSH
10244: LD_INT 1
10246: PUSH
10247: LD_INT 2
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: IN
10254: IFFALSE 10953
// begin if IsInUnit ( Frank ) then
10256: LD_EXP 32
10260: PPUSH
10261: CALL_OW 310
10265: IFFALSE 10276
// ComExitBuilding ( Frank ) ;
10267: LD_EXP 32
10271: PPUSH
10272: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10276: LD_EXP 32
10280: PPUSH
10281: CALL_OW 311
10285: IFFALSE 10296
// ComExitVehicle ( Frank ) ;
10287: LD_EXP 32
10291: PPUSH
10292: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10296: LD_EXP 32
10300: PPUSH
10301: LD_INT 4
10303: PPUSH
10304: CALL_OW 235
// wait ( 0 0$1 ) ;
10308: LD_INT 35
10310: PPUSH
10311: CALL_OW 67
// if us_scout = 2 then
10315: LD_EXP 8
10319: PUSH
10320: LD_INT 2
10322: EQUAL
10323: IFFALSE 10691
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10325: LD_EXP 32
10329: PPUSH
10330: LD_INT 75
10332: PPUSH
10333: LD_INT 63
10335: PPUSH
10336: CALL_OW 111
// AddComHold ( Frank ) ;
10340: LD_EXP 32
10344: PPUSH
10345: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10349: LD_EXP 32
10353: PPUSH
10354: LD_INT 770
10356: PPUSH
10357: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10361: LD_EXP 32
10365: PPUSH
10366: LD_INT 100
10368: PPUSH
10369: LD_INT 75
10371: PPUSH
10372: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10376: LD_EXP 32
10380: PPUSH
10381: LD_INT 123
10383: PPUSH
10384: LD_INT 103
10386: PPUSH
10387: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10391: LD_EXP 32
10395: PPUSH
10396: LD_INT 138
10398: PPUSH
10399: LD_INT 108
10401: PPUSH
10402: CALL_OW 171
// AddComHold ( Frank ) ;
10406: LD_EXP 32
10410: PPUSH
10411: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10415: LD_INT 35
10417: PPUSH
10418: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10422: LD_EXP 32
10426: PPUSH
10427: LD_INT 138
10429: PPUSH
10430: LD_INT 108
10432: PPUSH
10433: CALL_OW 307
10437: IFFALSE 10415
// AddComMoveXY ( Frank , 125 , 132 ) ;
10439: LD_EXP 32
10443: PPUSH
10444: LD_INT 125
10446: PPUSH
10447: LD_INT 132
10449: PPUSH
10450: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10461: LD_INT 1
10463: PPUSH
10464: LD_EXP 32
10468: PPUSH
10469: CALL_OW 292
10473: PUSH
10474: LD_EXP 32
10478: PPUSH
10479: LD_INT 7
10481: PPUSH
10482: CALL_OW 296
10486: PUSH
10487: LD_INT 7
10489: LESS
10490: OR
10491: IFFALSE 10454
// DialogueOn ;
10493: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10497: LD_EXP 32
10501: PPUSH
10502: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10506: LD_INT 10
10508: PPUSH
10509: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10513: LD_EXP 20
10517: PPUSH
10518: LD_STRING D4Fa-JMM-1
10520: PPUSH
10521: CALL_OW 88
// for i in points do
10525: LD_ADDR_VAR 0 1
10529: PUSH
10530: LD_VAR 0 2
10534: PUSH
10535: FOR_IN
10536: IFFALSE 10594
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10538: LD_VAR 0 1
10542: PUSH
10543: LD_INT 1
10545: ARRAY
10546: PPUSH
10547: LD_VAR 0 1
10551: PUSH
10552: LD_INT 2
10554: ARRAY
10555: PPUSH
10556: LD_INT 1
10558: PPUSH
10559: LD_INT 20
10561: NEG
10562: PPUSH
10563: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10567: LD_VAR 0 1
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: PPUSH
10576: LD_VAR 0 1
10580: PUSH
10581: LD_INT 2
10583: ARRAY
10584: PPUSH
10585: LD_INT 1
10587: PPUSH
10588: CALL_OW 331
// end ;
10592: GO 10535
10594: POP
10595: POP
// dwait ( 0 0$0.5 ) ;
10596: LD_INT 18
10598: PPUSH
10599: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10603: LD_INT 42
10605: PPUSH
10606: LD_INT 27
10608: PPUSH
10609: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10613: LD_EXP 32
10617: PPUSH
10618: LD_STRING D4Fa-Frank-1
10620: PPUSH
10621: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10625: LD_INT 18
10627: PPUSH
10628: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10632: LD_EXP 20
10636: PPUSH
10637: LD_STRING D4Fa-JMM-2
10639: PPUSH
10640: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10644: LD_INT 118
10646: PPUSH
10647: LD_INT 80
10649: PPUSH
10650: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10654: LD_EXP 32
10658: PPUSH
10659: LD_STRING D4Fa-Frank-2
10661: PPUSH
10662: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10666: LD_INT 10
10668: PPUSH
10669: CALL_OW 68
// DialogueOff ;
10673: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10677: LD_EXP 32
10681: PPUSH
10682: LD_INT 1
10684: PPUSH
10685: CALL_OW 235
// end else
10689: GO 10953
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10691: LD_INT 2
10693: PPUSH
10694: LD_INT 4
10696: PPUSH
10697: LD_INT 2
10699: PPUSH
10700: LD_INT 1
10702: PPUSH
10703: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10707: LD_EXP 32
10711: PPUSH
10712: LD_INT 75
10714: PPUSH
10715: LD_INT 63
10717: PPUSH
10718: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10722: LD_EXP 32
10726: PPUSH
10727: LD_INT 175
10729: PPUSH
10730: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10734: LD_EXP 32
10738: PPUSH
10739: LD_INT 102
10741: PPUSH
10742: LD_INT 76
10744: PPUSH
10745: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10749: LD_EXP 32
10753: PPUSH
10754: LD_INT 108
10756: PPUSH
10757: LD_INT 70
10759: PPUSH
10760: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10764: LD_INT 35
10766: PPUSH
10767: CALL_OW 67
// until See ( 2 , Frank ) ;
10771: LD_INT 2
10773: PPUSH
10774: LD_EXP 32
10778: PPUSH
10779: CALL_OW 292
10783: IFFALSE 10764
// ComMoveXY ( Frank , 112 , 118 ) ;
10785: LD_EXP 32
10789: PPUSH
10790: LD_INT 112
10792: PPUSH
10793: LD_INT 118
10795: PPUSH
10796: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
10800: LD_EXP 32
10804: PPUSH
10805: CALL_OW 256
10809: PUSH
10810: LD_INT 750
10812: GREATEREQUAL
10813: IFFALSE 10827
// SetLives ( Frank , 700 ) ;
10815: LD_EXP 32
10819: PPUSH
10820: LD_INT 700
10822: PPUSH
10823: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
10827: LD_INT 35
10829: PPUSH
10830: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
10834: LD_INT 1
10836: PPUSH
10837: LD_EXP 32
10841: PPUSH
10842: CALL_OW 292
10846: PUSH
10847: LD_EXP 32
10851: PPUSH
10852: LD_INT 7
10854: PPUSH
10855: CALL_OW 296
10859: PUSH
10860: LD_INT 17
10862: LESS
10863: OR
10864: IFFALSE 10827
// DialogueOn ;
10866: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10870: LD_EXP 32
10874: PPUSH
10875: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
10879: LD_EXP 32
10883: PPUSH
10884: LD_STRING D4Fb-Frank-1
10886: PPUSH
10887: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
10891: LD_EXP 20
10895: PPUSH
10896: LD_STRING D4Fb-JMM-1
10898: PPUSH
10899: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
10903: LD_INT 2
10905: PPUSH
10906: LD_STRING D4Fb-FSci1-1
10908: PPUSH
10909: CALL 15534 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
10913: LD_EXP 32
10917: PPUSH
10918: LD_STRING D4Fb-Frank-2
10920: PPUSH
10921: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
10925: LD_EXP 20
10929: PPUSH
10930: LD_STRING D4Fb-JMM-2
10932: PPUSH
10933: CALL_OW 88
// DialogueOff ;
10937: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10941: LD_EXP 32
10945: PPUSH
10946: LD_INT 1
10948: PPUSH
10949: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
10953: LD_EXP 33
10957: PPUSH
10958: CALL_OW 302
10962: PUSH
10963: LD_EXP 32
10967: NOT
10968: AND
10969: IFFALSE 11117
// begin DialogueOn ;
10971: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
10975: LD_EXP 20
10979: PUSH
10980: LD_EXP 33
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: PPUSH
10989: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
10993: LD_EXP 33
10997: PPUSH
10998: LD_STRING D3Y-Yam-1
11000: PPUSH
11001: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11005: LD_EXP 20
11009: PPUSH
11010: LD_STRING D3Y-JMM-1
11012: PPUSH
11013: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11017: LD_EXP 33
11021: PPUSH
11022: LD_STRING D3Y-Yam-2
11024: PPUSH
11025: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11029: LD_STRING QYamoko
11031: PPUSH
11032: CALL_OW 97
11036: PUSH
11037: LD_INT 1
11039: DOUBLE
11040: EQUAL
11041: IFTRUE 11045
11043: GO 11080
11045: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11046: LD_EXP 20
11050: PPUSH
11051: LD_STRING D3Ya-JMM-1
11053: PPUSH
11054: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11058: LD_EXP 33
11062: PPUSH
11063: LD_STRING D3Ya-Yam-1
11065: PPUSH
11066: CALL_OW 88
// us_scout := 1 ;
11070: LD_ADDR_EXP 8
11074: PUSH
11075: LD_INT 1
11077: ST_TO_ADDR
// end ; 2 :
11078: GO 11113
11080: LD_INT 2
11082: DOUBLE
11083: EQUAL
11084: IFTRUE 11088
11086: GO 11112
11088: POP
// begin us_scout := - 1 ;
11089: LD_ADDR_EXP 8
11093: PUSH
11094: LD_INT 1
11096: NEG
11097: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11098: LD_EXP 20
11102: PPUSH
11103: LD_STRING D3Yb-JMM-1
11105: PPUSH
11106: CALL_OW 88
// end ; end ;
11110: GO 11113
11112: POP
// DialogueOff ;
11113: CALL_OW 7
// end ; if Frank then
11117: LD_EXP 32
11121: IFFALSE 11125
// exit ;
11123: GO 11886
// if us_scout in [ - 1 , 0 ] then
11125: LD_EXP 8
11129: PUSH
11130: LD_INT 1
11132: NEG
11133: PUSH
11134: LD_INT 0
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: IN
11141: IFFALSE 11145
// exit ;
11143: GO 11886
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 2
11152: PUSH
11153: LD_INT 2
11155: PUSH
11156: LD_INT 1
11158: PUSH
11159: EMPTY
11160: LIST
11161: LIST
11162: LIST
11163: PUSH
11164: LD_OWVAR 67
11168: ARRAY
11169: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11170: LD_EXP 8
11174: PUSH
11175: LD_INT 1
11177: PUSH
11178: LD_INT 2
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: IN
11185: IFFALSE 11886
// begin if IsInUnit ( Kikuchi ) then
11187: LD_EXP 33
11191: PPUSH
11192: CALL_OW 310
11196: IFFALSE 11207
// ComExitBuilding ( Kikuchi ) ;
11198: LD_EXP 33
11202: PPUSH
11203: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11207: LD_EXP 33
11211: PPUSH
11212: CALL_OW 311
11216: IFFALSE 11227
// ComExitVehicle ( Kikuchi ) ;
11218: LD_EXP 33
11222: PPUSH
11223: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11227: LD_EXP 33
11231: PPUSH
11232: LD_INT 4
11234: PPUSH
11235: CALL_OW 235
// wait ( 0 0$1 ) ;
11239: LD_INT 35
11241: PPUSH
11242: CALL_OW 67
// if us_scout = 2 then
11246: LD_EXP 8
11250: PUSH
11251: LD_INT 2
11253: EQUAL
11254: IFFALSE 11634
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11256: LD_EXP 33
11260: PPUSH
11261: LD_INT 75
11263: PPUSH
11264: LD_INT 63
11266: PPUSH
11267: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11271: LD_EXP 33
11275: PPUSH
11276: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11280: LD_EXP 33
11284: PPUSH
11285: LD_INT 770
11287: PPUSH
11288: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11292: LD_EXP 33
11296: PPUSH
11297: LD_INT 100
11299: PPUSH
11300: LD_INT 75
11302: PPUSH
11303: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11307: LD_EXP 33
11311: PPUSH
11312: LD_INT 123
11314: PPUSH
11315: LD_INT 103
11317: PPUSH
11318: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11322: LD_EXP 33
11326: PPUSH
11327: LD_INT 138
11329: PPUSH
11330: LD_INT 108
11332: PPUSH
11333: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11337: LD_EXP 33
11341: PPUSH
11342: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11346: LD_INT 35
11348: PPUSH
11349: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11353: LD_EXP 33
11357: PPUSH
11358: LD_INT 138
11360: PPUSH
11361: LD_INT 108
11363: PPUSH
11364: CALL_OW 307
11368: IFFALSE 11346
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11370: LD_EXP 33
11374: PPUSH
11375: LD_INT 125
11377: PPUSH
11378: LD_INT 132
11380: PPUSH
11381: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11385: LD_INT 35
11387: PPUSH
11388: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11392: LD_INT 1
11394: PPUSH
11395: LD_EXP 33
11399: PPUSH
11400: CALL_OW 292
11404: PUSH
11405: LD_EXP 33
11409: PPUSH
11410: LD_INT 7
11412: PPUSH
11413: CALL_OW 296
11417: PUSH
11418: LD_INT 7
11420: LESS
11421: OR
11422: IFFALSE 11385
// DialogueOn ;
11424: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11428: LD_EXP 33
11432: PPUSH
11433: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11437: LD_INT 10
11439: PPUSH
11440: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_STRING D4Ya-Yam-1
11451: PPUSH
11452: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11456: LD_EXP 20
11460: PPUSH
11461: LD_STRING D4Ya-JMM-1
11463: PPUSH
11464: CALL_OW 88
// for i in points do
11468: LD_ADDR_VAR 0 1
11472: PUSH
11473: LD_VAR 0 2
11477: PUSH
11478: FOR_IN
11479: IFFALSE 11537
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11481: LD_VAR 0 1
11485: PUSH
11486: LD_INT 1
11488: ARRAY
11489: PPUSH
11490: LD_VAR 0 1
11494: PUSH
11495: LD_INT 2
11497: ARRAY
11498: PPUSH
11499: LD_INT 1
11501: PPUSH
11502: LD_INT 20
11504: NEG
11505: PPUSH
11506: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11510: LD_VAR 0 1
11514: PUSH
11515: LD_INT 1
11517: ARRAY
11518: PPUSH
11519: LD_VAR 0 1
11523: PUSH
11524: LD_INT 2
11526: ARRAY
11527: PPUSH
11528: LD_INT 1
11530: PPUSH
11531: CALL_OW 331
// end ;
11535: GO 11478
11537: POP
11538: POP
// dwait ( 0 0$0.5 ) ;
11539: LD_INT 18
11541: PPUSH
11542: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11546: LD_INT 42
11548: PPUSH
11549: LD_INT 27
11551: PPUSH
11552: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11556: LD_EXP 33
11560: PPUSH
11561: LD_STRING D4Ya-Yam-2
11563: PPUSH
11564: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11568: LD_INT 18
11570: PPUSH
11571: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11575: LD_INT 118
11577: PPUSH
11578: LD_INT 80
11580: PPUSH
11581: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11585: LD_EXP 20
11589: PPUSH
11590: LD_STRING D4Ya-JMM-2
11592: PPUSH
11593: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11597: LD_EXP 33
11601: PPUSH
11602: LD_STRING D4Ya-Yam-3
11604: PPUSH
11605: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11609: LD_INT 10
11611: PPUSH
11612: CALL_OW 68
// DialogueOff ;
11616: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11620: LD_EXP 33
11624: PPUSH
11625: LD_INT 1
11627: PPUSH
11628: CALL_OW 235
// end else
11632: GO 11886
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11634: LD_INT 2
11636: PPUSH
11637: LD_INT 4
11639: PPUSH
11640: LD_INT 2
11642: PPUSH
11643: LD_INT 1
11645: PPUSH
11646: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11650: LD_EXP 33
11654: PPUSH
11655: LD_INT 75
11657: PPUSH
11658: LD_INT 63
11660: PPUSH
11661: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11665: LD_EXP 33
11669: PPUSH
11670: LD_INT 175
11672: PPUSH
11673: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11677: LD_EXP 33
11681: PPUSH
11682: LD_INT 102
11684: PPUSH
11685: LD_INT 76
11687: PPUSH
11688: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11692: LD_EXP 33
11696: PPUSH
11697: LD_INT 108
11699: PPUSH
11700: LD_INT 70
11702: PPUSH
11703: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11707: LD_INT 35
11709: PPUSH
11710: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11714: LD_INT 2
11716: PPUSH
11717: LD_EXP 33
11721: PPUSH
11722: CALL_OW 292
11726: IFFALSE 11707
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11728: LD_EXP 33
11732: PPUSH
11733: LD_INT 112
11735: PPUSH
11736: LD_INT 118
11738: PPUSH
11739: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11743: LD_EXP 33
11747: PPUSH
11748: CALL_OW 256
11752: PUSH
11753: LD_INT 750
11755: GREATEREQUAL
11756: IFFALSE 11770
// SetLives ( Kikuchi , 700 ) ;
11758: LD_EXP 33
11762: PPUSH
11763: LD_INT 700
11765: PPUSH
11766: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11770: LD_INT 35
11772: PPUSH
11773: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11777: LD_INT 1
11779: PPUSH
11780: LD_EXP 33
11784: PPUSH
11785: CALL_OW 292
11789: PUSH
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 7
11797: PPUSH
11798: CALL_OW 296
11802: PUSH
11803: LD_INT 17
11805: LESS
11806: OR
11807: IFFALSE 11770
// DialogueOn ;
11809: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11813: LD_EXP 33
11817: PPUSH
11818: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
11822: LD_EXP 33
11826: PPUSH
11827: LD_STRING D4Yb-Yam-1
11829: PPUSH
11830: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
11834: LD_EXP 20
11838: PPUSH
11839: LD_STRING D4Yb-JMM-1
11841: PPUSH
11842: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
11846: LD_EXP 33
11850: PPUSH
11851: LD_STRING D4Yb-Yam-2
11853: PPUSH
11854: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
11858: LD_EXP 20
11862: PPUSH
11863: LD_STRING D4Yb-JMM-2
11865: PPUSH
11866: CALL_OW 88
// DialogueOff ;
11870: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11874: LD_EXP 33
11878: PPUSH
11879: LD_INT 1
11881: PPUSH
11882: CALL_OW 235
// end ; end ; end ;
11886: PPOPN 2
11888: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
11889: LD_EXP 6
11893: IFFALSE 12926
11895: GO 11897
11897: DISABLE
11898: LD_INT 0
11900: PPUSH
11901: PPUSH
11902: PPUSH
11903: PPUSH
// begin enable ;
11904: ENABLE
// if not seen [ 1 ] then
11905: LD_EXP 9
11909: PUSH
11910: LD_INT 1
11912: ARRAY
11913: NOT
11914: IFFALSE 12094
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
11916: LD_ADDR_VAR 0 2
11920: PUSH
11921: LD_INT 22
11923: PUSH
11924: LD_INT 2
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: PUSH
11931: LD_INT 2
11933: PUSH
11934: LD_INT 25
11936: PUSH
11937: LD_INT 11
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PUSH
11944: LD_INT 33
11946: PUSH
11947: LD_INT 4
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: LIST
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: PPUSH
11963: CALL_OW 69
11967: ST_TO_ADDR
// if tmp then
11968: LD_VAR 0 2
11972: IFFALSE 12094
// for i in tmp do
11974: LD_ADDR_VAR 0 1
11978: PUSH
11979: LD_VAR 0 2
11983: PUSH
11984: FOR_IN
11985: IFFALSE 12092
// if See ( 1 , i ) then
11987: LD_INT 1
11989: PPUSH
11990: LD_VAR 0 1
11994: PPUSH
11995: CALL_OW 292
11999: IFFALSE 12090
// begin seen := Replace ( seen , 1 , true ) ;
12001: LD_ADDR_EXP 9
12005: PUSH
12006: LD_EXP 9
12010: PPUSH
12011: LD_INT 1
12013: PPUSH
12014: LD_INT 1
12016: PPUSH
12017: CALL_OW 1
12021: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12022: LD_INT 1
12024: PPUSH
12025: CALL 15356 0 1
12029: IFFALSE 12090
// begin DialogueOn ;
12031: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12035: LD_VAR 0 1
12039: PPUSH
12040: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12044: LD_INT 10
12046: PPUSH
12047: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12051: LD_ADDR_VAR 0 3
12055: PUSH
12056: LD_INT 1
12058: PPUSH
12059: LD_STRING D5a-Sol2-1
12061: PPUSH
12062: CALL 15534 0 2
12066: ST_TO_ADDR
// if not un then
12067: LD_VAR 0 3
12071: NOT
12072: IFFALSE 12084
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12074: LD_INT 2
12076: PPUSH
12077: LD_STRING D5a-FSol2-1
12079: PPUSH
12080: CALL 15534 0 2
// DialogueOff ;
12084: CALL_OW 7
// break ;
12088: GO 12092
// end ; end ;
12090: GO 11984
12092: POP
12093: POP
// end ; if not seen [ 2 ] then
12094: LD_EXP 9
12098: PUSH
12099: LD_INT 2
12101: ARRAY
12102: NOT
12103: IFFALSE 12328
// begin can_kamikazed := true ;
12105: LD_ADDR_EXP 10
12109: PUSH
12110: LD_INT 1
12112: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12113: LD_ADDR_VAR 0 2
12117: PUSH
12118: LD_INT 22
12120: PUSH
12121: LD_INT 2
12123: PUSH
12124: EMPTY
12125: LIST
12126: LIST
12127: PUSH
12128: LD_INT 25
12130: PUSH
12131: LD_INT 17
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PUSH
12138: EMPTY
12139: LIST
12140: LIST
12141: PPUSH
12142: CALL_OW 69
12146: ST_TO_ADDR
// if tmp then
12147: LD_VAR 0 2
12151: IFFALSE 12328
// for i in tmp do
12153: LD_ADDR_VAR 0 1
12157: PUSH
12158: LD_VAR 0 2
12162: PUSH
12163: FOR_IN
12164: IFFALSE 12326
// if See ( 1 , i ) then
12166: LD_INT 1
12168: PPUSH
12169: LD_VAR 0 1
12173: PPUSH
12174: CALL_OW 292
12178: IFFALSE 12324
// begin seen := Replace ( seen , 2 , true ) ;
12180: LD_ADDR_EXP 9
12184: PUSH
12185: LD_EXP 9
12189: PPUSH
12190: LD_INT 2
12192: PPUSH
12193: LD_INT 1
12195: PPUSH
12196: CALL_OW 1
12200: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12201: LD_INT 1
12203: PPUSH
12204: CALL 15356 0 1
12208: IFFALSE 12324
// begin DialogueOn ;
12210: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12214: LD_VAR 0 1
12218: PPUSH
12219: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12223: LD_INT 10
12225: PPUSH
12226: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12230: LD_ADDR_VAR 0 3
12234: PUSH
12235: LD_INT 1
12237: PPUSH
12238: LD_STRING D5b-Sol1-1
12240: PPUSH
12241: CALL 15534 0 2
12245: ST_TO_ADDR
// if not un then
12246: LD_VAR 0 3
12250: NOT
12251: IFFALSE 12269
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12253: LD_ADDR_VAR 0 3
12257: PUSH
12258: LD_INT 2
12260: PPUSH
12261: LD_STRING D5b-FSol1-1
12263: PPUSH
12264: CALL 15534 0 2
12268: ST_TO_ADDR
// if un then
12269: LD_VAR 0 3
12273: IFFALSE 12318
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12275: LD_ADDR_VAR 0 4
12279: PUSH
12280: LD_INT 1
12282: PPUSH
12283: LD_STRING D5b-Sol2-1
12285: PPUSH
12286: LD_VAR 0 3
12290: PPUSH
12291: CALL 15760 0 3
12295: ST_TO_ADDR
// if not un2 then
12296: LD_VAR 0 4
12300: NOT
12301: IFFALSE 12318
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12303: LD_INT 2
12305: PPUSH
12306: LD_STRING D5b-FSol2-1
12308: PPUSH
12309: LD_VAR 0 3
12313: PPUSH
12314: CALL 15760 0 3
// end ; DialogueOff ;
12318: CALL_OW 7
// break ;
12322: GO 12326
// end ; end ;
12324: GO 12163
12326: POP
12327: POP
// end ; if not seen [ 3 ] then
12328: LD_EXP 9
12332: PUSH
12333: LD_INT 3
12335: ARRAY
12336: NOT
12337: IFFALSE 12511
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12339: LD_ADDR_VAR 0 2
12343: PUSH
12344: LD_INT 22
12346: PUSH
12347: LD_INT 2
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 33
12356: PUSH
12357: LD_INT 2
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PPUSH
12368: CALL_OW 69
12372: ST_TO_ADDR
// if tmp then
12373: LD_VAR 0 2
12377: IFFALSE 12511
// for i in tmp do
12379: LD_ADDR_VAR 0 1
12383: PUSH
12384: LD_VAR 0 2
12388: PUSH
12389: FOR_IN
12390: IFFALSE 12509
// if See ( 1 , i ) then
12392: LD_INT 1
12394: PPUSH
12395: LD_VAR 0 1
12399: PPUSH
12400: CALL_OW 292
12404: IFFALSE 12507
// begin seen := Replace ( seen , 3 , true ) ;
12406: LD_ADDR_EXP 9
12410: PUSH
12411: LD_EXP 9
12415: PPUSH
12416: LD_INT 3
12418: PPUSH
12419: LD_INT 1
12421: PPUSH
12422: CALL_OW 1
12426: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12427: LD_INT 1
12429: PPUSH
12430: CALL 15356 0 1
12434: IFFALSE 12507
// begin DialogueOn ;
12436: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12440: LD_VAR 0 1
12444: PPUSH
12445: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12449: LD_INT 10
12451: PPUSH
12452: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12456: LD_ADDR_VAR 0 3
12460: PUSH
12461: LD_INT 1
12463: PPUSH
12464: LD_STRING D8-Sol1-1
12466: PPUSH
12467: CALL 15534 0 2
12471: ST_TO_ADDR
// if not un then
12472: LD_VAR 0 3
12476: NOT
12477: IFFALSE 12489
// SayRand ( sex_female , D8-FSol1-1 ) ;
12479: LD_INT 2
12481: PPUSH
12482: LD_STRING D8-FSol1-1
12484: PPUSH
12485: CALL 15534 0 2
// Say ( JMM , D8-JMM-1 ) ;
12489: LD_EXP 20
12493: PPUSH
12494: LD_STRING D8-JMM-1
12496: PPUSH
12497: CALL_OW 88
// DialogueOff ;
12501: CALL_OW 7
// break ;
12505: GO 12509
// end ; end ;
12507: GO 12389
12509: POP
12510: POP
// end ; if not seen [ 4 ] then
12511: LD_EXP 9
12515: PUSH
12516: LD_INT 4
12518: ARRAY
12519: NOT
12520: IFFALSE 12682
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12522: LD_ADDR_VAR 0 2
12526: PUSH
12527: LD_INT 22
12529: PUSH
12530: LD_INT 2
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PUSH
12537: LD_INT 33
12539: PUSH
12540: LD_INT 5
12542: PUSH
12543: EMPTY
12544: LIST
12545: LIST
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PPUSH
12551: CALL_OW 69
12555: ST_TO_ADDR
// if tmp then
12556: LD_VAR 0 2
12560: IFFALSE 12682
// for i in tmp do
12562: LD_ADDR_VAR 0 1
12566: PUSH
12567: LD_VAR 0 2
12571: PUSH
12572: FOR_IN
12573: IFFALSE 12680
// if See ( 1 , i ) then
12575: LD_INT 1
12577: PPUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 292
12587: IFFALSE 12678
// begin seen := Replace ( seen , 4 , true ) ;
12589: LD_ADDR_EXP 9
12593: PUSH
12594: LD_EXP 9
12598: PPUSH
12599: LD_INT 4
12601: PPUSH
12602: LD_INT 1
12604: PPUSH
12605: CALL_OW 1
12609: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12610: LD_INT 1
12612: PPUSH
12613: CALL 15356 0 1
12617: IFFALSE 12678
// begin DialogueOn ;
12619: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12623: LD_VAR 0 1
12627: PPUSH
12628: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12632: LD_INT 10
12634: PPUSH
12635: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12639: LD_ADDR_VAR 0 3
12643: PUSH
12644: LD_INT 1
12646: PPUSH
12647: LD_STRING D5a-Sol1-1
12649: PPUSH
12650: CALL 15534 0 2
12654: ST_TO_ADDR
// if not un then
12655: LD_VAR 0 3
12659: NOT
12660: IFFALSE 12672
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12662: LD_INT 2
12664: PPUSH
12665: LD_STRING D5a-FSol1-1
12667: PPUSH
12668: CALL 15534 0 2
// DialogueOff ;
12672: CALL_OW 7
// break ;
12676: GO 12680
// end ; end ;
12678: GO 12572
12680: POP
12681: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12682: LD_EXP 9
12686: PUSH
12687: LD_INT 5
12689: ARRAY
12690: NOT
12691: PUSH
12692: LD_EXP 9
12696: PUSH
12697: LD_INT 3
12699: ARRAY
12700: AND
12701: IFFALSE 12875
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12703: LD_ADDR_VAR 0 2
12707: PUSH
12708: LD_INT 22
12710: PUSH
12711: LD_INT 2
12713: PUSH
12714: EMPTY
12715: LIST
12716: LIST
12717: PUSH
12718: LD_INT 34
12720: PUSH
12721: LD_INT 31
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PPUSH
12732: CALL_OW 69
12736: ST_TO_ADDR
// if tmp then
12737: LD_VAR 0 2
12741: IFFALSE 12875
// for i in tmp do
12743: LD_ADDR_VAR 0 1
12747: PUSH
12748: LD_VAR 0 2
12752: PUSH
12753: FOR_IN
12754: IFFALSE 12873
// if See ( 1 , i ) then
12756: LD_INT 1
12758: PPUSH
12759: LD_VAR 0 1
12763: PPUSH
12764: CALL_OW 292
12768: IFFALSE 12871
// begin seen := Replace ( seen , 5 , true ) ;
12770: LD_ADDR_EXP 9
12774: PUSH
12775: LD_EXP 9
12779: PPUSH
12780: LD_INT 5
12782: PPUSH
12783: LD_INT 1
12785: PPUSH
12786: CALL_OW 1
12790: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12791: LD_INT 1
12793: PPUSH
12794: CALL 15356 0 1
12798: IFFALSE 12871
// begin DialogueOn ;
12800: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12813: LD_INT 10
12815: PPUSH
12816: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
12820: LD_ADDR_VAR 0 3
12824: PUSH
12825: LD_INT 1
12827: PPUSH
12828: LD_STRING D8a-Sol2-1
12830: PPUSH
12831: CALL 15534 0 2
12835: ST_TO_ADDR
// if not un then
12836: LD_VAR 0 3
12840: NOT
12841: IFFALSE 12853
// SayRand ( sex_female , D8a-FSol2-1 ) ;
12843: LD_INT 2
12845: PPUSH
12846: LD_STRING D8a-FSol2-1
12848: PPUSH
12849: CALL 15534 0 2
// Say ( JMM , D8a-JMM-1 ) ;
12853: LD_EXP 20
12857: PPUSH
12858: LD_STRING D8a-JMM-1
12860: PPUSH
12861: CALL_OW 88
// DialogueOff ;
12865: CALL_OW 7
// break ;
12869: GO 12873
// end ; end ;
12871: GO 12753
12873: POP
12874: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
12875: LD_EXP 9
12879: PUSH
12880: LD_INT 1
12882: ARRAY
12883: PUSH
12884: LD_EXP 9
12888: PUSH
12889: LD_INT 2
12891: ARRAY
12892: AND
12893: PUSH
12894: LD_EXP 9
12898: PUSH
12899: LD_INT 3
12901: ARRAY
12902: AND
12903: PUSH
12904: LD_EXP 9
12908: PUSH
12909: LD_INT 4
12911: ARRAY
12912: AND
12913: PUSH
12914: LD_EXP 9
12918: PUSH
12919: LD_INT 5
12921: ARRAY
12922: AND
12923: IFFALSE 12926
// disable ;
12925: DISABLE
// end ;
12926: PPOPN 4
12928: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
12929: LD_EXP 10
12933: PUSH
12934: LD_EXP 11
12938: AND
12939: IFFALSE 13137
12941: GO 12943
12943: DISABLE
12944: LD_INT 0
12946: PPUSH
// begin DialogueOn ;
12947: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
12951: LD_EXP 11
12955: PPUSH
12956: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
12960: LD_ADDR_VAR 0 1
12964: PUSH
12965: LD_INT 1
12967: PPUSH
12968: LD_STRING D5c-Sol1-1
12970: PPUSH
12971: CALL 15534 0 2
12975: ST_TO_ADDR
// if not un then
12976: LD_VAR 0 1
12980: NOT
12981: IFFALSE 12999
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
12983: LD_ADDR_VAR 0 1
12987: PUSH
12988: LD_INT 2
12990: PPUSH
12991: LD_STRING D5c-FSol1-1
12993: PPUSH
12994: CALL 15534 0 2
12998: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
12999: LD_EXP 20
13003: PPUSH
13004: LD_STRING D5c-JMM-1
13006: PPUSH
13007: CALL_OW 88
// if IsOk ( Lisa ) then
13011: LD_EXP 21
13015: PPUSH
13016: CALL_OW 302
13020: IFFALSE 13036
// Say ( Lisa , D5d-Lisa-1 ) else
13022: LD_EXP 21
13026: PPUSH
13027: LD_STRING D5d-Lisa-1
13029: PPUSH
13030: CALL_OW 88
13034: GO 13121
// if IsOk ( Cyrus ) then
13036: LD_EXP 24
13040: PPUSH
13041: CALL_OW 302
13045: IFFALSE 13061
// Say ( Cyrus , D5d-Cyrus-1 ) else
13047: LD_EXP 24
13051: PPUSH
13052: LD_STRING D5d-Cyrus-1
13054: PPUSH
13055: CALL_OW 88
13059: GO 13121
// if IsOk ( Gary ) then
13061: LD_EXP 31
13065: PPUSH
13066: CALL_OW 302
13070: IFFALSE 13086
// Say ( Gary , D5d-Gary-1 ) else
13072: LD_EXP 31
13076: PPUSH
13077: LD_STRING D5d-Gary-1
13079: PPUSH
13080: CALL_OW 88
13084: GO 13121
// if GetSex ( un ) = sex_male then
13086: LD_VAR 0 1
13090: PPUSH
13091: CALL_OW 258
13095: PUSH
13096: LD_INT 1
13098: EQUAL
13099: IFFALSE 13115
// Say ( un , D5d-Sol1-1 ) else
13101: LD_VAR 0 1
13105: PPUSH
13106: LD_STRING D5d-Sol1-1
13108: PPUSH
13109: CALL_OW 88
13113: GO 13121
// begin DialogueOff ;
13115: CALL_OW 7
// exit ;
13119: GO 13137
// end ; Say ( JMM , D5d-JMM-1 ) ;
13121: LD_EXP 20
13125: PPUSH
13126: LD_STRING D5d-JMM-1
13128: PPUSH
13129: CALL_OW 88
// DialogueOff ;
13133: CALL_OW 7
// end ;
13137: PPOPN 1
13139: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13140: LD_INT 1
13142: PPUSH
13143: LD_INT 17
13145: PPUSH
13146: CALL_OW 294
13150: PUSH
13151: LD_INT 2
13153: GREATEREQUAL
13154: IFFALSE 13275
13156: GO 13158
13158: DISABLE
13159: LD_INT 0
13161: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13162: LD_INT 10
13164: PPUSH
13165: LD_INT 5
13167: PPUSH
13168: LD_INT 1
13170: PPUSH
13171: LD_INT 10
13173: NEG
13174: PPUSH
13175: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13179: LD_INT 10
13181: PPUSH
13182: LD_INT 5
13184: PPUSH
13185: LD_INT 1
13187: PPUSH
13188: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13192: LD_INT 10
13194: PPUSH
13195: LD_INT 5
13197: PPUSH
13198: CALL_OW 86
// DialogueOn ;
13202: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13206: LD_ADDR_VAR 0 1
13210: PUSH
13211: LD_INT 1
13213: PPUSH
13214: LD_STRING D6-Sci1-1
13216: PPUSH
13217: CALL 15534 0 2
13221: ST_TO_ADDR
// if un then
13222: LD_VAR 0 1
13226: IFFALSE 13264
// begin Say ( JMM , D6-JMM-1 ) ;
13228: LD_EXP 20
13232: PPUSH
13233: LD_STRING D6-JMM-1
13235: PPUSH
13236: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13240: LD_VAR 0 1
13244: PPUSH
13245: LD_STRING D6-Sci1-2
13247: PPUSH
13248: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13252: LD_EXP 20
13256: PPUSH
13257: LD_STRING D6-JMM-2
13259: PPUSH
13260: CALL_OW 88
// end ; DialogueOff ;
13264: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13268: LD_STRING M3
13270: PPUSH
13271: CALL_OW 337
// end ;
13275: PPOPN 1
13277: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
13278: LD_OWVAR 1
13282: PUSH
13283: LD_INT 42000
13285: GREATEREQUAL
13286: PUSH
13287: LD_INT 2
13289: PPUSH
13290: LD_INT 169
13292: PPUSH
13293: LD_INT 90
13295: PPUSH
13296: LD_INT 10
13298: PPUSH
13299: CALL 52581 0 4
13303: PUSH
13304: LD_INT 4
13306: ARRAY
13307: PUSH
13308: LD_INT 0
13310: EQUAL
13311: PUSH
13312: LD_INT 45
13314: PPUSH
13315: CALL_OW 301
13319: OR
13320: PUSH
13321: LD_INT 45
13323: PPUSH
13324: CALL_OW 255
13328: PUSH
13329: LD_INT 1
13331: EQUAL
13332: OR
13333: AND
13334: PUSH
13335: LD_INT 94
13337: PPUSH
13338: CALL_OW 301
13342: NOT
13343: AND
13344: IFFALSE 14470
13346: GO 13348
13348: DISABLE
13349: LD_INT 0
13351: PPUSH
13352: PPUSH
13353: PPUSH
13354: PPUSH
// begin uc_side := 5 ;
13355: LD_ADDR_OWVAR 20
13359: PUSH
13360: LD_INT 5
13362: ST_TO_ADDR
// uc_nation := 2 ;
13363: LD_ADDR_OWVAR 21
13367: PUSH
13368: LD_INT 2
13370: ST_TO_ADDR
// InitHc ;
13371: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13375: LD_INT 1
13377: PPUSH
13378: LD_INT 3
13380: PPUSH
13381: LD_INT 8
13383: PPUSH
13384: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13388: LD_ADDR_OWVAR 29
13392: PUSH
13393: LD_INT 12
13395: PUSH
13396: LD_INT 12
13398: PUSH
13399: EMPTY
13400: LIST
13401: LIST
13402: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13403: LD_ADDR_OWVAR 33
13407: PUSH
13408: LD_STRING SecondCharsGal
13410: ST_TO_ADDR
// hc_face_number := 7 ;
13411: LD_ADDR_OWVAR 34
13415: PUSH
13416: LD_INT 7
13418: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13419: LD_ADDR_EXP 45
13423: PUSH
13424: CALL_OW 44
13428: ST_TO_ADDR
// InitHc ;
13429: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 16
13438: PPUSH
13439: LD_INT 2
13441: PPUSH
13442: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13446: LD_ADDR_OWVAR 29
13450: PUSH
13451: LD_INT 12
13453: PUSH
13454: LD_INT 12
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: ST_TO_ADDR
// hc_name :=  ;
13461: LD_ADDR_OWVAR 26
13465: PUSH
13466: LD_STRING 
13468: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13469: LD_ADDR_EXP 46
13473: PUSH
13474: CALL_OW 44
13478: ST_TO_ADDR
// InitHc ;
13479: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13483: LD_INT 35
13485: PPUSH
13486: CALL_OW 67
// until not InBattle ( 1 ) ;
13490: LD_INT 1
13492: PPUSH
13493: CALL_OW 463
13497: NOT
13498: IFFALSE 13483
// wait ( 0 0$5 ) ;
13500: LD_INT 175
13502: PPUSH
13503: CALL_OW 67
// DialogueOn ;
13507: CALL_OW 6
// InGameOn ;
13511: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13515: LD_ADDR_VAR 0 1
13519: PUSH
13520: LD_INT 22
13522: PUSH
13523: LD_INT 1
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: PUSH
13530: LD_INT 2
13532: PUSH
13533: LD_INT 25
13535: PUSH
13536: LD_INT 1
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: LD_INT 25
13545: PUSH
13546: LD_INT 2
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 25
13555: PUSH
13556: LD_INT 3
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: LD_INT 25
13565: PUSH
13566: LD_INT 4
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PUSH
13573: LD_INT 25
13575: PUSH
13576: LD_INT 5
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PUSH
13583: LD_INT 25
13585: PUSH
13586: LD_INT 8
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PPUSH
13606: CALL_OW 69
13610: PUSH
13611: LD_EXP 20
13615: PUSH
13616: LD_EXP 21
13620: PUSH
13621: LD_EXP 22
13625: PUSH
13626: LD_EXP 23
13630: PUSH
13631: LD_EXP 24
13635: PUSH
13636: LD_EXP 25
13640: PUSH
13641: LD_EXP 26
13645: PUSH
13646: LD_EXP 27
13650: PUSH
13651: LD_EXP 28
13655: PUSH
13656: LD_EXP 30
13660: PUSH
13661: LD_EXP 31
13665: PUSH
13666: LD_EXP 32
13670: PUSH
13671: LD_EXP 33
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: DIFF
13691: PPUSH
13692: LD_INT 26
13694: PUSH
13695: LD_INT 1
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PPUSH
13702: CALL_OW 72
13706: PUSH
13707: LD_INT 1
13709: ARRAY
13710: ST_TO_ADDR
// if not un and Brown then
13711: LD_VAR 0 1
13715: NOT
13716: PUSH
13717: LD_EXP 26
13721: AND
13722: IFFALSE 13734
// un := Brown ;
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_EXP 26
13733: ST_TO_ADDR
// if un then
13734: LD_VAR 0 1
13738: IFFALSE 13764
// begin Say ( un , D7-Sol1-1 ) ;
13740: LD_VAR 0 1
13744: PPUSH
13745: LD_STRING D7-Sol1-1
13747: PPUSH
13748: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13752: LD_EXP 20
13756: PPUSH
13757: LD_STRING D7-JMM-1
13759: PPUSH
13760: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13764: LD_EXP 45
13768: PPUSH
13769: LD_STRING D7-Ar1-1
13771: PPUSH
13772: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13776: LD_EXP 20
13780: PPUSH
13781: LD_STRING D7-JMM-2
13783: PPUSH
13784: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13788: LD_EXP 45
13792: PPUSH
13793: LD_STRING D7-Ar1-2
13795: PPUSH
13796: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13800: LD_EXP 20
13804: PPUSH
13805: LD_STRING D7-JMM-3
13807: PPUSH
13808: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
13812: LD_EXP 45
13816: PPUSH
13817: LD_STRING D7-Ar1-3
13819: PPUSH
13820: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13824: LD_EXP 20
13828: PPUSH
13829: LD_STRING D7-JMM-4
13831: PPUSH
13832: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
13836: LD_EXP 45
13840: PPUSH
13841: LD_STRING D7-Ar1-4
13843: PPUSH
13844: CALL_OW 94
// InGameOff ;
13848: CALL_OW 9
// DialogueOff ;
13852: CALL_OW 7
// case Query ( QCameras ) of 1 :
13856: LD_STRING QCameras
13858: PPUSH
13859: CALL_OW 97
13863: PUSH
13864: LD_INT 1
13866: DOUBLE
13867: EQUAL
13868: IFTRUE 13872
13870: GO 13875
13872: POP
// ; 2 :
13873: GO 13889
13875: LD_INT 2
13877: DOUBLE
13878: EQUAL
13879: IFTRUE 13883
13881: GO 13888
13883: POP
// exit ; end ;
13884: GO 14470
13886: GO 13889
13888: POP
// ChangeMissionObjectives ( MCar ) ;
13889: LD_STRING MCar
13891: PPUSH
13892: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
13896: LD_INT 124
13898: PPUSH
13899: LD_INT 90
13901: PPUSH
13902: LD_INT 1
13904: PPUSH
13905: LD_INT 6
13907: NEG
13908: PPUSH
13909: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
13913: LD_INT 124
13915: PPUSH
13916: LD_INT 90
13918: PPUSH
13919: LD_INT 1
13921: PPUSH
13922: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
13926: LD_INT 12
13928: PPUSH
13929: LD_INT 1
13931: PPUSH
13932: CALL_OW 424
// wait ( 3 ) ;
13936: LD_INT 3
13938: PPUSH
13939: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
13943: LD_INT 124
13945: PPUSH
13946: LD_INT 90
13948: PPUSH
13949: CALL_OW 86
// cargo := false ;
13953: LD_ADDR_VAR 0 3
13957: PUSH
13958: LD_INT 0
13960: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13961: LD_INT 35
13963: PPUSH
13964: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: LD_INT 12
13975: PPUSH
13976: LD_INT 32
13978: PUSH
13979: LD_INT 3
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 34
13988: PUSH
13989: LD_INT 32
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: LD_INT 58
13998: PUSH
13999: EMPTY
14000: LIST
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: LIST
14006: PPUSH
14007: CALL_OW 70
14011: ST_TO_ADDR
// until cargo ;
14012: LD_VAR 0 3
14016: IFFALSE 13961
// cargo := cargo [ 1 ] ;
14018: LD_ADDR_VAR 0 3
14022: PUSH
14023: LD_VAR 0 3
14027: PUSH
14028: LD_INT 1
14030: ARRAY
14031: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14032: LD_VAR 0 3
14036: PPUSH
14037: LD_INT 5
14039: PPUSH
14040: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14044: LD_INT 12
14046: PPUSH
14047: LD_INT 0
14049: PPUSH
14050: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14054: LD_EXP 45
14058: PPUSH
14059: LD_INT 11
14061: PPUSH
14062: LD_INT 0
14064: PPUSH
14065: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14069: LD_EXP 46
14073: PPUSH
14074: LD_INT 11
14076: PPUSH
14077: LD_INT 0
14079: PPUSH
14080: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14084: LD_EXP 45
14088: PUSH
14089: LD_EXP 46
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: PPUSH
14098: LD_INT 12
14100: PPUSH
14101: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14105: LD_EXP 45
14109: PPUSH
14110: LD_VAR 0 3
14114: PPUSH
14115: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14119: LD_EXP 45
14123: PUSH
14124: LD_EXP 46
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: PPUSH
14133: LD_INT 209
14135: PPUSH
14136: LD_INT 178
14138: PPUSH
14139: CALL_OW 171
// while ( true ) do
14143: LD_INT 1
14145: IFFALSE 14299
// begin wait ( 0 0$1 ) ;
14147: LD_INT 35
14149: PPUSH
14150: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14154: LD_EXP 45
14158: PPUSH
14159: CALL_OW 314
14163: NOT
14164: PUSH
14165: LD_EXP 46
14169: PPUSH
14170: CALL_OW 314
14174: NOT
14175: OR
14176: IFFALSE 14202
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14178: LD_EXP 45
14182: PUSH
14183: LD_EXP 46
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: PPUSH
14192: LD_INT 209
14194: PPUSH
14195: LD_INT 178
14197: PPUSH
14198: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14202: LD_EXP 45
14206: PPUSH
14207: LD_INT 10
14209: PPUSH
14210: CALL_OW 308
14214: IFFALSE 14225
// RemoveUnit ( ar_mechanic ) ;
14216: LD_EXP 45
14220: PPUSH
14221: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
14225: LD_EXP 46
14229: PPUSH
14230: LD_INT 10
14232: PPUSH
14233: CALL_OW 308
14237: IFFALSE 14248
// RemoveUnit ( ar_mechanic_friend ) ;
14239: LD_EXP 46
14243: PPUSH
14244: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
14248: LD_VAR 0 3
14252: PPUSH
14253: LD_INT 10
14255: PPUSH
14256: CALL_OW 308
14260: IFFALSE 14271
// RemoveUnit ( cargo ) ;
14262: LD_VAR 0 3
14266: PPUSH
14267: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
14271: LD_EXP 45
14275: PPUSH
14276: CALL_OW 300
14280: NOT
14281: PUSH
14282: LD_EXP 46
14286: PPUSH
14287: CALL_OW 300
14291: NOT
14292: AND
14293: IFFALSE 14297
// break ;
14295: GO 14299
// end ;
14297: GO 14143
// wait ( 0 0$2 ) ;
14299: LD_INT 70
14301: PPUSH
14302: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14306: LD_EXP 45
14310: PPUSH
14311: LD_STRING D7a-Ar1-1
14313: PPUSH
14314: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14318: LD_ADDR_VAR 0 4
14322: PUSH
14323: LD_INT 129
14325: PUSH
14326: LD_INT 10
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 103
14335: PUSH
14336: LD_INT 6
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 148
14345: PUSH
14346: LD_INT 47
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: LD_INT 155
14355: PUSH
14356: LD_INT 16
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: ST_TO_ADDR
// if Difficulty = 1 then
14369: LD_OWVAR 67
14373: PUSH
14374: LD_INT 1
14376: EQUAL
14377: IFFALSE 14414
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14379: LD_ADDR_VAR 0 4
14383: PUSH
14384: LD_VAR 0 4
14388: PUSH
14389: LD_INT 78
14391: PUSH
14392: LD_INT 7
14394: PUSH
14395: EMPTY
14396: LIST
14397: LIST
14398: PUSH
14399: LD_INT 104
14401: PUSH
14402: LD_INT 43
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: ADD
14413: ST_TO_ADDR
// for i in tmp do
14414: LD_ADDR_VAR 0 2
14418: PUSH
14419: LD_VAR 0 4
14423: PUSH
14424: FOR_IN
14425: IFFALSE 14458
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14427: LD_VAR 0 2
14431: PUSH
14432: LD_INT 1
14434: ARRAY
14435: PPUSH
14436: LD_VAR 0 2
14440: PUSH
14441: LD_INT 2
14443: ARRAY
14444: PPUSH
14445: LD_INT 1
14447: PPUSH
14448: LD_INT 9
14450: NEG
14451: PPUSH
14452: CALL_OW 330
14456: GO 14424
14458: POP
14459: POP
// CenterOnXY ( 129 , 10 ) ;
14460: LD_INT 129
14462: PPUSH
14463: LD_INT 10
14465: PPUSH
14466: CALL_OW 84
// end ;
14470: PPOPN 4
14472: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14473: LD_EXP 15
14477: PUSH
14478: LD_INT 21000
14480: MINUS
14481: PUSH
14482: LD_OWVAR 1
14486: LESSEQUAL
14487: IFFALSE 14527
14489: GO 14491
14491: DISABLE
// begin powell_warn := true ;
14492: LD_ADDR_EXP 16
14496: PUSH
14497: LD_INT 1
14499: ST_TO_ADDR
// DialogueOn ;
14500: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14504: LD_EXP 29
14508: PPUSH
14509: LD_STRING D9-Pow-1
14511: PPUSH
14512: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14516: LD_INT 10
14518: PPUSH
14519: CALL_OW 68
// DialogueOff ;
14523: CALL_OW 7
// end ;
14527: END
// every 0 0$1 trigger game_time <= tick do
14528: LD_EXP 15
14532: PUSH
14533: LD_OWVAR 1
14537: LESSEQUAL
14538: IFFALSE 14577
14540: GO 14542
14542: DISABLE
// begin DialogueOn ;
14543: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14547: LD_EXP 29
14551: PPUSH
14552: LD_STRING D9a-Pow-1
14554: PPUSH
14555: CALL_OW 94
// dwait ( 0 0$2 ) ;
14559: LD_INT 70
14561: PPUSH
14562: CALL_OW 68
// DialogueOff ;
14566: CALL_OW 7
// YouLost ( Command ) ;
14570: LD_STRING Command
14572: PPUSH
14573: CALL_OW 104
// end ;
14577: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp ;
14578: LD_INT 22
14580: PUSH
14581: LD_INT 2
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PUSH
14588: LD_INT 30
14590: PUSH
14591: LD_INT 1
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PPUSH
14602: CALL_OW 69
14606: PUSH
14607: LD_INT 0
14609: EQUAL
14610: PUSH
14611: LD_EXP 20
14615: PPUSH
14616: CALL_OW 302
14620: AND
14621: IFFALSE 15353
14623: GO 14625
14625: DISABLE
14626: LD_INT 0
14628: PPUSH
// begin if tick < [ 95 95$00 , 85 85$00 , 80 80$00 ] [ Difficulty ] then
14629: LD_OWVAR 1
14633: PUSH
14634: LD_INT 199500
14636: PUSH
14637: LD_INT 178500
14639: PUSH
14640: LD_INT 168000
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: LIST
14647: PUSH
14648: LD_OWVAR 67
14652: ARRAY
14653: LESS
14654: IFFALSE 14668
// AddMedal ( Time1 , 1 ) else
14656: LD_STRING Time1
14658: PPUSH
14659: LD_INT 1
14661: PPUSH
14662: CALL_OW 101
14666: GO 14699
// if not powell_warn then
14668: LD_EXP 16
14672: NOT
14673: IFFALSE 14688
// AddMedal ( Time1 , - 1 ) else
14675: LD_STRING Time1
14677: PPUSH
14678: LD_INT 1
14680: NEG
14681: PPUSH
14682: CALL_OW 101
14686: GO 14699
// AddMedal ( Time1 , - 2 ) ;
14688: LD_STRING Time1
14690: PPUSH
14691: LD_INT 2
14693: NEG
14694: PPUSH
14695: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14699: LD_EXP 17
14703: PUSH
14704: LD_INT 5
14706: PUSH
14707: LD_INT 4
14709: PUSH
14710: LD_INT 3
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: PUSH
14718: LD_OWVAR 67
14722: ARRAY
14723: GREATEREQUAL
14724: IFFALSE 14739
// AddMedal ( Destroy , - 2 ) else
14726: LD_STRING Destroy
14728: PPUSH
14729: LD_INT 2
14731: NEG
14732: PPUSH
14733: CALL_OW 101
14737: GO 14856
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14739: LD_INT 22
14741: PUSH
14742: LD_INT 2
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: PUSH
14749: LD_INT 21
14751: PUSH
14752: LD_INT 3
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 50
14761: PUSH
14762: EMPTY
14763: LIST
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: LIST
14769: PPUSH
14770: CALL_OW 69
14774: PUSH
14775: LD_INT 25
14777: GREATEREQUAL
14778: IFFALSE 14793
// AddMedal ( Destroy , - 1 ) else
14780: LD_STRING Destroy
14782: PPUSH
14783: LD_INT 1
14785: NEG
14786: PPUSH
14787: CALL_OW 101
14791: GO 14856
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
14793: LD_INT 22
14795: PUSH
14796: LD_INT 2
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: LD_INT 21
14805: PUSH
14806: LD_INT 3
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 50
14815: PUSH
14816: EMPTY
14817: LIST
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: LIST
14823: PPUSH
14824: CALL_OW 69
14828: PUSH
14829: LD_INT 15
14831: GREATEREQUAL
14832: IFFALSE 14846
// AddMedal ( Destroy , 1 ) else
14834: LD_STRING Destroy
14836: PPUSH
14837: LD_INT 1
14839: PPUSH
14840: CALL_OW 101
14844: GO 14856
// AddMedal ( Destroy , 2 ) ;
14846: LD_STRING Destroy
14848: PPUSH
14849: LD_INT 2
14851: PPUSH
14852: CALL_OW 101
// SaveVariable ( artifact_get , 11_artifact_captured ) ;
14856: LD_EXP 13
14860: PPUSH
14861: LD_STRING 11_artifact_captured
14863: PPUSH
14864: CALL_OW 39
// if artifact_get then
14868: LD_EXP 13
14872: IFFALSE 14886
// AddMedal ( Artefact , 1 ) else
14874: LD_STRING Artefact
14876: PPUSH
14877: LD_INT 1
14879: PPUSH
14880: CALL_OW 101
14884: GO 14897
// AddMedal ( Artefact , - 1 ) ;
14886: LD_STRING Artefact
14888: PPUSH
14889: LD_INT 1
14891: NEG
14892: PPUSH
14893: CALL_OW 101
// GiveMedals ( MAIN ) ;
14897: LD_STRING MAIN
14899: PPUSH
14900: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
14904: LD_ADDR_EXP 19
14908: PUSH
14909: LD_EXP 19
14913: PPUSH
14914: LD_INT 51
14916: PUSH
14917: EMPTY
14918: LIST
14919: PPUSH
14920: CALL_OW 72
14924: ST_TO_ADDR
// tmp := JMM ^ selected ;
14925: LD_ADDR_VAR 0 1
14929: PUSH
14930: LD_EXP 20
14934: PUSH
14935: LD_EXP 19
14939: ADD
14940: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14941: LD_VAR 0 1
14945: PPUSH
14946: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
14950: LD_VAR 0 1
14954: PUSH
14955: LD_EXP 20
14959: PUSH
14960: LD_EXP 21
14964: PUSH
14965: LD_EXP 22
14969: PUSH
14970: LD_EXP 23
14974: PUSH
14975: LD_EXP 24
14979: PUSH
14980: LD_EXP 25
14984: PUSH
14985: LD_EXP 26
14989: PUSH
14990: LD_EXP 27
14994: PUSH
14995: LD_EXP 28
14999: PUSH
15000: LD_EXP 30
15004: PUSH
15005: LD_EXP 31
15009: PUSH
15010: LD_EXP 32
15014: PUSH
15015: LD_EXP 33
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: DIFF
15035: PPUSH
15036: LD_STRING 11c_others
15038: PPUSH
15039: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15043: LD_EXP 20
15047: PPUSH
15048: LD_EXP 3
15052: PUSH
15053: LD_STRING JMM
15055: STR
15056: PPUSH
15057: CALL_OW 38
// if Lisa then
15061: LD_EXP 21
15065: IFFALSE 15085
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15067: LD_EXP 21
15071: PPUSH
15072: LD_EXP 3
15076: PUSH
15077: LD_STRING Lisa
15079: STR
15080: PPUSH
15081: CALL_OW 38
// if Donaldson then
15085: LD_EXP 22
15089: IFFALSE 15109
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15091: LD_EXP 22
15095: PPUSH
15096: LD_EXP 3
15100: PUSH
15101: LD_STRING Donaldson
15103: STR
15104: PPUSH
15105: CALL_OW 38
// if Bobby then
15109: LD_EXP 23
15113: IFFALSE 15133
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15115: LD_EXP 23
15119: PPUSH
15120: LD_EXP 3
15124: PUSH
15125: LD_STRING Bobby
15127: STR
15128: PPUSH
15129: CALL_OW 38
// if Cyrus then
15133: LD_EXP 24
15137: IFFALSE 15157
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15139: LD_EXP 24
15143: PPUSH
15144: LD_EXP 3
15148: PUSH
15149: LD_STRING Cyrus
15151: STR
15152: PPUSH
15153: CALL_OW 38
// if Denis then
15157: LD_EXP 25
15161: IFFALSE 15181
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15163: LD_EXP 25
15167: PPUSH
15168: LD_EXP 3
15172: PUSH
15173: LD_STRING Denis
15175: STR
15176: PPUSH
15177: CALL_OW 38
// if Brown then
15181: LD_EXP 26
15185: IFFALSE 15205
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15187: LD_EXP 26
15191: PPUSH
15192: LD_EXP 3
15196: PUSH
15197: LD_STRING Brown
15199: STR
15200: PPUSH
15201: CALL_OW 38
// if Gladstone then
15205: LD_EXP 27
15209: IFFALSE 15229
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15211: LD_EXP 27
15215: PPUSH
15216: LD_EXP 3
15220: PUSH
15221: LD_STRING Gladstone
15223: STR
15224: PPUSH
15225: CALL_OW 38
// if Houten then
15229: LD_EXP 28
15233: IFFALSE 15253
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15235: LD_EXP 28
15239: PPUSH
15240: LD_EXP 3
15244: PUSH
15245: LD_STRING Houten
15247: STR
15248: PPUSH
15249: CALL_OW 38
// if Cornel then
15253: LD_EXP 30
15257: IFFALSE 15277
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15259: LD_EXP 30
15263: PPUSH
15264: LD_EXP 3
15268: PUSH
15269: LD_STRING Cornell
15271: STR
15272: PPUSH
15273: CALL_OW 38
// if Gary then
15277: LD_EXP 31
15281: IFFALSE 15301
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15283: LD_EXP 31
15287: PPUSH
15288: LD_EXP 3
15292: PUSH
15293: LD_STRING Gary
15295: STR
15296: PPUSH
15297: CALL_OW 38
// if Frank then
15301: LD_EXP 32
15305: IFFALSE 15325
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15307: LD_EXP 32
15311: PPUSH
15312: LD_EXP 3
15316: PUSH
15317: LD_STRING Frank
15319: STR
15320: PPUSH
15321: CALL_OW 38
// if Kikuchi then
15325: LD_EXP 33
15329: IFFALSE 15349
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15331: LD_EXP 33
15335: PPUSH
15336: LD_EXP 3
15340: PUSH
15341: LD_STRING Kikuchi
15343: STR
15344: PPUSH
15345: CALL_OW 38
// YouWin ;
15349: CALL_OW 103
// end ;
15353: PPOPN 1
15355: END
// export function CanSayRand ( side ) ; begin
15356: LD_INT 0
15358: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15359: LD_ADDR_VAR 0 2
15363: PUSH
15364: LD_INT 52
15366: PUSH
15367: EMPTY
15368: LIST
15369: PUSH
15370: LD_INT 22
15372: PUSH
15373: LD_VAR 0 1
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: PUSH
15382: LD_INT 2
15384: PUSH
15385: LD_INT 25
15387: PUSH
15388: LD_INT 1
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: PUSH
15395: LD_INT 25
15397: PUSH
15398: LD_INT 2
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: PUSH
15405: LD_INT 25
15407: PUSH
15408: LD_INT 3
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: PUSH
15415: LD_INT 25
15417: PUSH
15418: LD_INT 4
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: PUSH
15425: EMPTY
15426: LIST
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: LIST
15436: PPUSH
15437: CALL_OW 69
15441: PUSH
15442: LD_EXP 20
15446: PUSH
15447: LD_EXP 32
15451: PUSH
15452: LD_EXP 21
15456: PUSH
15457: LD_EXP 22
15461: PUSH
15462: LD_EXP 23
15466: PUSH
15467: LD_EXP 24
15471: PUSH
15472: LD_EXP 25
15476: PUSH
15477: LD_EXP 26
15481: PUSH
15482: LD_EXP 27
15486: PUSH
15487: LD_EXP 28
15491: PUSH
15492: LD_EXP 29
15496: PUSH
15497: LD_EXP 30
15501: PUSH
15502: LD_EXP 31
15506: PUSH
15507: LD_EXP 33
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: LIST
15516: LIST
15517: LIST
15518: LIST
15519: LIST
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: LIST
15527: DIFF
15528: ST_TO_ADDR
// end ;
15529: LD_VAR 0 2
15533: RET
// export function SayRand ( sex , dial ) ; begin
15534: LD_INT 0
15536: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15537: LD_ADDR_VAR 0 3
15541: PUSH
15542: LD_INT 52
15544: PUSH
15545: EMPTY
15546: LIST
15547: PUSH
15548: LD_INT 22
15550: PUSH
15551: LD_INT 1
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PUSH
15558: LD_INT 26
15560: PUSH
15561: LD_VAR 0 1
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PUSH
15570: LD_INT 2
15572: PUSH
15573: LD_INT 25
15575: PUSH
15576: LD_INT 1
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: PUSH
15583: LD_INT 25
15585: PUSH
15586: LD_INT 2
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PUSH
15593: LD_INT 25
15595: PUSH
15596: LD_INT 3
15598: PUSH
15599: EMPTY
15600: LIST
15601: LIST
15602: PUSH
15603: LD_INT 25
15605: PUSH
15606: LD_INT 4
15608: PUSH
15609: EMPTY
15610: LIST
15611: LIST
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: LIST
15624: LIST
15625: PPUSH
15626: CALL_OW 69
15630: PUSH
15631: LD_EXP 20
15635: PUSH
15636: LD_EXP 32
15640: PUSH
15641: LD_EXP 21
15645: PUSH
15646: LD_EXP 22
15650: PUSH
15651: LD_EXP 23
15655: PUSH
15656: LD_EXP 24
15660: PUSH
15661: LD_EXP 25
15665: PUSH
15666: LD_EXP 26
15670: PUSH
15671: LD_EXP 27
15675: PUSH
15676: LD_EXP 28
15680: PUSH
15681: LD_EXP 29
15685: PUSH
15686: LD_EXP 30
15690: PUSH
15691: LD_EXP 31
15695: PUSH
15696: LD_EXP 33
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: LIST
15705: LIST
15706: LIST
15707: LIST
15708: LIST
15709: LIST
15710: LIST
15711: LIST
15712: LIST
15713: LIST
15714: LIST
15715: LIST
15716: DIFF
15717: ST_TO_ADDR
// if not result then
15718: LD_VAR 0 3
15722: NOT
15723: IFFALSE 15727
// exit ;
15725: GO 15755
// result := result [ 1 ] ;
15727: LD_ADDR_VAR 0 3
15731: PUSH
15732: LD_VAR 0 3
15736: PUSH
15737: LD_INT 1
15739: ARRAY
15740: ST_TO_ADDR
// Say ( result , dial ) ;
15741: LD_VAR 0 3
15745: PPUSH
15746: LD_VAR 0 2
15750: PPUSH
15751: CALL_OW 88
// end ;
15755: LD_VAR 0 3
15759: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
15760: LD_INT 0
15762: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
15763: LD_ADDR_VAR 0 4
15767: PUSH
15768: LD_INT 22
15770: PUSH
15771: LD_INT 1
15773: PUSH
15774: EMPTY
15775: LIST
15776: LIST
15777: PUSH
15778: LD_INT 26
15780: PUSH
15781: LD_VAR 0 1
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 25
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 25
15805: PUSH
15806: LD_INT 2
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: LD_INT 25
15815: PUSH
15816: LD_INT 3
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PUSH
15823: LD_INT 25
15825: PUSH
15826: LD_INT 4
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: LIST
15837: LIST
15838: LIST
15839: PUSH
15840: EMPTY
15841: LIST
15842: LIST
15843: LIST
15844: PPUSH
15845: CALL_OW 69
15849: PUSH
15850: LD_EXP 20
15854: PUSH
15855: LD_EXP 32
15859: PUSH
15860: LD_EXP 21
15864: PUSH
15865: LD_EXP 22
15869: PUSH
15870: LD_EXP 23
15874: PUSH
15875: LD_EXP 24
15879: PUSH
15880: LD_EXP 25
15884: PUSH
15885: LD_EXP 26
15889: PUSH
15890: LD_EXP 27
15894: PUSH
15895: LD_EXP 28
15899: PUSH
15900: LD_EXP 29
15904: PUSH
15905: LD_EXP 30
15909: PUSH
15910: LD_EXP 31
15914: PUSH
15915: LD_EXP 33
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: LIST
15924: LIST
15925: LIST
15926: LIST
15927: LIST
15928: LIST
15929: LIST
15930: LIST
15931: LIST
15932: LIST
15933: LIST
15934: LIST
15935: PUSH
15936: LD_VAR 0 3
15940: ADD
15941: DIFF
15942: ST_TO_ADDR
// if not result then
15943: LD_VAR 0 4
15947: NOT
15948: IFFALSE 15952
// exit ;
15950: GO 15980
// result := result [ 1 ] ;
15952: LD_ADDR_VAR 0 4
15956: PUSH
15957: LD_VAR 0 4
15961: PUSH
15962: LD_INT 1
15964: ARRAY
15965: ST_TO_ADDR
// Say ( result , dial ) ;
15966: LD_VAR 0 4
15970: PPUSH
15971: LD_VAR 0 2
15975: PPUSH
15976: CALL_OW 88
// end ; end_of_file
15980: LD_VAR 0 4
15984: RET
// export function CustomEvent ( event ) ; begin
15985: LD_INT 0
15987: PPUSH
// end ;
15988: LD_VAR 0 2
15992: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
15993: LD_VAR 0 1
15997: PPUSH
15998: CALL_OW 255
16002: PUSH
16003: LD_INT 1
16005: EQUAL
16006: IFFALSE 16016
// artifact_get := true ;
16008: LD_ADDR_EXP 13
16012: PUSH
16013: LD_INT 1
16015: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16016: LD_VAR 0 1
16020: PPUSH
16021: CALL_OW 255
16025: PUSH
16026: LD_INT 2
16028: EQUAL
16029: IFFALSE 16047
// begin artifact_get := false ;
16031: LD_ADDR_EXP 13
16035: PUSH
16036: LD_INT 0
16038: ST_TO_ADDR
// artifact_stolen := true ;
16039: LD_ADDR_EXP 12
16043: PUSH
16044: LD_INT 1
16046: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16047: LD_ADDR_EXP 14
16051: PUSH
16052: LD_INT 1
16054: ST_TO_ADDR
// end ;
16055: PPOPN 2
16057: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16058: LD_ADDR_EXP 14
16062: PUSH
16063: LD_INT 0
16065: ST_TO_ADDR
// end ;
16066: PPOPN 2
16068: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16069: LD_VAR 0 1
16073: PUSH
16074: LD_EXP 20
16078: EQUAL
16079: IFFALSE 16090
// begin YouLost ( JMM ) ;
16081: LD_STRING JMM
16083: PPUSH
16084: CALL_OW 104
// exit ;
16088: GO 16222
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16090: LD_VAR 0 1
16094: PUSH
16095: LD_INT 22
16097: PUSH
16098: LD_INT 1
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PUSH
16105: LD_INT 21
16107: PUSH
16108: LD_INT 1
16110: PUSH
16111: EMPTY
16112: LIST
16113: LIST
16114: PUSH
16115: LD_INT 2
16117: PUSH
16118: LD_INT 25
16120: PUSH
16121: LD_INT 1
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: PUSH
16128: LD_INT 25
16130: PUSH
16131: LD_INT 2
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PUSH
16138: LD_INT 25
16140: PUSH
16141: LD_INT 3
16143: PUSH
16144: EMPTY
16145: LIST
16146: LIST
16147: PUSH
16148: LD_INT 25
16150: PUSH
16151: LD_INT 4
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: PUSH
16158: LD_INT 25
16160: PUSH
16161: LD_INT 5
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: LD_INT 25
16170: PUSH
16171: LD_INT 8
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: PUSH
16187: EMPTY
16188: LIST
16189: LIST
16190: LIST
16191: PPUSH
16192: CALL_OW 69
16196: IN
16197: IFFALSE 16213
// loses_counter := loses_counter + 1 ;
16199: LD_ADDR_EXP 17
16203: PUSH
16204: LD_EXP 17
16208: PUSH
16209: LD_INT 1
16211: PLUS
16212: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16213: LD_VAR 0 1
16217: PPUSH
16218: CALL 42333 0 1
// end ;
16222: PPOPN 1
16224: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16225: LD_VAR 0 1
16229: PPUSH
16230: LD_VAR 0 2
16234: PPUSH
16235: CALL 44312 0 2
// end ;
16239: PPOPN 2
16241: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16242: LD_VAR 0 1
16246: PPUSH
16247: CALL 43621 0 1
// end ;
16251: PPOPN 1
16253: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16254: LD_VAR 0 1
16258: PPUSH
16259: LD_VAR 0 2
16263: PPUSH
16264: LD_VAR 0 3
16268: PPUSH
16269: LD_VAR 0 4
16273: PPUSH
16274: LD_VAR 0 5
16278: PPUSH
16279: CALL 41649 0 5
// end ;
16283: PPOPN 5
16285: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 2
16295: PPUSH
16296: CALL 41239 0 2
// end ;
16300: PPOPN 2
16302: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16303: LD_VAR 0 1
16307: PPUSH
16308: CALL_OW 247
16312: PUSH
16313: LD_INT 2
16315: EQUAL
16316: IFFALSE 16320
// exit ;
16318: GO 16337
// if not kamikazed then
16320: LD_EXP 11
16324: NOT
16325: IFFALSE 16337
// kamikazed := unit ;
16327: LD_ADDR_EXP 11
16331: PUSH
16332: LD_VAR 0 1
16336: ST_TO_ADDR
// end ;
16337: PPOPN 1
16339: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16340: LD_INT 0
16342: PPUSH
16343: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16344: LD_VAR 0 1
16348: PPUSH
16349: LD_VAR 0 2
16353: PPUSH
16354: LD_VAR 0 3
16358: PPUSH
16359: LD_VAR 0 4
16363: PPUSH
16364: CALL 41077 0 4
// end ;
16368: PPOPN 6
16370: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16371: LD_VAR 0 1
16375: PPUSH
16376: LD_VAR 0 2
16380: PPUSH
16381: LD_VAR 0 3
16385: PPUSH
16386: CALL 40852 0 3
// end ;
16390: PPOPN 3
16392: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16393: LD_VAR 0 1
16397: PPUSH
16398: LD_VAR 0 2
16402: PPUSH
16403: CALL 42029 0 2
// end ;
16407: PPOPN 2
16409: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16410: LD_VAR 0 1
16414: PPUSH
16415: LD_VAR 0 2
16419: PPUSH
16420: CALL 40546 0 2
// end ;
16424: PPOPN 2
16426: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16427: LD_VAR 0 1
16431: PPUSH
16432: LD_VAR 0 2
16436: PPUSH
16437: CALL 40737 0 2
// end ;
16441: PPOPN 2
16443: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16444: LD_VAR 0 1
16448: PPUSH
16449: CALL 43380 0 1
// end ;
16453: PPOPN 1
16455: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16456: LD_VAR 0 1
16460: PPUSH
16461: LD_VAR 0 2
16465: PPUSH
16466: CALL 44573 0 2
// end ;
16470: PPOPN 2
16472: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16473: LD_VAR 0 1
16477: PPUSH
16478: LD_VAR 0 2
16482: PPUSH
16483: LD_VAR 0 3
16487: PPUSH
16488: LD_VAR 0 4
16492: PPUSH
16493: CALL 44789 0 4
// end ; end_of_file
16497: PPOPN 4
16499: END
// every 0 0$1 trigger game do
16500: LD_EXP 2
16504: IFFALSE 16534
16506: GO 16508
16508: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16509: LD_INT 7
16511: PUSH
16512: LD_INT 6
16514: PUSH
16515: LD_INT 4
16517: PUSH
16518: LD_INT 6
16520: PUSH
16521: EMPTY
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: PPUSH
16527: LD_INT 1750
16529: PPUSH
16530: CALL 16535 0 2
16534: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16535: LD_INT 0
16537: PPUSH
16538: PPUSH
16539: PPUSH
// if not areas then
16540: LD_VAR 0 1
16544: NOT
16545: IFFALSE 16549
// exit ;
16547: GO 16679
// repeat wait ( time ) ;
16549: LD_VAR 0 2
16553: PPUSH
16554: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16558: LD_ADDR_VAR 0 5
16562: PUSH
16563: LD_INT 1
16565: PPUSH
16566: LD_INT 90
16568: PPUSH
16569: CALL_OW 12
16573: ST_TO_ADDR
// for i in areas do
16574: LD_ADDR_VAR 0 4
16578: PUSH
16579: LD_VAR 0 1
16583: PUSH
16584: FOR_IN
16585: IFFALSE 16638
// begin if Prob ( p ) then
16587: LD_VAR 0 5
16591: PPUSH
16592: CALL_OW 13
16596: IFFALSE 16636
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
16598: LD_INT 1
16600: PPUSH
16601: LD_INT 5
16603: PPUSH
16604: CALL_OW 12
16608: PPUSH
16609: LD_VAR 0 4
16613: PPUSH
16614: LD_INT 1
16616: PPUSH
16617: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
16621: LD_INT 385
16623: PPUSH
16624: LD_INT 595
16626: PPUSH
16627: CALL_OW 12
16631: PPUSH
16632: CALL_OW 67
// end ; end ;
16636: GO 16584
16638: POP
16639: POP
// time := time + 0 0$3 ;
16640: LD_ADDR_VAR 0 2
16644: PUSH
16645: LD_VAR 0 2
16649: PUSH
16650: LD_INT 105
16652: PLUS
16653: ST_TO_ADDR
// if time > 7 7$00 then
16654: LD_VAR 0 2
16658: PUSH
16659: LD_INT 14700
16661: GREATER
16662: IFFALSE 16672
// time := 0 0$40 ;
16664: LD_ADDR_VAR 0 2
16668: PUSH
16669: LD_INT 1400
16671: ST_TO_ADDR
// until not game ;
16672: LD_EXP 2
16676: NOT
16677: IFFALSE 16549
// end ; end_of_file
16679: LD_VAR 0 3
16683: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
16684: LD_INT 0
16686: PPUSH
16687: PPUSH
// skirmish := false ;
16688: LD_ADDR_EXP 47
16692: PUSH
16693: LD_INT 0
16695: ST_TO_ADDR
// debug_mc := false ;
16696: LD_ADDR_EXP 48
16700: PUSH
16701: LD_INT 0
16703: ST_TO_ADDR
// mc_bases := [ ] ;
16704: LD_ADDR_EXP 49
16708: PUSH
16709: EMPTY
16710: ST_TO_ADDR
// mc_sides := [ ] ;
16711: LD_ADDR_EXP 75
16715: PUSH
16716: EMPTY
16717: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
16718: LD_ADDR_EXP 50
16722: PUSH
16723: EMPTY
16724: ST_TO_ADDR
// mc_building_repairs := [ ] ;
16725: LD_ADDR_EXP 51
16729: PUSH
16730: EMPTY
16731: ST_TO_ADDR
// mc_need_heal := [ ] ;
16732: LD_ADDR_EXP 52
16736: PUSH
16737: EMPTY
16738: ST_TO_ADDR
// mc_healers := [ ] ;
16739: LD_ADDR_EXP 53
16743: PUSH
16744: EMPTY
16745: ST_TO_ADDR
// mc_build_list := [ ] ;
16746: LD_ADDR_EXP 54
16750: PUSH
16751: EMPTY
16752: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
16753: LD_ADDR_EXP 81
16757: PUSH
16758: EMPTY
16759: ST_TO_ADDR
// mc_builders := [ ] ;
16760: LD_ADDR_EXP 55
16764: PUSH
16765: EMPTY
16766: ST_TO_ADDR
// mc_construct_list := [ ] ;
16767: LD_ADDR_EXP 56
16771: PUSH
16772: EMPTY
16773: ST_TO_ADDR
// mc_turret_list := [ ] ;
16774: LD_ADDR_EXP 57
16778: PUSH
16779: EMPTY
16780: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
16781: LD_ADDR_EXP 58
16785: PUSH
16786: EMPTY
16787: ST_TO_ADDR
// mc_miners := [ ] ;
16788: LD_ADDR_EXP 63
16792: PUSH
16793: EMPTY
16794: ST_TO_ADDR
// mc_mines := [ ] ;
16795: LD_ADDR_EXP 62
16799: PUSH
16800: EMPTY
16801: ST_TO_ADDR
// mc_minefields := [ ] ;
16802: LD_ADDR_EXP 64
16806: PUSH
16807: EMPTY
16808: ST_TO_ADDR
// mc_crates := [ ] ;
16809: LD_ADDR_EXP 65
16813: PUSH
16814: EMPTY
16815: ST_TO_ADDR
// mc_crates_collector := [ ] ;
16816: LD_ADDR_EXP 66
16820: PUSH
16821: EMPTY
16822: ST_TO_ADDR
// mc_crates_area := [ ] ;
16823: LD_ADDR_EXP 67
16827: PUSH
16828: EMPTY
16829: ST_TO_ADDR
// mc_vehicles := [ ] ;
16830: LD_ADDR_EXP 68
16834: PUSH
16835: EMPTY
16836: ST_TO_ADDR
// mc_attack := [ ] ;
16837: LD_ADDR_EXP 69
16841: PUSH
16842: EMPTY
16843: ST_TO_ADDR
// mc_produce := [ ] ;
16844: LD_ADDR_EXP 70
16848: PUSH
16849: EMPTY
16850: ST_TO_ADDR
// mc_defender := [ ] ;
16851: LD_ADDR_EXP 71
16855: PUSH
16856: EMPTY
16857: ST_TO_ADDR
// mc_parking := [ ] ;
16858: LD_ADDR_EXP 73
16862: PUSH
16863: EMPTY
16864: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
16865: LD_ADDR_EXP 59
16869: PUSH
16870: EMPTY
16871: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
16872: LD_ADDR_EXP 61
16876: PUSH
16877: EMPTY
16878: ST_TO_ADDR
// mc_scan := [ ] ;
16879: LD_ADDR_EXP 72
16883: PUSH
16884: EMPTY
16885: ST_TO_ADDR
// mc_scan_area := [ ] ;
16886: LD_ADDR_EXP 74
16890: PUSH
16891: EMPTY
16892: ST_TO_ADDR
// mc_tech := [ ] ;
16893: LD_ADDR_EXP 76
16897: PUSH
16898: EMPTY
16899: ST_TO_ADDR
// mc_class := [ ] ;
16900: LD_ADDR_EXP 90
16904: PUSH
16905: EMPTY
16906: ST_TO_ADDR
// mc_class_case_use := [ ] ;
16907: LD_ADDR_EXP 91
16911: PUSH
16912: EMPTY
16913: ST_TO_ADDR
// end ;
16914: LD_VAR 0 1
16918: RET
// export function MC_Kill ( base ) ; begin
16919: LD_INT 0
16921: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
16922: LD_ADDR_EXP 49
16926: PUSH
16927: LD_EXP 49
16931: PPUSH
16932: LD_VAR 0 1
16936: PPUSH
16937: EMPTY
16938: PPUSH
16939: CALL_OW 1
16943: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
16944: LD_ADDR_EXP 50
16948: PUSH
16949: LD_EXP 50
16953: PPUSH
16954: LD_VAR 0 1
16958: PPUSH
16959: EMPTY
16960: PPUSH
16961: CALL_OW 1
16965: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
16966: LD_ADDR_EXP 51
16970: PUSH
16971: LD_EXP 51
16975: PPUSH
16976: LD_VAR 0 1
16980: PPUSH
16981: EMPTY
16982: PPUSH
16983: CALL_OW 1
16987: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
16988: LD_ADDR_EXP 52
16992: PUSH
16993: LD_EXP 52
16997: PPUSH
16998: LD_VAR 0 1
17002: PPUSH
17003: EMPTY
17004: PPUSH
17005: CALL_OW 1
17009: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17010: LD_ADDR_EXP 53
17014: PUSH
17015: LD_EXP 53
17019: PPUSH
17020: LD_VAR 0 1
17024: PPUSH
17025: EMPTY
17026: PPUSH
17027: CALL_OW 1
17031: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17032: LD_ADDR_EXP 54
17036: PUSH
17037: LD_EXP 54
17041: PPUSH
17042: LD_VAR 0 1
17046: PPUSH
17047: EMPTY
17048: PPUSH
17049: CALL_OW 1
17053: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17054: LD_ADDR_EXP 55
17058: PUSH
17059: LD_EXP 55
17063: PPUSH
17064: LD_VAR 0 1
17068: PPUSH
17069: EMPTY
17070: PPUSH
17071: CALL_OW 1
17075: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17076: LD_ADDR_EXP 56
17080: PUSH
17081: LD_EXP 56
17085: PPUSH
17086: LD_VAR 0 1
17090: PPUSH
17091: EMPTY
17092: PPUSH
17093: CALL_OW 1
17097: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17098: LD_ADDR_EXP 57
17102: PUSH
17103: LD_EXP 57
17107: PPUSH
17108: LD_VAR 0 1
17112: PPUSH
17113: EMPTY
17114: PPUSH
17115: CALL_OW 1
17119: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17120: LD_ADDR_EXP 58
17124: PUSH
17125: LD_EXP 58
17129: PPUSH
17130: LD_VAR 0 1
17134: PPUSH
17135: EMPTY
17136: PPUSH
17137: CALL_OW 1
17141: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17142: LD_ADDR_EXP 59
17146: PUSH
17147: LD_EXP 59
17151: PPUSH
17152: LD_VAR 0 1
17156: PPUSH
17157: EMPTY
17158: PPUSH
17159: CALL_OW 1
17163: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17164: LD_ADDR_EXP 60
17168: PUSH
17169: LD_EXP 60
17173: PPUSH
17174: LD_VAR 0 1
17178: PPUSH
17179: LD_INT 0
17181: PPUSH
17182: CALL_OW 1
17186: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17187: LD_ADDR_EXP 61
17191: PUSH
17192: LD_EXP 61
17196: PPUSH
17197: LD_VAR 0 1
17201: PPUSH
17202: EMPTY
17203: PPUSH
17204: CALL_OW 1
17208: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17209: LD_ADDR_EXP 62
17213: PUSH
17214: LD_EXP 62
17218: PPUSH
17219: LD_VAR 0 1
17223: PPUSH
17224: EMPTY
17225: PPUSH
17226: CALL_OW 1
17230: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17231: LD_ADDR_EXP 63
17235: PUSH
17236: LD_EXP 63
17240: PPUSH
17241: LD_VAR 0 1
17245: PPUSH
17246: EMPTY
17247: PPUSH
17248: CALL_OW 1
17252: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17253: LD_ADDR_EXP 64
17257: PUSH
17258: LD_EXP 64
17262: PPUSH
17263: LD_VAR 0 1
17267: PPUSH
17268: EMPTY
17269: PPUSH
17270: CALL_OW 1
17274: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17275: LD_ADDR_EXP 65
17279: PUSH
17280: LD_EXP 65
17284: PPUSH
17285: LD_VAR 0 1
17289: PPUSH
17290: EMPTY
17291: PPUSH
17292: CALL_OW 1
17296: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17297: LD_ADDR_EXP 66
17301: PUSH
17302: LD_EXP 66
17306: PPUSH
17307: LD_VAR 0 1
17311: PPUSH
17312: EMPTY
17313: PPUSH
17314: CALL_OW 1
17318: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17319: LD_ADDR_EXP 67
17323: PUSH
17324: LD_EXP 67
17328: PPUSH
17329: LD_VAR 0 1
17333: PPUSH
17334: EMPTY
17335: PPUSH
17336: CALL_OW 1
17340: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17341: LD_ADDR_EXP 68
17345: PUSH
17346: LD_EXP 68
17350: PPUSH
17351: LD_VAR 0 1
17355: PPUSH
17356: EMPTY
17357: PPUSH
17358: CALL_OW 1
17362: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17363: LD_ADDR_EXP 69
17367: PUSH
17368: LD_EXP 69
17372: PPUSH
17373: LD_VAR 0 1
17377: PPUSH
17378: EMPTY
17379: PPUSH
17380: CALL_OW 1
17384: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17385: LD_ADDR_EXP 70
17389: PUSH
17390: LD_EXP 70
17394: PPUSH
17395: LD_VAR 0 1
17399: PPUSH
17400: EMPTY
17401: PPUSH
17402: CALL_OW 1
17406: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17407: LD_ADDR_EXP 71
17411: PUSH
17412: LD_EXP 71
17416: PPUSH
17417: LD_VAR 0 1
17421: PPUSH
17422: EMPTY
17423: PPUSH
17424: CALL_OW 1
17428: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17429: LD_ADDR_EXP 72
17433: PUSH
17434: LD_EXP 72
17438: PPUSH
17439: LD_VAR 0 1
17443: PPUSH
17444: EMPTY
17445: PPUSH
17446: CALL_OW 1
17450: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17451: LD_ADDR_EXP 73
17455: PUSH
17456: LD_EXP 73
17460: PPUSH
17461: LD_VAR 0 1
17465: PPUSH
17466: EMPTY
17467: PPUSH
17468: CALL_OW 1
17472: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17473: LD_ADDR_EXP 74
17477: PUSH
17478: LD_EXP 74
17482: PPUSH
17483: LD_VAR 0 1
17487: PPUSH
17488: EMPTY
17489: PPUSH
17490: CALL_OW 1
17494: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17495: LD_ADDR_EXP 76
17499: PUSH
17500: LD_EXP 76
17504: PPUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: EMPTY
17511: PPUSH
17512: CALL_OW 1
17516: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17517: LD_ADDR_EXP 78
17521: PUSH
17522: LD_EXP 78
17526: PPUSH
17527: LD_VAR 0 1
17531: PPUSH
17532: EMPTY
17533: PPUSH
17534: CALL_OW 1
17538: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17539: LD_ADDR_EXP 79
17543: PUSH
17544: LD_EXP 79
17548: PPUSH
17549: LD_VAR 0 1
17553: PPUSH
17554: EMPTY
17555: PPUSH
17556: CALL_OW 1
17560: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17561: LD_ADDR_EXP 80
17565: PUSH
17566: LD_EXP 80
17570: PPUSH
17571: LD_VAR 0 1
17575: PPUSH
17576: EMPTY
17577: PPUSH
17578: CALL_OW 1
17582: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17583: LD_ADDR_EXP 81
17587: PUSH
17588: LD_EXP 81
17592: PPUSH
17593: LD_VAR 0 1
17597: PPUSH
17598: EMPTY
17599: PPUSH
17600: CALL_OW 1
17604: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
17605: LD_ADDR_EXP 82
17609: PUSH
17610: LD_EXP 82
17614: PPUSH
17615: LD_VAR 0 1
17619: PPUSH
17620: EMPTY
17621: PPUSH
17622: CALL_OW 1
17626: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
17627: LD_ADDR_EXP 83
17631: PUSH
17632: LD_EXP 83
17636: PPUSH
17637: LD_VAR 0 1
17641: PPUSH
17642: EMPTY
17643: PPUSH
17644: CALL_OW 1
17648: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
17649: LD_ADDR_EXP 84
17653: PUSH
17654: LD_EXP 84
17658: PPUSH
17659: LD_VAR 0 1
17663: PPUSH
17664: EMPTY
17665: PPUSH
17666: CALL_OW 1
17670: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
17671: LD_ADDR_EXP 85
17675: PUSH
17676: LD_EXP 85
17680: PPUSH
17681: LD_VAR 0 1
17685: PPUSH
17686: EMPTY
17687: PPUSH
17688: CALL_OW 1
17692: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
17693: LD_ADDR_EXP 86
17697: PUSH
17698: LD_EXP 86
17702: PPUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: EMPTY
17709: PPUSH
17710: CALL_OW 1
17714: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
17715: LD_ADDR_EXP 87
17719: PUSH
17720: LD_EXP 87
17724: PPUSH
17725: LD_VAR 0 1
17729: PPUSH
17730: EMPTY
17731: PPUSH
17732: CALL_OW 1
17736: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
17737: LD_ADDR_EXP 88
17741: PUSH
17742: LD_EXP 88
17746: PPUSH
17747: LD_VAR 0 1
17751: PPUSH
17752: EMPTY
17753: PPUSH
17754: CALL_OW 1
17758: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
17759: LD_ADDR_EXP 89
17763: PUSH
17764: LD_EXP 89
17768: PPUSH
17769: LD_VAR 0 1
17773: PPUSH
17774: EMPTY
17775: PPUSH
17776: CALL_OW 1
17780: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
17781: LD_ADDR_EXP 90
17785: PUSH
17786: LD_EXP 90
17790: PPUSH
17791: LD_VAR 0 1
17795: PPUSH
17796: EMPTY
17797: PPUSH
17798: CALL_OW 1
17802: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
17803: LD_ADDR_EXP 91
17807: PUSH
17808: LD_EXP 91
17812: PPUSH
17813: LD_VAR 0 1
17817: PPUSH
17818: LD_INT 0
17820: PPUSH
17821: CALL_OW 1
17825: ST_TO_ADDR
// end ;
17826: LD_VAR 0 2
17830: RET
// export function MC_Start ( ) ; var i ; begin
17831: LD_INT 0
17833: PPUSH
17834: PPUSH
// for i = 1 to mc_bases do
17835: LD_ADDR_VAR 0 2
17839: PUSH
17840: DOUBLE
17841: LD_INT 1
17843: DEC
17844: ST_TO_ADDR
17845: LD_EXP 49
17849: PUSH
17850: FOR_TO
17851: IFFALSE 18928
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
17853: LD_ADDR_EXP 49
17857: PUSH
17858: LD_EXP 49
17862: PPUSH
17863: LD_VAR 0 2
17867: PPUSH
17868: LD_EXP 49
17872: PUSH
17873: LD_VAR 0 2
17877: ARRAY
17878: PUSH
17879: LD_INT 0
17881: DIFF
17882: PPUSH
17883: CALL_OW 1
17887: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
17888: LD_ADDR_EXP 50
17892: PUSH
17893: LD_EXP 50
17897: PPUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: EMPTY
17904: PPUSH
17905: CALL_OW 1
17909: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
17910: LD_ADDR_EXP 51
17914: PUSH
17915: LD_EXP 51
17919: PPUSH
17920: LD_VAR 0 2
17924: PPUSH
17925: EMPTY
17926: PPUSH
17927: CALL_OW 1
17931: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
17932: LD_ADDR_EXP 52
17936: PUSH
17937: LD_EXP 52
17941: PPUSH
17942: LD_VAR 0 2
17946: PPUSH
17947: EMPTY
17948: PPUSH
17949: CALL_OW 1
17953: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
17954: LD_ADDR_EXP 53
17958: PUSH
17959: LD_EXP 53
17963: PPUSH
17964: LD_VAR 0 2
17968: PPUSH
17969: EMPTY
17970: PUSH
17971: EMPTY
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: PPUSH
17977: CALL_OW 1
17981: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
17982: LD_ADDR_EXP 54
17986: PUSH
17987: LD_EXP 54
17991: PPUSH
17992: LD_VAR 0 2
17996: PPUSH
17997: EMPTY
17998: PPUSH
17999: CALL_OW 1
18003: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
18004: LD_ADDR_EXP 81
18008: PUSH
18009: LD_EXP 81
18013: PPUSH
18014: LD_VAR 0 2
18018: PPUSH
18019: EMPTY
18020: PPUSH
18021: CALL_OW 1
18025: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
18026: LD_ADDR_EXP 55
18030: PUSH
18031: LD_EXP 55
18035: PPUSH
18036: LD_VAR 0 2
18040: PPUSH
18041: EMPTY
18042: PPUSH
18043: CALL_OW 1
18047: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
18048: LD_ADDR_EXP 56
18052: PUSH
18053: LD_EXP 56
18057: PPUSH
18058: LD_VAR 0 2
18062: PPUSH
18063: EMPTY
18064: PPUSH
18065: CALL_OW 1
18069: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
18070: LD_ADDR_EXP 57
18074: PUSH
18075: LD_EXP 57
18079: PPUSH
18080: LD_VAR 0 2
18084: PPUSH
18085: LD_EXP 49
18089: PUSH
18090: LD_VAR 0 2
18094: ARRAY
18095: PPUSH
18096: LD_INT 2
18098: PUSH
18099: LD_INT 30
18101: PUSH
18102: LD_INT 32
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PUSH
18109: LD_INT 30
18111: PUSH
18112: LD_INT 33
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: LIST
18123: PPUSH
18124: CALL_OW 72
18128: PPUSH
18129: CALL_OW 1
18133: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
18134: LD_ADDR_EXP 58
18138: PUSH
18139: LD_EXP 58
18143: PPUSH
18144: LD_VAR 0 2
18148: PPUSH
18149: LD_EXP 49
18153: PUSH
18154: LD_VAR 0 2
18158: ARRAY
18159: PPUSH
18160: LD_INT 2
18162: PUSH
18163: LD_INT 30
18165: PUSH
18166: LD_INT 32
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: PUSH
18173: LD_INT 30
18175: PUSH
18176: LD_INT 31
18178: PUSH
18179: EMPTY
18180: LIST
18181: LIST
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: LIST
18187: PUSH
18188: LD_INT 58
18190: PUSH
18191: EMPTY
18192: LIST
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: PPUSH
18198: CALL_OW 72
18202: PPUSH
18203: CALL_OW 1
18207: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
18208: LD_ADDR_EXP 59
18212: PUSH
18213: LD_EXP 59
18217: PPUSH
18218: LD_VAR 0 2
18222: PPUSH
18223: EMPTY
18224: PPUSH
18225: CALL_OW 1
18229: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
18230: LD_ADDR_EXP 63
18234: PUSH
18235: LD_EXP 63
18239: PPUSH
18240: LD_VAR 0 2
18244: PPUSH
18245: EMPTY
18246: PPUSH
18247: CALL_OW 1
18251: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
18252: LD_ADDR_EXP 62
18256: PUSH
18257: LD_EXP 62
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: EMPTY
18268: PPUSH
18269: CALL_OW 1
18273: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
18274: LD_ADDR_EXP 64
18278: PUSH
18279: LD_EXP 64
18283: PPUSH
18284: LD_VAR 0 2
18288: PPUSH
18289: EMPTY
18290: PPUSH
18291: CALL_OW 1
18295: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
18296: LD_ADDR_EXP 65
18300: PUSH
18301: LD_EXP 65
18305: PPUSH
18306: LD_VAR 0 2
18310: PPUSH
18311: EMPTY
18312: PPUSH
18313: CALL_OW 1
18317: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
18318: LD_ADDR_EXP 66
18322: PUSH
18323: LD_EXP 66
18327: PPUSH
18328: LD_VAR 0 2
18332: PPUSH
18333: EMPTY
18334: PPUSH
18335: CALL_OW 1
18339: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
18340: LD_ADDR_EXP 67
18344: PUSH
18345: LD_EXP 67
18349: PPUSH
18350: LD_VAR 0 2
18354: PPUSH
18355: EMPTY
18356: PPUSH
18357: CALL_OW 1
18361: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
18362: LD_ADDR_EXP 68
18366: PUSH
18367: LD_EXP 68
18371: PPUSH
18372: LD_VAR 0 2
18376: PPUSH
18377: EMPTY
18378: PPUSH
18379: CALL_OW 1
18383: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
18384: LD_ADDR_EXP 69
18388: PUSH
18389: LD_EXP 69
18393: PPUSH
18394: LD_VAR 0 2
18398: PPUSH
18399: EMPTY
18400: PPUSH
18401: CALL_OW 1
18405: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
18406: LD_ADDR_EXP 70
18410: PUSH
18411: LD_EXP 70
18415: PPUSH
18416: LD_VAR 0 2
18420: PPUSH
18421: EMPTY
18422: PPUSH
18423: CALL_OW 1
18427: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
18428: LD_ADDR_EXP 71
18432: PUSH
18433: LD_EXP 71
18437: PPUSH
18438: LD_VAR 0 2
18442: PPUSH
18443: EMPTY
18444: PPUSH
18445: CALL_OW 1
18449: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
18450: LD_ADDR_EXP 60
18454: PUSH
18455: LD_EXP 60
18459: PPUSH
18460: LD_VAR 0 2
18464: PPUSH
18465: LD_INT 0
18467: PPUSH
18468: CALL_OW 1
18472: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
18473: LD_ADDR_EXP 73
18477: PUSH
18478: LD_EXP 73
18482: PPUSH
18483: LD_VAR 0 2
18487: PPUSH
18488: LD_INT 0
18490: PPUSH
18491: CALL_OW 1
18495: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
18496: LD_ADDR_EXP 61
18500: PUSH
18501: LD_EXP 61
18505: PPUSH
18506: LD_VAR 0 2
18510: PPUSH
18511: EMPTY
18512: PPUSH
18513: CALL_OW 1
18517: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
18518: LD_ADDR_EXP 72
18522: PUSH
18523: LD_EXP 72
18527: PPUSH
18528: LD_VAR 0 2
18532: PPUSH
18533: LD_INT 0
18535: PPUSH
18536: CALL_OW 1
18540: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
18541: LD_ADDR_EXP 74
18545: PUSH
18546: LD_EXP 74
18550: PPUSH
18551: LD_VAR 0 2
18555: PPUSH
18556: EMPTY
18557: PPUSH
18558: CALL_OW 1
18562: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
18563: LD_ADDR_EXP 77
18567: PUSH
18568: LD_EXP 77
18572: PPUSH
18573: LD_VAR 0 2
18577: PPUSH
18578: LD_INT 0
18580: PPUSH
18581: CALL_OW 1
18585: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
18586: LD_ADDR_EXP 78
18590: PUSH
18591: LD_EXP 78
18595: PPUSH
18596: LD_VAR 0 2
18600: PPUSH
18601: EMPTY
18602: PPUSH
18603: CALL_OW 1
18607: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
18608: LD_ADDR_EXP 79
18612: PUSH
18613: LD_EXP 79
18617: PPUSH
18618: LD_VAR 0 2
18622: PPUSH
18623: EMPTY
18624: PPUSH
18625: CALL_OW 1
18629: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
18630: LD_ADDR_EXP 80
18634: PUSH
18635: LD_EXP 80
18639: PPUSH
18640: LD_VAR 0 2
18644: PPUSH
18645: EMPTY
18646: PPUSH
18647: CALL_OW 1
18651: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
18652: LD_ADDR_EXP 82
18656: PUSH
18657: LD_EXP 82
18661: PPUSH
18662: LD_VAR 0 2
18666: PPUSH
18667: LD_EXP 49
18671: PUSH
18672: LD_VAR 0 2
18676: ARRAY
18677: PPUSH
18678: LD_INT 2
18680: PUSH
18681: LD_INT 30
18683: PUSH
18684: LD_INT 6
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 30
18693: PUSH
18694: LD_INT 7
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: LD_INT 30
18703: PUSH
18704: LD_INT 8
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: LIST
18715: LIST
18716: PPUSH
18717: CALL_OW 72
18721: PPUSH
18722: CALL_OW 1
18726: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
18727: LD_ADDR_EXP 83
18731: PUSH
18732: LD_EXP 83
18736: PPUSH
18737: LD_VAR 0 2
18741: PPUSH
18742: EMPTY
18743: PPUSH
18744: CALL_OW 1
18748: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
18749: LD_ADDR_EXP 84
18753: PUSH
18754: LD_EXP 84
18758: PPUSH
18759: LD_VAR 0 2
18763: PPUSH
18764: EMPTY
18765: PPUSH
18766: CALL_OW 1
18770: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
18771: LD_ADDR_EXP 85
18775: PUSH
18776: LD_EXP 85
18780: PPUSH
18781: LD_VAR 0 2
18785: PPUSH
18786: EMPTY
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
18793: LD_ADDR_EXP 86
18797: PUSH
18798: LD_EXP 86
18802: PPUSH
18803: LD_VAR 0 2
18807: PPUSH
18808: EMPTY
18809: PPUSH
18810: CALL_OW 1
18814: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
18815: LD_ADDR_EXP 87
18819: PUSH
18820: LD_EXP 87
18824: PPUSH
18825: LD_VAR 0 2
18829: PPUSH
18830: EMPTY
18831: PPUSH
18832: CALL_OW 1
18836: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
18837: LD_ADDR_EXP 88
18841: PUSH
18842: LD_EXP 88
18846: PPUSH
18847: LD_VAR 0 2
18851: PPUSH
18852: EMPTY
18853: PPUSH
18854: CALL_OW 1
18858: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
18859: LD_ADDR_EXP 89
18863: PUSH
18864: LD_EXP 89
18868: PPUSH
18869: LD_VAR 0 2
18873: PPUSH
18874: EMPTY
18875: PPUSH
18876: CALL_OW 1
18880: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
18881: LD_ADDR_EXP 90
18885: PUSH
18886: LD_EXP 90
18890: PPUSH
18891: LD_VAR 0 2
18895: PPUSH
18896: EMPTY
18897: PPUSH
18898: CALL_OW 1
18902: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
18903: LD_ADDR_EXP 91
18907: PUSH
18908: LD_EXP 91
18912: PPUSH
18913: LD_VAR 0 2
18917: PPUSH
18918: LD_INT 0
18920: PPUSH
18921: CALL_OW 1
18925: ST_TO_ADDR
// end ;
18926: GO 17850
18928: POP
18929: POP
// MC_InitSides ( ) ;
18930: CALL 19216 0 0
// MC_InitResearch ( ) ;
18934: CALL 18955 0 0
// CustomInitMacro ( ) ;
18938: CALL 285 0 0
// skirmish := true ;
18942: LD_ADDR_EXP 47
18946: PUSH
18947: LD_INT 1
18949: ST_TO_ADDR
// end ;
18950: LD_VAR 0 1
18954: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
18955: LD_INT 0
18957: PPUSH
18958: PPUSH
18959: PPUSH
18960: PPUSH
18961: PPUSH
18962: PPUSH
// if not mc_bases then
18963: LD_EXP 49
18967: NOT
18968: IFFALSE 18972
// exit ;
18970: GO 19211
// for i = 1 to 8 do
18972: LD_ADDR_VAR 0 2
18976: PUSH
18977: DOUBLE
18978: LD_INT 1
18980: DEC
18981: ST_TO_ADDR
18982: LD_INT 8
18984: PUSH
18985: FOR_TO
18986: IFFALSE 19012
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
18988: LD_ADDR_EXP 76
18992: PUSH
18993: LD_EXP 76
18997: PPUSH
18998: LD_VAR 0 2
19002: PPUSH
19003: EMPTY
19004: PPUSH
19005: CALL_OW 1
19009: ST_TO_ADDR
19010: GO 18985
19012: POP
19013: POP
// tmp := [ ] ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: EMPTY
19020: ST_TO_ADDR
// for i = 1 to mc_sides do
19021: LD_ADDR_VAR 0 2
19025: PUSH
19026: DOUBLE
19027: LD_INT 1
19029: DEC
19030: ST_TO_ADDR
19031: LD_EXP 75
19035: PUSH
19036: FOR_TO
19037: IFFALSE 19095
// if not mc_sides [ i ] in tmp then
19039: LD_EXP 75
19043: PUSH
19044: LD_VAR 0 2
19048: ARRAY
19049: PUSH
19050: LD_VAR 0 5
19054: IN
19055: NOT
19056: IFFALSE 19093
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
19058: LD_ADDR_VAR 0 5
19062: PUSH
19063: LD_VAR 0 5
19067: PPUSH
19068: LD_VAR 0 5
19072: PUSH
19073: LD_INT 1
19075: PLUS
19076: PPUSH
19077: LD_EXP 75
19081: PUSH
19082: LD_VAR 0 2
19086: ARRAY
19087: PPUSH
19088: CALL_OW 2
19092: ST_TO_ADDR
19093: GO 19036
19095: POP
19096: POP
// if not tmp then
19097: LD_VAR 0 5
19101: NOT
19102: IFFALSE 19106
// exit ;
19104: GO 19211
// for j in tmp do
19106: LD_ADDR_VAR 0 3
19110: PUSH
19111: LD_VAR 0 5
19115: PUSH
19116: FOR_IN
19117: IFFALSE 19209
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
19119: LD_ADDR_VAR 0 6
19123: PUSH
19124: LD_INT 22
19126: PUSH
19127: LD_VAR 0 3
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: PPUSH
19136: CALL_OW 69
19140: ST_TO_ADDR
// if not un then
19141: LD_VAR 0 6
19145: NOT
19146: IFFALSE 19150
// continue ;
19148: GO 19116
// nation := GetNation ( un [ 1 ] ) ;
19150: LD_ADDR_VAR 0 4
19154: PUSH
19155: LD_VAR 0 6
19159: PUSH
19160: LD_INT 1
19162: ARRAY
19163: PPUSH
19164: CALL_OW 248
19168: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
19169: LD_ADDR_EXP 76
19173: PUSH
19174: LD_EXP 76
19178: PPUSH
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 3
19188: PPUSH
19189: LD_VAR 0 4
19193: PPUSH
19194: LD_INT 1
19196: PPUSH
19197: CALL 44993 0 3
19201: PPUSH
19202: CALL_OW 1
19206: ST_TO_ADDR
// end ;
19207: GO 19116
19209: POP
19210: POP
// end ;
19211: LD_VAR 0 1
19215: RET
// export function MC_InitSides ( ) ; var i ; begin
19216: LD_INT 0
19218: PPUSH
19219: PPUSH
// if not mc_bases then
19220: LD_EXP 49
19224: NOT
19225: IFFALSE 19229
// exit ;
19227: GO 19303
// for i = 1 to mc_bases do
19229: LD_ADDR_VAR 0 2
19233: PUSH
19234: DOUBLE
19235: LD_INT 1
19237: DEC
19238: ST_TO_ADDR
19239: LD_EXP 49
19243: PUSH
19244: FOR_TO
19245: IFFALSE 19301
// if mc_bases [ i ] then
19247: LD_EXP 49
19251: PUSH
19252: LD_VAR 0 2
19256: ARRAY
19257: IFFALSE 19299
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
19259: LD_ADDR_EXP 75
19263: PUSH
19264: LD_EXP 75
19268: PPUSH
19269: LD_VAR 0 2
19273: PPUSH
19274: LD_EXP 49
19278: PUSH
19279: LD_VAR 0 2
19283: ARRAY
19284: PUSH
19285: LD_INT 1
19287: ARRAY
19288: PPUSH
19289: CALL_OW 255
19293: PPUSH
19294: CALL_OW 1
19298: ST_TO_ADDR
19299: GO 19244
19301: POP
19302: POP
// end ;
19303: LD_VAR 0 1
19307: RET
// every 0 0$01 trigger skirmish do
19308: LD_EXP 47
19312: IFFALSE 19466
19314: GO 19316
19316: DISABLE
// begin enable ;
19317: ENABLE
// MC_CheckBuildings ( ) ;
19318: CALL 23955 0 0
// MC_CheckPeopleLife ( ) ;
19322: CALL 24080 0 0
// RaiseSailEvent ( 100 ) ;
19326: LD_INT 100
19328: PPUSH
19329: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
19333: LD_INT 103
19335: PPUSH
19336: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
19340: LD_INT 104
19342: PPUSH
19343: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
19347: LD_INT 105
19349: PPUSH
19350: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
19354: LD_INT 106
19356: PPUSH
19357: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
19361: LD_INT 107
19363: PPUSH
19364: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
19368: LD_INT 108
19370: PPUSH
19371: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
19375: LD_INT 109
19377: PPUSH
19378: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
19382: LD_INT 110
19384: PPUSH
19385: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
19389: LD_INT 111
19391: PPUSH
19392: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
19396: LD_INT 112
19398: PPUSH
19399: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
19403: LD_INT 113
19405: PPUSH
19406: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
19410: LD_INT 120
19412: PPUSH
19413: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
19417: LD_INT 121
19419: PPUSH
19420: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
19424: LD_INT 122
19426: PPUSH
19427: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
19431: LD_INT 123
19433: PPUSH
19434: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
19438: LD_INT 124
19440: PPUSH
19441: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
19445: LD_INT 125
19447: PPUSH
19448: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
19452: LD_INT 126
19454: PPUSH
19455: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
19459: LD_INT 200
19461: PPUSH
19462: CALL_OW 427
// end ;
19466: END
// on SailEvent ( event ) do begin if event < 100 then
19467: LD_VAR 0 1
19471: PUSH
19472: LD_INT 100
19474: LESS
19475: IFFALSE 19486
// CustomEvent ( event ) ;
19477: LD_VAR 0 1
19481: PPUSH
19482: CALL 15985 0 1
// if event = 100 then
19486: LD_VAR 0 1
19490: PUSH
19491: LD_INT 100
19493: EQUAL
19494: IFFALSE 19500
// MC_ClassManager ( ) ;
19496: CALL 19892 0 0
// if event = 101 then
19500: LD_VAR 0 1
19504: PUSH
19505: LD_INT 101
19507: EQUAL
19508: IFFALSE 19514
// MC_RepairBuildings ( ) ;
19510: CALL 24676 0 0
// if event = 102 then
19514: LD_VAR 0 1
19518: PUSH
19519: LD_INT 102
19521: EQUAL
19522: IFFALSE 19528
// MC_Heal ( ) ;
19524: CALL 25082 0 0
// if event = 103 then
19528: LD_VAR 0 1
19532: PUSH
19533: LD_INT 103
19535: EQUAL
19536: IFFALSE 19542
// MC_Build ( ) ;
19538: CALL 25504 0 0
// if event = 104 then
19542: LD_VAR 0 1
19546: PUSH
19547: LD_INT 104
19549: EQUAL
19550: IFFALSE 19556
// MC_TurretWeapon ( ) ;
19552: CALL 27117 0 0
// if event = 105 then
19556: LD_VAR 0 1
19560: PUSH
19561: LD_INT 105
19563: EQUAL
19564: IFFALSE 19570
// MC_BuildUpgrade ( ) ;
19566: CALL 26668 0 0
// if event = 106 then
19570: LD_VAR 0 1
19574: PUSH
19575: LD_INT 106
19577: EQUAL
19578: IFFALSE 19584
// MC_PlantMines ( ) ;
19580: CALL 27547 0 0
// if event = 107 then
19584: LD_VAR 0 1
19588: PUSH
19589: LD_INT 107
19591: EQUAL
19592: IFFALSE 19598
// MC_CollectCrates ( ) ;
19594: CALL 28581 0 0
// if event = 108 then
19598: LD_VAR 0 1
19602: PUSH
19603: LD_INT 108
19605: EQUAL
19606: IFFALSE 19612
// MC_LinkRemoteControl ( ) ;
19608: CALL 30338 0 0
// if event = 109 then
19612: LD_VAR 0 1
19616: PUSH
19617: LD_INT 109
19619: EQUAL
19620: IFFALSE 19626
// MC_ProduceVehicle ( ) ;
19622: CALL 30519 0 0
// if event = 110 then
19626: LD_VAR 0 1
19630: PUSH
19631: LD_INT 110
19633: EQUAL
19634: IFFALSE 19640
// MC_SendAttack ( ) ;
19636: CALL 31000 0 0
// if event = 111 then
19640: LD_VAR 0 1
19644: PUSH
19645: LD_INT 111
19647: EQUAL
19648: IFFALSE 19654
// MC_Defend ( ) ;
19650: CALL 31108 0 0
// if event = 112 then
19654: LD_VAR 0 1
19658: PUSH
19659: LD_INT 112
19661: EQUAL
19662: IFFALSE 19668
// MC_Research ( ) ;
19664: CALL 31735 0 0
// if event = 113 then
19668: LD_VAR 0 1
19672: PUSH
19673: LD_INT 113
19675: EQUAL
19676: IFFALSE 19682
// MC_MinesTrigger ( ) ;
19678: CALL 32849 0 0
// if event = 120 then
19682: LD_VAR 0 1
19686: PUSH
19687: LD_INT 120
19689: EQUAL
19690: IFFALSE 19696
// MC_RepairVehicle ( ) ;
19692: CALL 32948 0 0
// if event = 121 then
19696: LD_VAR 0 1
19700: PUSH
19701: LD_INT 121
19703: EQUAL
19704: IFFALSE 19710
// MC_TameApe ( ) ;
19706: CALL 33691 0 0
// if event = 122 then
19710: LD_VAR 0 1
19714: PUSH
19715: LD_INT 122
19717: EQUAL
19718: IFFALSE 19724
// MC_ChangeApeClass ( ) ;
19720: CALL 34520 0 0
// if event = 123 then
19724: LD_VAR 0 1
19728: PUSH
19729: LD_INT 123
19731: EQUAL
19732: IFFALSE 19738
// MC_Bazooka ( ) ;
19734: CALL 35170 0 0
// if event = 124 then
19738: LD_VAR 0 1
19742: PUSH
19743: LD_INT 124
19745: EQUAL
19746: IFFALSE 19752
// MC_TeleportExit ( ) ;
19748: CALL 35368 0 0
// if event = 125 then
19752: LD_VAR 0 1
19756: PUSH
19757: LD_INT 125
19759: EQUAL
19760: IFFALSE 19766
// MC_Deposits ( ) ;
19762: CALL 36015 0 0
// if event = 126 then
19766: LD_VAR 0 1
19770: PUSH
19771: LD_INT 126
19773: EQUAL
19774: IFFALSE 19780
// MC_RemoteDriver ( ) ;
19776: CALL 36640 0 0
// if event = 200 then
19780: LD_VAR 0 1
19784: PUSH
19785: LD_INT 200
19787: EQUAL
19788: IFFALSE 19794
// MC_Idle ( ) ;
19790: CALL 38373 0 0
// end ;
19794: PPOPN 1
19796: END
// export function MC_Reset ( base , tag ) ; var i ; begin
19797: LD_INT 0
19799: PPUSH
19800: PPUSH
// if not mc_bases [ base ] or not tag then
19801: LD_EXP 49
19805: PUSH
19806: LD_VAR 0 1
19810: ARRAY
19811: NOT
19812: PUSH
19813: LD_VAR 0 2
19817: NOT
19818: OR
19819: IFFALSE 19823
// exit ;
19821: GO 19887
// for i in mc_bases [ base ] union mc_ape [ base ] do
19823: LD_ADDR_VAR 0 4
19827: PUSH
19828: LD_EXP 49
19832: PUSH
19833: LD_VAR 0 1
19837: ARRAY
19838: PUSH
19839: LD_EXP 78
19843: PUSH
19844: LD_VAR 0 1
19848: ARRAY
19849: UNION
19850: PUSH
19851: FOR_IN
19852: IFFALSE 19885
// if GetTag ( i ) = tag then
19854: LD_VAR 0 4
19858: PPUSH
19859: CALL_OW 110
19863: PUSH
19864: LD_VAR 0 2
19868: EQUAL
19869: IFFALSE 19883
// SetTag ( i , 0 ) ;
19871: LD_VAR 0 4
19875: PPUSH
19876: LD_INT 0
19878: PPUSH
19879: CALL_OW 109
19883: GO 19851
19885: POP
19886: POP
// end ;
19887: LD_VAR 0 3
19891: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
19892: LD_INT 0
19894: PPUSH
19895: PPUSH
19896: PPUSH
19897: PPUSH
19898: PPUSH
19899: PPUSH
19900: PPUSH
19901: PPUSH
// if not mc_bases then
19902: LD_EXP 49
19906: NOT
19907: IFFALSE 19911
// exit ;
19909: GO 20369
// for i = 1 to mc_bases do
19911: LD_ADDR_VAR 0 2
19915: PUSH
19916: DOUBLE
19917: LD_INT 1
19919: DEC
19920: ST_TO_ADDR
19921: LD_EXP 49
19925: PUSH
19926: FOR_TO
19927: IFFALSE 20367
// begin tmp := MC_ClassCheckReq ( i ) ;
19929: LD_ADDR_VAR 0 4
19933: PUSH
19934: LD_VAR 0 2
19938: PPUSH
19939: CALL 20374 0 1
19943: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
19944: LD_ADDR_EXP 90
19948: PUSH
19949: LD_EXP 90
19953: PPUSH
19954: LD_VAR 0 2
19958: PPUSH
19959: LD_VAR 0 4
19963: PPUSH
19964: CALL_OW 1
19968: ST_TO_ADDR
// if not tmp then
19969: LD_VAR 0 4
19973: NOT
19974: IFFALSE 19978
// continue ;
19976: GO 19926
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
19978: LD_ADDR_VAR 0 6
19982: PUSH
19983: LD_EXP 49
19987: PUSH
19988: LD_VAR 0 2
19992: ARRAY
19993: PPUSH
19994: LD_INT 2
19996: PUSH
19997: LD_INT 30
19999: PUSH
20000: LD_INT 4
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: PUSH
20007: LD_INT 30
20009: PUSH
20010: LD_INT 5
20012: PUSH
20013: EMPTY
20014: LIST
20015: LIST
20016: PUSH
20017: EMPTY
20018: LIST
20019: LIST
20020: LIST
20021: PPUSH
20022: CALL_OW 72
20026: PUSH
20027: LD_EXP 49
20031: PUSH
20032: LD_VAR 0 2
20036: ARRAY
20037: PPUSH
20038: LD_INT 2
20040: PUSH
20041: LD_INT 30
20043: PUSH
20044: LD_INT 0
20046: PUSH
20047: EMPTY
20048: LIST
20049: LIST
20050: PUSH
20051: LD_INT 30
20053: PUSH
20054: LD_INT 1
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: LIST
20065: PPUSH
20066: CALL_OW 72
20070: PUSH
20071: LD_EXP 49
20075: PUSH
20076: LD_VAR 0 2
20080: ARRAY
20081: PPUSH
20082: LD_INT 30
20084: PUSH
20085: LD_INT 3
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: PPUSH
20092: CALL_OW 72
20096: PUSH
20097: LD_EXP 49
20101: PUSH
20102: LD_VAR 0 2
20106: ARRAY
20107: PPUSH
20108: LD_INT 2
20110: PUSH
20111: LD_INT 30
20113: PUSH
20114: LD_INT 6
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: LD_INT 30
20123: PUSH
20124: LD_INT 7
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: PUSH
20131: LD_INT 30
20133: PUSH
20134: LD_INT 8
20136: PUSH
20137: EMPTY
20138: LIST
20139: LIST
20140: PUSH
20141: EMPTY
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: PPUSH
20147: CALL_OW 72
20151: PUSH
20152: EMPTY
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: ST_TO_ADDR
// for j = 1 to 4 do
20158: LD_ADDR_VAR 0 3
20162: PUSH
20163: DOUBLE
20164: LD_INT 1
20166: DEC
20167: ST_TO_ADDR
20168: LD_INT 4
20170: PUSH
20171: FOR_TO
20172: IFFALSE 20363
// begin if not tmp [ j ] then
20174: LD_VAR 0 4
20178: PUSH
20179: LD_VAR 0 3
20183: ARRAY
20184: NOT
20185: IFFALSE 20189
// continue ;
20187: GO 20171
// for p in tmp [ j ] do
20189: LD_ADDR_VAR 0 5
20193: PUSH
20194: LD_VAR 0 4
20198: PUSH
20199: LD_VAR 0 3
20203: ARRAY
20204: PUSH
20205: FOR_IN
20206: IFFALSE 20359
// begin if not b [ j ] then
20208: LD_VAR 0 6
20212: PUSH
20213: LD_VAR 0 3
20217: ARRAY
20218: NOT
20219: IFFALSE 20223
// break ;
20221: GO 20359
// e := 0 ;
20223: LD_ADDR_VAR 0 7
20227: PUSH
20228: LD_INT 0
20230: ST_TO_ADDR
// for k in b [ j ] do
20231: LD_ADDR_VAR 0 8
20235: PUSH
20236: LD_VAR 0 6
20240: PUSH
20241: LD_VAR 0 3
20245: ARRAY
20246: PUSH
20247: FOR_IN
20248: IFFALSE 20275
// if IsNotFull ( k ) then
20250: LD_VAR 0 8
20254: PPUSH
20255: CALL 49019 0 1
20259: IFFALSE 20273
// begin e := k ;
20261: LD_ADDR_VAR 0 7
20265: PUSH
20266: LD_VAR 0 8
20270: ST_TO_ADDR
// break ;
20271: GO 20275
// end ;
20273: GO 20247
20275: POP
20276: POP
// if e and not UnitGoingToBuilding ( p , e ) then
20277: LD_VAR 0 7
20281: PUSH
20282: LD_VAR 0 5
20286: PPUSH
20287: LD_VAR 0 7
20291: PPUSH
20292: CALL 86007 0 2
20296: NOT
20297: AND
20298: IFFALSE 20357
// begin if IsInUnit ( p ) then
20300: LD_VAR 0 5
20304: PPUSH
20305: CALL_OW 310
20309: IFFALSE 20320
// ComExitBuilding ( p ) ;
20311: LD_VAR 0 5
20315: PPUSH
20316: CALL_OW 122
// ComEnterUnit ( p , e ) ;
20320: LD_VAR 0 5
20324: PPUSH
20325: LD_VAR 0 7
20329: PPUSH
20330: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
20334: LD_VAR 0 5
20338: PPUSH
20339: LD_VAR 0 3
20343: PPUSH
20344: CALL_OW 183
// AddComExitBuilding ( p ) ;
20348: LD_VAR 0 5
20352: PPUSH
20353: CALL_OW 182
// end ; end ;
20357: GO 20205
20359: POP
20360: POP
// end ;
20361: GO 20171
20363: POP
20364: POP
// end ;
20365: GO 19926
20367: POP
20368: POP
// end ;
20369: LD_VAR 0 1
20373: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
20374: LD_INT 0
20376: PPUSH
20377: PPUSH
20378: PPUSH
20379: PPUSH
20380: PPUSH
20381: PPUSH
20382: PPUSH
20383: PPUSH
20384: PPUSH
20385: PPUSH
20386: PPUSH
20387: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
20388: LD_VAR 0 1
20392: NOT
20393: PUSH
20394: LD_EXP 49
20398: PUSH
20399: LD_VAR 0 1
20403: ARRAY
20404: NOT
20405: OR
20406: PUSH
20407: LD_EXP 49
20411: PUSH
20412: LD_VAR 0 1
20416: ARRAY
20417: PPUSH
20418: LD_INT 2
20420: PUSH
20421: LD_INT 30
20423: PUSH
20424: LD_INT 0
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 1
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: PPUSH
20446: CALL_OW 72
20450: NOT
20451: OR
20452: IFFALSE 20456
// exit ;
20454: GO 23950
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20456: LD_ADDR_VAR 0 4
20460: PUSH
20461: LD_EXP 49
20465: PUSH
20466: LD_VAR 0 1
20470: ARRAY
20471: PPUSH
20472: LD_INT 2
20474: PUSH
20475: LD_INT 25
20477: PUSH
20478: LD_INT 1
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PUSH
20485: LD_INT 25
20487: PUSH
20488: LD_INT 2
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 25
20497: PUSH
20498: LD_INT 3
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 25
20507: PUSH
20508: LD_INT 4
20510: PUSH
20511: EMPTY
20512: LIST
20513: LIST
20514: PUSH
20515: LD_INT 25
20517: PUSH
20518: LD_INT 5
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: PUSH
20525: LD_INT 25
20527: PUSH
20528: LD_INT 8
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 25
20537: PUSH
20538: LD_INT 9
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: PPUSH
20555: CALL_OW 72
20559: ST_TO_ADDR
// for i in tmp do
20560: LD_ADDR_VAR 0 3
20564: PUSH
20565: LD_VAR 0 4
20569: PUSH
20570: FOR_IN
20571: IFFALSE 20602
// if GetTag ( i ) then
20573: LD_VAR 0 3
20577: PPUSH
20578: CALL_OW 110
20582: IFFALSE 20600
// tmp := tmp diff i ;
20584: LD_ADDR_VAR 0 4
20588: PUSH
20589: LD_VAR 0 4
20593: PUSH
20594: LD_VAR 0 3
20598: DIFF
20599: ST_TO_ADDR
20600: GO 20570
20602: POP
20603: POP
// if not tmp then
20604: LD_VAR 0 4
20608: NOT
20609: IFFALSE 20613
// exit ;
20611: GO 23950
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20613: LD_ADDR_VAR 0 5
20617: PUSH
20618: LD_EXP 49
20622: PUSH
20623: LD_VAR 0 1
20627: ARRAY
20628: PPUSH
20629: LD_INT 2
20631: PUSH
20632: LD_INT 25
20634: PUSH
20635: LD_INT 1
20637: PUSH
20638: EMPTY
20639: LIST
20640: LIST
20641: PUSH
20642: LD_INT 25
20644: PUSH
20645: LD_INT 5
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: PUSH
20652: LD_INT 25
20654: PUSH
20655: LD_INT 8
20657: PUSH
20658: EMPTY
20659: LIST
20660: LIST
20661: PUSH
20662: LD_INT 25
20664: PUSH
20665: LD_INT 9
20667: PUSH
20668: EMPTY
20669: LIST
20670: LIST
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: PPUSH
20679: CALL_OW 72
20683: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
20684: LD_ADDR_VAR 0 6
20688: PUSH
20689: LD_EXP 49
20693: PUSH
20694: LD_VAR 0 1
20698: ARRAY
20699: PPUSH
20700: LD_INT 25
20702: PUSH
20703: LD_INT 2
20705: PUSH
20706: EMPTY
20707: LIST
20708: LIST
20709: PPUSH
20710: CALL_OW 72
20714: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
20715: LD_ADDR_VAR 0 7
20719: PUSH
20720: LD_EXP 49
20724: PUSH
20725: LD_VAR 0 1
20729: ARRAY
20730: PPUSH
20731: LD_INT 25
20733: PUSH
20734: LD_INT 3
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PPUSH
20741: CALL_OW 72
20745: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
20746: LD_ADDR_VAR 0 8
20750: PUSH
20751: LD_EXP 49
20755: PUSH
20756: LD_VAR 0 1
20760: ARRAY
20761: PPUSH
20762: LD_INT 25
20764: PUSH
20765: LD_INT 4
20767: PUSH
20768: EMPTY
20769: LIST
20770: LIST
20771: PUSH
20772: LD_INT 24
20774: PUSH
20775: LD_INT 251
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: PUSH
20782: EMPTY
20783: LIST
20784: LIST
20785: PPUSH
20786: CALL_OW 72
20790: ST_TO_ADDR
// if mc_scan [ base ] then
20791: LD_EXP 72
20795: PUSH
20796: LD_VAR 0 1
20800: ARRAY
20801: IFFALSE 21262
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
20803: LD_ADDR_EXP 91
20807: PUSH
20808: LD_EXP 91
20812: PPUSH
20813: LD_VAR 0 1
20817: PPUSH
20818: LD_INT 4
20820: PPUSH
20821: CALL_OW 1
20825: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
20826: LD_ADDR_VAR 0 12
20830: PUSH
20831: LD_EXP 49
20835: PUSH
20836: LD_VAR 0 1
20840: ARRAY
20841: PPUSH
20842: LD_INT 2
20844: PUSH
20845: LD_INT 30
20847: PUSH
20848: LD_INT 4
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: PUSH
20855: LD_INT 30
20857: PUSH
20858: LD_INT 5
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: LIST
20869: PPUSH
20870: CALL_OW 72
20874: ST_TO_ADDR
// if not b then
20875: LD_VAR 0 12
20879: NOT
20880: IFFALSE 20884
// exit ;
20882: GO 23950
// p := [ ] ;
20884: LD_ADDR_VAR 0 11
20888: PUSH
20889: EMPTY
20890: ST_TO_ADDR
// if sci >= 2 then
20891: LD_VAR 0 8
20895: PUSH
20896: LD_INT 2
20898: GREATEREQUAL
20899: IFFALSE 20930
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
20901: LD_ADDR_VAR 0 8
20905: PUSH
20906: LD_VAR 0 8
20910: PUSH
20911: LD_INT 1
20913: ARRAY
20914: PUSH
20915: LD_VAR 0 8
20919: PUSH
20920: LD_INT 2
20922: ARRAY
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: ST_TO_ADDR
20928: GO 20991
// if sci = 1 then
20930: LD_VAR 0 8
20934: PUSH
20935: LD_INT 1
20937: EQUAL
20938: IFFALSE 20959
// sci := [ sci [ 1 ] ] else
20940: LD_ADDR_VAR 0 8
20944: PUSH
20945: LD_VAR 0 8
20949: PUSH
20950: LD_INT 1
20952: ARRAY
20953: PUSH
20954: EMPTY
20955: LIST
20956: ST_TO_ADDR
20957: GO 20991
// if sci = 0 then
20959: LD_VAR 0 8
20963: PUSH
20964: LD_INT 0
20966: EQUAL
20967: IFFALSE 20991
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
20969: LD_ADDR_VAR 0 11
20973: PUSH
20974: LD_VAR 0 4
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: CALL 85870 0 2
20986: PUSH
20987: LD_INT 1
20989: ARRAY
20990: ST_TO_ADDR
// if eng > 4 then
20991: LD_VAR 0 6
20995: PUSH
20996: LD_INT 4
20998: GREATER
20999: IFFALSE 21045
// for i = eng downto 4 do
21001: LD_ADDR_VAR 0 3
21005: PUSH
21006: DOUBLE
21007: LD_VAR 0 6
21011: INC
21012: ST_TO_ADDR
21013: LD_INT 4
21015: PUSH
21016: FOR_DOWNTO
21017: IFFALSE 21043
// eng := eng diff eng [ i ] ;
21019: LD_ADDR_VAR 0 6
21023: PUSH
21024: LD_VAR 0 6
21028: PUSH
21029: LD_VAR 0 6
21033: PUSH
21034: LD_VAR 0 3
21038: ARRAY
21039: DIFF
21040: ST_TO_ADDR
21041: GO 21016
21043: POP
21044: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
21045: LD_ADDR_VAR 0 4
21049: PUSH
21050: LD_VAR 0 4
21054: PUSH
21055: LD_VAR 0 5
21059: PUSH
21060: LD_VAR 0 6
21064: UNION
21065: PUSH
21066: LD_VAR 0 7
21070: UNION
21071: PUSH
21072: LD_VAR 0 8
21076: UNION
21077: DIFF
21078: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
21079: LD_ADDR_VAR 0 13
21083: PUSH
21084: LD_EXP 49
21088: PUSH
21089: LD_VAR 0 1
21093: ARRAY
21094: PPUSH
21095: LD_INT 2
21097: PUSH
21098: LD_INT 30
21100: PUSH
21101: LD_INT 32
21103: PUSH
21104: EMPTY
21105: LIST
21106: LIST
21107: PUSH
21108: LD_INT 30
21110: PUSH
21111: LD_INT 31
21113: PUSH
21114: EMPTY
21115: LIST
21116: LIST
21117: PUSH
21118: EMPTY
21119: LIST
21120: LIST
21121: LIST
21122: PPUSH
21123: CALL_OW 72
21127: PUSH
21128: LD_EXP 49
21132: PUSH
21133: LD_VAR 0 1
21137: ARRAY
21138: PPUSH
21139: LD_INT 2
21141: PUSH
21142: LD_INT 30
21144: PUSH
21145: LD_INT 4
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PUSH
21152: LD_INT 30
21154: PUSH
21155: LD_INT 5
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: LIST
21166: PPUSH
21167: CALL_OW 72
21171: PUSH
21172: LD_INT 6
21174: MUL
21175: PLUS
21176: ST_TO_ADDR
// if bcount < tmp then
21177: LD_VAR 0 13
21181: PUSH
21182: LD_VAR 0 4
21186: LESS
21187: IFFALSE 21233
// for i = tmp downto bcount do
21189: LD_ADDR_VAR 0 3
21193: PUSH
21194: DOUBLE
21195: LD_VAR 0 4
21199: INC
21200: ST_TO_ADDR
21201: LD_VAR 0 13
21205: PUSH
21206: FOR_DOWNTO
21207: IFFALSE 21231
// tmp := Delete ( tmp , tmp ) ;
21209: LD_ADDR_VAR 0 4
21213: PUSH
21214: LD_VAR 0 4
21218: PPUSH
21219: LD_VAR 0 4
21223: PPUSH
21224: CALL_OW 3
21228: ST_TO_ADDR
21229: GO 21206
21231: POP
21232: POP
// result := [ tmp , 0 , 0 , p ] ;
21233: LD_ADDR_VAR 0 2
21237: PUSH
21238: LD_VAR 0 4
21242: PUSH
21243: LD_INT 0
21245: PUSH
21246: LD_INT 0
21248: PUSH
21249: LD_VAR 0 11
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: LIST
21258: LIST
21259: ST_TO_ADDR
// exit ;
21260: GO 23950
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21262: LD_EXP 49
21266: PUSH
21267: LD_VAR 0 1
21271: ARRAY
21272: PPUSH
21273: LD_INT 2
21275: PUSH
21276: LD_INT 30
21278: PUSH
21279: LD_INT 6
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PUSH
21286: LD_INT 30
21288: PUSH
21289: LD_INT 7
21291: PUSH
21292: EMPTY
21293: LIST
21294: LIST
21295: PUSH
21296: LD_INT 30
21298: PUSH
21299: LD_INT 8
21301: PUSH
21302: EMPTY
21303: LIST
21304: LIST
21305: PUSH
21306: EMPTY
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: PPUSH
21312: CALL_OW 72
21316: NOT
21317: PUSH
21318: LD_EXP 49
21322: PUSH
21323: LD_VAR 0 1
21327: ARRAY
21328: PPUSH
21329: LD_INT 30
21331: PUSH
21332: LD_INT 3
21334: PUSH
21335: EMPTY
21336: LIST
21337: LIST
21338: PPUSH
21339: CALL_OW 72
21343: NOT
21344: AND
21345: IFFALSE 21417
// begin if eng = tmp then
21347: LD_VAR 0 6
21351: PUSH
21352: LD_VAR 0 4
21356: EQUAL
21357: IFFALSE 21361
// exit ;
21359: GO 23950
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
21361: LD_ADDR_EXP 91
21365: PUSH
21366: LD_EXP 91
21370: PPUSH
21371: LD_VAR 0 1
21375: PPUSH
21376: LD_INT 1
21378: PPUSH
21379: CALL_OW 1
21383: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
21384: LD_ADDR_VAR 0 2
21388: PUSH
21389: LD_INT 0
21391: PUSH
21392: LD_VAR 0 4
21396: PUSH
21397: LD_VAR 0 6
21401: DIFF
21402: PUSH
21403: LD_INT 0
21405: PUSH
21406: LD_INT 0
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: LIST
21413: LIST
21414: ST_TO_ADDR
// exit ;
21415: GO 23950
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21417: LD_EXP 76
21421: PUSH
21422: LD_EXP 75
21426: PUSH
21427: LD_VAR 0 1
21431: ARRAY
21432: ARRAY
21433: PUSH
21434: LD_EXP 49
21438: PUSH
21439: LD_VAR 0 1
21443: ARRAY
21444: PPUSH
21445: LD_INT 2
21447: PUSH
21448: LD_INT 30
21450: PUSH
21451: LD_INT 6
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: PUSH
21458: LD_INT 30
21460: PUSH
21461: LD_INT 7
21463: PUSH
21464: EMPTY
21465: LIST
21466: LIST
21467: PUSH
21468: LD_INT 30
21470: PUSH
21471: LD_INT 8
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: LIST
21482: LIST
21483: PPUSH
21484: CALL_OW 72
21488: AND
21489: PUSH
21490: LD_EXP 49
21494: PUSH
21495: LD_VAR 0 1
21499: ARRAY
21500: PPUSH
21501: LD_INT 30
21503: PUSH
21504: LD_INT 3
21506: PUSH
21507: EMPTY
21508: LIST
21509: LIST
21510: PPUSH
21511: CALL_OW 72
21515: NOT
21516: AND
21517: IFFALSE 21731
// begin if sci >= 6 then
21519: LD_VAR 0 8
21523: PUSH
21524: LD_INT 6
21526: GREATEREQUAL
21527: IFFALSE 21531
// exit ;
21529: GO 23950
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
21531: LD_ADDR_EXP 91
21535: PUSH
21536: LD_EXP 91
21540: PPUSH
21541: LD_VAR 0 1
21545: PPUSH
21546: LD_INT 2
21548: PPUSH
21549: CALL_OW 1
21553: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
21554: LD_ADDR_VAR 0 9
21558: PUSH
21559: LD_VAR 0 4
21563: PUSH
21564: LD_VAR 0 8
21568: DIFF
21569: PPUSH
21570: LD_INT 4
21572: PPUSH
21573: CALL 85870 0 2
21577: ST_TO_ADDR
// p := [ ] ;
21578: LD_ADDR_VAR 0 11
21582: PUSH
21583: EMPTY
21584: ST_TO_ADDR
// if sci < 6 and sort > 6 then
21585: LD_VAR 0 8
21589: PUSH
21590: LD_INT 6
21592: LESS
21593: PUSH
21594: LD_VAR 0 9
21598: PUSH
21599: LD_INT 6
21601: GREATER
21602: AND
21603: IFFALSE 21684
// begin for i = 1 to 6 - sci do
21605: LD_ADDR_VAR 0 3
21609: PUSH
21610: DOUBLE
21611: LD_INT 1
21613: DEC
21614: ST_TO_ADDR
21615: LD_INT 6
21617: PUSH
21618: LD_VAR 0 8
21622: MINUS
21623: PUSH
21624: FOR_TO
21625: IFFALSE 21680
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
21627: LD_ADDR_VAR 0 11
21631: PUSH
21632: LD_VAR 0 11
21636: PPUSH
21637: LD_VAR 0 11
21641: PUSH
21642: LD_INT 1
21644: PLUS
21645: PPUSH
21646: LD_VAR 0 9
21650: PUSH
21651: LD_INT 1
21653: ARRAY
21654: PPUSH
21655: CALL_OW 2
21659: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
21660: LD_ADDR_VAR 0 9
21664: PUSH
21665: LD_VAR 0 9
21669: PPUSH
21670: LD_INT 1
21672: PPUSH
21673: CALL_OW 3
21677: ST_TO_ADDR
// end ;
21678: GO 21624
21680: POP
21681: POP
// end else
21682: GO 21704
// if sort then
21684: LD_VAR 0 9
21688: IFFALSE 21704
// p := sort [ 1 ] ;
21690: LD_ADDR_VAR 0 11
21694: PUSH
21695: LD_VAR 0 9
21699: PUSH
21700: LD_INT 1
21702: ARRAY
21703: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
21704: LD_ADDR_VAR 0 2
21708: PUSH
21709: LD_INT 0
21711: PUSH
21712: LD_INT 0
21714: PUSH
21715: LD_INT 0
21717: PUSH
21718: LD_VAR 0 11
21722: PUSH
21723: EMPTY
21724: LIST
21725: LIST
21726: LIST
21727: LIST
21728: ST_TO_ADDR
// exit ;
21729: GO 23950
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21731: LD_EXP 76
21735: PUSH
21736: LD_EXP 75
21740: PUSH
21741: LD_VAR 0 1
21745: ARRAY
21746: ARRAY
21747: PUSH
21748: LD_EXP 49
21752: PUSH
21753: LD_VAR 0 1
21757: ARRAY
21758: PPUSH
21759: LD_INT 2
21761: PUSH
21762: LD_INT 30
21764: PUSH
21765: LD_INT 6
21767: PUSH
21768: EMPTY
21769: LIST
21770: LIST
21771: PUSH
21772: LD_INT 30
21774: PUSH
21775: LD_INT 7
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: PUSH
21782: LD_INT 30
21784: PUSH
21785: LD_INT 8
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: PPUSH
21798: CALL_OW 72
21802: AND
21803: PUSH
21804: LD_EXP 49
21808: PUSH
21809: LD_VAR 0 1
21813: ARRAY
21814: PPUSH
21815: LD_INT 30
21817: PUSH
21818: LD_INT 3
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: PPUSH
21825: CALL_OW 72
21829: AND
21830: IFFALSE 22564
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
21832: LD_ADDR_EXP 91
21836: PUSH
21837: LD_EXP 91
21841: PPUSH
21842: LD_VAR 0 1
21846: PPUSH
21847: LD_INT 3
21849: PPUSH
21850: CALL_OW 1
21854: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
21855: LD_ADDR_VAR 0 2
21859: PUSH
21860: LD_INT 0
21862: PUSH
21863: LD_INT 0
21865: PUSH
21866: LD_INT 0
21868: PUSH
21869: LD_INT 0
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: ST_TO_ADDR
// if not eng then
21878: LD_VAR 0 6
21882: NOT
21883: IFFALSE 21946
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
21885: LD_ADDR_VAR 0 11
21889: PUSH
21890: LD_VAR 0 4
21894: PPUSH
21895: LD_INT 2
21897: PPUSH
21898: CALL 85870 0 2
21902: PUSH
21903: LD_INT 1
21905: ARRAY
21906: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
21907: LD_ADDR_VAR 0 2
21911: PUSH
21912: LD_VAR 0 2
21916: PPUSH
21917: LD_INT 2
21919: PPUSH
21920: LD_VAR 0 11
21924: PPUSH
21925: CALL_OW 1
21929: ST_TO_ADDR
// tmp := tmp diff p ;
21930: LD_ADDR_VAR 0 4
21934: PUSH
21935: LD_VAR 0 4
21939: PUSH
21940: LD_VAR 0 11
21944: DIFF
21945: ST_TO_ADDR
// end ; if tmp and sci < 6 then
21946: LD_VAR 0 4
21950: PUSH
21951: LD_VAR 0 8
21955: PUSH
21956: LD_INT 6
21958: LESS
21959: AND
21960: IFFALSE 22148
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
21962: LD_ADDR_VAR 0 9
21966: PUSH
21967: LD_VAR 0 4
21971: PUSH
21972: LD_VAR 0 8
21976: PUSH
21977: LD_VAR 0 7
21981: UNION
21982: DIFF
21983: PPUSH
21984: LD_INT 4
21986: PPUSH
21987: CALL 85870 0 2
21991: ST_TO_ADDR
// p := [ ] ;
21992: LD_ADDR_VAR 0 11
21996: PUSH
21997: EMPTY
21998: ST_TO_ADDR
// if sort then
21999: LD_VAR 0 9
22003: IFFALSE 22119
// for i = 1 to 6 - sci do
22005: LD_ADDR_VAR 0 3
22009: PUSH
22010: DOUBLE
22011: LD_INT 1
22013: DEC
22014: ST_TO_ADDR
22015: LD_INT 6
22017: PUSH
22018: LD_VAR 0 8
22022: MINUS
22023: PUSH
22024: FOR_TO
22025: IFFALSE 22117
// begin if i = sort then
22027: LD_VAR 0 3
22031: PUSH
22032: LD_VAR 0 9
22036: EQUAL
22037: IFFALSE 22041
// break ;
22039: GO 22117
// if GetClass ( i ) = 4 then
22041: LD_VAR 0 3
22045: PPUSH
22046: CALL_OW 257
22050: PUSH
22051: LD_INT 4
22053: EQUAL
22054: IFFALSE 22058
// continue ;
22056: GO 22024
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22058: LD_ADDR_VAR 0 11
22062: PUSH
22063: LD_VAR 0 11
22067: PPUSH
22068: LD_VAR 0 11
22072: PUSH
22073: LD_INT 1
22075: PLUS
22076: PPUSH
22077: LD_VAR 0 9
22081: PUSH
22082: LD_VAR 0 3
22086: ARRAY
22087: PPUSH
22088: CALL_OW 2
22092: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22093: LD_ADDR_VAR 0 4
22097: PUSH
22098: LD_VAR 0 4
22102: PUSH
22103: LD_VAR 0 9
22107: PUSH
22108: LD_VAR 0 3
22112: ARRAY
22113: DIFF
22114: ST_TO_ADDR
// end ;
22115: GO 22024
22117: POP
22118: POP
// if p then
22119: LD_VAR 0 11
22123: IFFALSE 22148
// result := Replace ( result , 4 , p ) ;
22125: LD_ADDR_VAR 0 2
22129: PUSH
22130: LD_VAR 0 2
22134: PPUSH
22135: LD_INT 4
22137: PPUSH
22138: LD_VAR 0 11
22142: PPUSH
22143: CALL_OW 1
22147: ST_TO_ADDR
// end ; if tmp and mech < 6 then
22148: LD_VAR 0 4
22152: PUSH
22153: LD_VAR 0 7
22157: PUSH
22158: LD_INT 6
22160: LESS
22161: AND
22162: IFFALSE 22350
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
22164: LD_ADDR_VAR 0 9
22168: PUSH
22169: LD_VAR 0 4
22173: PUSH
22174: LD_VAR 0 8
22178: PUSH
22179: LD_VAR 0 7
22183: UNION
22184: DIFF
22185: PPUSH
22186: LD_INT 3
22188: PPUSH
22189: CALL 85870 0 2
22193: ST_TO_ADDR
// p := [ ] ;
22194: LD_ADDR_VAR 0 11
22198: PUSH
22199: EMPTY
22200: ST_TO_ADDR
// if sort then
22201: LD_VAR 0 9
22205: IFFALSE 22321
// for i = 1 to 6 - mech do
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: DOUBLE
22213: LD_INT 1
22215: DEC
22216: ST_TO_ADDR
22217: LD_INT 6
22219: PUSH
22220: LD_VAR 0 7
22224: MINUS
22225: PUSH
22226: FOR_TO
22227: IFFALSE 22319
// begin if i = sort then
22229: LD_VAR 0 3
22233: PUSH
22234: LD_VAR 0 9
22238: EQUAL
22239: IFFALSE 22243
// break ;
22241: GO 22319
// if GetClass ( i ) = 3 then
22243: LD_VAR 0 3
22247: PPUSH
22248: CALL_OW 257
22252: PUSH
22253: LD_INT 3
22255: EQUAL
22256: IFFALSE 22260
// continue ;
22258: GO 22226
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22260: LD_ADDR_VAR 0 11
22264: PUSH
22265: LD_VAR 0 11
22269: PPUSH
22270: LD_VAR 0 11
22274: PUSH
22275: LD_INT 1
22277: PLUS
22278: PPUSH
22279: LD_VAR 0 9
22283: PUSH
22284: LD_VAR 0 3
22288: ARRAY
22289: PPUSH
22290: CALL_OW 2
22294: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22295: LD_ADDR_VAR 0 4
22299: PUSH
22300: LD_VAR 0 4
22304: PUSH
22305: LD_VAR 0 9
22309: PUSH
22310: LD_VAR 0 3
22314: ARRAY
22315: DIFF
22316: ST_TO_ADDR
// end ;
22317: GO 22226
22319: POP
22320: POP
// if p then
22321: LD_VAR 0 11
22325: IFFALSE 22350
// result := Replace ( result , 3 , p ) ;
22327: LD_ADDR_VAR 0 2
22331: PUSH
22332: LD_VAR 0 2
22336: PPUSH
22337: LD_INT 3
22339: PPUSH
22340: LD_VAR 0 11
22344: PPUSH
22345: CALL_OW 1
22349: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
22350: LD_VAR 0 4
22354: PUSH
22355: LD_INT 6
22357: GREATER
22358: PUSH
22359: LD_VAR 0 6
22363: PUSH
22364: LD_INT 6
22366: LESS
22367: AND
22368: IFFALSE 22562
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
22370: LD_ADDR_VAR 0 9
22374: PUSH
22375: LD_VAR 0 4
22379: PUSH
22380: LD_VAR 0 8
22384: PUSH
22385: LD_VAR 0 7
22389: UNION
22390: PUSH
22391: LD_VAR 0 6
22395: UNION
22396: DIFF
22397: PPUSH
22398: LD_INT 2
22400: PPUSH
22401: CALL 85870 0 2
22405: ST_TO_ADDR
// p := [ ] ;
22406: LD_ADDR_VAR 0 11
22410: PUSH
22411: EMPTY
22412: ST_TO_ADDR
// if sort then
22413: LD_VAR 0 9
22417: IFFALSE 22533
// for i = 1 to 6 - eng do
22419: LD_ADDR_VAR 0 3
22423: PUSH
22424: DOUBLE
22425: LD_INT 1
22427: DEC
22428: ST_TO_ADDR
22429: LD_INT 6
22431: PUSH
22432: LD_VAR 0 6
22436: MINUS
22437: PUSH
22438: FOR_TO
22439: IFFALSE 22531
// begin if i = sort then
22441: LD_VAR 0 3
22445: PUSH
22446: LD_VAR 0 9
22450: EQUAL
22451: IFFALSE 22455
// break ;
22453: GO 22531
// if GetClass ( i ) = 2 then
22455: LD_VAR 0 3
22459: PPUSH
22460: CALL_OW 257
22464: PUSH
22465: LD_INT 2
22467: EQUAL
22468: IFFALSE 22472
// continue ;
22470: GO 22438
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22472: LD_ADDR_VAR 0 11
22476: PUSH
22477: LD_VAR 0 11
22481: PPUSH
22482: LD_VAR 0 11
22486: PUSH
22487: LD_INT 1
22489: PLUS
22490: PPUSH
22491: LD_VAR 0 9
22495: PUSH
22496: LD_VAR 0 3
22500: ARRAY
22501: PPUSH
22502: CALL_OW 2
22506: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22507: LD_ADDR_VAR 0 4
22511: PUSH
22512: LD_VAR 0 4
22516: PUSH
22517: LD_VAR 0 9
22521: PUSH
22522: LD_VAR 0 3
22526: ARRAY
22527: DIFF
22528: ST_TO_ADDR
// end ;
22529: GO 22438
22531: POP
22532: POP
// if p then
22533: LD_VAR 0 11
22537: IFFALSE 22562
// result := Replace ( result , 2 , p ) ;
22539: LD_ADDR_VAR 0 2
22543: PUSH
22544: LD_VAR 0 2
22548: PPUSH
22549: LD_INT 2
22551: PPUSH
22552: LD_VAR 0 11
22556: PPUSH
22557: CALL_OW 1
22561: ST_TO_ADDR
// end ; exit ;
22562: GO 23950
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
22564: LD_EXP 76
22568: PUSH
22569: LD_EXP 75
22573: PUSH
22574: LD_VAR 0 1
22578: ARRAY
22579: ARRAY
22580: NOT
22581: PUSH
22582: LD_EXP 49
22586: PUSH
22587: LD_VAR 0 1
22591: ARRAY
22592: PPUSH
22593: LD_INT 30
22595: PUSH
22596: LD_INT 3
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: PPUSH
22603: CALL_OW 72
22607: AND
22608: PUSH
22609: LD_EXP 54
22613: PUSH
22614: LD_VAR 0 1
22618: ARRAY
22619: AND
22620: IFFALSE 23228
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
22622: LD_ADDR_EXP 91
22626: PUSH
22627: LD_EXP 91
22631: PPUSH
22632: LD_VAR 0 1
22636: PPUSH
22637: LD_INT 5
22639: PPUSH
22640: CALL_OW 1
22644: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22645: LD_ADDR_VAR 0 2
22649: PUSH
22650: LD_INT 0
22652: PUSH
22653: LD_INT 0
22655: PUSH
22656: LD_INT 0
22658: PUSH
22659: LD_INT 0
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: ST_TO_ADDR
// if sci > 1 then
22668: LD_VAR 0 8
22672: PUSH
22673: LD_INT 1
22675: GREATER
22676: IFFALSE 22704
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
22678: LD_ADDR_VAR 0 4
22682: PUSH
22683: LD_VAR 0 4
22687: PUSH
22688: LD_VAR 0 8
22692: PUSH
22693: LD_VAR 0 8
22697: PUSH
22698: LD_INT 1
22700: ARRAY
22701: DIFF
22702: DIFF
22703: ST_TO_ADDR
// if tmp and not sci then
22704: LD_VAR 0 4
22708: PUSH
22709: LD_VAR 0 8
22713: NOT
22714: AND
22715: IFFALSE 22784
// begin sort := SortBySkill ( tmp , 4 ) ;
22717: LD_ADDR_VAR 0 9
22721: PUSH
22722: LD_VAR 0 4
22726: PPUSH
22727: LD_INT 4
22729: PPUSH
22730: CALL 85870 0 2
22734: ST_TO_ADDR
// if sort then
22735: LD_VAR 0 9
22739: IFFALSE 22755
// p := sort [ 1 ] ;
22741: LD_ADDR_VAR 0 11
22745: PUSH
22746: LD_VAR 0 9
22750: PUSH
22751: LD_INT 1
22753: ARRAY
22754: ST_TO_ADDR
// if p then
22755: LD_VAR 0 11
22759: IFFALSE 22784
// result := Replace ( result , 4 , p ) ;
22761: LD_ADDR_VAR 0 2
22765: PUSH
22766: LD_VAR 0 2
22770: PPUSH
22771: LD_INT 4
22773: PPUSH
22774: LD_VAR 0 11
22778: PPUSH
22779: CALL_OW 1
22783: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
22784: LD_ADDR_VAR 0 4
22788: PUSH
22789: LD_VAR 0 4
22793: PUSH
22794: LD_VAR 0 7
22798: DIFF
22799: ST_TO_ADDR
// if tmp and mech < 6 then
22800: LD_VAR 0 4
22804: PUSH
22805: LD_VAR 0 7
22809: PUSH
22810: LD_INT 6
22812: LESS
22813: AND
22814: IFFALSE 23002
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
22816: LD_ADDR_VAR 0 9
22820: PUSH
22821: LD_VAR 0 4
22825: PUSH
22826: LD_VAR 0 8
22830: PUSH
22831: LD_VAR 0 7
22835: UNION
22836: DIFF
22837: PPUSH
22838: LD_INT 3
22840: PPUSH
22841: CALL 85870 0 2
22845: ST_TO_ADDR
// p := [ ] ;
22846: LD_ADDR_VAR 0 11
22850: PUSH
22851: EMPTY
22852: ST_TO_ADDR
// if sort then
22853: LD_VAR 0 9
22857: IFFALSE 22973
// for i = 1 to 6 - mech do
22859: LD_ADDR_VAR 0 3
22863: PUSH
22864: DOUBLE
22865: LD_INT 1
22867: DEC
22868: ST_TO_ADDR
22869: LD_INT 6
22871: PUSH
22872: LD_VAR 0 7
22876: MINUS
22877: PUSH
22878: FOR_TO
22879: IFFALSE 22971
// begin if i = sort then
22881: LD_VAR 0 3
22885: PUSH
22886: LD_VAR 0 9
22890: EQUAL
22891: IFFALSE 22895
// break ;
22893: GO 22971
// if GetClass ( i ) = 3 then
22895: LD_VAR 0 3
22899: PPUSH
22900: CALL_OW 257
22904: PUSH
22905: LD_INT 3
22907: EQUAL
22908: IFFALSE 22912
// continue ;
22910: GO 22878
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22912: LD_ADDR_VAR 0 11
22916: PUSH
22917: LD_VAR 0 11
22921: PPUSH
22922: LD_VAR 0 11
22926: PUSH
22927: LD_INT 1
22929: PLUS
22930: PPUSH
22931: LD_VAR 0 9
22935: PUSH
22936: LD_VAR 0 3
22940: ARRAY
22941: PPUSH
22942: CALL_OW 2
22946: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22947: LD_ADDR_VAR 0 4
22951: PUSH
22952: LD_VAR 0 4
22956: PUSH
22957: LD_VAR 0 9
22961: PUSH
22962: LD_VAR 0 3
22966: ARRAY
22967: DIFF
22968: ST_TO_ADDR
// end ;
22969: GO 22878
22971: POP
22972: POP
// if p then
22973: LD_VAR 0 11
22977: IFFALSE 23002
// result := Replace ( result , 3 , p ) ;
22979: LD_ADDR_VAR 0 2
22983: PUSH
22984: LD_VAR 0 2
22988: PPUSH
22989: LD_INT 3
22991: PPUSH
22992: LD_VAR 0 11
22996: PPUSH
22997: CALL_OW 1
23001: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
23002: LD_ADDR_VAR 0 4
23006: PUSH
23007: LD_VAR 0 4
23011: PUSH
23012: LD_VAR 0 6
23016: DIFF
23017: ST_TO_ADDR
// if tmp and eng < 6 then
23018: LD_VAR 0 4
23022: PUSH
23023: LD_VAR 0 6
23027: PUSH
23028: LD_INT 6
23030: LESS
23031: AND
23032: IFFALSE 23226
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23034: LD_ADDR_VAR 0 9
23038: PUSH
23039: LD_VAR 0 4
23043: PUSH
23044: LD_VAR 0 8
23048: PUSH
23049: LD_VAR 0 7
23053: UNION
23054: PUSH
23055: LD_VAR 0 6
23059: UNION
23060: DIFF
23061: PPUSH
23062: LD_INT 2
23064: PPUSH
23065: CALL 85870 0 2
23069: ST_TO_ADDR
// p := [ ] ;
23070: LD_ADDR_VAR 0 11
23074: PUSH
23075: EMPTY
23076: ST_TO_ADDR
// if sort then
23077: LD_VAR 0 9
23081: IFFALSE 23197
// for i = 1 to 6 - eng do
23083: LD_ADDR_VAR 0 3
23087: PUSH
23088: DOUBLE
23089: LD_INT 1
23091: DEC
23092: ST_TO_ADDR
23093: LD_INT 6
23095: PUSH
23096: LD_VAR 0 6
23100: MINUS
23101: PUSH
23102: FOR_TO
23103: IFFALSE 23195
// begin if i = sort then
23105: LD_VAR 0 3
23109: PUSH
23110: LD_VAR 0 9
23114: EQUAL
23115: IFFALSE 23119
// break ;
23117: GO 23195
// if GetClass ( i ) = 2 then
23119: LD_VAR 0 3
23123: PPUSH
23124: CALL_OW 257
23128: PUSH
23129: LD_INT 2
23131: EQUAL
23132: IFFALSE 23136
// continue ;
23134: GO 23102
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23136: LD_ADDR_VAR 0 11
23140: PUSH
23141: LD_VAR 0 11
23145: PPUSH
23146: LD_VAR 0 11
23150: PUSH
23151: LD_INT 1
23153: PLUS
23154: PPUSH
23155: LD_VAR 0 9
23159: PUSH
23160: LD_VAR 0 3
23164: ARRAY
23165: PPUSH
23166: CALL_OW 2
23170: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23171: LD_ADDR_VAR 0 4
23175: PUSH
23176: LD_VAR 0 4
23180: PUSH
23181: LD_VAR 0 9
23185: PUSH
23186: LD_VAR 0 3
23190: ARRAY
23191: DIFF
23192: ST_TO_ADDR
// end ;
23193: GO 23102
23195: POP
23196: POP
// if p then
23197: LD_VAR 0 11
23201: IFFALSE 23226
// result := Replace ( result , 2 , p ) ;
23203: LD_ADDR_VAR 0 2
23207: PUSH
23208: LD_VAR 0 2
23212: PPUSH
23213: LD_INT 2
23215: PPUSH
23216: LD_VAR 0 11
23220: PPUSH
23221: CALL_OW 1
23225: ST_TO_ADDR
// end ; exit ;
23226: GO 23950
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
23228: LD_EXP 76
23232: PUSH
23233: LD_EXP 75
23237: PUSH
23238: LD_VAR 0 1
23242: ARRAY
23243: ARRAY
23244: NOT
23245: PUSH
23246: LD_EXP 49
23250: PUSH
23251: LD_VAR 0 1
23255: ARRAY
23256: PPUSH
23257: LD_INT 30
23259: PUSH
23260: LD_INT 3
23262: PUSH
23263: EMPTY
23264: LIST
23265: LIST
23266: PPUSH
23267: CALL_OW 72
23271: AND
23272: PUSH
23273: LD_EXP 54
23277: PUSH
23278: LD_VAR 0 1
23282: ARRAY
23283: NOT
23284: AND
23285: IFFALSE 23950
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
23287: LD_ADDR_EXP 91
23291: PUSH
23292: LD_EXP 91
23296: PPUSH
23297: LD_VAR 0 1
23301: PPUSH
23302: LD_INT 6
23304: PPUSH
23305: CALL_OW 1
23309: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23310: LD_ADDR_VAR 0 2
23314: PUSH
23315: LD_INT 0
23317: PUSH
23318: LD_INT 0
23320: PUSH
23321: LD_INT 0
23323: PUSH
23324: LD_INT 0
23326: PUSH
23327: EMPTY
23328: LIST
23329: LIST
23330: LIST
23331: LIST
23332: ST_TO_ADDR
// if sci >= 1 then
23333: LD_VAR 0 8
23337: PUSH
23338: LD_INT 1
23340: GREATEREQUAL
23341: IFFALSE 23363
// tmp := tmp diff sci [ 1 ] ;
23343: LD_ADDR_VAR 0 4
23347: PUSH
23348: LD_VAR 0 4
23352: PUSH
23353: LD_VAR 0 8
23357: PUSH
23358: LD_INT 1
23360: ARRAY
23361: DIFF
23362: ST_TO_ADDR
// if tmp and not sci then
23363: LD_VAR 0 4
23367: PUSH
23368: LD_VAR 0 8
23372: NOT
23373: AND
23374: IFFALSE 23443
// begin sort := SortBySkill ( tmp , 4 ) ;
23376: LD_ADDR_VAR 0 9
23380: PUSH
23381: LD_VAR 0 4
23385: PPUSH
23386: LD_INT 4
23388: PPUSH
23389: CALL 85870 0 2
23393: ST_TO_ADDR
// if sort then
23394: LD_VAR 0 9
23398: IFFALSE 23414
// p := sort [ 1 ] ;
23400: LD_ADDR_VAR 0 11
23404: PUSH
23405: LD_VAR 0 9
23409: PUSH
23410: LD_INT 1
23412: ARRAY
23413: ST_TO_ADDR
// if p then
23414: LD_VAR 0 11
23418: IFFALSE 23443
// result := Replace ( result , 4 , p ) ;
23420: LD_ADDR_VAR 0 2
23424: PUSH
23425: LD_VAR 0 2
23429: PPUSH
23430: LD_INT 4
23432: PPUSH
23433: LD_VAR 0 11
23437: PPUSH
23438: CALL_OW 1
23442: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
23443: LD_ADDR_VAR 0 4
23447: PUSH
23448: LD_VAR 0 4
23452: PUSH
23453: LD_VAR 0 7
23457: DIFF
23458: ST_TO_ADDR
// if tmp and mech < 6 then
23459: LD_VAR 0 4
23463: PUSH
23464: LD_VAR 0 7
23468: PUSH
23469: LD_INT 6
23471: LESS
23472: AND
23473: IFFALSE 23655
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
23475: LD_ADDR_VAR 0 9
23479: PUSH
23480: LD_VAR 0 4
23484: PUSH
23485: LD_VAR 0 7
23489: DIFF
23490: PPUSH
23491: LD_INT 3
23493: PPUSH
23494: CALL 85870 0 2
23498: ST_TO_ADDR
// p := [ ] ;
23499: LD_ADDR_VAR 0 11
23503: PUSH
23504: EMPTY
23505: ST_TO_ADDR
// if sort then
23506: LD_VAR 0 9
23510: IFFALSE 23626
// for i = 1 to 6 - mech do
23512: LD_ADDR_VAR 0 3
23516: PUSH
23517: DOUBLE
23518: LD_INT 1
23520: DEC
23521: ST_TO_ADDR
23522: LD_INT 6
23524: PUSH
23525: LD_VAR 0 7
23529: MINUS
23530: PUSH
23531: FOR_TO
23532: IFFALSE 23624
// begin if i = sort then
23534: LD_VAR 0 3
23538: PUSH
23539: LD_VAR 0 9
23543: EQUAL
23544: IFFALSE 23548
// break ;
23546: GO 23624
// if GetClass ( i ) = 3 then
23548: LD_VAR 0 3
23552: PPUSH
23553: CALL_OW 257
23557: PUSH
23558: LD_INT 3
23560: EQUAL
23561: IFFALSE 23565
// continue ;
23563: GO 23531
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23565: LD_ADDR_VAR 0 11
23569: PUSH
23570: LD_VAR 0 11
23574: PPUSH
23575: LD_VAR 0 11
23579: PUSH
23580: LD_INT 1
23582: PLUS
23583: PPUSH
23584: LD_VAR 0 9
23588: PUSH
23589: LD_VAR 0 3
23593: ARRAY
23594: PPUSH
23595: CALL_OW 2
23599: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23600: LD_ADDR_VAR 0 4
23604: PUSH
23605: LD_VAR 0 4
23609: PUSH
23610: LD_VAR 0 9
23614: PUSH
23615: LD_VAR 0 3
23619: ARRAY
23620: DIFF
23621: ST_TO_ADDR
// end ;
23622: GO 23531
23624: POP
23625: POP
// if p then
23626: LD_VAR 0 11
23630: IFFALSE 23655
// result := Replace ( result , 3 , p ) ;
23632: LD_ADDR_VAR 0 2
23636: PUSH
23637: LD_VAR 0 2
23641: PPUSH
23642: LD_INT 3
23644: PPUSH
23645: LD_VAR 0 11
23649: PPUSH
23650: CALL_OW 1
23654: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
23655: LD_ADDR_VAR 0 4
23659: PUSH
23660: LD_VAR 0 4
23664: PUSH
23665: LD_VAR 0 6
23669: DIFF
23670: ST_TO_ADDR
// if tmp and eng < 4 then
23671: LD_VAR 0 4
23675: PUSH
23676: LD_VAR 0 6
23680: PUSH
23681: LD_INT 4
23683: LESS
23684: AND
23685: IFFALSE 23875
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
23687: LD_ADDR_VAR 0 9
23691: PUSH
23692: LD_VAR 0 4
23696: PUSH
23697: LD_VAR 0 7
23701: PUSH
23702: LD_VAR 0 6
23706: UNION
23707: DIFF
23708: PPUSH
23709: LD_INT 2
23711: PPUSH
23712: CALL 85870 0 2
23716: ST_TO_ADDR
// p := [ ] ;
23717: LD_ADDR_VAR 0 11
23721: PUSH
23722: EMPTY
23723: ST_TO_ADDR
// if sort then
23724: LD_VAR 0 9
23728: IFFALSE 23844
// for i = 1 to 4 - eng do
23730: LD_ADDR_VAR 0 3
23734: PUSH
23735: DOUBLE
23736: LD_INT 1
23738: DEC
23739: ST_TO_ADDR
23740: LD_INT 4
23742: PUSH
23743: LD_VAR 0 6
23747: MINUS
23748: PUSH
23749: FOR_TO
23750: IFFALSE 23842
// begin if i = sort then
23752: LD_VAR 0 3
23756: PUSH
23757: LD_VAR 0 9
23761: EQUAL
23762: IFFALSE 23766
// break ;
23764: GO 23842
// if GetClass ( i ) = 2 then
23766: LD_VAR 0 3
23770: PPUSH
23771: CALL_OW 257
23775: PUSH
23776: LD_INT 2
23778: EQUAL
23779: IFFALSE 23783
// continue ;
23781: GO 23749
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23783: LD_ADDR_VAR 0 11
23787: PUSH
23788: LD_VAR 0 11
23792: PPUSH
23793: LD_VAR 0 11
23797: PUSH
23798: LD_INT 1
23800: PLUS
23801: PPUSH
23802: LD_VAR 0 9
23806: PUSH
23807: LD_VAR 0 3
23811: ARRAY
23812: PPUSH
23813: CALL_OW 2
23817: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23818: LD_ADDR_VAR 0 4
23822: PUSH
23823: LD_VAR 0 4
23827: PUSH
23828: LD_VAR 0 9
23832: PUSH
23833: LD_VAR 0 3
23837: ARRAY
23838: DIFF
23839: ST_TO_ADDR
// end ;
23840: GO 23749
23842: POP
23843: POP
// if p then
23844: LD_VAR 0 11
23848: IFFALSE 23873
// result := Replace ( result , 2 , p ) ;
23850: LD_ADDR_VAR 0 2
23854: PUSH
23855: LD_VAR 0 2
23859: PPUSH
23860: LD_INT 2
23862: PPUSH
23863: LD_VAR 0 11
23867: PPUSH
23868: CALL_OW 1
23872: ST_TO_ADDR
// end else
23873: GO 23919
// for i = eng downto 5 do
23875: LD_ADDR_VAR 0 3
23879: PUSH
23880: DOUBLE
23881: LD_VAR 0 6
23885: INC
23886: ST_TO_ADDR
23887: LD_INT 5
23889: PUSH
23890: FOR_DOWNTO
23891: IFFALSE 23917
// tmp := tmp union eng [ i ] ;
23893: LD_ADDR_VAR 0 4
23897: PUSH
23898: LD_VAR 0 4
23902: PUSH
23903: LD_VAR 0 6
23907: PUSH
23908: LD_VAR 0 3
23912: ARRAY
23913: UNION
23914: ST_TO_ADDR
23915: GO 23890
23917: POP
23918: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
23919: LD_ADDR_VAR 0 2
23923: PUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: LD_INT 1
23931: PPUSH
23932: LD_VAR 0 4
23936: PUSH
23937: LD_VAR 0 5
23941: DIFF
23942: PPUSH
23943: CALL_OW 1
23947: ST_TO_ADDR
// exit ;
23948: GO 23950
// end ; end ;
23950: LD_VAR 0 2
23954: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
23955: LD_INT 0
23957: PPUSH
23958: PPUSH
23959: PPUSH
// if not mc_bases then
23960: LD_EXP 49
23964: NOT
23965: IFFALSE 23969
// exit ;
23967: GO 24075
// for i = 1 to mc_bases do
23969: LD_ADDR_VAR 0 2
23973: PUSH
23974: DOUBLE
23975: LD_INT 1
23977: DEC
23978: ST_TO_ADDR
23979: LD_EXP 49
23983: PUSH
23984: FOR_TO
23985: IFFALSE 24066
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
23987: LD_ADDR_VAR 0 3
23991: PUSH
23992: LD_EXP 49
23996: PUSH
23997: LD_VAR 0 2
24001: ARRAY
24002: PPUSH
24003: LD_INT 21
24005: PUSH
24006: LD_INT 3
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: PUSH
24013: LD_INT 3
24015: PUSH
24016: LD_INT 24
24018: PUSH
24019: LD_INT 1000
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: PPUSH
24034: CALL_OW 72
24038: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
24039: LD_ADDR_EXP 50
24043: PUSH
24044: LD_EXP 50
24048: PPUSH
24049: LD_VAR 0 2
24053: PPUSH
24054: LD_VAR 0 3
24058: PPUSH
24059: CALL_OW 1
24063: ST_TO_ADDR
// end ;
24064: GO 23984
24066: POP
24067: POP
// RaiseSailEvent ( 101 ) ;
24068: LD_INT 101
24070: PPUSH
24071: CALL_OW 427
// end ;
24075: LD_VAR 0 1
24079: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
24080: LD_INT 0
24082: PPUSH
24083: PPUSH
24084: PPUSH
24085: PPUSH
24086: PPUSH
24087: PPUSH
24088: PPUSH
// if not mc_bases then
24089: LD_EXP 49
24093: NOT
24094: IFFALSE 24098
// exit ;
24096: GO 24671
// for i = 1 to mc_bases do
24098: LD_ADDR_VAR 0 2
24102: PUSH
24103: DOUBLE
24104: LD_INT 1
24106: DEC
24107: ST_TO_ADDR
24108: LD_EXP 49
24112: PUSH
24113: FOR_TO
24114: IFFALSE 24662
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
24116: LD_ADDR_VAR 0 5
24120: PUSH
24121: LD_EXP 49
24125: PUSH
24126: LD_VAR 0 2
24130: ARRAY
24131: PUSH
24132: LD_EXP 78
24136: PUSH
24137: LD_VAR 0 2
24141: ARRAY
24142: UNION
24143: PPUSH
24144: LD_INT 21
24146: PUSH
24147: LD_INT 1
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: LD_INT 1
24156: PUSH
24157: LD_INT 3
24159: PUSH
24160: LD_INT 54
24162: PUSH
24163: EMPTY
24164: LIST
24165: PUSH
24166: EMPTY
24167: LIST
24168: LIST
24169: PUSH
24170: LD_INT 3
24172: PUSH
24173: LD_INT 24
24175: PUSH
24176: LD_INT 750
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: LIST
24191: PUSH
24192: EMPTY
24193: LIST
24194: LIST
24195: PPUSH
24196: CALL_OW 72
24200: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
24201: LD_ADDR_VAR 0 6
24205: PUSH
24206: LD_EXP 49
24210: PUSH
24211: LD_VAR 0 2
24215: ARRAY
24216: PPUSH
24217: LD_INT 21
24219: PUSH
24220: LD_INT 1
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PUSH
24227: LD_INT 1
24229: PUSH
24230: LD_INT 3
24232: PUSH
24233: LD_INT 54
24235: PUSH
24236: EMPTY
24237: LIST
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: PUSH
24243: LD_INT 3
24245: PUSH
24246: LD_INT 24
24248: PUSH
24249: LD_INT 250
24251: PUSH
24252: EMPTY
24253: LIST
24254: LIST
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: LIST
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PPUSH
24269: CALL_OW 72
24273: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
24274: LD_ADDR_VAR 0 7
24278: PUSH
24279: LD_VAR 0 5
24283: PUSH
24284: LD_VAR 0 6
24288: DIFF
24289: ST_TO_ADDR
// if not need_heal_1 then
24290: LD_VAR 0 6
24294: NOT
24295: IFFALSE 24328
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
24297: LD_ADDR_EXP 52
24301: PUSH
24302: LD_EXP 52
24306: PPUSH
24307: LD_VAR 0 2
24311: PUSH
24312: LD_INT 1
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PPUSH
24319: EMPTY
24320: PPUSH
24321: CALL 51685 0 3
24325: ST_TO_ADDR
24326: GO 24398
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
24328: LD_ADDR_EXP 52
24332: PUSH
24333: LD_EXP 52
24337: PPUSH
24338: LD_VAR 0 2
24342: PUSH
24343: LD_INT 1
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PPUSH
24350: LD_EXP 52
24354: PUSH
24355: LD_VAR 0 2
24359: ARRAY
24360: PUSH
24361: LD_INT 1
24363: ARRAY
24364: PPUSH
24365: LD_INT 3
24367: PUSH
24368: LD_INT 24
24370: PUSH
24371: LD_INT 1000
24373: PUSH
24374: EMPTY
24375: LIST
24376: LIST
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: PPUSH
24382: CALL_OW 72
24386: PUSH
24387: LD_VAR 0 6
24391: UNION
24392: PPUSH
24393: CALL 51685 0 3
24397: ST_TO_ADDR
// if not need_heal_2 then
24398: LD_VAR 0 7
24402: NOT
24403: IFFALSE 24436
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
24405: LD_ADDR_EXP 52
24409: PUSH
24410: LD_EXP 52
24414: PPUSH
24415: LD_VAR 0 2
24419: PUSH
24420: LD_INT 2
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PPUSH
24427: EMPTY
24428: PPUSH
24429: CALL 51685 0 3
24433: ST_TO_ADDR
24434: GO 24468
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
24436: LD_ADDR_EXP 52
24440: PUSH
24441: LD_EXP 52
24445: PPUSH
24446: LD_VAR 0 2
24450: PUSH
24451: LD_INT 2
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PPUSH
24458: LD_VAR 0 7
24462: PPUSH
24463: CALL 51685 0 3
24467: ST_TO_ADDR
// if need_heal_2 then
24468: LD_VAR 0 7
24472: IFFALSE 24644
// for j in need_heal_2 do
24474: LD_ADDR_VAR 0 3
24478: PUSH
24479: LD_VAR 0 7
24483: PUSH
24484: FOR_IN
24485: IFFALSE 24642
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
24487: LD_ADDR_VAR 0 5
24491: PUSH
24492: LD_EXP 49
24496: PUSH
24497: LD_VAR 0 2
24501: ARRAY
24502: PPUSH
24503: LD_INT 2
24505: PUSH
24506: LD_INT 30
24508: PUSH
24509: LD_INT 6
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PUSH
24516: LD_INT 30
24518: PUSH
24519: LD_INT 7
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 30
24528: PUSH
24529: LD_INT 8
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: PUSH
24536: LD_INT 30
24538: PUSH
24539: LD_INT 0
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: PUSH
24546: LD_INT 30
24548: PUSH
24549: LD_INT 1
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: PUSH
24556: LD_INT 25
24558: PUSH
24559: LD_INT 4
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 72
24579: ST_TO_ADDR
// if tmp then
24580: LD_VAR 0 5
24584: IFFALSE 24640
// begin k := NearestUnitToUnit ( tmp , j ) ;
24586: LD_ADDR_VAR 0 4
24590: PUSH
24591: LD_VAR 0 5
24595: PPUSH
24596: LD_VAR 0 3
24600: PPUSH
24601: CALL_OW 74
24605: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
24606: LD_VAR 0 3
24610: PPUSH
24611: LD_VAR 0 4
24615: PPUSH
24616: CALL_OW 296
24620: PUSH
24621: LD_INT 7
24623: GREATER
24624: IFFALSE 24640
// ComMoveUnit ( j , k ) ;
24626: LD_VAR 0 3
24630: PPUSH
24631: LD_VAR 0 4
24635: PPUSH
24636: CALL_OW 112
// end ; end ;
24640: GO 24484
24642: POP
24643: POP
// if not need_heal_1 and not need_heal_2 then
24644: LD_VAR 0 6
24648: NOT
24649: PUSH
24650: LD_VAR 0 7
24654: NOT
24655: AND
24656: IFFALSE 24660
// continue ;
24658: GO 24113
// end ;
24660: GO 24113
24662: POP
24663: POP
// RaiseSailEvent ( 102 ) ;
24664: LD_INT 102
24666: PPUSH
24667: CALL_OW 427
// end ;
24671: LD_VAR 0 1
24675: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
24676: LD_INT 0
24678: PPUSH
24679: PPUSH
24680: PPUSH
24681: PPUSH
24682: PPUSH
// if not mc_bases then
24683: LD_EXP 49
24687: NOT
24688: IFFALSE 24692
// exit ;
24690: GO 25077
// for i = 1 to mc_bases do
24692: LD_ADDR_VAR 0 2
24696: PUSH
24697: DOUBLE
24698: LD_INT 1
24700: DEC
24701: ST_TO_ADDR
24702: LD_EXP 49
24706: PUSH
24707: FOR_TO
24708: IFFALSE 25075
// begin if not mc_building_need_repair [ i ] then
24710: LD_EXP 50
24714: PUSH
24715: LD_VAR 0 2
24719: ARRAY
24720: NOT
24721: IFFALSE 24759
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24723: LD_ADDR_EXP 51
24727: PUSH
24728: LD_EXP 51
24732: PPUSH
24733: LD_VAR 0 2
24737: PPUSH
24738: EMPTY
24739: PPUSH
24740: CALL_OW 1
24744: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
24745: LD_VAR 0 2
24749: PPUSH
24750: LD_INT 101
24752: PPUSH
24753: CALL 19797 0 2
// continue ;
24757: GO 24707
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
24759: LD_ADDR_EXP 55
24763: PUSH
24764: LD_EXP 55
24768: PPUSH
24769: LD_VAR 0 2
24773: PPUSH
24774: EMPTY
24775: PPUSH
24776: CALL_OW 1
24780: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
24781: LD_VAR 0 2
24785: PPUSH
24786: LD_INT 103
24788: PPUSH
24789: CALL 19797 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
24793: LD_ADDR_VAR 0 5
24797: PUSH
24798: LD_EXP 49
24802: PUSH
24803: LD_VAR 0 2
24807: ARRAY
24808: PUSH
24809: LD_EXP 78
24813: PUSH
24814: LD_VAR 0 2
24818: ARRAY
24819: UNION
24820: PPUSH
24821: LD_INT 2
24823: PUSH
24824: LD_INT 25
24826: PUSH
24827: LD_INT 2
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: LD_INT 25
24836: PUSH
24837: LD_INT 16
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: LIST
24848: PUSH
24849: EMPTY
24850: LIST
24851: PPUSH
24852: CALL_OW 72
24856: ST_TO_ADDR
// if not tmp then
24857: LD_VAR 0 5
24861: NOT
24862: IFFALSE 24866
// continue ;
24864: GO 24707
// for j in tmp do
24866: LD_ADDR_VAR 0 3
24870: PUSH
24871: LD_VAR 0 5
24875: PUSH
24876: FOR_IN
24877: IFFALSE 25071
// begin if mc_need_heal [ i ] then
24879: LD_EXP 52
24883: PUSH
24884: LD_VAR 0 2
24888: ARRAY
24889: IFFALSE 24937
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
24891: LD_VAR 0 3
24895: PUSH
24896: LD_EXP 52
24900: PUSH
24901: LD_VAR 0 2
24905: ARRAY
24906: PUSH
24907: LD_INT 1
24909: ARRAY
24910: IN
24911: PUSH
24912: LD_VAR 0 3
24916: PUSH
24917: LD_EXP 52
24921: PUSH
24922: LD_VAR 0 2
24926: ARRAY
24927: PUSH
24928: LD_INT 2
24930: ARRAY
24931: IN
24932: OR
24933: IFFALSE 24937
// continue ;
24935: GO 24876
// if IsInUnit ( j ) then
24937: LD_VAR 0 3
24941: PPUSH
24942: CALL_OW 310
24946: IFFALSE 24957
// ComExitBuilding ( j ) ;
24948: LD_VAR 0 3
24952: PPUSH
24953: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
24957: LD_VAR 0 3
24961: PUSH
24962: LD_EXP 51
24966: PUSH
24967: LD_VAR 0 2
24971: ARRAY
24972: IN
24973: NOT
24974: IFFALSE 25032
// begin SetTag ( j , 101 ) ;
24976: LD_VAR 0 3
24980: PPUSH
24981: LD_INT 101
24983: PPUSH
24984: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
24988: LD_ADDR_EXP 51
24992: PUSH
24993: LD_EXP 51
24997: PPUSH
24998: LD_VAR 0 2
25002: PUSH
25003: LD_EXP 51
25007: PUSH
25008: LD_VAR 0 2
25012: ARRAY
25013: PUSH
25014: LD_INT 1
25016: PLUS
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PPUSH
25022: LD_VAR 0 3
25026: PPUSH
25027: CALL 51685 0 3
25031: ST_TO_ADDR
// end ; wait ( 1 ) ;
25032: LD_INT 1
25034: PPUSH
25035: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
25039: LD_VAR 0 3
25043: PPUSH
25044: LD_EXP 50
25048: PUSH
25049: LD_VAR 0 2
25053: ARRAY
25054: PPUSH
25055: LD_VAR 0 3
25059: PPUSH
25060: CALL_OW 74
25064: PPUSH
25065: CALL_OW 130
// end ;
25069: GO 24876
25071: POP
25072: POP
// end ;
25073: GO 24707
25075: POP
25076: POP
// end ;
25077: LD_VAR 0 1
25081: RET
// export function MC_Heal ; var i , j , tmp ; begin
25082: LD_INT 0
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
// if not mc_bases then
25088: LD_EXP 49
25092: NOT
25093: IFFALSE 25097
// exit ;
25095: GO 25499
// for i = 1 to mc_bases do
25097: LD_ADDR_VAR 0 2
25101: PUSH
25102: DOUBLE
25103: LD_INT 1
25105: DEC
25106: ST_TO_ADDR
25107: LD_EXP 49
25111: PUSH
25112: FOR_TO
25113: IFFALSE 25497
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
25115: LD_EXP 52
25119: PUSH
25120: LD_VAR 0 2
25124: ARRAY
25125: PUSH
25126: LD_INT 1
25128: ARRAY
25129: NOT
25130: PUSH
25131: LD_EXP 52
25135: PUSH
25136: LD_VAR 0 2
25140: ARRAY
25141: PUSH
25142: LD_INT 2
25144: ARRAY
25145: NOT
25146: AND
25147: IFFALSE 25185
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
25149: LD_ADDR_EXP 53
25153: PUSH
25154: LD_EXP 53
25158: PPUSH
25159: LD_VAR 0 2
25163: PPUSH
25164: EMPTY
25165: PPUSH
25166: CALL_OW 1
25170: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
25171: LD_VAR 0 2
25175: PPUSH
25176: LD_INT 102
25178: PPUSH
25179: CALL 19797 0 2
// continue ;
25183: GO 25112
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
25185: LD_ADDR_VAR 0 4
25189: PUSH
25190: LD_EXP 49
25194: PUSH
25195: LD_VAR 0 2
25199: ARRAY
25200: PPUSH
25201: LD_INT 25
25203: PUSH
25204: LD_INT 4
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: PPUSH
25211: CALL_OW 72
25215: ST_TO_ADDR
// if not tmp then
25216: LD_VAR 0 4
25220: NOT
25221: IFFALSE 25225
// continue ;
25223: GO 25112
// if mc_taming [ i ] then
25225: LD_EXP 80
25229: PUSH
25230: LD_VAR 0 2
25234: ARRAY
25235: IFFALSE 25259
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25237: LD_ADDR_EXP 80
25241: PUSH
25242: LD_EXP 80
25246: PPUSH
25247: LD_VAR 0 2
25251: PPUSH
25252: EMPTY
25253: PPUSH
25254: CALL_OW 1
25258: ST_TO_ADDR
// for j in tmp do
25259: LD_ADDR_VAR 0 3
25263: PUSH
25264: LD_VAR 0 4
25268: PUSH
25269: FOR_IN
25270: IFFALSE 25493
// begin if IsInUnit ( j ) then
25272: LD_VAR 0 3
25276: PPUSH
25277: CALL_OW 310
25281: IFFALSE 25292
// ComExitBuilding ( j ) ;
25283: LD_VAR 0 3
25287: PPUSH
25288: CALL_OW 122
// if not j in mc_healers [ i ] then
25292: LD_VAR 0 3
25296: PUSH
25297: LD_EXP 53
25301: PUSH
25302: LD_VAR 0 2
25306: ARRAY
25307: IN
25308: NOT
25309: IFFALSE 25355
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
25311: LD_ADDR_EXP 53
25315: PUSH
25316: LD_EXP 53
25320: PPUSH
25321: LD_VAR 0 2
25325: PUSH
25326: LD_EXP 53
25330: PUSH
25331: LD_VAR 0 2
25335: ARRAY
25336: PUSH
25337: LD_INT 1
25339: PLUS
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PPUSH
25345: LD_VAR 0 3
25349: PPUSH
25350: CALL 51685 0 3
25354: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
25355: LD_VAR 0 3
25359: PPUSH
25360: CALL_OW 110
25364: PUSH
25365: LD_INT 102
25367: NONEQUAL
25368: IFFALSE 25382
// SetTag ( j , 102 ) ;
25370: LD_VAR 0 3
25374: PPUSH
25375: LD_INT 102
25377: PPUSH
25378: CALL_OW 109
// Wait ( 3 ) ;
25382: LD_INT 3
25384: PPUSH
25385: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
25389: LD_EXP 52
25393: PUSH
25394: LD_VAR 0 2
25398: ARRAY
25399: PUSH
25400: LD_INT 1
25402: ARRAY
25403: IFFALSE 25435
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
25405: LD_VAR 0 3
25409: PPUSH
25410: LD_EXP 52
25414: PUSH
25415: LD_VAR 0 2
25419: ARRAY
25420: PUSH
25421: LD_INT 1
25423: ARRAY
25424: PUSH
25425: LD_INT 1
25427: ARRAY
25428: PPUSH
25429: CALL_OW 128
25433: GO 25491
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
25435: LD_VAR 0 3
25439: PPUSH
25440: CALL_OW 314
25444: NOT
25445: PUSH
25446: LD_EXP 52
25450: PUSH
25451: LD_VAR 0 2
25455: ARRAY
25456: PUSH
25457: LD_INT 2
25459: ARRAY
25460: AND
25461: IFFALSE 25491
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
25463: LD_VAR 0 3
25467: PPUSH
25468: LD_EXP 52
25472: PUSH
25473: LD_VAR 0 2
25477: ARRAY
25478: PUSH
25479: LD_INT 2
25481: ARRAY
25482: PUSH
25483: LD_INT 1
25485: ARRAY
25486: PPUSH
25487: CALL_OW 128
// end ;
25491: GO 25269
25493: POP
25494: POP
// end ;
25495: GO 25112
25497: POP
25498: POP
// end ;
25499: LD_VAR 0 1
25503: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
25504: LD_INT 0
25506: PPUSH
25507: PPUSH
25508: PPUSH
25509: PPUSH
25510: PPUSH
// if not mc_bases then
25511: LD_EXP 49
25515: NOT
25516: IFFALSE 25520
// exit ;
25518: GO 26663
// for i = 1 to mc_bases do
25520: LD_ADDR_VAR 0 2
25524: PUSH
25525: DOUBLE
25526: LD_INT 1
25528: DEC
25529: ST_TO_ADDR
25530: LD_EXP 49
25534: PUSH
25535: FOR_TO
25536: IFFALSE 26661
// begin if mc_scan [ i ] then
25538: LD_EXP 72
25542: PUSH
25543: LD_VAR 0 2
25547: ARRAY
25548: IFFALSE 25552
// continue ;
25550: GO 25535
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
25552: LD_EXP 54
25556: PUSH
25557: LD_VAR 0 2
25561: ARRAY
25562: NOT
25563: PUSH
25564: LD_EXP 56
25568: PUSH
25569: LD_VAR 0 2
25573: ARRAY
25574: NOT
25575: AND
25576: PUSH
25577: LD_EXP 55
25581: PUSH
25582: LD_VAR 0 2
25586: ARRAY
25587: AND
25588: IFFALSE 25626
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
25590: LD_ADDR_EXP 55
25594: PUSH
25595: LD_EXP 55
25599: PPUSH
25600: LD_VAR 0 2
25604: PPUSH
25605: EMPTY
25606: PPUSH
25607: CALL_OW 1
25611: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
25612: LD_VAR 0 2
25616: PPUSH
25617: LD_INT 103
25619: PPUSH
25620: CALL 19797 0 2
// continue ;
25624: GO 25535
// end ; if mc_construct_list [ i ] then
25626: LD_EXP 56
25630: PUSH
25631: LD_VAR 0 2
25635: ARRAY
25636: IFFALSE 25856
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
25638: LD_ADDR_VAR 0 4
25642: PUSH
25643: LD_EXP 49
25647: PUSH
25648: LD_VAR 0 2
25652: ARRAY
25653: PPUSH
25654: LD_INT 25
25656: PUSH
25657: LD_INT 2
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PPUSH
25664: CALL_OW 72
25668: PUSH
25669: LD_EXP 51
25673: PUSH
25674: LD_VAR 0 2
25678: ARRAY
25679: DIFF
25680: ST_TO_ADDR
// if not tmp then
25681: LD_VAR 0 4
25685: NOT
25686: IFFALSE 25690
// continue ;
25688: GO 25535
// for j in tmp do
25690: LD_ADDR_VAR 0 3
25694: PUSH
25695: LD_VAR 0 4
25699: PUSH
25700: FOR_IN
25701: IFFALSE 25852
// begin if not mc_builders [ i ] then
25703: LD_EXP 55
25707: PUSH
25708: LD_VAR 0 2
25712: ARRAY
25713: NOT
25714: IFFALSE 25772
// begin SetTag ( j , 103 ) ;
25716: LD_VAR 0 3
25720: PPUSH
25721: LD_INT 103
25723: PPUSH
25724: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
25728: LD_ADDR_EXP 55
25732: PUSH
25733: LD_EXP 55
25737: PPUSH
25738: LD_VAR 0 2
25742: PUSH
25743: LD_EXP 55
25747: PUSH
25748: LD_VAR 0 2
25752: ARRAY
25753: PUSH
25754: LD_INT 1
25756: PLUS
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PPUSH
25762: LD_VAR 0 3
25766: PPUSH
25767: CALL 51685 0 3
25771: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
25772: LD_VAR 0 3
25776: PPUSH
25777: CALL_OW 310
25781: IFFALSE 25792
// ComExitBuilding ( j ) ;
25783: LD_VAR 0 3
25787: PPUSH
25788: CALL_OW 122
// wait ( 3 ) ;
25792: LD_INT 3
25794: PPUSH
25795: CALL_OW 67
// if not mc_construct_list [ i ] then
25799: LD_EXP 56
25803: PUSH
25804: LD_VAR 0 2
25808: ARRAY
25809: NOT
25810: IFFALSE 25814
// break ;
25812: GO 25852
// if not HasTask ( j ) then
25814: LD_VAR 0 3
25818: PPUSH
25819: CALL_OW 314
25823: NOT
25824: IFFALSE 25850
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
25826: LD_VAR 0 3
25830: PPUSH
25831: LD_EXP 56
25835: PUSH
25836: LD_VAR 0 2
25840: ARRAY
25841: PUSH
25842: LD_INT 1
25844: ARRAY
25845: PPUSH
25846: CALL 54536 0 2
// end ;
25850: GO 25700
25852: POP
25853: POP
// end else
25854: GO 26659
// if mc_build_list [ i ] then
25856: LD_EXP 54
25860: PUSH
25861: LD_VAR 0 2
25865: ARRAY
25866: IFFALSE 26659
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25868: LD_ADDR_VAR 0 5
25872: PUSH
25873: LD_EXP 49
25877: PUSH
25878: LD_VAR 0 2
25882: ARRAY
25883: PPUSH
25884: LD_INT 2
25886: PUSH
25887: LD_INT 30
25889: PUSH
25890: LD_INT 0
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 30
25899: PUSH
25900: LD_INT 1
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: LIST
25911: PPUSH
25912: CALL_OW 72
25916: ST_TO_ADDR
// if depot then
25917: LD_VAR 0 5
25921: IFFALSE 25939
// depot := depot [ 1 ] else
25923: LD_ADDR_VAR 0 5
25927: PUSH
25928: LD_VAR 0 5
25932: PUSH
25933: LD_INT 1
25935: ARRAY
25936: ST_TO_ADDR
25937: GO 25947
// depot := 0 ;
25939: LD_ADDR_VAR 0 5
25943: PUSH
25944: LD_INT 0
25946: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
25947: LD_EXP 54
25951: PUSH
25952: LD_VAR 0 2
25956: ARRAY
25957: PUSH
25958: LD_INT 1
25960: ARRAY
25961: PUSH
25962: LD_INT 1
25964: ARRAY
25965: PPUSH
25966: CALL 54366 0 1
25970: PUSH
25971: LD_EXP 49
25975: PUSH
25976: LD_VAR 0 2
25980: ARRAY
25981: PPUSH
25982: LD_INT 2
25984: PUSH
25985: LD_INT 30
25987: PUSH
25988: LD_INT 2
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 30
25997: PUSH
25998: LD_INT 3
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: LIST
26009: PPUSH
26010: CALL_OW 72
26014: NOT
26015: AND
26016: IFFALSE 26121
// begin for j = 1 to mc_build_list [ i ] do
26018: LD_ADDR_VAR 0 3
26022: PUSH
26023: DOUBLE
26024: LD_INT 1
26026: DEC
26027: ST_TO_ADDR
26028: LD_EXP 54
26032: PUSH
26033: LD_VAR 0 2
26037: ARRAY
26038: PUSH
26039: FOR_TO
26040: IFFALSE 26119
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
26042: LD_EXP 54
26046: PUSH
26047: LD_VAR 0 2
26051: ARRAY
26052: PUSH
26053: LD_VAR 0 3
26057: ARRAY
26058: PUSH
26059: LD_INT 1
26061: ARRAY
26062: PUSH
26063: LD_INT 2
26065: EQUAL
26066: IFFALSE 26117
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
26068: LD_ADDR_EXP 54
26072: PUSH
26073: LD_EXP 54
26077: PPUSH
26078: LD_VAR 0 2
26082: PPUSH
26083: LD_EXP 54
26087: PUSH
26088: LD_VAR 0 2
26092: ARRAY
26093: PPUSH
26094: LD_VAR 0 3
26098: PPUSH
26099: LD_INT 1
26101: PPUSH
26102: LD_INT 0
26104: PPUSH
26105: CALL 51103 0 4
26109: PPUSH
26110: CALL_OW 1
26114: ST_TO_ADDR
// break ;
26115: GO 26119
// end ;
26117: GO 26039
26119: POP
26120: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
26121: LD_EXP 54
26125: PUSH
26126: LD_VAR 0 2
26130: ARRAY
26131: PUSH
26132: LD_INT 1
26134: ARRAY
26135: PUSH
26136: LD_INT 1
26138: ARRAY
26139: PUSH
26140: LD_INT 0
26142: EQUAL
26143: PUSH
26144: LD_VAR 0 5
26148: PUSH
26149: LD_VAR 0 5
26153: PPUSH
26154: LD_EXP 54
26158: PUSH
26159: LD_VAR 0 2
26163: ARRAY
26164: PUSH
26165: LD_INT 1
26167: ARRAY
26168: PUSH
26169: LD_INT 1
26171: ARRAY
26172: PPUSH
26173: LD_EXP 54
26177: PUSH
26178: LD_VAR 0 2
26182: ARRAY
26183: PUSH
26184: LD_INT 1
26186: ARRAY
26187: PUSH
26188: LD_INT 2
26190: ARRAY
26191: PPUSH
26192: LD_EXP 54
26196: PUSH
26197: LD_VAR 0 2
26201: ARRAY
26202: PUSH
26203: LD_INT 1
26205: ARRAY
26206: PUSH
26207: LD_INT 3
26209: ARRAY
26210: PPUSH
26211: LD_EXP 54
26215: PUSH
26216: LD_VAR 0 2
26220: ARRAY
26221: PUSH
26222: LD_INT 1
26224: ARRAY
26225: PUSH
26226: LD_INT 4
26228: ARRAY
26229: PPUSH
26230: CALL 59082 0 5
26234: AND
26235: OR
26236: IFFALSE 26517
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
26238: LD_ADDR_VAR 0 4
26242: PUSH
26243: LD_EXP 49
26247: PUSH
26248: LD_VAR 0 2
26252: ARRAY
26253: PPUSH
26254: LD_INT 25
26256: PUSH
26257: LD_INT 2
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: PPUSH
26264: CALL_OW 72
26268: PUSH
26269: LD_EXP 51
26273: PUSH
26274: LD_VAR 0 2
26278: ARRAY
26279: DIFF
26280: ST_TO_ADDR
// if not tmp then
26281: LD_VAR 0 4
26285: NOT
26286: IFFALSE 26290
// continue ;
26288: GO 25535
// for j in tmp do
26290: LD_ADDR_VAR 0 3
26294: PUSH
26295: LD_VAR 0 4
26299: PUSH
26300: FOR_IN
26301: IFFALSE 26513
// begin if not mc_builders [ i ] then
26303: LD_EXP 55
26307: PUSH
26308: LD_VAR 0 2
26312: ARRAY
26313: NOT
26314: IFFALSE 26372
// begin SetTag ( j , 103 ) ;
26316: LD_VAR 0 3
26320: PPUSH
26321: LD_INT 103
26323: PPUSH
26324: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
26328: LD_ADDR_EXP 55
26332: PUSH
26333: LD_EXP 55
26337: PPUSH
26338: LD_VAR 0 2
26342: PUSH
26343: LD_EXP 55
26347: PUSH
26348: LD_VAR 0 2
26352: ARRAY
26353: PUSH
26354: LD_INT 1
26356: PLUS
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PPUSH
26362: LD_VAR 0 3
26366: PPUSH
26367: CALL 51685 0 3
26371: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
26372: LD_VAR 0 3
26376: PPUSH
26377: CALL_OW 310
26381: IFFALSE 26392
// ComExitBuilding ( j ) ;
26383: LD_VAR 0 3
26387: PPUSH
26388: CALL_OW 122
// wait ( 3 ) ;
26392: LD_INT 3
26394: PPUSH
26395: CALL_OW 67
// if not mc_build_list [ i ] then
26399: LD_EXP 54
26403: PUSH
26404: LD_VAR 0 2
26408: ARRAY
26409: NOT
26410: IFFALSE 26414
// break ;
26412: GO 26513
// if not HasTask ( j ) then
26414: LD_VAR 0 3
26418: PPUSH
26419: CALL_OW 314
26423: NOT
26424: IFFALSE 26511
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
26426: LD_VAR 0 3
26430: PPUSH
26431: LD_EXP 54
26435: PUSH
26436: LD_VAR 0 2
26440: ARRAY
26441: PUSH
26442: LD_INT 1
26444: ARRAY
26445: PUSH
26446: LD_INT 1
26448: ARRAY
26449: PPUSH
26450: LD_EXP 54
26454: PUSH
26455: LD_VAR 0 2
26459: ARRAY
26460: PUSH
26461: LD_INT 1
26463: ARRAY
26464: PUSH
26465: LD_INT 2
26467: ARRAY
26468: PPUSH
26469: LD_EXP 54
26473: PUSH
26474: LD_VAR 0 2
26478: ARRAY
26479: PUSH
26480: LD_INT 1
26482: ARRAY
26483: PUSH
26484: LD_INT 3
26486: ARRAY
26487: PPUSH
26488: LD_EXP 54
26492: PUSH
26493: LD_VAR 0 2
26497: ARRAY
26498: PUSH
26499: LD_INT 1
26501: ARRAY
26502: PUSH
26503: LD_INT 4
26505: ARRAY
26506: PPUSH
26507: CALL_OW 145
// end ;
26511: GO 26300
26513: POP
26514: POP
// end else
26515: GO 26659
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
26517: LD_EXP 49
26521: PUSH
26522: LD_VAR 0 2
26526: ARRAY
26527: PPUSH
26528: LD_EXP 54
26532: PUSH
26533: LD_VAR 0 2
26537: ARRAY
26538: PUSH
26539: LD_INT 1
26541: ARRAY
26542: PUSH
26543: LD_INT 1
26545: ARRAY
26546: PPUSH
26547: LD_EXP 54
26551: PUSH
26552: LD_VAR 0 2
26556: ARRAY
26557: PUSH
26558: LD_INT 1
26560: ARRAY
26561: PUSH
26562: LD_INT 2
26564: ARRAY
26565: PPUSH
26566: LD_EXP 54
26570: PUSH
26571: LD_VAR 0 2
26575: ARRAY
26576: PUSH
26577: LD_INT 1
26579: ARRAY
26580: PUSH
26581: LD_INT 3
26583: ARRAY
26584: PPUSH
26585: LD_EXP 54
26589: PUSH
26590: LD_VAR 0 2
26594: ARRAY
26595: PUSH
26596: LD_INT 1
26598: ARRAY
26599: PUSH
26600: LD_INT 4
26602: ARRAY
26603: PPUSH
26604: CALL 58436 0 5
26608: NOT
26609: IFFALSE 26659
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
26611: LD_ADDR_EXP 54
26615: PUSH
26616: LD_EXP 54
26620: PPUSH
26621: LD_VAR 0 2
26625: PPUSH
26626: LD_EXP 54
26630: PUSH
26631: LD_VAR 0 2
26635: ARRAY
26636: PPUSH
26637: LD_INT 1
26639: PPUSH
26640: LD_INT 1
26642: NEG
26643: PPUSH
26644: LD_INT 0
26646: PPUSH
26647: CALL 51103 0 4
26651: PPUSH
26652: CALL_OW 1
26656: ST_TO_ADDR
// continue ;
26657: GO 25535
// end ; end ; end ;
26659: GO 25535
26661: POP
26662: POP
// end ;
26663: LD_VAR 0 1
26667: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
26668: LD_INT 0
26670: PPUSH
26671: PPUSH
26672: PPUSH
26673: PPUSH
26674: PPUSH
26675: PPUSH
// if not mc_bases then
26676: LD_EXP 49
26680: NOT
26681: IFFALSE 26685
// exit ;
26683: GO 27112
// for i = 1 to mc_bases do
26685: LD_ADDR_VAR 0 2
26689: PUSH
26690: DOUBLE
26691: LD_INT 1
26693: DEC
26694: ST_TO_ADDR
26695: LD_EXP 49
26699: PUSH
26700: FOR_TO
26701: IFFALSE 27110
// begin tmp := mc_build_upgrade [ i ] ;
26703: LD_ADDR_VAR 0 4
26707: PUSH
26708: LD_EXP 81
26712: PUSH
26713: LD_VAR 0 2
26717: ARRAY
26718: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
26719: LD_ADDR_VAR 0 6
26723: PUSH
26724: LD_EXP 82
26728: PUSH
26729: LD_VAR 0 2
26733: ARRAY
26734: PPUSH
26735: LD_INT 2
26737: PUSH
26738: LD_INT 30
26740: PUSH
26741: LD_INT 6
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: PUSH
26748: LD_INT 30
26750: PUSH
26751: LD_INT 7
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: LIST
26762: PPUSH
26763: CALL_OW 72
26767: ST_TO_ADDR
// if not tmp and not lab then
26768: LD_VAR 0 4
26772: NOT
26773: PUSH
26774: LD_VAR 0 6
26778: NOT
26779: AND
26780: IFFALSE 26784
// continue ;
26782: GO 26700
// if tmp then
26784: LD_VAR 0 4
26788: IFFALSE 26908
// for j in tmp do
26790: LD_ADDR_VAR 0 3
26794: PUSH
26795: LD_VAR 0 4
26799: PUSH
26800: FOR_IN
26801: IFFALSE 26906
// begin if UpgradeCost ( j ) then
26803: LD_VAR 0 3
26807: PPUSH
26808: CALL 58096 0 1
26812: IFFALSE 26904
// begin ComUpgrade ( j ) ;
26814: LD_VAR 0 3
26818: PPUSH
26819: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
26823: LD_ADDR_EXP 81
26827: PUSH
26828: LD_EXP 81
26832: PPUSH
26833: LD_VAR 0 2
26837: PPUSH
26838: LD_EXP 81
26842: PUSH
26843: LD_VAR 0 2
26847: ARRAY
26848: PUSH
26849: LD_VAR 0 3
26853: DIFF
26854: PPUSH
26855: CALL_OW 1
26859: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
26860: LD_ADDR_EXP 56
26864: PUSH
26865: LD_EXP 56
26869: PPUSH
26870: LD_VAR 0 2
26874: PUSH
26875: LD_EXP 56
26879: PUSH
26880: LD_VAR 0 2
26884: ARRAY
26885: PUSH
26886: LD_INT 1
26888: PLUS
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: PPUSH
26894: LD_VAR 0 3
26898: PPUSH
26899: CALL 51685 0 3
26903: ST_TO_ADDR
// end ; end ;
26904: GO 26800
26906: POP
26907: POP
// if not lab or not mc_lab_upgrade [ i ] then
26908: LD_VAR 0 6
26912: NOT
26913: PUSH
26914: LD_EXP 83
26918: PUSH
26919: LD_VAR 0 2
26923: ARRAY
26924: NOT
26925: OR
26926: IFFALSE 26930
// continue ;
26928: GO 26700
// for j in lab do
26930: LD_ADDR_VAR 0 3
26934: PUSH
26935: LD_VAR 0 6
26939: PUSH
26940: FOR_IN
26941: IFFALSE 27106
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
26943: LD_VAR 0 3
26947: PPUSH
26948: CALL_OW 266
26952: PUSH
26953: LD_INT 6
26955: PUSH
26956: LD_INT 7
26958: PUSH
26959: EMPTY
26960: LIST
26961: LIST
26962: IN
26963: PUSH
26964: LD_VAR 0 3
26968: PPUSH
26969: CALL_OW 461
26973: PUSH
26974: LD_INT 1
26976: NONEQUAL
26977: AND
26978: IFFALSE 27104
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
26980: LD_VAR 0 3
26984: PPUSH
26985: LD_EXP 83
26989: PUSH
26990: LD_VAR 0 2
26994: ARRAY
26995: PUSH
26996: LD_INT 1
26998: ARRAY
26999: PPUSH
27000: CALL 58301 0 2
27004: IFFALSE 27104
// begin ComCancel ( j ) ;
27006: LD_VAR 0 3
27010: PPUSH
27011: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
27015: LD_VAR 0 3
27019: PPUSH
27020: LD_EXP 83
27024: PUSH
27025: LD_VAR 0 2
27029: ARRAY
27030: PUSH
27031: LD_INT 1
27033: ARRAY
27034: PPUSH
27035: CALL_OW 207
// if not j in mc_construct_list [ i ] then
27039: LD_VAR 0 3
27043: PUSH
27044: LD_EXP 56
27048: PUSH
27049: LD_VAR 0 2
27053: ARRAY
27054: IN
27055: NOT
27056: IFFALSE 27102
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
27058: LD_ADDR_EXP 56
27062: PUSH
27063: LD_EXP 56
27067: PPUSH
27068: LD_VAR 0 2
27072: PUSH
27073: LD_EXP 56
27077: PUSH
27078: LD_VAR 0 2
27082: ARRAY
27083: PUSH
27084: LD_INT 1
27086: PLUS
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PPUSH
27092: LD_VAR 0 3
27096: PPUSH
27097: CALL 51685 0 3
27101: ST_TO_ADDR
// break ;
27102: GO 27106
// end ; end ; end ;
27104: GO 26940
27106: POP
27107: POP
// end ;
27108: GO 26700
27110: POP
27111: POP
// end ;
27112: LD_VAR 0 1
27116: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
27117: LD_INT 0
27119: PPUSH
27120: PPUSH
27121: PPUSH
27122: PPUSH
27123: PPUSH
27124: PPUSH
27125: PPUSH
27126: PPUSH
27127: PPUSH
// if not mc_bases then
27128: LD_EXP 49
27132: NOT
27133: IFFALSE 27137
// exit ;
27135: GO 27542
// for i = 1 to mc_bases do
27137: LD_ADDR_VAR 0 2
27141: PUSH
27142: DOUBLE
27143: LD_INT 1
27145: DEC
27146: ST_TO_ADDR
27147: LD_EXP 49
27151: PUSH
27152: FOR_TO
27153: IFFALSE 27540
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
27155: LD_EXP 57
27159: PUSH
27160: LD_VAR 0 2
27164: ARRAY
27165: NOT
27166: PUSH
27167: LD_EXP 49
27171: PUSH
27172: LD_VAR 0 2
27176: ARRAY
27177: PPUSH
27178: LD_INT 30
27180: PUSH
27181: LD_INT 3
27183: PUSH
27184: EMPTY
27185: LIST
27186: LIST
27187: PPUSH
27188: CALL_OW 72
27192: NOT
27193: OR
27194: IFFALSE 27198
// continue ;
27196: GO 27152
// busy := false ;
27198: LD_ADDR_VAR 0 8
27202: PUSH
27203: LD_INT 0
27205: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
27206: LD_ADDR_VAR 0 4
27210: PUSH
27211: LD_EXP 49
27215: PUSH
27216: LD_VAR 0 2
27220: ARRAY
27221: PPUSH
27222: LD_INT 30
27224: PUSH
27225: LD_INT 3
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PPUSH
27232: CALL_OW 72
27236: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
27237: LD_ADDR_VAR 0 6
27241: PUSH
27242: LD_EXP 57
27246: PUSH
27247: LD_VAR 0 2
27251: ARRAY
27252: PPUSH
27253: LD_INT 2
27255: PUSH
27256: LD_INT 30
27258: PUSH
27259: LD_INT 32
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 30
27268: PUSH
27269: LD_INT 33
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: LIST
27280: PPUSH
27281: CALL_OW 72
27285: ST_TO_ADDR
// if not t then
27286: LD_VAR 0 6
27290: NOT
27291: IFFALSE 27295
// continue ;
27293: GO 27152
// for j in tmp do
27295: LD_ADDR_VAR 0 3
27299: PUSH
27300: LD_VAR 0 4
27304: PUSH
27305: FOR_IN
27306: IFFALSE 27336
// if not BuildingStatus ( j ) = bs_idle then
27308: LD_VAR 0 3
27312: PPUSH
27313: CALL_OW 461
27317: PUSH
27318: LD_INT 2
27320: EQUAL
27321: NOT
27322: IFFALSE 27334
// begin busy := true ;
27324: LD_ADDR_VAR 0 8
27328: PUSH
27329: LD_INT 1
27331: ST_TO_ADDR
// break ;
27332: GO 27336
// end ;
27334: GO 27305
27336: POP
27337: POP
// if busy then
27338: LD_VAR 0 8
27342: IFFALSE 27346
// continue ;
27344: GO 27152
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
27346: LD_ADDR_VAR 0 7
27350: PUSH
27351: LD_VAR 0 6
27355: PPUSH
27356: LD_INT 35
27358: PUSH
27359: LD_INT 0
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PPUSH
27366: CALL_OW 72
27370: ST_TO_ADDR
// if tw then
27371: LD_VAR 0 7
27375: IFFALSE 27452
// begin tw := tw [ 1 ] ;
27377: LD_ADDR_VAR 0 7
27381: PUSH
27382: LD_VAR 0 7
27386: PUSH
27387: LD_INT 1
27389: ARRAY
27390: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
27391: LD_ADDR_VAR 0 9
27395: PUSH
27396: LD_VAR 0 7
27400: PPUSH
27401: LD_EXP 74
27405: PUSH
27406: LD_VAR 0 2
27410: ARRAY
27411: PPUSH
27412: CALL 56655 0 2
27416: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
27417: LD_EXP 88
27421: PUSH
27422: LD_VAR 0 2
27426: ARRAY
27427: IFFALSE 27450
// if not weapon in mc_allowed_tower_weapons [ i ] then
27429: LD_VAR 0 9
27433: PUSH
27434: LD_EXP 88
27438: PUSH
27439: LD_VAR 0 2
27443: ARRAY
27444: IN
27445: NOT
27446: IFFALSE 27450
// continue ;
27448: GO 27152
// end else
27450: GO 27515
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
27452: LD_ADDR_VAR 0 5
27456: PUSH
27457: LD_EXP 57
27461: PUSH
27462: LD_VAR 0 2
27466: ARRAY
27467: PPUSH
27468: LD_VAR 0 4
27472: PPUSH
27473: CALL 86794 0 2
27477: ST_TO_ADDR
// if not tmp2 then
27478: LD_VAR 0 5
27482: NOT
27483: IFFALSE 27487
// continue ;
27485: GO 27152
// tw := tmp2 [ 1 ] ;
27487: LD_ADDR_VAR 0 7
27491: PUSH
27492: LD_VAR 0 5
27496: PUSH
27497: LD_INT 1
27499: ARRAY
27500: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
27501: LD_ADDR_VAR 0 9
27505: PUSH
27506: LD_VAR 0 5
27510: PUSH
27511: LD_INT 2
27513: ARRAY
27514: ST_TO_ADDR
// end ; if not weapon then
27515: LD_VAR 0 9
27519: NOT
27520: IFFALSE 27524
// continue ;
27522: GO 27152
// ComPlaceWeapon ( tw , weapon ) ;
27524: LD_VAR 0 7
27528: PPUSH
27529: LD_VAR 0 9
27533: PPUSH
27534: CALL_OW 148
// end ;
27538: GO 27152
27540: POP
27541: POP
// end ;
27542: LD_VAR 0 1
27546: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
27547: LD_INT 0
27549: PPUSH
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
// if not mc_bases then
27555: LD_EXP 49
27559: NOT
27560: IFFALSE 27564
// exit ;
27562: GO 28576
// for i = 1 to mc_bases do
27564: LD_ADDR_VAR 0 2
27568: PUSH
27569: DOUBLE
27570: LD_INT 1
27572: DEC
27573: ST_TO_ADDR
27574: LD_EXP 49
27578: PUSH
27579: FOR_TO
27580: IFFALSE 28574
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
27582: LD_EXP 62
27586: PUSH
27587: LD_VAR 0 2
27591: ARRAY
27592: NOT
27593: PUSH
27594: LD_EXP 62
27598: PUSH
27599: LD_VAR 0 2
27603: ARRAY
27604: PUSH
27605: LD_EXP 63
27609: PUSH
27610: LD_VAR 0 2
27614: ARRAY
27615: EQUAL
27616: OR
27617: IFFALSE 27621
// continue ;
27619: GO 27579
// if mc_miners [ i ] then
27621: LD_EXP 63
27625: PUSH
27626: LD_VAR 0 2
27630: ARRAY
27631: IFFALSE 28261
// begin k := 1 ;
27633: LD_ADDR_VAR 0 4
27637: PUSH
27638: LD_INT 1
27640: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
27641: LD_ADDR_VAR 0 3
27645: PUSH
27646: DOUBLE
27647: LD_EXP 63
27651: PUSH
27652: LD_VAR 0 2
27656: ARRAY
27657: INC
27658: ST_TO_ADDR
27659: LD_INT 1
27661: PUSH
27662: FOR_DOWNTO
27663: IFFALSE 28259
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
27665: LD_EXP 63
27669: PUSH
27670: LD_VAR 0 2
27674: ARRAY
27675: PUSH
27676: LD_VAR 0 3
27680: ARRAY
27681: PPUSH
27682: CALL_OW 301
27686: PUSH
27687: LD_EXP 63
27691: PUSH
27692: LD_VAR 0 2
27696: ARRAY
27697: PUSH
27698: LD_VAR 0 3
27702: ARRAY
27703: PPUSH
27704: CALL_OW 257
27708: PUSH
27709: LD_INT 1
27711: NONEQUAL
27712: OR
27713: IFFALSE 27776
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
27715: LD_ADDR_VAR 0 5
27719: PUSH
27720: LD_EXP 63
27724: PUSH
27725: LD_VAR 0 2
27729: ARRAY
27730: PUSH
27731: LD_EXP 63
27735: PUSH
27736: LD_VAR 0 2
27740: ARRAY
27741: PUSH
27742: LD_VAR 0 3
27746: ARRAY
27747: DIFF
27748: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
27749: LD_ADDR_EXP 63
27753: PUSH
27754: LD_EXP 63
27758: PPUSH
27759: LD_VAR 0 2
27763: PPUSH
27764: LD_VAR 0 5
27768: PPUSH
27769: CALL_OW 1
27773: ST_TO_ADDR
// continue ;
27774: GO 27662
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
27776: LD_EXP 63
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: PUSH
27787: LD_VAR 0 3
27791: ARRAY
27792: PPUSH
27793: CALL 51621 0 1
27797: PUSH
27798: LD_EXP 63
27802: PUSH
27803: LD_VAR 0 2
27807: ARRAY
27808: PUSH
27809: LD_VAR 0 3
27813: ARRAY
27814: PPUSH
27815: CALL_OW 255
27819: PPUSH
27820: LD_EXP 62
27824: PUSH
27825: LD_VAR 0 2
27829: ARRAY
27830: PUSH
27831: LD_VAR 0 4
27835: ARRAY
27836: PUSH
27837: LD_INT 1
27839: ARRAY
27840: PPUSH
27841: LD_EXP 62
27845: PUSH
27846: LD_VAR 0 2
27850: ARRAY
27851: PUSH
27852: LD_VAR 0 4
27856: ARRAY
27857: PUSH
27858: LD_INT 2
27860: ARRAY
27861: PPUSH
27862: LD_INT 15
27864: PPUSH
27865: CALL 52581 0 4
27869: PUSH
27870: LD_INT 4
27872: ARRAY
27873: PUSH
27874: LD_EXP 63
27878: PUSH
27879: LD_VAR 0 2
27883: ARRAY
27884: PUSH
27885: LD_VAR 0 3
27889: ARRAY
27890: PPUSH
27891: LD_INT 10
27893: PPUSH
27894: CALL 54278 0 2
27898: PUSH
27899: LD_INT 4
27901: ARRAY
27902: OR
27903: AND
27904: IFFALSE 27927
// ComStop ( mc_miners [ i ] [ j ] ) ;
27906: LD_EXP 63
27910: PUSH
27911: LD_VAR 0 2
27915: ARRAY
27916: PUSH
27917: LD_VAR 0 3
27921: ARRAY
27922: PPUSH
27923: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
27927: LD_EXP 63
27931: PUSH
27932: LD_VAR 0 2
27936: ARRAY
27937: PUSH
27938: LD_VAR 0 3
27942: ARRAY
27943: PPUSH
27944: CALL_OW 257
27948: PUSH
27949: LD_INT 1
27951: EQUAL
27952: PUSH
27953: LD_EXP 63
27957: PUSH
27958: LD_VAR 0 2
27962: ARRAY
27963: PUSH
27964: LD_VAR 0 3
27968: ARRAY
27969: PPUSH
27970: CALL_OW 459
27974: NOT
27975: AND
27976: PUSH
27977: LD_EXP 63
27981: PUSH
27982: LD_VAR 0 2
27986: ARRAY
27987: PUSH
27988: LD_VAR 0 3
27992: ARRAY
27993: PPUSH
27994: CALL_OW 255
27998: PPUSH
27999: LD_EXP 62
28003: PUSH
28004: LD_VAR 0 2
28008: ARRAY
28009: PUSH
28010: LD_VAR 0 4
28014: ARRAY
28015: PUSH
28016: LD_INT 1
28018: ARRAY
28019: PPUSH
28020: LD_EXP 62
28024: PUSH
28025: LD_VAR 0 2
28029: ARRAY
28030: PUSH
28031: LD_VAR 0 4
28035: ARRAY
28036: PUSH
28037: LD_INT 2
28039: ARRAY
28040: PPUSH
28041: LD_INT 15
28043: PPUSH
28044: CALL 52581 0 4
28048: PUSH
28049: LD_INT 4
28051: ARRAY
28052: PUSH
28053: LD_INT 0
28055: EQUAL
28056: AND
28057: PUSH
28058: LD_EXP 63
28062: PUSH
28063: LD_VAR 0 2
28067: ARRAY
28068: PUSH
28069: LD_VAR 0 3
28073: ARRAY
28074: PPUSH
28075: CALL_OW 314
28079: NOT
28080: AND
28081: IFFALSE 28257
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
28083: LD_EXP 63
28087: PUSH
28088: LD_VAR 0 2
28092: ARRAY
28093: PUSH
28094: LD_VAR 0 3
28098: ARRAY
28099: PPUSH
28100: CALL_OW 310
28104: IFFALSE 28127
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
28106: LD_EXP 63
28110: PUSH
28111: LD_VAR 0 2
28115: ARRAY
28116: PUSH
28117: LD_VAR 0 3
28121: ARRAY
28122: PPUSH
28123: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
28127: LD_EXP 63
28131: PUSH
28132: LD_VAR 0 2
28136: ARRAY
28137: PUSH
28138: LD_VAR 0 3
28142: ARRAY
28143: PPUSH
28144: CALL_OW 314
28148: NOT
28149: IFFALSE 28217
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
28151: LD_EXP 63
28155: PUSH
28156: LD_VAR 0 2
28160: ARRAY
28161: PUSH
28162: LD_VAR 0 3
28166: ARRAY
28167: PPUSH
28168: LD_EXP 62
28172: PUSH
28173: LD_VAR 0 2
28177: ARRAY
28178: PUSH
28179: LD_VAR 0 4
28183: ARRAY
28184: PUSH
28185: LD_INT 1
28187: ARRAY
28188: PPUSH
28189: LD_EXP 62
28193: PUSH
28194: LD_VAR 0 2
28198: ARRAY
28199: PUSH
28200: LD_VAR 0 4
28204: ARRAY
28205: PUSH
28206: LD_INT 2
28208: ARRAY
28209: PPUSH
28210: LD_INT 0
28212: PPUSH
28213: CALL_OW 193
// k := k + 1 ;
28217: LD_ADDR_VAR 0 4
28221: PUSH
28222: LD_VAR 0 4
28226: PUSH
28227: LD_INT 1
28229: PLUS
28230: ST_TO_ADDR
// if k > mc_mines [ i ] then
28231: LD_VAR 0 4
28235: PUSH
28236: LD_EXP 62
28240: PUSH
28241: LD_VAR 0 2
28245: ARRAY
28246: GREATER
28247: IFFALSE 28257
// k := 1 ;
28249: LD_ADDR_VAR 0 4
28253: PUSH
28254: LD_INT 1
28256: ST_TO_ADDR
// end ; end ;
28257: GO 27662
28259: POP
28260: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
28261: LD_ADDR_VAR 0 5
28265: PUSH
28266: LD_EXP 49
28270: PUSH
28271: LD_VAR 0 2
28275: ARRAY
28276: PPUSH
28277: LD_INT 2
28279: PUSH
28280: LD_INT 30
28282: PUSH
28283: LD_INT 4
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 30
28292: PUSH
28293: LD_INT 5
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 30
28302: PUSH
28303: LD_INT 32
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: LIST
28314: LIST
28315: PPUSH
28316: CALL_OW 72
28320: ST_TO_ADDR
// if not tmp then
28321: LD_VAR 0 5
28325: NOT
28326: IFFALSE 28330
// continue ;
28328: GO 27579
// list := [ ] ;
28330: LD_ADDR_VAR 0 6
28334: PUSH
28335: EMPTY
28336: ST_TO_ADDR
// for j in tmp do
28337: LD_ADDR_VAR 0 3
28341: PUSH
28342: LD_VAR 0 5
28346: PUSH
28347: FOR_IN
28348: IFFALSE 28417
// begin for k in UnitsInside ( j ) do
28350: LD_ADDR_VAR 0 4
28354: PUSH
28355: LD_VAR 0 3
28359: PPUSH
28360: CALL_OW 313
28364: PUSH
28365: FOR_IN
28366: IFFALSE 28413
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
28368: LD_VAR 0 4
28372: PPUSH
28373: CALL_OW 257
28377: PUSH
28378: LD_INT 1
28380: EQUAL
28381: PUSH
28382: LD_VAR 0 4
28386: PPUSH
28387: CALL_OW 459
28391: NOT
28392: AND
28393: IFFALSE 28411
// list := list ^ k ;
28395: LD_ADDR_VAR 0 6
28399: PUSH
28400: LD_VAR 0 6
28404: PUSH
28405: LD_VAR 0 4
28409: ADD
28410: ST_TO_ADDR
28411: GO 28365
28413: POP
28414: POP
// end ;
28415: GO 28347
28417: POP
28418: POP
// list := list diff mc_miners [ i ] ;
28419: LD_ADDR_VAR 0 6
28423: PUSH
28424: LD_VAR 0 6
28428: PUSH
28429: LD_EXP 63
28433: PUSH
28434: LD_VAR 0 2
28438: ARRAY
28439: DIFF
28440: ST_TO_ADDR
// if not list then
28441: LD_VAR 0 6
28445: NOT
28446: IFFALSE 28450
// continue ;
28448: GO 27579
// k := mc_mines [ i ] - mc_miners [ i ] ;
28450: LD_ADDR_VAR 0 4
28454: PUSH
28455: LD_EXP 62
28459: PUSH
28460: LD_VAR 0 2
28464: ARRAY
28465: PUSH
28466: LD_EXP 63
28470: PUSH
28471: LD_VAR 0 2
28475: ARRAY
28476: MINUS
28477: ST_TO_ADDR
// if k > list then
28478: LD_VAR 0 4
28482: PUSH
28483: LD_VAR 0 6
28487: GREATER
28488: IFFALSE 28500
// k := list ;
28490: LD_ADDR_VAR 0 4
28494: PUSH
28495: LD_VAR 0 6
28499: ST_TO_ADDR
// for j = 1 to k do
28500: LD_ADDR_VAR 0 3
28504: PUSH
28505: DOUBLE
28506: LD_INT 1
28508: DEC
28509: ST_TO_ADDR
28510: LD_VAR 0 4
28514: PUSH
28515: FOR_TO
28516: IFFALSE 28570
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
28518: LD_ADDR_EXP 63
28522: PUSH
28523: LD_EXP 63
28527: PPUSH
28528: LD_VAR 0 2
28532: PUSH
28533: LD_EXP 63
28537: PUSH
28538: LD_VAR 0 2
28542: ARRAY
28543: PUSH
28544: LD_INT 1
28546: PLUS
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PPUSH
28552: LD_VAR 0 6
28556: PUSH
28557: LD_VAR 0 3
28561: ARRAY
28562: PPUSH
28563: CALL 51685 0 3
28567: ST_TO_ADDR
28568: GO 28515
28570: POP
28571: POP
// end ;
28572: GO 27579
28574: POP
28575: POP
// end ;
28576: LD_VAR 0 1
28580: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
28581: LD_INT 0
28583: PPUSH
28584: PPUSH
28585: PPUSH
28586: PPUSH
28587: PPUSH
28588: PPUSH
28589: PPUSH
28590: PPUSH
28591: PPUSH
28592: PPUSH
// if not mc_bases then
28593: LD_EXP 49
28597: NOT
28598: IFFALSE 28602
// exit ;
28600: GO 30333
// for i = 1 to mc_bases do
28602: LD_ADDR_VAR 0 2
28606: PUSH
28607: DOUBLE
28608: LD_INT 1
28610: DEC
28611: ST_TO_ADDR
28612: LD_EXP 49
28616: PUSH
28617: FOR_TO
28618: IFFALSE 30331
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
28620: LD_EXP 49
28624: PUSH
28625: LD_VAR 0 2
28629: ARRAY
28630: NOT
28631: PUSH
28632: LD_EXP 56
28636: PUSH
28637: LD_VAR 0 2
28641: ARRAY
28642: OR
28643: IFFALSE 28647
// continue ;
28645: GO 28617
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
28647: LD_EXP 65
28651: PUSH
28652: LD_VAR 0 2
28656: ARRAY
28657: NOT
28658: PUSH
28659: LD_EXP 66
28663: PUSH
28664: LD_VAR 0 2
28668: ARRAY
28669: AND
28670: IFFALSE 28708
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
28672: LD_ADDR_EXP 66
28676: PUSH
28677: LD_EXP 66
28681: PPUSH
28682: LD_VAR 0 2
28686: PPUSH
28687: EMPTY
28688: PPUSH
28689: CALL_OW 1
28693: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
28694: LD_VAR 0 2
28698: PPUSH
28699: LD_INT 107
28701: PPUSH
28702: CALL 19797 0 2
// continue ;
28706: GO 28617
// end ; target := [ ] ;
28708: LD_ADDR_VAR 0 6
28712: PUSH
28713: EMPTY
28714: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
28715: LD_ADDR_VAR 0 3
28719: PUSH
28720: DOUBLE
28721: LD_EXP 65
28725: PUSH
28726: LD_VAR 0 2
28730: ARRAY
28731: INC
28732: ST_TO_ADDR
28733: LD_INT 1
28735: PUSH
28736: FOR_DOWNTO
28737: IFFALSE 28997
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
28739: LD_EXP 65
28743: PUSH
28744: LD_VAR 0 2
28748: ARRAY
28749: PUSH
28750: LD_VAR 0 3
28754: ARRAY
28755: PUSH
28756: LD_INT 2
28758: ARRAY
28759: PPUSH
28760: LD_EXP 65
28764: PUSH
28765: LD_VAR 0 2
28769: ARRAY
28770: PUSH
28771: LD_VAR 0 3
28775: ARRAY
28776: PUSH
28777: LD_INT 3
28779: ARRAY
28780: PPUSH
28781: CALL_OW 488
28785: PUSH
28786: LD_EXP 65
28790: PUSH
28791: LD_VAR 0 2
28795: ARRAY
28796: PUSH
28797: LD_VAR 0 3
28801: ARRAY
28802: PUSH
28803: LD_INT 2
28805: ARRAY
28806: PPUSH
28807: LD_EXP 65
28811: PUSH
28812: LD_VAR 0 2
28816: ARRAY
28817: PUSH
28818: LD_VAR 0 3
28822: ARRAY
28823: PUSH
28824: LD_INT 3
28826: ARRAY
28827: PPUSH
28828: CALL_OW 284
28832: PUSH
28833: LD_INT 0
28835: EQUAL
28836: AND
28837: IFFALSE 28892
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
28839: LD_ADDR_VAR 0 5
28843: PUSH
28844: LD_EXP 65
28848: PUSH
28849: LD_VAR 0 2
28853: ARRAY
28854: PPUSH
28855: LD_VAR 0 3
28859: PPUSH
28860: CALL_OW 3
28864: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
28865: LD_ADDR_EXP 65
28869: PUSH
28870: LD_EXP 65
28874: PPUSH
28875: LD_VAR 0 2
28879: PPUSH
28880: LD_VAR 0 5
28884: PPUSH
28885: CALL_OW 1
28889: ST_TO_ADDR
// continue ;
28890: GO 28736
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
28892: LD_EXP 49
28896: PUSH
28897: LD_VAR 0 2
28901: ARRAY
28902: PUSH
28903: LD_INT 1
28905: ARRAY
28906: PPUSH
28907: CALL_OW 255
28911: PPUSH
28912: LD_EXP 65
28916: PUSH
28917: LD_VAR 0 2
28921: ARRAY
28922: PUSH
28923: LD_VAR 0 3
28927: ARRAY
28928: PUSH
28929: LD_INT 2
28931: ARRAY
28932: PPUSH
28933: LD_EXP 65
28937: PUSH
28938: LD_VAR 0 2
28942: ARRAY
28943: PUSH
28944: LD_VAR 0 3
28948: ARRAY
28949: PUSH
28950: LD_INT 3
28952: ARRAY
28953: PPUSH
28954: LD_INT 30
28956: PPUSH
28957: CALL 52581 0 4
28961: PUSH
28962: LD_INT 4
28964: ARRAY
28965: PUSH
28966: LD_INT 0
28968: EQUAL
28969: IFFALSE 28995
// begin target := mc_crates [ i ] [ j ] ;
28971: LD_ADDR_VAR 0 6
28975: PUSH
28976: LD_EXP 65
28980: PUSH
28981: LD_VAR 0 2
28985: ARRAY
28986: PUSH
28987: LD_VAR 0 3
28991: ARRAY
28992: ST_TO_ADDR
// break ;
28993: GO 28997
// end ; end ;
28995: GO 28736
28997: POP
28998: POP
// if not target then
28999: LD_VAR 0 6
29003: NOT
29004: IFFALSE 29008
// continue ;
29006: GO 28617
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
29008: LD_ADDR_VAR 0 7
29012: PUSH
29013: LD_EXP 68
29017: PUSH
29018: LD_VAR 0 2
29022: ARRAY
29023: PPUSH
29024: LD_INT 2
29026: PUSH
29027: LD_INT 3
29029: PUSH
29030: LD_INT 58
29032: PUSH
29033: EMPTY
29034: LIST
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 61
29042: PUSH
29043: EMPTY
29044: LIST
29045: PUSH
29046: LD_INT 33
29048: PUSH
29049: LD_INT 5
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 33
29058: PUSH
29059: LD_INT 3
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: LIST
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 2
29075: PUSH
29076: LD_INT 34
29078: PUSH
29079: LD_INT 32
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 34
29088: PUSH
29089: LD_INT 51
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 34
29098: PUSH
29099: LD_INT 12
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: LIST
29110: LIST
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PPUSH
29116: CALL_OW 72
29120: ST_TO_ADDR
// if not cargo then
29121: LD_VAR 0 7
29125: NOT
29126: IFFALSE 29769
// begin if mc_crates_collector [ i ] < 5 then
29128: LD_EXP 66
29132: PUSH
29133: LD_VAR 0 2
29137: ARRAY
29138: PUSH
29139: LD_INT 5
29141: LESS
29142: IFFALSE 29508
// begin if mc_ape [ i ] then
29144: LD_EXP 78
29148: PUSH
29149: LD_VAR 0 2
29153: ARRAY
29154: IFFALSE 29201
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
29156: LD_ADDR_VAR 0 5
29160: PUSH
29161: LD_EXP 78
29165: PUSH
29166: LD_VAR 0 2
29170: ARRAY
29171: PPUSH
29172: LD_INT 25
29174: PUSH
29175: LD_INT 16
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 24
29184: PUSH
29185: LD_INT 750
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PPUSH
29196: CALL_OW 72
29200: ST_TO_ADDR
// if not tmp then
29201: LD_VAR 0 5
29205: NOT
29206: IFFALSE 29253
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
29208: LD_ADDR_VAR 0 5
29212: PUSH
29213: LD_EXP 49
29217: PUSH
29218: LD_VAR 0 2
29222: ARRAY
29223: PPUSH
29224: LD_INT 25
29226: PUSH
29227: LD_INT 2
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 24
29236: PUSH
29237: LD_INT 750
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PPUSH
29248: CALL_OW 72
29252: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
29253: LD_EXP 78
29257: PUSH
29258: LD_VAR 0 2
29262: ARRAY
29263: PUSH
29264: LD_EXP 49
29268: PUSH
29269: LD_VAR 0 2
29273: ARRAY
29274: PPUSH
29275: LD_INT 25
29277: PUSH
29278: LD_INT 2
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 24
29287: PUSH
29288: LD_INT 750
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PPUSH
29299: CALL_OW 72
29303: AND
29304: PUSH
29305: LD_VAR 0 5
29309: PUSH
29310: LD_INT 5
29312: LESS
29313: AND
29314: IFFALSE 29396
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
29316: LD_ADDR_VAR 0 3
29320: PUSH
29321: LD_EXP 49
29325: PUSH
29326: LD_VAR 0 2
29330: ARRAY
29331: PPUSH
29332: LD_INT 25
29334: PUSH
29335: LD_INT 2
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 24
29344: PUSH
29345: LD_INT 750
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PPUSH
29356: CALL_OW 72
29360: PUSH
29361: FOR_IN
29362: IFFALSE 29394
// begin tmp := tmp union j ;
29364: LD_ADDR_VAR 0 5
29368: PUSH
29369: LD_VAR 0 5
29373: PUSH
29374: LD_VAR 0 3
29378: UNION
29379: ST_TO_ADDR
// if tmp >= 5 then
29380: LD_VAR 0 5
29384: PUSH
29385: LD_INT 5
29387: GREATEREQUAL
29388: IFFALSE 29392
// break ;
29390: GO 29394
// end ;
29392: GO 29361
29394: POP
29395: POP
// end ; if not tmp then
29396: LD_VAR 0 5
29400: NOT
29401: IFFALSE 29405
// continue ;
29403: GO 28617
// for j in tmp do
29405: LD_ADDR_VAR 0 3
29409: PUSH
29410: LD_VAR 0 5
29414: PUSH
29415: FOR_IN
29416: IFFALSE 29506
// if not GetTag ( j ) then
29418: LD_VAR 0 3
29422: PPUSH
29423: CALL_OW 110
29427: NOT
29428: IFFALSE 29504
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
29430: LD_ADDR_EXP 66
29434: PUSH
29435: LD_EXP 66
29439: PPUSH
29440: LD_VAR 0 2
29444: PUSH
29445: LD_EXP 66
29449: PUSH
29450: LD_VAR 0 2
29454: ARRAY
29455: PUSH
29456: LD_INT 1
29458: PLUS
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PPUSH
29464: LD_VAR 0 3
29468: PPUSH
29469: CALL 51685 0 3
29473: ST_TO_ADDR
// SetTag ( j , 107 ) ;
29474: LD_VAR 0 3
29478: PPUSH
29479: LD_INT 107
29481: PPUSH
29482: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
29486: LD_EXP 66
29490: PUSH
29491: LD_VAR 0 2
29495: ARRAY
29496: PUSH
29497: LD_INT 5
29499: GREATEREQUAL
29500: IFFALSE 29504
// break ;
29502: GO 29506
// end ;
29504: GO 29415
29506: POP
29507: POP
// end ; if mc_crates_collector [ i ] and target then
29508: LD_EXP 66
29512: PUSH
29513: LD_VAR 0 2
29517: ARRAY
29518: PUSH
29519: LD_VAR 0 6
29523: AND
29524: IFFALSE 29767
// begin if mc_crates_collector [ i ] < target [ 1 ] then
29526: LD_EXP 66
29530: PUSH
29531: LD_VAR 0 2
29535: ARRAY
29536: PUSH
29537: LD_VAR 0 6
29541: PUSH
29542: LD_INT 1
29544: ARRAY
29545: LESS
29546: IFFALSE 29566
// tmp := mc_crates_collector [ i ] else
29548: LD_ADDR_VAR 0 5
29552: PUSH
29553: LD_EXP 66
29557: PUSH
29558: LD_VAR 0 2
29562: ARRAY
29563: ST_TO_ADDR
29564: GO 29580
// tmp := target [ 1 ] ;
29566: LD_ADDR_VAR 0 5
29570: PUSH
29571: LD_VAR 0 6
29575: PUSH
29576: LD_INT 1
29578: ARRAY
29579: ST_TO_ADDR
// k := 0 ;
29580: LD_ADDR_VAR 0 4
29584: PUSH
29585: LD_INT 0
29587: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
29588: LD_ADDR_VAR 0 3
29592: PUSH
29593: LD_EXP 66
29597: PUSH
29598: LD_VAR 0 2
29602: ARRAY
29603: PUSH
29604: FOR_IN
29605: IFFALSE 29765
// begin k := k + 1 ;
29607: LD_ADDR_VAR 0 4
29611: PUSH
29612: LD_VAR 0 4
29616: PUSH
29617: LD_INT 1
29619: PLUS
29620: ST_TO_ADDR
// if k > tmp then
29621: LD_VAR 0 4
29625: PUSH
29626: LD_VAR 0 5
29630: GREATER
29631: IFFALSE 29635
// break ;
29633: GO 29765
// if not GetClass ( j ) in [ 2 , 16 ] then
29635: LD_VAR 0 3
29639: PPUSH
29640: CALL_OW 257
29644: PUSH
29645: LD_INT 2
29647: PUSH
29648: LD_INT 16
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: IN
29655: NOT
29656: IFFALSE 29709
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
29658: LD_ADDR_EXP 66
29662: PUSH
29663: LD_EXP 66
29667: PPUSH
29668: LD_VAR 0 2
29672: PPUSH
29673: LD_EXP 66
29677: PUSH
29678: LD_VAR 0 2
29682: ARRAY
29683: PUSH
29684: LD_VAR 0 3
29688: DIFF
29689: PPUSH
29690: CALL_OW 1
29694: ST_TO_ADDR
// SetTag ( j , 0 ) ;
29695: LD_VAR 0 3
29699: PPUSH
29700: LD_INT 0
29702: PPUSH
29703: CALL_OW 109
// continue ;
29707: GO 29604
// end ; if IsInUnit ( j ) then
29709: LD_VAR 0 3
29713: PPUSH
29714: CALL_OW 310
29718: IFFALSE 29729
// ComExitBuilding ( j ) ;
29720: LD_VAR 0 3
29724: PPUSH
29725: CALL_OW 122
// wait ( 3 ) ;
29729: LD_INT 3
29731: PPUSH
29732: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
29736: LD_VAR 0 3
29740: PPUSH
29741: LD_VAR 0 6
29745: PUSH
29746: LD_INT 2
29748: ARRAY
29749: PPUSH
29750: LD_VAR 0 6
29754: PUSH
29755: LD_INT 3
29757: ARRAY
29758: PPUSH
29759: CALL_OW 117
// end ;
29763: GO 29604
29765: POP
29766: POP
// end ; end else
29767: GO 30329
// begin for j in cargo do
29769: LD_ADDR_VAR 0 3
29773: PUSH
29774: LD_VAR 0 7
29778: PUSH
29779: FOR_IN
29780: IFFALSE 30327
// begin if GetTag ( j ) <> 0 then
29782: LD_VAR 0 3
29786: PPUSH
29787: CALL_OW 110
29791: PUSH
29792: LD_INT 0
29794: NONEQUAL
29795: IFFALSE 29799
// continue ;
29797: GO 29779
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
29799: LD_VAR 0 3
29803: PPUSH
29804: CALL_OW 256
29808: PUSH
29809: LD_INT 1000
29811: LESS
29812: PUSH
29813: LD_VAR 0 3
29817: PPUSH
29818: LD_EXP 73
29822: PUSH
29823: LD_VAR 0 2
29827: ARRAY
29828: PPUSH
29829: CALL_OW 308
29833: NOT
29834: AND
29835: IFFALSE 29857
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29837: LD_VAR 0 3
29841: PPUSH
29842: LD_EXP 73
29846: PUSH
29847: LD_VAR 0 2
29851: ARRAY
29852: PPUSH
29853: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
29857: LD_VAR 0 3
29861: PPUSH
29862: CALL_OW 256
29866: PUSH
29867: LD_INT 1000
29869: LESS
29870: PUSH
29871: LD_VAR 0 3
29875: PPUSH
29876: LD_EXP 73
29880: PUSH
29881: LD_VAR 0 2
29885: ARRAY
29886: PPUSH
29887: CALL_OW 308
29891: AND
29892: IFFALSE 29896
// continue ;
29894: GO 29779
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
29896: LD_VAR 0 3
29900: PPUSH
29901: CALL_OW 262
29905: PUSH
29906: LD_INT 2
29908: EQUAL
29909: PUSH
29910: LD_VAR 0 3
29914: PPUSH
29915: CALL_OW 261
29919: PUSH
29920: LD_INT 15
29922: LESS
29923: AND
29924: IFFALSE 29928
// continue ;
29926: GO 29779
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
29928: LD_VAR 0 3
29932: PPUSH
29933: CALL_OW 262
29937: PUSH
29938: LD_INT 1
29940: EQUAL
29941: PUSH
29942: LD_VAR 0 3
29946: PPUSH
29947: CALL_OW 261
29951: PUSH
29952: LD_INT 10
29954: LESS
29955: AND
29956: IFFALSE 30266
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29958: LD_ADDR_VAR 0 8
29962: PUSH
29963: LD_EXP 49
29967: PUSH
29968: LD_VAR 0 2
29972: ARRAY
29973: PPUSH
29974: LD_INT 2
29976: PUSH
29977: LD_INT 30
29979: PUSH
29980: LD_INT 0
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 30
29989: PUSH
29990: LD_INT 1
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: LIST
30001: PPUSH
30002: CALL_OW 72
30006: ST_TO_ADDR
// if not depot then
30007: LD_VAR 0 8
30011: NOT
30012: IFFALSE 30016
// continue ;
30014: GO 29779
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
30016: LD_VAR 0 3
30020: PPUSH
30021: LD_VAR 0 8
30025: PPUSH
30026: LD_VAR 0 3
30030: PPUSH
30031: CALL_OW 74
30035: PPUSH
30036: CALL_OW 296
30040: PUSH
30041: LD_INT 6
30043: LESS
30044: IFFALSE 30060
// SetFuel ( j , 100 ) else
30046: LD_VAR 0 3
30050: PPUSH
30051: LD_INT 100
30053: PPUSH
30054: CALL_OW 240
30058: GO 30266
// if GetFuel ( j ) = 0 then
30060: LD_VAR 0 3
30064: PPUSH
30065: CALL_OW 261
30069: PUSH
30070: LD_INT 0
30072: EQUAL
30073: IFFALSE 30266
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
30075: LD_ADDR_EXP 68
30079: PUSH
30080: LD_EXP 68
30084: PPUSH
30085: LD_VAR 0 2
30089: PPUSH
30090: LD_EXP 68
30094: PUSH
30095: LD_VAR 0 2
30099: ARRAY
30100: PUSH
30101: LD_VAR 0 3
30105: DIFF
30106: PPUSH
30107: CALL_OW 1
30111: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
30112: LD_VAR 0 3
30116: PPUSH
30117: CALL_OW 263
30121: PUSH
30122: LD_INT 1
30124: EQUAL
30125: IFFALSE 30141
// ComExitVehicle ( IsInUnit ( j ) ) ;
30127: LD_VAR 0 3
30131: PPUSH
30132: CALL_OW 310
30136: PPUSH
30137: CALL_OW 121
// if GetControl ( j ) = control_remote then
30141: LD_VAR 0 3
30145: PPUSH
30146: CALL_OW 263
30150: PUSH
30151: LD_INT 2
30153: EQUAL
30154: IFFALSE 30165
// ComUnlink ( j ) ;
30156: LD_VAR 0 3
30160: PPUSH
30161: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
30165: LD_ADDR_VAR 0 9
30169: PUSH
30170: LD_VAR 0 2
30174: PPUSH
30175: LD_INT 3
30177: PPUSH
30178: CALL 39370 0 2
30182: ST_TO_ADDR
// if fac then
30183: LD_VAR 0 9
30187: IFFALSE 30264
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
30189: LD_ADDR_VAR 0 10
30193: PUSH
30194: LD_VAR 0 9
30198: PPUSH
30199: LD_VAR 0 3
30203: PPUSH
30204: CALL_OW 265
30208: PPUSH
30209: LD_VAR 0 3
30213: PPUSH
30214: CALL_OW 262
30218: PPUSH
30219: LD_VAR 0 3
30223: PPUSH
30224: CALL_OW 263
30228: PPUSH
30229: LD_VAR 0 3
30233: PPUSH
30234: CALL_OW 264
30238: PPUSH
30239: CALL 49285 0 5
30243: ST_TO_ADDR
// if components then
30244: LD_VAR 0 10
30248: IFFALSE 30264
// MC_InsertProduceList ( i , components ) ;
30250: LD_VAR 0 2
30254: PPUSH
30255: LD_VAR 0 10
30259: PPUSH
30260: CALL 38998 0 2
// end ; continue ;
30264: GO 29779
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
30266: LD_VAR 0 3
30270: PPUSH
30271: LD_INT 1
30273: PPUSH
30274: CALL_OW 289
30278: PUSH
30279: LD_INT 100
30281: LESS
30282: PUSH
30283: LD_VAR 0 3
30287: PPUSH
30288: CALL_OW 314
30292: NOT
30293: AND
30294: IFFALSE 30323
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
30296: LD_VAR 0 3
30300: PPUSH
30301: LD_VAR 0 6
30305: PUSH
30306: LD_INT 2
30308: ARRAY
30309: PPUSH
30310: LD_VAR 0 6
30314: PUSH
30315: LD_INT 3
30317: ARRAY
30318: PPUSH
30319: CALL_OW 117
// break ;
30323: GO 30327
// end ;
30325: GO 29779
30327: POP
30328: POP
// end ; end ;
30329: GO 28617
30331: POP
30332: POP
// end ;
30333: LD_VAR 0 1
30337: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
30338: LD_INT 0
30340: PPUSH
30341: PPUSH
30342: PPUSH
30343: PPUSH
// if not mc_bases then
30344: LD_EXP 49
30348: NOT
30349: IFFALSE 30353
// exit ;
30351: GO 30514
// for i = 1 to mc_bases do
30353: LD_ADDR_VAR 0 2
30357: PUSH
30358: DOUBLE
30359: LD_INT 1
30361: DEC
30362: ST_TO_ADDR
30363: LD_EXP 49
30367: PUSH
30368: FOR_TO
30369: IFFALSE 30512
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
30371: LD_ADDR_VAR 0 4
30375: PUSH
30376: LD_EXP 68
30380: PUSH
30381: LD_VAR 0 2
30385: ARRAY
30386: PUSH
30387: LD_EXP 71
30391: PUSH
30392: LD_VAR 0 2
30396: ARRAY
30397: UNION
30398: PPUSH
30399: LD_INT 33
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PPUSH
30409: CALL_OW 72
30413: ST_TO_ADDR
// if tmp then
30414: LD_VAR 0 4
30418: IFFALSE 30510
// for j in tmp do
30420: LD_ADDR_VAR 0 3
30424: PUSH
30425: LD_VAR 0 4
30429: PUSH
30430: FOR_IN
30431: IFFALSE 30508
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
30433: LD_VAR 0 3
30437: PPUSH
30438: CALL_OW 312
30442: NOT
30443: PUSH
30444: LD_VAR 0 3
30448: PPUSH
30449: CALL_OW 256
30453: PUSH
30454: LD_INT 250
30456: GREATEREQUAL
30457: AND
30458: IFFALSE 30471
// Connect ( j ) else
30460: LD_VAR 0 3
30464: PPUSH
30465: CALL 54618 0 1
30469: GO 30506
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
30471: LD_VAR 0 3
30475: PPUSH
30476: CALL_OW 256
30480: PUSH
30481: LD_INT 250
30483: LESS
30484: PUSH
30485: LD_VAR 0 3
30489: PPUSH
30490: CALL_OW 312
30494: AND
30495: IFFALSE 30506
// ComUnlink ( j ) ;
30497: LD_VAR 0 3
30501: PPUSH
30502: CALL_OW 136
30506: GO 30430
30508: POP
30509: POP
// end ;
30510: GO 30368
30512: POP
30513: POP
// end ;
30514: LD_VAR 0 1
30518: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
30519: LD_INT 0
30521: PPUSH
30522: PPUSH
30523: PPUSH
30524: PPUSH
30525: PPUSH
// if not mc_bases then
30526: LD_EXP 49
30530: NOT
30531: IFFALSE 30535
// exit ;
30533: GO 30995
// for i = 1 to mc_bases do
30535: LD_ADDR_VAR 0 2
30539: PUSH
30540: DOUBLE
30541: LD_INT 1
30543: DEC
30544: ST_TO_ADDR
30545: LD_EXP 49
30549: PUSH
30550: FOR_TO
30551: IFFALSE 30993
// begin if not mc_produce [ i ] then
30553: LD_EXP 70
30557: PUSH
30558: LD_VAR 0 2
30562: ARRAY
30563: NOT
30564: IFFALSE 30568
// continue ;
30566: GO 30550
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30568: LD_ADDR_VAR 0 5
30572: PUSH
30573: LD_EXP 49
30577: PUSH
30578: LD_VAR 0 2
30582: ARRAY
30583: PPUSH
30584: LD_INT 30
30586: PUSH
30587: LD_INT 3
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PPUSH
30594: CALL_OW 72
30598: ST_TO_ADDR
// if not fac then
30599: LD_VAR 0 5
30603: NOT
30604: IFFALSE 30608
// continue ;
30606: GO 30550
// for j in fac do
30608: LD_ADDR_VAR 0 3
30612: PUSH
30613: LD_VAR 0 5
30617: PUSH
30618: FOR_IN
30619: IFFALSE 30989
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
30621: LD_VAR 0 3
30625: PPUSH
30626: CALL_OW 461
30630: PUSH
30631: LD_INT 2
30633: NONEQUAL
30634: PUSH
30635: LD_VAR 0 3
30639: PPUSH
30640: LD_INT 15
30642: PPUSH
30643: CALL 54278 0 2
30647: PUSH
30648: LD_INT 4
30650: ARRAY
30651: OR
30652: PUSH
30653: LD_VAR 0 3
30657: PPUSH
30658: CALL_OW 313
30662: PUSH
30663: LD_INT 0
30665: EQUAL
30666: OR
30667: IFFALSE 30671
// continue ;
30669: GO 30618
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
30671: LD_VAR 0 3
30675: PPUSH
30676: LD_EXP 70
30680: PUSH
30681: LD_VAR 0 2
30685: ARRAY
30686: PUSH
30687: LD_INT 1
30689: ARRAY
30690: PUSH
30691: LD_INT 1
30693: ARRAY
30694: PPUSH
30695: LD_EXP 70
30699: PUSH
30700: LD_VAR 0 2
30704: ARRAY
30705: PUSH
30706: LD_INT 1
30708: ARRAY
30709: PUSH
30710: LD_INT 2
30712: ARRAY
30713: PPUSH
30714: LD_EXP 70
30718: PUSH
30719: LD_VAR 0 2
30723: ARRAY
30724: PUSH
30725: LD_INT 1
30727: ARRAY
30728: PUSH
30729: LD_INT 3
30731: ARRAY
30732: PPUSH
30733: LD_EXP 70
30737: PUSH
30738: LD_VAR 0 2
30742: ARRAY
30743: PUSH
30744: LD_INT 1
30746: ARRAY
30747: PUSH
30748: LD_INT 4
30750: ARRAY
30751: PPUSH
30752: CALL_OW 448
30756: PUSH
30757: LD_VAR 0 3
30761: PPUSH
30762: LD_EXP 70
30766: PUSH
30767: LD_VAR 0 2
30771: ARRAY
30772: PUSH
30773: LD_INT 1
30775: ARRAY
30776: PUSH
30777: LD_INT 1
30779: ARRAY
30780: PUSH
30781: LD_EXP 70
30785: PUSH
30786: LD_VAR 0 2
30790: ARRAY
30791: PUSH
30792: LD_INT 1
30794: ARRAY
30795: PUSH
30796: LD_INT 2
30798: ARRAY
30799: PUSH
30800: LD_EXP 70
30804: PUSH
30805: LD_VAR 0 2
30809: ARRAY
30810: PUSH
30811: LD_INT 1
30813: ARRAY
30814: PUSH
30815: LD_INT 3
30817: ARRAY
30818: PUSH
30819: LD_EXP 70
30823: PUSH
30824: LD_VAR 0 2
30828: ARRAY
30829: PUSH
30830: LD_INT 1
30832: ARRAY
30833: PUSH
30834: LD_INT 4
30836: ARRAY
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: LIST
30842: LIST
30843: PPUSH
30844: CALL 57949 0 2
30848: AND
30849: IFFALSE 30987
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
30851: LD_VAR 0 3
30855: PPUSH
30856: LD_EXP 70
30860: PUSH
30861: LD_VAR 0 2
30865: ARRAY
30866: PUSH
30867: LD_INT 1
30869: ARRAY
30870: PUSH
30871: LD_INT 1
30873: ARRAY
30874: PPUSH
30875: LD_EXP 70
30879: PUSH
30880: LD_VAR 0 2
30884: ARRAY
30885: PUSH
30886: LD_INT 1
30888: ARRAY
30889: PUSH
30890: LD_INT 2
30892: ARRAY
30893: PPUSH
30894: LD_EXP 70
30898: PUSH
30899: LD_VAR 0 2
30903: ARRAY
30904: PUSH
30905: LD_INT 1
30907: ARRAY
30908: PUSH
30909: LD_INT 3
30911: ARRAY
30912: PPUSH
30913: LD_EXP 70
30917: PUSH
30918: LD_VAR 0 2
30922: ARRAY
30923: PUSH
30924: LD_INT 1
30926: ARRAY
30927: PUSH
30928: LD_INT 4
30930: ARRAY
30931: PPUSH
30932: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
30936: LD_ADDR_VAR 0 4
30940: PUSH
30941: LD_EXP 70
30945: PUSH
30946: LD_VAR 0 2
30950: ARRAY
30951: PPUSH
30952: LD_INT 1
30954: PPUSH
30955: CALL_OW 3
30959: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
30960: LD_ADDR_EXP 70
30964: PUSH
30965: LD_EXP 70
30969: PPUSH
30970: LD_VAR 0 2
30974: PPUSH
30975: LD_VAR 0 4
30979: PPUSH
30980: CALL_OW 1
30984: ST_TO_ADDR
// break ;
30985: GO 30989
// end ; end ;
30987: GO 30618
30989: POP
30990: POP
// end ;
30991: GO 30550
30993: POP
30994: POP
// end ;
30995: LD_VAR 0 1
30999: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
31000: LD_INT 0
31002: PPUSH
31003: PPUSH
31004: PPUSH
// if not mc_bases then
31005: LD_EXP 49
31009: NOT
31010: IFFALSE 31014
// exit ;
31012: GO 31103
// for i = 1 to mc_bases do
31014: LD_ADDR_VAR 0 2
31018: PUSH
31019: DOUBLE
31020: LD_INT 1
31022: DEC
31023: ST_TO_ADDR
31024: LD_EXP 49
31028: PUSH
31029: FOR_TO
31030: IFFALSE 31101
// begin if mc_attack [ i ] then
31032: LD_EXP 69
31036: PUSH
31037: LD_VAR 0 2
31041: ARRAY
31042: IFFALSE 31099
// begin tmp := mc_attack [ i ] [ 1 ] ;
31044: LD_ADDR_VAR 0 3
31048: PUSH
31049: LD_EXP 69
31053: PUSH
31054: LD_VAR 0 2
31058: ARRAY
31059: PUSH
31060: LD_INT 1
31062: ARRAY
31063: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
31064: LD_ADDR_EXP 69
31068: PUSH
31069: LD_EXP 69
31073: PPUSH
31074: LD_VAR 0 2
31078: PPUSH
31079: EMPTY
31080: PPUSH
31081: CALL_OW 1
31085: ST_TO_ADDR
// Attack ( tmp ) ;
31086: LD_VAR 0 3
31090: PPUSH
31091: CALL 80138 0 1
// exit ;
31095: POP
31096: POP
31097: GO 31103
// end ; end ;
31099: GO 31029
31101: POP
31102: POP
// end ;
31103: LD_VAR 0 1
31107: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
31108: LD_INT 0
31110: PPUSH
31111: PPUSH
31112: PPUSH
31113: PPUSH
31114: PPUSH
31115: PPUSH
31116: PPUSH
// if not mc_bases then
31117: LD_EXP 49
31121: NOT
31122: IFFALSE 31126
// exit ;
31124: GO 31730
// for i = 1 to mc_bases do
31126: LD_ADDR_VAR 0 2
31130: PUSH
31131: DOUBLE
31132: LD_INT 1
31134: DEC
31135: ST_TO_ADDR
31136: LD_EXP 49
31140: PUSH
31141: FOR_TO
31142: IFFALSE 31728
// begin if not mc_bases [ i ] then
31144: LD_EXP 49
31148: PUSH
31149: LD_VAR 0 2
31153: ARRAY
31154: NOT
31155: IFFALSE 31159
// continue ;
31157: GO 31141
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
31159: LD_ADDR_VAR 0 7
31163: PUSH
31164: LD_EXP 49
31168: PUSH
31169: LD_VAR 0 2
31173: ARRAY
31174: PUSH
31175: LD_INT 1
31177: ARRAY
31178: PPUSH
31179: CALL 48589 0 1
31183: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
31184: LD_ADDR_EXP 72
31188: PUSH
31189: LD_EXP 72
31193: PPUSH
31194: LD_VAR 0 2
31198: PPUSH
31199: LD_EXP 49
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PUSH
31210: LD_INT 1
31212: ARRAY
31213: PPUSH
31214: CALL_OW 255
31218: PPUSH
31219: LD_EXP 74
31223: PUSH
31224: LD_VAR 0 2
31228: ARRAY
31229: PPUSH
31230: CALL 46549 0 2
31234: PPUSH
31235: CALL_OW 1
31239: ST_TO_ADDR
// if not mc_scan [ i ] then
31240: LD_EXP 72
31244: PUSH
31245: LD_VAR 0 2
31249: ARRAY
31250: NOT
31251: IFFALSE 31406
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
31253: LD_ADDR_VAR 0 4
31257: PUSH
31258: LD_EXP 49
31262: PUSH
31263: LD_VAR 0 2
31267: ARRAY
31268: PPUSH
31269: LD_INT 2
31271: PUSH
31272: LD_INT 25
31274: PUSH
31275: LD_INT 5
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 25
31284: PUSH
31285: LD_INT 8
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 25
31294: PUSH
31295: LD_INT 9
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: PPUSH
31308: CALL_OW 72
31312: ST_TO_ADDR
// if not tmp then
31313: LD_VAR 0 4
31317: NOT
31318: IFFALSE 31322
// continue ;
31320: GO 31141
// for j in tmp do
31322: LD_ADDR_VAR 0 3
31326: PUSH
31327: LD_VAR 0 4
31331: PUSH
31332: FOR_IN
31333: IFFALSE 31404
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
31335: LD_VAR 0 3
31339: PPUSH
31340: CALL_OW 310
31344: PPUSH
31345: CALL_OW 266
31349: PUSH
31350: LD_INT 5
31352: EQUAL
31353: PUSH
31354: LD_VAR 0 3
31358: PPUSH
31359: CALL_OW 257
31363: PUSH
31364: LD_INT 1
31366: EQUAL
31367: AND
31368: PUSH
31369: LD_VAR 0 3
31373: PPUSH
31374: CALL_OW 459
31378: NOT
31379: AND
31380: PUSH
31381: LD_VAR 0 7
31385: AND
31386: IFFALSE 31402
// ComChangeProfession ( j , class ) ;
31388: LD_VAR 0 3
31392: PPUSH
31393: LD_VAR 0 7
31397: PPUSH
31398: CALL_OW 123
31402: GO 31332
31404: POP
31405: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
31406: LD_EXP 72
31410: PUSH
31411: LD_VAR 0 2
31415: ARRAY
31416: PUSH
31417: LD_EXP 71
31421: PUSH
31422: LD_VAR 0 2
31426: ARRAY
31427: NOT
31428: AND
31429: PUSH
31430: LD_EXP 49
31434: PUSH
31435: LD_VAR 0 2
31439: ARRAY
31440: PPUSH
31441: LD_INT 30
31443: PUSH
31444: LD_INT 32
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PPUSH
31451: CALL_OW 72
31455: NOT
31456: AND
31457: PUSH
31458: LD_EXP 49
31462: PUSH
31463: LD_VAR 0 2
31467: ARRAY
31468: PPUSH
31469: LD_INT 2
31471: PUSH
31472: LD_INT 30
31474: PUSH
31475: LD_INT 4
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 30
31484: PUSH
31485: LD_INT 5
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: LIST
31496: PPUSH
31497: CALL_OW 72
31501: NOT
31502: AND
31503: IFFALSE 31635
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
31505: LD_ADDR_VAR 0 4
31509: PUSH
31510: LD_EXP 49
31514: PUSH
31515: LD_VAR 0 2
31519: ARRAY
31520: PPUSH
31521: LD_INT 2
31523: PUSH
31524: LD_INT 25
31526: PUSH
31527: LD_INT 1
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PUSH
31534: LD_INT 25
31536: PUSH
31537: LD_INT 5
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: LD_INT 25
31546: PUSH
31547: LD_INT 8
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: LD_INT 25
31556: PUSH
31557: LD_INT 9
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: PPUSH
31571: CALL_OW 72
31575: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
31576: LD_ADDR_VAR 0 4
31580: PUSH
31581: LD_VAR 0 4
31585: PUSH
31586: LD_VAR 0 4
31590: PPUSH
31591: LD_INT 18
31593: PPUSH
31594: CALL 84882 0 2
31598: DIFF
31599: ST_TO_ADDR
// if tmp then
31600: LD_VAR 0 4
31604: IFFALSE 31635
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
31606: LD_VAR 0 2
31610: PPUSH
31611: LD_VAR 0 4
31615: PPUSH
31616: LD_EXP 74
31620: PUSH
31621: LD_VAR 0 2
31625: ARRAY
31626: PPUSH
31627: CALL 46584 0 3
// exit ;
31631: POP
31632: POP
31633: GO 31730
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
31635: LD_EXP 72
31639: PUSH
31640: LD_VAR 0 2
31644: ARRAY
31645: PUSH
31646: LD_EXP 71
31650: PUSH
31651: LD_VAR 0 2
31655: ARRAY
31656: AND
31657: IFFALSE 31726
// begin tmp := mc_defender [ i ] ;
31659: LD_ADDR_VAR 0 4
31663: PUSH
31664: LD_EXP 71
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
31675: LD_ADDR_EXP 71
31679: PUSH
31680: LD_EXP 71
31684: PPUSH
31685: LD_VAR 0 2
31689: PPUSH
31690: EMPTY
31691: PPUSH
31692: CALL_OW 1
31696: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
31697: LD_VAR 0 2
31701: PPUSH
31702: LD_VAR 0 4
31706: PPUSH
31707: LD_EXP 72
31711: PUSH
31712: LD_VAR 0 2
31716: ARRAY
31717: PPUSH
31718: CALL 47082 0 3
// exit ;
31722: POP
31723: POP
31724: GO 31730
// end ; end ;
31726: GO 31141
31728: POP
31729: POP
// end ;
31730: LD_VAR 0 1
31734: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
31735: LD_INT 0
31737: PPUSH
31738: PPUSH
31739: PPUSH
31740: PPUSH
31741: PPUSH
31742: PPUSH
31743: PPUSH
31744: PPUSH
31745: PPUSH
31746: PPUSH
31747: PPUSH
// if not mc_bases then
31748: LD_EXP 49
31752: NOT
31753: IFFALSE 31757
// exit ;
31755: GO 32844
// for i = 1 to mc_bases do
31757: LD_ADDR_VAR 0 2
31761: PUSH
31762: DOUBLE
31763: LD_INT 1
31765: DEC
31766: ST_TO_ADDR
31767: LD_EXP 49
31771: PUSH
31772: FOR_TO
31773: IFFALSE 32842
// begin tmp := mc_lab [ i ] ;
31775: LD_ADDR_VAR 0 6
31779: PUSH
31780: LD_EXP 82
31784: PUSH
31785: LD_VAR 0 2
31789: ARRAY
31790: ST_TO_ADDR
// if not tmp then
31791: LD_VAR 0 6
31795: NOT
31796: IFFALSE 31800
// continue ;
31798: GO 31772
// idle_lab := 0 ;
31800: LD_ADDR_VAR 0 11
31804: PUSH
31805: LD_INT 0
31807: ST_TO_ADDR
// for j in tmp do
31808: LD_ADDR_VAR 0 3
31812: PUSH
31813: LD_VAR 0 6
31817: PUSH
31818: FOR_IN
31819: IFFALSE 32838
// begin researching := false ;
31821: LD_ADDR_VAR 0 10
31825: PUSH
31826: LD_INT 0
31828: ST_TO_ADDR
// side := GetSide ( j ) ;
31829: LD_ADDR_VAR 0 4
31833: PUSH
31834: LD_VAR 0 3
31838: PPUSH
31839: CALL_OW 255
31843: ST_TO_ADDR
// if not mc_tech [ side ] then
31844: LD_EXP 76
31848: PUSH
31849: LD_VAR 0 4
31853: ARRAY
31854: NOT
31855: IFFALSE 31859
// continue ;
31857: GO 31818
// if BuildingStatus ( j ) = bs_idle then
31859: LD_VAR 0 3
31863: PPUSH
31864: CALL_OW 461
31868: PUSH
31869: LD_INT 2
31871: EQUAL
31872: IFFALSE 32060
// begin if idle_lab and UnitsInside ( j ) < 6 then
31874: LD_VAR 0 11
31878: PUSH
31879: LD_VAR 0 3
31883: PPUSH
31884: CALL_OW 313
31888: PUSH
31889: LD_INT 6
31891: LESS
31892: AND
31893: IFFALSE 31964
// begin tmp2 := UnitsInside ( idle_lab ) ;
31895: LD_ADDR_VAR 0 9
31899: PUSH
31900: LD_VAR 0 11
31904: PPUSH
31905: CALL_OW 313
31909: ST_TO_ADDR
// if tmp2 then
31910: LD_VAR 0 9
31914: IFFALSE 31956
// for x in tmp2 do
31916: LD_ADDR_VAR 0 7
31920: PUSH
31921: LD_VAR 0 9
31925: PUSH
31926: FOR_IN
31927: IFFALSE 31954
// begin ComExitBuilding ( x ) ;
31929: LD_VAR 0 7
31933: PPUSH
31934: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
31938: LD_VAR 0 7
31942: PPUSH
31943: LD_VAR 0 3
31947: PPUSH
31948: CALL_OW 180
// end ;
31952: GO 31926
31954: POP
31955: POP
// idle_lab := 0 ;
31956: LD_ADDR_VAR 0 11
31960: PUSH
31961: LD_INT 0
31963: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
31964: LD_ADDR_VAR 0 5
31968: PUSH
31969: LD_EXP 76
31973: PUSH
31974: LD_VAR 0 4
31978: ARRAY
31979: PUSH
31980: FOR_IN
31981: IFFALSE 32041
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
31983: LD_VAR 0 3
31987: PPUSH
31988: LD_VAR 0 5
31992: PPUSH
31993: CALL_OW 430
31997: PUSH
31998: LD_VAR 0 4
32002: PPUSH
32003: LD_VAR 0 5
32007: PPUSH
32008: CALL 45654 0 2
32012: AND
32013: IFFALSE 32039
// begin researching := true ;
32015: LD_ADDR_VAR 0 10
32019: PUSH
32020: LD_INT 1
32022: ST_TO_ADDR
// ComResearch ( j , t ) ;
32023: LD_VAR 0 3
32027: PPUSH
32028: LD_VAR 0 5
32032: PPUSH
32033: CALL_OW 124
// break ;
32037: GO 32041
// end ;
32039: GO 31980
32041: POP
32042: POP
// if not researching then
32043: LD_VAR 0 10
32047: NOT
32048: IFFALSE 32060
// idle_lab := j ;
32050: LD_ADDR_VAR 0 11
32054: PUSH
32055: LD_VAR 0 3
32059: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
32060: LD_VAR 0 3
32064: PPUSH
32065: CALL_OW 461
32069: PUSH
32070: LD_INT 10
32072: EQUAL
32073: IFFALSE 32661
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
32075: LD_EXP 78
32079: PUSH
32080: LD_VAR 0 2
32084: ARRAY
32085: NOT
32086: PUSH
32087: LD_EXP 79
32091: PUSH
32092: LD_VAR 0 2
32096: ARRAY
32097: NOT
32098: AND
32099: PUSH
32100: LD_EXP 76
32104: PUSH
32105: LD_VAR 0 4
32109: ARRAY
32110: PUSH
32111: LD_INT 1
32113: GREATER
32114: AND
32115: IFFALSE 32246
// begin ComCancel ( j ) ;
32117: LD_VAR 0 3
32121: PPUSH
32122: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
32126: LD_ADDR_EXP 76
32130: PUSH
32131: LD_EXP 76
32135: PPUSH
32136: LD_VAR 0 4
32140: PPUSH
32141: LD_EXP 76
32145: PUSH
32146: LD_VAR 0 4
32150: ARRAY
32151: PPUSH
32152: LD_EXP 76
32156: PUSH
32157: LD_VAR 0 4
32161: ARRAY
32162: PUSH
32163: LD_INT 1
32165: MINUS
32166: PPUSH
32167: LD_EXP 76
32171: PUSH
32172: LD_VAR 0 4
32176: ARRAY
32177: PPUSH
32178: LD_INT 0
32180: PPUSH
32181: CALL 51103 0 4
32185: PPUSH
32186: CALL_OW 1
32190: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
32191: LD_ADDR_EXP 76
32195: PUSH
32196: LD_EXP 76
32200: PPUSH
32201: LD_VAR 0 4
32205: PPUSH
32206: LD_EXP 76
32210: PUSH
32211: LD_VAR 0 4
32215: ARRAY
32216: PPUSH
32217: LD_EXP 76
32221: PUSH
32222: LD_VAR 0 4
32226: ARRAY
32227: PPUSH
32228: LD_INT 1
32230: PPUSH
32231: LD_INT 0
32233: PPUSH
32234: CALL 51103 0 4
32238: PPUSH
32239: CALL_OW 1
32243: ST_TO_ADDR
// continue ;
32244: GO 31818
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
32246: LD_EXP 78
32250: PUSH
32251: LD_VAR 0 2
32255: ARRAY
32256: PUSH
32257: LD_EXP 79
32261: PUSH
32262: LD_VAR 0 2
32266: ARRAY
32267: NOT
32268: AND
32269: IFFALSE 32396
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
32271: LD_ADDR_EXP 79
32275: PUSH
32276: LD_EXP 79
32280: PPUSH
32281: LD_VAR 0 2
32285: PUSH
32286: LD_EXP 79
32290: PUSH
32291: LD_VAR 0 2
32295: ARRAY
32296: PUSH
32297: LD_INT 1
32299: PLUS
32300: PUSH
32301: EMPTY
32302: LIST
32303: LIST
32304: PPUSH
32305: LD_EXP 78
32309: PUSH
32310: LD_VAR 0 2
32314: ARRAY
32315: PUSH
32316: LD_INT 1
32318: ARRAY
32319: PPUSH
32320: CALL 51685 0 3
32324: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
32325: LD_EXP 78
32329: PUSH
32330: LD_VAR 0 2
32334: ARRAY
32335: PUSH
32336: LD_INT 1
32338: ARRAY
32339: PPUSH
32340: LD_INT 112
32342: PPUSH
32343: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
32347: LD_ADDR_VAR 0 9
32351: PUSH
32352: LD_EXP 78
32356: PUSH
32357: LD_VAR 0 2
32361: ARRAY
32362: PPUSH
32363: LD_INT 1
32365: PPUSH
32366: CALL_OW 3
32370: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
32371: LD_ADDR_EXP 78
32375: PUSH
32376: LD_EXP 78
32380: PPUSH
32381: LD_VAR 0 2
32385: PPUSH
32386: LD_VAR 0 9
32390: PPUSH
32391: CALL_OW 1
32395: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
32396: LD_EXP 78
32400: PUSH
32401: LD_VAR 0 2
32405: ARRAY
32406: PUSH
32407: LD_EXP 79
32411: PUSH
32412: LD_VAR 0 2
32416: ARRAY
32417: AND
32418: PUSH
32419: LD_EXP 79
32423: PUSH
32424: LD_VAR 0 2
32428: ARRAY
32429: PUSH
32430: LD_INT 1
32432: ARRAY
32433: PPUSH
32434: CALL_OW 310
32438: NOT
32439: AND
32440: PUSH
32441: LD_VAR 0 3
32445: PPUSH
32446: CALL_OW 313
32450: PUSH
32451: LD_INT 6
32453: EQUAL
32454: AND
32455: IFFALSE 32511
// begin tmp2 := UnitsInside ( j ) ;
32457: LD_ADDR_VAR 0 9
32461: PUSH
32462: LD_VAR 0 3
32466: PPUSH
32467: CALL_OW 313
32471: ST_TO_ADDR
// if tmp2 = 6 then
32472: LD_VAR 0 9
32476: PUSH
32477: LD_INT 6
32479: EQUAL
32480: IFFALSE 32511
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
32482: LD_VAR 0 9
32486: PUSH
32487: LD_INT 1
32489: ARRAY
32490: PPUSH
32491: LD_INT 112
32493: PPUSH
32494: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
32498: LD_VAR 0 9
32502: PUSH
32503: LD_INT 1
32505: ARRAY
32506: PPUSH
32507: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
32511: LD_EXP 79
32515: PUSH
32516: LD_VAR 0 2
32520: ARRAY
32521: PUSH
32522: LD_EXP 79
32526: PUSH
32527: LD_VAR 0 2
32531: ARRAY
32532: PUSH
32533: LD_INT 1
32535: ARRAY
32536: PPUSH
32537: CALL_OW 314
32541: NOT
32542: AND
32543: PUSH
32544: LD_EXP 79
32548: PUSH
32549: LD_VAR 0 2
32553: ARRAY
32554: PUSH
32555: LD_INT 1
32557: ARRAY
32558: PPUSH
32559: CALL_OW 310
32563: NOT
32564: AND
32565: IFFALSE 32591
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
32567: LD_EXP 79
32571: PUSH
32572: LD_VAR 0 2
32576: ARRAY
32577: PUSH
32578: LD_INT 1
32580: ARRAY
32581: PPUSH
32582: LD_VAR 0 3
32586: PPUSH
32587: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
32591: LD_EXP 79
32595: PUSH
32596: LD_VAR 0 2
32600: ARRAY
32601: PUSH
32602: LD_INT 1
32604: ARRAY
32605: PPUSH
32606: CALL_OW 310
32610: PUSH
32611: LD_EXP 79
32615: PUSH
32616: LD_VAR 0 2
32620: ARRAY
32621: PUSH
32622: LD_INT 1
32624: ARRAY
32625: PPUSH
32626: CALL_OW 310
32630: PPUSH
32631: CALL_OW 461
32635: PUSH
32636: LD_INT 3
32638: NONEQUAL
32639: AND
32640: IFFALSE 32661
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
32642: LD_EXP 79
32646: PUSH
32647: LD_VAR 0 2
32651: ARRAY
32652: PUSH
32653: LD_INT 1
32655: ARRAY
32656: PPUSH
32657: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
32661: LD_VAR 0 3
32665: PPUSH
32666: CALL_OW 461
32670: PUSH
32671: LD_INT 6
32673: EQUAL
32674: PUSH
32675: LD_VAR 0 6
32679: PUSH
32680: LD_INT 1
32682: GREATER
32683: AND
32684: IFFALSE 32836
// begin sci := [ ] ;
32686: LD_ADDR_VAR 0 8
32690: PUSH
32691: EMPTY
32692: ST_TO_ADDR
// for x in ( tmp diff j ) do
32693: LD_ADDR_VAR 0 7
32697: PUSH
32698: LD_VAR 0 6
32702: PUSH
32703: LD_VAR 0 3
32707: DIFF
32708: PUSH
32709: FOR_IN
32710: IFFALSE 32762
// begin if sci = 6 then
32712: LD_VAR 0 8
32716: PUSH
32717: LD_INT 6
32719: EQUAL
32720: IFFALSE 32724
// break ;
32722: GO 32762
// if BuildingStatus ( x ) = bs_idle then
32724: LD_VAR 0 7
32728: PPUSH
32729: CALL_OW 461
32733: PUSH
32734: LD_INT 2
32736: EQUAL
32737: IFFALSE 32760
// sci := sci ^ UnitsInside ( x ) ;
32739: LD_ADDR_VAR 0 8
32743: PUSH
32744: LD_VAR 0 8
32748: PUSH
32749: LD_VAR 0 7
32753: PPUSH
32754: CALL_OW 313
32758: ADD
32759: ST_TO_ADDR
// end ;
32760: GO 32709
32762: POP
32763: POP
// if not sci then
32764: LD_VAR 0 8
32768: NOT
32769: IFFALSE 32773
// continue ;
32771: GO 31818
// for x in sci do
32773: LD_ADDR_VAR 0 7
32777: PUSH
32778: LD_VAR 0 8
32782: PUSH
32783: FOR_IN
32784: IFFALSE 32834
// if IsInUnit ( x ) and not HasTask ( x ) then
32786: LD_VAR 0 7
32790: PPUSH
32791: CALL_OW 310
32795: PUSH
32796: LD_VAR 0 7
32800: PPUSH
32801: CALL_OW 314
32805: NOT
32806: AND
32807: IFFALSE 32832
// begin ComExitBuilding ( x ) ;
32809: LD_VAR 0 7
32813: PPUSH
32814: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
32818: LD_VAR 0 7
32822: PPUSH
32823: LD_VAR 0 3
32827: PPUSH
32828: CALL_OW 180
// end ;
32832: GO 32783
32834: POP
32835: POP
// end ; end ;
32836: GO 31818
32838: POP
32839: POP
// end ;
32840: GO 31772
32842: POP
32843: POP
// end ;
32844: LD_VAR 0 1
32848: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
32849: LD_INT 0
32851: PPUSH
32852: PPUSH
// if not mc_bases then
32853: LD_EXP 49
32857: NOT
32858: IFFALSE 32862
// exit ;
32860: GO 32943
// for i = 1 to mc_bases do
32862: LD_ADDR_VAR 0 2
32866: PUSH
32867: DOUBLE
32868: LD_INT 1
32870: DEC
32871: ST_TO_ADDR
32872: LD_EXP 49
32876: PUSH
32877: FOR_TO
32878: IFFALSE 32941
// if mc_mines [ i ] and mc_miners [ i ] then
32880: LD_EXP 62
32884: PUSH
32885: LD_VAR 0 2
32889: ARRAY
32890: PUSH
32891: LD_EXP 63
32895: PUSH
32896: LD_VAR 0 2
32900: ARRAY
32901: AND
32902: IFFALSE 32939
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
32904: LD_EXP 63
32908: PUSH
32909: LD_VAR 0 2
32913: ARRAY
32914: PUSH
32915: LD_INT 1
32917: ARRAY
32918: PPUSH
32919: CALL_OW 255
32923: PPUSH
32924: LD_EXP 62
32928: PUSH
32929: LD_VAR 0 2
32933: ARRAY
32934: PPUSH
32935: CALL 48742 0 2
32939: GO 32877
32941: POP
32942: POP
// end ;
32943: LD_VAR 0 1
32947: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
32948: LD_INT 0
32950: PPUSH
32951: PPUSH
32952: PPUSH
32953: PPUSH
32954: PPUSH
32955: PPUSH
32956: PPUSH
32957: PPUSH
// if not mc_bases or not mc_parking then
32958: LD_EXP 49
32962: NOT
32963: PUSH
32964: LD_EXP 73
32968: NOT
32969: OR
32970: IFFALSE 32974
// exit ;
32972: GO 33686
// for i = 1 to mc_bases do
32974: LD_ADDR_VAR 0 2
32978: PUSH
32979: DOUBLE
32980: LD_INT 1
32982: DEC
32983: ST_TO_ADDR
32984: LD_EXP 49
32988: PUSH
32989: FOR_TO
32990: IFFALSE 33684
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
32992: LD_EXP 49
32996: PUSH
32997: LD_VAR 0 2
33001: ARRAY
33002: NOT
33003: PUSH
33004: LD_EXP 73
33008: PUSH
33009: LD_VAR 0 2
33013: ARRAY
33014: NOT
33015: OR
33016: IFFALSE 33020
// continue ;
33018: GO 32989
// if mc_scan [ i ] then
33020: LD_EXP 72
33024: PUSH
33025: LD_VAR 0 2
33029: ARRAY
33030: IFFALSE 33056
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
33032: LD_ADDR_EXP 61
33036: PUSH
33037: LD_EXP 61
33041: PPUSH
33042: LD_VAR 0 2
33046: PPUSH
33047: EMPTY
33048: PPUSH
33049: CALL_OW 1
33053: ST_TO_ADDR
// continue ;
33054: GO 32989
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
33056: LD_ADDR_VAR 0 5
33060: PUSH
33061: LD_EXP 49
33065: PUSH
33066: LD_VAR 0 2
33070: ARRAY
33071: PUSH
33072: LD_INT 1
33074: ARRAY
33075: PPUSH
33076: CALL_OW 255
33080: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33081: LD_ADDR_VAR 0 6
33085: PUSH
33086: LD_EXP 49
33090: PUSH
33091: LD_VAR 0 2
33095: ARRAY
33096: PPUSH
33097: LD_INT 30
33099: PUSH
33100: LD_INT 3
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PPUSH
33107: CALL_OW 72
33111: ST_TO_ADDR
// if not fac then
33112: LD_VAR 0 6
33116: NOT
33117: IFFALSE 33168
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_EXP 49
33128: PUSH
33129: LD_VAR 0 2
33133: ARRAY
33134: PPUSH
33135: LD_INT 2
33137: PUSH
33138: LD_INT 30
33140: PUSH
33141: LD_INT 0
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 30
33150: PUSH
33151: LD_INT 1
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: PPUSH
33163: CALL_OW 72
33167: ST_TO_ADDR
// if not fac then
33168: LD_VAR 0 6
33172: NOT
33173: IFFALSE 33177
// continue ;
33175: GO 32989
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
33177: LD_ADDR_VAR 0 7
33181: PUSH
33182: LD_EXP 73
33186: PUSH
33187: LD_VAR 0 2
33191: ARRAY
33192: PPUSH
33193: LD_INT 22
33195: PUSH
33196: LD_VAR 0 5
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 21
33207: PUSH
33208: LD_INT 2
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 3
33217: PUSH
33218: LD_INT 24
33220: PUSH
33221: LD_INT 1000
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: LIST
33236: PPUSH
33237: CALL_OW 70
33241: PUSH
33242: LD_INT 22
33244: PUSH
33245: LD_VAR 0 5
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 91
33256: PUSH
33257: LD_VAR 0 6
33261: PUSH
33262: LD_INT 1
33264: ARRAY
33265: PUSH
33266: LD_INT 25
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 21
33276: PUSH
33277: LD_INT 2
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 3
33286: PUSH
33287: LD_INT 24
33289: PUSH
33290: LD_INT 1000
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: PPUSH
33307: CALL_OW 69
33311: UNION
33312: ST_TO_ADDR
// if not vehs then
33313: LD_VAR 0 7
33317: NOT
33318: IFFALSE 33344
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
33320: LD_ADDR_EXP 61
33324: PUSH
33325: LD_EXP 61
33329: PPUSH
33330: LD_VAR 0 2
33334: PPUSH
33335: EMPTY
33336: PPUSH
33337: CALL_OW 1
33341: ST_TO_ADDR
// continue ;
33342: GO 32989
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33344: LD_ADDR_VAR 0 8
33348: PUSH
33349: LD_EXP 49
33353: PUSH
33354: LD_VAR 0 2
33358: ARRAY
33359: PPUSH
33360: LD_INT 30
33362: PUSH
33363: LD_INT 3
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PPUSH
33370: CALL_OW 72
33374: ST_TO_ADDR
// if tmp then
33375: LD_VAR 0 8
33379: IFFALSE 33482
// begin for j in tmp do
33381: LD_ADDR_VAR 0 3
33385: PUSH
33386: LD_VAR 0 8
33390: PUSH
33391: FOR_IN
33392: IFFALSE 33480
// for k in UnitsInside ( j ) do
33394: LD_ADDR_VAR 0 4
33398: PUSH
33399: LD_VAR 0 3
33403: PPUSH
33404: CALL_OW 313
33408: PUSH
33409: FOR_IN
33410: IFFALSE 33476
// if k then
33412: LD_VAR 0 4
33416: IFFALSE 33474
// if not k in mc_repair_vehicle [ i ] then
33418: LD_VAR 0 4
33422: PUSH
33423: LD_EXP 61
33427: PUSH
33428: LD_VAR 0 2
33432: ARRAY
33433: IN
33434: NOT
33435: IFFALSE 33474
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
33437: LD_ADDR_EXP 61
33441: PUSH
33442: LD_EXP 61
33446: PPUSH
33447: LD_VAR 0 2
33451: PPUSH
33452: LD_EXP 61
33456: PUSH
33457: LD_VAR 0 2
33461: ARRAY
33462: PUSH
33463: LD_VAR 0 4
33467: UNION
33468: PPUSH
33469: CALL_OW 1
33473: ST_TO_ADDR
33474: GO 33409
33476: POP
33477: POP
33478: GO 33391
33480: POP
33481: POP
// end ; if not mc_repair_vehicle [ i ] then
33482: LD_EXP 61
33486: PUSH
33487: LD_VAR 0 2
33491: ARRAY
33492: NOT
33493: IFFALSE 33497
// continue ;
33495: GO 32989
// for j in mc_repair_vehicle [ i ] do
33497: LD_ADDR_VAR 0 3
33501: PUSH
33502: LD_EXP 61
33506: PUSH
33507: LD_VAR 0 2
33511: ARRAY
33512: PUSH
33513: FOR_IN
33514: IFFALSE 33680
// begin if GetClass ( j ) <> 3 then
33516: LD_VAR 0 3
33520: PPUSH
33521: CALL_OW 257
33525: PUSH
33526: LD_INT 3
33528: NONEQUAL
33529: IFFALSE 33570
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
33531: LD_ADDR_EXP 61
33535: PUSH
33536: LD_EXP 61
33540: PPUSH
33541: LD_VAR 0 2
33545: PPUSH
33546: LD_EXP 61
33550: PUSH
33551: LD_VAR 0 2
33555: ARRAY
33556: PUSH
33557: LD_VAR 0 3
33561: DIFF
33562: PPUSH
33563: CALL_OW 1
33567: ST_TO_ADDR
// continue ;
33568: GO 33513
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
33570: LD_VAR 0 3
33574: PPUSH
33575: CALL_OW 311
33579: NOT
33580: PUSH
33581: LD_VAR 0 3
33585: PUSH
33586: LD_EXP 52
33590: PUSH
33591: LD_VAR 0 2
33595: ARRAY
33596: PUSH
33597: LD_INT 1
33599: ARRAY
33600: IN
33601: NOT
33602: AND
33603: PUSH
33604: LD_VAR 0 3
33608: PUSH
33609: LD_EXP 52
33613: PUSH
33614: LD_VAR 0 2
33618: ARRAY
33619: PUSH
33620: LD_INT 2
33622: ARRAY
33623: IN
33624: NOT
33625: AND
33626: IFFALSE 33678
// begin if IsInUnit ( j ) then
33628: LD_VAR 0 3
33632: PPUSH
33633: CALL_OW 310
33637: IFFALSE 33648
// ComExitBuilding ( j ) ;
33639: LD_VAR 0 3
33643: PPUSH
33644: CALL_OW 122
// if not HasTask ( j ) then
33648: LD_VAR 0 3
33652: PPUSH
33653: CALL_OW 314
33657: NOT
33658: IFFALSE 33678
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
33660: LD_VAR 0 3
33664: PPUSH
33665: LD_VAR 0 7
33669: PUSH
33670: LD_INT 1
33672: ARRAY
33673: PPUSH
33674: CALL_OW 189
// end ; end ;
33678: GO 33513
33680: POP
33681: POP
// end ;
33682: GO 32989
33684: POP
33685: POP
// end ;
33686: LD_VAR 0 1
33690: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
33691: LD_INT 0
33693: PPUSH
33694: PPUSH
33695: PPUSH
33696: PPUSH
33697: PPUSH
33698: PPUSH
33699: PPUSH
33700: PPUSH
33701: PPUSH
33702: PPUSH
33703: PPUSH
// if not mc_bases then
33704: LD_EXP 49
33708: NOT
33709: IFFALSE 33713
// exit ;
33711: GO 34515
// for i = 1 to mc_bases do
33713: LD_ADDR_VAR 0 2
33717: PUSH
33718: DOUBLE
33719: LD_INT 1
33721: DEC
33722: ST_TO_ADDR
33723: LD_EXP 49
33727: PUSH
33728: FOR_TO
33729: IFFALSE 34513
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
33731: LD_EXP 77
33735: PUSH
33736: LD_VAR 0 2
33740: ARRAY
33741: NOT
33742: PUSH
33743: LD_EXP 52
33747: PUSH
33748: LD_VAR 0 2
33752: ARRAY
33753: PUSH
33754: LD_INT 1
33756: ARRAY
33757: OR
33758: PUSH
33759: LD_EXP 52
33763: PUSH
33764: LD_VAR 0 2
33768: ARRAY
33769: PUSH
33770: LD_INT 2
33772: ARRAY
33773: OR
33774: PUSH
33775: LD_EXP 75
33779: PUSH
33780: LD_VAR 0 2
33784: ARRAY
33785: PPUSH
33786: LD_INT 1
33788: PPUSH
33789: CALL_OW 325
33793: NOT
33794: OR
33795: PUSH
33796: LD_EXP 72
33800: PUSH
33801: LD_VAR 0 2
33805: ARRAY
33806: OR
33807: IFFALSE 33811
// continue ;
33809: GO 33728
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
33811: LD_ADDR_VAR 0 8
33815: PUSH
33816: LD_EXP 49
33820: PUSH
33821: LD_VAR 0 2
33825: ARRAY
33826: PPUSH
33827: LD_INT 25
33829: PUSH
33830: LD_INT 4
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 50
33839: PUSH
33840: EMPTY
33841: LIST
33842: PUSH
33843: LD_INT 3
33845: PUSH
33846: LD_INT 60
33848: PUSH
33849: EMPTY
33850: LIST
33851: PUSH
33852: EMPTY
33853: LIST
33854: LIST
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: LIST
33860: PPUSH
33861: CALL_OW 72
33865: PUSH
33866: LD_EXP 53
33870: PUSH
33871: LD_VAR 0 2
33875: ARRAY
33876: DIFF
33877: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33878: LD_ADDR_VAR 0 9
33882: PUSH
33883: LD_EXP 49
33887: PUSH
33888: LD_VAR 0 2
33892: ARRAY
33893: PPUSH
33894: LD_INT 2
33896: PUSH
33897: LD_INT 30
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 30
33909: PUSH
33910: LD_INT 1
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: LIST
33921: PPUSH
33922: CALL_OW 72
33926: ST_TO_ADDR
// if not tmp or not dep then
33927: LD_VAR 0 8
33931: NOT
33932: PUSH
33933: LD_VAR 0 9
33937: NOT
33938: OR
33939: IFFALSE 33943
// continue ;
33941: GO 33728
// side := GetSide ( tmp [ 1 ] ) ;
33943: LD_ADDR_VAR 0 11
33947: PUSH
33948: LD_VAR 0 8
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PPUSH
33957: CALL_OW 255
33961: ST_TO_ADDR
// dep := dep [ 1 ] ;
33962: LD_ADDR_VAR 0 9
33966: PUSH
33967: LD_VAR 0 9
33971: PUSH
33972: LD_INT 1
33974: ARRAY
33975: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
33976: LD_ADDR_VAR 0 7
33980: PUSH
33981: LD_EXP 77
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PPUSH
33992: LD_INT 22
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 25
34004: PUSH
34005: LD_INT 12
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PPUSH
34016: CALL_OW 70
34020: PUSH
34021: LD_INT 22
34023: PUSH
34024: LD_INT 0
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 25
34033: PUSH
34034: LD_INT 12
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 91
34043: PUSH
34044: LD_VAR 0 9
34048: PUSH
34049: LD_INT 20
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: LIST
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: LIST
34061: PPUSH
34062: CALL_OW 69
34066: UNION
34067: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
34068: LD_ADDR_VAR 0 10
34072: PUSH
34073: LD_EXP 77
34077: PUSH
34078: LD_VAR 0 2
34082: ARRAY
34083: PPUSH
34084: LD_INT 81
34086: PUSH
34087: LD_VAR 0 11
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PPUSH
34096: CALL_OW 70
34100: ST_TO_ADDR
// if not apes or danger_at_area then
34101: LD_VAR 0 7
34105: NOT
34106: PUSH
34107: LD_VAR 0 10
34111: OR
34112: IFFALSE 34162
// begin if mc_taming [ i ] then
34114: LD_EXP 80
34118: PUSH
34119: LD_VAR 0 2
34123: ARRAY
34124: IFFALSE 34160
// begin MC_Reset ( i , 121 ) ;
34126: LD_VAR 0 2
34130: PPUSH
34131: LD_INT 121
34133: PPUSH
34134: CALL 19797 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
34138: LD_ADDR_EXP 80
34142: PUSH
34143: LD_EXP 80
34147: PPUSH
34148: LD_VAR 0 2
34152: PPUSH
34153: EMPTY
34154: PPUSH
34155: CALL_OW 1
34159: ST_TO_ADDR
// end ; continue ;
34160: GO 33728
// end ; for j in tmp do
34162: LD_ADDR_VAR 0 3
34166: PUSH
34167: LD_VAR 0 8
34171: PUSH
34172: FOR_IN
34173: IFFALSE 34509
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
34175: LD_VAR 0 3
34179: PUSH
34180: LD_EXP 80
34184: PUSH
34185: LD_VAR 0 2
34189: ARRAY
34190: IN
34191: NOT
34192: PUSH
34193: LD_EXP 80
34197: PUSH
34198: LD_VAR 0 2
34202: ARRAY
34203: PUSH
34204: LD_INT 3
34206: LESS
34207: AND
34208: IFFALSE 34266
// begin SetTag ( j , 121 ) ;
34210: LD_VAR 0 3
34214: PPUSH
34215: LD_INT 121
34217: PPUSH
34218: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
34222: LD_ADDR_EXP 80
34226: PUSH
34227: LD_EXP 80
34231: PPUSH
34232: LD_VAR 0 2
34236: PUSH
34237: LD_EXP 80
34241: PUSH
34242: LD_VAR 0 2
34246: ARRAY
34247: PUSH
34248: LD_INT 1
34250: PLUS
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PPUSH
34256: LD_VAR 0 3
34260: PPUSH
34261: CALL 51685 0 3
34265: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
34266: LD_VAR 0 3
34270: PUSH
34271: LD_EXP 80
34275: PUSH
34276: LD_VAR 0 2
34280: ARRAY
34281: IN
34282: IFFALSE 34507
// begin if GetClass ( j ) <> 4 then
34284: LD_VAR 0 3
34288: PPUSH
34289: CALL_OW 257
34293: PUSH
34294: LD_INT 4
34296: NONEQUAL
34297: IFFALSE 34350
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
34299: LD_ADDR_EXP 80
34303: PUSH
34304: LD_EXP 80
34308: PPUSH
34309: LD_VAR 0 2
34313: PPUSH
34314: LD_EXP 80
34318: PUSH
34319: LD_VAR 0 2
34323: ARRAY
34324: PUSH
34325: LD_VAR 0 3
34329: DIFF
34330: PPUSH
34331: CALL_OW 1
34335: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34336: LD_VAR 0 3
34340: PPUSH
34341: LD_INT 0
34343: PPUSH
34344: CALL_OW 109
// continue ;
34348: GO 34172
// end ; if IsInUnit ( j ) then
34350: LD_VAR 0 3
34354: PPUSH
34355: CALL_OW 310
34359: IFFALSE 34370
// ComExitBuilding ( j ) ;
34361: LD_VAR 0 3
34365: PPUSH
34366: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
34370: LD_ADDR_VAR 0 6
34374: PUSH
34375: LD_VAR 0 7
34379: PPUSH
34380: LD_VAR 0 3
34384: PPUSH
34385: CALL_OW 74
34389: ST_TO_ADDR
// if not ape then
34390: LD_VAR 0 6
34394: NOT
34395: IFFALSE 34399
// break ;
34397: GO 34509
// x := GetX ( ape ) ;
34399: LD_ADDR_VAR 0 4
34403: PUSH
34404: LD_VAR 0 6
34408: PPUSH
34409: CALL_OW 250
34413: ST_TO_ADDR
// y := GetY ( ape ) ;
34414: LD_ADDR_VAR 0 5
34418: PUSH
34419: LD_VAR 0 6
34423: PPUSH
34424: CALL_OW 251
34428: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
34429: LD_VAR 0 4
34433: PPUSH
34434: LD_VAR 0 5
34438: PPUSH
34439: CALL_OW 488
34443: NOT
34444: PUSH
34445: LD_VAR 0 11
34449: PPUSH
34450: LD_VAR 0 4
34454: PPUSH
34455: LD_VAR 0 5
34459: PPUSH
34460: LD_INT 20
34462: PPUSH
34463: CALL 52581 0 4
34467: PUSH
34468: LD_INT 4
34470: ARRAY
34471: OR
34472: IFFALSE 34476
// break ;
34474: GO 34509
// if not HasTask ( j ) then
34476: LD_VAR 0 3
34480: PPUSH
34481: CALL_OW 314
34485: NOT
34486: IFFALSE 34507
// ComTameXY ( j , x , y ) ;
34488: LD_VAR 0 3
34492: PPUSH
34493: LD_VAR 0 4
34497: PPUSH
34498: LD_VAR 0 5
34502: PPUSH
34503: CALL_OW 131
// end ; end ;
34507: GO 34172
34509: POP
34510: POP
// end ;
34511: GO 33728
34513: POP
34514: POP
// end ;
34515: LD_VAR 0 1
34519: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
34520: LD_INT 0
34522: PPUSH
34523: PPUSH
34524: PPUSH
34525: PPUSH
34526: PPUSH
34527: PPUSH
34528: PPUSH
34529: PPUSH
// if not mc_bases then
34530: LD_EXP 49
34534: NOT
34535: IFFALSE 34539
// exit ;
34537: GO 35165
// for i = 1 to mc_bases do
34539: LD_ADDR_VAR 0 2
34543: PUSH
34544: DOUBLE
34545: LD_INT 1
34547: DEC
34548: ST_TO_ADDR
34549: LD_EXP 49
34553: PUSH
34554: FOR_TO
34555: IFFALSE 35163
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
34557: LD_EXP 78
34561: PUSH
34562: LD_VAR 0 2
34566: ARRAY
34567: NOT
34568: PUSH
34569: LD_EXP 78
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PPUSH
34580: LD_INT 25
34582: PUSH
34583: LD_INT 12
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PPUSH
34590: CALL_OW 72
34594: NOT
34595: OR
34596: IFFALSE 34600
// continue ;
34598: GO 34554
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
34600: LD_ADDR_VAR 0 5
34604: PUSH
34605: LD_EXP 78
34609: PUSH
34610: LD_VAR 0 2
34614: ARRAY
34615: PUSH
34616: LD_INT 1
34618: ARRAY
34619: PPUSH
34620: CALL_OW 255
34624: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
34625: LD_VAR 0 5
34629: PPUSH
34630: LD_INT 2
34632: PPUSH
34633: CALL_OW 325
34637: IFFALSE 34890
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
34639: LD_ADDR_VAR 0 4
34643: PUSH
34644: LD_EXP 78
34648: PUSH
34649: LD_VAR 0 2
34653: ARRAY
34654: PPUSH
34655: LD_INT 25
34657: PUSH
34658: LD_INT 16
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PPUSH
34665: CALL_OW 72
34669: ST_TO_ADDR
// if tmp < 6 then
34670: LD_VAR 0 4
34674: PUSH
34675: LD_INT 6
34677: LESS
34678: IFFALSE 34890
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34680: LD_ADDR_VAR 0 6
34684: PUSH
34685: LD_EXP 49
34689: PUSH
34690: LD_VAR 0 2
34694: ARRAY
34695: PPUSH
34696: LD_INT 2
34698: PUSH
34699: LD_INT 30
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 30
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: LIST
34723: PPUSH
34724: CALL_OW 72
34728: ST_TO_ADDR
// if depot then
34729: LD_VAR 0 6
34733: IFFALSE 34890
// begin selected := 0 ;
34735: LD_ADDR_VAR 0 7
34739: PUSH
34740: LD_INT 0
34742: ST_TO_ADDR
// for j in depot do
34743: LD_ADDR_VAR 0 3
34747: PUSH
34748: LD_VAR 0 6
34752: PUSH
34753: FOR_IN
34754: IFFALSE 34785
// begin if UnitsInside ( j ) < 6 then
34756: LD_VAR 0 3
34760: PPUSH
34761: CALL_OW 313
34765: PUSH
34766: LD_INT 6
34768: LESS
34769: IFFALSE 34783
// begin selected := j ;
34771: LD_ADDR_VAR 0 7
34775: PUSH
34776: LD_VAR 0 3
34780: ST_TO_ADDR
// break ;
34781: GO 34785
// end ; end ;
34783: GO 34753
34785: POP
34786: POP
// if selected then
34787: LD_VAR 0 7
34791: IFFALSE 34890
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
34793: LD_ADDR_VAR 0 3
34797: PUSH
34798: LD_EXP 78
34802: PUSH
34803: LD_VAR 0 2
34807: ARRAY
34808: PPUSH
34809: LD_INT 25
34811: PUSH
34812: LD_INT 12
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PPUSH
34819: CALL_OW 72
34823: PUSH
34824: FOR_IN
34825: IFFALSE 34888
// if not HasTask ( j ) then
34827: LD_VAR 0 3
34831: PPUSH
34832: CALL_OW 314
34836: NOT
34837: IFFALSE 34886
// begin if not IsInUnit ( j ) then
34839: LD_VAR 0 3
34843: PPUSH
34844: CALL_OW 310
34848: NOT
34849: IFFALSE 34865
// ComEnterUnit ( j , selected ) ;
34851: LD_VAR 0 3
34855: PPUSH
34856: LD_VAR 0 7
34860: PPUSH
34861: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
34865: LD_VAR 0 3
34869: PPUSH
34870: LD_INT 16
34872: PPUSH
34873: CALL_OW 183
// AddComExitBuilding ( j ) ;
34877: LD_VAR 0 3
34881: PPUSH
34882: CALL_OW 182
// end ;
34886: GO 34824
34888: POP
34889: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
34890: LD_VAR 0 5
34894: PPUSH
34895: LD_INT 11
34897: PPUSH
34898: CALL_OW 325
34902: IFFALSE 35161
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
34904: LD_ADDR_VAR 0 4
34908: PUSH
34909: LD_EXP 78
34913: PUSH
34914: LD_VAR 0 2
34918: ARRAY
34919: PPUSH
34920: LD_INT 25
34922: PUSH
34923: LD_INT 16
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PPUSH
34930: CALL_OW 72
34934: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
34935: LD_VAR 0 4
34939: PUSH
34940: LD_INT 6
34942: GREATEREQUAL
34943: PUSH
34944: LD_VAR 0 5
34948: PPUSH
34949: LD_INT 2
34951: PPUSH
34952: CALL_OW 325
34956: NOT
34957: OR
34958: IFFALSE 35161
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
34960: LD_ADDR_VAR 0 8
34964: PUSH
34965: LD_EXP 49
34969: PUSH
34970: LD_VAR 0 2
34974: ARRAY
34975: PPUSH
34976: LD_INT 2
34978: PUSH
34979: LD_INT 30
34981: PUSH
34982: LD_INT 4
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 30
34991: PUSH
34992: LD_INT 5
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: LIST
35003: PPUSH
35004: CALL_OW 72
35008: ST_TO_ADDR
// if barracks then
35009: LD_VAR 0 8
35013: IFFALSE 35161
// begin selected := 0 ;
35015: LD_ADDR_VAR 0 7
35019: PUSH
35020: LD_INT 0
35022: ST_TO_ADDR
// for j in barracks do
35023: LD_ADDR_VAR 0 3
35027: PUSH
35028: LD_VAR 0 8
35032: PUSH
35033: FOR_IN
35034: IFFALSE 35065
// begin if UnitsInside ( j ) < 6 then
35036: LD_VAR 0 3
35040: PPUSH
35041: CALL_OW 313
35045: PUSH
35046: LD_INT 6
35048: LESS
35049: IFFALSE 35063
// begin selected := j ;
35051: LD_ADDR_VAR 0 7
35055: PUSH
35056: LD_VAR 0 3
35060: ST_TO_ADDR
// break ;
35061: GO 35065
// end ; end ;
35063: GO 35033
35065: POP
35066: POP
// if selected then
35067: LD_VAR 0 7
35071: IFFALSE 35161
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
35073: LD_ADDR_VAR 0 3
35077: PUSH
35078: LD_EXP 78
35082: PUSH
35083: LD_VAR 0 2
35087: ARRAY
35088: PPUSH
35089: LD_INT 25
35091: PUSH
35092: LD_INT 12
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PPUSH
35099: CALL_OW 72
35103: PUSH
35104: FOR_IN
35105: IFFALSE 35159
// if not IsInUnit ( j ) and not HasTask ( j ) then
35107: LD_VAR 0 3
35111: PPUSH
35112: CALL_OW 310
35116: NOT
35117: PUSH
35118: LD_VAR 0 3
35122: PPUSH
35123: CALL_OW 314
35127: NOT
35128: AND
35129: IFFALSE 35157
// begin ComEnterUnit ( j , selected ) ;
35131: LD_VAR 0 3
35135: PPUSH
35136: LD_VAR 0 7
35140: PPUSH
35141: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
35145: LD_VAR 0 3
35149: PPUSH
35150: LD_INT 15
35152: PPUSH
35153: CALL_OW 183
// end ;
35157: GO 35104
35159: POP
35160: POP
// end ; end ; end ; end ; end ;
35161: GO 34554
35163: POP
35164: POP
// end ;
35165: LD_VAR 0 1
35169: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
35170: LD_INT 0
35172: PPUSH
35173: PPUSH
35174: PPUSH
35175: PPUSH
// if not mc_bases then
35176: LD_EXP 49
35180: NOT
35181: IFFALSE 35185
// exit ;
35183: GO 35363
// for i = 1 to mc_bases do
35185: LD_ADDR_VAR 0 2
35189: PUSH
35190: DOUBLE
35191: LD_INT 1
35193: DEC
35194: ST_TO_ADDR
35195: LD_EXP 49
35199: PUSH
35200: FOR_TO
35201: IFFALSE 35361
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
35203: LD_ADDR_VAR 0 4
35207: PUSH
35208: LD_EXP 49
35212: PUSH
35213: LD_VAR 0 2
35217: ARRAY
35218: PPUSH
35219: LD_INT 25
35221: PUSH
35222: LD_INT 9
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PPUSH
35229: CALL_OW 72
35233: ST_TO_ADDR
// if not tmp then
35234: LD_VAR 0 4
35238: NOT
35239: IFFALSE 35243
// continue ;
35241: GO 35200
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
35243: LD_EXP 75
35247: PUSH
35248: LD_VAR 0 2
35252: ARRAY
35253: PPUSH
35254: LD_INT 29
35256: PPUSH
35257: CALL_OW 325
35261: NOT
35262: PUSH
35263: LD_EXP 75
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PPUSH
35274: LD_INT 28
35276: PPUSH
35277: CALL_OW 325
35281: NOT
35282: AND
35283: IFFALSE 35287
// continue ;
35285: GO 35200
// for j in tmp do
35287: LD_ADDR_VAR 0 3
35291: PUSH
35292: LD_VAR 0 4
35296: PUSH
35297: FOR_IN
35298: IFFALSE 35357
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35300: LD_VAR 0 3
35304: PUSH
35305: LD_EXP 52
35309: PUSH
35310: LD_VAR 0 2
35314: ARRAY
35315: PUSH
35316: LD_INT 1
35318: ARRAY
35319: IN
35320: NOT
35321: PUSH
35322: LD_VAR 0 3
35326: PUSH
35327: LD_EXP 52
35331: PUSH
35332: LD_VAR 0 2
35336: ARRAY
35337: PUSH
35338: LD_INT 2
35340: ARRAY
35341: IN
35342: NOT
35343: AND
35344: IFFALSE 35355
// ComSpaceTimeShoot ( j ) ;
35346: LD_VAR 0 3
35350: PPUSH
35351: CALL 45745 0 1
35355: GO 35297
35357: POP
35358: POP
// end ;
35359: GO 35200
35361: POP
35362: POP
// end ;
35363: LD_VAR 0 1
35367: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
35368: LD_INT 0
35370: PPUSH
35371: PPUSH
35372: PPUSH
35373: PPUSH
35374: PPUSH
35375: PPUSH
35376: PPUSH
35377: PPUSH
35378: PPUSH
// if not mc_bases then
35379: LD_EXP 49
35383: NOT
35384: IFFALSE 35388
// exit ;
35386: GO 36010
// for i = 1 to mc_bases do
35388: LD_ADDR_VAR 0 2
35392: PUSH
35393: DOUBLE
35394: LD_INT 1
35396: DEC
35397: ST_TO_ADDR
35398: LD_EXP 49
35402: PUSH
35403: FOR_TO
35404: IFFALSE 36008
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
35406: LD_EXP 84
35410: PUSH
35411: LD_VAR 0 2
35415: ARRAY
35416: NOT
35417: PUSH
35418: LD_INT 38
35420: PPUSH
35421: LD_EXP 75
35425: PUSH
35426: LD_VAR 0 2
35430: ARRAY
35431: PPUSH
35432: CALL_OW 321
35436: PUSH
35437: LD_INT 2
35439: NONEQUAL
35440: OR
35441: IFFALSE 35445
// continue ;
35443: GO 35403
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
35445: LD_ADDR_VAR 0 8
35449: PUSH
35450: LD_EXP 49
35454: PUSH
35455: LD_VAR 0 2
35459: ARRAY
35460: PPUSH
35461: LD_INT 30
35463: PUSH
35464: LD_INT 34
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PPUSH
35471: CALL_OW 72
35475: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
35476: LD_ADDR_VAR 0 9
35480: PUSH
35481: LD_EXP 49
35485: PUSH
35486: LD_VAR 0 2
35490: ARRAY
35491: PPUSH
35492: LD_INT 25
35494: PUSH
35495: LD_INT 4
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PPUSH
35502: CALL_OW 72
35506: PPUSH
35507: LD_INT 0
35509: PPUSH
35510: CALL 84882 0 2
35514: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
35515: LD_VAR 0 9
35519: NOT
35520: PUSH
35521: LD_VAR 0 8
35525: NOT
35526: OR
35527: PUSH
35528: LD_EXP 49
35532: PUSH
35533: LD_VAR 0 2
35537: ARRAY
35538: PPUSH
35539: LD_INT 124
35541: PPUSH
35542: CALL 84882 0 2
35546: OR
35547: IFFALSE 35551
// continue ;
35549: GO 35403
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
35551: LD_EXP 85
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: PUSH
35562: LD_EXP 84
35566: PUSH
35567: LD_VAR 0 2
35571: ARRAY
35572: LESS
35573: PUSH
35574: LD_EXP 85
35578: PUSH
35579: LD_VAR 0 2
35583: ARRAY
35584: PUSH
35585: LD_VAR 0 8
35589: LESS
35590: AND
35591: IFFALSE 36006
// begin tmp := sci [ 1 ] ;
35593: LD_ADDR_VAR 0 7
35597: PUSH
35598: LD_VAR 0 9
35602: PUSH
35603: LD_INT 1
35605: ARRAY
35606: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
35607: LD_VAR 0 7
35611: PPUSH
35612: LD_INT 124
35614: PPUSH
35615: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
35619: LD_ADDR_VAR 0 3
35623: PUSH
35624: DOUBLE
35625: LD_EXP 84
35629: PUSH
35630: LD_VAR 0 2
35634: ARRAY
35635: INC
35636: ST_TO_ADDR
35637: LD_EXP 84
35641: PUSH
35642: LD_VAR 0 2
35646: ARRAY
35647: PUSH
35648: FOR_DOWNTO
35649: IFFALSE 35992
// begin if IsInUnit ( tmp ) then
35651: LD_VAR 0 7
35655: PPUSH
35656: CALL_OW 310
35660: IFFALSE 35671
// ComExitBuilding ( tmp ) ;
35662: LD_VAR 0 7
35666: PPUSH
35667: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
35671: LD_INT 35
35673: PPUSH
35674: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
35678: LD_VAR 0 7
35682: PPUSH
35683: CALL_OW 310
35687: NOT
35688: PUSH
35689: LD_VAR 0 7
35693: PPUSH
35694: CALL_OW 314
35698: NOT
35699: AND
35700: IFFALSE 35671
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
35702: LD_ADDR_VAR 0 6
35706: PUSH
35707: LD_VAR 0 7
35711: PPUSH
35712: CALL_OW 250
35716: PUSH
35717: LD_VAR 0 7
35721: PPUSH
35722: CALL_OW 251
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
35731: LD_INT 35
35733: PPUSH
35734: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
35738: LD_ADDR_VAR 0 4
35742: PUSH
35743: LD_EXP 84
35747: PUSH
35748: LD_VAR 0 2
35752: ARRAY
35753: PUSH
35754: LD_VAR 0 3
35758: ARRAY
35759: PUSH
35760: LD_INT 1
35762: ARRAY
35763: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
35764: LD_ADDR_VAR 0 5
35768: PUSH
35769: LD_EXP 84
35773: PUSH
35774: LD_VAR 0 2
35778: ARRAY
35779: PUSH
35780: LD_VAR 0 3
35784: ARRAY
35785: PUSH
35786: LD_INT 2
35788: ARRAY
35789: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
35790: LD_VAR 0 7
35794: PPUSH
35795: LD_INT 10
35797: PPUSH
35798: CALL 54278 0 2
35802: PUSH
35803: LD_INT 4
35805: ARRAY
35806: IFFALSE 35844
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
35808: LD_VAR 0 7
35812: PPUSH
35813: LD_VAR 0 6
35817: PUSH
35818: LD_INT 1
35820: ARRAY
35821: PPUSH
35822: LD_VAR 0 6
35826: PUSH
35827: LD_INT 2
35829: ARRAY
35830: PPUSH
35831: CALL_OW 111
// wait ( 0 0$10 ) ;
35835: LD_INT 350
35837: PPUSH
35838: CALL_OW 67
// end else
35842: GO 35870
// begin ComMoveXY ( tmp , x , y ) ;
35844: LD_VAR 0 7
35848: PPUSH
35849: LD_VAR 0 4
35853: PPUSH
35854: LD_VAR 0 5
35858: PPUSH
35859: CALL_OW 111
// wait ( 0 0$3 ) ;
35863: LD_INT 105
35865: PPUSH
35866: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
35870: LD_VAR 0 7
35874: PPUSH
35875: LD_VAR 0 4
35879: PPUSH
35880: LD_VAR 0 5
35884: PPUSH
35885: CALL_OW 307
35889: IFFALSE 35731
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
35891: LD_VAR 0 7
35895: PPUSH
35896: LD_VAR 0 4
35900: PPUSH
35901: LD_VAR 0 5
35905: PPUSH
35906: LD_VAR 0 8
35910: PUSH
35911: LD_VAR 0 3
35915: ARRAY
35916: PPUSH
35917: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
35921: LD_INT 35
35923: PPUSH
35924: CALL_OW 67
// until not HasTask ( tmp ) ;
35928: LD_VAR 0 7
35932: PPUSH
35933: CALL_OW 314
35937: NOT
35938: IFFALSE 35921
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
35940: LD_ADDR_EXP 85
35944: PUSH
35945: LD_EXP 85
35949: PPUSH
35950: LD_VAR 0 2
35954: PUSH
35955: LD_EXP 85
35959: PUSH
35960: LD_VAR 0 2
35964: ARRAY
35965: PUSH
35966: LD_INT 1
35968: PLUS
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PPUSH
35974: LD_VAR 0 8
35978: PUSH
35979: LD_VAR 0 3
35983: ARRAY
35984: PPUSH
35985: CALL 51685 0 3
35989: ST_TO_ADDR
// end ;
35990: GO 35648
35992: POP
35993: POP
// MC_Reset ( i , 124 ) ;
35994: LD_VAR 0 2
35998: PPUSH
35999: LD_INT 124
36001: PPUSH
36002: CALL 19797 0 2
// end ; end ;
36006: GO 35403
36008: POP
36009: POP
// end ;
36010: LD_VAR 0 1
36014: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
36015: LD_INT 0
36017: PPUSH
36018: PPUSH
36019: PPUSH
// if not mc_bases then
36020: LD_EXP 49
36024: NOT
36025: IFFALSE 36029
// exit ;
36027: GO 36635
// for i = 1 to mc_bases do
36029: LD_ADDR_VAR 0 2
36033: PUSH
36034: DOUBLE
36035: LD_INT 1
36037: DEC
36038: ST_TO_ADDR
36039: LD_EXP 49
36043: PUSH
36044: FOR_TO
36045: IFFALSE 36633
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
36047: LD_ADDR_VAR 0 3
36051: PUSH
36052: LD_EXP 49
36056: PUSH
36057: LD_VAR 0 2
36061: ARRAY
36062: PPUSH
36063: LD_INT 25
36065: PUSH
36066: LD_INT 4
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PPUSH
36073: CALL_OW 72
36077: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
36078: LD_VAR 0 3
36082: NOT
36083: PUSH
36084: LD_EXP 86
36088: PUSH
36089: LD_VAR 0 2
36093: ARRAY
36094: NOT
36095: OR
36096: PUSH
36097: LD_EXP 49
36101: PUSH
36102: LD_VAR 0 2
36106: ARRAY
36107: PPUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 30
36113: PUSH
36114: LD_INT 0
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 30
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: LIST
36135: PPUSH
36136: CALL_OW 72
36140: NOT
36141: OR
36142: IFFALSE 36192
// begin if mc_deposits_finder [ i ] then
36144: LD_EXP 87
36148: PUSH
36149: LD_VAR 0 2
36153: ARRAY
36154: IFFALSE 36190
// begin MC_Reset ( i , 125 ) ;
36156: LD_VAR 0 2
36160: PPUSH
36161: LD_INT 125
36163: PPUSH
36164: CALL 19797 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36168: LD_ADDR_EXP 87
36172: PUSH
36173: LD_EXP 87
36177: PPUSH
36178: LD_VAR 0 2
36182: PPUSH
36183: EMPTY
36184: PPUSH
36185: CALL_OW 1
36189: ST_TO_ADDR
// end ; continue ;
36190: GO 36044
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
36192: LD_EXP 86
36196: PUSH
36197: LD_VAR 0 2
36201: ARRAY
36202: PUSH
36203: LD_INT 1
36205: ARRAY
36206: PUSH
36207: LD_INT 3
36209: ARRAY
36210: PUSH
36211: LD_INT 1
36213: EQUAL
36214: PUSH
36215: LD_INT 20
36217: PPUSH
36218: LD_EXP 75
36222: PUSH
36223: LD_VAR 0 2
36227: ARRAY
36228: PPUSH
36229: CALL_OW 321
36233: PUSH
36234: LD_INT 2
36236: NONEQUAL
36237: AND
36238: IFFALSE 36288
// begin if mc_deposits_finder [ i ] then
36240: LD_EXP 87
36244: PUSH
36245: LD_VAR 0 2
36249: ARRAY
36250: IFFALSE 36286
// begin MC_Reset ( i , 125 ) ;
36252: LD_VAR 0 2
36256: PPUSH
36257: LD_INT 125
36259: PPUSH
36260: CALL 19797 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36264: LD_ADDR_EXP 87
36268: PUSH
36269: LD_EXP 87
36273: PPUSH
36274: LD_VAR 0 2
36278: PPUSH
36279: EMPTY
36280: PPUSH
36281: CALL_OW 1
36285: ST_TO_ADDR
// end ; continue ;
36286: GO 36044
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
36288: LD_EXP 86
36292: PUSH
36293: LD_VAR 0 2
36297: ARRAY
36298: PUSH
36299: LD_INT 1
36301: ARRAY
36302: PUSH
36303: LD_INT 1
36305: ARRAY
36306: PPUSH
36307: LD_EXP 86
36311: PUSH
36312: LD_VAR 0 2
36316: ARRAY
36317: PUSH
36318: LD_INT 1
36320: ARRAY
36321: PUSH
36322: LD_INT 2
36324: ARRAY
36325: PPUSH
36326: LD_EXP 75
36330: PUSH
36331: LD_VAR 0 2
36335: ARRAY
36336: PPUSH
36337: CALL_OW 440
36341: IFFALSE 36384
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
36343: LD_ADDR_EXP 86
36347: PUSH
36348: LD_EXP 86
36352: PPUSH
36353: LD_VAR 0 2
36357: PPUSH
36358: LD_EXP 86
36362: PUSH
36363: LD_VAR 0 2
36367: ARRAY
36368: PPUSH
36369: LD_INT 1
36371: PPUSH
36372: CALL_OW 3
36376: PPUSH
36377: CALL_OW 1
36381: ST_TO_ADDR
36382: GO 36631
// begin if not mc_deposits_finder [ i ] then
36384: LD_EXP 87
36388: PUSH
36389: LD_VAR 0 2
36393: ARRAY
36394: NOT
36395: IFFALSE 36447
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
36397: LD_ADDR_EXP 87
36401: PUSH
36402: LD_EXP 87
36406: PPUSH
36407: LD_VAR 0 2
36411: PPUSH
36412: LD_VAR 0 3
36416: PUSH
36417: LD_INT 1
36419: ARRAY
36420: PUSH
36421: EMPTY
36422: LIST
36423: PPUSH
36424: CALL_OW 1
36428: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
36429: LD_VAR 0 3
36433: PUSH
36434: LD_INT 1
36436: ARRAY
36437: PPUSH
36438: LD_INT 125
36440: PPUSH
36441: CALL_OW 109
// end else
36445: GO 36631
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
36447: LD_EXP 87
36451: PUSH
36452: LD_VAR 0 2
36456: ARRAY
36457: PUSH
36458: LD_INT 1
36460: ARRAY
36461: PPUSH
36462: CALL_OW 310
36466: IFFALSE 36489
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
36468: LD_EXP 87
36472: PUSH
36473: LD_VAR 0 2
36477: ARRAY
36478: PUSH
36479: LD_INT 1
36481: ARRAY
36482: PPUSH
36483: CALL_OW 122
36487: GO 36631
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
36489: LD_EXP 87
36493: PUSH
36494: LD_VAR 0 2
36498: ARRAY
36499: PUSH
36500: LD_INT 1
36502: ARRAY
36503: PPUSH
36504: CALL_OW 314
36508: NOT
36509: PUSH
36510: LD_EXP 87
36514: PUSH
36515: LD_VAR 0 2
36519: ARRAY
36520: PUSH
36521: LD_INT 1
36523: ARRAY
36524: PPUSH
36525: LD_EXP 86
36529: PUSH
36530: LD_VAR 0 2
36534: ARRAY
36535: PUSH
36536: LD_INT 1
36538: ARRAY
36539: PUSH
36540: LD_INT 1
36542: ARRAY
36543: PPUSH
36544: LD_EXP 86
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: PUSH
36555: LD_INT 1
36557: ARRAY
36558: PUSH
36559: LD_INT 2
36561: ARRAY
36562: PPUSH
36563: CALL_OW 297
36567: PUSH
36568: LD_INT 6
36570: GREATER
36571: AND
36572: IFFALSE 36631
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
36574: LD_EXP 87
36578: PUSH
36579: LD_VAR 0 2
36583: ARRAY
36584: PUSH
36585: LD_INT 1
36587: ARRAY
36588: PPUSH
36589: LD_EXP 86
36593: PUSH
36594: LD_VAR 0 2
36598: ARRAY
36599: PUSH
36600: LD_INT 1
36602: ARRAY
36603: PUSH
36604: LD_INT 1
36606: ARRAY
36607: PPUSH
36608: LD_EXP 86
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: PUSH
36619: LD_INT 1
36621: ARRAY
36622: PUSH
36623: LD_INT 2
36625: ARRAY
36626: PPUSH
36627: CALL_OW 111
// end ; end ; end ;
36631: GO 36044
36633: POP
36634: POP
// end ;
36635: LD_VAR 0 1
36639: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
36640: LD_INT 0
36642: PPUSH
36643: PPUSH
36644: PPUSH
36645: PPUSH
36646: PPUSH
36647: PPUSH
36648: PPUSH
36649: PPUSH
36650: PPUSH
36651: PPUSH
36652: PPUSH
// if not mc_bases then
36653: LD_EXP 49
36657: NOT
36658: IFFALSE 36662
// exit ;
36660: GO 37386
// for i = 1 to mc_bases do
36662: LD_ADDR_VAR 0 2
36666: PUSH
36667: DOUBLE
36668: LD_INT 1
36670: DEC
36671: ST_TO_ADDR
36672: LD_EXP 49
36676: PUSH
36677: FOR_TO
36678: IFFALSE 37384
// begin if not mc_bases [ i ] then
36680: LD_EXP 49
36684: PUSH
36685: LD_VAR 0 2
36689: ARRAY
36690: NOT
36691: IFFALSE 36695
// continue ;
36693: GO 36677
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
36695: LD_ADDR_VAR 0 7
36699: PUSH
36700: LD_EXP 49
36704: PUSH
36705: LD_VAR 0 2
36709: ARRAY
36710: PUSH
36711: LD_INT 1
36713: ARRAY
36714: PPUSH
36715: CALL_OW 248
36719: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
36720: LD_VAR 0 7
36724: PUSH
36725: LD_INT 3
36727: EQUAL
36728: PUSH
36729: LD_EXP 68
36733: PUSH
36734: LD_VAR 0 2
36738: ARRAY
36739: PUSH
36740: LD_EXP 71
36744: PUSH
36745: LD_VAR 0 2
36749: ARRAY
36750: UNION
36751: PPUSH
36752: LD_INT 33
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PPUSH
36762: CALL_OW 72
36766: NOT
36767: OR
36768: IFFALSE 36772
// continue ;
36770: GO 36677
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
36772: LD_ADDR_VAR 0 9
36776: PUSH
36777: LD_EXP 49
36781: PUSH
36782: LD_VAR 0 2
36786: ARRAY
36787: PPUSH
36788: LD_INT 30
36790: PUSH
36791: LD_INT 36
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PPUSH
36798: CALL_OW 72
36802: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
36803: LD_ADDR_VAR 0 10
36807: PUSH
36808: LD_EXP 68
36812: PUSH
36813: LD_VAR 0 2
36817: ARRAY
36818: PPUSH
36819: LD_INT 34
36821: PUSH
36822: LD_INT 31
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PPUSH
36829: CALL_OW 72
36833: ST_TO_ADDR
// if not cts and not mcts then
36834: LD_VAR 0 9
36838: NOT
36839: PUSH
36840: LD_VAR 0 10
36844: NOT
36845: AND
36846: IFFALSE 36850
// continue ;
36848: GO 36677
// x := cts ;
36850: LD_ADDR_VAR 0 11
36854: PUSH
36855: LD_VAR 0 9
36859: ST_TO_ADDR
// if not x then
36860: LD_VAR 0 11
36864: NOT
36865: IFFALSE 36877
// x := mcts ;
36867: LD_ADDR_VAR 0 11
36871: PUSH
36872: LD_VAR 0 10
36876: ST_TO_ADDR
// if mc_remote_driver [ i ] then
36877: LD_EXP 89
36881: PUSH
36882: LD_VAR 0 2
36886: ARRAY
36887: IFFALSE 37156
// for j in mc_remote_driver [ i ] do
36889: LD_ADDR_VAR 0 3
36893: PUSH
36894: LD_EXP 89
36898: PUSH
36899: LD_VAR 0 2
36903: ARRAY
36904: PUSH
36905: FOR_IN
36906: IFFALSE 37154
// begin if GetClass ( j ) <> 3 then
36908: LD_VAR 0 3
36912: PPUSH
36913: CALL_OW 257
36917: PUSH
36918: LD_INT 3
36920: NONEQUAL
36921: IFFALSE 36974
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
36923: LD_ADDR_EXP 89
36927: PUSH
36928: LD_EXP 89
36932: PPUSH
36933: LD_VAR 0 2
36937: PPUSH
36938: LD_EXP 89
36942: PUSH
36943: LD_VAR 0 2
36947: ARRAY
36948: PUSH
36949: LD_VAR 0 3
36953: DIFF
36954: PPUSH
36955: CALL_OW 1
36959: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36960: LD_VAR 0 3
36964: PPUSH
36965: LD_INT 0
36967: PPUSH
36968: CALL_OW 109
// continue ;
36972: GO 36905
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
36974: LD_VAR 0 3
36978: PPUSH
36979: CALL_OW 310
36983: NOT
36984: PUSH
36985: LD_VAR 0 3
36989: PPUSH
36990: CALL_OW 310
36994: PPUSH
36995: CALL_OW 266
36999: PUSH
37000: LD_INT 36
37002: NONEQUAL
37003: PUSH
37004: LD_VAR 0 3
37008: PPUSH
37009: CALL 84970 0 1
37013: NOT
37014: AND
37015: OR
37016: IFFALSE 37152
// begin if IsInUnit ( j ) then
37018: LD_VAR 0 3
37022: PPUSH
37023: CALL_OW 310
37027: IFFALSE 37038
// ComExitBuilding ( j ) ;
37029: LD_VAR 0 3
37033: PPUSH
37034: CALL_OW 122
// ct := 0 ;
37038: LD_ADDR_VAR 0 8
37042: PUSH
37043: LD_INT 0
37045: ST_TO_ADDR
// for k in x do
37046: LD_ADDR_VAR 0 4
37050: PUSH
37051: LD_VAR 0 11
37055: PUSH
37056: FOR_IN
37057: IFFALSE 37130
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
37059: LD_VAR 0 4
37063: PPUSH
37064: CALL_OW 264
37068: PUSH
37069: LD_INT 31
37071: EQUAL
37072: PUSH
37073: LD_VAR 0 4
37077: PPUSH
37078: CALL_OW 311
37082: NOT
37083: AND
37084: PUSH
37085: LD_VAR 0 4
37089: PPUSH
37090: CALL_OW 266
37094: PUSH
37095: LD_INT 36
37097: EQUAL
37098: PUSH
37099: LD_VAR 0 4
37103: PPUSH
37104: CALL_OW 313
37108: PUSH
37109: LD_INT 3
37111: LESS
37112: AND
37113: OR
37114: IFFALSE 37128
// begin ct := k ;
37116: LD_ADDR_VAR 0 8
37120: PUSH
37121: LD_VAR 0 4
37125: ST_TO_ADDR
// break ;
37126: GO 37130
// end ;
37128: GO 37056
37130: POP
37131: POP
// if ct then
37132: LD_VAR 0 8
37136: IFFALSE 37152
// ComEnterUnit ( j , ct ) ;
37138: LD_VAR 0 3
37142: PPUSH
37143: LD_VAR 0 8
37147: PPUSH
37148: CALL_OW 120
// end ; end ;
37152: GO 36905
37154: POP
37155: POP
// places := 0 ;
37156: LD_ADDR_VAR 0 5
37160: PUSH
37161: LD_INT 0
37163: ST_TO_ADDR
// for j = 1 to x do
37164: LD_ADDR_VAR 0 3
37168: PUSH
37169: DOUBLE
37170: LD_INT 1
37172: DEC
37173: ST_TO_ADDR
37174: LD_VAR 0 11
37178: PUSH
37179: FOR_TO
37180: IFFALSE 37235
// if GetWeapon ( x [ j ] ) = ar_control_tower then
37182: LD_VAR 0 11
37186: PUSH
37187: LD_VAR 0 3
37191: ARRAY
37192: PPUSH
37193: CALL_OW 264
37197: PUSH
37198: LD_INT 31
37200: EQUAL
37201: IFFALSE 37219
// places := places + 1 else
37203: LD_ADDR_VAR 0 5
37207: PUSH
37208: LD_VAR 0 5
37212: PUSH
37213: LD_INT 1
37215: PLUS
37216: ST_TO_ADDR
37217: GO 37233
// places := places + 3 ;
37219: LD_ADDR_VAR 0 5
37223: PUSH
37224: LD_VAR 0 5
37228: PUSH
37229: LD_INT 3
37231: PLUS
37232: ST_TO_ADDR
37233: GO 37179
37235: POP
37236: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
37237: LD_ADDR_VAR 0 6
37241: PUSH
37242: LD_EXP 49
37246: PUSH
37247: LD_VAR 0 2
37251: ARRAY
37252: PPUSH
37253: LD_INT 25
37255: PUSH
37256: LD_INT 3
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: PPUSH
37263: CALL_OW 72
37267: PUSH
37268: LD_EXP 89
37272: PUSH
37273: LD_VAR 0 2
37277: ARRAY
37278: DIFF
37279: PPUSH
37280: LD_INT 3
37282: PPUSH
37283: CALL 85870 0 2
37287: ST_TO_ADDR
// if not tmp then
37288: LD_VAR 0 6
37292: NOT
37293: IFFALSE 37297
// continue ;
37295: GO 36677
// places := places - mc_remote_driver [ i ] ;
37297: LD_ADDR_VAR 0 5
37301: PUSH
37302: LD_VAR 0 5
37306: PUSH
37307: LD_EXP 89
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: MINUS
37318: ST_TO_ADDR
// if places then
37319: LD_VAR 0 5
37323: IFFALSE 37382
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
37325: LD_ADDR_EXP 89
37329: PUSH
37330: LD_EXP 89
37334: PPUSH
37335: LD_VAR 0 2
37339: PPUSH
37340: LD_EXP 89
37344: PUSH
37345: LD_VAR 0 2
37349: ARRAY
37350: PUSH
37351: LD_VAR 0 6
37355: PUSH
37356: LD_INT 1
37358: ARRAY
37359: UNION
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
37366: LD_VAR 0 6
37370: PUSH
37371: LD_INT 1
37373: ARRAY
37374: PPUSH
37375: LD_INT 126
37377: PPUSH
37378: CALL_OW 109
// end ; end ;
37382: GO 36677
37384: POP
37385: POP
// end ;
37386: LD_VAR 0 1
37390: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
37391: LD_INT 0
37393: PPUSH
37394: PPUSH
37395: PPUSH
37396: PPUSH
37397: PPUSH
37398: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
37399: LD_VAR 0 1
37403: NOT
37404: PUSH
37405: LD_VAR 0 2
37409: NOT
37410: OR
37411: PUSH
37412: LD_VAR 0 3
37416: NOT
37417: OR
37418: PUSH
37419: LD_VAR 0 4
37423: PUSH
37424: LD_INT 1
37426: PUSH
37427: LD_INT 2
37429: PUSH
37430: LD_INT 3
37432: PUSH
37433: LD_INT 4
37435: PUSH
37436: LD_INT 5
37438: PUSH
37439: LD_INT 8
37441: PUSH
37442: LD_INT 9
37444: PUSH
37445: LD_INT 15
37447: PUSH
37448: LD_INT 16
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: LIST
37457: LIST
37458: LIST
37459: LIST
37460: LIST
37461: IN
37462: NOT
37463: OR
37464: IFFALSE 37468
// exit ;
37466: GO 38368
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
37468: LD_ADDR_VAR 0 2
37472: PUSH
37473: LD_VAR 0 2
37477: PPUSH
37478: LD_INT 21
37480: PUSH
37481: LD_INT 3
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 24
37490: PUSH
37491: LD_INT 250
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PPUSH
37502: CALL_OW 72
37506: ST_TO_ADDR
// case class of 1 , 15 :
37507: LD_VAR 0 4
37511: PUSH
37512: LD_INT 1
37514: DOUBLE
37515: EQUAL
37516: IFTRUE 37526
37518: LD_INT 15
37520: DOUBLE
37521: EQUAL
37522: IFTRUE 37526
37524: GO 37611
37526: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
37527: LD_ADDR_VAR 0 8
37531: PUSH
37532: LD_VAR 0 2
37536: PPUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 30
37542: PUSH
37543: LD_INT 32
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 30
37552: PUSH
37553: LD_INT 31
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: LIST
37564: PPUSH
37565: CALL_OW 72
37569: PUSH
37570: LD_VAR 0 2
37574: PPUSH
37575: LD_INT 2
37577: PUSH
37578: LD_INT 30
37580: PUSH
37581: LD_INT 4
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 30
37590: PUSH
37591: LD_INT 5
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: LIST
37602: PPUSH
37603: CALL_OW 72
37607: ADD
37608: ST_TO_ADDR
37609: GO 37857
37611: LD_INT 2
37613: DOUBLE
37614: EQUAL
37615: IFTRUE 37625
37617: LD_INT 16
37619: DOUBLE
37620: EQUAL
37621: IFTRUE 37625
37623: GO 37671
37625: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
37626: LD_ADDR_VAR 0 8
37630: PUSH
37631: LD_VAR 0 2
37635: PPUSH
37636: LD_INT 2
37638: PUSH
37639: LD_INT 30
37641: PUSH
37642: LD_INT 0
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: LD_INT 30
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: LIST
37663: PPUSH
37664: CALL_OW 72
37668: ST_TO_ADDR
37669: GO 37857
37671: LD_INT 3
37673: DOUBLE
37674: EQUAL
37675: IFTRUE 37679
37677: GO 37725
37679: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
37680: LD_ADDR_VAR 0 8
37684: PUSH
37685: LD_VAR 0 2
37689: PPUSH
37690: LD_INT 2
37692: PUSH
37693: LD_INT 30
37695: PUSH
37696: LD_INT 2
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 30
37705: PUSH
37706: LD_INT 3
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: LIST
37717: PPUSH
37718: CALL_OW 72
37722: ST_TO_ADDR
37723: GO 37857
37725: LD_INT 4
37727: DOUBLE
37728: EQUAL
37729: IFTRUE 37733
37731: GO 37790
37733: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
37734: LD_ADDR_VAR 0 8
37738: PUSH
37739: LD_VAR 0 2
37743: PPUSH
37744: LD_INT 2
37746: PUSH
37747: LD_INT 30
37749: PUSH
37750: LD_INT 6
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 30
37759: PUSH
37760: LD_INT 7
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 30
37769: PUSH
37770: LD_INT 8
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: LIST
37781: LIST
37782: PPUSH
37783: CALL_OW 72
37787: ST_TO_ADDR
37788: GO 37857
37790: LD_INT 5
37792: DOUBLE
37793: EQUAL
37794: IFTRUE 37810
37796: LD_INT 8
37798: DOUBLE
37799: EQUAL
37800: IFTRUE 37810
37802: LD_INT 9
37804: DOUBLE
37805: EQUAL
37806: IFTRUE 37810
37808: GO 37856
37810: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
37811: LD_ADDR_VAR 0 8
37815: PUSH
37816: LD_VAR 0 2
37820: PPUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 30
37826: PUSH
37827: LD_INT 4
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 30
37836: PUSH
37837: LD_INT 5
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: LIST
37848: PPUSH
37849: CALL_OW 72
37853: ST_TO_ADDR
37854: GO 37857
37856: POP
// if not tmp then
37857: LD_VAR 0 8
37861: NOT
37862: IFFALSE 37866
// exit ;
37864: GO 38368
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
37866: LD_VAR 0 4
37870: PUSH
37871: LD_INT 1
37873: PUSH
37874: LD_INT 15
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: IN
37881: PUSH
37882: LD_EXP 58
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: AND
37893: IFFALSE 38049
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
37895: LD_ADDR_VAR 0 9
37899: PUSH
37900: LD_EXP 58
37904: PUSH
37905: LD_VAR 0 1
37909: ARRAY
37910: PUSH
37911: LD_INT 1
37913: ARRAY
37914: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
37915: LD_VAR 0 9
37919: PUSH
37920: LD_EXP 59
37924: PUSH
37925: LD_VAR 0 1
37929: ARRAY
37930: IN
37931: NOT
37932: IFFALSE 38047
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
37934: LD_ADDR_EXP 59
37938: PUSH
37939: LD_EXP 59
37943: PPUSH
37944: LD_VAR 0 1
37948: PUSH
37949: LD_EXP 59
37953: PUSH
37954: LD_VAR 0 1
37958: ARRAY
37959: PUSH
37960: LD_INT 1
37962: PLUS
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PPUSH
37968: LD_VAR 0 9
37972: PPUSH
37973: CALL 51685 0 3
37977: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
37978: LD_ADDR_EXP 58
37982: PUSH
37983: LD_EXP 58
37987: PPUSH
37988: LD_VAR 0 1
37992: PPUSH
37993: LD_EXP 58
37997: PUSH
37998: LD_VAR 0 1
38002: ARRAY
38003: PUSH
38004: LD_VAR 0 9
38008: DIFF
38009: PPUSH
38010: CALL_OW 1
38014: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
38015: LD_VAR 0 3
38019: PPUSH
38020: LD_EXP 59
38024: PUSH
38025: LD_VAR 0 1
38029: ARRAY
38030: PUSH
38031: LD_EXP 59
38035: PUSH
38036: LD_VAR 0 1
38040: ARRAY
38041: ARRAY
38042: PPUSH
38043: CALL_OW 120
// end ; exit ;
38047: GO 38368
// end ; if tmp > 1 then
38049: LD_VAR 0 8
38053: PUSH
38054: LD_INT 1
38056: GREATER
38057: IFFALSE 38161
// for i = 2 to tmp do
38059: LD_ADDR_VAR 0 6
38063: PUSH
38064: DOUBLE
38065: LD_INT 2
38067: DEC
38068: ST_TO_ADDR
38069: LD_VAR 0 8
38073: PUSH
38074: FOR_TO
38075: IFFALSE 38159
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
38077: LD_VAR 0 8
38081: PUSH
38082: LD_VAR 0 6
38086: ARRAY
38087: PPUSH
38088: CALL_OW 461
38092: PUSH
38093: LD_INT 6
38095: EQUAL
38096: IFFALSE 38157
// begin x := tmp [ i ] ;
38098: LD_ADDR_VAR 0 9
38102: PUSH
38103: LD_VAR 0 8
38107: PUSH
38108: LD_VAR 0 6
38112: ARRAY
38113: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
38114: LD_ADDR_VAR 0 8
38118: PUSH
38119: LD_VAR 0 8
38123: PPUSH
38124: LD_VAR 0 6
38128: PPUSH
38129: CALL_OW 3
38133: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
38134: LD_ADDR_VAR 0 8
38138: PUSH
38139: LD_VAR 0 8
38143: PPUSH
38144: LD_INT 1
38146: PPUSH
38147: LD_VAR 0 9
38151: PPUSH
38152: CALL_OW 2
38156: ST_TO_ADDR
// end ;
38157: GO 38074
38159: POP
38160: POP
// for i in tmp do
38161: LD_ADDR_VAR 0 6
38165: PUSH
38166: LD_VAR 0 8
38170: PUSH
38171: FOR_IN
38172: IFFALSE 38241
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
38174: LD_VAR 0 6
38178: PPUSH
38179: CALL_OW 313
38183: PUSH
38184: LD_INT 6
38186: LESS
38187: PUSH
38188: LD_VAR 0 6
38192: PPUSH
38193: CALL_OW 266
38197: PUSH
38198: LD_INT 31
38200: PUSH
38201: LD_INT 32
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: IN
38208: NOT
38209: AND
38210: PUSH
38211: LD_VAR 0 6
38215: PPUSH
38216: CALL_OW 313
38220: PUSH
38221: LD_INT 0
38223: EQUAL
38224: OR
38225: IFFALSE 38239
// begin j := i ;
38227: LD_ADDR_VAR 0 7
38231: PUSH
38232: LD_VAR 0 6
38236: ST_TO_ADDR
// break ;
38237: GO 38241
// end ; end ;
38239: GO 38171
38241: POP
38242: POP
// if j then
38243: LD_VAR 0 7
38247: IFFALSE 38265
// ComEnterUnit ( unit , j ) else
38249: LD_VAR 0 3
38253: PPUSH
38254: LD_VAR 0 7
38258: PPUSH
38259: CALL_OW 120
38263: GO 38368
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38265: LD_ADDR_VAR 0 10
38269: PUSH
38270: LD_VAR 0 2
38274: PPUSH
38275: LD_INT 2
38277: PUSH
38278: LD_INT 30
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 30
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: LIST
38302: PPUSH
38303: CALL_OW 72
38307: ST_TO_ADDR
// if depot then
38308: LD_VAR 0 10
38312: IFFALSE 38368
// begin depot := NearestUnitToUnit ( depot , unit ) ;
38314: LD_ADDR_VAR 0 10
38318: PUSH
38319: LD_VAR 0 10
38323: PPUSH
38324: LD_VAR 0 3
38328: PPUSH
38329: CALL_OW 74
38333: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
38334: LD_VAR 0 3
38338: PPUSH
38339: LD_VAR 0 10
38343: PPUSH
38344: CALL_OW 296
38348: PUSH
38349: LD_INT 10
38351: GREATER
38352: IFFALSE 38368
// ComStandNearbyBuilding ( unit , depot ) ;
38354: LD_VAR 0 3
38358: PPUSH
38359: LD_VAR 0 10
38363: PPUSH
38364: CALL 46362 0 2
// end ; end ; end ;
38368: LD_VAR 0 5
38372: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
38373: LD_INT 0
38375: PPUSH
38376: PPUSH
38377: PPUSH
38378: PPUSH
// if not mc_bases then
38379: LD_EXP 49
38383: NOT
38384: IFFALSE 38388
// exit ;
38386: GO 38627
// for i = 1 to mc_bases do
38388: LD_ADDR_VAR 0 2
38392: PUSH
38393: DOUBLE
38394: LD_INT 1
38396: DEC
38397: ST_TO_ADDR
38398: LD_EXP 49
38402: PUSH
38403: FOR_TO
38404: IFFALSE 38625
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 49
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: PPUSH
38422: LD_INT 21
38424: PUSH
38425: LD_INT 1
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PPUSH
38432: CALL_OW 72
38436: PUSH
38437: LD_EXP 78
38441: PUSH
38442: LD_VAR 0 2
38446: ARRAY
38447: UNION
38448: ST_TO_ADDR
// if not tmp then
38449: LD_VAR 0 4
38453: NOT
38454: IFFALSE 38458
// continue ;
38456: GO 38403
// for j in tmp do
38458: LD_ADDR_VAR 0 3
38462: PUSH
38463: LD_VAR 0 4
38467: PUSH
38468: FOR_IN
38469: IFFALSE 38621
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
38471: LD_VAR 0 3
38475: PPUSH
38476: CALL_OW 110
38480: NOT
38481: PUSH
38482: LD_VAR 0 3
38486: PPUSH
38487: CALL_OW 314
38491: NOT
38492: AND
38493: PUSH
38494: LD_VAR 0 3
38498: PPUSH
38499: CALL_OW 311
38503: NOT
38504: AND
38505: PUSH
38506: LD_VAR 0 3
38510: PPUSH
38511: CALL_OW 310
38515: NOT
38516: AND
38517: PUSH
38518: LD_VAR 0 3
38522: PUSH
38523: LD_EXP 52
38527: PUSH
38528: LD_VAR 0 2
38532: ARRAY
38533: PUSH
38534: LD_INT 1
38536: ARRAY
38537: IN
38538: NOT
38539: AND
38540: PUSH
38541: LD_VAR 0 3
38545: PUSH
38546: LD_EXP 52
38550: PUSH
38551: LD_VAR 0 2
38555: ARRAY
38556: PUSH
38557: LD_INT 2
38559: ARRAY
38560: IN
38561: NOT
38562: AND
38563: PUSH
38564: LD_VAR 0 3
38568: PUSH
38569: LD_EXP 61
38573: PUSH
38574: LD_VAR 0 2
38578: ARRAY
38579: IN
38580: NOT
38581: AND
38582: IFFALSE 38619
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
38584: LD_VAR 0 2
38588: PPUSH
38589: LD_EXP 49
38593: PUSH
38594: LD_VAR 0 2
38598: ARRAY
38599: PPUSH
38600: LD_VAR 0 3
38604: PPUSH
38605: LD_VAR 0 3
38609: PPUSH
38610: CALL_OW 257
38614: PPUSH
38615: CALL 37391 0 4
// end ;
38619: GO 38468
38621: POP
38622: POP
// end ;
38623: GO 38403
38625: POP
38626: POP
// end ;
38627: LD_VAR 0 1
38631: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
38632: LD_INT 0
38634: PPUSH
38635: PPUSH
38636: PPUSH
38637: PPUSH
38638: PPUSH
38639: PPUSH
// if not mc_bases [ base ] then
38640: LD_EXP 49
38644: PUSH
38645: LD_VAR 0 1
38649: ARRAY
38650: NOT
38651: IFFALSE 38655
// exit ;
38653: GO 38837
// tmp := [ ] ;
38655: LD_ADDR_VAR 0 6
38659: PUSH
38660: EMPTY
38661: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
38662: LD_ADDR_VAR 0 7
38666: PUSH
38667: LD_VAR 0 3
38671: PPUSH
38672: LD_INT 0
38674: PPUSH
38675: CALL_OW 517
38679: ST_TO_ADDR
// if not list then
38680: LD_VAR 0 7
38684: NOT
38685: IFFALSE 38689
// exit ;
38687: GO 38837
// for i = 1 to amount do
38689: LD_ADDR_VAR 0 5
38693: PUSH
38694: DOUBLE
38695: LD_INT 1
38697: DEC
38698: ST_TO_ADDR
38699: LD_VAR 0 2
38703: PUSH
38704: FOR_TO
38705: IFFALSE 38785
// begin x := rand ( 1 , list [ 1 ] ) ;
38707: LD_ADDR_VAR 0 8
38711: PUSH
38712: LD_INT 1
38714: PPUSH
38715: LD_VAR 0 7
38719: PUSH
38720: LD_INT 1
38722: ARRAY
38723: PPUSH
38724: CALL_OW 12
38728: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
38729: LD_ADDR_VAR 0 6
38733: PUSH
38734: LD_VAR 0 6
38738: PPUSH
38739: LD_VAR 0 5
38743: PPUSH
38744: LD_VAR 0 7
38748: PUSH
38749: LD_INT 1
38751: ARRAY
38752: PUSH
38753: LD_VAR 0 8
38757: ARRAY
38758: PUSH
38759: LD_VAR 0 7
38763: PUSH
38764: LD_INT 2
38766: ARRAY
38767: PUSH
38768: LD_VAR 0 8
38772: ARRAY
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PPUSH
38778: CALL_OW 1
38782: ST_TO_ADDR
// end ;
38783: GO 38704
38785: POP
38786: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
38787: LD_ADDR_EXP 62
38791: PUSH
38792: LD_EXP 62
38796: PPUSH
38797: LD_VAR 0 1
38801: PPUSH
38802: LD_VAR 0 6
38806: PPUSH
38807: CALL_OW 1
38811: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
38812: LD_ADDR_EXP 64
38816: PUSH
38817: LD_EXP 64
38821: PPUSH
38822: LD_VAR 0 1
38826: PPUSH
38827: LD_VAR 0 3
38831: PPUSH
38832: CALL_OW 1
38836: ST_TO_ADDR
// end ;
38837: LD_VAR 0 4
38841: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
38842: LD_INT 0
38844: PPUSH
// if not mc_bases [ base ] then
38845: LD_EXP 49
38849: PUSH
38850: LD_VAR 0 1
38854: ARRAY
38855: NOT
38856: IFFALSE 38860
// exit ;
38858: GO 38885
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
38860: LD_ADDR_EXP 54
38864: PUSH
38865: LD_EXP 54
38869: PPUSH
38870: LD_VAR 0 1
38874: PPUSH
38875: LD_VAR 0 2
38879: PPUSH
38880: CALL_OW 1
38884: ST_TO_ADDR
// end ;
38885: LD_VAR 0 3
38889: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
38890: LD_INT 0
38892: PPUSH
// if not mc_bases [ base ] then
38893: LD_EXP 49
38897: PUSH
38898: LD_VAR 0 1
38902: ARRAY
38903: NOT
38904: IFFALSE 38908
// exit ;
38906: GO 38945
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
38908: LD_ADDR_EXP 54
38912: PUSH
38913: LD_EXP 54
38917: PPUSH
38918: LD_VAR 0 1
38922: PPUSH
38923: LD_EXP 54
38927: PUSH
38928: LD_VAR 0 1
38932: ARRAY
38933: PUSH
38934: LD_VAR 0 2
38938: UNION
38939: PPUSH
38940: CALL_OW 1
38944: ST_TO_ADDR
// end ;
38945: LD_VAR 0 3
38949: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
38950: LD_INT 0
38952: PPUSH
// if not mc_bases [ base ] then
38953: LD_EXP 49
38957: PUSH
38958: LD_VAR 0 1
38962: ARRAY
38963: NOT
38964: IFFALSE 38968
// exit ;
38966: GO 38993
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
38968: LD_ADDR_EXP 70
38972: PUSH
38973: LD_EXP 70
38977: PPUSH
38978: LD_VAR 0 1
38982: PPUSH
38983: LD_VAR 0 2
38987: PPUSH
38988: CALL_OW 1
38992: ST_TO_ADDR
// end ;
38993: LD_VAR 0 3
38997: RET
// export function MC_InsertProduceList ( base , components ) ; begin
38998: LD_INT 0
39000: PPUSH
// if not mc_bases [ base ] then
39001: LD_EXP 49
39005: PUSH
39006: LD_VAR 0 1
39010: ARRAY
39011: NOT
39012: IFFALSE 39016
// exit ;
39014: GO 39053
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
39016: LD_ADDR_EXP 70
39020: PUSH
39021: LD_EXP 70
39025: PPUSH
39026: LD_VAR 0 1
39030: PPUSH
39031: LD_EXP 70
39035: PUSH
39036: LD_VAR 0 1
39040: ARRAY
39041: PUSH
39042: LD_VAR 0 2
39046: ADD
39047: PPUSH
39048: CALL_OW 1
39052: ST_TO_ADDR
// end ;
39053: LD_VAR 0 3
39057: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
39058: LD_INT 0
39060: PPUSH
// if not mc_bases [ base ] then
39061: LD_EXP 49
39065: PUSH
39066: LD_VAR 0 1
39070: ARRAY
39071: NOT
39072: IFFALSE 39076
// exit ;
39074: GO 39130
// mc_defender := Replace ( mc_defender , base , deflist ) ;
39076: LD_ADDR_EXP 71
39080: PUSH
39081: LD_EXP 71
39085: PPUSH
39086: LD_VAR 0 1
39090: PPUSH
39091: LD_VAR 0 2
39095: PPUSH
39096: CALL_OW 1
39100: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
39101: LD_ADDR_EXP 60
39105: PUSH
39106: LD_EXP 60
39110: PPUSH
39111: LD_VAR 0 1
39115: PPUSH
39116: LD_VAR 0 2
39120: PUSH
39121: LD_INT 0
39123: PLUS
39124: PPUSH
39125: CALL_OW 1
39129: ST_TO_ADDR
// end ;
39130: LD_VAR 0 3
39134: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
39135: LD_INT 0
39137: PPUSH
// if not mc_bases [ base ] then
39138: LD_EXP 49
39142: PUSH
39143: LD_VAR 0 1
39147: ARRAY
39148: NOT
39149: IFFALSE 39153
// exit ;
39151: GO 39178
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
39153: LD_ADDR_EXP 60
39157: PUSH
39158: LD_EXP 60
39162: PPUSH
39163: LD_VAR 0 1
39167: PPUSH
39168: LD_VAR 0 2
39172: PPUSH
39173: CALL_OW 1
39177: ST_TO_ADDR
// end ;
39178: LD_VAR 0 3
39182: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
39183: LD_INT 0
39185: PPUSH
39186: PPUSH
39187: PPUSH
39188: PPUSH
// if not mc_bases [ base ] then
39189: LD_EXP 49
39193: PUSH
39194: LD_VAR 0 1
39198: ARRAY
39199: NOT
39200: IFFALSE 39204
// exit ;
39202: GO 39269
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
39204: LD_ADDR_EXP 69
39208: PUSH
39209: LD_EXP 69
39213: PPUSH
39214: LD_VAR 0 1
39218: PUSH
39219: LD_EXP 69
39223: PUSH
39224: LD_VAR 0 1
39228: ARRAY
39229: PUSH
39230: LD_INT 1
39232: PLUS
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: PPUSH
39238: LD_VAR 0 1
39242: PUSH
39243: LD_VAR 0 2
39247: PUSH
39248: LD_VAR 0 3
39252: PUSH
39253: LD_VAR 0 4
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: PPUSH
39264: CALL 51685 0 3
39268: ST_TO_ADDR
// end ;
39269: LD_VAR 0 5
39273: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
39274: LD_INT 0
39276: PPUSH
// if not mc_bases [ base ] then
39277: LD_EXP 49
39281: PUSH
39282: LD_VAR 0 1
39286: ARRAY
39287: NOT
39288: IFFALSE 39292
// exit ;
39290: GO 39317
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
39292: LD_ADDR_EXP 86
39296: PUSH
39297: LD_EXP 86
39301: PPUSH
39302: LD_VAR 0 1
39306: PPUSH
39307: LD_VAR 0 2
39311: PPUSH
39312: CALL_OW 1
39316: ST_TO_ADDR
// end ;
39317: LD_VAR 0 3
39321: RET
// export function MC_GetMinesField ( base ) ; begin
39322: LD_INT 0
39324: PPUSH
// result := mc_mines [ base ] ;
39325: LD_ADDR_VAR 0 2
39329: PUSH
39330: LD_EXP 62
39334: PUSH
39335: LD_VAR 0 1
39339: ARRAY
39340: ST_TO_ADDR
// end ;
39341: LD_VAR 0 2
39345: RET
// export function MC_GetProduceList ( base ) ; begin
39346: LD_INT 0
39348: PPUSH
// result := mc_produce [ base ] ;
39349: LD_ADDR_VAR 0 2
39353: PUSH
39354: LD_EXP 70
39358: PUSH
39359: LD_VAR 0 1
39363: ARRAY
39364: ST_TO_ADDR
// end ;
39365: LD_VAR 0 2
39369: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
39370: LD_INT 0
39372: PPUSH
39373: PPUSH
// if not mc_bases then
39374: LD_EXP 49
39378: NOT
39379: IFFALSE 39383
// exit ;
39381: GO 39448
// if mc_bases [ base ] then
39383: LD_EXP 49
39387: PUSH
39388: LD_VAR 0 1
39392: ARRAY
39393: IFFALSE 39448
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
39395: LD_ADDR_VAR 0 3
39399: PUSH
39400: LD_EXP 49
39404: PUSH
39405: LD_VAR 0 1
39409: ARRAY
39410: PPUSH
39411: LD_INT 30
39413: PUSH
39414: LD_VAR 0 2
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PPUSH
39423: CALL_OW 72
39427: ST_TO_ADDR
// if result then
39428: LD_VAR 0 3
39432: IFFALSE 39448
// result := result [ 1 ] ;
39434: LD_ADDR_VAR 0 3
39438: PUSH
39439: LD_VAR 0 3
39443: PUSH
39444: LD_INT 1
39446: ARRAY
39447: ST_TO_ADDR
// end ; end ;
39448: LD_VAR 0 3
39452: RET
// export function MC_SetTame ( base , area ) ; begin
39453: LD_INT 0
39455: PPUSH
// if not mc_bases or not base then
39456: LD_EXP 49
39460: NOT
39461: PUSH
39462: LD_VAR 0 1
39466: NOT
39467: OR
39468: IFFALSE 39472
// exit ;
39470: GO 39497
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
39472: LD_ADDR_EXP 77
39476: PUSH
39477: LD_EXP 77
39481: PPUSH
39482: LD_VAR 0 1
39486: PPUSH
39487: LD_VAR 0 2
39491: PPUSH
39492: CALL_OW 1
39496: ST_TO_ADDR
// end ;
39497: LD_VAR 0 3
39501: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
39502: LD_INT 0
39504: PPUSH
39505: PPUSH
// if not mc_bases or not base then
39506: LD_EXP 49
39510: NOT
39511: PUSH
39512: LD_VAR 0 1
39516: NOT
39517: OR
39518: IFFALSE 39522
// exit ;
39520: GO 39624
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
39522: LD_ADDR_VAR 0 4
39526: PUSH
39527: LD_EXP 49
39531: PUSH
39532: LD_VAR 0 1
39536: ARRAY
39537: PPUSH
39538: LD_INT 30
39540: PUSH
39541: LD_VAR 0 2
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PPUSH
39550: CALL_OW 72
39554: ST_TO_ADDR
// if not tmp then
39555: LD_VAR 0 4
39559: NOT
39560: IFFALSE 39564
// exit ;
39562: GO 39624
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
39564: LD_ADDR_EXP 81
39568: PUSH
39569: LD_EXP 81
39573: PPUSH
39574: LD_VAR 0 1
39578: PPUSH
39579: LD_EXP 81
39583: PUSH
39584: LD_VAR 0 1
39588: ARRAY
39589: PPUSH
39590: LD_EXP 81
39594: PUSH
39595: LD_VAR 0 1
39599: ARRAY
39600: PUSH
39601: LD_INT 1
39603: PLUS
39604: PPUSH
39605: LD_VAR 0 4
39609: PUSH
39610: LD_INT 1
39612: ARRAY
39613: PPUSH
39614: CALL_OW 2
39618: PPUSH
39619: CALL_OW 1
39623: ST_TO_ADDR
// end ;
39624: LD_VAR 0 3
39628: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
39629: LD_INT 0
39631: PPUSH
39632: PPUSH
// if not mc_bases or not base or not kinds then
39633: LD_EXP 49
39637: NOT
39638: PUSH
39639: LD_VAR 0 1
39643: NOT
39644: OR
39645: PUSH
39646: LD_VAR 0 2
39650: NOT
39651: OR
39652: IFFALSE 39656
// exit ;
39654: GO 39717
// for i in kinds do
39656: LD_ADDR_VAR 0 4
39660: PUSH
39661: LD_VAR 0 2
39665: PUSH
39666: FOR_IN
39667: IFFALSE 39715
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
39669: LD_ADDR_EXP 83
39673: PUSH
39674: LD_EXP 83
39678: PPUSH
39679: LD_VAR 0 1
39683: PUSH
39684: LD_EXP 83
39688: PUSH
39689: LD_VAR 0 1
39693: ARRAY
39694: PUSH
39695: LD_INT 1
39697: PLUS
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PPUSH
39703: LD_VAR 0 4
39707: PPUSH
39708: CALL 51685 0 3
39712: ST_TO_ADDR
39713: GO 39666
39715: POP
39716: POP
// end ;
39717: LD_VAR 0 3
39721: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
39722: LD_INT 0
39724: PPUSH
// if not mc_bases or not base or not areas then
39725: LD_EXP 49
39729: NOT
39730: PUSH
39731: LD_VAR 0 1
39735: NOT
39736: OR
39737: PUSH
39738: LD_VAR 0 2
39742: NOT
39743: OR
39744: IFFALSE 39748
// exit ;
39746: GO 39773
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
39748: LD_ADDR_EXP 67
39752: PUSH
39753: LD_EXP 67
39757: PPUSH
39758: LD_VAR 0 1
39762: PPUSH
39763: LD_VAR 0 2
39767: PPUSH
39768: CALL_OW 1
39772: ST_TO_ADDR
// end ;
39773: LD_VAR 0 3
39777: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
39778: LD_INT 0
39780: PPUSH
// if not mc_bases or not base or not teleports_exit then
39781: LD_EXP 49
39785: NOT
39786: PUSH
39787: LD_VAR 0 1
39791: NOT
39792: OR
39793: PUSH
39794: LD_VAR 0 2
39798: NOT
39799: OR
39800: IFFALSE 39804
// exit ;
39802: GO 39829
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
39804: LD_ADDR_EXP 84
39808: PUSH
39809: LD_EXP 84
39813: PPUSH
39814: LD_VAR 0 1
39818: PPUSH
39819: LD_VAR 0 2
39823: PPUSH
39824: CALL_OW 1
39828: ST_TO_ADDR
// end ;
39829: LD_VAR 0 3
39833: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
39834: LD_INT 0
39836: PPUSH
39837: PPUSH
39838: PPUSH
// if not mc_bases or not base or not ext_list then
39839: LD_EXP 49
39843: NOT
39844: PUSH
39845: LD_VAR 0 1
39849: NOT
39850: OR
39851: PUSH
39852: LD_VAR 0 5
39856: NOT
39857: OR
39858: IFFALSE 39862
// exit ;
39860: GO 40035
// tmp := GetFacExtXYD ( x , y , d ) ;
39862: LD_ADDR_VAR 0 8
39866: PUSH
39867: LD_VAR 0 2
39871: PPUSH
39872: LD_VAR 0 3
39876: PPUSH
39877: LD_VAR 0 4
39881: PPUSH
39882: CALL 85000 0 3
39886: ST_TO_ADDR
// if not tmp then
39887: LD_VAR 0 8
39891: NOT
39892: IFFALSE 39896
// exit ;
39894: GO 40035
// for i in tmp do
39896: LD_ADDR_VAR 0 7
39900: PUSH
39901: LD_VAR 0 8
39905: PUSH
39906: FOR_IN
39907: IFFALSE 40033
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
39909: LD_ADDR_EXP 54
39913: PUSH
39914: LD_EXP 54
39918: PPUSH
39919: LD_VAR 0 1
39923: PPUSH
39924: LD_EXP 54
39928: PUSH
39929: LD_VAR 0 1
39933: ARRAY
39934: PPUSH
39935: LD_EXP 54
39939: PUSH
39940: LD_VAR 0 1
39944: ARRAY
39945: PUSH
39946: LD_INT 1
39948: PLUS
39949: PPUSH
39950: LD_VAR 0 5
39954: PUSH
39955: LD_INT 1
39957: ARRAY
39958: PUSH
39959: LD_VAR 0 7
39963: PUSH
39964: LD_INT 1
39966: ARRAY
39967: PUSH
39968: LD_VAR 0 7
39972: PUSH
39973: LD_INT 2
39975: ARRAY
39976: PUSH
39977: LD_VAR 0 7
39981: PUSH
39982: LD_INT 3
39984: ARRAY
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: PPUSH
39992: CALL_OW 2
39996: PPUSH
39997: CALL_OW 1
40001: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
40002: LD_ADDR_VAR 0 5
40006: PUSH
40007: LD_VAR 0 5
40011: PPUSH
40012: LD_INT 1
40014: PPUSH
40015: CALL_OW 3
40019: ST_TO_ADDR
// if not ext_list then
40020: LD_VAR 0 5
40024: NOT
40025: IFFALSE 40031
// exit ;
40027: POP
40028: POP
40029: GO 40035
// end ;
40031: GO 39906
40033: POP
40034: POP
// end ;
40035: LD_VAR 0 6
40039: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
40040: LD_INT 0
40042: PPUSH
// if not mc_bases or not base or not weapon_list then
40043: LD_EXP 49
40047: NOT
40048: PUSH
40049: LD_VAR 0 1
40053: NOT
40054: OR
40055: PUSH
40056: LD_VAR 0 2
40060: NOT
40061: OR
40062: IFFALSE 40066
// exit ;
40064: GO 40091
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
40066: LD_ADDR_EXP 88
40070: PUSH
40071: LD_EXP 88
40075: PPUSH
40076: LD_VAR 0 1
40080: PPUSH
40081: LD_VAR 0 2
40085: PPUSH
40086: CALL_OW 1
40090: ST_TO_ADDR
// end ;
40091: LD_VAR 0 3
40095: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
40096: LD_INT 0
40098: PPUSH
// if not mc_bases or not base or not tech_list then
40099: LD_EXP 49
40103: NOT
40104: PUSH
40105: LD_VAR 0 1
40109: NOT
40110: OR
40111: PUSH
40112: LD_VAR 0 2
40116: NOT
40117: OR
40118: IFFALSE 40122
// exit ;
40120: GO 40147
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
40122: LD_ADDR_EXP 76
40126: PUSH
40127: LD_EXP 76
40131: PPUSH
40132: LD_VAR 0 1
40136: PPUSH
40137: LD_VAR 0 2
40141: PPUSH
40142: CALL_OW 1
40146: ST_TO_ADDR
// end ;
40147: LD_VAR 0 3
40151: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
40152: LD_INT 0
40154: PPUSH
// if not mc_bases or not parking_area or not base then
40155: LD_EXP 49
40159: NOT
40160: PUSH
40161: LD_VAR 0 2
40165: NOT
40166: OR
40167: PUSH
40168: LD_VAR 0 1
40172: NOT
40173: OR
40174: IFFALSE 40178
// exit ;
40176: GO 40203
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
40178: LD_ADDR_EXP 73
40182: PUSH
40183: LD_EXP 73
40187: PPUSH
40188: LD_VAR 0 1
40192: PPUSH
40193: LD_VAR 0 2
40197: PPUSH
40198: CALL_OW 1
40202: ST_TO_ADDR
// end ;
40203: LD_VAR 0 3
40207: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
40208: LD_INT 0
40210: PPUSH
// if not mc_bases or not base or not scan_area then
40211: LD_EXP 49
40215: NOT
40216: PUSH
40217: LD_VAR 0 1
40221: NOT
40222: OR
40223: PUSH
40224: LD_VAR 0 2
40228: NOT
40229: OR
40230: IFFALSE 40234
// exit ;
40232: GO 40259
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
40234: LD_ADDR_EXP 74
40238: PUSH
40239: LD_EXP 74
40243: PPUSH
40244: LD_VAR 0 1
40248: PPUSH
40249: LD_VAR 0 2
40253: PPUSH
40254: CALL_OW 1
40258: ST_TO_ADDR
// end ;
40259: LD_VAR 0 3
40263: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
40264: LD_INT 0
40266: PPUSH
40267: PPUSH
// if not mc_bases or not base then
40268: LD_EXP 49
40272: NOT
40273: PUSH
40274: LD_VAR 0 1
40278: NOT
40279: OR
40280: IFFALSE 40284
// exit ;
40282: GO 40348
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
40284: LD_ADDR_VAR 0 3
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: LD_INT 2
40294: PUSH
40295: LD_INT 3
40297: PUSH
40298: LD_INT 4
40300: PUSH
40301: LD_INT 11
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: LIST
40310: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
40311: LD_ADDR_EXP 76
40315: PUSH
40316: LD_EXP 76
40320: PPUSH
40321: LD_VAR 0 1
40325: PPUSH
40326: LD_EXP 76
40330: PUSH
40331: LD_VAR 0 1
40335: ARRAY
40336: PUSH
40337: LD_VAR 0 3
40341: DIFF
40342: PPUSH
40343: CALL_OW 1
40347: ST_TO_ADDR
// end ;
40348: LD_VAR 0 2
40352: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
40353: LD_INT 0
40355: PPUSH
// result := mc_vehicles [ base ] ;
40356: LD_ADDR_VAR 0 3
40360: PUSH
40361: LD_EXP 68
40365: PUSH
40366: LD_VAR 0 1
40370: ARRAY
40371: ST_TO_ADDR
// if onlyCombat then
40372: LD_VAR 0 2
40376: IFFALSE 40541
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
40378: LD_ADDR_VAR 0 3
40382: PUSH
40383: LD_VAR 0 3
40387: PUSH
40388: LD_VAR 0 3
40392: PPUSH
40393: LD_INT 2
40395: PUSH
40396: LD_INT 34
40398: PUSH
40399: LD_INT 12
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 34
40408: PUSH
40409: LD_INT 51
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 34
40418: PUSH
40419: LD_EXP 93
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: LD_INT 34
40430: PUSH
40431: LD_INT 32
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 34
40440: PUSH
40441: LD_INT 13
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 34
40450: PUSH
40451: LD_INT 52
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 34
40460: PUSH
40461: LD_INT 14
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 34
40470: PUSH
40471: LD_INT 53
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 34
40480: PUSH
40481: LD_EXP 92
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 34
40492: PUSH
40493: LD_INT 31
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 34
40502: PUSH
40503: LD_INT 48
40505: PUSH
40506: EMPTY
40507: LIST
40508: LIST
40509: PUSH
40510: LD_INT 34
40512: PUSH
40513: LD_INT 8
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: PPUSH
40535: CALL_OW 72
40539: DIFF
40540: ST_TO_ADDR
// end ; end_of_file
40541: LD_VAR 0 3
40545: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
40546: LD_INT 0
40548: PPUSH
40549: PPUSH
40550: PPUSH
// if not mc_bases or not skirmish then
40551: LD_EXP 49
40555: NOT
40556: PUSH
40557: LD_EXP 47
40561: NOT
40562: OR
40563: IFFALSE 40567
// exit ;
40565: GO 40732
// for i = 1 to mc_bases do
40567: LD_ADDR_VAR 0 4
40571: PUSH
40572: DOUBLE
40573: LD_INT 1
40575: DEC
40576: ST_TO_ADDR
40577: LD_EXP 49
40581: PUSH
40582: FOR_TO
40583: IFFALSE 40730
// begin if sci in mc_bases [ i ] then
40585: LD_VAR 0 2
40589: PUSH
40590: LD_EXP 49
40594: PUSH
40595: LD_VAR 0 4
40599: ARRAY
40600: IN
40601: IFFALSE 40728
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
40603: LD_ADDR_EXP 78
40607: PUSH
40608: LD_EXP 78
40612: PPUSH
40613: LD_VAR 0 4
40617: PUSH
40618: LD_EXP 78
40622: PUSH
40623: LD_VAR 0 4
40627: ARRAY
40628: PUSH
40629: LD_INT 1
40631: PLUS
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PPUSH
40637: LD_VAR 0 1
40641: PPUSH
40642: CALL 51685 0 3
40646: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
40647: LD_ADDR_VAR 0 5
40651: PUSH
40652: LD_EXP 49
40656: PUSH
40657: LD_VAR 0 4
40661: ARRAY
40662: PPUSH
40663: LD_INT 2
40665: PUSH
40666: LD_INT 30
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: LD_INT 30
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: LIST
40690: PPUSH
40691: CALL_OW 72
40695: PPUSH
40696: LD_VAR 0 1
40700: PPUSH
40701: CALL_OW 74
40705: ST_TO_ADDR
// if tmp then
40706: LD_VAR 0 5
40710: IFFALSE 40726
// ComStandNearbyBuilding ( ape , tmp ) ;
40712: LD_VAR 0 1
40716: PPUSH
40717: LD_VAR 0 5
40721: PPUSH
40722: CALL 46362 0 2
// break ;
40726: GO 40730
// end ; end ;
40728: GO 40582
40730: POP
40731: POP
// end ;
40732: LD_VAR 0 3
40736: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
40737: LD_INT 0
40739: PPUSH
40740: PPUSH
40741: PPUSH
// if not mc_bases or not skirmish then
40742: LD_EXP 49
40746: NOT
40747: PUSH
40748: LD_EXP 47
40752: NOT
40753: OR
40754: IFFALSE 40758
// exit ;
40756: GO 40847
// for i = 1 to mc_bases do
40758: LD_ADDR_VAR 0 4
40762: PUSH
40763: DOUBLE
40764: LD_INT 1
40766: DEC
40767: ST_TO_ADDR
40768: LD_EXP 49
40772: PUSH
40773: FOR_TO
40774: IFFALSE 40845
// begin if building in mc_busy_turret_list [ i ] then
40776: LD_VAR 0 1
40780: PUSH
40781: LD_EXP 59
40785: PUSH
40786: LD_VAR 0 4
40790: ARRAY
40791: IN
40792: IFFALSE 40843
// begin tmp := mc_busy_turret_list [ i ] diff building ;
40794: LD_ADDR_VAR 0 5
40798: PUSH
40799: LD_EXP 59
40803: PUSH
40804: LD_VAR 0 4
40808: ARRAY
40809: PUSH
40810: LD_VAR 0 1
40814: DIFF
40815: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
40816: LD_ADDR_EXP 59
40820: PUSH
40821: LD_EXP 59
40825: PPUSH
40826: LD_VAR 0 4
40830: PPUSH
40831: LD_VAR 0 5
40835: PPUSH
40836: CALL_OW 1
40840: ST_TO_ADDR
// break ;
40841: GO 40845
// end ; end ;
40843: GO 40773
40845: POP
40846: POP
// end ;
40847: LD_VAR 0 3
40851: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
40852: LD_INT 0
40854: PPUSH
40855: PPUSH
40856: PPUSH
// if not mc_bases or not skirmish then
40857: LD_EXP 49
40861: NOT
40862: PUSH
40863: LD_EXP 47
40867: NOT
40868: OR
40869: IFFALSE 40873
// exit ;
40871: GO 41072
// for i = 1 to mc_bases do
40873: LD_ADDR_VAR 0 5
40877: PUSH
40878: DOUBLE
40879: LD_INT 1
40881: DEC
40882: ST_TO_ADDR
40883: LD_EXP 49
40887: PUSH
40888: FOR_TO
40889: IFFALSE 41070
// if building in mc_bases [ i ] then
40891: LD_VAR 0 1
40895: PUSH
40896: LD_EXP 49
40900: PUSH
40901: LD_VAR 0 5
40905: ARRAY
40906: IN
40907: IFFALSE 41068
// begin tmp := mc_bases [ i ] diff building ;
40909: LD_ADDR_VAR 0 6
40913: PUSH
40914: LD_EXP 49
40918: PUSH
40919: LD_VAR 0 5
40923: ARRAY
40924: PUSH
40925: LD_VAR 0 1
40929: DIFF
40930: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
40931: LD_ADDR_EXP 49
40935: PUSH
40936: LD_EXP 49
40940: PPUSH
40941: LD_VAR 0 5
40945: PPUSH
40946: LD_VAR 0 6
40950: PPUSH
40951: CALL_OW 1
40955: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
40956: LD_VAR 0 1
40960: PUSH
40961: LD_EXP 57
40965: PUSH
40966: LD_VAR 0 5
40970: ARRAY
40971: IN
40972: IFFALSE 41011
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
40974: LD_ADDR_EXP 57
40978: PUSH
40979: LD_EXP 57
40983: PPUSH
40984: LD_VAR 0 5
40988: PPUSH
40989: LD_EXP 57
40993: PUSH
40994: LD_VAR 0 5
40998: ARRAY
40999: PUSH
41000: LD_VAR 0 1
41004: DIFF
41005: PPUSH
41006: CALL_OW 1
41010: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
41011: LD_VAR 0 1
41015: PUSH
41016: LD_EXP 58
41020: PUSH
41021: LD_VAR 0 5
41025: ARRAY
41026: IN
41027: IFFALSE 41066
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
41029: LD_ADDR_EXP 58
41033: PUSH
41034: LD_EXP 58
41038: PPUSH
41039: LD_VAR 0 5
41043: PPUSH
41044: LD_EXP 58
41048: PUSH
41049: LD_VAR 0 5
41053: ARRAY
41054: PUSH
41055: LD_VAR 0 1
41059: DIFF
41060: PPUSH
41061: CALL_OW 1
41065: ST_TO_ADDR
// break ;
41066: GO 41070
// end ;
41068: GO 40888
41070: POP
41071: POP
// end ;
41072: LD_VAR 0 4
41076: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
41077: LD_INT 0
41079: PPUSH
41080: PPUSH
41081: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
41082: LD_EXP 49
41086: NOT
41087: PUSH
41088: LD_EXP 47
41092: NOT
41093: OR
41094: PUSH
41095: LD_VAR 0 3
41099: PUSH
41100: LD_EXP 75
41104: IN
41105: NOT
41106: OR
41107: IFFALSE 41111
// exit ;
41109: GO 41234
// for i = 1 to mc_vehicles do
41111: LD_ADDR_VAR 0 6
41115: PUSH
41116: DOUBLE
41117: LD_INT 1
41119: DEC
41120: ST_TO_ADDR
41121: LD_EXP 68
41125: PUSH
41126: FOR_TO
41127: IFFALSE 41232
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
41129: LD_VAR 0 2
41133: PUSH
41134: LD_EXP 68
41138: PUSH
41139: LD_VAR 0 6
41143: ARRAY
41144: IN
41145: PUSH
41146: LD_VAR 0 1
41150: PUSH
41151: LD_EXP 68
41155: PUSH
41156: LD_VAR 0 6
41160: ARRAY
41161: IN
41162: OR
41163: IFFALSE 41230
// begin tmp := mc_vehicles [ i ] diff old ;
41165: LD_ADDR_VAR 0 7
41169: PUSH
41170: LD_EXP 68
41174: PUSH
41175: LD_VAR 0 6
41179: ARRAY
41180: PUSH
41181: LD_VAR 0 2
41185: DIFF
41186: ST_TO_ADDR
// tmp := tmp diff new ;
41187: LD_ADDR_VAR 0 7
41191: PUSH
41192: LD_VAR 0 7
41196: PUSH
41197: LD_VAR 0 1
41201: DIFF
41202: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
41203: LD_ADDR_EXP 68
41207: PUSH
41208: LD_EXP 68
41212: PPUSH
41213: LD_VAR 0 6
41217: PPUSH
41218: LD_VAR 0 7
41222: PPUSH
41223: CALL_OW 1
41227: ST_TO_ADDR
// break ;
41228: GO 41232
// end ;
41230: GO 41126
41232: POP
41233: POP
// end ;
41234: LD_VAR 0 5
41238: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
41239: LD_INT 0
41241: PPUSH
41242: PPUSH
41243: PPUSH
41244: PPUSH
// if not mc_bases or not skirmish then
41245: LD_EXP 49
41249: NOT
41250: PUSH
41251: LD_EXP 47
41255: NOT
41256: OR
41257: IFFALSE 41261
// exit ;
41259: GO 41644
// side := GetSide ( vehicle ) ;
41261: LD_ADDR_VAR 0 5
41265: PUSH
41266: LD_VAR 0 1
41270: PPUSH
41271: CALL_OW 255
41275: ST_TO_ADDR
// for i = 1 to mc_bases do
41276: LD_ADDR_VAR 0 4
41280: PUSH
41281: DOUBLE
41282: LD_INT 1
41284: DEC
41285: ST_TO_ADDR
41286: LD_EXP 49
41290: PUSH
41291: FOR_TO
41292: IFFALSE 41642
// begin if factory in mc_bases [ i ] then
41294: LD_VAR 0 2
41298: PUSH
41299: LD_EXP 49
41303: PUSH
41304: LD_VAR 0 4
41308: ARRAY
41309: IN
41310: IFFALSE 41640
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
41312: LD_EXP 71
41316: PUSH
41317: LD_VAR 0 4
41321: ARRAY
41322: PUSH
41323: LD_EXP 60
41327: PUSH
41328: LD_VAR 0 4
41332: ARRAY
41333: LESS
41334: PUSH
41335: LD_VAR 0 1
41339: PPUSH
41340: CALL_OW 264
41344: PUSH
41345: LD_INT 31
41347: PUSH
41348: LD_INT 32
41350: PUSH
41351: LD_INT 51
41353: PUSH
41354: LD_EXP 93
41358: PUSH
41359: LD_INT 12
41361: PUSH
41362: LD_INT 30
41364: PUSH
41365: LD_EXP 92
41369: PUSH
41370: LD_INT 11
41372: PUSH
41373: LD_INT 53
41375: PUSH
41376: LD_INT 14
41378: PUSH
41379: LD_EXP 96
41383: PUSH
41384: LD_INT 29
41386: PUSH
41387: LD_EXP 94
41391: PUSH
41392: LD_INT 13
41394: PUSH
41395: LD_INT 52
41397: PUSH
41398: LD_INT 48
41400: PUSH
41401: LD_INT 8
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: LIST
41408: LIST
41409: LIST
41410: LIST
41411: LIST
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: IN
41423: NOT
41424: AND
41425: IFFALSE 41466
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
41427: LD_ADDR_EXP 71
41431: PUSH
41432: LD_EXP 71
41436: PPUSH
41437: LD_VAR 0 4
41441: PPUSH
41442: LD_EXP 71
41446: PUSH
41447: LD_VAR 0 4
41451: ARRAY
41452: PUSH
41453: LD_VAR 0 1
41457: ADD
41458: PPUSH
41459: CALL_OW 1
41463: ST_TO_ADDR
41464: GO 41510
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
41466: LD_ADDR_EXP 68
41470: PUSH
41471: LD_EXP 68
41475: PPUSH
41476: LD_VAR 0 4
41480: PUSH
41481: LD_EXP 68
41485: PUSH
41486: LD_VAR 0 4
41490: ARRAY
41491: PUSH
41492: LD_INT 1
41494: PLUS
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PPUSH
41500: LD_VAR 0 1
41504: PPUSH
41505: CALL 51685 0 3
41509: ST_TO_ADDR
// if not mc_scan [ i ] then
41510: LD_EXP 72
41514: PUSH
41515: LD_VAR 0 4
41519: ARRAY
41520: NOT
41521: IFFALSE 41640
// begin if GetControl ( vehicle ) = control_remote then
41523: LD_VAR 0 1
41527: PPUSH
41528: CALL_OW 263
41532: PUSH
41533: LD_INT 2
41535: EQUAL
41536: IFFALSE 41556
// repeat wait ( 0 0$1 ) ;
41538: LD_INT 35
41540: PPUSH
41541: CALL_OW 67
// until IsControledBy ( vehicle ) ;
41545: LD_VAR 0 1
41549: PPUSH
41550: CALL_OW 312
41554: IFFALSE 41538
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
41556: LD_VAR 0 1
41560: PPUSH
41561: LD_EXP 73
41565: PUSH
41566: LD_VAR 0 4
41570: ARRAY
41571: PPUSH
41572: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
41576: LD_VAR 0 1
41580: PPUSH
41581: CALL_OW 263
41585: PUSH
41586: LD_INT 1
41588: NONEQUAL
41589: IFFALSE 41593
// break ;
41591: GO 41642
// repeat wait ( 0 0$1 ) ;
41593: LD_INT 35
41595: PPUSH
41596: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
41600: LD_VAR 0 1
41604: PPUSH
41605: LD_EXP 73
41609: PUSH
41610: LD_VAR 0 4
41614: ARRAY
41615: PPUSH
41616: CALL_OW 308
41620: IFFALSE 41593
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
41622: LD_VAR 0 1
41626: PPUSH
41627: CALL_OW 311
41631: PPUSH
41632: CALL_OW 121
// exit ;
41636: POP
41637: POP
41638: GO 41644
// end ; end ; end ;
41640: GO 41291
41642: POP
41643: POP
// end ;
41644: LD_VAR 0 3
41648: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
41649: LD_INT 0
41651: PPUSH
41652: PPUSH
41653: PPUSH
41654: PPUSH
// if not mc_bases or not skirmish then
41655: LD_EXP 49
41659: NOT
41660: PUSH
41661: LD_EXP 47
41665: NOT
41666: OR
41667: IFFALSE 41671
// exit ;
41669: GO 42024
// repeat wait ( 0 0$1 ) ;
41671: LD_INT 35
41673: PPUSH
41674: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
41678: LD_VAR 0 2
41682: PPUSH
41683: LD_VAR 0 3
41687: PPUSH
41688: CALL_OW 284
41692: IFFALSE 41671
// if GetResourceTypeXY ( x , y ) = mat_artefact then
41694: LD_VAR 0 2
41698: PPUSH
41699: LD_VAR 0 3
41703: PPUSH
41704: CALL_OW 283
41708: PUSH
41709: LD_INT 4
41711: EQUAL
41712: IFFALSE 41716
// exit ;
41714: GO 42024
// for i = 1 to mc_bases do
41716: LD_ADDR_VAR 0 7
41720: PUSH
41721: DOUBLE
41722: LD_INT 1
41724: DEC
41725: ST_TO_ADDR
41726: LD_EXP 49
41730: PUSH
41731: FOR_TO
41732: IFFALSE 42022
// begin if mc_crates_area [ i ] then
41734: LD_EXP 67
41738: PUSH
41739: LD_VAR 0 7
41743: ARRAY
41744: IFFALSE 41855
// for j in mc_crates_area [ i ] do
41746: LD_ADDR_VAR 0 8
41750: PUSH
41751: LD_EXP 67
41755: PUSH
41756: LD_VAR 0 7
41760: ARRAY
41761: PUSH
41762: FOR_IN
41763: IFFALSE 41853
// if InArea ( x , y , j ) then
41765: LD_VAR 0 2
41769: PPUSH
41770: LD_VAR 0 3
41774: PPUSH
41775: LD_VAR 0 8
41779: PPUSH
41780: CALL_OW 309
41784: IFFALSE 41851
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
41786: LD_ADDR_EXP 65
41790: PUSH
41791: LD_EXP 65
41795: PPUSH
41796: LD_VAR 0 7
41800: PUSH
41801: LD_EXP 65
41805: PUSH
41806: LD_VAR 0 7
41810: ARRAY
41811: PUSH
41812: LD_INT 1
41814: PLUS
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PPUSH
41820: LD_VAR 0 4
41824: PUSH
41825: LD_VAR 0 2
41829: PUSH
41830: LD_VAR 0 3
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: LIST
41839: PPUSH
41840: CALL 51685 0 3
41844: ST_TO_ADDR
// exit ;
41845: POP
41846: POP
41847: POP
41848: POP
41849: GO 42024
// end ;
41851: GO 41762
41853: POP
41854: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41855: LD_ADDR_VAR 0 9
41859: PUSH
41860: LD_EXP 49
41864: PUSH
41865: LD_VAR 0 7
41869: ARRAY
41870: PPUSH
41871: LD_INT 2
41873: PUSH
41874: LD_INT 30
41876: PUSH
41877: LD_INT 0
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 30
41886: PUSH
41887: LD_INT 1
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: LIST
41898: PPUSH
41899: CALL_OW 72
41903: ST_TO_ADDR
// if not depot then
41904: LD_VAR 0 9
41908: NOT
41909: IFFALSE 41913
// continue ;
41911: GO 41731
// for j in depot do
41913: LD_ADDR_VAR 0 8
41917: PUSH
41918: LD_VAR 0 9
41922: PUSH
41923: FOR_IN
41924: IFFALSE 42018
// if GetDistUnitXY ( j , x , y ) < 30 then
41926: LD_VAR 0 8
41930: PPUSH
41931: LD_VAR 0 2
41935: PPUSH
41936: LD_VAR 0 3
41940: PPUSH
41941: CALL_OW 297
41945: PUSH
41946: LD_INT 30
41948: LESS
41949: IFFALSE 42016
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
41951: LD_ADDR_EXP 65
41955: PUSH
41956: LD_EXP 65
41960: PPUSH
41961: LD_VAR 0 7
41965: PUSH
41966: LD_EXP 65
41970: PUSH
41971: LD_VAR 0 7
41975: ARRAY
41976: PUSH
41977: LD_INT 1
41979: PLUS
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PPUSH
41985: LD_VAR 0 4
41989: PUSH
41990: LD_VAR 0 2
41994: PUSH
41995: LD_VAR 0 3
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: LIST
42004: PPUSH
42005: CALL 51685 0 3
42009: ST_TO_ADDR
// exit ;
42010: POP
42011: POP
42012: POP
42013: POP
42014: GO 42024
// end ;
42016: GO 41923
42018: POP
42019: POP
// end ;
42020: GO 41731
42022: POP
42023: POP
// end ;
42024: LD_VAR 0 6
42028: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
42029: LD_INT 0
42031: PPUSH
42032: PPUSH
42033: PPUSH
42034: PPUSH
// if not mc_bases or not skirmish then
42035: LD_EXP 49
42039: NOT
42040: PUSH
42041: LD_EXP 47
42045: NOT
42046: OR
42047: IFFALSE 42051
// exit ;
42049: GO 42328
// side := GetSide ( lab ) ;
42051: LD_ADDR_VAR 0 4
42055: PUSH
42056: LD_VAR 0 2
42060: PPUSH
42061: CALL_OW 255
42065: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
42066: LD_VAR 0 4
42070: PUSH
42071: LD_EXP 75
42075: IN
42076: NOT
42077: PUSH
42078: LD_EXP 76
42082: NOT
42083: OR
42084: PUSH
42085: LD_EXP 49
42089: NOT
42090: OR
42091: IFFALSE 42095
// exit ;
42093: GO 42328
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
42095: LD_ADDR_EXP 76
42099: PUSH
42100: LD_EXP 76
42104: PPUSH
42105: LD_VAR 0 4
42109: PPUSH
42110: LD_EXP 76
42114: PUSH
42115: LD_VAR 0 4
42119: ARRAY
42120: PUSH
42121: LD_VAR 0 1
42125: DIFF
42126: PPUSH
42127: CALL_OW 1
42131: ST_TO_ADDR
// for i = 1 to mc_bases do
42132: LD_ADDR_VAR 0 5
42136: PUSH
42137: DOUBLE
42138: LD_INT 1
42140: DEC
42141: ST_TO_ADDR
42142: LD_EXP 49
42146: PUSH
42147: FOR_TO
42148: IFFALSE 42326
// begin if lab in mc_bases [ i ] then
42150: LD_VAR 0 2
42154: PUSH
42155: LD_EXP 49
42159: PUSH
42160: LD_VAR 0 5
42164: ARRAY
42165: IN
42166: IFFALSE 42324
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
42168: LD_VAR 0 1
42172: PUSH
42173: LD_INT 11
42175: PUSH
42176: LD_INT 4
42178: PUSH
42179: LD_INT 3
42181: PUSH
42182: LD_INT 2
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: IN
42191: PUSH
42192: LD_EXP 79
42196: PUSH
42197: LD_VAR 0 5
42201: ARRAY
42202: AND
42203: IFFALSE 42324
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
42205: LD_ADDR_VAR 0 6
42209: PUSH
42210: LD_EXP 79
42214: PUSH
42215: LD_VAR 0 5
42219: ARRAY
42220: PUSH
42221: LD_INT 1
42223: ARRAY
42224: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42225: LD_ADDR_EXP 79
42229: PUSH
42230: LD_EXP 79
42234: PPUSH
42235: LD_VAR 0 5
42239: PPUSH
42240: EMPTY
42241: PPUSH
42242: CALL_OW 1
42246: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
42247: LD_VAR 0 6
42251: PPUSH
42252: LD_INT 0
42254: PPUSH
42255: CALL_OW 109
// ComExitBuilding ( tmp ) ;
42259: LD_VAR 0 6
42263: PPUSH
42264: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
42268: LD_ADDR_EXP 78
42272: PUSH
42273: LD_EXP 78
42277: PPUSH
42278: LD_VAR 0 5
42282: PPUSH
42283: LD_EXP 78
42287: PUSH
42288: LD_VAR 0 5
42292: ARRAY
42293: PPUSH
42294: LD_INT 1
42296: PPUSH
42297: LD_VAR 0 6
42301: PPUSH
42302: CALL_OW 2
42306: PPUSH
42307: CALL_OW 1
42311: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
42312: LD_VAR 0 5
42316: PPUSH
42317: LD_INT 112
42319: PPUSH
42320: CALL 19797 0 2
// end ; end ; end ;
42324: GO 42147
42326: POP
42327: POP
// end ;
42328: LD_VAR 0 3
42332: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
42333: LD_INT 0
42335: PPUSH
42336: PPUSH
42337: PPUSH
42338: PPUSH
42339: PPUSH
42340: PPUSH
42341: PPUSH
42342: PPUSH
// if not mc_bases or not skirmish then
42343: LD_EXP 49
42347: NOT
42348: PUSH
42349: LD_EXP 47
42353: NOT
42354: OR
42355: IFFALSE 42359
// exit ;
42357: GO 43375
// for i = 1 to mc_bases do
42359: LD_ADDR_VAR 0 3
42363: PUSH
42364: DOUBLE
42365: LD_INT 1
42367: DEC
42368: ST_TO_ADDR
42369: LD_EXP 49
42373: PUSH
42374: FOR_TO
42375: IFFALSE 43373
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
42377: LD_VAR 0 1
42381: PUSH
42382: LD_EXP 49
42386: PUSH
42387: LD_VAR 0 3
42391: ARRAY
42392: IN
42393: PUSH
42394: LD_VAR 0 1
42398: PUSH
42399: LD_EXP 56
42403: PUSH
42404: LD_VAR 0 3
42408: ARRAY
42409: IN
42410: OR
42411: PUSH
42412: LD_VAR 0 1
42416: PUSH
42417: LD_EXP 68
42421: PUSH
42422: LD_VAR 0 3
42426: ARRAY
42427: IN
42428: OR
42429: PUSH
42430: LD_VAR 0 1
42434: PUSH
42435: LD_EXP 78
42439: PUSH
42440: LD_VAR 0 3
42444: ARRAY
42445: IN
42446: OR
42447: PUSH
42448: LD_VAR 0 1
42452: PUSH
42453: LD_EXP 79
42457: PUSH
42458: LD_VAR 0 3
42462: ARRAY
42463: IN
42464: OR
42465: IFFALSE 43371
// begin if un in mc_ape [ i ] then
42467: LD_VAR 0 1
42471: PUSH
42472: LD_EXP 78
42476: PUSH
42477: LD_VAR 0 3
42481: ARRAY
42482: IN
42483: IFFALSE 42522
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
42485: LD_ADDR_EXP 78
42489: PUSH
42490: LD_EXP 78
42494: PPUSH
42495: LD_VAR 0 3
42499: PPUSH
42500: LD_EXP 78
42504: PUSH
42505: LD_VAR 0 3
42509: ARRAY
42510: PUSH
42511: LD_VAR 0 1
42515: DIFF
42516: PPUSH
42517: CALL_OW 1
42521: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
42522: LD_VAR 0 1
42526: PUSH
42527: LD_EXP 79
42531: PUSH
42532: LD_VAR 0 3
42536: ARRAY
42537: IN
42538: IFFALSE 42562
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42540: LD_ADDR_EXP 79
42544: PUSH
42545: LD_EXP 79
42549: PPUSH
42550: LD_VAR 0 3
42554: PPUSH
42555: EMPTY
42556: PPUSH
42557: CALL_OW 1
42561: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
42562: LD_VAR 0 1
42566: PPUSH
42567: CALL_OW 247
42571: PUSH
42572: LD_INT 2
42574: EQUAL
42575: PUSH
42576: LD_VAR 0 1
42580: PPUSH
42581: CALL_OW 110
42585: PUSH
42586: LD_INT 20
42588: EQUAL
42589: PUSH
42590: LD_VAR 0 1
42594: PUSH
42595: LD_EXP 71
42599: PUSH
42600: LD_VAR 0 3
42604: ARRAY
42605: IN
42606: OR
42607: AND
42608: IFFALSE 42711
// begin fac := MC_GetBuilding ( i , b_factory ) ;
42610: LD_ADDR_VAR 0 8
42614: PUSH
42615: LD_VAR 0 3
42619: PPUSH
42620: LD_INT 3
42622: PPUSH
42623: CALL 39370 0 2
42627: ST_TO_ADDR
// if fac then
42628: LD_VAR 0 8
42632: IFFALSE 42711
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
42634: LD_ADDR_VAR 0 9
42638: PUSH
42639: LD_VAR 0 8
42643: PPUSH
42644: LD_VAR 0 1
42648: PPUSH
42649: CALL_OW 265
42653: PPUSH
42654: LD_VAR 0 1
42658: PPUSH
42659: CALL_OW 262
42663: PPUSH
42664: LD_VAR 0 1
42668: PPUSH
42669: CALL_OW 263
42673: PPUSH
42674: LD_VAR 0 1
42678: PPUSH
42679: CALL_OW 264
42683: PPUSH
42684: CALL 49285 0 5
42688: ST_TO_ADDR
// if components then
42689: LD_VAR 0 9
42693: IFFALSE 42709
// MC_InsertProduceList ( i , components ) ;
42695: LD_VAR 0 3
42699: PPUSH
42700: LD_VAR 0 9
42704: PPUSH
42705: CALL 38998 0 2
// break ;
42709: GO 43373
// end ; end ; if GetType ( un ) = unit_building then
42711: LD_VAR 0 1
42715: PPUSH
42716: CALL_OW 247
42720: PUSH
42721: LD_INT 3
42723: EQUAL
42724: IFFALSE 43039
// begin btype := GetBType ( un ) ;
42726: LD_ADDR_VAR 0 5
42730: PUSH
42731: LD_VAR 0 1
42735: PPUSH
42736: CALL_OW 266
42740: ST_TO_ADDR
// if btype = b_warehouse then
42741: LD_VAR 0 5
42745: PUSH
42746: LD_INT 1
42748: EQUAL
42749: IFFALSE 42767
// begin btype := b_depot ;
42751: LD_ADDR_VAR 0 5
42755: PUSH
42756: LD_INT 0
42758: ST_TO_ADDR
// pos := 1 ;
42759: LD_ADDR_VAR 0 6
42763: PUSH
42764: LD_INT 1
42766: ST_TO_ADDR
// end ; if btype = b_factory then
42767: LD_VAR 0 5
42771: PUSH
42772: LD_INT 3
42774: EQUAL
42775: IFFALSE 42793
// begin btype := b_workshop ;
42777: LD_ADDR_VAR 0 5
42781: PUSH
42782: LD_INT 2
42784: ST_TO_ADDR
// pos := 1 ;
42785: LD_ADDR_VAR 0 6
42789: PUSH
42790: LD_INT 1
42792: ST_TO_ADDR
// end ; if btype = b_barracks then
42793: LD_VAR 0 5
42797: PUSH
42798: LD_INT 5
42800: EQUAL
42801: IFFALSE 42811
// btype := b_armoury ;
42803: LD_ADDR_VAR 0 5
42807: PUSH
42808: LD_INT 4
42810: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
42811: LD_VAR 0 5
42815: PUSH
42816: LD_INT 7
42818: PUSH
42819: LD_INT 8
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: IN
42826: IFFALSE 42836
// btype := b_lab ;
42828: LD_ADDR_VAR 0 5
42832: PUSH
42833: LD_INT 6
42835: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
42836: LD_ADDR_EXP 54
42840: PUSH
42841: LD_EXP 54
42845: PPUSH
42846: LD_VAR 0 3
42850: PUSH
42851: LD_EXP 54
42855: PUSH
42856: LD_VAR 0 3
42860: ARRAY
42861: PUSH
42862: LD_INT 1
42864: PLUS
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PPUSH
42870: LD_VAR 0 5
42874: PUSH
42875: LD_VAR 0 1
42879: PPUSH
42880: CALL_OW 250
42884: PUSH
42885: LD_VAR 0 1
42889: PPUSH
42890: CALL_OW 251
42894: PUSH
42895: LD_VAR 0 1
42899: PPUSH
42900: CALL_OW 254
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: LIST
42909: LIST
42910: PPUSH
42911: CALL 51685 0 3
42915: ST_TO_ADDR
// if pos = 1 then
42916: LD_VAR 0 6
42920: PUSH
42921: LD_INT 1
42923: EQUAL
42924: IFFALSE 43039
// begin tmp := mc_build_list [ i ] ;
42926: LD_ADDR_VAR 0 7
42930: PUSH
42931: LD_EXP 54
42935: PUSH
42936: LD_VAR 0 3
42940: ARRAY
42941: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42942: LD_VAR 0 7
42946: PPUSH
42947: LD_INT 2
42949: PUSH
42950: LD_INT 30
42952: PUSH
42953: LD_INT 0
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PUSH
42960: LD_INT 30
42962: PUSH
42963: LD_INT 1
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: EMPTY
42971: LIST
42972: LIST
42973: LIST
42974: PPUSH
42975: CALL_OW 72
42979: IFFALSE 42989
// pos := 2 ;
42981: LD_ADDR_VAR 0 6
42985: PUSH
42986: LD_INT 2
42988: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
42989: LD_ADDR_VAR 0 7
42993: PUSH
42994: LD_VAR 0 7
42998: PPUSH
42999: LD_VAR 0 6
43003: PPUSH
43004: LD_VAR 0 7
43008: PPUSH
43009: CALL 52011 0 3
43013: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
43014: LD_ADDR_EXP 54
43018: PUSH
43019: LD_EXP 54
43023: PPUSH
43024: LD_VAR 0 3
43028: PPUSH
43029: LD_VAR 0 7
43033: PPUSH
43034: CALL_OW 1
43038: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
43039: LD_VAR 0 1
43043: PUSH
43044: LD_EXP 49
43048: PUSH
43049: LD_VAR 0 3
43053: ARRAY
43054: IN
43055: IFFALSE 43094
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
43057: LD_ADDR_EXP 49
43061: PUSH
43062: LD_EXP 49
43066: PPUSH
43067: LD_VAR 0 3
43071: PPUSH
43072: LD_EXP 49
43076: PUSH
43077: LD_VAR 0 3
43081: ARRAY
43082: PUSH
43083: LD_VAR 0 1
43087: DIFF
43088: PPUSH
43089: CALL_OW 1
43093: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
43094: LD_VAR 0 1
43098: PUSH
43099: LD_EXP 56
43103: PUSH
43104: LD_VAR 0 3
43108: ARRAY
43109: IN
43110: IFFALSE 43149
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
43112: LD_ADDR_EXP 56
43116: PUSH
43117: LD_EXP 56
43121: PPUSH
43122: LD_VAR 0 3
43126: PPUSH
43127: LD_EXP 56
43131: PUSH
43132: LD_VAR 0 3
43136: ARRAY
43137: PUSH
43138: LD_VAR 0 1
43142: DIFF
43143: PPUSH
43144: CALL_OW 1
43148: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
43149: LD_VAR 0 1
43153: PUSH
43154: LD_EXP 68
43158: PUSH
43159: LD_VAR 0 3
43163: ARRAY
43164: IN
43165: IFFALSE 43204
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
43167: LD_ADDR_EXP 68
43171: PUSH
43172: LD_EXP 68
43176: PPUSH
43177: LD_VAR 0 3
43181: PPUSH
43182: LD_EXP 68
43186: PUSH
43187: LD_VAR 0 3
43191: ARRAY
43192: PUSH
43193: LD_VAR 0 1
43197: DIFF
43198: PPUSH
43199: CALL_OW 1
43203: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
43204: LD_VAR 0 1
43208: PUSH
43209: LD_EXP 71
43213: PUSH
43214: LD_VAR 0 3
43218: ARRAY
43219: IN
43220: IFFALSE 43259
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
43222: LD_ADDR_EXP 71
43226: PUSH
43227: LD_EXP 71
43231: PPUSH
43232: LD_VAR 0 3
43236: PPUSH
43237: LD_EXP 71
43241: PUSH
43242: LD_VAR 0 3
43246: ARRAY
43247: PUSH
43248: LD_VAR 0 1
43252: DIFF
43253: PPUSH
43254: CALL_OW 1
43258: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
43259: LD_VAR 0 1
43263: PUSH
43264: LD_EXP 58
43268: PUSH
43269: LD_VAR 0 3
43273: ARRAY
43274: IN
43275: IFFALSE 43314
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
43277: LD_ADDR_EXP 58
43281: PUSH
43282: LD_EXP 58
43286: PPUSH
43287: LD_VAR 0 3
43291: PPUSH
43292: LD_EXP 58
43296: PUSH
43297: LD_VAR 0 3
43301: ARRAY
43302: PUSH
43303: LD_VAR 0 1
43307: DIFF
43308: PPUSH
43309: CALL_OW 1
43313: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
43314: LD_VAR 0 1
43318: PUSH
43319: LD_EXP 57
43323: PUSH
43324: LD_VAR 0 3
43328: ARRAY
43329: IN
43330: IFFALSE 43369
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
43332: LD_ADDR_EXP 57
43336: PUSH
43337: LD_EXP 57
43341: PPUSH
43342: LD_VAR 0 3
43346: PPUSH
43347: LD_EXP 57
43351: PUSH
43352: LD_VAR 0 3
43356: ARRAY
43357: PUSH
43358: LD_VAR 0 1
43362: DIFF
43363: PPUSH
43364: CALL_OW 1
43368: ST_TO_ADDR
// end ; break ;
43369: GO 43373
// end ;
43371: GO 42374
43373: POP
43374: POP
// end ;
43375: LD_VAR 0 2
43379: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
43380: LD_INT 0
43382: PPUSH
43383: PPUSH
43384: PPUSH
// if not mc_bases or not skirmish then
43385: LD_EXP 49
43389: NOT
43390: PUSH
43391: LD_EXP 47
43395: NOT
43396: OR
43397: IFFALSE 43401
// exit ;
43399: GO 43616
// for i = 1 to mc_bases do
43401: LD_ADDR_VAR 0 3
43405: PUSH
43406: DOUBLE
43407: LD_INT 1
43409: DEC
43410: ST_TO_ADDR
43411: LD_EXP 49
43415: PUSH
43416: FOR_TO
43417: IFFALSE 43614
// begin if building in mc_construct_list [ i ] then
43419: LD_VAR 0 1
43423: PUSH
43424: LD_EXP 56
43428: PUSH
43429: LD_VAR 0 3
43433: ARRAY
43434: IN
43435: IFFALSE 43612
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
43437: LD_ADDR_EXP 56
43441: PUSH
43442: LD_EXP 56
43446: PPUSH
43447: LD_VAR 0 3
43451: PPUSH
43452: LD_EXP 56
43456: PUSH
43457: LD_VAR 0 3
43461: ARRAY
43462: PUSH
43463: LD_VAR 0 1
43467: DIFF
43468: PPUSH
43469: CALL_OW 1
43473: ST_TO_ADDR
// if building in mc_lab [ i ] then
43474: LD_VAR 0 1
43478: PUSH
43479: LD_EXP 82
43483: PUSH
43484: LD_VAR 0 3
43488: ARRAY
43489: IN
43490: IFFALSE 43545
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
43492: LD_ADDR_EXP 83
43496: PUSH
43497: LD_EXP 83
43501: PPUSH
43502: LD_VAR 0 3
43506: PPUSH
43507: LD_EXP 83
43511: PUSH
43512: LD_VAR 0 3
43516: ARRAY
43517: PPUSH
43518: LD_INT 1
43520: PPUSH
43521: LD_EXP 83
43525: PUSH
43526: LD_VAR 0 3
43530: ARRAY
43531: PPUSH
43532: LD_INT 0
43534: PPUSH
43535: CALL 51103 0 4
43539: PPUSH
43540: CALL_OW 1
43544: ST_TO_ADDR
// if not building in mc_bases [ i ] then
43545: LD_VAR 0 1
43549: PUSH
43550: LD_EXP 49
43554: PUSH
43555: LD_VAR 0 3
43559: ARRAY
43560: IN
43561: NOT
43562: IFFALSE 43608
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
43564: LD_ADDR_EXP 49
43568: PUSH
43569: LD_EXP 49
43573: PPUSH
43574: LD_VAR 0 3
43578: PUSH
43579: LD_EXP 49
43583: PUSH
43584: LD_VAR 0 3
43588: ARRAY
43589: PUSH
43590: LD_INT 1
43592: PLUS
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PPUSH
43598: LD_VAR 0 1
43602: PPUSH
43603: CALL 51685 0 3
43607: ST_TO_ADDR
// exit ;
43608: POP
43609: POP
43610: GO 43616
// end ; end ;
43612: GO 43416
43614: POP
43615: POP
// end ;
43616: LD_VAR 0 2
43620: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
43621: LD_INT 0
43623: PPUSH
43624: PPUSH
43625: PPUSH
43626: PPUSH
43627: PPUSH
43628: PPUSH
43629: PPUSH
// if not mc_bases or not skirmish then
43630: LD_EXP 49
43634: NOT
43635: PUSH
43636: LD_EXP 47
43640: NOT
43641: OR
43642: IFFALSE 43646
// exit ;
43644: GO 44307
// for i = 1 to mc_bases do
43646: LD_ADDR_VAR 0 3
43650: PUSH
43651: DOUBLE
43652: LD_INT 1
43654: DEC
43655: ST_TO_ADDR
43656: LD_EXP 49
43660: PUSH
43661: FOR_TO
43662: IFFALSE 44305
// begin if building in mc_construct_list [ i ] then
43664: LD_VAR 0 1
43668: PUSH
43669: LD_EXP 56
43673: PUSH
43674: LD_VAR 0 3
43678: ARRAY
43679: IN
43680: IFFALSE 44303
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
43682: LD_ADDR_EXP 56
43686: PUSH
43687: LD_EXP 56
43691: PPUSH
43692: LD_VAR 0 3
43696: PPUSH
43697: LD_EXP 56
43701: PUSH
43702: LD_VAR 0 3
43706: ARRAY
43707: PUSH
43708: LD_VAR 0 1
43712: DIFF
43713: PPUSH
43714: CALL_OW 1
43718: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
43719: LD_ADDR_EXP 49
43723: PUSH
43724: LD_EXP 49
43728: PPUSH
43729: LD_VAR 0 3
43733: PUSH
43734: LD_EXP 49
43738: PUSH
43739: LD_VAR 0 3
43743: ARRAY
43744: PUSH
43745: LD_INT 1
43747: PLUS
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PPUSH
43753: LD_VAR 0 1
43757: PPUSH
43758: CALL 51685 0 3
43762: ST_TO_ADDR
// btype := GetBType ( building ) ;
43763: LD_ADDR_VAR 0 5
43767: PUSH
43768: LD_VAR 0 1
43772: PPUSH
43773: CALL_OW 266
43777: ST_TO_ADDR
// side := GetSide ( building ) ;
43778: LD_ADDR_VAR 0 8
43782: PUSH
43783: LD_VAR 0 1
43787: PPUSH
43788: CALL_OW 255
43792: ST_TO_ADDR
// if btype = b_lab then
43793: LD_VAR 0 5
43797: PUSH
43798: LD_INT 6
43800: EQUAL
43801: IFFALSE 43851
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
43803: LD_ADDR_EXP 82
43807: PUSH
43808: LD_EXP 82
43812: PPUSH
43813: LD_VAR 0 3
43817: PUSH
43818: LD_EXP 82
43822: PUSH
43823: LD_VAR 0 3
43827: ARRAY
43828: PUSH
43829: LD_INT 1
43831: PLUS
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PPUSH
43837: LD_VAR 0 1
43841: PPUSH
43842: CALL 51685 0 3
43846: ST_TO_ADDR
// exit ;
43847: POP
43848: POP
43849: GO 44307
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
43851: LD_VAR 0 5
43855: PUSH
43856: LD_INT 0
43858: PUSH
43859: LD_INT 2
43861: PUSH
43862: LD_INT 4
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: LIST
43869: IN
43870: IFFALSE 43994
// begin if btype = b_armoury then
43872: LD_VAR 0 5
43876: PUSH
43877: LD_INT 4
43879: EQUAL
43880: IFFALSE 43890
// btype := b_barracks ;
43882: LD_ADDR_VAR 0 5
43886: PUSH
43887: LD_INT 5
43889: ST_TO_ADDR
// if btype = b_depot then
43890: LD_VAR 0 5
43894: PUSH
43895: LD_INT 0
43897: EQUAL
43898: IFFALSE 43908
// btype := b_warehouse ;
43900: LD_ADDR_VAR 0 5
43904: PUSH
43905: LD_INT 1
43907: ST_TO_ADDR
// if btype = b_workshop then
43908: LD_VAR 0 5
43912: PUSH
43913: LD_INT 2
43915: EQUAL
43916: IFFALSE 43926
// btype := b_factory ;
43918: LD_ADDR_VAR 0 5
43922: PUSH
43923: LD_INT 3
43925: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
43926: LD_VAR 0 5
43930: PPUSH
43931: LD_VAR 0 8
43935: PPUSH
43936: CALL_OW 323
43940: PUSH
43941: LD_INT 1
43943: EQUAL
43944: IFFALSE 43990
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
43946: LD_ADDR_EXP 81
43950: PUSH
43951: LD_EXP 81
43955: PPUSH
43956: LD_VAR 0 3
43960: PUSH
43961: LD_EXP 81
43965: PUSH
43966: LD_VAR 0 3
43970: ARRAY
43971: PUSH
43972: LD_INT 1
43974: PLUS
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PPUSH
43980: LD_VAR 0 1
43984: PPUSH
43985: CALL 51685 0 3
43989: ST_TO_ADDR
// exit ;
43990: POP
43991: POP
43992: GO 44307
// end ; if btype in [ b_bunker , b_turret ] then
43994: LD_VAR 0 5
43998: PUSH
43999: LD_INT 32
44001: PUSH
44002: LD_INT 33
44004: PUSH
44005: EMPTY
44006: LIST
44007: LIST
44008: IN
44009: IFFALSE 44299
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
44011: LD_ADDR_EXP 57
44015: PUSH
44016: LD_EXP 57
44020: PPUSH
44021: LD_VAR 0 3
44025: PUSH
44026: LD_EXP 57
44030: PUSH
44031: LD_VAR 0 3
44035: ARRAY
44036: PUSH
44037: LD_INT 1
44039: PLUS
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PPUSH
44045: LD_VAR 0 1
44049: PPUSH
44050: CALL 51685 0 3
44054: ST_TO_ADDR
// if btype = b_bunker then
44055: LD_VAR 0 5
44059: PUSH
44060: LD_INT 32
44062: EQUAL
44063: IFFALSE 44299
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
44065: LD_ADDR_EXP 58
44069: PUSH
44070: LD_EXP 58
44074: PPUSH
44075: LD_VAR 0 3
44079: PUSH
44080: LD_EXP 58
44084: PUSH
44085: LD_VAR 0 3
44089: ARRAY
44090: PUSH
44091: LD_INT 1
44093: PLUS
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PPUSH
44099: LD_VAR 0 1
44103: PPUSH
44104: CALL 51685 0 3
44108: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
44109: LD_ADDR_VAR 0 6
44113: PUSH
44114: LD_EXP 49
44118: PUSH
44119: LD_VAR 0 3
44123: ARRAY
44124: PPUSH
44125: LD_INT 25
44127: PUSH
44128: LD_INT 1
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 3
44137: PUSH
44138: LD_INT 54
44140: PUSH
44141: EMPTY
44142: LIST
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PPUSH
44152: CALL_OW 72
44156: ST_TO_ADDR
// if tmp then
44157: LD_VAR 0 6
44161: IFFALSE 44167
// exit ;
44163: POP
44164: POP
44165: GO 44307
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44167: LD_ADDR_VAR 0 6
44171: PUSH
44172: LD_EXP 49
44176: PUSH
44177: LD_VAR 0 3
44181: ARRAY
44182: PPUSH
44183: LD_INT 2
44185: PUSH
44186: LD_INT 30
44188: PUSH
44189: LD_INT 4
44191: PUSH
44192: EMPTY
44193: LIST
44194: LIST
44195: PUSH
44196: LD_INT 30
44198: PUSH
44199: LD_INT 5
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: LIST
44210: PPUSH
44211: CALL_OW 72
44215: ST_TO_ADDR
// if not tmp then
44216: LD_VAR 0 6
44220: NOT
44221: IFFALSE 44227
// exit ;
44223: POP
44224: POP
44225: GO 44307
// for j in tmp do
44227: LD_ADDR_VAR 0 4
44231: PUSH
44232: LD_VAR 0 6
44236: PUSH
44237: FOR_IN
44238: IFFALSE 44297
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
44240: LD_ADDR_VAR 0 7
44244: PUSH
44245: LD_VAR 0 4
44249: PPUSH
44250: CALL_OW 313
44254: PPUSH
44255: LD_INT 25
44257: PUSH
44258: LD_INT 1
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PPUSH
44265: CALL_OW 72
44269: ST_TO_ADDR
// if units then
44270: LD_VAR 0 7
44274: IFFALSE 44295
// begin ComExitBuilding ( units [ 1 ] ) ;
44276: LD_VAR 0 7
44280: PUSH
44281: LD_INT 1
44283: ARRAY
44284: PPUSH
44285: CALL_OW 122
// exit ;
44289: POP
44290: POP
44291: POP
44292: POP
44293: GO 44307
// end ; end ;
44295: GO 44237
44297: POP
44298: POP
// end ; end ; exit ;
44299: POP
44300: POP
44301: GO 44307
// end ; end ;
44303: GO 43661
44305: POP
44306: POP
// end ;
44307: LD_VAR 0 2
44311: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
44312: LD_INT 0
44314: PPUSH
44315: PPUSH
44316: PPUSH
44317: PPUSH
44318: PPUSH
44319: PPUSH
44320: PPUSH
// if not mc_bases or not skirmish then
44321: LD_EXP 49
44325: NOT
44326: PUSH
44327: LD_EXP 47
44331: NOT
44332: OR
44333: IFFALSE 44337
// exit ;
44335: GO 44568
// btype := GetBType ( building ) ;
44337: LD_ADDR_VAR 0 6
44341: PUSH
44342: LD_VAR 0 1
44346: PPUSH
44347: CALL_OW 266
44351: ST_TO_ADDR
// x := GetX ( building ) ;
44352: LD_ADDR_VAR 0 7
44356: PUSH
44357: LD_VAR 0 1
44361: PPUSH
44362: CALL_OW 250
44366: ST_TO_ADDR
// y := GetY ( building ) ;
44367: LD_ADDR_VAR 0 8
44371: PUSH
44372: LD_VAR 0 1
44376: PPUSH
44377: CALL_OW 251
44381: ST_TO_ADDR
// d := GetDir ( building ) ;
44382: LD_ADDR_VAR 0 9
44386: PUSH
44387: LD_VAR 0 1
44391: PPUSH
44392: CALL_OW 254
44396: ST_TO_ADDR
// for i = 1 to mc_bases do
44397: LD_ADDR_VAR 0 4
44401: PUSH
44402: DOUBLE
44403: LD_INT 1
44405: DEC
44406: ST_TO_ADDR
44407: LD_EXP 49
44411: PUSH
44412: FOR_TO
44413: IFFALSE 44566
// begin if not mc_build_list [ i ] then
44415: LD_EXP 54
44419: PUSH
44420: LD_VAR 0 4
44424: ARRAY
44425: NOT
44426: IFFALSE 44430
// continue ;
44428: GO 44412
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
44430: LD_VAR 0 6
44434: PUSH
44435: LD_VAR 0 7
44439: PUSH
44440: LD_VAR 0 8
44444: PUSH
44445: LD_VAR 0 9
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: PPUSH
44456: LD_EXP 54
44460: PUSH
44461: LD_VAR 0 4
44465: ARRAY
44466: PUSH
44467: LD_INT 1
44469: ARRAY
44470: PPUSH
44471: CALL 57854 0 2
44475: IFFALSE 44564
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
44477: LD_ADDR_EXP 54
44481: PUSH
44482: LD_EXP 54
44486: PPUSH
44487: LD_VAR 0 4
44491: PPUSH
44492: LD_EXP 54
44496: PUSH
44497: LD_VAR 0 4
44501: ARRAY
44502: PPUSH
44503: LD_INT 1
44505: PPUSH
44506: CALL_OW 3
44510: PPUSH
44511: CALL_OW 1
44515: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
44516: LD_ADDR_EXP 56
44520: PUSH
44521: LD_EXP 56
44525: PPUSH
44526: LD_VAR 0 4
44530: PUSH
44531: LD_EXP 56
44535: PUSH
44536: LD_VAR 0 4
44540: ARRAY
44541: PUSH
44542: LD_INT 1
44544: PLUS
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PPUSH
44550: LD_VAR 0 1
44554: PPUSH
44555: CALL 51685 0 3
44559: ST_TO_ADDR
// exit ;
44560: POP
44561: POP
44562: GO 44568
// end ; end ;
44564: GO 44412
44566: POP
44567: POP
// end ;
44568: LD_VAR 0 3
44572: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
44573: LD_INT 0
44575: PPUSH
44576: PPUSH
44577: PPUSH
// if not mc_bases or not skirmish then
44578: LD_EXP 49
44582: NOT
44583: PUSH
44584: LD_EXP 47
44588: NOT
44589: OR
44590: IFFALSE 44594
// exit ;
44592: GO 44784
// for i = 1 to mc_bases do
44594: LD_ADDR_VAR 0 4
44598: PUSH
44599: DOUBLE
44600: LD_INT 1
44602: DEC
44603: ST_TO_ADDR
44604: LD_EXP 49
44608: PUSH
44609: FOR_TO
44610: IFFALSE 44697
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
44612: LD_VAR 0 1
44616: PUSH
44617: LD_EXP 57
44621: PUSH
44622: LD_VAR 0 4
44626: ARRAY
44627: IN
44628: PUSH
44629: LD_VAR 0 1
44633: PUSH
44634: LD_EXP 58
44638: PUSH
44639: LD_VAR 0 4
44643: ARRAY
44644: IN
44645: NOT
44646: AND
44647: IFFALSE 44695
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
44649: LD_ADDR_EXP 58
44653: PUSH
44654: LD_EXP 58
44658: PPUSH
44659: LD_VAR 0 4
44663: PUSH
44664: LD_EXP 58
44668: PUSH
44669: LD_VAR 0 4
44673: ARRAY
44674: PUSH
44675: LD_INT 1
44677: PLUS
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PPUSH
44683: LD_VAR 0 1
44687: PPUSH
44688: CALL 51685 0 3
44692: ST_TO_ADDR
// break ;
44693: GO 44697
// end ; end ;
44695: GO 44609
44697: POP
44698: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
44699: LD_VAR 0 1
44703: PPUSH
44704: CALL_OW 257
44708: PUSH
44709: LD_EXP 75
44713: IN
44714: PUSH
44715: LD_VAR 0 1
44719: PPUSH
44720: CALL_OW 266
44724: PUSH
44725: LD_INT 5
44727: EQUAL
44728: AND
44729: PUSH
44730: LD_VAR 0 2
44734: PPUSH
44735: CALL_OW 110
44739: PUSH
44740: LD_INT 18
44742: NONEQUAL
44743: AND
44744: IFFALSE 44784
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
44746: LD_VAR 0 2
44750: PPUSH
44751: CALL_OW 257
44755: PUSH
44756: LD_INT 5
44758: PUSH
44759: LD_INT 8
44761: PUSH
44762: LD_INT 9
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: LIST
44769: IN
44770: IFFALSE 44784
// SetClass ( unit , 1 ) ;
44772: LD_VAR 0 2
44776: PPUSH
44777: LD_INT 1
44779: PPUSH
44780: CALL_OW 336
// end ;
44784: LD_VAR 0 3
44788: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
44789: LD_INT 0
44791: PPUSH
44792: PPUSH
// if not mc_bases or not skirmish then
44793: LD_EXP 49
44797: NOT
44798: PUSH
44799: LD_EXP 47
44803: NOT
44804: OR
44805: IFFALSE 44809
// exit ;
44807: GO 44925
// if GetLives ( abandoned_vehicle ) > 250 then
44809: LD_VAR 0 2
44813: PPUSH
44814: CALL_OW 256
44818: PUSH
44819: LD_INT 250
44821: GREATER
44822: IFFALSE 44826
// exit ;
44824: GO 44925
// for i = 1 to mc_bases do
44826: LD_ADDR_VAR 0 6
44830: PUSH
44831: DOUBLE
44832: LD_INT 1
44834: DEC
44835: ST_TO_ADDR
44836: LD_EXP 49
44840: PUSH
44841: FOR_TO
44842: IFFALSE 44923
// begin if driver in mc_bases [ i ] then
44844: LD_VAR 0 1
44848: PUSH
44849: LD_EXP 49
44853: PUSH
44854: LD_VAR 0 6
44858: ARRAY
44859: IN
44860: IFFALSE 44921
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
44862: LD_VAR 0 1
44866: PPUSH
44867: LD_EXP 49
44871: PUSH
44872: LD_VAR 0 6
44876: ARRAY
44877: PPUSH
44878: LD_INT 2
44880: PUSH
44881: LD_INT 30
44883: PUSH
44884: LD_INT 0
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 30
44893: PUSH
44894: LD_INT 1
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: PPUSH
44906: CALL_OW 72
44910: PUSH
44911: LD_INT 1
44913: ARRAY
44914: PPUSH
44915: CALL_OW 112
// break ;
44919: GO 44923
// end ; end ;
44921: GO 44841
44923: POP
44924: POP
// end ; end_of_file
44925: LD_VAR 0 5
44929: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
44930: LD_INT 0
44932: PPUSH
44933: PPUSH
// if exist_mode then
44934: LD_VAR 0 2
44938: IFFALSE 44963
// unit := CreateCharacter ( prefix & ident ) else
44940: LD_ADDR_VAR 0 5
44944: PUSH
44945: LD_VAR 0 3
44949: PUSH
44950: LD_VAR 0 1
44954: STR
44955: PPUSH
44956: CALL_OW 34
44960: ST_TO_ADDR
44961: GO 44978
// unit := NewCharacter ( ident ) ;
44963: LD_ADDR_VAR 0 5
44967: PUSH
44968: LD_VAR 0 1
44972: PPUSH
44973: CALL_OW 25
44977: ST_TO_ADDR
// result := unit ;
44978: LD_ADDR_VAR 0 4
44982: PUSH
44983: LD_VAR 0 5
44987: ST_TO_ADDR
// end ;
44988: LD_VAR 0 4
44992: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
44993: LD_INT 0
44995: PPUSH
44996: PPUSH
// if not side or not nation then
44997: LD_VAR 0 1
45001: NOT
45002: PUSH
45003: LD_VAR 0 2
45007: NOT
45008: OR
45009: IFFALSE 45013
// exit ;
45011: GO 45649
// case nation of nation_american :
45013: LD_VAR 0 2
45017: PUSH
45018: LD_INT 1
45020: DOUBLE
45021: EQUAL
45022: IFTRUE 45026
45024: GO 45196
45026: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
45027: LD_ADDR_VAR 0 4
45031: PUSH
45032: LD_INT 35
45034: PUSH
45035: LD_INT 45
45037: PUSH
45038: LD_INT 46
45040: PUSH
45041: LD_INT 47
45043: PUSH
45044: LD_INT 1
45046: PUSH
45047: LD_INT 2
45049: PUSH
45050: LD_INT 6
45052: PUSH
45053: LD_INT 15
45055: PUSH
45056: LD_INT 16
45058: PUSH
45059: LD_INT 7
45061: PUSH
45062: LD_INT 12
45064: PUSH
45065: LD_INT 13
45067: PUSH
45068: LD_INT 10
45070: PUSH
45071: LD_INT 14
45073: PUSH
45074: LD_INT 20
45076: PUSH
45077: LD_INT 21
45079: PUSH
45080: LD_INT 22
45082: PUSH
45083: LD_INT 25
45085: PUSH
45086: LD_INT 32
45088: PUSH
45089: LD_INT 27
45091: PUSH
45092: LD_INT 36
45094: PUSH
45095: LD_INT 69
45097: PUSH
45098: LD_INT 39
45100: PUSH
45101: LD_INT 34
45103: PUSH
45104: LD_INT 40
45106: PUSH
45107: LD_INT 48
45109: PUSH
45110: LD_INT 49
45112: PUSH
45113: LD_INT 50
45115: PUSH
45116: LD_INT 51
45118: PUSH
45119: LD_INT 52
45121: PUSH
45122: LD_INT 53
45124: PUSH
45125: LD_INT 54
45127: PUSH
45128: LD_INT 55
45130: PUSH
45131: LD_INT 56
45133: PUSH
45134: LD_INT 57
45136: PUSH
45137: LD_INT 58
45139: PUSH
45140: LD_INT 59
45142: PUSH
45143: LD_INT 60
45145: PUSH
45146: LD_INT 61
45148: PUSH
45149: LD_INT 62
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: ST_TO_ADDR
45194: GO 45573
45196: LD_INT 2
45198: DOUBLE
45199: EQUAL
45200: IFTRUE 45204
45202: GO 45382
45204: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
45205: LD_ADDR_VAR 0 4
45209: PUSH
45210: LD_INT 35
45212: PUSH
45213: LD_INT 45
45215: PUSH
45216: LD_INT 46
45218: PUSH
45219: LD_INT 47
45221: PUSH
45222: LD_INT 70
45224: PUSH
45225: LD_INT 1
45227: PUSH
45228: LD_INT 11
45230: PUSH
45231: LD_INT 3
45233: PUSH
45234: LD_INT 4
45236: PUSH
45237: LD_INT 5
45239: PUSH
45240: LD_INT 6
45242: PUSH
45243: LD_INT 15
45245: PUSH
45246: LD_INT 18
45248: PUSH
45249: LD_INT 7
45251: PUSH
45252: LD_INT 17
45254: PUSH
45255: LD_INT 8
45257: PUSH
45258: LD_INT 20
45260: PUSH
45261: LD_INT 21
45263: PUSH
45264: LD_INT 22
45266: PUSH
45267: LD_INT 72
45269: PUSH
45270: LD_INT 26
45272: PUSH
45273: LD_INT 69
45275: PUSH
45276: LD_INT 39
45278: PUSH
45279: LD_INT 40
45281: PUSH
45282: LD_INT 41
45284: PUSH
45285: LD_INT 42
45287: PUSH
45288: LD_INT 43
45290: PUSH
45291: LD_INT 48
45293: PUSH
45294: LD_INT 49
45296: PUSH
45297: LD_INT 50
45299: PUSH
45300: LD_INT 51
45302: PUSH
45303: LD_INT 52
45305: PUSH
45306: LD_INT 53
45308: PUSH
45309: LD_INT 54
45311: PUSH
45312: LD_INT 55
45314: PUSH
45315: LD_INT 56
45317: PUSH
45318: LD_INT 60
45320: PUSH
45321: LD_INT 61
45323: PUSH
45324: LD_INT 62
45326: PUSH
45327: LD_INT 66
45329: PUSH
45330: LD_INT 67
45332: PUSH
45333: LD_INT 68
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: ST_TO_ADDR
45380: GO 45573
45382: LD_INT 3
45384: DOUBLE
45385: EQUAL
45386: IFTRUE 45390
45388: GO 45572
45390: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
45391: LD_ADDR_VAR 0 4
45395: PUSH
45396: LD_INT 46
45398: PUSH
45399: LD_INT 47
45401: PUSH
45402: LD_INT 1
45404: PUSH
45405: LD_INT 2
45407: PUSH
45408: LD_INT 11
45410: PUSH
45411: LD_INT 9
45413: PUSH
45414: LD_INT 20
45416: PUSH
45417: LD_INT 19
45419: PUSH
45420: LD_INT 21
45422: PUSH
45423: LD_INT 24
45425: PUSH
45426: LD_INT 22
45428: PUSH
45429: LD_INT 25
45431: PUSH
45432: LD_INT 28
45434: PUSH
45435: LD_INT 29
45437: PUSH
45438: LD_INT 30
45440: PUSH
45441: LD_INT 31
45443: PUSH
45444: LD_INT 37
45446: PUSH
45447: LD_INT 38
45449: PUSH
45450: LD_INT 32
45452: PUSH
45453: LD_INT 27
45455: PUSH
45456: LD_INT 33
45458: PUSH
45459: LD_INT 69
45461: PUSH
45462: LD_INT 39
45464: PUSH
45465: LD_INT 34
45467: PUSH
45468: LD_INT 40
45470: PUSH
45471: LD_INT 71
45473: PUSH
45474: LD_INT 23
45476: PUSH
45477: LD_INT 44
45479: PUSH
45480: LD_INT 48
45482: PUSH
45483: LD_INT 49
45485: PUSH
45486: LD_INT 50
45488: PUSH
45489: LD_INT 51
45491: PUSH
45492: LD_INT 52
45494: PUSH
45495: LD_INT 53
45497: PUSH
45498: LD_INT 54
45500: PUSH
45501: LD_INT 55
45503: PUSH
45504: LD_INT 56
45506: PUSH
45507: LD_INT 57
45509: PUSH
45510: LD_INT 58
45512: PUSH
45513: LD_INT 59
45515: PUSH
45516: LD_INT 63
45518: PUSH
45519: LD_INT 64
45521: PUSH
45522: LD_INT 65
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: ST_TO_ADDR
45570: GO 45573
45572: POP
// if state > - 1 and state < 3 then
45573: LD_VAR 0 3
45577: PUSH
45578: LD_INT 1
45580: NEG
45581: GREATER
45582: PUSH
45583: LD_VAR 0 3
45587: PUSH
45588: LD_INT 3
45590: LESS
45591: AND
45592: IFFALSE 45649
// for i in result do
45594: LD_ADDR_VAR 0 5
45598: PUSH
45599: LD_VAR 0 4
45603: PUSH
45604: FOR_IN
45605: IFFALSE 45647
// if GetTech ( i , side ) <> state then
45607: LD_VAR 0 5
45611: PPUSH
45612: LD_VAR 0 1
45616: PPUSH
45617: CALL_OW 321
45621: PUSH
45622: LD_VAR 0 3
45626: NONEQUAL
45627: IFFALSE 45645
// result := result diff i ;
45629: LD_ADDR_VAR 0 4
45633: PUSH
45634: LD_VAR 0 4
45638: PUSH
45639: LD_VAR 0 5
45643: DIFF
45644: ST_TO_ADDR
45645: GO 45604
45647: POP
45648: POP
// end ;
45649: LD_VAR 0 4
45653: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
45654: LD_INT 0
45656: PPUSH
45657: PPUSH
45658: PPUSH
// result := true ;
45659: LD_ADDR_VAR 0 3
45663: PUSH
45664: LD_INT 1
45666: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
45667: LD_ADDR_VAR 0 5
45671: PUSH
45672: LD_VAR 0 2
45676: PPUSH
45677: CALL_OW 480
45681: ST_TO_ADDR
// if not tmp then
45682: LD_VAR 0 5
45686: NOT
45687: IFFALSE 45691
// exit ;
45689: GO 45740
// for i in tmp do
45691: LD_ADDR_VAR 0 4
45695: PUSH
45696: LD_VAR 0 5
45700: PUSH
45701: FOR_IN
45702: IFFALSE 45738
// if GetTech ( i , side ) <> state_researched then
45704: LD_VAR 0 4
45708: PPUSH
45709: LD_VAR 0 1
45713: PPUSH
45714: CALL_OW 321
45718: PUSH
45719: LD_INT 2
45721: NONEQUAL
45722: IFFALSE 45736
// begin result := false ;
45724: LD_ADDR_VAR 0 3
45728: PUSH
45729: LD_INT 0
45731: ST_TO_ADDR
// exit ;
45732: POP
45733: POP
45734: GO 45740
// end ;
45736: GO 45701
45738: POP
45739: POP
// end ;
45740: LD_VAR 0 3
45744: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
45745: LD_INT 0
45747: PPUSH
45748: PPUSH
45749: PPUSH
45750: PPUSH
45751: PPUSH
45752: PPUSH
45753: PPUSH
45754: PPUSH
45755: PPUSH
45756: PPUSH
45757: PPUSH
45758: PPUSH
45759: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
45760: LD_VAR 0 1
45764: NOT
45765: PUSH
45766: LD_VAR 0 1
45770: PPUSH
45771: CALL_OW 257
45775: PUSH
45776: LD_INT 9
45778: NONEQUAL
45779: OR
45780: IFFALSE 45784
// exit ;
45782: GO 46357
// side := GetSide ( unit ) ;
45784: LD_ADDR_VAR 0 9
45788: PUSH
45789: LD_VAR 0 1
45793: PPUSH
45794: CALL_OW 255
45798: ST_TO_ADDR
// tech_space := tech_spacanom ;
45799: LD_ADDR_VAR 0 12
45803: PUSH
45804: LD_INT 29
45806: ST_TO_ADDR
// tech_time := tech_taurad ;
45807: LD_ADDR_VAR 0 13
45811: PUSH
45812: LD_INT 28
45814: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
45815: LD_ADDR_VAR 0 11
45819: PUSH
45820: LD_VAR 0 1
45824: PPUSH
45825: CALL_OW 310
45829: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
45830: LD_VAR 0 11
45834: PPUSH
45835: CALL_OW 247
45839: PUSH
45840: LD_INT 2
45842: EQUAL
45843: IFFALSE 45847
// exit ;
45845: GO 46357
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
45847: LD_ADDR_VAR 0 8
45851: PUSH
45852: LD_INT 81
45854: PUSH
45855: LD_VAR 0 9
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 3
45866: PUSH
45867: LD_INT 21
45869: PUSH
45870: LD_INT 3
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: PPUSH
45885: CALL_OW 69
45889: ST_TO_ADDR
// if not tmp then
45890: LD_VAR 0 8
45894: NOT
45895: IFFALSE 45899
// exit ;
45897: GO 46357
// if in_unit then
45899: LD_VAR 0 11
45903: IFFALSE 45927
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
45905: LD_ADDR_VAR 0 10
45909: PUSH
45910: LD_VAR 0 8
45914: PPUSH
45915: LD_VAR 0 11
45919: PPUSH
45920: CALL_OW 74
45924: ST_TO_ADDR
45925: GO 45947
// enemy := NearestUnitToUnit ( tmp , unit ) ;
45927: LD_ADDR_VAR 0 10
45931: PUSH
45932: LD_VAR 0 8
45936: PPUSH
45937: LD_VAR 0 1
45941: PPUSH
45942: CALL_OW 74
45946: ST_TO_ADDR
// if not enemy then
45947: LD_VAR 0 10
45951: NOT
45952: IFFALSE 45956
// exit ;
45954: GO 46357
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
45956: LD_VAR 0 11
45960: PUSH
45961: LD_VAR 0 11
45965: PPUSH
45966: LD_VAR 0 10
45970: PPUSH
45971: CALL_OW 296
45975: PUSH
45976: LD_INT 13
45978: GREATER
45979: AND
45980: PUSH
45981: LD_VAR 0 1
45985: PPUSH
45986: LD_VAR 0 10
45990: PPUSH
45991: CALL_OW 296
45995: PUSH
45996: LD_INT 12
45998: GREATER
45999: OR
46000: IFFALSE 46004
// exit ;
46002: GO 46357
// missile := [ 1 ] ;
46004: LD_ADDR_VAR 0 14
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: EMPTY
46013: LIST
46014: ST_TO_ADDR
// if Researched ( side , tech_space ) then
46015: LD_VAR 0 9
46019: PPUSH
46020: LD_VAR 0 12
46024: PPUSH
46025: CALL_OW 325
46029: IFFALSE 46058
// missile := Insert ( missile , missile + 1 , 2 ) ;
46031: LD_ADDR_VAR 0 14
46035: PUSH
46036: LD_VAR 0 14
46040: PPUSH
46041: LD_VAR 0 14
46045: PUSH
46046: LD_INT 1
46048: PLUS
46049: PPUSH
46050: LD_INT 2
46052: PPUSH
46053: CALL_OW 2
46057: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
46058: LD_VAR 0 9
46062: PPUSH
46063: LD_VAR 0 13
46067: PPUSH
46068: CALL_OW 325
46072: PUSH
46073: LD_VAR 0 10
46077: PPUSH
46078: CALL_OW 255
46082: PPUSH
46083: LD_VAR 0 13
46087: PPUSH
46088: CALL_OW 325
46092: NOT
46093: AND
46094: IFFALSE 46123
// missile := Insert ( missile , missile + 1 , 3 ) ;
46096: LD_ADDR_VAR 0 14
46100: PUSH
46101: LD_VAR 0 14
46105: PPUSH
46106: LD_VAR 0 14
46110: PUSH
46111: LD_INT 1
46113: PLUS
46114: PPUSH
46115: LD_INT 3
46117: PPUSH
46118: CALL_OW 2
46122: ST_TO_ADDR
// if missile < 2 then
46123: LD_VAR 0 14
46127: PUSH
46128: LD_INT 2
46130: LESS
46131: IFFALSE 46135
// exit ;
46133: GO 46357
// x := GetX ( enemy ) ;
46135: LD_ADDR_VAR 0 4
46139: PUSH
46140: LD_VAR 0 10
46144: PPUSH
46145: CALL_OW 250
46149: ST_TO_ADDR
// y := GetY ( enemy ) ;
46150: LD_ADDR_VAR 0 5
46154: PUSH
46155: LD_VAR 0 10
46159: PPUSH
46160: CALL_OW 251
46164: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
46165: LD_ADDR_VAR 0 6
46169: PUSH
46170: LD_VAR 0 4
46174: PUSH
46175: LD_INT 1
46177: NEG
46178: PPUSH
46179: LD_INT 1
46181: PPUSH
46182: CALL_OW 12
46186: PLUS
46187: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
46188: LD_ADDR_VAR 0 7
46192: PUSH
46193: LD_VAR 0 5
46197: PUSH
46198: LD_INT 1
46200: NEG
46201: PPUSH
46202: LD_INT 1
46204: PPUSH
46205: CALL_OW 12
46209: PLUS
46210: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
46211: LD_VAR 0 6
46215: PPUSH
46216: LD_VAR 0 7
46220: PPUSH
46221: CALL_OW 488
46225: NOT
46226: IFFALSE 46248
// begin _x := x ;
46228: LD_ADDR_VAR 0 6
46232: PUSH
46233: LD_VAR 0 4
46237: ST_TO_ADDR
// _y := y ;
46238: LD_ADDR_VAR 0 7
46242: PUSH
46243: LD_VAR 0 5
46247: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
46248: LD_ADDR_VAR 0 3
46252: PUSH
46253: LD_INT 1
46255: PPUSH
46256: LD_VAR 0 14
46260: PPUSH
46261: CALL_OW 12
46265: ST_TO_ADDR
// case i of 1 :
46266: LD_VAR 0 3
46270: PUSH
46271: LD_INT 1
46273: DOUBLE
46274: EQUAL
46275: IFTRUE 46279
46277: GO 46296
46279: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
46280: LD_VAR 0 1
46284: PPUSH
46285: LD_VAR 0 10
46289: PPUSH
46290: CALL_OW 115
46294: GO 46357
46296: LD_INT 2
46298: DOUBLE
46299: EQUAL
46300: IFTRUE 46304
46302: GO 46326
46304: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
46305: LD_VAR 0 1
46309: PPUSH
46310: LD_VAR 0 6
46314: PPUSH
46315: LD_VAR 0 7
46319: PPUSH
46320: CALL_OW 153
46324: GO 46357
46326: LD_INT 3
46328: DOUBLE
46329: EQUAL
46330: IFTRUE 46334
46332: GO 46356
46334: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
46335: LD_VAR 0 1
46339: PPUSH
46340: LD_VAR 0 6
46344: PPUSH
46345: LD_VAR 0 7
46349: PPUSH
46350: CALL_OW 154
46354: GO 46357
46356: POP
// end ;
46357: LD_VAR 0 2
46361: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
46362: LD_INT 0
46364: PPUSH
46365: PPUSH
46366: PPUSH
46367: PPUSH
46368: PPUSH
46369: PPUSH
// if not unit or not building then
46370: LD_VAR 0 1
46374: NOT
46375: PUSH
46376: LD_VAR 0 2
46380: NOT
46381: OR
46382: IFFALSE 46386
// exit ;
46384: GO 46544
// x := GetX ( building ) ;
46386: LD_ADDR_VAR 0 5
46390: PUSH
46391: LD_VAR 0 2
46395: PPUSH
46396: CALL_OW 250
46400: ST_TO_ADDR
// y := GetY ( building ) ;
46401: LD_ADDR_VAR 0 6
46405: PUSH
46406: LD_VAR 0 2
46410: PPUSH
46411: CALL_OW 251
46415: ST_TO_ADDR
// for i = 0 to 5 do
46416: LD_ADDR_VAR 0 4
46420: PUSH
46421: DOUBLE
46422: LD_INT 0
46424: DEC
46425: ST_TO_ADDR
46426: LD_INT 5
46428: PUSH
46429: FOR_TO
46430: IFFALSE 46542
// begin _x := ShiftX ( x , i , 3 ) ;
46432: LD_ADDR_VAR 0 7
46436: PUSH
46437: LD_VAR 0 5
46441: PPUSH
46442: LD_VAR 0 4
46446: PPUSH
46447: LD_INT 3
46449: PPUSH
46450: CALL_OW 272
46454: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
46455: LD_ADDR_VAR 0 8
46459: PUSH
46460: LD_VAR 0 6
46464: PPUSH
46465: LD_VAR 0 4
46469: PPUSH
46470: LD_INT 3
46472: PPUSH
46473: CALL_OW 273
46477: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
46478: LD_VAR 0 7
46482: PPUSH
46483: LD_VAR 0 8
46487: PPUSH
46488: CALL_OW 488
46492: NOT
46493: IFFALSE 46497
// continue ;
46495: GO 46429
// if HexInfo ( _x , _y ) = 0 then
46497: LD_VAR 0 7
46501: PPUSH
46502: LD_VAR 0 8
46506: PPUSH
46507: CALL_OW 428
46511: PUSH
46512: LD_INT 0
46514: EQUAL
46515: IFFALSE 46540
// begin ComMoveXY ( unit , _x , _y ) ;
46517: LD_VAR 0 1
46521: PPUSH
46522: LD_VAR 0 7
46526: PPUSH
46527: LD_VAR 0 8
46531: PPUSH
46532: CALL_OW 111
// exit ;
46536: POP
46537: POP
46538: GO 46544
// end ; end ;
46540: GO 46429
46542: POP
46543: POP
// end ;
46544: LD_VAR 0 3
46548: RET
// export function ScanBase ( side , base_area ) ; begin
46549: LD_INT 0
46551: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
46552: LD_ADDR_VAR 0 3
46556: PUSH
46557: LD_VAR 0 2
46561: PPUSH
46562: LD_INT 81
46564: PUSH
46565: LD_VAR 0 1
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PPUSH
46574: CALL_OW 70
46578: ST_TO_ADDR
// end ;
46579: LD_VAR 0 3
46583: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
46584: LD_INT 0
46586: PPUSH
46587: PPUSH
46588: PPUSH
46589: PPUSH
46590: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
46591: LD_VAR 0 1
46595: NOT
46596: PUSH
46597: LD_EXP 49
46601: PUSH
46602: LD_VAR 0 1
46606: ARRAY
46607: NOT
46608: OR
46609: PUSH
46610: LD_VAR 0 2
46614: NOT
46615: OR
46616: PUSH
46617: LD_VAR 0 3
46621: NOT
46622: OR
46623: IFFALSE 46627
// exit ;
46625: GO 47077
// side := mc_sides [ base ] ;
46627: LD_ADDR_VAR 0 6
46631: PUSH
46632: LD_EXP 75
46636: PUSH
46637: LD_VAR 0 1
46641: ARRAY
46642: ST_TO_ADDR
// if not side then
46643: LD_VAR 0 6
46647: NOT
46648: IFFALSE 46652
// exit ;
46650: GO 47077
// for i in solds do
46652: LD_ADDR_VAR 0 7
46656: PUSH
46657: LD_VAR 0 2
46661: PUSH
46662: FOR_IN
46663: IFFALSE 46724
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
46665: LD_VAR 0 7
46669: PPUSH
46670: CALL_OW 310
46674: PPUSH
46675: CALL_OW 266
46679: PUSH
46680: LD_INT 32
46682: PUSH
46683: LD_INT 31
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: IN
46690: IFFALSE 46710
// solds := solds diff i else
46692: LD_ADDR_VAR 0 2
46696: PUSH
46697: LD_VAR 0 2
46701: PUSH
46702: LD_VAR 0 7
46706: DIFF
46707: ST_TO_ADDR
46708: GO 46722
// SetTag ( i , 18 ) ;
46710: LD_VAR 0 7
46714: PPUSH
46715: LD_INT 18
46717: PPUSH
46718: CALL_OW 109
46722: GO 46662
46724: POP
46725: POP
// if not solds then
46726: LD_VAR 0 2
46730: NOT
46731: IFFALSE 46735
// exit ;
46733: GO 47077
// repeat wait ( 0 0$1 ) ;
46735: LD_INT 35
46737: PPUSH
46738: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
46742: LD_ADDR_VAR 0 5
46746: PUSH
46747: LD_VAR 0 6
46751: PPUSH
46752: LD_VAR 0 3
46756: PPUSH
46757: CALL 46549 0 2
46761: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
46762: LD_VAR 0 5
46766: NOT
46767: PUSH
46768: LD_VAR 0 5
46772: PUSH
46773: LD_INT 3
46775: GREATER
46776: OR
46777: PUSH
46778: LD_EXP 71
46782: PUSH
46783: LD_VAR 0 1
46787: ARRAY
46788: OR
46789: IFFALSE 46830
// begin for i in solds do
46791: LD_ADDR_VAR 0 7
46795: PUSH
46796: LD_VAR 0 2
46800: PUSH
46801: FOR_IN
46802: IFFALSE 46826
// if HasTask ( i ) then
46804: LD_VAR 0 7
46808: PPUSH
46809: CALL_OW 314
46813: IFFALSE 46824
// ComStop ( i ) ;
46815: LD_VAR 0 7
46819: PPUSH
46820: CALL_OW 141
46824: GO 46801
46826: POP
46827: POP
// break ;
46828: GO 47065
// end ; for i in solds do
46830: LD_ADDR_VAR 0 7
46834: PUSH
46835: LD_VAR 0 2
46839: PUSH
46840: FOR_IN
46841: IFFALSE 47057
// begin if IsInUnit ( i ) then
46843: LD_VAR 0 7
46847: PPUSH
46848: CALL_OW 310
46852: IFFALSE 46863
// ComExitBuilding ( i ) ;
46854: LD_VAR 0 7
46858: PPUSH
46859: CALL_OW 122
// if GetLives ( i ) > 333 then
46863: LD_VAR 0 7
46867: PPUSH
46868: CALL_OW 256
46872: PUSH
46873: LD_INT 333
46875: GREATER
46876: IFFALSE 46904
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
46878: LD_VAR 0 7
46882: PPUSH
46883: LD_VAR 0 5
46887: PPUSH
46888: LD_VAR 0 7
46892: PPUSH
46893: CALL_OW 74
46897: PPUSH
46898: CALL_OW 115
46902: GO 47055
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
46904: LD_ADDR_VAR 0 8
46908: PUSH
46909: LD_EXP 49
46913: PUSH
46914: LD_VAR 0 1
46918: ARRAY
46919: PPUSH
46920: LD_INT 2
46922: PUSH
46923: LD_INT 30
46925: PUSH
46926: LD_INT 0
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 30
46935: PUSH
46936: LD_INT 1
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 30
46945: PUSH
46946: LD_INT 6
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: PPUSH
46959: CALL_OW 72
46963: PPUSH
46964: LD_VAR 0 7
46968: PPUSH
46969: CALL_OW 74
46973: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
46974: LD_VAR 0 7
46978: PPUSH
46979: LD_VAR 0 8
46983: PPUSH
46984: CALL_OW 250
46988: PPUSH
46989: LD_INT 3
46991: PPUSH
46992: LD_INT 5
46994: PPUSH
46995: CALL_OW 272
46999: PPUSH
47000: LD_VAR 0 8
47004: PPUSH
47005: CALL_OW 251
47009: PPUSH
47010: LD_INT 3
47012: PPUSH
47013: LD_INT 5
47015: PPUSH
47016: CALL_OW 273
47020: PPUSH
47021: CALL_OW 111
// SetTag ( i , 0 ) ;
47025: LD_VAR 0 7
47029: PPUSH
47030: LD_INT 0
47032: PPUSH
47033: CALL_OW 109
// solds := solds diff i ;
47037: LD_ADDR_VAR 0 2
47041: PUSH
47042: LD_VAR 0 2
47046: PUSH
47047: LD_VAR 0 7
47051: DIFF
47052: ST_TO_ADDR
// continue ;
47053: GO 46840
// end ; end ;
47055: GO 46840
47057: POP
47058: POP
// until solds ;
47059: LD_VAR 0 2
47063: IFFALSE 46735
// MC_Reset ( base , 18 ) ;
47065: LD_VAR 0 1
47069: PPUSH
47070: LD_INT 18
47072: PPUSH
47073: CALL 19797 0 2
// end ;
47077: LD_VAR 0 4
47081: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
47082: LD_INT 0
47084: PPUSH
47085: PPUSH
47086: PPUSH
47087: PPUSH
47088: PPUSH
47089: PPUSH
47090: PPUSH
47091: PPUSH
47092: PPUSH
47093: PPUSH
47094: PPUSH
47095: PPUSH
47096: PPUSH
47097: PPUSH
47098: PPUSH
47099: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
47100: LD_ADDR_VAR 0 12
47104: PUSH
47105: LD_EXP 49
47109: PUSH
47110: LD_VAR 0 1
47114: ARRAY
47115: PPUSH
47116: LD_INT 25
47118: PUSH
47119: LD_INT 3
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PPUSH
47126: CALL_OW 72
47130: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47131: LD_ADDR_VAR 0 8
47135: PUSH
47136: LD_EXP 49
47140: PUSH
47141: LD_VAR 0 1
47145: ARRAY
47146: PPUSH
47147: LD_INT 2
47149: PUSH
47150: LD_INT 25
47152: PUSH
47153: LD_INT 1
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: PUSH
47160: LD_INT 25
47162: PUSH
47163: LD_INT 5
47165: PUSH
47166: EMPTY
47167: LIST
47168: LIST
47169: PUSH
47170: LD_INT 25
47172: PUSH
47173: LD_INT 8
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: LD_INT 25
47182: PUSH
47183: LD_INT 9
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: EMPTY
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: PPUSH
47197: CALL_OW 72
47201: ST_TO_ADDR
// if not defenders and not solds then
47202: LD_VAR 0 2
47206: NOT
47207: PUSH
47208: LD_VAR 0 8
47212: NOT
47213: AND
47214: IFFALSE 47218
// exit ;
47216: GO 48584
// depot_under_attack := false ;
47218: LD_ADDR_VAR 0 16
47222: PUSH
47223: LD_INT 0
47225: ST_TO_ADDR
// sold_defenders := [ ] ;
47226: LD_ADDR_VAR 0 17
47230: PUSH
47231: EMPTY
47232: ST_TO_ADDR
// if mechs then
47233: LD_VAR 0 12
47237: IFFALSE 47366
// for i in defenders do
47239: LD_ADDR_VAR 0 5
47243: PUSH
47244: LD_VAR 0 2
47248: PUSH
47249: FOR_IN
47250: IFFALSE 47364
// begin SetTag ( i , 20 ) ;
47252: LD_VAR 0 5
47256: PPUSH
47257: LD_INT 20
47259: PPUSH
47260: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
47264: LD_VAR 0 5
47268: PPUSH
47269: CALL_OW 263
47273: PUSH
47274: LD_INT 1
47276: EQUAL
47277: PUSH
47278: LD_VAR 0 5
47282: PPUSH
47283: CALL_OW 311
47287: NOT
47288: AND
47289: PUSH
47290: LD_VAR 0 12
47294: AND
47295: IFFALSE 47362
// begin un := mechs [ 1 ] ;
47297: LD_ADDR_VAR 0 10
47301: PUSH
47302: LD_VAR 0 12
47306: PUSH
47307: LD_INT 1
47309: ARRAY
47310: ST_TO_ADDR
// ComExitBuilding ( un ) ;
47311: LD_VAR 0 10
47315: PPUSH
47316: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
47320: LD_VAR 0 10
47324: PPUSH
47325: LD_VAR 0 5
47329: PPUSH
47330: CALL_OW 180
// SetTag ( un , 19 ) ;
47334: LD_VAR 0 10
47338: PPUSH
47339: LD_INT 19
47341: PPUSH
47342: CALL_OW 109
// mechs := mechs diff un ;
47346: LD_ADDR_VAR 0 12
47350: PUSH
47351: LD_VAR 0 12
47355: PUSH
47356: LD_VAR 0 10
47360: DIFF
47361: ST_TO_ADDR
// end ; end ;
47362: GO 47249
47364: POP
47365: POP
// if solds then
47366: LD_VAR 0 8
47370: IFFALSE 47429
// for i in solds do
47372: LD_ADDR_VAR 0 5
47376: PUSH
47377: LD_VAR 0 8
47381: PUSH
47382: FOR_IN
47383: IFFALSE 47427
// if not GetTag ( i ) then
47385: LD_VAR 0 5
47389: PPUSH
47390: CALL_OW 110
47394: NOT
47395: IFFALSE 47425
// begin defenders := defenders union i ;
47397: LD_ADDR_VAR 0 2
47401: PUSH
47402: LD_VAR 0 2
47406: PUSH
47407: LD_VAR 0 5
47411: UNION
47412: ST_TO_ADDR
// SetTag ( i , 18 ) ;
47413: LD_VAR 0 5
47417: PPUSH
47418: LD_INT 18
47420: PPUSH
47421: CALL_OW 109
// end ;
47425: GO 47382
47427: POP
47428: POP
// repeat wait ( 0 0$1 ) ;
47429: LD_INT 35
47431: PPUSH
47432: CALL_OW 67
// enemy := mc_scan [ base ] ;
47436: LD_ADDR_VAR 0 3
47440: PUSH
47441: LD_EXP 72
47445: PUSH
47446: LD_VAR 0 1
47450: ARRAY
47451: ST_TO_ADDR
// for i in defenders do
47452: LD_ADDR_VAR 0 5
47456: PUSH
47457: LD_VAR 0 2
47461: PUSH
47462: FOR_IN
47463: IFFALSE 48148
// begin e := NearestUnitToUnit ( enemy , i ) ;
47465: LD_ADDR_VAR 0 13
47469: PUSH
47470: LD_VAR 0 3
47474: PPUSH
47475: LD_VAR 0 5
47479: PPUSH
47480: CALL_OW 74
47484: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
47485: LD_ADDR_VAR 0 16
47489: PUSH
47490: LD_EXP 49
47494: PUSH
47495: LD_VAR 0 1
47499: ARRAY
47500: PPUSH
47501: LD_INT 2
47503: PUSH
47504: LD_INT 30
47506: PUSH
47507: LD_INT 0
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: PUSH
47514: LD_INT 30
47516: PUSH
47517: LD_INT 1
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: LIST
47528: PPUSH
47529: CALL_OW 72
47533: NOT
47534: PUSH
47535: LD_EXP 49
47539: PUSH
47540: LD_VAR 0 1
47544: ARRAY
47545: PPUSH
47546: LD_INT 2
47548: PUSH
47549: LD_INT 30
47551: PUSH
47552: LD_INT 0
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: PUSH
47559: LD_INT 30
47561: PUSH
47562: LD_INT 1
47564: PUSH
47565: EMPTY
47566: LIST
47567: LIST
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: LIST
47573: PPUSH
47574: CALL_OW 72
47578: PPUSH
47579: CALL_OW 256
47583: PUSH
47584: LD_INT 600
47586: LESS
47587: OR
47588: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
47589: LD_VAR 0 5
47593: PPUSH
47594: CALL_OW 247
47598: PUSH
47599: LD_INT 2
47601: DOUBLE
47602: EQUAL
47603: IFTRUE 47607
47605: GO 47854
47607: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
47608: LD_VAR 0 5
47612: PPUSH
47613: CALL_OW 256
47617: PUSH
47618: LD_INT 650
47620: GREATER
47621: PUSH
47622: LD_VAR 0 5
47626: PPUSH
47627: LD_VAR 0 13
47631: PPUSH
47632: CALL_OW 296
47636: PUSH
47637: LD_INT 40
47639: LESS
47640: AND
47641: IFFALSE 47659
// ComAttackUnit ( i , e ) else
47643: LD_VAR 0 5
47647: PPUSH
47648: LD_VAR 0 13
47652: PPUSH
47653: CALL_OW 115
47657: GO 47737
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
47659: LD_VAR 0 5
47663: PPUSH
47664: LD_VAR 0 13
47668: PPUSH
47669: CALL_OW 296
47673: PUSH
47674: LD_INT 30
47676: GREATEREQUAL
47677: PUSH
47678: LD_VAR 0 5
47682: PPUSH
47683: CALL_OW 256
47687: PUSH
47688: LD_INT 650
47690: LESSEQUAL
47691: OR
47692: PUSH
47693: LD_VAR 0 5
47697: PPUSH
47698: LD_EXP 73
47702: PUSH
47703: LD_VAR 0 1
47707: ARRAY
47708: PPUSH
47709: CALL_OW 308
47713: NOT
47714: AND
47715: IFFALSE 47737
// ComMoveToArea ( i , mc_parking [ base ] ) ;
47717: LD_VAR 0 5
47721: PPUSH
47722: LD_EXP 73
47726: PUSH
47727: LD_VAR 0 1
47731: ARRAY
47732: PPUSH
47733: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
47737: LD_VAR 0 5
47741: PPUSH
47742: CALL_OW 256
47746: PUSH
47747: LD_INT 998
47749: LESS
47750: PUSH
47751: LD_VAR 0 5
47755: PPUSH
47756: CALL_OW 263
47760: PUSH
47761: LD_INT 1
47763: EQUAL
47764: AND
47765: PUSH
47766: LD_VAR 0 5
47770: PPUSH
47771: CALL_OW 311
47775: AND
47776: PUSH
47777: LD_VAR 0 5
47781: PPUSH
47782: LD_EXP 73
47786: PUSH
47787: LD_VAR 0 1
47791: ARRAY
47792: PPUSH
47793: CALL_OW 308
47797: AND
47798: IFFALSE 47852
// begin mech := IsDrivenBy ( i ) ;
47800: LD_ADDR_VAR 0 9
47804: PUSH
47805: LD_VAR 0 5
47809: PPUSH
47810: CALL_OW 311
47814: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
47815: LD_VAR 0 9
47819: PPUSH
47820: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
47824: LD_VAR 0 9
47828: PPUSH
47829: LD_VAR 0 5
47833: PPUSH
47834: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
47838: LD_VAR 0 9
47842: PPUSH
47843: LD_VAR 0 5
47847: PPUSH
47848: CALL_OW 180
// end ; end ; unit_human :
47852: GO 48119
47854: LD_INT 1
47856: DOUBLE
47857: EQUAL
47858: IFTRUE 47862
47860: GO 48118
47862: POP
// begin b := IsInUnit ( i ) ;
47863: LD_ADDR_VAR 0 18
47867: PUSH
47868: LD_VAR 0 5
47872: PPUSH
47873: CALL_OW 310
47877: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
47878: LD_ADDR_VAR 0 19
47882: PUSH
47883: LD_VAR 0 18
47887: NOT
47888: PUSH
47889: LD_VAR 0 18
47893: PPUSH
47894: CALL_OW 266
47898: PUSH
47899: LD_INT 32
47901: PUSH
47902: LD_INT 31
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: IN
47909: OR
47910: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
47911: LD_VAR 0 16
47915: PUSH
47916: LD_VAR 0 2
47920: PPUSH
47921: LD_INT 21
47923: PUSH
47924: LD_INT 2
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PPUSH
47931: CALL_OW 72
47935: PUSH
47936: LD_INT 1
47938: LESSEQUAL
47939: OR
47940: PUSH
47941: LD_VAR 0 19
47945: AND
47946: PUSH
47947: LD_VAR 0 5
47951: PUSH
47952: LD_VAR 0 17
47956: IN
47957: NOT
47958: AND
47959: IFFALSE 48052
// begin if b then
47961: LD_VAR 0 18
47965: IFFALSE 48014
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
47967: LD_VAR 0 18
47971: PPUSH
47972: LD_VAR 0 3
47976: PPUSH
47977: LD_VAR 0 18
47981: PPUSH
47982: CALL_OW 74
47986: PPUSH
47987: CALL_OW 296
47991: PUSH
47992: LD_INT 10
47994: LESS
47995: PUSH
47996: LD_VAR 0 18
48000: PPUSH
48001: CALL_OW 461
48005: PUSH
48006: LD_INT 7
48008: NONEQUAL
48009: AND
48010: IFFALSE 48014
// continue ;
48012: GO 47462
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
48014: LD_ADDR_VAR 0 17
48018: PUSH
48019: LD_VAR 0 17
48023: PPUSH
48024: LD_VAR 0 17
48028: PUSH
48029: LD_INT 1
48031: PLUS
48032: PPUSH
48033: LD_VAR 0 5
48037: PPUSH
48038: CALL_OW 1
48042: ST_TO_ADDR
// ComExitBuilding ( i ) ;
48043: LD_VAR 0 5
48047: PPUSH
48048: CALL_OW 122
// end ; if sold_defenders then
48052: LD_VAR 0 17
48056: IFFALSE 48116
// if i in sold_defenders then
48058: LD_VAR 0 5
48062: PUSH
48063: LD_VAR 0 17
48067: IN
48068: IFFALSE 48116
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
48070: LD_VAR 0 5
48074: PPUSH
48075: CALL_OW 314
48079: NOT
48080: PUSH
48081: LD_VAR 0 5
48085: PPUSH
48086: LD_VAR 0 13
48090: PPUSH
48091: CALL_OW 296
48095: PUSH
48096: LD_INT 30
48098: LESS
48099: AND
48100: IFFALSE 48116
// ComAttackUnit ( i , e ) ;
48102: LD_VAR 0 5
48106: PPUSH
48107: LD_VAR 0 13
48111: PPUSH
48112: CALL_OW 115
// end ; end ; end ;
48116: GO 48119
48118: POP
// if IsDead ( i ) then
48119: LD_VAR 0 5
48123: PPUSH
48124: CALL_OW 301
48128: IFFALSE 48146
// defenders := defenders diff i ;
48130: LD_ADDR_VAR 0 2
48134: PUSH
48135: LD_VAR 0 2
48139: PUSH
48140: LD_VAR 0 5
48144: DIFF
48145: ST_TO_ADDR
// end ;
48146: GO 47462
48148: POP
48149: POP
// until not enemy or not defenders ;
48150: LD_VAR 0 3
48154: NOT
48155: PUSH
48156: LD_VAR 0 2
48160: NOT
48161: OR
48162: IFFALSE 47429
// MC_Reset ( base , 18 ) ;
48164: LD_VAR 0 1
48168: PPUSH
48169: LD_INT 18
48171: PPUSH
48172: CALL 19797 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
48176: LD_ADDR_VAR 0 2
48180: PUSH
48181: LD_VAR 0 2
48185: PUSH
48186: LD_VAR 0 2
48190: PPUSH
48191: LD_INT 2
48193: PUSH
48194: LD_INT 25
48196: PUSH
48197: LD_INT 1
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: PUSH
48204: LD_INT 25
48206: PUSH
48207: LD_INT 5
48209: PUSH
48210: EMPTY
48211: LIST
48212: LIST
48213: PUSH
48214: LD_INT 25
48216: PUSH
48217: LD_INT 8
48219: PUSH
48220: EMPTY
48221: LIST
48222: LIST
48223: PUSH
48224: LD_INT 25
48226: PUSH
48227: LD_INT 9
48229: PUSH
48230: EMPTY
48231: LIST
48232: LIST
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: PPUSH
48241: CALL_OW 72
48245: DIFF
48246: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
48247: LD_VAR 0 3
48251: NOT
48252: PUSH
48253: LD_VAR 0 2
48257: PPUSH
48258: LD_INT 21
48260: PUSH
48261: LD_INT 2
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PPUSH
48268: CALL_OW 72
48272: AND
48273: IFFALSE 48535
// begin tmp := FilterByTag ( defenders , 19 ) ;
48275: LD_ADDR_VAR 0 11
48279: PUSH
48280: LD_VAR 0 2
48284: PPUSH
48285: LD_INT 19
48287: PPUSH
48288: CALL 84882 0 2
48292: ST_TO_ADDR
// if tmp then
48293: LD_VAR 0 11
48297: IFFALSE 48367
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
48299: LD_ADDR_VAR 0 11
48303: PUSH
48304: LD_VAR 0 11
48308: PPUSH
48309: LD_INT 25
48311: PUSH
48312: LD_INT 3
48314: PUSH
48315: EMPTY
48316: LIST
48317: LIST
48318: PPUSH
48319: CALL_OW 72
48323: ST_TO_ADDR
// if tmp then
48324: LD_VAR 0 11
48328: IFFALSE 48367
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
48330: LD_ADDR_EXP 61
48334: PUSH
48335: LD_EXP 61
48339: PPUSH
48340: LD_VAR 0 1
48344: PPUSH
48345: LD_EXP 61
48349: PUSH
48350: LD_VAR 0 1
48354: ARRAY
48355: PUSH
48356: LD_VAR 0 11
48360: UNION
48361: PPUSH
48362: CALL_OW 1
48366: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
48367: LD_VAR 0 1
48371: PPUSH
48372: LD_INT 19
48374: PPUSH
48375: CALL 19797 0 2
// repeat wait ( 0 0$1 ) ;
48379: LD_INT 35
48381: PPUSH
48382: CALL_OW 67
// for i in defenders do
48386: LD_ADDR_VAR 0 5
48390: PUSH
48391: LD_VAR 0 2
48395: PUSH
48396: FOR_IN
48397: IFFALSE 48486
// begin if not IsInArea ( i , mc_parking [ base ] ) then
48399: LD_VAR 0 5
48403: PPUSH
48404: LD_EXP 73
48408: PUSH
48409: LD_VAR 0 1
48413: ARRAY
48414: PPUSH
48415: CALL_OW 308
48419: NOT
48420: IFFALSE 48444
// ComMoveToArea ( i , mc_parking [ base ] ) else
48422: LD_VAR 0 5
48426: PPUSH
48427: LD_EXP 73
48431: PUSH
48432: LD_VAR 0 1
48436: ARRAY
48437: PPUSH
48438: CALL_OW 113
48442: GO 48484
// if GetControl ( i ) = control_manual then
48444: LD_VAR 0 5
48448: PPUSH
48449: CALL_OW 263
48453: PUSH
48454: LD_INT 1
48456: EQUAL
48457: IFFALSE 48484
// if IsDrivenBy ( i ) then
48459: LD_VAR 0 5
48463: PPUSH
48464: CALL_OW 311
48468: IFFALSE 48484
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
48470: LD_VAR 0 5
48474: PPUSH
48475: CALL_OW 311
48479: PPUSH
48480: CALL_OW 121
// end ;
48484: GO 48396
48486: POP
48487: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
48488: LD_VAR 0 2
48492: PPUSH
48493: LD_INT 95
48495: PUSH
48496: LD_EXP 73
48500: PUSH
48501: LD_VAR 0 1
48505: ARRAY
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PPUSH
48511: CALL_OW 72
48515: PUSH
48516: LD_VAR 0 2
48520: EQUAL
48521: PUSH
48522: LD_EXP 72
48526: PUSH
48527: LD_VAR 0 1
48531: ARRAY
48532: OR
48533: IFFALSE 48379
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
48535: LD_ADDR_EXP 71
48539: PUSH
48540: LD_EXP 71
48544: PPUSH
48545: LD_VAR 0 1
48549: PPUSH
48550: LD_EXP 71
48554: PUSH
48555: LD_VAR 0 1
48559: ARRAY
48560: PUSH
48561: LD_VAR 0 2
48565: UNION
48566: PPUSH
48567: CALL_OW 1
48571: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
48572: LD_VAR 0 1
48576: PPUSH
48577: LD_INT 20
48579: PPUSH
48580: CALL 19797 0 2
// end ;
48584: LD_VAR 0 4
48588: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
48589: LD_INT 0
48591: PPUSH
48592: PPUSH
48593: PPUSH
48594: PPUSH
// result := false ;
48595: LD_ADDR_VAR 0 2
48599: PUSH
48600: LD_INT 0
48602: ST_TO_ADDR
// side := GetSide ( unit ) ;
48603: LD_ADDR_VAR 0 3
48607: PUSH
48608: LD_VAR 0 1
48612: PPUSH
48613: CALL_OW 255
48617: ST_TO_ADDR
// nat := GetNation ( unit ) ;
48618: LD_ADDR_VAR 0 4
48622: PUSH
48623: LD_VAR 0 1
48627: PPUSH
48628: CALL_OW 248
48632: ST_TO_ADDR
// case nat of 1 :
48633: LD_VAR 0 4
48637: PUSH
48638: LD_INT 1
48640: DOUBLE
48641: EQUAL
48642: IFTRUE 48646
48644: GO 48657
48646: POP
// tech := tech_lassight ; 2 :
48647: LD_ADDR_VAR 0 5
48651: PUSH
48652: LD_INT 12
48654: ST_TO_ADDR
48655: GO 48696
48657: LD_INT 2
48659: DOUBLE
48660: EQUAL
48661: IFTRUE 48665
48663: GO 48676
48665: POP
// tech := tech_mortar ; 3 :
48666: LD_ADDR_VAR 0 5
48670: PUSH
48671: LD_INT 41
48673: ST_TO_ADDR
48674: GO 48696
48676: LD_INT 3
48678: DOUBLE
48679: EQUAL
48680: IFTRUE 48684
48682: GO 48695
48684: POP
// tech := tech_bazooka ; end ;
48685: LD_ADDR_VAR 0 5
48689: PUSH
48690: LD_INT 44
48692: ST_TO_ADDR
48693: GO 48696
48695: POP
// if Researched ( side , tech ) then
48696: LD_VAR 0 3
48700: PPUSH
48701: LD_VAR 0 5
48705: PPUSH
48706: CALL_OW 325
48710: IFFALSE 48737
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
48712: LD_ADDR_VAR 0 2
48716: PUSH
48717: LD_INT 5
48719: PUSH
48720: LD_INT 8
48722: PUSH
48723: LD_INT 9
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: LIST
48730: PUSH
48731: LD_VAR 0 4
48735: ARRAY
48736: ST_TO_ADDR
// end ;
48737: LD_VAR 0 2
48741: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
48742: LD_INT 0
48744: PPUSH
48745: PPUSH
48746: PPUSH
// if not mines then
48747: LD_VAR 0 2
48751: NOT
48752: IFFALSE 48756
// exit ;
48754: GO 48900
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48756: LD_ADDR_VAR 0 5
48760: PUSH
48761: LD_INT 81
48763: PUSH
48764: LD_VAR 0 1
48768: PUSH
48769: EMPTY
48770: LIST
48771: LIST
48772: PUSH
48773: LD_INT 3
48775: PUSH
48776: LD_INT 21
48778: PUSH
48779: LD_INT 3
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: PUSH
48790: EMPTY
48791: LIST
48792: LIST
48793: PPUSH
48794: CALL_OW 69
48798: ST_TO_ADDR
// for i in mines do
48799: LD_ADDR_VAR 0 4
48803: PUSH
48804: LD_VAR 0 2
48808: PUSH
48809: FOR_IN
48810: IFFALSE 48898
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
48812: LD_VAR 0 4
48816: PUSH
48817: LD_INT 1
48819: ARRAY
48820: PPUSH
48821: LD_VAR 0 4
48825: PUSH
48826: LD_INT 2
48828: ARRAY
48829: PPUSH
48830: CALL_OW 458
48834: NOT
48835: IFFALSE 48839
// continue ;
48837: GO 48809
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
48839: LD_VAR 0 4
48843: PUSH
48844: LD_INT 1
48846: ARRAY
48847: PPUSH
48848: LD_VAR 0 4
48852: PUSH
48853: LD_INT 2
48855: ARRAY
48856: PPUSH
48857: CALL_OW 428
48861: PUSH
48862: LD_VAR 0 5
48866: IN
48867: IFFALSE 48896
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
48869: LD_VAR 0 4
48873: PUSH
48874: LD_INT 1
48876: ARRAY
48877: PPUSH
48878: LD_VAR 0 4
48882: PUSH
48883: LD_INT 2
48885: ARRAY
48886: PPUSH
48887: LD_VAR 0 1
48891: PPUSH
48892: CALL_OW 456
// end ;
48896: GO 48809
48898: POP
48899: POP
// end ;
48900: LD_VAR 0 3
48904: RET
// export function Count ( array ) ; var i ; begin
48905: LD_INT 0
48907: PPUSH
48908: PPUSH
// result := 0 ;
48909: LD_ADDR_VAR 0 2
48913: PUSH
48914: LD_INT 0
48916: ST_TO_ADDR
// for i in array do
48917: LD_ADDR_VAR 0 3
48921: PUSH
48922: LD_VAR 0 1
48926: PUSH
48927: FOR_IN
48928: IFFALSE 48952
// if i then
48930: LD_VAR 0 3
48934: IFFALSE 48950
// result := result + 1 ;
48936: LD_ADDR_VAR 0 2
48940: PUSH
48941: LD_VAR 0 2
48945: PUSH
48946: LD_INT 1
48948: PLUS
48949: ST_TO_ADDR
48950: GO 48927
48952: POP
48953: POP
// end ;
48954: LD_VAR 0 2
48958: RET
// export function IsEmpty ( building ) ; begin
48959: LD_INT 0
48961: PPUSH
// if not building then
48962: LD_VAR 0 1
48966: NOT
48967: IFFALSE 48971
// exit ;
48969: GO 49014
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
48971: LD_ADDR_VAR 0 2
48975: PUSH
48976: LD_VAR 0 1
48980: PUSH
48981: LD_INT 22
48983: PUSH
48984: LD_VAR 0 1
48988: PPUSH
48989: CALL_OW 255
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: PUSH
48998: LD_INT 58
49000: PUSH
49001: EMPTY
49002: LIST
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PPUSH
49008: CALL_OW 69
49012: IN
49013: ST_TO_ADDR
// end ;
49014: LD_VAR 0 2
49018: RET
// export function IsNotFull ( building ) ; begin
49019: LD_INT 0
49021: PPUSH
// if not building then
49022: LD_VAR 0 1
49026: NOT
49027: IFFALSE 49031
// exit ;
49029: GO 49050
// result := UnitsInside ( building ) < 6 ;
49031: LD_ADDR_VAR 0 2
49035: PUSH
49036: LD_VAR 0 1
49040: PPUSH
49041: CALL_OW 313
49045: PUSH
49046: LD_INT 6
49048: LESS
49049: ST_TO_ADDR
// end ;
49050: LD_VAR 0 2
49054: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
49055: LD_INT 0
49057: PPUSH
49058: PPUSH
49059: PPUSH
49060: PPUSH
// tmp := [ ] ;
49061: LD_ADDR_VAR 0 3
49065: PUSH
49066: EMPTY
49067: ST_TO_ADDR
// list := [ ] ;
49068: LD_ADDR_VAR 0 5
49072: PUSH
49073: EMPTY
49074: ST_TO_ADDR
// for i = 16 to 25 do
49075: LD_ADDR_VAR 0 4
49079: PUSH
49080: DOUBLE
49081: LD_INT 16
49083: DEC
49084: ST_TO_ADDR
49085: LD_INT 25
49087: PUSH
49088: FOR_TO
49089: IFFALSE 49162
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
49091: LD_ADDR_VAR 0 3
49095: PUSH
49096: LD_VAR 0 3
49100: PUSH
49101: LD_INT 22
49103: PUSH
49104: LD_VAR 0 1
49108: PPUSH
49109: CALL_OW 255
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PUSH
49118: LD_INT 91
49120: PUSH
49121: LD_VAR 0 1
49125: PUSH
49126: LD_INT 6
49128: PUSH
49129: EMPTY
49130: LIST
49131: LIST
49132: LIST
49133: PUSH
49134: LD_INT 30
49136: PUSH
49137: LD_VAR 0 4
49141: PUSH
49142: EMPTY
49143: LIST
49144: LIST
49145: PUSH
49146: EMPTY
49147: LIST
49148: LIST
49149: LIST
49150: PUSH
49151: EMPTY
49152: LIST
49153: PPUSH
49154: CALL_OW 69
49158: ADD
49159: ST_TO_ADDR
49160: GO 49088
49162: POP
49163: POP
// for i = 1 to tmp do
49164: LD_ADDR_VAR 0 4
49168: PUSH
49169: DOUBLE
49170: LD_INT 1
49172: DEC
49173: ST_TO_ADDR
49174: LD_VAR 0 3
49178: PUSH
49179: FOR_TO
49180: IFFALSE 49268
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
49182: LD_ADDR_VAR 0 5
49186: PUSH
49187: LD_VAR 0 5
49191: PUSH
49192: LD_VAR 0 3
49196: PUSH
49197: LD_VAR 0 4
49201: ARRAY
49202: PPUSH
49203: CALL_OW 266
49207: PUSH
49208: LD_VAR 0 3
49212: PUSH
49213: LD_VAR 0 4
49217: ARRAY
49218: PPUSH
49219: CALL_OW 250
49223: PUSH
49224: LD_VAR 0 3
49228: PUSH
49229: LD_VAR 0 4
49233: ARRAY
49234: PPUSH
49235: CALL_OW 251
49239: PUSH
49240: LD_VAR 0 3
49244: PUSH
49245: LD_VAR 0 4
49249: ARRAY
49250: PPUSH
49251: CALL_OW 254
49255: PUSH
49256: EMPTY
49257: LIST
49258: LIST
49259: LIST
49260: LIST
49261: PUSH
49262: EMPTY
49263: LIST
49264: ADD
49265: ST_TO_ADDR
49266: GO 49179
49268: POP
49269: POP
// result := list ;
49270: LD_ADDR_VAR 0 2
49274: PUSH
49275: LD_VAR 0 5
49279: ST_TO_ADDR
// end ;
49280: LD_VAR 0 2
49284: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
49285: LD_INT 0
49287: PPUSH
49288: PPUSH
49289: PPUSH
49290: PPUSH
49291: PPUSH
49292: PPUSH
49293: PPUSH
// if not factory then
49294: LD_VAR 0 1
49298: NOT
49299: IFFALSE 49303
// exit ;
49301: GO 49828
// if control = control_apeman then
49303: LD_VAR 0 4
49307: PUSH
49308: LD_INT 5
49310: EQUAL
49311: IFFALSE 49420
// begin tmp := UnitsInside ( factory ) ;
49313: LD_ADDR_VAR 0 8
49317: PUSH
49318: LD_VAR 0 1
49322: PPUSH
49323: CALL_OW 313
49327: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
49328: LD_VAR 0 8
49332: PPUSH
49333: LD_INT 25
49335: PUSH
49336: LD_INT 12
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PPUSH
49343: CALL_OW 72
49347: NOT
49348: IFFALSE 49358
// control := control_manual ;
49350: LD_ADDR_VAR 0 4
49354: PUSH
49355: LD_INT 1
49357: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
49358: LD_ADDR_VAR 0 8
49362: PUSH
49363: LD_VAR 0 1
49367: PPUSH
49368: CALL 49055 0 1
49372: ST_TO_ADDR
// if tmp then
49373: LD_VAR 0 8
49377: IFFALSE 49420
// begin for i in tmp do
49379: LD_ADDR_VAR 0 7
49383: PUSH
49384: LD_VAR 0 8
49388: PUSH
49389: FOR_IN
49390: IFFALSE 49418
// if i [ 1 ] = b_ext_radar then
49392: LD_VAR 0 7
49396: PUSH
49397: LD_INT 1
49399: ARRAY
49400: PUSH
49401: LD_INT 20
49403: EQUAL
49404: IFFALSE 49416
// begin control := control_remote ;
49406: LD_ADDR_VAR 0 4
49410: PUSH
49411: LD_INT 2
49413: ST_TO_ADDR
// break ;
49414: GO 49418
// end ;
49416: GO 49389
49418: POP
49419: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
49420: LD_VAR 0 1
49424: PPUSH
49425: LD_VAR 0 2
49429: PPUSH
49430: LD_VAR 0 3
49434: PPUSH
49435: LD_VAR 0 4
49439: PPUSH
49440: LD_VAR 0 5
49444: PPUSH
49445: CALL_OW 448
49449: IFFALSE 49484
// begin result := [ chassis , engine , control , weapon ] ;
49451: LD_ADDR_VAR 0 6
49455: PUSH
49456: LD_VAR 0 2
49460: PUSH
49461: LD_VAR 0 3
49465: PUSH
49466: LD_VAR 0 4
49470: PUSH
49471: LD_VAR 0 5
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: ST_TO_ADDR
// exit ;
49482: GO 49828
// end ; _chassis := AvailableChassisList ( factory ) ;
49484: LD_ADDR_VAR 0 9
49488: PUSH
49489: LD_VAR 0 1
49493: PPUSH
49494: CALL_OW 475
49498: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
49499: LD_ADDR_VAR 0 11
49503: PUSH
49504: LD_VAR 0 1
49508: PPUSH
49509: CALL_OW 476
49513: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
49514: LD_ADDR_VAR 0 12
49518: PUSH
49519: LD_VAR 0 1
49523: PPUSH
49524: CALL_OW 477
49528: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
49529: LD_ADDR_VAR 0 10
49533: PUSH
49534: LD_VAR 0 1
49538: PPUSH
49539: CALL_OW 478
49543: ST_TO_ADDR
// if not chassis in _chassis then
49544: LD_VAR 0 2
49548: PUSH
49549: LD_VAR 0 9
49553: IN
49554: NOT
49555: IFFALSE 49581
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
49557: LD_ADDR_VAR 0 2
49561: PUSH
49562: LD_VAR 0 9
49566: PUSH
49567: LD_INT 1
49569: PPUSH
49570: LD_VAR 0 9
49574: PPUSH
49575: CALL_OW 12
49579: ARRAY
49580: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
49581: LD_VAR 0 2
49585: PPUSH
49586: LD_VAR 0 3
49590: PPUSH
49591: CALL 49833 0 2
49595: NOT
49596: IFFALSE 49655
// repeat engine := _engine [ 1 ] ;
49598: LD_ADDR_VAR 0 3
49602: PUSH
49603: LD_VAR 0 11
49607: PUSH
49608: LD_INT 1
49610: ARRAY
49611: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
49612: LD_ADDR_VAR 0 11
49616: PUSH
49617: LD_VAR 0 11
49621: PPUSH
49622: LD_INT 1
49624: PPUSH
49625: CALL_OW 3
49629: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
49630: LD_VAR 0 2
49634: PPUSH
49635: LD_VAR 0 3
49639: PPUSH
49640: CALL 49833 0 2
49644: PUSH
49645: LD_VAR 0 11
49649: PUSH
49650: EMPTY
49651: EQUAL
49652: OR
49653: IFFALSE 49598
// if not control in _control then
49655: LD_VAR 0 4
49659: PUSH
49660: LD_VAR 0 12
49664: IN
49665: NOT
49666: IFFALSE 49692
// control := _control [ rand ( 1 , _control ) ] ;
49668: LD_ADDR_VAR 0 4
49672: PUSH
49673: LD_VAR 0 12
49677: PUSH
49678: LD_INT 1
49680: PPUSH
49681: LD_VAR 0 12
49685: PPUSH
49686: CALL_OW 12
49690: ARRAY
49691: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
49692: LD_VAR 0 2
49696: PPUSH
49697: LD_VAR 0 5
49701: PPUSH
49702: CALL 50053 0 2
49706: NOT
49707: IFFALSE 49766
// repeat weapon := _weapon [ 1 ] ;
49709: LD_ADDR_VAR 0 5
49713: PUSH
49714: LD_VAR 0 10
49718: PUSH
49719: LD_INT 1
49721: ARRAY
49722: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
49723: LD_ADDR_VAR 0 10
49727: PUSH
49728: LD_VAR 0 10
49732: PPUSH
49733: LD_INT 1
49735: PPUSH
49736: CALL_OW 3
49740: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
49741: LD_VAR 0 2
49745: PPUSH
49746: LD_VAR 0 5
49750: PPUSH
49751: CALL 50053 0 2
49755: PUSH
49756: LD_VAR 0 10
49760: PUSH
49761: EMPTY
49762: EQUAL
49763: OR
49764: IFFALSE 49709
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
49766: LD_VAR 0 1
49770: PPUSH
49771: LD_VAR 0 2
49775: PPUSH
49776: LD_VAR 0 3
49780: PPUSH
49781: LD_VAR 0 4
49785: PPUSH
49786: LD_VAR 0 5
49790: PPUSH
49791: CALL_OW 448
49795: IFFALSE 49828
// result := [ chassis , engine , control , weapon ] ;
49797: LD_ADDR_VAR 0 6
49801: PUSH
49802: LD_VAR 0 2
49806: PUSH
49807: LD_VAR 0 3
49811: PUSH
49812: LD_VAR 0 4
49816: PUSH
49817: LD_VAR 0 5
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: ST_TO_ADDR
// end ;
49828: LD_VAR 0 6
49832: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
49833: LD_INT 0
49835: PPUSH
// if not chassis or not engine then
49836: LD_VAR 0 1
49840: NOT
49841: PUSH
49842: LD_VAR 0 2
49846: NOT
49847: OR
49848: IFFALSE 49852
// exit ;
49850: GO 50048
// case engine of engine_solar :
49852: LD_VAR 0 2
49856: PUSH
49857: LD_INT 2
49859: DOUBLE
49860: EQUAL
49861: IFTRUE 49865
49863: GO 49903
49865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
49866: LD_ADDR_VAR 0 3
49870: PUSH
49871: LD_INT 11
49873: PUSH
49874: LD_INT 12
49876: PUSH
49877: LD_INT 13
49879: PUSH
49880: LD_INT 14
49882: PUSH
49883: LD_INT 1
49885: PUSH
49886: LD_INT 2
49888: PUSH
49889: LD_INT 3
49891: PUSH
49892: EMPTY
49893: LIST
49894: LIST
49895: LIST
49896: LIST
49897: LIST
49898: LIST
49899: LIST
49900: ST_TO_ADDR
49901: GO 50032
49903: LD_INT 1
49905: DOUBLE
49906: EQUAL
49907: IFTRUE 49911
49909: GO 49973
49911: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
49912: LD_ADDR_VAR 0 3
49916: PUSH
49917: LD_INT 11
49919: PUSH
49920: LD_INT 12
49922: PUSH
49923: LD_INT 13
49925: PUSH
49926: LD_INT 14
49928: PUSH
49929: LD_INT 1
49931: PUSH
49932: LD_INT 2
49934: PUSH
49935: LD_INT 3
49937: PUSH
49938: LD_INT 4
49940: PUSH
49941: LD_INT 5
49943: PUSH
49944: LD_INT 21
49946: PUSH
49947: LD_INT 23
49949: PUSH
49950: LD_INT 22
49952: PUSH
49953: LD_INT 24
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: LIST
49960: LIST
49961: LIST
49962: LIST
49963: LIST
49964: LIST
49965: LIST
49966: LIST
49967: LIST
49968: LIST
49969: LIST
49970: ST_TO_ADDR
49971: GO 50032
49973: LD_INT 3
49975: DOUBLE
49976: EQUAL
49977: IFTRUE 49981
49979: GO 50031
49981: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
49982: LD_ADDR_VAR 0 3
49986: PUSH
49987: LD_INT 13
49989: PUSH
49990: LD_INT 14
49992: PUSH
49993: LD_INT 2
49995: PUSH
49996: LD_INT 3
49998: PUSH
49999: LD_INT 4
50001: PUSH
50002: LD_INT 5
50004: PUSH
50005: LD_INT 21
50007: PUSH
50008: LD_INT 22
50010: PUSH
50011: LD_INT 23
50013: PUSH
50014: LD_INT 24
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: ST_TO_ADDR
50029: GO 50032
50031: POP
// result := ( chassis in result ) ;
50032: LD_ADDR_VAR 0 3
50036: PUSH
50037: LD_VAR 0 1
50041: PUSH
50042: LD_VAR 0 3
50046: IN
50047: ST_TO_ADDR
// end ;
50048: LD_VAR 0 3
50052: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
50053: LD_INT 0
50055: PPUSH
// if not chassis or not weapon then
50056: LD_VAR 0 1
50060: NOT
50061: PUSH
50062: LD_VAR 0 2
50066: NOT
50067: OR
50068: IFFALSE 50072
// exit ;
50070: GO 51098
// case weapon of us_machine_gun :
50072: LD_VAR 0 2
50076: PUSH
50077: LD_INT 2
50079: DOUBLE
50080: EQUAL
50081: IFTRUE 50085
50083: GO 50115
50085: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
50086: LD_ADDR_VAR 0 3
50090: PUSH
50091: LD_INT 1
50093: PUSH
50094: LD_INT 2
50096: PUSH
50097: LD_INT 3
50099: PUSH
50100: LD_INT 4
50102: PUSH
50103: LD_INT 5
50105: PUSH
50106: EMPTY
50107: LIST
50108: LIST
50109: LIST
50110: LIST
50111: LIST
50112: ST_TO_ADDR
50113: GO 51082
50115: LD_INT 3
50117: DOUBLE
50118: EQUAL
50119: IFTRUE 50123
50121: GO 50153
50123: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
50124: LD_ADDR_VAR 0 3
50128: PUSH
50129: LD_INT 1
50131: PUSH
50132: LD_INT 2
50134: PUSH
50135: LD_INT 3
50137: PUSH
50138: LD_INT 4
50140: PUSH
50141: LD_INT 5
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: LIST
50148: LIST
50149: LIST
50150: ST_TO_ADDR
50151: GO 51082
50153: LD_INT 11
50155: DOUBLE
50156: EQUAL
50157: IFTRUE 50161
50159: GO 50191
50161: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
50162: LD_ADDR_VAR 0 3
50166: PUSH
50167: LD_INT 1
50169: PUSH
50170: LD_INT 2
50172: PUSH
50173: LD_INT 3
50175: PUSH
50176: LD_INT 4
50178: PUSH
50179: LD_INT 5
50181: PUSH
50182: EMPTY
50183: LIST
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: ST_TO_ADDR
50189: GO 51082
50191: LD_INT 4
50193: DOUBLE
50194: EQUAL
50195: IFTRUE 50199
50197: GO 50225
50199: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
50200: LD_ADDR_VAR 0 3
50204: PUSH
50205: LD_INT 2
50207: PUSH
50208: LD_INT 3
50210: PUSH
50211: LD_INT 4
50213: PUSH
50214: LD_INT 5
50216: PUSH
50217: EMPTY
50218: LIST
50219: LIST
50220: LIST
50221: LIST
50222: ST_TO_ADDR
50223: GO 51082
50225: LD_INT 5
50227: DOUBLE
50228: EQUAL
50229: IFTRUE 50233
50231: GO 50259
50233: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
50234: LD_ADDR_VAR 0 3
50238: PUSH
50239: LD_INT 2
50241: PUSH
50242: LD_INT 3
50244: PUSH
50245: LD_INT 4
50247: PUSH
50248: LD_INT 5
50250: PUSH
50251: EMPTY
50252: LIST
50253: LIST
50254: LIST
50255: LIST
50256: ST_TO_ADDR
50257: GO 51082
50259: LD_INT 9
50261: DOUBLE
50262: EQUAL
50263: IFTRUE 50267
50265: GO 50293
50267: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
50268: LD_ADDR_VAR 0 3
50272: PUSH
50273: LD_INT 2
50275: PUSH
50276: LD_INT 3
50278: PUSH
50279: LD_INT 4
50281: PUSH
50282: LD_INT 5
50284: PUSH
50285: EMPTY
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: ST_TO_ADDR
50291: GO 51082
50293: LD_INT 7
50295: DOUBLE
50296: EQUAL
50297: IFTRUE 50301
50299: GO 50327
50301: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
50302: LD_ADDR_VAR 0 3
50306: PUSH
50307: LD_INT 2
50309: PUSH
50310: LD_INT 3
50312: PUSH
50313: LD_INT 4
50315: PUSH
50316: LD_INT 5
50318: PUSH
50319: EMPTY
50320: LIST
50321: LIST
50322: LIST
50323: LIST
50324: ST_TO_ADDR
50325: GO 51082
50327: LD_INT 12
50329: DOUBLE
50330: EQUAL
50331: IFTRUE 50335
50333: GO 50361
50335: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
50336: LD_ADDR_VAR 0 3
50340: PUSH
50341: LD_INT 2
50343: PUSH
50344: LD_INT 3
50346: PUSH
50347: LD_INT 4
50349: PUSH
50350: LD_INT 5
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: ST_TO_ADDR
50359: GO 51082
50361: LD_INT 13
50363: DOUBLE
50364: EQUAL
50365: IFTRUE 50369
50367: GO 50395
50369: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
50370: LD_ADDR_VAR 0 3
50374: PUSH
50375: LD_INT 2
50377: PUSH
50378: LD_INT 3
50380: PUSH
50381: LD_INT 4
50383: PUSH
50384: LD_INT 5
50386: PUSH
50387: EMPTY
50388: LIST
50389: LIST
50390: LIST
50391: LIST
50392: ST_TO_ADDR
50393: GO 51082
50395: LD_INT 14
50397: DOUBLE
50398: EQUAL
50399: IFTRUE 50403
50401: GO 50421
50403: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
50404: LD_ADDR_VAR 0 3
50408: PUSH
50409: LD_INT 4
50411: PUSH
50412: LD_INT 5
50414: PUSH
50415: EMPTY
50416: LIST
50417: LIST
50418: ST_TO_ADDR
50419: GO 51082
50421: LD_INT 6
50423: DOUBLE
50424: EQUAL
50425: IFTRUE 50429
50427: GO 50447
50429: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
50430: LD_ADDR_VAR 0 3
50434: PUSH
50435: LD_INT 4
50437: PUSH
50438: LD_INT 5
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: ST_TO_ADDR
50445: GO 51082
50447: LD_INT 10
50449: DOUBLE
50450: EQUAL
50451: IFTRUE 50455
50453: GO 50473
50455: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
50456: LD_ADDR_VAR 0 3
50460: PUSH
50461: LD_INT 4
50463: PUSH
50464: LD_INT 5
50466: PUSH
50467: EMPTY
50468: LIST
50469: LIST
50470: ST_TO_ADDR
50471: GO 51082
50473: LD_INT 22
50475: DOUBLE
50476: EQUAL
50477: IFTRUE 50481
50479: GO 50507
50481: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
50482: LD_ADDR_VAR 0 3
50486: PUSH
50487: LD_INT 11
50489: PUSH
50490: LD_INT 12
50492: PUSH
50493: LD_INT 13
50495: PUSH
50496: LD_INT 14
50498: PUSH
50499: EMPTY
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: ST_TO_ADDR
50505: GO 51082
50507: LD_INT 23
50509: DOUBLE
50510: EQUAL
50511: IFTRUE 50515
50513: GO 50541
50515: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
50516: LD_ADDR_VAR 0 3
50520: PUSH
50521: LD_INT 11
50523: PUSH
50524: LD_INT 12
50526: PUSH
50527: LD_INT 13
50529: PUSH
50530: LD_INT 14
50532: PUSH
50533: EMPTY
50534: LIST
50535: LIST
50536: LIST
50537: LIST
50538: ST_TO_ADDR
50539: GO 51082
50541: LD_INT 24
50543: DOUBLE
50544: EQUAL
50545: IFTRUE 50549
50547: GO 50575
50549: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
50550: LD_ADDR_VAR 0 3
50554: PUSH
50555: LD_INT 11
50557: PUSH
50558: LD_INT 12
50560: PUSH
50561: LD_INT 13
50563: PUSH
50564: LD_INT 14
50566: PUSH
50567: EMPTY
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: ST_TO_ADDR
50573: GO 51082
50575: LD_INT 30
50577: DOUBLE
50578: EQUAL
50579: IFTRUE 50583
50581: GO 50609
50583: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
50584: LD_ADDR_VAR 0 3
50588: PUSH
50589: LD_INT 11
50591: PUSH
50592: LD_INT 12
50594: PUSH
50595: LD_INT 13
50597: PUSH
50598: LD_INT 14
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: LIST
50605: LIST
50606: ST_TO_ADDR
50607: GO 51082
50609: LD_INT 25
50611: DOUBLE
50612: EQUAL
50613: IFTRUE 50617
50615: GO 50635
50617: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
50618: LD_ADDR_VAR 0 3
50622: PUSH
50623: LD_INT 13
50625: PUSH
50626: LD_INT 14
50628: PUSH
50629: EMPTY
50630: LIST
50631: LIST
50632: ST_TO_ADDR
50633: GO 51082
50635: LD_INT 27
50637: DOUBLE
50638: EQUAL
50639: IFTRUE 50643
50641: GO 50661
50643: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
50644: LD_ADDR_VAR 0 3
50648: PUSH
50649: LD_INT 13
50651: PUSH
50652: LD_INT 14
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: ST_TO_ADDR
50659: GO 51082
50661: LD_INT 28
50663: DOUBLE
50664: EQUAL
50665: IFTRUE 50669
50667: GO 50687
50669: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
50670: LD_ADDR_VAR 0 3
50674: PUSH
50675: LD_INT 13
50677: PUSH
50678: LD_INT 14
50680: PUSH
50681: EMPTY
50682: LIST
50683: LIST
50684: ST_TO_ADDR
50685: GO 51082
50687: LD_INT 29
50689: DOUBLE
50690: EQUAL
50691: IFTRUE 50695
50693: GO 50713
50695: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
50696: LD_ADDR_VAR 0 3
50700: PUSH
50701: LD_INT 13
50703: PUSH
50704: LD_INT 14
50706: PUSH
50707: EMPTY
50708: LIST
50709: LIST
50710: ST_TO_ADDR
50711: GO 51082
50713: LD_INT 31
50715: DOUBLE
50716: EQUAL
50717: IFTRUE 50721
50719: GO 50739
50721: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
50722: LD_ADDR_VAR 0 3
50726: PUSH
50727: LD_INT 13
50729: PUSH
50730: LD_INT 14
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: ST_TO_ADDR
50737: GO 51082
50739: LD_INT 26
50741: DOUBLE
50742: EQUAL
50743: IFTRUE 50747
50745: GO 50765
50747: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
50748: LD_ADDR_VAR 0 3
50752: PUSH
50753: LD_INT 13
50755: PUSH
50756: LD_INT 14
50758: PUSH
50759: EMPTY
50760: LIST
50761: LIST
50762: ST_TO_ADDR
50763: GO 51082
50765: LD_INT 42
50767: DOUBLE
50768: EQUAL
50769: IFTRUE 50773
50771: GO 50799
50773: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
50774: LD_ADDR_VAR 0 3
50778: PUSH
50779: LD_INT 21
50781: PUSH
50782: LD_INT 22
50784: PUSH
50785: LD_INT 23
50787: PUSH
50788: LD_INT 24
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: LIST
50795: LIST
50796: ST_TO_ADDR
50797: GO 51082
50799: LD_INT 43
50801: DOUBLE
50802: EQUAL
50803: IFTRUE 50807
50805: GO 50833
50807: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
50808: LD_ADDR_VAR 0 3
50812: PUSH
50813: LD_INT 21
50815: PUSH
50816: LD_INT 22
50818: PUSH
50819: LD_INT 23
50821: PUSH
50822: LD_INT 24
50824: PUSH
50825: EMPTY
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: ST_TO_ADDR
50831: GO 51082
50833: LD_INT 44
50835: DOUBLE
50836: EQUAL
50837: IFTRUE 50841
50839: GO 50867
50841: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
50842: LD_ADDR_VAR 0 3
50846: PUSH
50847: LD_INT 21
50849: PUSH
50850: LD_INT 22
50852: PUSH
50853: LD_INT 23
50855: PUSH
50856: LD_INT 24
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: LIST
50863: LIST
50864: ST_TO_ADDR
50865: GO 51082
50867: LD_INT 45
50869: DOUBLE
50870: EQUAL
50871: IFTRUE 50875
50873: GO 50901
50875: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
50876: LD_ADDR_VAR 0 3
50880: PUSH
50881: LD_INT 21
50883: PUSH
50884: LD_INT 22
50886: PUSH
50887: LD_INT 23
50889: PUSH
50890: LD_INT 24
50892: PUSH
50893: EMPTY
50894: LIST
50895: LIST
50896: LIST
50897: LIST
50898: ST_TO_ADDR
50899: GO 51082
50901: LD_INT 49
50903: DOUBLE
50904: EQUAL
50905: IFTRUE 50909
50907: GO 50935
50909: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
50910: LD_ADDR_VAR 0 3
50914: PUSH
50915: LD_INT 21
50917: PUSH
50918: LD_INT 22
50920: PUSH
50921: LD_INT 23
50923: PUSH
50924: LD_INT 24
50926: PUSH
50927: EMPTY
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: ST_TO_ADDR
50933: GO 51082
50935: LD_INT 51
50937: DOUBLE
50938: EQUAL
50939: IFTRUE 50943
50941: GO 50969
50943: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
50944: LD_ADDR_VAR 0 3
50948: PUSH
50949: LD_INT 21
50951: PUSH
50952: LD_INT 22
50954: PUSH
50955: LD_INT 23
50957: PUSH
50958: LD_INT 24
50960: PUSH
50961: EMPTY
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: ST_TO_ADDR
50967: GO 51082
50969: LD_INT 52
50971: DOUBLE
50972: EQUAL
50973: IFTRUE 50977
50975: GO 51003
50977: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
50978: LD_ADDR_VAR 0 3
50982: PUSH
50983: LD_INT 21
50985: PUSH
50986: LD_INT 22
50988: PUSH
50989: LD_INT 23
50991: PUSH
50992: LD_INT 24
50994: PUSH
50995: EMPTY
50996: LIST
50997: LIST
50998: LIST
50999: LIST
51000: ST_TO_ADDR
51001: GO 51082
51003: LD_INT 53
51005: DOUBLE
51006: EQUAL
51007: IFTRUE 51011
51009: GO 51029
51011: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
51012: LD_ADDR_VAR 0 3
51016: PUSH
51017: LD_INT 23
51019: PUSH
51020: LD_INT 24
51022: PUSH
51023: EMPTY
51024: LIST
51025: LIST
51026: ST_TO_ADDR
51027: GO 51082
51029: LD_INT 46
51031: DOUBLE
51032: EQUAL
51033: IFTRUE 51037
51035: GO 51055
51037: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
51038: LD_ADDR_VAR 0 3
51042: PUSH
51043: LD_INT 23
51045: PUSH
51046: LD_INT 24
51048: PUSH
51049: EMPTY
51050: LIST
51051: LIST
51052: ST_TO_ADDR
51053: GO 51082
51055: LD_INT 47
51057: DOUBLE
51058: EQUAL
51059: IFTRUE 51063
51061: GO 51081
51063: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51064: LD_ADDR_VAR 0 3
51068: PUSH
51069: LD_INT 23
51071: PUSH
51072: LD_INT 24
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: ST_TO_ADDR
51079: GO 51082
51081: POP
// result := ( chassis in result ) ;
51082: LD_ADDR_VAR 0 3
51086: PUSH
51087: LD_VAR 0 1
51091: PUSH
51092: LD_VAR 0 3
51096: IN
51097: ST_TO_ADDR
// end ;
51098: LD_VAR 0 3
51102: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
51103: LD_INT 0
51105: PPUSH
51106: PPUSH
51107: PPUSH
51108: PPUSH
51109: PPUSH
51110: PPUSH
51111: PPUSH
// result := array ;
51112: LD_ADDR_VAR 0 5
51116: PUSH
51117: LD_VAR 0 1
51121: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
51122: LD_VAR 0 1
51126: NOT
51127: PUSH
51128: LD_VAR 0 2
51132: NOT
51133: OR
51134: PUSH
51135: LD_VAR 0 3
51139: NOT
51140: OR
51141: PUSH
51142: LD_VAR 0 2
51146: PUSH
51147: LD_VAR 0 1
51151: GREATER
51152: OR
51153: PUSH
51154: LD_VAR 0 3
51158: PUSH
51159: LD_VAR 0 1
51163: GREATER
51164: OR
51165: IFFALSE 51169
// exit ;
51167: GO 51465
// if direction then
51169: LD_VAR 0 4
51173: IFFALSE 51237
// begin d := 1 ;
51175: LD_ADDR_VAR 0 9
51179: PUSH
51180: LD_INT 1
51182: ST_TO_ADDR
// if i_from > i_to then
51183: LD_VAR 0 2
51187: PUSH
51188: LD_VAR 0 3
51192: GREATER
51193: IFFALSE 51219
// length := ( array - i_from ) + i_to else
51195: LD_ADDR_VAR 0 11
51199: PUSH
51200: LD_VAR 0 1
51204: PUSH
51205: LD_VAR 0 2
51209: MINUS
51210: PUSH
51211: LD_VAR 0 3
51215: PLUS
51216: ST_TO_ADDR
51217: GO 51235
// length := i_to - i_from ;
51219: LD_ADDR_VAR 0 11
51223: PUSH
51224: LD_VAR 0 3
51228: PUSH
51229: LD_VAR 0 2
51233: MINUS
51234: ST_TO_ADDR
// end else
51235: GO 51298
// begin d := - 1 ;
51237: LD_ADDR_VAR 0 9
51241: PUSH
51242: LD_INT 1
51244: NEG
51245: ST_TO_ADDR
// if i_from > i_to then
51246: LD_VAR 0 2
51250: PUSH
51251: LD_VAR 0 3
51255: GREATER
51256: IFFALSE 51276
// length := i_from - i_to else
51258: LD_ADDR_VAR 0 11
51262: PUSH
51263: LD_VAR 0 2
51267: PUSH
51268: LD_VAR 0 3
51272: MINUS
51273: ST_TO_ADDR
51274: GO 51298
// length := ( array - i_to ) + i_from ;
51276: LD_ADDR_VAR 0 11
51280: PUSH
51281: LD_VAR 0 1
51285: PUSH
51286: LD_VAR 0 3
51290: MINUS
51291: PUSH
51292: LD_VAR 0 2
51296: PLUS
51297: ST_TO_ADDR
// end ; if not length then
51298: LD_VAR 0 11
51302: NOT
51303: IFFALSE 51307
// exit ;
51305: GO 51465
// tmp := array ;
51307: LD_ADDR_VAR 0 10
51311: PUSH
51312: LD_VAR 0 1
51316: ST_TO_ADDR
// for i = 1 to length do
51317: LD_ADDR_VAR 0 6
51321: PUSH
51322: DOUBLE
51323: LD_INT 1
51325: DEC
51326: ST_TO_ADDR
51327: LD_VAR 0 11
51331: PUSH
51332: FOR_TO
51333: IFFALSE 51453
// begin for j = 1 to array do
51335: LD_ADDR_VAR 0 7
51339: PUSH
51340: DOUBLE
51341: LD_INT 1
51343: DEC
51344: ST_TO_ADDR
51345: LD_VAR 0 1
51349: PUSH
51350: FOR_TO
51351: IFFALSE 51439
// begin k := j + d ;
51353: LD_ADDR_VAR 0 8
51357: PUSH
51358: LD_VAR 0 7
51362: PUSH
51363: LD_VAR 0 9
51367: PLUS
51368: ST_TO_ADDR
// if k > array then
51369: LD_VAR 0 8
51373: PUSH
51374: LD_VAR 0 1
51378: GREATER
51379: IFFALSE 51389
// k := 1 ;
51381: LD_ADDR_VAR 0 8
51385: PUSH
51386: LD_INT 1
51388: ST_TO_ADDR
// if not k then
51389: LD_VAR 0 8
51393: NOT
51394: IFFALSE 51406
// k := array ;
51396: LD_ADDR_VAR 0 8
51400: PUSH
51401: LD_VAR 0 1
51405: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
51406: LD_ADDR_VAR 0 10
51410: PUSH
51411: LD_VAR 0 10
51415: PPUSH
51416: LD_VAR 0 8
51420: PPUSH
51421: LD_VAR 0 1
51425: PUSH
51426: LD_VAR 0 7
51430: ARRAY
51431: PPUSH
51432: CALL_OW 1
51436: ST_TO_ADDR
// end ;
51437: GO 51350
51439: POP
51440: POP
// array := tmp ;
51441: LD_ADDR_VAR 0 1
51445: PUSH
51446: LD_VAR 0 10
51450: ST_TO_ADDR
// end ;
51451: GO 51332
51453: POP
51454: POP
// result := array ;
51455: LD_ADDR_VAR 0 5
51459: PUSH
51460: LD_VAR 0 1
51464: ST_TO_ADDR
// end ;
51465: LD_VAR 0 5
51469: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
51470: LD_INT 0
51472: PPUSH
51473: PPUSH
// result := 0 ;
51474: LD_ADDR_VAR 0 3
51478: PUSH
51479: LD_INT 0
51481: ST_TO_ADDR
// if not array or not value in array then
51482: LD_VAR 0 1
51486: NOT
51487: PUSH
51488: LD_VAR 0 2
51492: PUSH
51493: LD_VAR 0 1
51497: IN
51498: NOT
51499: OR
51500: IFFALSE 51504
// exit ;
51502: GO 51558
// for i = 1 to array do
51504: LD_ADDR_VAR 0 4
51508: PUSH
51509: DOUBLE
51510: LD_INT 1
51512: DEC
51513: ST_TO_ADDR
51514: LD_VAR 0 1
51518: PUSH
51519: FOR_TO
51520: IFFALSE 51556
// if value = array [ i ] then
51522: LD_VAR 0 2
51526: PUSH
51527: LD_VAR 0 1
51531: PUSH
51532: LD_VAR 0 4
51536: ARRAY
51537: EQUAL
51538: IFFALSE 51554
// begin result := i ;
51540: LD_ADDR_VAR 0 3
51544: PUSH
51545: LD_VAR 0 4
51549: ST_TO_ADDR
// exit ;
51550: POP
51551: POP
51552: GO 51558
// end ;
51554: GO 51519
51556: POP
51557: POP
// end ;
51558: LD_VAR 0 3
51562: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
51563: LD_INT 0
51565: PPUSH
// vc_chassis := chassis ;
51566: LD_ADDR_OWVAR 37
51570: PUSH
51571: LD_VAR 0 1
51575: ST_TO_ADDR
// vc_engine := engine ;
51576: LD_ADDR_OWVAR 39
51580: PUSH
51581: LD_VAR 0 2
51585: ST_TO_ADDR
// vc_control := control ;
51586: LD_ADDR_OWVAR 38
51590: PUSH
51591: LD_VAR 0 3
51595: ST_TO_ADDR
// vc_weapon := weapon ;
51596: LD_ADDR_OWVAR 40
51600: PUSH
51601: LD_VAR 0 4
51605: ST_TO_ADDR
// vc_fuel_battery := fuel ;
51606: LD_ADDR_OWVAR 41
51610: PUSH
51611: LD_VAR 0 5
51615: ST_TO_ADDR
// end ;
51616: LD_VAR 0 6
51620: RET
// export function WantPlant ( unit ) ; var task ; begin
51621: LD_INT 0
51623: PPUSH
51624: PPUSH
// result := false ;
51625: LD_ADDR_VAR 0 2
51629: PUSH
51630: LD_INT 0
51632: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
51633: LD_ADDR_VAR 0 3
51637: PUSH
51638: LD_VAR 0 1
51642: PPUSH
51643: CALL_OW 437
51647: ST_TO_ADDR
// if task then
51648: LD_VAR 0 3
51652: IFFALSE 51680
// if task [ 1 ] [ 1 ] = p then
51654: LD_VAR 0 3
51658: PUSH
51659: LD_INT 1
51661: ARRAY
51662: PUSH
51663: LD_INT 1
51665: ARRAY
51666: PUSH
51667: LD_STRING p
51669: EQUAL
51670: IFFALSE 51680
// result := true ;
51672: LD_ADDR_VAR 0 2
51676: PUSH
51677: LD_INT 1
51679: ST_TO_ADDR
// end ;
51680: LD_VAR 0 2
51684: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
51685: LD_INT 0
51687: PPUSH
51688: PPUSH
51689: PPUSH
51690: PPUSH
// if pos < 1 then
51691: LD_VAR 0 2
51695: PUSH
51696: LD_INT 1
51698: LESS
51699: IFFALSE 51703
// exit ;
51701: GO 52006
// if pos = 1 then
51703: LD_VAR 0 2
51707: PUSH
51708: LD_INT 1
51710: EQUAL
51711: IFFALSE 51744
// result := Replace ( arr , pos [ 1 ] , value ) else
51713: LD_ADDR_VAR 0 4
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: LD_VAR 0 2
51727: PUSH
51728: LD_INT 1
51730: ARRAY
51731: PPUSH
51732: LD_VAR 0 3
51736: PPUSH
51737: CALL_OW 1
51741: ST_TO_ADDR
51742: GO 52006
// begin tmp := arr ;
51744: LD_ADDR_VAR 0 6
51748: PUSH
51749: LD_VAR 0 1
51753: ST_TO_ADDR
// s_arr := [ tmp ] ;
51754: LD_ADDR_VAR 0 7
51758: PUSH
51759: LD_VAR 0 6
51763: PUSH
51764: EMPTY
51765: LIST
51766: ST_TO_ADDR
// for i = 1 to pos - 1 do
51767: LD_ADDR_VAR 0 5
51771: PUSH
51772: DOUBLE
51773: LD_INT 1
51775: DEC
51776: ST_TO_ADDR
51777: LD_VAR 0 2
51781: PUSH
51782: LD_INT 1
51784: MINUS
51785: PUSH
51786: FOR_TO
51787: IFFALSE 51832
// begin tmp := tmp [ pos [ i ] ] ;
51789: LD_ADDR_VAR 0 6
51793: PUSH
51794: LD_VAR 0 6
51798: PUSH
51799: LD_VAR 0 2
51803: PUSH
51804: LD_VAR 0 5
51808: ARRAY
51809: ARRAY
51810: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
51811: LD_ADDR_VAR 0 7
51815: PUSH
51816: LD_VAR 0 7
51820: PUSH
51821: LD_VAR 0 6
51825: PUSH
51826: EMPTY
51827: LIST
51828: ADD
51829: ST_TO_ADDR
// end ;
51830: GO 51786
51832: POP
51833: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
51834: LD_ADDR_VAR 0 6
51838: PUSH
51839: LD_VAR 0 6
51843: PPUSH
51844: LD_VAR 0 2
51848: PUSH
51849: LD_VAR 0 2
51853: ARRAY
51854: PPUSH
51855: LD_VAR 0 3
51859: PPUSH
51860: CALL_OW 1
51864: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
51865: LD_ADDR_VAR 0 7
51869: PUSH
51870: LD_VAR 0 7
51874: PPUSH
51875: LD_VAR 0 7
51879: PPUSH
51880: LD_VAR 0 6
51884: PPUSH
51885: CALL_OW 1
51889: ST_TO_ADDR
// for i = s_arr downto 2 do
51890: LD_ADDR_VAR 0 5
51894: PUSH
51895: DOUBLE
51896: LD_VAR 0 7
51900: INC
51901: ST_TO_ADDR
51902: LD_INT 2
51904: PUSH
51905: FOR_DOWNTO
51906: IFFALSE 51990
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
51908: LD_ADDR_VAR 0 6
51912: PUSH
51913: LD_VAR 0 7
51917: PUSH
51918: LD_VAR 0 5
51922: PUSH
51923: LD_INT 1
51925: MINUS
51926: ARRAY
51927: PPUSH
51928: LD_VAR 0 2
51932: PUSH
51933: LD_VAR 0 5
51937: PUSH
51938: LD_INT 1
51940: MINUS
51941: ARRAY
51942: PPUSH
51943: LD_VAR 0 7
51947: PUSH
51948: LD_VAR 0 5
51952: ARRAY
51953: PPUSH
51954: CALL_OW 1
51958: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
51959: LD_ADDR_VAR 0 7
51963: PUSH
51964: LD_VAR 0 7
51968: PPUSH
51969: LD_VAR 0 5
51973: PUSH
51974: LD_INT 1
51976: MINUS
51977: PPUSH
51978: LD_VAR 0 6
51982: PPUSH
51983: CALL_OW 1
51987: ST_TO_ADDR
// end ;
51988: GO 51905
51990: POP
51991: POP
// result := s_arr [ 1 ] ;
51992: LD_ADDR_VAR 0 4
51996: PUSH
51997: LD_VAR 0 7
52001: PUSH
52002: LD_INT 1
52004: ARRAY
52005: ST_TO_ADDR
// end ; end ;
52006: LD_VAR 0 4
52010: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
52011: LD_INT 0
52013: PPUSH
52014: PPUSH
// if not list then
52015: LD_VAR 0 1
52019: NOT
52020: IFFALSE 52024
// exit ;
52022: GO 52115
// i := list [ pos1 ] ;
52024: LD_ADDR_VAR 0 5
52028: PUSH
52029: LD_VAR 0 1
52033: PUSH
52034: LD_VAR 0 2
52038: ARRAY
52039: ST_TO_ADDR
// if not i then
52040: LD_VAR 0 5
52044: NOT
52045: IFFALSE 52049
// exit ;
52047: GO 52115
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
52049: LD_ADDR_VAR 0 1
52053: PUSH
52054: LD_VAR 0 1
52058: PPUSH
52059: LD_VAR 0 2
52063: PPUSH
52064: LD_VAR 0 1
52068: PUSH
52069: LD_VAR 0 3
52073: ARRAY
52074: PPUSH
52075: CALL_OW 1
52079: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
52080: LD_ADDR_VAR 0 1
52084: PUSH
52085: LD_VAR 0 1
52089: PPUSH
52090: LD_VAR 0 3
52094: PPUSH
52095: LD_VAR 0 5
52099: PPUSH
52100: CALL_OW 1
52104: ST_TO_ADDR
// result := list ;
52105: LD_ADDR_VAR 0 4
52109: PUSH
52110: LD_VAR 0 1
52114: ST_TO_ADDR
// end ;
52115: LD_VAR 0 4
52119: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
52120: LD_INT 0
52122: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
52123: LD_ADDR_VAR 0 5
52127: PUSH
52128: LD_VAR 0 1
52132: PPUSH
52133: CALL_OW 250
52137: PPUSH
52138: LD_VAR 0 1
52142: PPUSH
52143: CALL_OW 251
52147: PPUSH
52148: LD_VAR 0 2
52152: PPUSH
52153: LD_VAR 0 3
52157: PPUSH
52158: LD_VAR 0 4
52162: PPUSH
52163: CALL 52173 0 5
52167: ST_TO_ADDR
// end ;
52168: LD_VAR 0 5
52172: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
52173: LD_INT 0
52175: PPUSH
52176: PPUSH
52177: PPUSH
52178: PPUSH
// if not list then
52179: LD_VAR 0 3
52183: NOT
52184: IFFALSE 52188
// exit ;
52186: GO 52576
// result := [ ] ;
52188: LD_ADDR_VAR 0 6
52192: PUSH
52193: EMPTY
52194: ST_TO_ADDR
// for i in list do
52195: LD_ADDR_VAR 0 7
52199: PUSH
52200: LD_VAR 0 3
52204: PUSH
52205: FOR_IN
52206: IFFALSE 52408
// begin tmp := GetDistUnitXY ( i , x , y ) ;
52208: LD_ADDR_VAR 0 9
52212: PUSH
52213: LD_VAR 0 7
52217: PPUSH
52218: LD_VAR 0 1
52222: PPUSH
52223: LD_VAR 0 2
52227: PPUSH
52228: CALL_OW 297
52232: ST_TO_ADDR
// if not result then
52233: LD_VAR 0 6
52237: NOT
52238: IFFALSE 52264
// result := [ [ i , tmp ] ] else
52240: LD_ADDR_VAR 0 6
52244: PUSH
52245: LD_VAR 0 7
52249: PUSH
52250: LD_VAR 0 9
52254: PUSH
52255: EMPTY
52256: LIST
52257: LIST
52258: PUSH
52259: EMPTY
52260: LIST
52261: ST_TO_ADDR
52262: GO 52406
// begin if result [ result ] [ 2 ] < tmp then
52264: LD_VAR 0 6
52268: PUSH
52269: LD_VAR 0 6
52273: ARRAY
52274: PUSH
52275: LD_INT 2
52277: ARRAY
52278: PUSH
52279: LD_VAR 0 9
52283: LESS
52284: IFFALSE 52326
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
52286: LD_ADDR_VAR 0 6
52290: PUSH
52291: LD_VAR 0 6
52295: PPUSH
52296: LD_VAR 0 6
52300: PUSH
52301: LD_INT 1
52303: PLUS
52304: PPUSH
52305: LD_VAR 0 7
52309: PUSH
52310: LD_VAR 0 9
52314: PUSH
52315: EMPTY
52316: LIST
52317: LIST
52318: PPUSH
52319: CALL_OW 2
52323: ST_TO_ADDR
52324: GO 52406
// for j = 1 to result do
52326: LD_ADDR_VAR 0 8
52330: PUSH
52331: DOUBLE
52332: LD_INT 1
52334: DEC
52335: ST_TO_ADDR
52336: LD_VAR 0 6
52340: PUSH
52341: FOR_TO
52342: IFFALSE 52404
// begin if tmp < result [ j ] [ 2 ] then
52344: LD_VAR 0 9
52348: PUSH
52349: LD_VAR 0 6
52353: PUSH
52354: LD_VAR 0 8
52358: ARRAY
52359: PUSH
52360: LD_INT 2
52362: ARRAY
52363: LESS
52364: IFFALSE 52402
// begin result := Insert ( result , j , [ i , tmp ] ) ;
52366: LD_ADDR_VAR 0 6
52370: PUSH
52371: LD_VAR 0 6
52375: PPUSH
52376: LD_VAR 0 8
52380: PPUSH
52381: LD_VAR 0 7
52385: PUSH
52386: LD_VAR 0 9
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PPUSH
52395: CALL_OW 2
52399: ST_TO_ADDR
// break ;
52400: GO 52404
// end ; end ;
52402: GO 52341
52404: POP
52405: POP
// end ; end ;
52406: GO 52205
52408: POP
52409: POP
// if result and not asc then
52410: LD_VAR 0 6
52414: PUSH
52415: LD_VAR 0 4
52419: NOT
52420: AND
52421: IFFALSE 52496
// begin tmp := result ;
52423: LD_ADDR_VAR 0 9
52427: PUSH
52428: LD_VAR 0 6
52432: ST_TO_ADDR
// for i = tmp downto 1 do
52433: LD_ADDR_VAR 0 7
52437: PUSH
52438: DOUBLE
52439: LD_VAR 0 9
52443: INC
52444: ST_TO_ADDR
52445: LD_INT 1
52447: PUSH
52448: FOR_DOWNTO
52449: IFFALSE 52494
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
52451: LD_ADDR_VAR 0 6
52455: PUSH
52456: LD_VAR 0 6
52460: PPUSH
52461: LD_VAR 0 9
52465: PUSH
52466: LD_VAR 0 7
52470: MINUS
52471: PUSH
52472: LD_INT 1
52474: PLUS
52475: PPUSH
52476: LD_VAR 0 9
52480: PUSH
52481: LD_VAR 0 7
52485: ARRAY
52486: PPUSH
52487: CALL_OW 1
52491: ST_TO_ADDR
52492: GO 52448
52494: POP
52495: POP
// end ; tmp := [ ] ;
52496: LD_ADDR_VAR 0 9
52500: PUSH
52501: EMPTY
52502: ST_TO_ADDR
// if mode then
52503: LD_VAR 0 5
52507: IFFALSE 52576
// begin for i = 1 to result do
52509: LD_ADDR_VAR 0 7
52513: PUSH
52514: DOUBLE
52515: LD_INT 1
52517: DEC
52518: ST_TO_ADDR
52519: LD_VAR 0 6
52523: PUSH
52524: FOR_TO
52525: IFFALSE 52564
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
52527: LD_ADDR_VAR 0 9
52531: PUSH
52532: LD_VAR 0 9
52536: PPUSH
52537: LD_VAR 0 7
52541: PPUSH
52542: LD_VAR 0 6
52546: PUSH
52547: LD_VAR 0 7
52551: ARRAY
52552: PUSH
52553: LD_INT 1
52555: ARRAY
52556: PPUSH
52557: CALL_OW 1
52561: ST_TO_ADDR
52562: GO 52524
52564: POP
52565: POP
// result := tmp ;
52566: LD_ADDR_VAR 0 6
52570: PUSH
52571: LD_VAR 0 9
52575: ST_TO_ADDR
// end ; end ;
52576: LD_VAR 0 6
52580: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
52581: LD_INT 0
52583: PPUSH
52584: PPUSH
52585: PPUSH
52586: PPUSH
52587: PPUSH
52588: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
52589: LD_ADDR_VAR 0 5
52593: PUSH
52594: LD_INT 0
52596: PUSH
52597: LD_INT 0
52599: PUSH
52600: LD_INT 0
52602: PUSH
52603: EMPTY
52604: PUSH
52605: EMPTY
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: ST_TO_ADDR
// if not x or not y then
52611: LD_VAR 0 2
52615: NOT
52616: PUSH
52617: LD_VAR 0 3
52621: NOT
52622: OR
52623: IFFALSE 52627
// exit ;
52625: GO 54273
// if not range then
52627: LD_VAR 0 4
52631: NOT
52632: IFFALSE 52642
// range := 10 ;
52634: LD_ADDR_VAR 0 4
52638: PUSH
52639: LD_INT 10
52641: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52642: LD_ADDR_VAR 0 8
52646: PUSH
52647: LD_INT 81
52649: PUSH
52650: LD_VAR 0 1
52654: PUSH
52655: EMPTY
52656: LIST
52657: LIST
52658: PUSH
52659: LD_INT 92
52661: PUSH
52662: LD_VAR 0 2
52666: PUSH
52667: LD_VAR 0 3
52671: PUSH
52672: LD_VAR 0 4
52676: PUSH
52677: EMPTY
52678: LIST
52679: LIST
52680: LIST
52681: LIST
52682: PUSH
52683: LD_INT 3
52685: PUSH
52686: LD_INT 21
52688: PUSH
52689: LD_INT 3
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: PUSH
52696: EMPTY
52697: LIST
52698: LIST
52699: PUSH
52700: EMPTY
52701: LIST
52702: LIST
52703: LIST
52704: PPUSH
52705: CALL_OW 69
52709: ST_TO_ADDR
// if not tmp then
52710: LD_VAR 0 8
52714: NOT
52715: IFFALSE 52719
// exit ;
52717: GO 54273
// for i in tmp do
52719: LD_ADDR_VAR 0 6
52723: PUSH
52724: LD_VAR 0 8
52728: PUSH
52729: FOR_IN
52730: IFFALSE 54248
// begin points := [ 0 , 0 , 0 ] ;
52732: LD_ADDR_VAR 0 9
52736: PUSH
52737: LD_INT 0
52739: PUSH
52740: LD_INT 0
52742: PUSH
52743: LD_INT 0
52745: PUSH
52746: EMPTY
52747: LIST
52748: LIST
52749: LIST
52750: ST_TO_ADDR
// bpoints := 1 ;
52751: LD_ADDR_VAR 0 10
52755: PUSH
52756: LD_INT 1
52758: ST_TO_ADDR
// case GetType ( i ) of unit_human :
52759: LD_VAR 0 6
52763: PPUSH
52764: CALL_OW 247
52768: PUSH
52769: LD_INT 1
52771: DOUBLE
52772: EQUAL
52773: IFTRUE 52777
52775: GO 53355
52777: POP
// begin if GetClass ( i ) = 1 then
52778: LD_VAR 0 6
52782: PPUSH
52783: CALL_OW 257
52787: PUSH
52788: LD_INT 1
52790: EQUAL
52791: IFFALSE 52812
// points := [ 10 , 5 , 3 ] ;
52793: LD_ADDR_VAR 0 9
52797: PUSH
52798: LD_INT 10
52800: PUSH
52801: LD_INT 5
52803: PUSH
52804: LD_INT 3
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: LIST
52811: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
52812: LD_VAR 0 6
52816: PPUSH
52817: CALL_OW 257
52821: PUSH
52822: LD_INT 2
52824: PUSH
52825: LD_INT 3
52827: PUSH
52828: LD_INT 4
52830: PUSH
52831: EMPTY
52832: LIST
52833: LIST
52834: LIST
52835: IN
52836: IFFALSE 52857
// points := [ 3 , 2 , 1 ] ;
52838: LD_ADDR_VAR 0 9
52842: PUSH
52843: LD_INT 3
52845: PUSH
52846: LD_INT 2
52848: PUSH
52849: LD_INT 1
52851: PUSH
52852: EMPTY
52853: LIST
52854: LIST
52855: LIST
52856: ST_TO_ADDR
// if GetClass ( i ) = 5 then
52857: LD_VAR 0 6
52861: PPUSH
52862: CALL_OW 257
52866: PUSH
52867: LD_INT 5
52869: EQUAL
52870: IFFALSE 52891
// points := [ 130 , 5 , 2 ] ;
52872: LD_ADDR_VAR 0 9
52876: PUSH
52877: LD_INT 130
52879: PUSH
52880: LD_INT 5
52882: PUSH
52883: LD_INT 2
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: LIST
52890: ST_TO_ADDR
// if GetClass ( i ) = 8 then
52891: LD_VAR 0 6
52895: PPUSH
52896: CALL_OW 257
52900: PUSH
52901: LD_INT 8
52903: EQUAL
52904: IFFALSE 52925
// points := [ 35 , 35 , 30 ] ;
52906: LD_ADDR_VAR 0 9
52910: PUSH
52911: LD_INT 35
52913: PUSH
52914: LD_INT 35
52916: PUSH
52917: LD_INT 30
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: LIST
52924: ST_TO_ADDR
// if GetClass ( i ) = 9 then
52925: LD_VAR 0 6
52929: PPUSH
52930: CALL_OW 257
52934: PUSH
52935: LD_INT 9
52937: EQUAL
52938: IFFALSE 52959
// points := [ 20 , 55 , 40 ] ;
52940: LD_ADDR_VAR 0 9
52944: PUSH
52945: LD_INT 20
52947: PUSH
52948: LD_INT 55
52950: PUSH
52951: LD_INT 40
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: LIST
52958: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
52959: LD_VAR 0 6
52963: PPUSH
52964: CALL_OW 257
52968: PUSH
52969: LD_INT 12
52971: PUSH
52972: LD_INT 16
52974: PUSH
52975: EMPTY
52976: LIST
52977: LIST
52978: IN
52979: IFFALSE 53000
// points := [ 5 , 3 , 2 ] ;
52981: LD_ADDR_VAR 0 9
52985: PUSH
52986: LD_INT 5
52988: PUSH
52989: LD_INT 3
52991: PUSH
52992: LD_INT 2
52994: PUSH
52995: EMPTY
52996: LIST
52997: LIST
52998: LIST
52999: ST_TO_ADDR
// if GetClass ( i ) = 17 then
53000: LD_VAR 0 6
53004: PPUSH
53005: CALL_OW 257
53009: PUSH
53010: LD_INT 17
53012: EQUAL
53013: IFFALSE 53034
// points := [ 100 , 50 , 75 ] ;
53015: LD_ADDR_VAR 0 9
53019: PUSH
53020: LD_INT 100
53022: PUSH
53023: LD_INT 50
53025: PUSH
53026: LD_INT 75
53028: PUSH
53029: EMPTY
53030: LIST
53031: LIST
53032: LIST
53033: ST_TO_ADDR
// if GetClass ( i ) = 15 then
53034: LD_VAR 0 6
53038: PPUSH
53039: CALL_OW 257
53043: PUSH
53044: LD_INT 15
53046: EQUAL
53047: IFFALSE 53068
// points := [ 10 , 5 , 3 ] ;
53049: LD_ADDR_VAR 0 9
53053: PUSH
53054: LD_INT 10
53056: PUSH
53057: LD_INT 5
53059: PUSH
53060: LD_INT 3
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: LIST
53067: ST_TO_ADDR
// if GetClass ( i ) = 14 then
53068: LD_VAR 0 6
53072: PPUSH
53073: CALL_OW 257
53077: PUSH
53078: LD_INT 14
53080: EQUAL
53081: IFFALSE 53102
// points := [ 10 , 0 , 0 ] ;
53083: LD_ADDR_VAR 0 9
53087: PUSH
53088: LD_INT 10
53090: PUSH
53091: LD_INT 0
53093: PUSH
53094: LD_INT 0
53096: PUSH
53097: EMPTY
53098: LIST
53099: LIST
53100: LIST
53101: ST_TO_ADDR
// if GetClass ( i ) = 11 then
53102: LD_VAR 0 6
53106: PPUSH
53107: CALL_OW 257
53111: PUSH
53112: LD_INT 11
53114: EQUAL
53115: IFFALSE 53136
// points := [ 30 , 10 , 5 ] ;
53117: LD_ADDR_VAR 0 9
53121: PUSH
53122: LD_INT 30
53124: PUSH
53125: LD_INT 10
53127: PUSH
53128: LD_INT 5
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: LIST
53135: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
53136: LD_VAR 0 1
53140: PPUSH
53141: LD_INT 5
53143: PPUSH
53144: CALL_OW 321
53148: PUSH
53149: LD_INT 2
53151: EQUAL
53152: IFFALSE 53169
// bpoints := bpoints * 1.8 ;
53154: LD_ADDR_VAR 0 10
53158: PUSH
53159: LD_VAR 0 10
53163: PUSH
53164: LD_REAL  1.80000000000000E+0000
53167: MUL
53168: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
53169: LD_VAR 0 6
53173: PPUSH
53174: CALL_OW 257
53178: PUSH
53179: LD_INT 1
53181: PUSH
53182: LD_INT 2
53184: PUSH
53185: LD_INT 3
53187: PUSH
53188: LD_INT 4
53190: PUSH
53191: EMPTY
53192: LIST
53193: LIST
53194: LIST
53195: LIST
53196: IN
53197: PUSH
53198: LD_VAR 0 1
53202: PPUSH
53203: LD_INT 51
53205: PPUSH
53206: CALL_OW 321
53210: PUSH
53211: LD_INT 2
53213: EQUAL
53214: AND
53215: IFFALSE 53232
// bpoints := bpoints * 1.2 ;
53217: LD_ADDR_VAR 0 10
53221: PUSH
53222: LD_VAR 0 10
53226: PUSH
53227: LD_REAL  1.20000000000000E+0000
53230: MUL
53231: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
53232: LD_VAR 0 6
53236: PPUSH
53237: CALL_OW 257
53241: PUSH
53242: LD_INT 5
53244: PUSH
53245: LD_INT 7
53247: PUSH
53248: LD_INT 9
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: LIST
53255: IN
53256: PUSH
53257: LD_VAR 0 1
53261: PPUSH
53262: LD_INT 52
53264: PPUSH
53265: CALL_OW 321
53269: PUSH
53270: LD_INT 2
53272: EQUAL
53273: AND
53274: IFFALSE 53291
// bpoints := bpoints * 1.5 ;
53276: LD_ADDR_VAR 0 10
53280: PUSH
53281: LD_VAR 0 10
53285: PUSH
53286: LD_REAL  1.50000000000000E+0000
53289: MUL
53290: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
53291: LD_VAR 0 1
53295: PPUSH
53296: LD_INT 66
53298: PPUSH
53299: CALL_OW 321
53303: PUSH
53304: LD_INT 2
53306: EQUAL
53307: IFFALSE 53324
// bpoints := bpoints * 1.1 ;
53309: LD_ADDR_VAR 0 10
53313: PUSH
53314: LD_VAR 0 10
53318: PUSH
53319: LD_REAL  1.10000000000000E+0000
53322: MUL
53323: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
53324: LD_ADDR_VAR 0 10
53328: PUSH
53329: LD_VAR 0 10
53333: PUSH
53334: LD_VAR 0 6
53338: PPUSH
53339: LD_INT 1
53341: PPUSH
53342: CALL_OW 259
53346: PUSH
53347: LD_REAL  1.15000000000000E+0000
53350: MUL
53351: MUL
53352: ST_TO_ADDR
// end ; unit_vehicle :
53353: GO 54177
53355: LD_INT 2
53357: DOUBLE
53358: EQUAL
53359: IFTRUE 53363
53361: GO 54165
53363: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
53364: LD_VAR 0 6
53368: PPUSH
53369: CALL_OW 264
53373: PUSH
53374: LD_INT 2
53376: PUSH
53377: LD_INT 42
53379: PUSH
53380: LD_INT 24
53382: PUSH
53383: EMPTY
53384: LIST
53385: LIST
53386: LIST
53387: IN
53388: IFFALSE 53409
// points := [ 25 , 5 , 3 ] ;
53390: LD_ADDR_VAR 0 9
53394: PUSH
53395: LD_INT 25
53397: PUSH
53398: LD_INT 5
53400: PUSH
53401: LD_INT 3
53403: PUSH
53404: EMPTY
53405: LIST
53406: LIST
53407: LIST
53408: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
53409: LD_VAR 0 6
53413: PPUSH
53414: CALL_OW 264
53418: PUSH
53419: LD_INT 4
53421: PUSH
53422: LD_INT 43
53424: PUSH
53425: LD_INT 25
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: LIST
53432: IN
53433: IFFALSE 53454
// points := [ 40 , 15 , 5 ] ;
53435: LD_ADDR_VAR 0 9
53439: PUSH
53440: LD_INT 40
53442: PUSH
53443: LD_INT 15
53445: PUSH
53446: LD_INT 5
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: LIST
53453: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
53454: LD_VAR 0 6
53458: PPUSH
53459: CALL_OW 264
53463: PUSH
53464: LD_INT 3
53466: PUSH
53467: LD_INT 23
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: IN
53474: IFFALSE 53495
// points := [ 7 , 25 , 8 ] ;
53476: LD_ADDR_VAR 0 9
53480: PUSH
53481: LD_INT 7
53483: PUSH
53484: LD_INT 25
53486: PUSH
53487: LD_INT 8
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: LIST
53494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
53495: LD_VAR 0 6
53499: PPUSH
53500: CALL_OW 264
53504: PUSH
53505: LD_INT 5
53507: PUSH
53508: LD_INT 27
53510: PUSH
53511: LD_INT 44
53513: PUSH
53514: EMPTY
53515: LIST
53516: LIST
53517: LIST
53518: IN
53519: IFFALSE 53540
// points := [ 14 , 50 , 16 ] ;
53521: LD_ADDR_VAR 0 9
53525: PUSH
53526: LD_INT 14
53528: PUSH
53529: LD_INT 50
53531: PUSH
53532: LD_INT 16
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: LIST
53539: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
53540: LD_VAR 0 6
53544: PPUSH
53545: CALL_OW 264
53549: PUSH
53550: LD_INT 6
53552: PUSH
53553: LD_INT 46
53555: PUSH
53556: EMPTY
53557: LIST
53558: LIST
53559: IN
53560: IFFALSE 53581
// points := [ 32 , 120 , 70 ] ;
53562: LD_ADDR_VAR 0 9
53566: PUSH
53567: LD_INT 32
53569: PUSH
53570: LD_INT 120
53572: PUSH
53573: LD_INT 70
53575: PUSH
53576: EMPTY
53577: LIST
53578: LIST
53579: LIST
53580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
53581: LD_VAR 0 6
53585: PPUSH
53586: CALL_OW 264
53590: PUSH
53591: LD_INT 7
53593: PUSH
53594: LD_INT 28
53596: PUSH
53597: LD_INT 45
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: LIST
53604: IN
53605: IFFALSE 53626
// points := [ 35 , 20 , 45 ] ;
53607: LD_ADDR_VAR 0 9
53611: PUSH
53612: LD_INT 35
53614: PUSH
53615: LD_INT 20
53617: PUSH
53618: LD_INT 45
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: LIST
53625: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
53626: LD_VAR 0 6
53630: PPUSH
53631: CALL_OW 264
53635: PUSH
53636: LD_INT 47
53638: PUSH
53639: EMPTY
53640: LIST
53641: IN
53642: IFFALSE 53663
// points := [ 67 , 45 , 75 ] ;
53644: LD_ADDR_VAR 0 9
53648: PUSH
53649: LD_INT 67
53651: PUSH
53652: LD_INT 45
53654: PUSH
53655: LD_INT 75
53657: PUSH
53658: EMPTY
53659: LIST
53660: LIST
53661: LIST
53662: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
53663: LD_VAR 0 6
53667: PPUSH
53668: CALL_OW 264
53672: PUSH
53673: LD_INT 26
53675: PUSH
53676: EMPTY
53677: LIST
53678: IN
53679: IFFALSE 53700
// points := [ 120 , 30 , 80 ] ;
53681: LD_ADDR_VAR 0 9
53685: PUSH
53686: LD_INT 120
53688: PUSH
53689: LD_INT 30
53691: PUSH
53692: LD_INT 80
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: LIST
53699: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
53700: LD_VAR 0 6
53704: PPUSH
53705: CALL_OW 264
53709: PUSH
53710: LD_INT 22
53712: PUSH
53713: EMPTY
53714: LIST
53715: IN
53716: IFFALSE 53737
// points := [ 40 , 1 , 1 ] ;
53718: LD_ADDR_VAR 0 9
53722: PUSH
53723: LD_INT 40
53725: PUSH
53726: LD_INT 1
53728: PUSH
53729: LD_INT 1
53731: PUSH
53732: EMPTY
53733: LIST
53734: LIST
53735: LIST
53736: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
53737: LD_VAR 0 6
53741: PPUSH
53742: CALL_OW 264
53746: PUSH
53747: LD_INT 29
53749: PUSH
53750: EMPTY
53751: LIST
53752: IN
53753: IFFALSE 53774
// points := [ 70 , 200 , 400 ] ;
53755: LD_ADDR_VAR 0 9
53759: PUSH
53760: LD_INT 70
53762: PUSH
53763: LD_INT 200
53765: PUSH
53766: LD_INT 400
53768: PUSH
53769: EMPTY
53770: LIST
53771: LIST
53772: LIST
53773: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
53774: LD_VAR 0 6
53778: PPUSH
53779: CALL_OW 264
53783: PUSH
53784: LD_INT 14
53786: PUSH
53787: LD_INT 53
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: IN
53794: IFFALSE 53815
// points := [ 40 , 10 , 20 ] ;
53796: LD_ADDR_VAR 0 9
53800: PUSH
53801: LD_INT 40
53803: PUSH
53804: LD_INT 10
53806: PUSH
53807: LD_INT 20
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: LIST
53814: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
53815: LD_VAR 0 6
53819: PPUSH
53820: CALL_OW 264
53824: PUSH
53825: LD_INT 9
53827: PUSH
53828: EMPTY
53829: LIST
53830: IN
53831: IFFALSE 53852
// points := [ 5 , 70 , 20 ] ;
53833: LD_ADDR_VAR 0 9
53837: PUSH
53838: LD_INT 5
53840: PUSH
53841: LD_INT 70
53843: PUSH
53844: LD_INT 20
53846: PUSH
53847: EMPTY
53848: LIST
53849: LIST
53850: LIST
53851: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
53852: LD_VAR 0 6
53856: PPUSH
53857: CALL_OW 264
53861: PUSH
53862: LD_INT 10
53864: PUSH
53865: EMPTY
53866: LIST
53867: IN
53868: IFFALSE 53889
// points := [ 35 , 110 , 70 ] ;
53870: LD_ADDR_VAR 0 9
53874: PUSH
53875: LD_INT 35
53877: PUSH
53878: LD_INT 110
53880: PUSH
53881: LD_INT 70
53883: PUSH
53884: EMPTY
53885: LIST
53886: LIST
53887: LIST
53888: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
53889: LD_VAR 0 6
53893: PPUSH
53894: CALL_OW 265
53898: PUSH
53899: LD_INT 25
53901: EQUAL
53902: IFFALSE 53923
// points := [ 80 , 65 , 100 ] ;
53904: LD_ADDR_VAR 0 9
53908: PUSH
53909: LD_INT 80
53911: PUSH
53912: LD_INT 65
53914: PUSH
53915: LD_INT 100
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: LIST
53922: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
53923: LD_VAR 0 6
53927: PPUSH
53928: CALL_OW 263
53932: PUSH
53933: LD_INT 1
53935: EQUAL
53936: IFFALSE 53971
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
53938: LD_ADDR_VAR 0 10
53942: PUSH
53943: LD_VAR 0 10
53947: PUSH
53948: LD_VAR 0 6
53952: PPUSH
53953: CALL_OW 311
53957: PPUSH
53958: LD_INT 3
53960: PPUSH
53961: CALL_OW 259
53965: PUSH
53966: LD_INT 4
53968: MUL
53969: MUL
53970: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
53971: LD_VAR 0 6
53975: PPUSH
53976: CALL_OW 263
53980: PUSH
53981: LD_INT 2
53983: EQUAL
53984: IFFALSE 54035
// begin j := IsControledBy ( i ) ;
53986: LD_ADDR_VAR 0 7
53990: PUSH
53991: LD_VAR 0 6
53995: PPUSH
53996: CALL_OW 312
54000: ST_TO_ADDR
// if j then
54001: LD_VAR 0 7
54005: IFFALSE 54035
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
54007: LD_ADDR_VAR 0 10
54011: PUSH
54012: LD_VAR 0 10
54016: PUSH
54017: LD_VAR 0 7
54021: PPUSH
54022: LD_INT 3
54024: PPUSH
54025: CALL_OW 259
54029: PUSH
54030: LD_INT 3
54032: MUL
54033: MUL
54034: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
54035: LD_VAR 0 6
54039: PPUSH
54040: CALL_OW 264
54044: PUSH
54045: LD_INT 5
54047: PUSH
54048: LD_INT 6
54050: PUSH
54051: LD_INT 46
54053: PUSH
54054: LD_INT 44
54056: PUSH
54057: LD_INT 47
54059: PUSH
54060: LD_INT 45
54062: PUSH
54063: LD_INT 28
54065: PUSH
54066: LD_INT 7
54068: PUSH
54069: LD_INT 27
54071: PUSH
54072: LD_INT 29
54074: PUSH
54075: EMPTY
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: LIST
54081: LIST
54082: LIST
54083: LIST
54084: LIST
54085: LIST
54086: IN
54087: PUSH
54088: LD_VAR 0 1
54092: PPUSH
54093: LD_INT 52
54095: PPUSH
54096: CALL_OW 321
54100: PUSH
54101: LD_INT 2
54103: EQUAL
54104: AND
54105: IFFALSE 54122
// bpoints := bpoints * 1.2 ;
54107: LD_ADDR_VAR 0 10
54111: PUSH
54112: LD_VAR 0 10
54116: PUSH
54117: LD_REAL  1.20000000000000E+0000
54120: MUL
54121: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
54122: LD_VAR 0 6
54126: PPUSH
54127: CALL_OW 264
54131: PUSH
54132: LD_INT 6
54134: PUSH
54135: LD_INT 46
54137: PUSH
54138: LD_INT 47
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: IN
54146: IFFALSE 54163
// bpoints := bpoints * 1.2 ;
54148: LD_ADDR_VAR 0 10
54152: PUSH
54153: LD_VAR 0 10
54157: PUSH
54158: LD_REAL  1.20000000000000E+0000
54161: MUL
54162: ST_TO_ADDR
// end ; unit_building :
54163: GO 54177
54165: LD_INT 3
54167: DOUBLE
54168: EQUAL
54169: IFTRUE 54173
54171: GO 54176
54173: POP
// ; end ;
54174: GO 54177
54176: POP
// for j = 1 to 3 do
54177: LD_ADDR_VAR 0 7
54181: PUSH
54182: DOUBLE
54183: LD_INT 1
54185: DEC
54186: ST_TO_ADDR
54187: LD_INT 3
54189: PUSH
54190: FOR_TO
54191: IFFALSE 54244
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
54193: LD_ADDR_VAR 0 5
54197: PUSH
54198: LD_VAR 0 5
54202: PPUSH
54203: LD_VAR 0 7
54207: PPUSH
54208: LD_VAR 0 5
54212: PUSH
54213: LD_VAR 0 7
54217: ARRAY
54218: PUSH
54219: LD_VAR 0 9
54223: PUSH
54224: LD_VAR 0 7
54228: ARRAY
54229: PUSH
54230: LD_VAR 0 10
54234: MUL
54235: PLUS
54236: PPUSH
54237: CALL_OW 1
54241: ST_TO_ADDR
54242: GO 54190
54244: POP
54245: POP
// end ;
54246: GO 52729
54248: POP
54249: POP
// result := Replace ( result , 4 , tmp ) ;
54250: LD_ADDR_VAR 0 5
54254: PUSH
54255: LD_VAR 0 5
54259: PPUSH
54260: LD_INT 4
54262: PPUSH
54263: LD_VAR 0 8
54267: PPUSH
54268: CALL_OW 1
54272: ST_TO_ADDR
// end ;
54273: LD_VAR 0 5
54277: RET
// export function DangerAtRange ( unit , range ) ; begin
54278: LD_INT 0
54280: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
54281: LD_ADDR_VAR 0 3
54285: PUSH
54286: LD_VAR 0 1
54290: PPUSH
54291: CALL_OW 255
54295: PPUSH
54296: LD_VAR 0 1
54300: PPUSH
54301: CALL_OW 250
54305: PPUSH
54306: LD_VAR 0 1
54310: PPUSH
54311: CALL_OW 251
54315: PPUSH
54316: LD_VAR 0 2
54320: PPUSH
54321: CALL 52581 0 4
54325: ST_TO_ADDR
// end ;
54326: LD_VAR 0 3
54330: RET
// export function DangerInArea ( side , area ) ; begin
54331: LD_INT 0
54333: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
54334: LD_ADDR_VAR 0 3
54338: PUSH
54339: LD_VAR 0 2
54343: PPUSH
54344: LD_INT 81
54346: PUSH
54347: LD_VAR 0 1
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: PPUSH
54356: CALL_OW 70
54360: ST_TO_ADDR
// end ;
54361: LD_VAR 0 3
54365: RET
// export function IsExtension ( b ) ; begin
54366: LD_INT 0
54368: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
54369: LD_ADDR_VAR 0 2
54373: PUSH
54374: LD_VAR 0 1
54378: PUSH
54379: LD_INT 23
54381: PUSH
54382: LD_INT 20
54384: PUSH
54385: LD_INT 22
54387: PUSH
54388: LD_INT 17
54390: PUSH
54391: LD_INT 24
54393: PUSH
54394: LD_INT 21
54396: PUSH
54397: LD_INT 19
54399: PUSH
54400: LD_INT 16
54402: PUSH
54403: LD_INT 25
54405: PUSH
54406: LD_INT 18
54408: PUSH
54409: EMPTY
54410: LIST
54411: LIST
54412: LIST
54413: LIST
54414: LIST
54415: LIST
54416: LIST
54417: LIST
54418: LIST
54419: LIST
54420: IN
54421: ST_TO_ADDR
// end ;
54422: LD_VAR 0 2
54426: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
54427: LD_INT 0
54429: PPUSH
54430: PPUSH
54431: PPUSH
// result := [ ] ;
54432: LD_ADDR_VAR 0 3
54436: PUSH
54437: EMPTY
54438: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
54439: LD_ADDR_VAR 0 4
54443: PUSH
54444: LD_VAR 0 2
54448: PPUSH
54449: LD_INT 21
54451: PUSH
54452: LD_INT 3
54454: PUSH
54455: EMPTY
54456: LIST
54457: LIST
54458: PPUSH
54459: CALL_OW 70
54463: ST_TO_ADDR
// if not tmp then
54464: LD_VAR 0 4
54468: NOT
54469: IFFALSE 54473
// exit ;
54471: GO 54531
// for i in tmp do
54473: LD_ADDR_VAR 0 5
54477: PUSH
54478: LD_VAR 0 4
54482: PUSH
54483: FOR_IN
54484: IFFALSE 54519
// if GetBase ( i ) <> base then
54486: LD_VAR 0 5
54490: PPUSH
54491: CALL_OW 274
54495: PUSH
54496: LD_VAR 0 1
54500: NONEQUAL
54501: IFFALSE 54517
// ComLinkToBase ( base , i ) ;
54503: LD_VAR 0 1
54507: PPUSH
54508: LD_VAR 0 5
54512: PPUSH
54513: CALL_OW 169
54517: GO 54483
54519: POP
54520: POP
// result := tmp ;
54521: LD_ADDR_VAR 0 3
54525: PUSH
54526: LD_VAR 0 4
54530: ST_TO_ADDR
// end ;
54531: LD_VAR 0 3
54535: RET
// export function ComComplete ( unit , b ) ; var i ; begin
54536: LD_INT 0
54538: PPUSH
54539: PPUSH
// if BuildingStatus ( b ) = bs_build then
54540: LD_VAR 0 2
54544: PPUSH
54545: CALL_OW 461
54549: PUSH
54550: LD_INT 1
54552: EQUAL
54553: IFFALSE 54613
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
54555: LD_VAR 0 1
54559: PPUSH
54560: LD_STRING h
54562: PUSH
54563: LD_VAR 0 2
54567: PPUSH
54568: CALL_OW 250
54572: PUSH
54573: LD_VAR 0 2
54577: PPUSH
54578: CALL_OW 251
54582: PUSH
54583: LD_VAR 0 2
54587: PUSH
54588: LD_INT 0
54590: PUSH
54591: LD_INT 0
54593: PUSH
54594: LD_INT 0
54596: PUSH
54597: EMPTY
54598: LIST
54599: LIST
54600: LIST
54601: LIST
54602: LIST
54603: LIST
54604: LIST
54605: PUSH
54606: EMPTY
54607: LIST
54608: PPUSH
54609: CALL_OW 446
// end ;
54613: LD_VAR 0 3
54617: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
54618: LD_INT 0
54620: PPUSH
54621: PPUSH
54622: PPUSH
54623: PPUSH
54624: PPUSH
54625: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
54626: LD_VAR 0 1
54630: NOT
54631: PUSH
54632: LD_VAR 0 1
54636: PPUSH
54637: CALL_OW 263
54641: PUSH
54642: LD_INT 2
54644: EQUAL
54645: NOT
54646: OR
54647: IFFALSE 54651
// exit ;
54649: GO 54967
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
54651: LD_ADDR_VAR 0 6
54655: PUSH
54656: LD_INT 22
54658: PUSH
54659: LD_VAR 0 1
54663: PPUSH
54664: CALL_OW 255
54668: PUSH
54669: EMPTY
54670: LIST
54671: LIST
54672: PUSH
54673: LD_INT 2
54675: PUSH
54676: LD_INT 30
54678: PUSH
54679: LD_INT 36
54681: PUSH
54682: EMPTY
54683: LIST
54684: LIST
54685: PUSH
54686: LD_INT 34
54688: PUSH
54689: LD_INT 31
54691: PUSH
54692: EMPTY
54693: LIST
54694: LIST
54695: PUSH
54696: EMPTY
54697: LIST
54698: LIST
54699: LIST
54700: PUSH
54701: EMPTY
54702: LIST
54703: LIST
54704: PPUSH
54705: CALL_OW 69
54709: ST_TO_ADDR
// if not tmp then
54710: LD_VAR 0 6
54714: NOT
54715: IFFALSE 54719
// exit ;
54717: GO 54967
// result := [ ] ;
54719: LD_ADDR_VAR 0 2
54723: PUSH
54724: EMPTY
54725: ST_TO_ADDR
// for i in tmp do
54726: LD_ADDR_VAR 0 3
54730: PUSH
54731: LD_VAR 0 6
54735: PUSH
54736: FOR_IN
54737: IFFALSE 54808
// begin t := UnitsInside ( i ) ;
54739: LD_ADDR_VAR 0 4
54743: PUSH
54744: LD_VAR 0 3
54748: PPUSH
54749: CALL_OW 313
54753: ST_TO_ADDR
// if t then
54754: LD_VAR 0 4
54758: IFFALSE 54806
// for j in t do
54760: LD_ADDR_VAR 0 7
54764: PUSH
54765: LD_VAR 0 4
54769: PUSH
54770: FOR_IN
54771: IFFALSE 54804
// result := Insert ( result , result + 1 , j ) ;
54773: LD_ADDR_VAR 0 2
54777: PUSH
54778: LD_VAR 0 2
54782: PPUSH
54783: LD_VAR 0 2
54787: PUSH
54788: LD_INT 1
54790: PLUS
54791: PPUSH
54792: LD_VAR 0 7
54796: PPUSH
54797: CALL_OW 2
54801: ST_TO_ADDR
54802: GO 54770
54804: POP
54805: POP
// end ;
54806: GO 54736
54808: POP
54809: POP
// if not result then
54810: LD_VAR 0 2
54814: NOT
54815: IFFALSE 54819
// exit ;
54817: GO 54967
// mech := result [ 1 ] ;
54819: LD_ADDR_VAR 0 5
54823: PUSH
54824: LD_VAR 0 2
54828: PUSH
54829: LD_INT 1
54831: ARRAY
54832: ST_TO_ADDR
// if result > 1 then
54833: LD_VAR 0 2
54837: PUSH
54838: LD_INT 1
54840: GREATER
54841: IFFALSE 54953
// for i = 2 to result do
54843: LD_ADDR_VAR 0 3
54847: PUSH
54848: DOUBLE
54849: LD_INT 2
54851: DEC
54852: ST_TO_ADDR
54853: LD_VAR 0 2
54857: PUSH
54858: FOR_TO
54859: IFFALSE 54951
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
54861: LD_ADDR_VAR 0 4
54865: PUSH
54866: LD_VAR 0 2
54870: PUSH
54871: LD_VAR 0 3
54875: ARRAY
54876: PPUSH
54877: LD_INT 3
54879: PPUSH
54880: CALL_OW 259
54884: PUSH
54885: LD_VAR 0 2
54889: PUSH
54890: LD_VAR 0 3
54894: ARRAY
54895: PPUSH
54896: CALL_OW 432
54900: MINUS
54901: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
54902: LD_VAR 0 4
54906: PUSH
54907: LD_VAR 0 5
54911: PPUSH
54912: LD_INT 3
54914: PPUSH
54915: CALL_OW 259
54919: PUSH
54920: LD_VAR 0 5
54924: PPUSH
54925: CALL_OW 432
54929: MINUS
54930: GREATEREQUAL
54931: IFFALSE 54949
// mech := result [ i ] ;
54933: LD_ADDR_VAR 0 5
54937: PUSH
54938: LD_VAR 0 2
54942: PUSH
54943: LD_VAR 0 3
54947: ARRAY
54948: ST_TO_ADDR
// end ;
54949: GO 54858
54951: POP
54952: POP
// ComLinkTo ( vehicle , mech ) ;
54953: LD_VAR 0 1
54957: PPUSH
54958: LD_VAR 0 5
54962: PPUSH
54963: CALL_OW 135
// end ;
54967: LD_VAR 0 2
54971: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
54972: LD_INT 0
54974: PPUSH
54975: PPUSH
54976: PPUSH
54977: PPUSH
54978: PPUSH
54979: PPUSH
54980: PPUSH
54981: PPUSH
54982: PPUSH
54983: PPUSH
54984: PPUSH
54985: PPUSH
54986: PPUSH
// result := [ ] ;
54987: LD_ADDR_VAR 0 7
54991: PUSH
54992: EMPTY
54993: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
54994: LD_VAR 0 1
54998: PPUSH
54999: CALL_OW 266
55003: PUSH
55004: LD_INT 0
55006: PUSH
55007: LD_INT 1
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: IN
55014: NOT
55015: IFFALSE 55019
// exit ;
55017: GO 56650
// if name then
55019: LD_VAR 0 3
55023: IFFALSE 55039
// SetBName ( base_dep , name ) ;
55025: LD_VAR 0 1
55029: PPUSH
55030: LD_VAR 0 3
55034: PPUSH
55035: CALL_OW 500
// base := GetBase ( base_dep ) ;
55039: LD_ADDR_VAR 0 15
55043: PUSH
55044: LD_VAR 0 1
55048: PPUSH
55049: CALL_OW 274
55053: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
55054: LD_ADDR_VAR 0 16
55058: PUSH
55059: LD_VAR 0 1
55063: PPUSH
55064: CALL_OW 255
55068: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
55069: LD_ADDR_VAR 0 17
55073: PUSH
55074: LD_VAR 0 1
55078: PPUSH
55079: CALL_OW 248
55083: ST_TO_ADDR
// if sources then
55084: LD_VAR 0 5
55088: IFFALSE 55135
// for i = 1 to 3 do
55090: LD_ADDR_VAR 0 8
55094: PUSH
55095: DOUBLE
55096: LD_INT 1
55098: DEC
55099: ST_TO_ADDR
55100: LD_INT 3
55102: PUSH
55103: FOR_TO
55104: IFFALSE 55133
// AddResourceType ( base , i , sources [ i ] ) ;
55106: LD_VAR 0 15
55110: PPUSH
55111: LD_VAR 0 8
55115: PPUSH
55116: LD_VAR 0 5
55120: PUSH
55121: LD_VAR 0 8
55125: ARRAY
55126: PPUSH
55127: CALL_OW 276
55131: GO 55103
55133: POP
55134: POP
// buildings := GetBaseBuildings ( base , area ) ;
55135: LD_ADDR_VAR 0 18
55139: PUSH
55140: LD_VAR 0 15
55144: PPUSH
55145: LD_VAR 0 2
55149: PPUSH
55150: CALL 54427 0 2
55154: ST_TO_ADDR
// InitHc ;
55155: CALL_OW 19
// InitUc ;
55159: CALL_OW 18
// uc_side := side ;
55163: LD_ADDR_OWVAR 20
55167: PUSH
55168: LD_VAR 0 16
55172: ST_TO_ADDR
// uc_nation := nation ;
55173: LD_ADDR_OWVAR 21
55177: PUSH
55178: LD_VAR 0 17
55182: ST_TO_ADDR
// if buildings then
55183: LD_VAR 0 18
55187: IFFALSE 56509
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
55189: LD_ADDR_VAR 0 19
55193: PUSH
55194: LD_VAR 0 18
55198: PPUSH
55199: LD_INT 2
55201: PUSH
55202: LD_INT 30
55204: PUSH
55205: LD_INT 29
55207: PUSH
55208: EMPTY
55209: LIST
55210: LIST
55211: PUSH
55212: LD_INT 30
55214: PUSH
55215: LD_INT 30
55217: PUSH
55218: EMPTY
55219: LIST
55220: LIST
55221: PUSH
55222: EMPTY
55223: LIST
55224: LIST
55225: LIST
55226: PPUSH
55227: CALL_OW 72
55231: ST_TO_ADDR
// if tmp then
55232: LD_VAR 0 19
55236: IFFALSE 55284
// for i in tmp do
55238: LD_ADDR_VAR 0 8
55242: PUSH
55243: LD_VAR 0 19
55247: PUSH
55248: FOR_IN
55249: IFFALSE 55282
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
55251: LD_VAR 0 8
55255: PPUSH
55256: CALL_OW 250
55260: PPUSH
55261: LD_VAR 0 8
55265: PPUSH
55266: CALL_OW 251
55270: PPUSH
55271: LD_VAR 0 16
55275: PPUSH
55276: CALL_OW 441
55280: GO 55248
55282: POP
55283: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
55284: LD_VAR 0 18
55288: PPUSH
55289: LD_INT 2
55291: PUSH
55292: LD_INT 30
55294: PUSH
55295: LD_INT 32
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: PUSH
55302: LD_INT 30
55304: PUSH
55305: LD_INT 33
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: PUSH
55312: EMPTY
55313: LIST
55314: LIST
55315: LIST
55316: PPUSH
55317: CALL_OW 72
55321: IFFALSE 55409
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
55323: LD_ADDR_VAR 0 8
55327: PUSH
55328: LD_VAR 0 18
55332: PPUSH
55333: LD_INT 2
55335: PUSH
55336: LD_INT 30
55338: PUSH
55339: LD_INT 32
55341: PUSH
55342: EMPTY
55343: LIST
55344: LIST
55345: PUSH
55346: LD_INT 30
55348: PUSH
55349: LD_INT 33
55351: PUSH
55352: EMPTY
55353: LIST
55354: LIST
55355: PUSH
55356: EMPTY
55357: LIST
55358: LIST
55359: LIST
55360: PPUSH
55361: CALL_OW 72
55365: PUSH
55366: FOR_IN
55367: IFFALSE 55407
// begin if not GetBWeapon ( i ) then
55369: LD_VAR 0 8
55373: PPUSH
55374: CALL_OW 269
55378: NOT
55379: IFFALSE 55405
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
55381: LD_VAR 0 8
55385: PPUSH
55386: LD_VAR 0 8
55390: PPUSH
55391: LD_VAR 0 2
55395: PPUSH
55396: CALL 56655 0 2
55400: PPUSH
55401: CALL_OW 431
// end ;
55405: GO 55366
55407: POP
55408: POP
// end ; for i = 1 to personel do
55409: LD_ADDR_VAR 0 8
55413: PUSH
55414: DOUBLE
55415: LD_INT 1
55417: DEC
55418: ST_TO_ADDR
55419: LD_VAR 0 6
55423: PUSH
55424: FOR_TO
55425: IFFALSE 56489
// begin if i > 4 then
55427: LD_VAR 0 8
55431: PUSH
55432: LD_INT 4
55434: GREATER
55435: IFFALSE 55439
// break ;
55437: GO 56489
// case i of 1 :
55439: LD_VAR 0 8
55443: PUSH
55444: LD_INT 1
55446: DOUBLE
55447: EQUAL
55448: IFTRUE 55452
55450: GO 55532
55452: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
55453: LD_ADDR_VAR 0 12
55457: PUSH
55458: LD_VAR 0 18
55462: PPUSH
55463: LD_INT 22
55465: PUSH
55466: LD_VAR 0 16
55470: PUSH
55471: EMPTY
55472: LIST
55473: LIST
55474: PUSH
55475: LD_INT 58
55477: PUSH
55478: EMPTY
55479: LIST
55480: PUSH
55481: LD_INT 2
55483: PUSH
55484: LD_INT 30
55486: PUSH
55487: LD_INT 32
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PUSH
55494: LD_INT 30
55496: PUSH
55497: LD_INT 4
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: PUSH
55504: LD_INT 30
55506: PUSH
55507: LD_INT 5
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: LIST
55518: LIST
55519: PUSH
55520: EMPTY
55521: LIST
55522: LIST
55523: LIST
55524: PPUSH
55525: CALL_OW 72
55529: ST_TO_ADDR
55530: GO 55754
55532: LD_INT 2
55534: DOUBLE
55535: EQUAL
55536: IFTRUE 55540
55538: GO 55602
55540: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
55541: LD_ADDR_VAR 0 12
55545: PUSH
55546: LD_VAR 0 18
55550: PPUSH
55551: LD_INT 22
55553: PUSH
55554: LD_VAR 0 16
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: PUSH
55563: LD_INT 2
55565: PUSH
55566: LD_INT 30
55568: PUSH
55569: LD_INT 0
55571: PUSH
55572: EMPTY
55573: LIST
55574: LIST
55575: PUSH
55576: LD_INT 30
55578: PUSH
55579: LD_INT 1
55581: PUSH
55582: EMPTY
55583: LIST
55584: LIST
55585: PUSH
55586: EMPTY
55587: LIST
55588: LIST
55589: LIST
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PPUSH
55595: CALL_OW 72
55599: ST_TO_ADDR
55600: GO 55754
55602: LD_INT 3
55604: DOUBLE
55605: EQUAL
55606: IFTRUE 55610
55608: GO 55672
55610: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
55611: LD_ADDR_VAR 0 12
55615: PUSH
55616: LD_VAR 0 18
55620: PPUSH
55621: LD_INT 22
55623: PUSH
55624: LD_VAR 0 16
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: PUSH
55633: LD_INT 2
55635: PUSH
55636: LD_INT 30
55638: PUSH
55639: LD_INT 2
55641: PUSH
55642: EMPTY
55643: LIST
55644: LIST
55645: PUSH
55646: LD_INT 30
55648: PUSH
55649: LD_INT 3
55651: PUSH
55652: EMPTY
55653: LIST
55654: LIST
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: LIST
55660: PUSH
55661: EMPTY
55662: LIST
55663: LIST
55664: PPUSH
55665: CALL_OW 72
55669: ST_TO_ADDR
55670: GO 55754
55672: LD_INT 4
55674: DOUBLE
55675: EQUAL
55676: IFTRUE 55680
55678: GO 55753
55680: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
55681: LD_ADDR_VAR 0 12
55685: PUSH
55686: LD_VAR 0 18
55690: PPUSH
55691: LD_INT 22
55693: PUSH
55694: LD_VAR 0 16
55698: PUSH
55699: EMPTY
55700: LIST
55701: LIST
55702: PUSH
55703: LD_INT 2
55705: PUSH
55706: LD_INT 30
55708: PUSH
55709: LD_INT 6
55711: PUSH
55712: EMPTY
55713: LIST
55714: LIST
55715: PUSH
55716: LD_INT 30
55718: PUSH
55719: LD_INT 7
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: PUSH
55726: LD_INT 30
55728: PUSH
55729: LD_INT 8
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PUSH
55736: EMPTY
55737: LIST
55738: LIST
55739: LIST
55740: LIST
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: PPUSH
55746: CALL_OW 72
55750: ST_TO_ADDR
55751: GO 55754
55753: POP
// if i = 1 then
55754: LD_VAR 0 8
55758: PUSH
55759: LD_INT 1
55761: EQUAL
55762: IFFALSE 55873
// begin tmp := [ ] ;
55764: LD_ADDR_VAR 0 19
55768: PUSH
55769: EMPTY
55770: ST_TO_ADDR
// for j in f do
55771: LD_ADDR_VAR 0 9
55775: PUSH
55776: LD_VAR 0 12
55780: PUSH
55781: FOR_IN
55782: IFFALSE 55855
// if GetBType ( j ) = b_bunker then
55784: LD_VAR 0 9
55788: PPUSH
55789: CALL_OW 266
55793: PUSH
55794: LD_INT 32
55796: EQUAL
55797: IFFALSE 55824
// tmp := Insert ( tmp , 1 , j ) else
55799: LD_ADDR_VAR 0 19
55803: PUSH
55804: LD_VAR 0 19
55808: PPUSH
55809: LD_INT 1
55811: PPUSH
55812: LD_VAR 0 9
55816: PPUSH
55817: CALL_OW 2
55821: ST_TO_ADDR
55822: GO 55853
// tmp := Insert ( tmp , tmp + 1 , j ) ;
55824: LD_ADDR_VAR 0 19
55828: PUSH
55829: LD_VAR 0 19
55833: PPUSH
55834: LD_VAR 0 19
55838: PUSH
55839: LD_INT 1
55841: PLUS
55842: PPUSH
55843: LD_VAR 0 9
55847: PPUSH
55848: CALL_OW 2
55852: ST_TO_ADDR
55853: GO 55781
55855: POP
55856: POP
// if tmp then
55857: LD_VAR 0 19
55861: IFFALSE 55873
// f := tmp ;
55863: LD_ADDR_VAR 0 12
55867: PUSH
55868: LD_VAR 0 19
55872: ST_TO_ADDR
// end ; x := personel [ i ] ;
55873: LD_ADDR_VAR 0 13
55877: PUSH
55878: LD_VAR 0 6
55882: PUSH
55883: LD_VAR 0 8
55887: ARRAY
55888: ST_TO_ADDR
// if x = - 1 then
55889: LD_VAR 0 13
55893: PUSH
55894: LD_INT 1
55896: NEG
55897: EQUAL
55898: IFFALSE 56107
// begin for j in f do
55900: LD_ADDR_VAR 0 9
55904: PUSH
55905: LD_VAR 0 12
55909: PUSH
55910: FOR_IN
55911: IFFALSE 56103
// repeat InitHc ;
55913: CALL_OW 19
// if GetBType ( j ) = b_barracks then
55917: LD_VAR 0 9
55921: PPUSH
55922: CALL_OW 266
55926: PUSH
55927: LD_INT 5
55929: EQUAL
55930: IFFALSE 56000
// begin if UnitsInside ( j ) < 3 then
55932: LD_VAR 0 9
55936: PPUSH
55937: CALL_OW 313
55941: PUSH
55942: LD_INT 3
55944: LESS
55945: IFFALSE 55981
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
55947: LD_INT 0
55949: PPUSH
55950: LD_INT 5
55952: PUSH
55953: LD_INT 8
55955: PUSH
55956: LD_INT 9
55958: PUSH
55959: EMPTY
55960: LIST
55961: LIST
55962: LIST
55963: PUSH
55964: LD_VAR 0 17
55968: ARRAY
55969: PPUSH
55970: LD_VAR 0 4
55974: PPUSH
55975: CALL_OW 380
55979: GO 55998
// PrepareHuman ( false , i , skill ) ;
55981: LD_INT 0
55983: PPUSH
55984: LD_VAR 0 8
55988: PPUSH
55989: LD_VAR 0 4
55993: PPUSH
55994: CALL_OW 380
// end else
55998: GO 56017
// PrepareHuman ( false , i , skill ) ;
56000: LD_INT 0
56002: PPUSH
56003: LD_VAR 0 8
56007: PPUSH
56008: LD_VAR 0 4
56012: PPUSH
56013: CALL_OW 380
// un := CreateHuman ;
56017: LD_ADDR_VAR 0 14
56021: PUSH
56022: CALL_OW 44
56026: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56027: LD_ADDR_VAR 0 7
56031: PUSH
56032: LD_VAR 0 7
56036: PPUSH
56037: LD_INT 1
56039: PPUSH
56040: LD_VAR 0 14
56044: PPUSH
56045: CALL_OW 2
56049: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
56050: LD_VAR 0 14
56054: PPUSH
56055: LD_VAR 0 9
56059: PPUSH
56060: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
56064: LD_VAR 0 9
56068: PPUSH
56069: CALL_OW 313
56073: PUSH
56074: LD_INT 6
56076: EQUAL
56077: PUSH
56078: LD_VAR 0 9
56082: PPUSH
56083: CALL_OW 266
56087: PUSH
56088: LD_INT 32
56090: PUSH
56091: LD_INT 31
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: IN
56098: OR
56099: IFFALSE 55913
56101: GO 55910
56103: POP
56104: POP
// end else
56105: GO 56487
// for j = 1 to x do
56107: LD_ADDR_VAR 0 9
56111: PUSH
56112: DOUBLE
56113: LD_INT 1
56115: DEC
56116: ST_TO_ADDR
56117: LD_VAR 0 13
56121: PUSH
56122: FOR_TO
56123: IFFALSE 56485
// begin InitHc ;
56125: CALL_OW 19
// if not f then
56129: LD_VAR 0 12
56133: NOT
56134: IFFALSE 56223
// begin PrepareHuman ( false , i , skill ) ;
56136: LD_INT 0
56138: PPUSH
56139: LD_VAR 0 8
56143: PPUSH
56144: LD_VAR 0 4
56148: PPUSH
56149: CALL_OW 380
// un := CreateHuman ;
56153: LD_ADDR_VAR 0 14
56157: PUSH
56158: CALL_OW 44
56162: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56163: LD_ADDR_VAR 0 7
56167: PUSH
56168: LD_VAR 0 7
56172: PPUSH
56173: LD_INT 1
56175: PPUSH
56176: LD_VAR 0 14
56180: PPUSH
56181: CALL_OW 2
56185: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
56186: LD_VAR 0 14
56190: PPUSH
56191: LD_VAR 0 1
56195: PPUSH
56196: CALL_OW 250
56200: PPUSH
56201: LD_VAR 0 1
56205: PPUSH
56206: CALL_OW 251
56210: PPUSH
56211: LD_INT 10
56213: PPUSH
56214: LD_INT 0
56216: PPUSH
56217: CALL_OW 50
// continue ;
56221: GO 56122
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
56223: LD_VAR 0 12
56227: PUSH
56228: LD_INT 1
56230: ARRAY
56231: PPUSH
56232: CALL_OW 313
56236: PUSH
56237: LD_VAR 0 12
56241: PUSH
56242: LD_INT 1
56244: ARRAY
56245: PPUSH
56246: CALL_OW 266
56250: PUSH
56251: LD_INT 32
56253: PUSH
56254: LD_INT 31
56256: PUSH
56257: EMPTY
56258: LIST
56259: LIST
56260: IN
56261: AND
56262: PUSH
56263: LD_VAR 0 12
56267: PUSH
56268: LD_INT 1
56270: ARRAY
56271: PPUSH
56272: CALL_OW 313
56276: PUSH
56277: LD_INT 6
56279: EQUAL
56280: OR
56281: IFFALSE 56301
// f := Delete ( f , 1 ) ;
56283: LD_ADDR_VAR 0 12
56287: PUSH
56288: LD_VAR 0 12
56292: PPUSH
56293: LD_INT 1
56295: PPUSH
56296: CALL_OW 3
56300: ST_TO_ADDR
// if not f then
56301: LD_VAR 0 12
56305: NOT
56306: IFFALSE 56324
// begin x := x + 2 ;
56308: LD_ADDR_VAR 0 13
56312: PUSH
56313: LD_VAR 0 13
56317: PUSH
56318: LD_INT 2
56320: PLUS
56321: ST_TO_ADDR
// continue ;
56322: GO 56122
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
56324: LD_VAR 0 12
56328: PUSH
56329: LD_INT 1
56331: ARRAY
56332: PPUSH
56333: CALL_OW 266
56337: PUSH
56338: LD_INT 5
56340: EQUAL
56341: IFFALSE 56415
// begin if UnitsInside ( f [ 1 ] ) < 3 then
56343: LD_VAR 0 12
56347: PUSH
56348: LD_INT 1
56350: ARRAY
56351: PPUSH
56352: CALL_OW 313
56356: PUSH
56357: LD_INT 3
56359: LESS
56360: IFFALSE 56396
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
56362: LD_INT 0
56364: PPUSH
56365: LD_INT 5
56367: PUSH
56368: LD_INT 8
56370: PUSH
56371: LD_INT 9
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: LIST
56378: PUSH
56379: LD_VAR 0 17
56383: ARRAY
56384: PPUSH
56385: LD_VAR 0 4
56389: PPUSH
56390: CALL_OW 380
56394: GO 56413
// PrepareHuman ( false , i , skill ) ;
56396: LD_INT 0
56398: PPUSH
56399: LD_VAR 0 8
56403: PPUSH
56404: LD_VAR 0 4
56408: PPUSH
56409: CALL_OW 380
// end else
56413: GO 56432
// PrepareHuman ( false , i , skill ) ;
56415: LD_INT 0
56417: PPUSH
56418: LD_VAR 0 8
56422: PPUSH
56423: LD_VAR 0 4
56427: PPUSH
56428: CALL_OW 380
// un := CreateHuman ;
56432: LD_ADDR_VAR 0 14
56436: PUSH
56437: CALL_OW 44
56441: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56442: LD_ADDR_VAR 0 7
56446: PUSH
56447: LD_VAR 0 7
56451: PPUSH
56452: LD_INT 1
56454: PPUSH
56455: LD_VAR 0 14
56459: PPUSH
56460: CALL_OW 2
56464: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
56465: LD_VAR 0 14
56469: PPUSH
56470: LD_VAR 0 12
56474: PUSH
56475: LD_INT 1
56477: ARRAY
56478: PPUSH
56479: CALL_OW 52
// end ;
56483: GO 56122
56485: POP
56486: POP
// end ;
56487: GO 55424
56489: POP
56490: POP
// result := result ^ buildings ;
56491: LD_ADDR_VAR 0 7
56495: PUSH
56496: LD_VAR 0 7
56500: PUSH
56501: LD_VAR 0 18
56505: ADD
56506: ST_TO_ADDR
// end else
56507: GO 56650
// begin for i = 1 to personel do
56509: LD_ADDR_VAR 0 8
56513: PUSH
56514: DOUBLE
56515: LD_INT 1
56517: DEC
56518: ST_TO_ADDR
56519: LD_VAR 0 6
56523: PUSH
56524: FOR_TO
56525: IFFALSE 56648
// begin if i > 4 then
56527: LD_VAR 0 8
56531: PUSH
56532: LD_INT 4
56534: GREATER
56535: IFFALSE 56539
// break ;
56537: GO 56648
// x := personel [ i ] ;
56539: LD_ADDR_VAR 0 13
56543: PUSH
56544: LD_VAR 0 6
56548: PUSH
56549: LD_VAR 0 8
56553: ARRAY
56554: ST_TO_ADDR
// if x = - 1 then
56555: LD_VAR 0 13
56559: PUSH
56560: LD_INT 1
56562: NEG
56563: EQUAL
56564: IFFALSE 56568
// continue ;
56566: GO 56524
// PrepareHuman ( false , i , skill ) ;
56568: LD_INT 0
56570: PPUSH
56571: LD_VAR 0 8
56575: PPUSH
56576: LD_VAR 0 4
56580: PPUSH
56581: CALL_OW 380
// un := CreateHuman ;
56585: LD_ADDR_VAR 0 14
56589: PUSH
56590: CALL_OW 44
56594: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
56595: LD_VAR 0 14
56599: PPUSH
56600: LD_VAR 0 1
56604: PPUSH
56605: CALL_OW 250
56609: PPUSH
56610: LD_VAR 0 1
56614: PPUSH
56615: CALL_OW 251
56619: PPUSH
56620: LD_INT 10
56622: PPUSH
56623: LD_INT 0
56625: PPUSH
56626: CALL_OW 50
// result := result ^ un ;
56630: LD_ADDR_VAR 0 7
56634: PUSH
56635: LD_VAR 0 7
56639: PUSH
56640: LD_VAR 0 14
56644: ADD
56645: ST_TO_ADDR
// end ;
56646: GO 56524
56648: POP
56649: POP
// end ; end ;
56650: LD_VAR 0 7
56654: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
56655: LD_INT 0
56657: PPUSH
56658: PPUSH
56659: PPUSH
56660: PPUSH
56661: PPUSH
56662: PPUSH
56663: PPUSH
56664: PPUSH
56665: PPUSH
56666: PPUSH
56667: PPUSH
56668: PPUSH
56669: PPUSH
56670: PPUSH
56671: PPUSH
56672: PPUSH
// result := false ;
56673: LD_ADDR_VAR 0 3
56677: PUSH
56678: LD_INT 0
56680: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
56681: LD_VAR 0 1
56685: NOT
56686: PUSH
56687: LD_VAR 0 1
56691: PPUSH
56692: CALL_OW 266
56696: PUSH
56697: LD_INT 32
56699: PUSH
56700: LD_INT 33
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: IN
56707: NOT
56708: OR
56709: IFFALSE 56713
// exit ;
56711: GO 57849
// nat := GetNation ( tower ) ;
56713: LD_ADDR_VAR 0 12
56717: PUSH
56718: LD_VAR 0 1
56722: PPUSH
56723: CALL_OW 248
56727: ST_TO_ADDR
// side := GetSide ( tower ) ;
56728: LD_ADDR_VAR 0 16
56732: PUSH
56733: LD_VAR 0 1
56737: PPUSH
56738: CALL_OW 255
56742: ST_TO_ADDR
// x := GetX ( tower ) ;
56743: LD_ADDR_VAR 0 10
56747: PUSH
56748: LD_VAR 0 1
56752: PPUSH
56753: CALL_OW 250
56757: ST_TO_ADDR
// y := GetY ( tower ) ;
56758: LD_ADDR_VAR 0 11
56762: PUSH
56763: LD_VAR 0 1
56767: PPUSH
56768: CALL_OW 251
56772: ST_TO_ADDR
// if not x or not y then
56773: LD_VAR 0 10
56777: NOT
56778: PUSH
56779: LD_VAR 0 11
56783: NOT
56784: OR
56785: IFFALSE 56789
// exit ;
56787: GO 57849
// weapon := 0 ;
56789: LD_ADDR_VAR 0 18
56793: PUSH
56794: LD_INT 0
56796: ST_TO_ADDR
// fac_list := [ ] ;
56797: LD_ADDR_VAR 0 17
56801: PUSH
56802: EMPTY
56803: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
56804: LD_ADDR_VAR 0 6
56808: PUSH
56809: LD_VAR 0 1
56813: PPUSH
56814: CALL_OW 274
56818: PPUSH
56819: LD_VAR 0 2
56823: PPUSH
56824: CALL 54427 0 2
56828: PPUSH
56829: LD_INT 30
56831: PUSH
56832: LD_INT 3
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: PPUSH
56839: CALL_OW 72
56843: ST_TO_ADDR
// if not factories then
56844: LD_VAR 0 6
56848: NOT
56849: IFFALSE 56853
// exit ;
56851: GO 57849
// for i in factories do
56853: LD_ADDR_VAR 0 8
56857: PUSH
56858: LD_VAR 0 6
56862: PUSH
56863: FOR_IN
56864: IFFALSE 56889
// fac_list := fac_list union AvailableWeaponList ( i ) ;
56866: LD_ADDR_VAR 0 17
56870: PUSH
56871: LD_VAR 0 17
56875: PUSH
56876: LD_VAR 0 8
56880: PPUSH
56881: CALL_OW 478
56885: UNION
56886: ST_TO_ADDR
56887: GO 56863
56889: POP
56890: POP
// if not fac_list then
56891: LD_VAR 0 17
56895: NOT
56896: IFFALSE 56900
// exit ;
56898: GO 57849
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
56900: LD_ADDR_VAR 0 5
56904: PUSH
56905: LD_INT 4
56907: PUSH
56908: LD_INT 5
56910: PUSH
56911: LD_INT 9
56913: PUSH
56914: LD_INT 10
56916: PUSH
56917: LD_INT 6
56919: PUSH
56920: LD_INT 7
56922: PUSH
56923: LD_INT 11
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: LIST
56930: LIST
56931: LIST
56932: LIST
56933: LIST
56934: PUSH
56935: LD_INT 27
56937: PUSH
56938: LD_INT 28
56940: PUSH
56941: LD_INT 26
56943: PUSH
56944: LD_INT 30
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: LIST
56951: LIST
56952: PUSH
56953: LD_INT 43
56955: PUSH
56956: LD_INT 44
56958: PUSH
56959: LD_INT 46
56961: PUSH
56962: LD_INT 45
56964: PUSH
56965: LD_INT 47
56967: PUSH
56968: LD_INT 49
56970: PUSH
56971: EMPTY
56972: LIST
56973: LIST
56974: LIST
56975: LIST
56976: LIST
56977: LIST
56978: PUSH
56979: EMPTY
56980: LIST
56981: LIST
56982: LIST
56983: PUSH
56984: LD_VAR 0 12
56988: ARRAY
56989: ST_TO_ADDR
// for i in list do
56990: LD_ADDR_VAR 0 8
56994: PUSH
56995: LD_VAR 0 5
56999: PUSH
57000: FOR_IN
57001: IFFALSE 57034
// if not i in fac_list then
57003: LD_VAR 0 8
57007: PUSH
57008: LD_VAR 0 17
57012: IN
57013: NOT
57014: IFFALSE 57032
// list := list diff i ;
57016: LD_ADDR_VAR 0 5
57020: PUSH
57021: LD_VAR 0 5
57025: PUSH
57026: LD_VAR 0 8
57030: DIFF
57031: ST_TO_ADDR
57032: GO 57000
57034: POP
57035: POP
// if not list then
57036: LD_VAR 0 5
57040: NOT
57041: IFFALSE 57045
// exit ;
57043: GO 57849
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
57045: LD_VAR 0 12
57049: PUSH
57050: LD_INT 3
57052: EQUAL
57053: PUSH
57054: LD_INT 49
57056: PUSH
57057: LD_VAR 0 5
57061: IN
57062: AND
57063: PUSH
57064: LD_INT 31
57066: PPUSH
57067: LD_VAR 0 16
57071: PPUSH
57072: CALL_OW 321
57076: PUSH
57077: LD_INT 2
57079: EQUAL
57080: AND
57081: IFFALSE 57141
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
57083: LD_INT 22
57085: PUSH
57086: LD_VAR 0 16
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: LD_INT 35
57097: PUSH
57098: LD_INT 49
57100: PUSH
57101: EMPTY
57102: LIST
57103: LIST
57104: PUSH
57105: LD_INT 91
57107: PUSH
57108: LD_VAR 0 1
57112: PUSH
57113: LD_INT 10
57115: PUSH
57116: EMPTY
57117: LIST
57118: LIST
57119: LIST
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: LIST
57125: PPUSH
57126: CALL_OW 69
57130: NOT
57131: IFFALSE 57141
// weapon := ru_time_lapser ;
57133: LD_ADDR_VAR 0 18
57137: PUSH
57138: LD_INT 49
57140: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
57141: LD_VAR 0 12
57145: PUSH
57146: LD_INT 1
57148: PUSH
57149: LD_INT 2
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: IN
57156: PUSH
57157: LD_INT 11
57159: PUSH
57160: LD_VAR 0 5
57164: IN
57165: PUSH
57166: LD_INT 30
57168: PUSH
57169: LD_VAR 0 5
57173: IN
57174: OR
57175: AND
57176: PUSH
57177: LD_INT 6
57179: PPUSH
57180: LD_VAR 0 16
57184: PPUSH
57185: CALL_OW 321
57189: PUSH
57190: LD_INT 2
57192: EQUAL
57193: AND
57194: IFFALSE 57359
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
57196: LD_INT 22
57198: PUSH
57199: LD_VAR 0 16
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: LD_INT 2
57210: PUSH
57211: LD_INT 35
57213: PUSH
57214: LD_INT 11
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: PUSH
57221: LD_INT 35
57223: PUSH
57224: LD_INT 30
57226: PUSH
57227: EMPTY
57228: LIST
57229: LIST
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: LIST
57235: PUSH
57236: LD_INT 91
57238: PUSH
57239: LD_VAR 0 1
57243: PUSH
57244: LD_INT 18
57246: PUSH
57247: EMPTY
57248: LIST
57249: LIST
57250: LIST
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: LIST
57256: PPUSH
57257: CALL_OW 69
57261: NOT
57262: PUSH
57263: LD_INT 22
57265: PUSH
57266: LD_VAR 0 16
57270: PUSH
57271: EMPTY
57272: LIST
57273: LIST
57274: PUSH
57275: LD_INT 2
57277: PUSH
57278: LD_INT 30
57280: PUSH
57281: LD_INT 32
57283: PUSH
57284: EMPTY
57285: LIST
57286: LIST
57287: PUSH
57288: LD_INT 30
57290: PUSH
57291: LD_INT 33
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: LIST
57302: PUSH
57303: LD_INT 91
57305: PUSH
57306: LD_VAR 0 1
57310: PUSH
57311: LD_INT 12
57313: PUSH
57314: EMPTY
57315: LIST
57316: LIST
57317: LIST
57318: PUSH
57319: EMPTY
57320: LIST
57321: LIST
57322: LIST
57323: PUSH
57324: EMPTY
57325: LIST
57326: PPUSH
57327: CALL_OW 69
57331: PUSH
57332: LD_INT 2
57334: GREATER
57335: AND
57336: IFFALSE 57359
// weapon := [ us_radar , ar_radar ] [ nat ] ;
57338: LD_ADDR_VAR 0 18
57342: PUSH
57343: LD_INT 11
57345: PUSH
57346: LD_INT 30
57348: PUSH
57349: EMPTY
57350: LIST
57351: LIST
57352: PUSH
57353: LD_VAR 0 12
57357: ARRAY
57358: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
57359: LD_VAR 0 18
57363: NOT
57364: PUSH
57365: LD_INT 40
57367: PPUSH
57368: LD_VAR 0 16
57372: PPUSH
57373: CALL_OW 321
57377: PUSH
57378: LD_INT 2
57380: EQUAL
57381: AND
57382: PUSH
57383: LD_INT 7
57385: PUSH
57386: LD_VAR 0 5
57390: IN
57391: PUSH
57392: LD_INT 28
57394: PUSH
57395: LD_VAR 0 5
57399: IN
57400: OR
57401: PUSH
57402: LD_INT 45
57404: PUSH
57405: LD_VAR 0 5
57409: IN
57410: OR
57411: AND
57412: IFFALSE 57666
// begin hex := GetHexInfo ( x , y ) ;
57414: LD_ADDR_VAR 0 4
57418: PUSH
57419: LD_VAR 0 10
57423: PPUSH
57424: LD_VAR 0 11
57428: PPUSH
57429: CALL_OW 546
57433: ST_TO_ADDR
// if hex [ 1 ] then
57434: LD_VAR 0 4
57438: PUSH
57439: LD_INT 1
57441: ARRAY
57442: IFFALSE 57446
// exit ;
57444: GO 57849
// height := hex [ 2 ] ;
57446: LD_ADDR_VAR 0 15
57450: PUSH
57451: LD_VAR 0 4
57455: PUSH
57456: LD_INT 2
57458: ARRAY
57459: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
57460: LD_ADDR_VAR 0 14
57464: PUSH
57465: LD_INT 0
57467: PUSH
57468: LD_INT 2
57470: PUSH
57471: LD_INT 3
57473: PUSH
57474: LD_INT 5
57476: PUSH
57477: EMPTY
57478: LIST
57479: LIST
57480: LIST
57481: LIST
57482: ST_TO_ADDR
// for i in tmp do
57483: LD_ADDR_VAR 0 8
57487: PUSH
57488: LD_VAR 0 14
57492: PUSH
57493: FOR_IN
57494: IFFALSE 57664
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
57496: LD_ADDR_VAR 0 9
57500: PUSH
57501: LD_VAR 0 10
57505: PPUSH
57506: LD_VAR 0 8
57510: PPUSH
57511: LD_INT 5
57513: PPUSH
57514: CALL_OW 272
57518: PUSH
57519: LD_VAR 0 11
57523: PPUSH
57524: LD_VAR 0 8
57528: PPUSH
57529: LD_INT 5
57531: PPUSH
57532: CALL_OW 273
57536: PUSH
57537: EMPTY
57538: LIST
57539: LIST
57540: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
57541: LD_VAR 0 9
57545: PUSH
57546: LD_INT 1
57548: ARRAY
57549: PPUSH
57550: LD_VAR 0 9
57554: PUSH
57555: LD_INT 2
57557: ARRAY
57558: PPUSH
57559: CALL_OW 488
57563: IFFALSE 57662
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
57565: LD_ADDR_VAR 0 4
57569: PUSH
57570: LD_VAR 0 9
57574: PUSH
57575: LD_INT 1
57577: ARRAY
57578: PPUSH
57579: LD_VAR 0 9
57583: PUSH
57584: LD_INT 2
57586: ARRAY
57587: PPUSH
57588: CALL_OW 546
57592: ST_TO_ADDR
// if hex [ 1 ] then
57593: LD_VAR 0 4
57597: PUSH
57598: LD_INT 1
57600: ARRAY
57601: IFFALSE 57605
// continue ;
57603: GO 57493
// h := hex [ 2 ] ;
57605: LD_ADDR_VAR 0 13
57609: PUSH
57610: LD_VAR 0 4
57614: PUSH
57615: LD_INT 2
57617: ARRAY
57618: ST_TO_ADDR
// if h + 7 < height then
57619: LD_VAR 0 13
57623: PUSH
57624: LD_INT 7
57626: PLUS
57627: PUSH
57628: LD_VAR 0 15
57632: LESS
57633: IFFALSE 57662
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
57635: LD_ADDR_VAR 0 18
57639: PUSH
57640: LD_INT 7
57642: PUSH
57643: LD_INT 28
57645: PUSH
57646: LD_INT 45
57648: PUSH
57649: EMPTY
57650: LIST
57651: LIST
57652: LIST
57653: PUSH
57654: LD_VAR 0 12
57658: ARRAY
57659: ST_TO_ADDR
// break ;
57660: GO 57664
// end ; end ; end ;
57662: GO 57493
57664: POP
57665: POP
// end ; if not weapon then
57666: LD_VAR 0 18
57670: NOT
57671: IFFALSE 57731
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
57673: LD_ADDR_VAR 0 5
57677: PUSH
57678: LD_VAR 0 5
57682: PUSH
57683: LD_INT 11
57685: PUSH
57686: LD_INT 30
57688: PUSH
57689: LD_INT 49
57691: PUSH
57692: EMPTY
57693: LIST
57694: LIST
57695: LIST
57696: DIFF
57697: ST_TO_ADDR
// if not list then
57698: LD_VAR 0 5
57702: NOT
57703: IFFALSE 57707
// exit ;
57705: GO 57849
// weapon := list [ rand ( 1 , list ) ] ;
57707: LD_ADDR_VAR 0 18
57711: PUSH
57712: LD_VAR 0 5
57716: PUSH
57717: LD_INT 1
57719: PPUSH
57720: LD_VAR 0 5
57724: PPUSH
57725: CALL_OW 12
57729: ARRAY
57730: ST_TO_ADDR
// end ; if weapon then
57731: LD_VAR 0 18
57735: IFFALSE 57849
// begin tmp := CostOfWeapon ( weapon ) ;
57737: LD_ADDR_VAR 0 14
57741: PUSH
57742: LD_VAR 0 18
57746: PPUSH
57747: CALL_OW 451
57751: ST_TO_ADDR
// j := GetBase ( tower ) ;
57752: LD_ADDR_VAR 0 9
57756: PUSH
57757: LD_VAR 0 1
57761: PPUSH
57762: CALL_OW 274
57766: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
57767: LD_VAR 0 9
57771: PPUSH
57772: LD_INT 1
57774: PPUSH
57775: CALL_OW 275
57779: PUSH
57780: LD_VAR 0 14
57784: PUSH
57785: LD_INT 1
57787: ARRAY
57788: GREATEREQUAL
57789: PUSH
57790: LD_VAR 0 9
57794: PPUSH
57795: LD_INT 2
57797: PPUSH
57798: CALL_OW 275
57802: PUSH
57803: LD_VAR 0 14
57807: PUSH
57808: LD_INT 2
57810: ARRAY
57811: GREATEREQUAL
57812: AND
57813: PUSH
57814: LD_VAR 0 9
57818: PPUSH
57819: LD_INT 3
57821: PPUSH
57822: CALL_OW 275
57826: PUSH
57827: LD_VAR 0 14
57831: PUSH
57832: LD_INT 3
57834: ARRAY
57835: GREATEREQUAL
57836: AND
57837: IFFALSE 57849
// result := weapon ;
57839: LD_ADDR_VAR 0 3
57843: PUSH
57844: LD_VAR 0 18
57848: ST_TO_ADDR
// end ; end ;
57849: LD_VAR 0 3
57853: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
57854: LD_INT 0
57856: PPUSH
57857: PPUSH
// result := true ;
57858: LD_ADDR_VAR 0 3
57862: PUSH
57863: LD_INT 1
57865: ST_TO_ADDR
// if array1 = array2 then
57866: LD_VAR 0 1
57870: PUSH
57871: LD_VAR 0 2
57875: EQUAL
57876: IFFALSE 57936
// begin for i = 1 to array1 do
57878: LD_ADDR_VAR 0 4
57882: PUSH
57883: DOUBLE
57884: LD_INT 1
57886: DEC
57887: ST_TO_ADDR
57888: LD_VAR 0 1
57892: PUSH
57893: FOR_TO
57894: IFFALSE 57932
// if array1 [ i ] <> array2 [ i ] then
57896: LD_VAR 0 1
57900: PUSH
57901: LD_VAR 0 4
57905: ARRAY
57906: PUSH
57907: LD_VAR 0 2
57911: PUSH
57912: LD_VAR 0 4
57916: ARRAY
57917: NONEQUAL
57918: IFFALSE 57930
// begin result := false ;
57920: LD_ADDR_VAR 0 3
57924: PUSH
57925: LD_INT 0
57927: ST_TO_ADDR
// break ;
57928: GO 57932
// end ;
57930: GO 57893
57932: POP
57933: POP
// end else
57934: GO 57944
// result := false ;
57936: LD_ADDR_VAR 0 3
57940: PUSH
57941: LD_INT 0
57943: ST_TO_ADDR
// end ;
57944: LD_VAR 0 3
57948: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
57949: LD_INT 0
57951: PPUSH
57952: PPUSH
57953: PPUSH
// pom := GetBase ( fac ) ;
57954: LD_ADDR_VAR 0 5
57958: PUSH
57959: LD_VAR 0 1
57963: PPUSH
57964: CALL_OW 274
57968: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
57969: LD_ADDR_VAR 0 4
57973: PUSH
57974: LD_VAR 0 2
57978: PUSH
57979: LD_INT 1
57981: ARRAY
57982: PPUSH
57983: LD_VAR 0 2
57987: PUSH
57988: LD_INT 2
57990: ARRAY
57991: PPUSH
57992: LD_VAR 0 2
57996: PUSH
57997: LD_INT 3
57999: ARRAY
58000: PPUSH
58001: LD_VAR 0 2
58005: PUSH
58006: LD_INT 4
58008: ARRAY
58009: PPUSH
58010: CALL_OW 449
58014: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58015: LD_ADDR_VAR 0 3
58019: PUSH
58020: LD_VAR 0 5
58024: PPUSH
58025: LD_INT 1
58027: PPUSH
58028: CALL_OW 275
58032: PUSH
58033: LD_VAR 0 4
58037: PUSH
58038: LD_INT 1
58040: ARRAY
58041: GREATEREQUAL
58042: PUSH
58043: LD_VAR 0 5
58047: PPUSH
58048: LD_INT 2
58050: PPUSH
58051: CALL_OW 275
58055: PUSH
58056: LD_VAR 0 4
58060: PUSH
58061: LD_INT 2
58063: ARRAY
58064: GREATEREQUAL
58065: AND
58066: PUSH
58067: LD_VAR 0 5
58071: PPUSH
58072: LD_INT 3
58074: PPUSH
58075: CALL_OW 275
58079: PUSH
58080: LD_VAR 0 4
58084: PUSH
58085: LD_INT 3
58087: ARRAY
58088: GREATEREQUAL
58089: AND
58090: ST_TO_ADDR
// end ;
58091: LD_VAR 0 3
58095: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
58096: LD_INT 0
58098: PPUSH
58099: PPUSH
58100: PPUSH
58101: PPUSH
// pom := GetBase ( building ) ;
58102: LD_ADDR_VAR 0 3
58106: PUSH
58107: LD_VAR 0 1
58111: PPUSH
58112: CALL_OW 274
58116: ST_TO_ADDR
// if not pom then
58117: LD_VAR 0 3
58121: NOT
58122: IFFALSE 58126
// exit ;
58124: GO 58296
// btype := GetBType ( building ) ;
58126: LD_ADDR_VAR 0 5
58130: PUSH
58131: LD_VAR 0 1
58135: PPUSH
58136: CALL_OW 266
58140: ST_TO_ADDR
// if btype = b_armoury then
58141: LD_VAR 0 5
58145: PUSH
58146: LD_INT 4
58148: EQUAL
58149: IFFALSE 58159
// btype := b_barracks ;
58151: LD_ADDR_VAR 0 5
58155: PUSH
58156: LD_INT 5
58158: ST_TO_ADDR
// if btype = b_depot then
58159: LD_VAR 0 5
58163: PUSH
58164: LD_INT 0
58166: EQUAL
58167: IFFALSE 58177
// btype := b_warehouse ;
58169: LD_ADDR_VAR 0 5
58173: PUSH
58174: LD_INT 1
58176: ST_TO_ADDR
// if btype = b_workshop then
58177: LD_VAR 0 5
58181: PUSH
58182: LD_INT 2
58184: EQUAL
58185: IFFALSE 58195
// btype := b_factory ;
58187: LD_ADDR_VAR 0 5
58191: PUSH
58192: LD_INT 3
58194: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58195: LD_ADDR_VAR 0 4
58199: PUSH
58200: LD_VAR 0 5
58204: PPUSH
58205: LD_VAR 0 1
58209: PPUSH
58210: CALL_OW 248
58214: PPUSH
58215: CALL_OW 450
58219: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58220: LD_ADDR_VAR 0 2
58224: PUSH
58225: LD_VAR 0 3
58229: PPUSH
58230: LD_INT 1
58232: PPUSH
58233: CALL_OW 275
58237: PUSH
58238: LD_VAR 0 4
58242: PUSH
58243: LD_INT 1
58245: ARRAY
58246: GREATEREQUAL
58247: PUSH
58248: LD_VAR 0 3
58252: PPUSH
58253: LD_INT 2
58255: PPUSH
58256: CALL_OW 275
58260: PUSH
58261: LD_VAR 0 4
58265: PUSH
58266: LD_INT 2
58268: ARRAY
58269: GREATEREQUAL
58270: AND
58271: PUSH
58272: LD_VAR 0 3
58276: PPUSH
58277: LD_INT 3
58279: PPUSH
58280: CALL_OW 275
58284: PUSH
58285: LD_VAR 0 4
58289: PUSH
58290: LD_INT 3
58292: ARRAY
58293: GREATEREQUAL
58294: AND
58295: ST_TO_ADDR
// end ;
58296: LD_VAR 0 2
58300: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
58301: LD_INT 0
58303: PPUSH
58304: PPUSH
58305: PPUSH
// pom := GetBase ( building ) ;
58306: LD_ADDR_VAR 0 4
58310: PUSH
58311: LD_VAR 0 1
58315: PPUSH
58316: CALL_OW 274
58320: ST_TO_ADDR
// if not pom then
58321: LD_VAR 0 4
58325: NOT
58326: IFFALSE 58330
// exit ;
58328: GO 58431
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58330: LD_ADDR_VAR 0 5
58334: PUSH
58335: LD_VAR 0 2
58339: PPUSH
58340: LD_VAR 0 1
58344: PPUSH
58345: CALL_OW 248
58349: PPUSH
58350: CALL_OW 450
58354: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58355: LD_ADDR_VAR 0 3
58359: PUSH
58360: LD_VAR 0 4
58364: PPUSH
58365: LD_INT 1
58367: PPUSH
58368: CALL_OW 275
58372: PUSH
58373: LD_VAR 0 5
58377: PUSH
58378: LD_INT 1
58380: ARRAY
58381: GREATEREQUAL
58382: PUSH
58383: LD_VAR 0 4
58387: PPUSH
58388: LD_INT 2
58390: PPUSH
58391: CALL_OW 275
58395: PUSH
58396: LD_VAR 0 5
58400: PUSH
58401: LD_INT 2
58403: ARRAY
58404: GREATEREQUAL
58405: AND
58406: PUSH
58407: LD_VAR 0 4
58411: PPUSH
58412: LD_INT 3
58414: PPUSH
58415: CALL_OW 275
58419: PUSH
58420: LD_VAR 0 5
58424: PUSH
58425: LD_INT 3
58427: ARRAY
58428: GREATEREQUAL
58429: AND
58430: ST_TO_ADDR
// end ;
58431: LD_VAR 0 3
58435: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
58436: LD_INT 0
58438: PPUSH
58439: PPUSH
58440: PPUSH
58441: PPUSH
58442: PPUSH
58443: PPUSH
58444: PPUSH
58445: PPUSH
58446: PPUSH
58447: PPUSH
// result := false ;
58448: LD_ADDR_VAR 0 6
58452: PUSH
58453: LD_INT 0
58455: ST_TO_ADDR
// if not base or not btype or not x or not y then
58456: LD_VAR 0 1
58460: NOT
58461: PUSH
58462: LD_VAR 0 2
58466: NOT
58467: OR
58468: PUSH
58469: LD_VAR 0 3
58473: NOT
58474: OR
58475: PUSH
58476: LD_VAR 0 4
58480: NOT
58481: OR
58482: IFFALSE 58486
// exit ;
58484: GO 59077
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
58486: LD_ADDR_VAR 0 12
58490: PUSH
58491: LD_VAR 0 2
58495: PPUSH
58496: LD_VAR 0 3
58500: PPUSH
58501: LD_VAR 0 4
58505: PPUSH
58506: LD_VAR 0 5
58510: PPUSH
58511: LD_VAR 0 1
58515: PUSH
58516: LD_INT 1
58518: ARRAY
58519: PPUSH
58520: CALL_OW 248
58524: PPUSH
58525: LD_INT 0
58527: PPUSH
58528: CALL 59914 0 6
58532: ST_TO_ADDR
// if not hexes then
58533: LD_VAR 0 12
58537: NOT
58538: IFFALSE 58542
// exit ;
58540: GO 59077
// for i = 1 to hexes do
58542: LD_ADDR_VAR 0 7
58546: PUSH
58547: DOUBLE
58548: LD_INT 1
58550: DEC
58551: ST_TO_ADDR
58552: LD_VAR 0 12
58556: PUSH
58557: FOR_TO
58558: IFFALSE 59075
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
58560: LD_ADDR_VAR 0 11
58564: PUSH
58565: LD_VAR 0 12
58569: PUSH
58570: LD_VAR 0 7
58574: ARRAY
58575: PUSH
58576: LD_INT 1
58578: ARRAY
58579: PPUSH
58580: LD_VAR 0 12
58584: PUSH
58585: LD_VAR 0 7
58589: ARRAY
58590: PUSH
58591: LD_INT 2
58593: ARRAY
58594: PPUSH
58595: CALL_OW 428
58599: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
58600: LD_VAR 0 12
58604: PUSH
58605: LD_VAR 0 7
58609: ARRAY
58610: PUSH
58611: LD_INT 1
58613: ARRAY
58614: PPUSH
58615: LD_VAR 0 12
58619: PUSH
58620: LD_VAR 0 7
58624: ARRAY
58625: PUSH
58626: LD_INT 2
58628: ARRAY
58629: PPUSH
58630: CALL_OW 351
58634: PUSH
58635: LD_VAR 0 12
58639: PUSH
58640: LD_VAR 0 7
58644: ARRAY
58645: PUSH
58646: LD_INT 1
58648: ARRAY
58649: PPUSH
58650: LD_VAR 0 12
58654: PUSH
58655: LD_VAR 0 7
58659: ARRAY
58660: PUSH
58661: LD_INT 2
58663: ARRAY
58664: PPUSH
58665: CALL_OW 488
58669: NOT
58670: OR
58671: PUSH
58672: LD_VAR 0 11
58676: PPUSH
58677: CALL_OW 247
58681: PUSH
58682: LD_INT 3
58684: EQUAL
58685: OR
58686: IFFALSE 58692
// exit ;
58688: POP
58689: POP
58690: GO 59077
// if not tmp then
58692: LD_VAR 0 11
58696: NOT
58697: IFFALSE 58701
// continue ;
58699: GO 58557
// result := true ;
58701: LD_ADDR_VAR 0 6
58705: PUSH
58706: LD_INT 1
58708: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
58709: LD_ADDR_VAR 0 15
58713: PUSH
58714: LD_INT 22
58716: PUSH
58717: LD_VAR 0 11
58721: PPUSH
58722: CALL_OW 255
58726: PUSH
58727: EMPTY
58728: LIST
58729: LIST
58730: PUSH
58731: LD_INT 2
58733: PUSH
58734: LD_INT 30
58736: PUSH
58737: LD_INT 0
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: PUSH
58744: LD_INT 30
58746: PUSH
58747: LD_INT 1
58749: PUSH
58750: EMPTY
58751: LIST
58752: LIST
58753: PUSH
58754: EMPTY
58755: LIST
58756: LIST
58757: LIST
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PPUSH
58763: CALL_OW 69
58767: ST_TO_ADDR
// if dep then
58768: LD_VAR 0 15
58772: IFFALSE 58908
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
58774: LD_ADDR_VAR 0 14
58778: PUSH
58779: LD_VAR 0 15
58783: PUSH
58784: LD_INT 1
58786: ARRAY
58787: PPUSH
58788: CALL_OW 250
58792: PPUSH
58793: LD_VAR 0 15
58797: PUSH
58798: LD_INT 1
58800: ARRAY
58801: PPUSH
58802: CALL_OW 254
58806: PPUSH
58807: LD_INT 5
58809: PPUSH
58810: CALL_OW 272
58814: PUSH
58815: LD_VAR 0 15
58819: PUSH
58820: LD_INT 1
58822: ARRAY
58823: PPUSH
58824: CALL_OW 251
58828: PPUSH
58829: LD_VAR 0 15
58833: PUSH
58834: LD_INT 1
58836: ARRAY
58837: PPUSH
58838: CALL_OW 254
58842: PPUSH
58843: LD_INT 5
58845: PPUSH
58846: CALL_OW 273
58850: PUSH
58851: EMPTY
58852: LIST
58853: LIST
58854: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
58855: LD_VAR 0 14
58859: PUSH
58860: LD_INT 1
58862: ARRAY
58863: PPUSH
58864: LD_VAR 0 14
58868: PUSH
58869: LD_INT 2
58871: ARRAY
58872: PPUSH
58873: CALL_OW 488
58877: IFFALSE 58908
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
58879: LD_VAR 0 11
58883: PPUSH
58884: LD_VAR 0 14
58888: PUSH
58889: LD_INT 1
58891: ARRAY
58892: PPUSH
58893: LD_VAR 0 14
58897: PUSH
58898: LD_INT 2
58900: ARRAY
58901: PPUSH
58902: CALL_OW 111
// continue ;
58906: GO 58557
// end ; end ; r := GetDir ( tmp ) ;
58908: LD_ADDR_VAR 0 13
58912: PUSH
58913: LD_VAR 0 11
58917: PPUSH
58918: CALL_OW 254
58922: ST_TO_ADDR
// if r = 5 then
58923: LD_VAR 0 13
58927: PUSH
58928: LD_INT 5
58930: EQUAL
58931: IFFALSE 58941
// r := 0 ;
58933: LD_ADDR_VAR 0 13
58937: PUSH
58938: LD_INT 0
58940: ST_TO_ADDR
// for j = r to 5 do
58941: LD_ADDR_VAR 0 8
58945: PUSH
58946: DOUBLE
58947: LD_VAR 0 13
58951: DEC
58952: ST_TO_ADDR
58953: LD_INT 5
58955: PUSH
58956: FOR_TO
58957: IFFALSE 59071
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
58959: LD_ADDR_VAR 0 9
58963: PUSH
58964: LD_VAR 0 11
58968: PPUSH
58969: CALL_OW 250
58973: PPUSH
58974: LD_VAR 0 8
58978: PPUSH
58979: LD_INT 2
58981: PPUSH
58982: CALL_OW 272
58986: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
58987: LD_ADDR_VAR 0 10
58991: PUSH
58992: LD_VAR 0 11
58996: PPUSH
58997: CALL_OW 251
59001: PPUSH
59002: LD_VAR 0 8
59006: PPUSH
59007: LD_INT 2
59009: PPUSH
59010: CALL_OW 273
59014: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
59015: LD_VAR 0 9
59019: PPUSH
59020: LD_VAR 0 10
59024: PPUSH
59025: CALL_OW 488
59029: PUSH
59030: LD_VAR 0 9
59034: PPUSH
59035: LD_VAR 0 10
59039: PPUSH
59040: CALL_OW 428
59044: NOT
59045: AND
59046: IFFALSE 59069
// begin ComMoveXY ( tmp , _x , _y ) ;
59048: LD_VAR 0 11
59052: PPUSH
59053: LD_VAR 0 9
59057: PPUSH
59058: LD_VAR 0 10
59062: PPUSH
59063: CALL_OW 111
// break ;
59067: GO 59071
// end ; end ;
59069: GO 58956
59071: POP
59072: POP
// end ;
59073: GO 58557
59075: POP
59076: POP
// end ;
59077: LD_VAR 0 6
59081: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
59082: LD_INT 0
59084: PPUSH
59085: PPUSH
59086: PPUSH
59087: PPUSH
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
// result := false ;
59094: LD_ADDR_VAR 0 6
59098: PUSH
59099: LD_INT 0
59101: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
59102: LD_VAR 0 1
59106: NOT
59107: PUSH
59108: LD_VAR 0 1
59112: PPUSH
59113: CALL_OW 266
59117: PUSH
59118: LD_INT 0
59120: PUSH
59121: LD_INT 1
59123: PUSH
59124: EMPTY
59125: LIST
59126: LIST
59127: IN
59128: NOT
59129: OR
59130: PUSH
59131: LD_VAR 0 2
59135: NOT
59136: OR
59137: PUSH
59138: LD_VAR 0 5
59142: PUSH
59143: LD_INT 0
59145: PUSH
59146: LD_INT 1
59148: PUSH
59149: LD_INT 2
59151: PUSH
59152: LD_INT 3
59154: PUSH
59155: LD_INT 4
59157: PUSH
59158: LD_INT 5
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: LIST
59165: LIST
59166: LIST
59167: LIST
59168: IN
59169: NOT
59170: OR
59171: PUSH
59172: LD_VAR 0 3
59176: PPUSH
59177: LD_VAR 0 4
59181: PPUSH
59182: CALL_OW 488
59186: NOT
59187: OR
59188: IFFALSE 59192
// exit ;
59190: GO 59909
// pom := GetBase ( bdepot ) ;
59192: LD_ADDR_VAR 0 10
59196: PUSH
59197: LD_VAR 0 1
59201: PPUSH
59202: CALL_OW 274
59206: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
59207: LD_ADDR_VAR 0 11
59211: PUSH
59212: LD_VAR 0 2
59216: PPUSH
59217: LD_VAR 0 1
59221: PPUSH
59222: CALL_OW 248
59226: PPUSH
59227: CALL_OW 450
59231: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
59232: LD_VAR 0 10
59236: PPUSH
59237: LD_INT 1
59239: PPUSH
59240: CALL_OW 275
59244: PUSH
59245: LD_VAR 0 11
59249: PUSH
59250: LD_INT 1
59252: ARRAY
59253: GREATEREQUAL
59254: PUSH
59255: LD_VAR 0 10
59259: PPUSH
59260: LD_INT 2
59262: PPUSH
59263: CALL_OW 275
59267: PUSH
59268: LD_VAR 0 11
59272: PUSH
59273: LD_INT 2
59275: ARRAY
59276: GREATEREQUAL
59277: AND
59278: PUSH
59279: LD_VAR 0 10
59283: PPUSH
59284: LD_INT 3
59286: PPUSH
59287: CALL_OW 275
59291: PUSH
59292: LD_VAR 0 11
59296: PUSH
59297: LD_INT 3
59299: ARRAY
59300: GREATEREQUAL
59301: AND
59302: NOT
59303: IFFALSE 59307
// exit ;
59305: GO 59909
// if GetBType ( bdepot ) = b_depot then
59307: LD_VAR 0 1
59311: PPUSH
59312: CALL_OW 266
59316: PUSH
59317: LD_INT 0
59319: EQUAL
59320: IFFALSE 59332
// dist := 28 else
59322: LD_ADDR_VAR 0 14
59326: PUSH
59327: LD_INT 28
59329: ST_TO_ADDR
59330: GO 59340
// dist := 36 ;
59332: LD_ADDR_VAR 0 14
59336: PUSH
59337: LD_INT 36
59339: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
59340: LD_VAR 0 1
59344: PPUSH
59345: LD_VAR 0 3
59349: PPUSH
59350: LD_VAR 0 4
59354: PPUSH
59355: CALL_OW 297
59359: PUSH
59360: LD_VAR 0 14
59364: GREATER
59365: IFFALSE 59369
// exit ;
59367: GO 59909
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
59369: LD_ADDR_VAR 0 12
59373: PUSH
59374: LD_VAR 0 2
59378: PPUSH
59379: LD_VAR 0 3
59383: PPUSH
59384: LD_VAR 0 4
59388: PPUSH
59389: LD_VAR 0 5
59393: PPUSH
59394: LD_VAR 0 1
59398: PPUSH
59399: CALL_OW 248
59403: PPUSH
59404: LD_INT 0
59406: PPUSH
59407: CALL 59914 0 6
59411: ST_TO_ADDR
// if not hexes then
59412: LD_VAR 0 12
59416: NOT
59417: IFFALSE 59421
// exit ;
59419: GO 59909
// hex := GetHexInfo ( x , y ) ;
59421: LD_ADDR_VAR 0 15
59425: PUSH
59426: LD_VAR 0 3
59430: PPUSH
59431: LD_VAR 0 4
59435: PPUSH
59436: CALL_OW 546
59440: ST_TO_ADDR
// if hex [ 1 ] then
59441: LD_VAR 0 15
59445: PUSH
59446: LD_INT 1
59448: ARRAY
59449: IFFALSE 59453
// exit ;
59451: GO 59909
// height := hex [ 2 ] ;
59453: LD_ADDR_VAR 0 13
59457: PUSH
59458: LD_VAR 0 15
59462: PUSH
59463: LD_INT 2
59465: ARRAY
59466: ST_TO_ADDR
// for i = 1 to hexes do
59467: LD_ADDR_VAR 0 7
59471: PUSH
59472: DOUBLE
59473: LD_INT 1
59475: DEC
59476: ST_TO_ADDR
59477: LD_VAR 0 12
59481: PUSH
59482: FOR_TO
59483: IFFALSE 59813
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
59485: LD_VAR 0 12
59489: PUSH
59490: LD_VAR 0 7
59494: ARRAY
59495: PUSH
59496: LD_INT 1
59498: ARRAY
59499: PPUSH
59500: LD_VAR 0 12
59504: PUSH
59505: LD_VAR 0 7
59509: ARRAY
59510: PUSH
59511: LD_INT 2
59513: ARRAY
59514: PPUSH
59515: CALL_OW 488
59519: NOT
59520: PUSH
59521: LD_VAR 0 12
59525: PUSH
59526: LD_VAR 0 7
59530: ARRAY
59531: PUSH
59532: LD_INT 1
59534: ARRAY
59535: PPUSH
59536: LD_VAR 0 12
59540: PUSH
59541: LD_VAR 0 7
59545: ARRAY
59546: PUSH
59547: LD_INT 2
59549: ARRAY
59550: PPUSH
59551: CALL_OW 428
59555: PUSH
59556: LD_INT 0
59558: GREATER
59559: OR
59560: PUSH
59561: LD_VAR 0 12
59565: PUSH
59566: LD_VAR 0 7
59570: ARRAY
59571: PUSH
59572: LD_INT 1
59574: ARRAY
59575: PPUSH
59576: LD_VAR 0 12
59580: PUSH
59581: LD_VAR 0 7
59585: ARRAY
59586: PUSH
59587: LD_INT 2
59589: ARRAY
59590: PPUSH
59591: CALL_OW 351
59595: OR
59596: IFFALSE 59602
// exit ;
59598: POP
59599: POP
59600: GO 59909
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59602: LD_ADDR_VAR 0 8
59606: PUSH
59607: LD_VAR 0 12
59611: PUSH
59612: LD_VAR 0 7
59616: ARRAY
59617: PUSH
59618: LD_INT 1
59620: ARRAY
59621: PPUSH
59622: LD_VAR 0 12
59626: PUSH
59627: LD_VAR 0 7
59631: ARRAY
59632: PUSH
59633: LD_INT 2
59635: ARRAY
59636: PPUSH
59637: CALL_OW 546
59641: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
59642: LD_VAR 0 8
59646: PUSH
59647: LD_INT 1
59649: ARRAY
59650: PUSH
59651: LD_VAR 0 8
59655: PUSH
59656: LD_INT 2
59658: ARRAY
59659: PUSH
59660: LD_VAR 0 13
59664: PUSH
59665: LD_INT 2
59667: PLUS
59668: GREATER
59669: OR
59670: PUSH
59671: LD_VAR 0 8
59675: PUSH
59676: LD_INT 2
59678: ARRAY
59679: PUSH
59680: LD_VAR 0 13
59684: PUSH
59685: LD_INT 2
59687: MINUS
59688: LESS
59689: OR
59690: PUSH
59691: LD_VAR 0 8
59695: PUSH
59696: LD_INT 3
59698: ARRAY
59699: PUSH
59700: LD_INT 0
59702: PUSH
59703: LD_INT 8
59705: PUSH
59706: LD_INT 9
59708: PUSH
59709: LD_INT 10
59711: PUSH
59712: LD_INT 11
59714: PUSH
59715: LD_INT 12
59717: PUSH
59718: LD_INT 13
59720: PUSH
59721: LD_INT 16
59723: PUSH
59724: LD_INT 17
59726: PUSH
59727: LD_INT 18
59729: PUSH
59730: LD_INT 19
59732: PUSH
59733: LD_INT 20
59735: PUSH
59736: LD_INT 21
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: LIST
59743: LIST
59744: LIST
59745: LIST
59746: LIST
59747: LIST
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: LIST
59753: IN
59754: NOT
59755: OR
59756: PUSH
59757: LD_VAR 0 8
59761: PUSH
59762: LD_INT 5
59764: ARRAY
59765: NOT
59766: OR
59767: PUSH
59768: LD_VAR 0 8
59772: PUSH
59773: LD_INT 6
59775: ARRAY
59776: PUSH
59777: LD_INT 1
59779: PUSH
59780: LD_INT 2
59782: PUSH
59783: LD_INT 7
59785: PUSH
59786: LD_INT 9
59788: PUSH
59789: LD_INT 10
59791: PUSH
59792: LD_INT 11
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: LIST
59799: LIST
59800: LIST
59801: LIST
59802: IN
59803: NOT
59804: OR
59805: IFFALSE 59811
// exit ;
59807: POP
59808: POP
59809: GO 59909
// end ;
59811: GO 59482
59813: POP
59814: POP
// side := GetSide ( bdepot ) ;
59815: LD_ADDR_VAR 0 9
59819: PUSH
59820: LD_VAR 0 1
59824: PPUSH
59825: CALL_OW 255
59829: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59830: LD_VAR 0 9
59834: PPUSH
59835: LD_VAR 0 3
59839: PPUSH
59840: LD_VAR 0 4
59844: PPUSH
59845: LD_INT 20
59847: PPUSH
59848: CALL 52581 0 4
59852: PUSH
59853: LD_INT 4
59855: ARRAY
59856: IFFALSE 59860
// exit ;
59858: GO 59909
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
59860: LD_VAR 0 2
59864: PUSH
59865: LD_INT 29
59867: PUSH
59868: LD_INT 30
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: IN
59875: PUSH
59876: LD_VAR 0 3
59880: PPUSH
59881: LD_VAR 0 4
59885: PPUSH
59886: LD_VAR 0 9
59890: PPUSH
59891: CALL_OW 440
59895: NOT
59896: AND
59897: IFFALSE 59901
// exit ;
59899: GO 59909
// result := true ;
59901: LD_ADDR_VAR 0 6
59905: PUSH
59906: LD_INT 1
59908: ST_TO_ADDR
// end ;
59909: LD_VAR 0 6
59913: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
59914: LD_INT 0
59916: PPUSH
59917: PPUSH
59918: PPUSH
59919: PPUSH
59920: PPUSH
59921: PPUSH
59922: PPUSH
59923: PPUSH
59924: PPUSH
59925: PPUSH
59926: PPUSH
59927: PPUSH
59928: PPUSH
59929: PPUSH
59930: PPUSH
59931: PPUSH
59932: PPUSH
59933: PPUSH
59934: PPUSH
59935: PPUSH
59936: PPUSH
59937: PPUSH
59938: PPUSH
59939: PPUSH
59940: PPUSH
59941: PPUSH
59942: PPUSH
59943: PPUSH
59944: PPUSH
59945: PPUSH
59946: PPUSH
59947: PPUSH
59948: PPUSH
59949: PPUSH
59950: PPUSH
59951: PPUSH
59952: PPUSH
59953: PPUSH
59954: PPUSH
59955: PPUSH
59956: PPUSH
59957: PPUSH
59958: PPUSH
59959: PPUSH
59960: PPUSH
59961: PPUSH
59962: PPUSH
59963: PPUSH
59964: PPUSH
59965: PPUSH
59966: PPUSH
59967: PPUSH
59968: PPUSH
59969: PPUSH
59970: PPUSH
59971: PPUSH
59972: PPUSH
59973: PPUSH
// result = [ ] ;
59974: LD_ADDR_VAR 0 7
59978: PUSH
59979: EMPTY
59980: ST_TO_ADDR
// temp_list = [ ] ;
59981: LD_ADDR_VAR 0 9
59985: PUSH
59986: EMPTY
59987: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
59988: LD_VAR 0 4
59992: PUSH
59993: LD_INT 0
59995: PUSH
59996: LD_INT 1
59998: PUSH
59999: LD_INT 2
60001: PUSH
60002: LD_INT 3
60004: PUSH
60005: LD_INT 4
60007: PUSH
60008: LD_INT 5
60010: PUSH
60011: EMPTY
60012: LIST
60013: LIST
60014: LIST
60015: LIST
60016: LIST
60017: LIST
60018: IN
60019: NOT
60020: PUSH
60021: LD_VAR 0 1
60025: PUSH
60026: LD_INT 0
60028: PUSH
60029: LD_INT 1
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: IN
60036: PUSH
60037: LD_VAR 0 5
60041: PUSH
60042: LD_INT 1
60044: PUSH
60045: LD_INT 2
60047: PUSH
60048: LD_INT 3
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: LIST
60055: IN
60056: NOT
60057: AND
60058: OR
60059: IFFALSE 60063
// exit ;
60061: GO 78448
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
60063: LD_VAR 0 1
60067: PUSH
60068: LD_INT 6
60070: PUSH
60071: LD_INT 7
60073: PUSH
60074: LD_INT 8
60076: PUSH
60077: LD_INT 13
60079: PUSH
60080: LD_INT 12
60082: PUSH
60083: LD_INT 15
60085: PUSH
60086: LD_INT 11
60088: PUSH
60089: LD_INT 14
60091: PUSH
60092: LD_INT 10
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: LIST
60099: LIST
60100: LIST
60101: LIST
60102: LIST
60103: LIST
60104: LIST
60105: IN
60106: IFFALSE 60116
// btype = b_lab ;
60108: LD_ADDR_VAR 0 1
60112: PUSH
60113: LD_INT 6
60115: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
60116: LD_VAR 0 6
60120: PUSH
60121: LD_INT 0
60123: PUSH
60124: LD_INT 1
60126: PUSH
60127: LD_INT 2
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: LIST
60134: IN
60135: NOT
60136: PUSH
60137: LD_VAR 0 1
60141: PUSH
60142: LD_INT 0
60144: PUSH
60145: LD_INT 1
60147: PUSH
60148: LD_INT 2
60150: PUSH
60151: LD_INT 3
60153: PUSH
60154: LD_INT 6
60156: PUSH
60157: LD_INT 36
60159: PUSH
60160: LD_INT 4
60162: PUSH
60163: LD_INT 5
60165: PUSH
60166: LD_INT 31
60168: PUSH
60169: LD_INT 32
60171: PUSH
60172: LD_INT 33
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: LIST
60179: LIST
60180: LIST
60181: LIST
60182: LIST
60183: LIST
60184: LIST
60185: LIST
60186: LIST
60187: IN
60188: NOT
60189: PUSH
60190: LD_VAR 0 6
60194: PUSH
60195: LD_INT 1
60197: EQUAL
60198: AND
60199: OR
60200: PUSH
60201: LD_VAR 0 1
60205: PUSH
60206: LD_INT 2
60208: PUSH
60209: LD_INT 3
60211: PUSH
60212: EMPTY
60213: LIST
60214: LIST
60215: IN
60216: NOT
60217: PUSH
60218: LD_VAR 0 6
60222: PUSH
60223: LD_INT 2
60225: EQUAL
60226: AND
60227: OR
60228: IFFALSE 60238
// mode = 0 ;
60230: LD_ADDR_VAR 0 6
60234: PUSH
60235: LD_INT 0
60237: ST_TO_ADDR
// case mode of 0 :
60238: LD_VAR 0 6
60242: PUSH
60243: LD_INT 0
60245: DOUBLE
60246: EQUAL
60247: IFTRUE 60251
60249: GO 71704
60251: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
60252: LD_ADDR_VAR 0 11
60256: PUSH
60257: LD_INT 0
60259: PUSH
60260: LD_INT 0
60262: PUSH
60263: EMPTY
60264: LIST
60265: LIST
60266: PUSH
60267: LD_INT 0
60269: PUSH
60270: LD_INT 1
60272: NEG
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PUSH
60278: LD_INT 1
60280: PUSH
60281: LD_INT 0
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: PUSH
60288: LD_INT 1
60290: PUSH
60291: LD_INT 1
60293: PUSH
60294: EMPTY
60295: LIST
60296: LIST
60297: PUSH
60298: LD_INT 0
60300: PUSH
60301: LD_INT 1
60303: PUSH
60304: EMPTY
60305: LIST
60306: LIST
60307: PUSH
60308: LD_INT 1
60310: NEG
60311: PUSH
60312: LD_INT 0
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: PUSH
60319: LD_INT 1
60321: NEG
60322: PUSH
60323: LD_INT 1
60325: NEG
60326: PUSH
60327: EMPTY
60328: LIST
60329: LIST
60330: PUSH
60331: LD_INT 1
60333: NEG
60334: PUSH
60335: LD_INT 2
60337: NEG
60338: PUSH
60339: EMPTY
60340: LIST
60341: LIST
60342: PUSH
60343: LD_INT 0
60345: PUSH
60346: LD_INT 2
60348: NEG
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: LD_INT 1
60356: PUSH
60357: LD_INT 1
60359: NEG
60360: PUSH
60361: EMPTY
60362: LIST
60363: LIST
60364: PUSH
60365: LD_INT 1
60367: PUSH
60368: LD_INT 2
60370: PUSH
60371: EMPTY
60372: LIST
60373: LIST
60374: PUSH
60375: LD_INT 0
60377: PUSH
60378: LD_INT 2
60380: PUSH
60381: EMPTY
60382: LIST
60383: LIST
60384: PUSH
60385: LD_INT 1
60387: NEG
60388: PUSH
60389: LD_INT 1
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: LD_INT 1
60398: PUSH
60399: LD_INT 3
60401: PUSH
60402: EMPTY
60403: LIST
60404: LIST
60405: PUSH
60406: LD_INT 0
60408: PUSH
60409: LD_INT 3
60411: PUSH
60412: EMPTY
60413: LIST
60414: LIST
60415: PUSH
60416: LD_INT 1
60418: NEG
60419: PUSH
60420: LD_INT 2
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: LIST
60431: LIST
60432: LIST
60433: LIST
60434: LIST
60435: LIST
60436: LIST
60437: LIST
60438: LIST
60439: LIST
60440: LIST
60441: LIST
60442: LIST
60443: LIST
60444: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
60445: LD_ADDR_VAR 0 12
60449: PUSH
60450: LD_INT 0
60452: PUSH
60453: LD_INT 0
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: PUSH
60460: LD_INT 0
60462: PUSH
60463: LD_INT 1
60465: NEG
60466: PUSH
60467: EMPTY
60468: LIST
60469: LIST
60470: PUSH
60471: LD_INT 1
60473: PUSH
60474: LD_INT 0
60476: PUSH
60477: EMPTY
60478: LIST
60479: LIST
60480: PUSH
60481: LD_INT 1
60483: PUSH
60484: LD_INT 1
60486: PUSH
60487: EMPTY
60488: LIST
60489: LIST
60490: PUSH
60491: LD_INT 0
60493: PUSH
60494: LD_INT 1
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PUSH
60501: LD_INT 1
60503: NEG
60504: PUSH
60505: LD_INT 0
60507: PUSH
60508: EMPTY
60509: LIST
60510: LIST
60511: PUSH
60512: LD_INT 1
60514: NEG
60515: PUSH
60516: LD_INT 1
60518: NEG
60519: PUSH
60520: EMPTY
60521: LIST
60522: LIST
60523: PUSH
60524: LD_INT 1
60526: PUSH
60527: LD_INT 1
60529: NEG
60530: PUSH
60531: EMPTY
60532: LIST
60533: LIST
60534: PUSH
60535: LD_INT 2
60537: PUSH
60538: LD_INT 0
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: LD_INT 2
60547: PUSH
60548: LD_INT 1
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: PUSH
60555: LD_INT 1
60557: NEG
60558: PUSH
60559: LD_INT 1
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: PUSH
60566: LD_INT 2
60568: NEG
60569: PUSH
60570: LD_INT 0
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: PUSH
60577: LD_INT 2
60579: NEG
60580: PUSH
60581: LD_INT 1
60583: NEG
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PUSH
60589: LD_INT 2
60591: NEG
60592: PUSH
60593: LD_INT 1
60595: PUSH
60596: EMPTY
60597: LIST
60598: LIST
60599: PUSH
60600: LD_INT 3
60602: NEG
60603: PUSH
60604: LD_INT 0
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: PUSH
60611: LD_INT 3
60613: NEG
60614: PUSH
60615: LD_INT 1
60617: NEG
60618: PUSH
60619: EMPTY
60620: LIST
60621: LIST
60622: PUSH
60623: EMPTY
60624: LIST
60625: LIST
60626: LIST
60627: LIST
60628: LIST
60629: LIST
60630: LIST
60631: LIST
60632: LIST
60633: LIST
60634: LIST
60635: LIST
60636: LIST
60637: LIST
60638: LIST
60639: LIST
60640: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
60641: LD_ADDR_VAR 0 13
60645: PUSH
60646: LD_INT 0
60648: PUSH
60649: LD_INT 0
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: PUSH
60656: LD_INT 0
60658: PUSH
60659: LD_INT 1
60661: NEG
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: PUSH
60667: LD_INT 1
60669: PUSH
60670: LD_INT 0
60672: PUSH
60673: EMPTY
60674: LIST
60675: LIST
60676: PUSH
60677: LD_INT 1
60679: PUSH
60680: LD_INT 1
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: PUSH
60687: LD_INT 0
60689: PUSH
60690: LD_INT 1
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: PUSH
60697: LD_INT 1
60699: NEG
60700: PUSH
60701: LD_INT 0
60703: PUSH
60704: EMPTY
60705: LIST
60706: LIST
60707: PUSH
60708: LD_INT 1
60710: NEG
60711: PUSH
60712: LD_INT 1
60714: NEG
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: PUSH
60720: LD_INT 1
60722: NEG
60723: PUSH
60724: LD_INT 2
60726: NEG
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: PUSH
60732: LD_INT 2
60734: PUSH
60735: LD_INT 1
60737: PUSH
60738: EMPTY
60739: LIST
60740: LIST
60741: PUSH
60742: LD_INT 2
60744: PUSH
60745: LD_INT 2
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: PUSH
60752: LD_INT 1
60754: PUSH
60755: LD_INT 2
60757: PUSH
60758: EMPTY
60759: LIST
60760: LIST
60761: PUSH
60762: LD_INT 2
60764: NEG
60765: PUSH
60766: LD_INT 1
60768: NEG
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: PUSH
60774: LD_INT 2
60776: NEG
60777: PUSH
60778: LD_INT 2
60780: NEG
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PUSH
60786: LD_INT 2
60788: NEG
60789: PUSH
60790: LD_INT 3
60792: NEG
60793: PUSH
60794: EMPTY
60795: LIST
60796: LIST
60797: PUSH
60798: LD_INT 3
60800: NEG
60801: PUSH
60802: LD_INT 2
60804: NEG
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PUSH
60810: LD_INT 3
60812: NEG
60813: PUSH
60814: LD_INT 3
60816: NEG
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: EMPTY
60823: LIST
60824: LIST
60825: LIST
60826: LIST
60827: LIST
60828: LIST
60829: LIST
60830: LIST
60831: LIST
60832: LIST
60833: LIST
60834: LIST
60835: LIST
60836: LIST
60837: LIST
60838: LIST
60839: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
60840: LD_ADDR_VAR 0 14
60844: PUSH
60845: LD_INT 0
60847: PUSH
60848: LD_INT 0
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PUSH
60855: LD_INT 0
60857: PUSH
60858: LD_INT 1
60860: NEG
60861: PUSH
60862: EMPTY
60863: LIST
60864: LIST
60865: PUSH
60866: LD_INT 1
60868: PUSH
60869: LD_INT 0
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PUSH
60876: LD_INT 1
60878: PUSH
60879: LD_INT 1
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PUSH
60886: LD_INT 0
60888: PUSH
60889: LD_INT 1
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PUSH
60896: LD_INT 1
60898: NEG
60899: PUSH
60900: LD_INT 0
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: PUSH
60907: LD_INT 1
60909: NEG
60910: PUSH
60911: LD_INT 1
60913: NEG
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: PUSH
60919: LD_INT 1
60921: NEG
60922: PUSH
60923: LD_INT 2
60925: NEG
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: PUSH
60931: LD_INT 0
60933: PUSH
60934: LD_INT 2
60936: NEG
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 1
60944: PUSH
60945: LD_INT 1
60947: NEG
60948: PUSH
60949: EMPTY
60950: LIST
60951: LIST
60952: PUSH
60953: LD_INT 1
60955: PUSH
60956: LD_INT 2
60958: PUSH
60959: EMPTY
60960: LIST
60961: LIST
60962: PUSH
60963: LD_INT 0
60965: PUSH
60966: LD_INT 2
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: PUSH
60973: LD_INT 1
60975: NEG
60976: PUSH
60977: LD_INT 1
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: LD_INT 1
60986: NEG
60987: PUSH
60988: LD_INT 3
60990: NEG
60991: PUSH
60992: EMPTY
60993: LIST
60994: LIST
60995: PUSH
60996: LD_INT 0
60998: PUSH
60999: LD_INT 3
61001: NEG
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: PUSH
61007: LD_INT 1
61009: PUSH
61010: LD_INT 2
61012: NEG
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: PUSH
61018: EMPTY
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
61036: LD_ADDR_VAR 0 15
61040: PUSH
61041: LD_INT 0
61043: PUSH
61044: LD_INT 0
61046: PUSH
61047: EMPTY
61048: LIST
61049: LIST
61050: PUSH
61051: LD_INT 0
61053: PUSH
61054: LD_INT 1
61056: NEG
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: LD_INT 1
61064: PUSH
61065: LD_INT 0
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: PUSH
61072: LD_INT 1
61074: PUSH
61075: LD_INT 1
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: PUSH
61082: LD_INT 0
61084: PUSH
61085: LD_INT 1
61087: PUSH
61088: EMPTY
61089: LIST
61090: LIST
61091: PUSH
61092: LD_INT 1
61094: NEG
61095: PUSH
61096: LD_INT 0
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PUSH
61103: LD_INT 1
61105: NEG
61106: PUSH
61107: LD_INT 1
61109: NEG
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: PUSH
61115: LD_INT 1
61117: PUSH
61118: LD_INT 1
61120: NEG
61121: PUSH
61122: EMPTY
61123: LIST
61124: LIST
61125: PUSH
61126: LD_INT 2
61128: PUSH
61129: LD_INT 0
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 2
61138: PUSH
61139: LD_INT 1
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 1
61148: NEG
61149: PUSH
61150: LD_INT 1
61152: PUSH
61153: EMPTY
61154: LIST
61155: LIST
61156: PUSH
61157: LD_INT 2
61159: NEG
61160: PUSH
61161: LD_INT 0
61163: PUSH
61164: EMPTY
61165: LIST
61166: LIST
61167: PUSH
61168: LD_INT 2
61170: NEG
61171: PUSH
61172: LD_INT 1
61174: NEG
61175: PUSH
61176: EMPTY
61177: LIST
61178: LIST
61179: PUSH
61180: LD_INT 2
61182: PUSH
61183: LD_INT 1
61185: NEG
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PUSH
61191: LD_INT 3
61193: PUSH
61194: LD_INT 0
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: PUSH
61201: LD_INT 3
61203: PUSH
61204: LD_INT 1
61206: PUSH
61207: EMPTY
61208: LIST
61209: LIST
61210: PUSH
61211: EMPTY
61212: LIST
61213: LIST
61214: LIST
61215: LIST
61216: LIST
61217: LIST
61218: LIST
61219: LIST
61220: LIST
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: LIST
61228: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
61229: LD_ADDR_VAR 0 16
61233: PUSH
61234: LD_INT 0
61236: PUSH
61237: LD_INT 0
61239: PUSH
61240: EMPTY
61241: LIST
61242: LIST
61243: PUSH
61244: LD_INT 0
61246: PUSH
61247: LD_INT 1
61249: NEG
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: PUSH
61255: LD_INT 1
61257: PUSH
61258: LD_INT 0
61260: PUSH
61261: EMPTY
61262: LIST
61263: LIST
61264: PUSH
61265: LD_INT 1
61267: PUSH
61268: LD_INT 1
61270: PUSH
61271: EMPTY
61272: LIST
61273: LIST
61274: PUSH
61275: LD_INT 0
61277: PUSH
61278: LD_INT 1
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: PUSH
61285: LD_INT 1
61287: NEG
61288: PUSH
61289: LD_INT 0
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: PUSH
61296: LD_INT 1
61298: NEG
61299: PUSH
61300: LD_INT 1
61302: NEG
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: LD_INT 1
61310: NEG
61311: PUSH
61312: LD_INT 2
61314: NEG
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: PUSH
61320: LD_INT 2
61322: PUSH
61323: LD_INT 1
61325: PUSH
61326: EMPTY
61327: LIST
61328: LIST
61329: PUSH
61330: LD_INT 2
61332: PUSH
61333: LD_INT 2
61335: PUSH
61336: EMPTY
61337: LIST
61338: LIST
61339: PUSH
61340: LD_INT 1
61342: PUSH
61343: LD_INT 2
61345: PUSH
61346: EMPTY
61347: LIST
61348: LIST
61349: PUSH
61350: LD_INT 2
61352: NEG
61353: PUSH
61354: LD_INT 1
61356: NEG
61357: PUSH
61358: EMPTY
61359: LIST
61360: LIST
61361: PUSH
61362: LD_INT 2
61364: NEG
61365: PUSH
61366: LD_INT 2
61368: NEG
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: PUSH
61374: LD_INT 3
61376: PUSH
61377: LD_INT 2
61379: PUSH
61380: EMPTY
61381: LIST
61382: LIST
61383: PUSH
61384: LD_INT 3
61386: PUSH
61387: LD_INT 3
61389: PUSH
61390: EMPTY
61391: LIST
61392: LIST
61393: PUSH
61394: LD_INT 2
61396: PUSH
61397: LD_INT 3
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: LIST
61408: LIST
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: LIST
61414: LIST
61415: LIST
61416: LIST
61417: LIST
61418: LIST
61419: LIST
61420: LIST
61421: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61422: LD_ADDR_VAR 0 17
61426: PUSH
61427: LD_INT 0
61429: PUSH
61430: LD_INT 0
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: PUSH
61437: LD_INT 0
61439: PUSH
61440: LD_INT 1
61442: NEG
61443: PUSH
61444: EMPTY
61445: LIST
61446: LIST
61447: PUSH
61448: LD_INT 1
61450: PUSH
61451: LD_INT 0
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: PUSH
61458: LD_INT 1
61460: PUSH
61461: LD_INT 1
61463: PUSH
61464: EMPTY
61465: LIST
61466: LIST
61467: PUSH
61468: LD_INT 0
61470: PUSH
61471: LD_INT 1
61473: PUSH
61474: EMPTY
61475: LIST
61476: LIST
61477: PUSH
61478: LD_INT 1
61480: NEG
61481: PUSH
61482: LD_INT 0
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PUSH
61489: LD_INT 1
61491: NEG
61492: PUSH
61493: LD_INT 1
61495: NEG
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: LD_INT 1
61503: NEG
61504: PUSH
61505: LD_INT 2
61507: NEG
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: PUSH
61513: LD_INT 0
61515: PUSH
61516: LD_INT 2
61518: NEG
61519: PUSH
61520: EMPTY
61521: LIST
61522: LIST
61523: PUSH
61524: LD_INT 1
61526: PUSH
61527: LD_INT 1
61529: NEG
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: PUSH
61535: LD_INT 2
61537: PUSH
61538: LD_INT 0
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: LD_INT 2
61547: PUSH
61548: LD_INT 1
61550: PUSH
61551: EMPTY
61552: LIST
61553: LIST
61554: PUSH
61555: LD_INT 2
61557: PUSH
61558: LD_INT 2
61560: PUSH
61561: EMPTY
61562: LIST
61563: LIST
61564: PUSH
61565: LD_INT 1
61567: PUSH
61568: LD_INT 2
61570: PUSH
61571: EMPTY
61572: LIST
61573: LIST
61574: PUSH
61575: LD_INT 0
61577: PUSH
61578: LD_INT 2
61580: PUSH
61581: EMPTY
61582: LIST
61583: LIST
61584: PUSH
61585: LD_INT 1
61587: NEG
61588: PUSH
61589: LD_INT 1
61591: PUSH
61592: EMPTY
61593: LIST
61594: LIST
61595: PUSH
61596: LD_INT 2
61598: NEG
61599: PUSH
61600: LD_INT 0
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: PUSH
61607: LD_INT 2
61609: NEG
61610: PUSH
61611: LD_INT 1
61613: NEG
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: PUSH
61619: LD_INT 2
61621: NEG
61622: PUSH
61623: LD_INT 2
61625: NEG
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: LIST
61635: LIST
61636: LIST
61637: LIST
61638: LIST
61639: LIST
61640: LIST
61641: LIST
61642: LIST
61643: LIST
61644: LIST
61645: LIST
61646: LIST
61647: LIST
61648: LIST
61649: LIST
61650: LIST
61651: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61652: LD_ADDR_VAR 0 18
61656: PUSH
61657: LD_INT 0
61659: PUSH
61660: LD_INT 0
61662: PUSH
61663: EMPTY
61664: LIST
61665: LIST
61666: PUSH
61667: LD_INT 0
61669: PUSH
61670: LD_INT 1
61672: NEG
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: PUSH
61678: LD_INT 1
61680: PUSH
61681: LD_INT 0
61683: PUSH
61684: EMPTY
61685: LIST
61686: LIST
61687: PUSH
61688: LD_INT 1
61690: PUSH
61691: LD_INT 1
61693: PUSH
61694: EMPTY
61695: LIST
61696: LIST
61697: PUSH
61698: LD_INT 0
61700: PUSH
61701: LD_INT 1
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PUSH
61708: LD_INT 1
61710: NEG
61711: PUSH
61712: LD_INT 0
61714: PUSH
61715: EMPTY
61716: LIST
61717: LIST
61718: PUSH
61719: LD_INT 1
61721: NEG
61722: PUSH
61723: LD_INT 1
61725: NEG
61726: PUSH
61727: EMPTY
61728: LIST
61729: LIST
61730: PUSH
61731: LD_INT 1
61733: NEG
61734: PUSH
61735: LD_INT 2
61737: NEG
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: LD_INT 0
61745: PUSH
61746: LD_INT 2
61748: NEG
61749: PUSH
61750: EMPTY
61751: LIST
61752: LIST
61753: PUSH
61754: LD_INT 1
61756: PUSH
61757: LD_INT 1
61759: NEG
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PUSH
61765: LD_INT 2
61767: PUSH
61768: LD_INT 0
61770: PUSH
61771: EMPTY
61772: LIST
61773: LIST
61774: PUSH
61775: LD_INT 2
61777: PUSH
61778: LD_INT 1
61780: PUSH
61781: EMPTY
61782: LIST
61783: LIST
61784: PUSH
61785: LD_INT 2
61787: PUSH
61788: LD_INT 2
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: PUSH
61795: LD_INT 1
61797: PUSH
61798: LD_INT 2
61800: PUSH
61801: EMPTY
61802: LIST
61803: LIST
61804: PUSH
61805: LD_INT 0
61807: PUSH
61808: LD_INT 2
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: PUSH
61815: LD_INT 1
61817: NEG
61818: PUSH
61819: LD_INT 1
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: LD_INT 2
61828: NEG
61829: PUSH
61830: LD_INT 0
61832: PUSH
61833: EMPTY
61834: LIST
61835: LIST
61836: PUSH
61837: LD_INT 2
61839: NEG
61840: PUSH
61841: LD_INT 1
61843: NEG
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PUSH
61849: LD_INT 2
61851: NEG
61852: PUSH
61853: LD_INT 2
61855: NEG
61856: PUSH
61857: EMPTY
61858: LIST
61859: LIST
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: LIST
61865: LIST
61866: LIST
61867: LIST
61868: LIST
61869: LIST
61870: LIST
61871: LIST
61872: LIST
61873: LIST
61874: LIST
61875: LIST
61876: LIST
61877: LIST
61878: LIST
61879: LIST
61880: LIST
61881: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61882: LD_ADDR_VAR 0 19
61886: PUSH
61887: LD_INT 0
61889: PUSH
61890: LD_INT 0
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 0
61899: PUSH
61900: LD_INT 1
61902: NEG
61903: PUSH
61904: EMPTY
61905: LIST
61906: LIST
61907: PUSH
61908: LD_INT 1
61910: PUSH
61911: LD_INT 0
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: PUSH
61918: LD_INT 1
61920: PUSH
61921: LD_INT 1
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 0
61930: PUSH
61931: LD_INT 1
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: PUSH
61938: LD_INT 1
61940: NEG
61941: PUSH
61942: LD_INT 0
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 1
61951: NEG
61952: PUSH
61953: LD_INT 1
61955: NEG
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: PUSH
61961: LD_INT 1
61963: NEG
61964: PUSH
61965: LD_INT 2
61967: NEG
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: PUSH
61973: LD_INT 0
61975: PUSH
61976: LD_INT 2
61978: NEG
61979: PUSH
61980: EMPTY
61981: LIST
61982: LIST
61983: PUSH
61984: LD_INT 1
61986: PUSH
61987: LD_INT 1
61989: NEG
61990: PUSH
61991: EMPTY
61992: LIST
61993: LIST
61994: PUSH
61995: LD_INT 2
61997: PUSH
61998: LD_INT 0
62000: PUSH
62001: EMPTY
62002: LIST
62003: LIST
62004: PUSH
62005: LD_INT 2
62007: PUSH
62008: LD_INT 1
62010: PUSH
62011: EMPTY
62012: LIST
62013: LIST
62014: PUSH
62015: LD_INT 2
62017: PUSH
62018: LD_INT 2
62020: PUSH
62021: EMPTY
62022: LIST
62023: LIST
62024: PUSH
62025: LD_INT 1
62027: PUSH
62028: LD_INT 2
62030: PUSH
62031: EMPTY
62032: LIST
62033: LIST
62034: PUSH
62035: LD_INT 0
62037: PUSH
62038: LD_INT 2
62040: PUSH
62041: EMPTY
62042: LIST
62043: LIST
62044: PUSH
62045: LD_INT 1
62047: NEG
62048: PUSH
62049: LD_INT 1
62051: PUSH
62052: EMPTY
62053: LIST
62054: LIST
62055: PUSH
62056: LD_INT 2
62058: NEG
62059: PUSH
62060: LD_INT 0
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: PUSH
62067: LD_INT 2
62069: NEG
62070: PUSH
62071: LD_INT 1
62073: NEG
62074: PUSH
62075: EMPTY
62076: LIST
62077: LIST
62078: PUSH
62079: LD_INT 2
62081: NEG
62082: PUSH
62083: LD_INT 2
62085: NEG
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PUSH
62091: EMPTY
62092: LIST
62093: LIST
62094: LIST
62095: LIST
62096: LIST
62097: LIST
62098: LIST
62099: LIST
62100: LIST
62101: LIST
62102: LIST
62103: LIST
62104: LIST
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: LIST
62110: LIST
62111: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62112: LD_ADDR_VAR 0 20
62116: PUSH
62117: LD_INT 0
62119: PUSH
62120: LD_INT 0
62122: PUSH
62123: EMPTY
62124: LIST
62125: LIST
62126: PUSH
62127: LD_INT 0
62129: PUSH
62130: LD_INT 1
62132: NEG
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: PUSH
62138: LD_INT 1
62140: PUSH
62141: LD_INT 0
62143: PUSH
62144: EMPTY
62145: LIST
62146: LIST
62147: PUSH
62148: LD_INT 1
62150: PUSH
62151: LD_INT 1
62153: PUSH
62154: EMPTY
62155: LIST
62156: LIST
62157: PUSH
62158: LD_INT 0
62160: PUSH
62161: LD_INT 1
62163: PUSH
62164: EMPTY
62165: LIST
62166: LIST
62167: PUSH
62168: LD_INT 1
62170: NEG
62171: PUSH
62172: LD_INT 0
62174: PUSH
62175: EMPTY
62176: LIST
62177: LIST
62178: PUSH
62179: LD_INT 1
62181: NEG
62182: PUSH
62183: LD_INT 1
62185: NEG
62186: PUSH
62187: EMPTY
62188: LIST
62189: LIST
62190: PUSH
62191: LD_INT 1
62193: NEG
62194: PUSH
62195: LD_INT 2
62197: NEG
62198: PUSH
62199: EMPTY
62200: LIST
62201: LIST
62202: PUSH
62203: LD_INT 0
62205: PUSH
62206: LD_INT 2
62208: NEG
62209: PUSH
62210: EMPTY
62211: LIST
62212: LIST
62213: PUSH
62214: LD_INT 1
62216: PUSH
62217: LD_INT 1
62219: NEG
62220: PUSH
62221: EMPTY
62222: LIST
62223: LIST
62224: PUSH
62225: LD_INT 2
62227: PUSH
62228: LD_INT 0
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: PUSH
62235: LD_INT 2
62237: PUSH
62238: LD_INT 1
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: PUSH
62245: LD_INT 2
62247: PUSH
62248: LD_INT 2
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: PUSH
62255: LD_INT 1
62257: PUSH
62258: LD_INT 2
62260: PUSH
62261: EMPTY
62262: LIST
62263: LIST
62264: PUSH
62265: LD_INT 0
62267: PUSH
62268: LD_INT 2
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: PUSH
62275: LD_INT 1
62277: NEG
62278: PUSH
62279: LD_INT 1
62281: PUSH
62282: EMPTY
62283: LIST
62284: LIST
62285: PUSH
62286: LD_INT 2
62288: NEG
62289: PUSH
62290: LD_INT 0
62292: PUSH
62293: EMPTY
62294: LIST
62295: LIST
62296: PUSH
62297: LD_INT 2
62299: NEG
62300: PUSH
62301: LD_INT 1
62303: NEG
62304: PUSH
62305: EMPTY
62306: LIST
62307: LIST
62308: PUSH
62309: LD_INT 2
62311: NEG
62312: PUSH
62313: LD_INT 2
62315: NEG
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: PUSH
62321: EMPTY
62322: LIST
62323: LIST
62324: LIST
62325: LIST
62326: LIST
62327: LIST
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: LIST
62333: LIST
62334: LIST
62335: LIST
62336: LIST
62337: LIST
62338: LIST
62339: LIST
62340: LIST
62341: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62342: LD_ADDR_VAR 0 21
62346: PUSH
62347: LD_INT 0
62349: PUSH
62350: LD_INT 0
62352: PUSH
62353: EMPTY
62354: LIST
62355: LIST
62356: PUSH
62357: LD_INT 0
62359: PUSH
62360: LD_INT 1
62362: NEG
62363: PUSH
62364: EMPTY
62365: LIST
62366: LIST
62367: PUSH
62368: LD_INT 1
62370: PUSH
62371: LD_INT 0
62373: PUSH
62374: EMPTY
62375: LIST
62376: LIST
62377: PUSH
62378: LD_INT 1
62380: PUSH
62381: LD_INT 1
62383: PUSH
62384: EMPTY
62385: LIST
62386: LIST
62387: PUSH
62388: LD_INT 0
62390: PUSH
62391: LD_INT 1
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: PUSH
62398: LD_INT 1
62400: NEG
62401: PUSH
62402: LD_INT 0
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: PUSH
62409: LD_INT 1
62411: NEG
62412: PUSH
62413: LD_INT 1
62415: NEG
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PUSH
62421: LD_INT 1
62423: NEG
62424: PUSH
62425: LD_INT 2
62427: NEG
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PUSH
62433: LD_INT 0
62435: PUSH
62436: LD_INT 2
62438: NEG
62439: PUSH
62440: EMPTY
62441: LIST
62442: LIST
62443: PUSH
62444: LD_INT 1
62446: PUSH
62447: LD_INT 1
62449: NEG
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: PUSH
62455: LD_INT 2
62457: PUSH
62458: LD_INT 0
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: PUSH
62465: LD_INT 2
62467: PUSH
62468: LD_INT 1
62470: PUSH
62471: EMPTY
62472: LIST
62473: LIST
62474: PUSH
62475: LD_INT 2
62477: PUSH
62478: LD_INT 2
62480: PUSH
62481: EMPTY
62482: LIST
62483: LIST
62484: PUSH
62485: LD_INT 1
62487: PUSH
62488: LD_INT 2
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: PUSH
62495: LD_INT 0
62497: PUSH
62498: LD_INT 2
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: PUSH
62505: LD_INT 1
62507: NEG
62508: PUSH
62509: LD_INT 1
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: PUSH
62516: LD_INT 2
62518: NEG
62519: PUSH
62520: LD_INT 0
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: PUSH
62527: LD_INT 2
62529: NEG
62530: PUSH
62531: LD_INT 1
62533: NEG
62534: PUSH
62535: EMPTY
62536: LIST
62537: LIST
62538: PUSH
62539: LD_INT 2
62541: NEG
62542: PUSH
62543: LD_INT 2
62545: NEG
62546: PUSH
62547: EMPTY
62548: LIST
62549: LIST
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: LIST
62555: LIST
62556: LIST
62557: LIST
62558: LIST
62559: LIST
62560: LIST
62561: LIST
62562: LIST
62563: LIST
62564: LIST
62565: LIST
62566: LIST
62567: LIST
62568: LIST
62569: LIST
62570: LIST
62571: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62572: LD_ADDR_VAR 0 22
62576: PUSH
62577: LD_INT 0
62579: PUSH
62580: LD_INT 0
62582: PUSH
62583: EMPTY
62584: LIST
62585: LIST
62586: PUSH
62587: LD_INT 0
62589: PUSH
62590: LD_INT 1
62592: NEG
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PUSH
62598: LD_INT 1
62600: PUSH
62601: LD_INT 0
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: LD_INT 1
62610: PUSH
62611: LD_INT 1
62613: PUSH
62614: EMPTY
62615: LIST
62616: LIST
62617: PUSH
62618: LD_INT 0
62620: PUSH
62621: LD_INT 1
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 1
62630: NEG
62631: PUSH
62632: LD_INT 0
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 1
62641: NEG
62642: PUSH
62643: LD_INT 1
62645: NEG
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: PUSH
62651: LD_INT 1
62653: NEG
62654: PUSH
62655: LD_INT 2
62657: NEG
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: PUSH
62663: LD_INT 0
62665: PUSH
62666: LD_INT 2
62668: NEG
62669: PUSH
62670: EMPTY
62671: LIST
62672: LIST
62673: PUSH
62674: LD_INT 1
62676: PUSH
62677: LD_INT 1
62679: NEG
62680: PUSH
62681: EMPTY
62682: LIST
62683: LIST
62684: PUSH
62685: LD_INT 2
62687: PUSH
62688: LD_INT 0
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: PUSH
62695: LD_INT 2
62697: PUSH
62698: LD_INT 1
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PUSH
62705: LD_INT 2
62707: PUSH
62708: LD_INT 2
62710: PUSH
62711: EMPTY
62712: LIST
62713: LIST
62714: PUSH
62715: LD_INT 1
62717: PUSH
62718: LD_INT 2
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: PUSH
62725: LD_INT 0
62727: PUSH
62728: LD_INT 2
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PUSH
62735: LD_INT 1
62737: NEG
62738: PUSH
62739: LD_INT 1
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: PUSH
62746: LD_INT 2
62748: NEG
62749: PUSH
62750: LD_INT 0
62752: PUSH
62753: EMPTY
62754: LIST
62755: LIST
62756: PUSH
62757: LD_INT 2
62759: NEG
62760: PUSH
62761: LD_INT 1
62763: NEG
62764: PUSH
62765: EMPTY
62766: LIST
62767: LIST
62768: PUSH
62769: LD_INT 2
62771: NEG
62772: PUSH
62773: LD_INT 2
62775: NEG
62776: PUSH
62777: EMPTY
62778: LIST
62779: LIST
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: LIST
62792: LIST
62793: LIST
62794: LIST
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: LIST
62800: LIST
62801: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
62802: LD_ADDR_VAR 0 23
62806: PUSH
62807: LD_INT 0
62809: PUSH
62810: LD_INT 0
62812: PUSH
62813: EMPTY
62814: LIST
62815: LIST
62816: PUSH
62817: LD_INT 0
62819: PUSH
62820: LD_INT 1
62822: NEG
62823: PUSH
62824: EMPTY
62825: LIST
62826: LIST
62827: PUSH
62828: LD_INT 1
62830: PUSH
62831: LD_INT 0
62833: PUSH
62834: EMPTY
62835: LIST
62836: LIST
62837: PUSH
62838: LD_INT 1
62840: PUSH
62841: LD_INT 1
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: PUSH
62848: LD_INT 0
62850: PUSH
62851: LD_INT 1
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PUSH
62858: LD_INT 1
62860: NEG
62861: PUSH
62862: LD_INT 0
62864: PUSH
62865: EMPTY
62866: LIST
62867: LIST
62868: PUSH
62869: LD_INT 1
62871: NEG
62872: PUSH
62873: LD_INT 1
62875: NEG
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: PUSH
62881: LD_INT 1
62883: NEG
62884: PUSH
62885: LD_INT 2
62887: NEG
62888: PUSH
62889: EMPTY
62890: LIST
62891: LIST
62892: PUSH
62893: LD_INT 0
62895: PUSH
62896: LD_INT 2
62898: NEG
62899: PUSH
62900: EMPTY
62901: LIST
62902: LIST
62903: PUSH
62904: LD_INT 1
62906: PUSH
62907: LD_INT 1
62909: NEG
62910: PUSH
62911: EMPTY
62912: LIST
62913: LIST
62914: PUSH
62915: LD_INT 2
62917: PUSH
62918: LD_INT 0
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: LD_INT 2
62927: PUSH
62928: LD_INT 1
62930: PUSH
62931: EMPTY
62932: LIST
62933: LIST
62934: PUSH
62935: LD_INT 2
62937: PUSH
62938: LD_INT 2
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: PUSH
62945: LD_INT 1
62947: PUSH
62948: LD_INT 2
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: PUSH
62955: LD_INT 0
62957: PUSH
62958: LD_INT 2
62960: PUSH
62961: EMPTY
62962: LIST
62963: LIST
62964: PUSH
62965: LD_INT 1
62967: NEG
62968: PUSH
62969: LD_INT 1
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 2
62978: NEG
62979: PUSH
62980: LD_INT 0
62982: PUSH
62983: EMPTY
62984: LIST
62985: LIST
62986: PUSH
62987: LD_INT 2
62989: NEG
62990: PUSH
62991: LD_INT 1
62993: NEG
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: LD_INT 2
63001: NEG
63002: PUSH
63003: LD_INT 2
63005: NEG
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 2
63013: NEG
63014: PUSH
63015: LD_INT 3
63017: NEG
63018: PUSH
63019: EMPTY
63020: LIST
63021: LIST
63022: PUSH
63023: LD_INT 1
63025: NEG
63026: PUSH
63027: LD_INT 3
63029: NEG
63030: PUSH
63031: EMPTY
63032: LIST
63033: LIST
63034: PUSH
63035: LD_INT 1
63037: PUSH
63038: LD_INT 2
63040: NEG
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: LD_INT 2
63048: PUSH
63049: LD_INT 1
63051: NEG
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: LIST
63065: LIST
63066: LIST
63067: LIST
63068: LIST
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: LIST
63074: LIST
63075: LIST
63076: LIST
63077: LIST
63078: LIST
63079: LIST
63080: LIST
63081: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
63082: LD_ADDR_VAR 0 24
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: LD_INT 0
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 0
63099: PUSH
63100: LD_INT 1
63102: NEG
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 1
63110: PUSH
63111: LD_INT 0
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 1
63120: PUSH
63121: LD_INT 1
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 0
63130: PUSH
63131: LD_INT 1
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: LD_INT 1
63140: NEG
63141: PUSH
63142: LD_INT 0
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PUSH
63149: LD_INT 1
63151: NEG
63152: PUSH
63153: LD_INT 1
63155: NEG
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 1
63163: NEG
63164: PUSH
63165: LD_INT 2
63167: NEG
63168: PUSH
63169: EMPTY
63170: LIST
63171: LIST
63172: PUSH
63173: LD_INT 0
63175: PUSH
63176: LD_INT 2
63178: NEG
63179: PUSH
63180: EMPTY
63181: LIST
63182: LIST
63183: PUSH
63184: LD_INT 1
63186: PUSH
63187: LD_INT 1
63189: NEG
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 2
63197: PUSH
63198: LD_INT 0
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 2
63207: PUSH
63208: LD_INT 1
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: LD_INT 2
63217: PUSH
63218: LD_INT 2
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: LD_INT 1
63227: PUSH
63228: LD_INT 2
63230: PUSH
63231: EMPTY
63232: LIST
63233: LIST
63234: PUSH
63235: LD_INT 0
63237: PUSH
63238: LD_INT 2
63240: PUSH
63241: EMPTY
63242: LIST
63243: LIST
63244: PUSH
63245: LD_INT 1
63247: NEG
63248: PUSH
63249: LD_INT 1
63251: PUSH
63252: EMPTY
63253: LIST
63254: LIST
63255: PUSH
63256: LD_INT 2
63258: NEG
63259: PUSH
63260: LD_INT 0
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: PUSH
63267: LD_INT 2
63269: NEG
63270: PUSH
63271: LD_INT 1
63273: NEG
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: LD_INT 2
63281: NEG
63282: PUSH
63283: LD_INT 2
63285: NEG
63286: PUSH
63287: EMPTY
63288: LIST
63289: LIST
63290: PUSH
63291: LD_INT 1
63293: PUSH
63294: LD_INT 2
63296: NEG
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 2
63304: PUSH
63305: LD_INT 1
63307: NEG
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 3
63315: PUSH
63316: LD_INT 1
63318: PUSH
63319: EMPTY
63320: LIST
63321: LIST
63322: PUSH
63323: LD_INT 3
63325: PUSH
63326: LD_INT 2
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: LIST
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
63358: LD_ADDR_VAR 0 25
63362: PUSH
63363: LD_INT 0
63365: PUSH
63366: LD_INT 0
63368: PUSH
63369: EMPTY
63370: LIST
63371: LIST
63372: PUSH
63373: LD_INT 0
63375: PUSH
63376: LD_INT 1
63378: NEG
63379: PUSH
63380: EMPTY
63381: LIST
63382: LIST
63383: PUSH
63384: LD_INT 1
63386: PUSH
63387: LD_INT 0
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: PUSH
63394: LD_INT 1
63396: PUSH
63397: LD_INT 1
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: LD_INT 0
63406: PUSH
63407: LD_INT 1
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: PUSH
63414: LD_INT 1
63416: NEG
63417: PUSH
63418: LD_INT 0
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 1
63427: NEG
63428: PUSH
63429: LD_INT 1
63431: NEG
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 1
63439: NEG
63440: PUSH
63441: LD_INT 2
63443: NEG
63444: PUSH
63445: EMPTY
63446: LIST
63447: LIST
63448: PUSH
63449: LD_INT 0
63451: PUSH
63452: LD_INT 2
63454: NEG
63455: PUSH
63456: EMPTY
63457: LIST
63458: LIST
63459: PUSH
63460: LD_INT 1
63462: PUSH
63463: LD_INT 1
63465: NEG
63466: PUSH
63467: EMPTY
63468: LIST
63469: LIST
63470: PUSH
63471: LD_INT 2
63473: PUSH
63474: LD_INT 0
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: LD_INT 2
63483: PUSH
63484: LD_INT 1
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 2
63493: PUSH
63494: LD_INT 2
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: PUSH
63504: LD_INT 2
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 0
63513: PUSH
63514: LD_INT 2
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 1
63523: NEG
63524: PUSH
63525: LD_INT 1
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: LD_INT 2
63534: NEG
63535: PUSH
63536: LD_INT 0
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: LD_INT 2
63545: NEG
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 2
63557: NEG
63558: PUSH
63559: LD_INT 2
63561: NEG
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 3
63569: PUSH
63570: LD_INT 1
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 3
63579: PUSH
63580: LD_INT 2
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: LD_INT 2
63589: PUSH
63590: LD_INT 3
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: PUSH
63597: LD_INT 1
63599: PUSH
63600: LD_INT 3
63602: PUSH
63603: EMPTY
63604: LIST
63605: LIST
63606: PUSH
63607: EMPTY
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
63632: LD_ADDR_VAR 0 26
63636: PUSH
63637: LD_INT 0
63639: PUSH
63640: LD_INT 0
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: PUSH
63647: LD_INT 0
63649: PUSH
63650: LD_INT 1
63652: NEG
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PUSH
63658: LD_INT 1
63660: PUSH
63661: LD_INT 0
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: PUSH
63668: LD_INT 1
63670: PUSH
63671: LD_INT 1
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: PUSH
63678: LD_INT 0
63680: PUSH
63681: LD_INT 1
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: PUSH
63688: LD_INT 1
63690: NEG
63691: PUSH
63692: LD_INT 0
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: PUSH
63699: LD_INT 1
63701: NEG
63702: PUSH
63703: LD_INT 1
63705: NEG
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 1
63713: NEG
63714: PUSH
63715: LD_INT 2
63717: NEG
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PUSH
63723: LD_INT 0
63725: PUSH
63726: LD_INT 2
63728: NEG
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PUSH
63734: LD_INT 1
63736: PUSH
63737: LD_INT 1
63739: NEG
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: LD_INT 2
63747: PUSH
63748: LD_INT 0
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 2
63757: PUSH
63758: LD_INT 1
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: PUSH
63765: LD_INT 2
63767: PUSH
63768: LD_INT 2
63770: PUSH
63771: EMPTY
63772: LIST
63773: LIST
63774: PUSH
63775: LD_INT 1
63777: PUSH
63778: LD_INT 2
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 0
63787: PUSH
63788: LD_INT 2
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PUSH
63795: LD_INT 1
63797: NEG
63798: PUSH
63799: LD_INT 1
63801: PUSH
63802: EMPTY
63803: LIST
63804: LIST
63805: PUSH
63806: LD_INT 2
63808: NEG
63809: PUSH
63810: LD_INT 0
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: PUSH
63817: LD_INT 2
63819: NEG
63820: PUSH
63821: LD_INT 1
63823: NEG
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 2
63831: NEG
63832: PUSH
63833: LD_INT 2
63835: NEG
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: LD_INT 2
63843: PUSH
63844: LD_INT 3
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 1
63853: PUSH
63854: LD_INT 3
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 1
63863: NEG
63864: PUSH
63865: LD_INT 2
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PUSH
63872: LD_INT 2
63874: NEG
63875: PUSH
63876: LD_INT 1
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
63908: LD_ADDR_VAR 0 27
63912: PUSH
63913: LD_INT 0
63915: PUSH
63916: LD_INT 0
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: PUSH
63923: LD_INT 0
63925: PUSH
63926: LD_INT 1
63928: NEG
63929: PUSH
63930: EMPTY
63931: LIST
63932: LIST
63933: PUSH
63934: LD_INT 1
63936: PUSH
63937: LD_INT 0
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PUSH
63944: LD_INT 1
63946: PUSH
63947: LD_INT 1
63949: PUSH
63950: EMPTY
63951: LIST
63952: LIST
63953: PUSH
63954: LD_INT 0
63956: PUSH
63957: LD_INT 1
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 1
63966: NEG
63967: PUSH
63968: LD_INT 0
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 1
63977: NEG
63978: PUSH
63979: LD_INT 1
63981: NEG
63982: PUSH
63983: EMPTY
63984: LIST
63985: LIST
63986: PUSH
63987: LD_INT 1
63989: NEG
63990: PUSH
63991: LD_INT 2
63993: NEG
63994: PUSH
63995: EMPTY
63996: LIST
63997: LIST
63998: PUSH
63999: LD_INT 0
64001: PUSH
64002: LD_INT 2
64004: NEG
64005: PUSH
64006: EMPTY
64007: LIST
64008: LIST
64009: PUSH
64010: LD_INT 1
64012: PUSH
64013: LD_INT 1
64015: NEG
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: PUSH
64021: LD_INT 2
64023: PUSH
64024: LD_INT 0
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PUSH
64031: LD_INT 2
64033: PUSH
64034: LD_INT 1
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: PUSH
64041: LD_INT 2
64043: PUSH
64044: LD_INT 2
64046: PUSH
64047: EMPTY
64048: LIST
64049: LIST
64050: PUSH
64051: LD_INT 1
64053: PUSH
64054: LD_INT 2
64056: PUSH
64057: EMPTY
64058: LIST
64059: LIST
64060: PUSH
64061: LD_INT 0
64063: PUSH
64064: LD_INT 2
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: LD_INT 1
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PUSH
64082: LD_INT 2
64084: NEG
64085: PUSH
64086: LD_INT 0
64088: PUSH
64089: EMPTY
64090: LIST
64091: LIST
64092: PUSH
64093: LD_INT 2
64095: NEG
64096: PUSH
64097: LD_INT 1
64099: NEG
64100: PUSH
64101: EMPTY
64102: LIST
64103: LIST
64104: PUSH
64105: LD_INT 2
64107: NEG
64108: PUSH
64109: LD_INT 2
64111: NEG
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 1
64119: NEG
64120: PUSH
64121: LD_INT 2
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: LD_INT 2
64130: NEG
64131: PUSH
64132: LD_INT 1
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: PUSH
64139: LD_INT 3
64141: NEG
64142: PUSH
64143: LD_INT 1
64145: NEG
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: PUSH
64151: LD_INT 3
64153: NEG
64154: PUSH
64155: LD_INT 2
64157: NEG
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: LIST
64167: LIST
64168: LIST
64169: LIST
64170: LIST
64171: LIST
64172: LIST
64173: LIST
64174: LIST
64175: LIST
64176: LIST
64177: LIST
64178: LIST
64179: LIST
64180: LIST
64181: LIST
64182: LIST
64183: LIST
64184: LIST
64185: LIST
64186: LIST
64187: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64188: LD_ADDR_VAR 0 28
64192: PUSH
64193: LD_INT 0
64195: PUSH
64196: LD_INT 0
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: LD_INT 0
64205: PUSH
64206: LD_INT 1
64208: NEG
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: PUSH
64214: LD_INT 1
64216: PUSH
64217: LD_INT 0
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PUSH
64224: LD_INT 1
64226: PUSH
64227: LD_INT 1
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 0
64236: PUSH
64237: LD_INT 1
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: PUSH
64244: LD_INT 1
64246: NEG
64247: PUSH
64248: LD_INT 0
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 1
64257: NEG
64258: PUSH
64259: LD_INT 1
64261: NEG
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 1
64269: NEG
64270: PUSH
64271: LD_INT 2
64273: NEG
64274: PUSH
64275: EMPTY
64276: LIST
64277: LIST
64278: PUSH
64279: LD_INT 0
64281: PUSH
64282: LD_INT 2
64284: NEG
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: PUSH
64290: LD_INT 1
64292: PUSH
64293: LD_INT 1
64295: NEG
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: LD_INT 2
64303: PUSH
64304: LD_INT 0
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 2
64313: PUSH
64314: LD_INT 1
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: LD_INT 2
64323: PUSH
64324: LD_INT 2
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 1
64333: PUSH
64334: LD_INT 2
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: LD_INT 0
64343: PUSH
64344: LD_INT 2
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 1
64353: NEG
64354: PUSH
64355: LD_INT 1
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: PUSH
64362: LD_INT 2
64364: NEG
64365: PUSH
64366: LD_INT 0
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PUSH
64373: LD_INT 2
64375: NEG
64376: PUSH
64377: LD_INT 1
64379: NEG
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: LD_INT 2
64387: NEG
64388: PUSH
64389: LD_INT 2
64391: NEG
64392: PUSH
64393: EMPTY
64394: LIST
64395: LIST
64396: PUSH
64397: LD_INT 2
64399: NEG
64400: PUSH
64401: LD_INT 3
64403: NEG
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 1
64411: NEG
64412: PUSH
64413: LD_INT 3
64415: NEG
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 3
64423: NEG
64424: PUSH
64425: LD_INT 1
64427: NEG
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 3
64435: NEG
64436: PUSH
64437: LD_INT 2
64439: NEG
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
64470: LD_ADDR_VAR 0 29
64474: PUSH
64475: LD_INT 0
64477: PUSH
64478: LD_INT 0
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: LD_INT 0
64487: PUSH
64488: LD_INT 1
64490: NEG
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_INT 1
64498: PUSH
64499: LD_INT 0
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 1
64508: PUSH
64509: LD_INT 1
64511: PUSH
64512: EMPTY
64513: LIST
64514: LIST
64515: PUSH
64516: LD_INT 0
64518: PUSH
64519: LD_INT 1
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: PUSH
64526: LD_INT 1
64528: NEG
64529: PUSH
64530: LD_INT 0
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PUSH
64537: LD_INT 1
64539: NEG
64540: PUSH
64541: LD_INT 1
64543: NEG
64544: PUSH
64545: EMPTY
64546: LIST
64547: LIST
64548: PUSH
64549: LD_INT 1
64551: NEG
64552: PUSH
64553: LD_INT 2
64555: NEG
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 0
64563: PUSH
64564: LD_INT 2
64566: NEG
64567: PUSH
64568: EMPTY
64569: LIST
64570: LIST
64571: PUSH
64572: LD_INT 1
64574: PUSH
64575: LD_INT 1
64577: NEG
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: PUSH
64583: LD_INT 2
64585: PUSH
64586: LD_INT 0
64588: PUSH
64589: EMPTY
64590: LIST
64591: LIST
64592: PUSH
64593: LD_INT 2
64595: PUSH
64596: LD_INT 1
64598: PUSH
64599: EMPTY
64600: LIST
64601: LIST
64602: PUSH
64603: LD_INT 1
64605: PUSH
64606: LD_INT 2
64608: PUSH
64609: EMPTY
64610: LIST
64611: LIST
64612: PUSH
64613: LD_INT 0
64615: PUSH
64616: LD_INT 2
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: PUSH
64623: LD_INT 1
64625: NEG
64626: PUSH
64627: LD_INT 1
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 2
64636: NEG
64637: PUSH
64638: LD_INT 1
64640: NEG
64641: PUSH
64642: EMPTY
64643: LIST
64644: LIST
64645: PUSH
64646: LD_INT 2
64648: NEG
64649: PUSH
64650: LD_INT 2
64652: NEG
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: PUSH
64658: LD_INT 2
64660: NEG
64661: PUSH
64662: LD_INT 3
64664: NEG
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 2
64672: PUSH
64673: LD_INT 1
64675: NEG
64676: PUSH
64677: EMPTY
64678: LIST
64679: LIST
64680: PUSH
64681: LD_INT 3
64683: PUSH
64684: LD_INT 1
64686: PUSH
64687: EMPTY
64688: LIST
64689: LIST
64690: PUSH
64691: LD_INT 1
64693: PUSH
64694: LD_INT 3
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: PUSH
64701: LD_INT 1
64703: NEG
64704: PUSH
64705: LD_INT 2
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: PUSH
64712: LD_INT 3
64714: NEG
64715: PUSH
64716: LD_INT 2
64718: NEG
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: LIST
64734: LIST
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: LIST
64740: LIST
64741: LIST
64742: LIST
64743: LIST
64744: LIST
64745: LIST
64746: LIST
64747: LIST
64748: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
64749: LD_ADDR_VAR 0 30
64753: PUSH
64754: LD_INT 0
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 0
64766: PUSH
64767: LD_INT 1
64769: NEG
64770: PUSH
64771: EMPTY
64772: LIST
64773: LIST
64774: PUSH
64775: LD_INT 1
64777: PUSH
64778: LD_INT 0
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 1
64787: PUSH
64788: LD_INT 1
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: LD_INT 0
64797: PUSH
64798: LD_INT 1
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 1
64807: NEG
64808: PUSH
64809: LD_INT 0
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 1
64818: NEG
64819: PUSH
64820: LD_INT 1
64822: NEG
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 1
64830: NEG
64831: PUSH
64832: LD_INT 2
64834: NEG
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PUSH
64840: LD_INT 0
64842: PUSH
64843: LD_INT 2
64845: NEG
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 1
64853: PUSH
64854: LD_INT 1
64856: NEG
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 2
64864: PUSH
64865: LD_INT 0
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 2
64874: PUSH
64875: LD_INT 1
64877: PUSH
64878: EMPTY
64879: LIST
64880: LIST
64881: PUSH
64882: LD_INT 2
64884: PUSH
64885: LD_INT 2
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 1
64894: PUSH
64895: LD_INT 2
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PUSH
64902: LD_INT 1
64904: NEG
64905: PUSH
64906: LD_INT 1
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 2
64915: NEG
64916: PUSH
64917: LD_INT 0
64919: PUSH
64920: EMPTY
64921: LIST
64922: LIST
64923: PUSH
64924: LD_INT 2
64926: NEG
64927: PUSH
64928: LD_INT 1
64930: NEG
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 1
64938: NEG
64939: PUSH
64940: LD_INT 3
64942: NEG
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: PUSH
64948: LD_INT 1
64950: PUSH
64951: LD_INT 2
64953: NEG
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: PUSH
64959: LD_INT 3
64961: PUSH
64962: LD_INT 2
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: PUSH
64969: LD_INT 2
64971: PUSH
64972: LD_INT 3
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: LD_INT 2
64981: NEG
64982: PUSH
64983: LD_INT 1
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: PUSH
64990: LD_INT 3
64992: NEG
64993: PUSH
64994: LD_INT 1
64996: NEG
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: LIST
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65027: LD_ADDR_VAR 0 31
65031: PUSH
65032: LD_INT 0
65034: PUSH
65035: LD_INT 0
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 0
65044: PUSH
65045: LD_INT 1
65047: NEG
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: LD_INT 1
65055: PUSH
65056: LD_INT 0
65058: PUSH
65059: EMPTY
65060: LIST
65061: LIST
65062: PUSH
65063: LD_INT 1
65065: PUSH
65066: LD_INT 1
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PUSH
65073: LD_INT 0
65075: PUSH
65076: LD_INT 1
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: PUSH
65083: LD_INT 1
65085: NEG
65086: PUSH
65087: LD_INT 0
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PUSH
65094: LD_INT 1
65096: NEG
65097: PUSH
65098: LD_INT 1
65100: NEG
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PUSH
65106: LD_INT 1
65108: NEG
65109: PUSH
65110: LD_INT 2
65112: NEG
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 1
65120: PUSH
65121: LD_INT 1
65123: NEG
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 2
65131: PUSH
65132: LD_INT 0
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 2
65141: PUSH
65142: LD_INT 1
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 2
65151: PUSH
65152: LD_INT 2
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 1
65161: PUSH
65162: LD_INT 2
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: LD_INT 2
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: PUSH
65179: LD_INT 1
65181: NEG
65182: PUSH
65183: LD_INT 1
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PUSH
65190: LD_INT 2
65192: NEG
65193: PUSH
65194: LD_INT 1
65196: NEG
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 2
65204: NEG
65205: PUSH
65206: LD_INT 2
65208: NEG
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: LD_INT 2
65216: NEG
65217: PUSH
65218: LD_INT 3
65220: NEG
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: PUSH
65226: LD_INT 2
65228: PUSH
65229: LD_INT 1
65231: NEG
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 3
65239: PUSH
65240: LD_INT 1
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: PUSH
65247: LD_INT 1
65249: PUSH
65250: LD_INT 3
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 1
65259: NEG
65260: PUSH
65261: LD_INT 2
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 3
65270: NEG
65271: PUSH
65272: LD_INT 2
65274: NEG
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: EMPTY
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: LIST
65295: LIST
65296: LIST
65297: LIST
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: LIST
65303: LIST
65304: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65305: LD_ADDR_VAR 0 32
65309: PUSH
65310: LD_INT 0
65312: PUSH
65313: LD_INT 0
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: PUSH
65320: LD_INT 0
65322: PUSH
65323: LD_INT 1
65325: NEG
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 1
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: LD_INT 1
65343: PUSH
65344: LD_INT 1
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 0
65353: PUSH
65354: LD_INT 1
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 1
65363: NEG
65364: PUSH
65365: LD_INT 0
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PUSH
65372: LD_INT 1
65374: NEG
65375: PUSH
65376: LD_INT 1
65378: NEG
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PUSH
65384: LD_INT 1
65386: NEG
65387: PUSH
65388: LD_INT 2
65390: NEG
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 2
65401: NEG
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 1
65409: PUSH
65410: LD_INT 1
65412: NEG
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: PUSH
65418: LD_INT 2
65420: PUSH
65421: LD_INT 1
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 2
65430: PUSH
65431: LD_INT 2
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 1
65440: PUSH
65441: LD_INT 2
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 0
65450: PUSH
65451: LD_INT 2
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: PUSH
65458: LD_INT 1
65460: NEG
65461: PUSH
65462: LD_INT 1
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: LD_INT 2
65471: NEG
65472: PUSH
65473: LD_INT 0
65475: PUSH
65476: EMPTY
65477: LIST
65478: LIST
65479: PUSH
65480: LD_INT 2
65482: NEG
65483: PUSH
65484: LD_INT 1
65486: NEG
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: LD_INT 1
65494: NEG
65495: PUSH
65496: LD_INT 3
65498: NEG
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 1
65506: PUSH
65507: LD_INT 2
65509: NEG
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 3
65517: PUSH
65518: LD_INT 2
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: LD_INT 2
65527: PUSH
65528: LD_INT 3
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: LD_INT 2
65537: NEG
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: PUSH
65546: LD_INT 3
65548: NEG
65549: PUSH
65550: LD_INT 1
65552: NEG
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: LIST
65573: LIST
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65583: LD_ADDR_VAR 0 33
65587: PUSH
65588: LD_INT 0
65590: PUSH
65591: LD_INT 0
65593: PUSH
65594: EMPTY
65595: LIST
65596: LIST
65597: PUSH
65598: LD_INT 0
65600: PUSH
65601: LD_INT 1
65603: NEG
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 1
65611: PUSH
65612: LD_INT 0
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PUSH
65619: LD_INT 1
65621: PUSH
65622: LD_INT 1
65624: PUSH
65625: EMPTY
65626: LIST
65627: LIST
65628: PUSH
65629: LD_INT 0
65631: PUSH
65632: LD_INT 1
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: LD_INT 1
65641: NEG
65642: PUSH
65643: LD_INT 0
65645: PUSH
65646: EMPTY
65647: LIST
65648: LIST
65649: PUSH
65650: LD_INT 1
65652: NEG
65653: PUSH
65654: LD_INT 1
65656: NEG
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 1
65664: NEG
65665: PUSH
65666: LD_INT 2
65668: NEG
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 1
65676: PUSH
65677: LD_INT 1
65679: NEG
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 2
65687: PUSH
65688: LD_INT 0
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 2
65697: PUSH
65698: LD_INT 1
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: LD_INT 1
65707: PUSH
65708: LD_INT 2
65710: PUSH
65711: EMPTY
65712: LIST
65713: LIST
65714: PUSH
65715: LD_INT 0
65717: PUSH
65718: LD_INT 2
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: LD_INT 1
65727: NEG
65728: PUSH
65729: LD_INT 1
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 2
65738: NEG
65739: PUSH
65740: LD_INT 0
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 2
65749: NEG
65750: PUSH
65751: LD_INT 1
65753: NEG
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 2
65761: NEG
65762: PUSH
65763: LD_INT 2
65765: NEG
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: LD_INT 2
65773: NEG
65774: PUSH
65775: LD_INT 3
65777: NEG
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: PUSH
65783: LD_INT 2
65785: PUSH
65786: LD_INT 1
65788: NEG
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 3
65796: PUSH
65797: LD_INT 1
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: PUSH
65804: LD_INT 1
65806: PUSH
65807: LD_INT 3
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 1
65816: NEG
65817: PUSH
65818: LD_INT 2
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 3
65827: NEG
65828: PUSH
65829: LD_INT 2
65831: NEG
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65862: LD_ADDR_VAR 0 34
65866: PUSH
65867: LD_INT 0
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 0
65879: PUSH
65880: LD_INT 1
65882: NEG
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 1
65890: PUSH
65891: LD_INT 0
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 1
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 0
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: LD_INT 1
65920: NEG
65921: PUSH
65922: LD_INT 0
65924: PUSH
65925: EMPTY
65926: LIST
65927: LIST
65928: PUSH
65929: LD_INT 1
65931: NEG
65932: PUSH
65933: LD_INT 1
65935: NEG
65936: PUSH
65937: EMPTY
65938: LIST
65939: LIST
65940: PUSH
65941: LD_INT 1
65943: NEG
65944: PUSH
65945: LD_INT 2
65947: NEG
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: PUSH
65953: LD_INT 0
65955: PUSH
65956: LD_INT 2
65958: NEG
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 1
65966: PUSH
65967: LD_INT 1
65969: NEG
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 2
65977: PUSH
65978: LD_INT 1
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 2
65987: PUSH
65988: LD_INT 2
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 1
65997: PUSH
65998: LD_INT 2
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 1
66007: NEG
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 2
66018: NEG
66019: PUSH
66020: LD_INT 0
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 2
66029: NEG
66030: PUSH
66031: LD_INT 1
66033: NEG
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 2
66041: NEG
66042: PUSH
66043: LD_INT 2
66045: NEG
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 1
66053: NEG
66054: PUSH
66055: LD_INT 3
66057: NEG
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PUSH
66063: LD_INT 1
66065: PUSH
66066: LD_INT 2
66068: NEG
66069: PUSH
66070: EMPTY
66071: LIST
66072: LIST
66073: PUSH
66074: LD_INT 3
66076: PUSH
66077: LD_INT 2
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 2
66086: PUSH
66087: LD_INT 3
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 2
66096: NEG
66097: PUSH
66098: LD_INT 1
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 3
66107: NEG
66108: PUSH
66109: LD_INT 1
66111: NEG
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: LIST
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: LIST
66126: LIST
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
66142: LD_ADDR_VAR 0 35
66146: PUSH
66147: LD_INT 0
66149: PUSH
66150: LD_INT 0
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: LD_INT 0
66159: PUSH
66160: LD_INT 1
66162: NEG
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 1
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 1
66180: PUSH
66181: LD_INT 1
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: LD_INT 0
66190: PUSH
66191: LD_INT 1
66193: PUSH
66194: EMPTY
66195: LIST
66196: LIST
66197: PUSH
66198: LD_INT 1
66200: NEG
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 1
66211: NEG
66212: PUSH
66213: LD_INT 1
66215: NEG
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: LD_INT 2
66223: PUSH
66224: LD_INT 1
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: PUSH
66231: LD_INT 2
66233: NEG
66234: PUSH
66235: LD_INT 1
66237: NEG
66238: PUSH
66239: EMPTY
66240: LIST
66241: LIST
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
66254: LD_ADDR_VAR 0 36
66258: PUSH
66259: LD_INT 0
66261: PUSH
66262: LD_INT 0
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 0
66271: PUSH
66272: LD_INT 1
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 1
66282: PUSH
66283: LD_INT 0
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 1
66292: PUSH
66293: LD_INT 1
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 0
66302: PUSH
66303: LD_INT 1
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: NEG
66313: PUSH
66314: LD_INT 0
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 1
66323: NEG
66324: PUSH
66325: LD_INT 1
66327: NEG
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: LD_INT 1
66335: NEG
66336: PUSH
66337: LD_INT 2
66339: NEG
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: PUSH
66345: LD_INT 1
66347: PUSH
66348: LD_INT 2
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
66366: LD_ADDR_VAR 0 37
66370: PUSH
66371: LD_INT 0
66373: PUSH
66374: LD_INT 0
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: LD_INT 0
66383: PUSH
66384: LD_INT 1
66386: NEG
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 1
66394: PUSH
66395: LD_INT 0
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: LD_INT 1
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: LD_INT 1
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: LD_INT 0
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 1
66435: NEG
66436: PUSH
66437: LD_INT 1
66439: NEG
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 1
66447: PUSH
66448: LD_INT 1
66450: NEG
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 1
66458: NEG
66459: PUSH
66460: LD_INT 1
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
66478: LD_ADDR_VAR 0 38
66482: PUSH
66483: LD_INT 0
66485: PUSH
66486: LD_INT 0
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 0
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 1
66506: PUSH
66507: LD_INT 0
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 1
66516: PUSH
66517: LD_INT 1
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 0
66526: PUSH
66527: LD_INT 1
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: NEG
66537: PUSH
66538: LD_INT 0
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 1
66547: NEG
66548: PUSH
66549: LD_INT 1
66551: NEG
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 2
66559: PUSH
66560: LD_INT 1
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: PUSH
66567: LD_INT 2
66569: NEG
66570: PUSH
66571: LD_INT 1
66573: NEG
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
66590: LD_ADDR_VAR 0 39
66594: PUSH
66595: LD_INT 0
66597: PUSH
66598: LD_INT 0
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: LD_INT 1
66610: NEG
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: PUSH
66619: LD_INT 0
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 1
66628: PUSH
66629: LD_INT 1
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 0
66638: PUSH
66639: LD_INT 1
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 1
66648: NEG
66649: PUSH
66650: LD_INT 0
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 1
66659: NEG
66660: PUSH
66661: LD_INT 1
66663: NEG
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 1
66671: NEG
66672: PUSH
66673: LD_INT 2
66675: NEG
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 1
66683: PUSH
66684: LD_INT 2
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
66702: LD_ADDR_VAR 0 40
66706: PUSH
66707: LD_INT 0
66709: PUSH
66710: LD_INT 0
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 0
66719: PUSH
66720: LD_INT 1
66722: NEG
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 1
66730: PUSH
66731: LD_INT 0
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: PUSH
66741: LD_INT 1
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: PUSH
66748: LD_INT 0
66750: PUSH
66751: LD_INT 1
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: NEG
66761: PUSH
66762: LD_INT 0
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 1
66771: NEG
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: LD_INT 1
66783: PUSH
66784: LD_INT 1
66786: NEG
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PUSH
66792: LD_INT 1
66794: NEG
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: LIST
66809: LIST
66810: LIST
66811: LIST
66812: LIST
66813: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66814: LD_ADDR_VAR 0 41
66818: PUSH
66819: LD_INT 0
66821: PUSH
66822: LD_INT 0
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 0
66831: PUSH
66832: LD_INT 1
66834: NEG
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: LD_INT 1
66842: PUSH
66843: LD_INT 0
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PUSH
66850: LD_INT 1
66852: PUSH
66853: LD_INT 1
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: LD_INT 1
66865: PUSH
66866: EMPTY
66867: LIST
66868: LIST
66869: PUSH
66870: LD_INT 1
66872: NEG
66873: PUSH
66874: LD_INT 0
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 1
66883: NEG
66884: PUSH
66885: LD_INT 1
66887: NEG
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 1
66895: NEG
66896: PUSH
66897: LD_INT 2
66899: NEG
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 1
66907: PUSH
66908: LD_INT 1
66910: NEG
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: LD_INT 0
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: LD_INT 1
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: PUSH
66936: LD_INT 2
66938: PUSH
66939: LD_INT 2
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 1
66948: PUSH
66949: LD_INT 2
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: LD_INT 1
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 2
66969: NEG
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 2
66980: NEG
66981: PUSH
66982: LD_INT 1
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 2
66992: NEG
66993: PUSH
66994: LD_INT 2
66996: NEG
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 2
67004: NEG
67005: PUSH
67006: LD_INT 3
67008: NEG
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 2
67016: PUSH
67017: LD_INT 1
67019: NEG
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 3
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 3
67037: PUSH
67038: LD_INT 1
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 3
67047: PUSH
67048: LD_INT 2
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PUSH
67055: LD_INT 3
67057: PUSH
67058: LD_INT 3
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 2
67067: PUSH
67068: LD_INT 3
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 2
67077: NEG
67078: PUSH
67079: LD_INT 1
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 3
67088: NEG
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: LD_INT 3
67099: NEG
67100: PUSH
67101: LD_INT 1
67103: NEG
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 3
67111: NEG
67112: PUSH
67113: LD_INT 2
67115: NEG
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 3
67123: NEG
67124: PUSH
67125: LD_INT 3
67127: NEG
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67164: LD_ADDR_VAR 0 42
67168: PUSH
67169: LD_INT 0
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 0
67181: PUSH
67182: LD_INT 1
67184: NEG
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: PUSH
67190: LD_INT 1
67192: PUSH
67193: LD_INT 0
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: PUSH
67200: LD_INT 1
67202: PUSH
67203: LD_INT 1
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 0
67212: PUSH
67213: LD_INT 1
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 1
67222: NEG
67223: PUSH
67224: LD_INT 0
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 1
67233: NEG
67234: PUSH
67235: LD_INT 1
67237: NEG
67238: PUSH
67239: EMPTY
67240: LIST
67241: LIST
67242: PUSH
67243: LD_INT 1
67245: NEG
67246: PUSH
67247: LD_INT 2
67249: NEG
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 0
67257: PUSH
67258: LD_INT 2
67260: NEG
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 1
67268: PUSH
67269: LD_INT 1
67271: NEG
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: LD_INT 2
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 2
67289: PUSH
67290: LD_INT 2
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: PUSH
67300: LD_INT 2
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 0
67309: PUSH
67310: LD_INT 2
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 1
67319: NEG
67320: PUSH
67321: LD_INT 1
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 2
67330: NEG
67331: PUSH
67332: LD_INT 1
67334: NEG
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 2
67342: NEG
67343: PUSH
67344: LD_INT 2
67346: NEG
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 2
67354: NEG
67355: PUSH
67356: LD_INT 3
67358: NEG
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 1
67366: NEG
67367: PUSH
67368: LD_INT 3
67370: NEG
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 0
67378: PUSH
67379: LD_INT 3
67381: NEG
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 1
67389: PUSH
67390: LD_INT 2
67392: NEG
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 3
67400: PUSH
67401: LD_INT 2
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 3
67410: PUSH
67411: LD_INT 3
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 2
67420: PUSH
67421: LD_INT 3
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: PUSH
67428: LD_INT 1
67430: PUSH
67431: LD_INT 3
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 0
67440: PUSH
67441: LD_INT 3
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PUSH
67448: LD_INT 1
67450: NEG
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: LD_INT 3
67461: NEG
67462: PUSH
67463: LD_INT 2
67465: NEG
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 3
67473: NEG
67474: PUSH
67475: LD_INT 3
67477: NEG
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67514: LD_ADDR_VAR 0 43
67518: PUSH
67519: LD_INT 0
67521: PUSH
67522: LD_INT 0
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: LD_INT 1
67534: NEG
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: LD_INT 0
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: LD_INT 1
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 0
67562: PUSH
67563: LD_INT 1
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 1
67572: NEG
67573: PUSH
67574: LD_INT 0
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 1
67583: NEG
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 1
67595: NEG
67596: PUSH
67597: LD_INT 2
67599: NEG
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 0
67607: PUSH
67608: LD_INT 2
67610: NEG
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 1
67618: PUSH
67619: LD_INT 1
67621: NEG
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 2
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 2
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 1
67649: PUSH
67650: LD_INT 2
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 0
67659: PUSH
67660: LD_INT 2
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 1
67669: NEG
67670: PUSH
67671: LD_INT 1
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 2
67680: NEG
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: LD_INT 2
67691: NEG
67692: PUSH
67693: LD_INT 1
67695: NEG
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: PUSH
67701: LD_INT 1
67703: NEG
67704: PUSH
67705: LD_INT 3
67707: NEG
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: LD_INT 3
67718: NEG
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 1
67726: PUSH
67727: LD_INT 2
67729: NEG
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 2
67737: PUSH
67738: LD_INT 1
67740: NEG
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 3
67748: PUSH
67749: LD_INT 0
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 3
67758: PUSH
67759: LD_INT 1
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: PUSH
67769: LD_INT 3
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 0
67778: PUSH
67779: LD_INT 3
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 1
67788: NEG
67789: PUSH
67790: LD_INT 2
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: PUSH
67797: LD_INT 2
67799: NEG
67800: PUSH
67801: LD_INT 1
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: PUSH
67808: LD_INT 3
67810: NEG
67811: PUSH
67812: LD_INT 0
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 3
67821: NEG
67822: PUSH
67823: LD_INT 1
67825: NEG
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67862: LD_ADDR_VAR 0 44
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: LD_INT 0
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 0
67879: PUSH
67880: LD_INT 1
67882: NEG
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 1
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 1
67900: PUSH
67901: LD_INT 1
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: LD_INT 1
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: LD_INT 0
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 1
67931: NEG
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 1
67943: NEG
67944: PUSH
67945: LD_INT 2
67947: NEG
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 1
67955: PUSH
67956: LD_INT 1
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 2
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: LD_INT 1
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 2
67986: PUSH
67987: LD_INT 2
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: PUSH
67997: LD_INT 2
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 1
68006: NEG
68007: PUSH
68008: LD_INT 1
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 2
68017: NEG
68018: PUSH
68019: LD_INT 0
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 2
68028: NEG
68029: PUSH
68030: LD_INT 1
68032: NEG
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 2
68040: NEG
68041: PUSH
68042: LD_INT 2
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 2
68052: NEG
68053: PUSH
68054: LD_INT 3
68056: NEG
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 2
68064: PUSH
68065: LD_INT 1
68067: NEG
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PUSH
68073: LD_INT 3
68075: PUSH
68076: LD_INT 0
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 3
68085: PUSH
68086: LD_INT 1
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 3
68095: PUSH
68096: LD_INT 2
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 3
68105: PUSH
68106: LD_INT 3
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: LD_INT 2
68115: PUSH
68116: LD_INT 3
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: LD_INT 2
68125: NEG
68126: PUSH
68127: LD_INT 1
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 3
68136: NEG
68137: PUSH
68138: LD_INT 0
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 3
68147: NEG
68148: PUSH
68149: LD_INT 1
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 3
68159: NEG
68160: PUSH
68161: LD_INT 2
68163: NEG
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 3
68171: NEG
68172: PUSH
68173: LD_INT 3
68175: NEG
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68212: LD_ADDR_VAR 0 45
68216: PUSH
68217: LD_INT 0
68219: PUSH
68220: LD_INT 0
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: PUSH
68227: LD_INT 0
68229: PUSH
68230: LD_INT 1
68232: NEG
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 1
68240: PUSH
68241: LD_INT 0
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 1
68250: PUSH
68251: LD_INT 1
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 0
68260: PUSH
68261: LD_INT 1
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 1
68270: NEG
68271: PUSH
68272: LD_INT 0
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 1
68281: NEG
68282: PUSH
68283: LD_INT 1
68285: NEG
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 1
68293: NEG
68294: PUSH
68295: LD_INT 2
68297: NEG
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 0
68305: PUSH
68306: LD_INT 2
68308: NEG
68309: PUSH
68310: EMPTY
68311: LIST
68312: LIST
68313: PUSH
68314: LD_INT 1
68316: PUSH
68317: LD_INT 1
68319: NEG
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 2
68327: PUSH
68328: LD_INT 1
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 2
68337: PUSH
68338: LD_INT 2
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 1
68347: PUSH
68348: LD_INT 2
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 0
68357: PUSH
68358: LD_INT 2
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 1
68367: NEG
68368: PUSH
68369: LD_INT 1
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 2
68378: NEG
68379: PUSH
68380: LD_INT 1
68382: NEG
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 2
68390: NEG
68391: PUSH
68392: LD_INT 2
68394: NEG
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 2
68402: NEG
68403: PUSH
68404: LD_INT 3
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 1
68414: NEG
68415: PUSH
68416: LD_INT 3
68418: NEG
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: LD_INT 3
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 1
68437: PUSH
68438: LD_INT 2
68440: NEG
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 3
68448: PUSH
68449: LD_INT 2
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 3
68458: PUSH
68459: LD_INT 3
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 2
68468: PUSH
68469: LD_INT 3
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: LD_INT 3
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 0
68488: PUSH
68489: LD_INT 3
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 1
68498: NEG
68499: PUSH
68500: LD_INT 2
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 3
68509: NEG
68510: PUSH
68511: LD_INT 2
68513: NEG
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 3
68521: NEG
68522: PUSH
68523: LD_INT 3
68525: NEG
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68562: LD_ADDR_VAR 0 46
68566: PUSH
68567: LD_INT 0
68569: PUSH
68570: LD_INT 0
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 0
68579: PUSH
68580: LD_INT 1
68582: NEG
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 1
68590: PUSH
68591: LD_INT 0
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 1
68600: PUSH
68601: LD_INT 1
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 0
68610: PUSH
68611: LD_INT 1
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 1
68620: NEG
68621: PUSH
68622: LD_INT 0
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 1
68631: NEG
68632: PUSH
68633: LD_INT 1
68635: NEG
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 1
68643: NEG
68644: PUSH
68645: LD_INT 2
68647: NEG
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 0
68655: PUSH
68656: LD_INT 2
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 1
68666: PUSH
68667: LD_INT 1
68669: NEG
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PUSH
68675: LD_INT 2
68677: PUSH
68678: LD_INT 0
68680: PUSH
68681: EMPTY
68682: LIST
68683: LIST
68684: PUSH
68685: LD_INT 2
68687: PUSH
68688: LD_INT 1
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: PUSH
68695: LD_INT 1
68697: PUSH
68698: LD_INT 2
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: PUSH
68705: LD_INT 0
68707: PUSH
68708: LD_INT 2
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 1
68717: NEG
68718: PUSH
68719: LD_INT 1
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 2
68728: NEG
68729: PUSH
68730: LD_INT 0
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 2
68739: NEG
68740: PUSH
68741: LD_INT 1
68743: NEG
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: LD_INT 3
68755: NEG
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 0
68763: PUSH
68764: LD_INT 3
68766: NEG
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 1
68774: PUSH
68775: LD_INT 2
68777: NEG
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 2
68785: PUSH
68786: LD_INT 1
68788: NEG
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 3
68796: PUSH
68797: LD_INT 0
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 3
68806: PUSH
68807: LD_INT 1
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: LD_INT 3
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 0
68826: PUSH
68827: LD_INT 3
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 1
68836: NEG
68837: PUSH
68838: LD_INT 2
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 2
68847: NEG
68848: PUSH
68849: LD_INT 1
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: PUSH
68856: LD_INT 3
68858: NEG
68859: PUSH
68860: LD_INT 0
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: PUSH
68867: LD_INT 3
68869: NEG
68870: PUSH
68871: LD_INT 1
68873: NEG
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68910: LD_ADDR_VAR 0 47
68914: PUSH
68915: LD_INT 0
68917: PUSH
68918: LD_INT 0
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: PUSH
68925: LD_INT 0
68927: PUSH
68928: LD_INT 1
68930: NEG
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 1
68938: PUSH
68939: LD_INT 0
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PUSH
68946: LD_INT 1
68948: PUSH
68949: LD_INT 1
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 0
68958: PUSH
68959: LD_INT 1
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 1
68968: NEG
68969: PUSH
68970: LD_INT 0
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 1
68979: NEG
68980: PUSH
68981: LD_INT 1
68983: NEG
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: LD_INT 2
68995: NEG
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: PUSH
69001: LD_INT 0
69003: PUSH
69004: LD_INT 2
69006: NEG
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 1
69014: PUSH
69015: LD_INT 1
69017: NEG
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 2
69025: NEG
69026: PUSH
69027: LD_INT 1
69029: NEG
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 2
69037: NEG
69038: PUSH
69039: LD_INT 2
69041: NEG
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69061: LD_ADDR_VAR 0 48
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: LD_INT 0
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 0
69078: PUSH
69079: LD_INT 1
69081: NEG
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 1
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 1
69099: PUSH
69100: LD_INT 1
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 0
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 1
69119: NEG
69120: PUSH
69121: LD_INT 0
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 1
69130: NEG
69131: PUSH
69132: LD_INT 1
69134: NEG
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 1
69142: NEG
69143: PUSH
69144: LD_INT 2
69146: NEG
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 0
69154: PUSH
69155: LD_INT 2
69157: NEG
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 1
69165: PUSH
69166: LD_INT 1
69168: NEG
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 2
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
69208: LD_ADDR_VAR 0 49
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: LD_INT 0
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: PUSH
69223: LD_INT 0
69225: PUSH
69226: LD_INT 1
69228: NEG
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: LD_INT 0
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: LD_INT 1
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 1
69266: NEG
69267: PUSH
69268: LD_INT 0
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: LD_INT 1
69277: NEG
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 1
69289: PUSH
69290: LD_INT 1
69292: NEG
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 2
69300: PUSH
69301: LD_INT 0
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 2
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: LD_INT 2
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
69352: LD_ADDR_VAR 0 50
69356: PUSH
69357: LD_INT 0
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 0
69369: PUSH
69370: LD_INT 1
69372: NEG
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 1
69380: PUSH
69381: LD_INT 0
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PUSH
69388: LD_INT 1
69390: PUSH
69391: LD_INT 1
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: LD_INT 1
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 1
69410: NEG
69411: PUSH
69412: LD_INT 0
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 1
69421: NEG
69422: PUSH
69423: LD_INT 1
69425: NEG
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 2
69433: PUSH
69434: LD_INT 1
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 2
69443: PUSH
69444: LD_INT 2
69446: PUSH
69447: EMPTY
69448: LIST
69449: LIST
69450: PUSH
69451: LD_INT 1
69453: PUSH
69454: LD_INT 2
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: LD_INT 2
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 1
69473: NEG
69474: PUSH
69475: LD_INT 1
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
69496: LD_ADDR_VAR 0 51
69500: PUSH
69501: LD_INT 0
69503: PUSH
69504: LD_INT 0
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 0
69513: PUSH
69514: LD_INT 1
69516: NEG
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: PUSH
69522: LD_INT 1
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 1
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: LD_INT 1
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: LD_INT 0
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 1
69565: NEG
69566: PUSH
69567: LD_INT 1
69569: NEG
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 1
69577: PUSH
69578: LD_INT 2
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 0
69587: PUSH
69588: LD_INT 2
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 1
69597: NEG
69598: PUSH
69599: LD_INT 1
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: LD_INT 2
69608: NEG
69609: PUSH
69610: LD_INT 0
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 2
69619: NEG
69620: PUSH
69621: LD_INT 1
69623: NEG
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69643: LD_ADDR_VAR 0 52
69647: PUSH
69648: LD_INT 0
69650: PUSH
69651: LD_INT 0
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 0
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 1
69671: PUSH
69672: LD_INT 0
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 1
69681: PUSH
69682: LD_INT 1
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 0
69691: PUSH
69692: LD_INT 1
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 1
69701: NEG
69702: PUSH
69703: LD_INT 0
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: LD_INT 1
69712: NEG
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 1
69724: NEG
69725: PUSH
69726: LD_INT 2
69728: NEG
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 1
69736: NEG
69737: PUSH
69738: LD_INT 1
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 2
69747: NEG
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 2
69758: NEG
69759: PUSH
69760: LD_INT 1
69762: NEG
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 2
69770: NEG
69771: PUSH
69772: LD_INT 2
69774: NEG
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69794: LD_ADDR_VAR 0 53
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 0
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: PUSH
69823: LD_INT 0
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: LD_INT 1
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 0
69842: PUSH
69843: LD_INT 1
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 1
69852: NEG
69853: PUSH
69854: LD_INT 0
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 1
69863: NEG
69864: PUSH
69865: LD_INT 1
69867: NEG
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 1
69875: NEG
69876: PUSH
69877: LD_INT 2
69879: NEG
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 0
69887: PUSH
69888: LD_INT 2
69890: NEG
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: LD_INT 1
69898: PUSH
69899: LD_INT 1
69901: NEG
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 2
69909: PUSH
69910: LD_INT 0
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 2
69919: PUSH
69920: LD_INT 1
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 2
69929: PUSH
69930: LD_INT 2
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 1
69939: PUSH
69940: LD_INT 2
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 0
69949: PUSH
69950: LD_INT 2
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 1
69959: NEG
69960: PUSH
69961: LD_INT 1
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 2
69970: NEG
69971: PUSH
69972: LD_INT 0
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 2
69981: NEG
69982: PUSH
69983: LD_INT 1
69985: NEG
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 2
69993: NEG
69994: PUSH
69995: LD_INT 2
69997: NEG
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70024: LD_ADDR_VAR 0 54
70028: PUSH
70029: LD_INT 0
70031: PUSH
70032: LD_INT 0
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: LD_INT 1
70044: NEG
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 1
70052: PUSH
70053: LD_INT 0
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: LD_INT 1
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 0
70072: PUSH
70073: LD_INT 1
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 1
70082: NEG
70083: PUSH
70084: LD_INT 0
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: NEG
70094: PUSH
70095: LD_INT 1
70097: NEG
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 1
70105: NEG
70106: PUSH
70107: LD_INT 2
70109: NEG
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 0
70117: PUSH
70118: LD_INT 2
70120: NEG
70121: PUSH
70122: EMPTY
70123: LIST
70124: LIST
70125: PUSH
70126: LD_INT 1
70128: PUSH
70129: LD_INT 1
70131: NEG
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 2
70139: PUSH
70140: LD_INT 0
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 2
70149: PUSH
70150: LD_INT 1
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 2
70159: PUSH
70160: LD_INT 2
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 1
70169: PUSH
70170: LD_INT 2
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 0
70179: PUSH
70180: LD_INT 2
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 1
70189: NEG
70190: PUSH
70191: LD_INT 1
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 2
70200: NEG
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 2
70211: NEG
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 2
70223: NEG
70224: PUSH
70225: LD_INT 2
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70254: LD_ADDR_VAR 0 55
70258: PUSH
70259: LD_INT 0
70261: PUSH
70262: LD_INT 0
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 0
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: PUSH
70283: LD_INT 0
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 1
70292: PUSH
70293: LD_INT 1
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 0
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 1
70312: NEG
70313: PUSH
70314: LD_INT 0
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 1
70323: NEG
70324: PUSH
70325: LD_INT 1
70327: NEG
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 1
70335: NEG
70336: PUSH
70337: LD_INT 2
70339: NEG
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PUSH
70345: LD_INT 0
70347: PUSH
70348: LD_INT 2
70350: NEG
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 1
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 2
70369: PUSH
70370: LD_INT 0
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: PUSH
70380: LD_INT 1
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: LD_INT 2
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 1
70399: PUSH
70400: LD_INT 2
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 0
70409: PUSH
70410: LD_INT 2
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 1
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 2
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 2
70453: NEG
70454: PUSH
70455: LD_INT 2
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70484: LD_ADDR_VAR 0 56
70488: PUSH
70489: LD_INT 0
70491: PUSH
70492: LD_INT 0
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 0
70501: PUSH
70502: LD_INT 1
70504: NEG
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 1
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: LD_INT 1
70522: PUSH
70523: LD_INT 1
70525: PUSH
70526: EMPTY
70527: LIST
70528: LIST
70529: PUSH
70530: LD_INT 0
70532: PUSH
70533: LD_INT 1
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 1
70542: NEG
70543: PUSH
70544: LD_INT 0
70546: PUSH
70547: EMPTY
70548: LIST
70549: LIST
70550: PUSH
70551: LD_INT 1
70553: NEG
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: PUSH
70563: LD_INT 1
70565: NEG
70566: PUSH
70567: LD_INT 2
70569: NEG
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: LD_INT 2
70580: NEG
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: LD_INT 1
70591: NEG
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 2
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 2
70609: PUSH
70610: LD_INT 1
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 2
70619: PUSH
70620: LD_INT 2
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 1
70629: PUSH
70630: LD_INT 2
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: LD_INT 2
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: LD_INT 1
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 2
70660: NEG
70661: PUSH
70662: LD_INT 0
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 2
70671: NEG
70672: PUSH
70673: LD_INT 1
70675: NEG
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 2
70683: NEG
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70714: LD_ADDR_VAR 0 57
70718: PUSH
70719: LD_INT 0
70721: PUSH
70722: LD_INT 0
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 0
70731: PUSH
70732: LD_INT 1
70734: NEG
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 1
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 0
70762: PUSH
70763: LD_INT 1
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 1
70772: NEG
70773: PUSH
70774: LD_INT 0
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 1
70783: NEG
70784: PUSH
70785: LD_INT 1
70787: NEG
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 1
70795: NEG
70796: PUSH
70797: LD_INT 2
70799: NEG
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: LD_INT 0
70807: PUSH
70808: LD_INT 2
70810: NEG
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 1
70818: PUSH
70819: LD_INT 1
70821: NEG
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 2
70829: PUSH
70830: LD_INT 0
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 2
70839: PUSH
70840: LD_INT 1
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: LD_INT 2
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: LD_INT 2
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 0
70869: PUSH
70870: LD_INT 2
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 1
70879: NEG
70880: PUSH
70881: LD_INT 1
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 2
70890: NEG
70891: PUSH
70892: LD_INT 0
70894: PUSH
70895: EMPTY
70896: LIST
70897: LIST
70898: PUSH
70899: LD_INT 2
70901: NEG
70902: PUSH
70903: LD_INT 1
70905: NEG
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 2
70913: NEG
70914: PUSH
70915: LD_INT 2
70917: NEG
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70944: LD_ADDR_VAR 0 58
70948: PUSH
70949: LD_INT 0
70951: PUSH
70952: LD_INT 0
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 0
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 1
70972: PUSH
70973: LD_INT 0
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: LD_INT 1
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: LD_INT 0
70992: PUSH
70993: LD_INT 1
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 1
71002: NEG
71003: PUSH
71004: LD_INT 0
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 1
71013: NEG
71014: PUSH
71015: LD_INT 1
71017: NEG
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 1
71025: NEG
71026: PUSH
71027: LD_INT 2
71029: NEG
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: LD_INT 0
71037: PUSH
71038: LD_INT 2
71040: NEG
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 1
71048: PUSH
71049: LD_INT 1
71051: NEG
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 2
71059: PUSH
71060: LD_INT 0
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 2
71069: PUSH
71070: LD_INT 1
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 2
71079: PUSH
71080: LD_INT 2
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 1
71089: PUSH
71090: LD_INT 2
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 0
71099: PUSH
71100: LD_INT 2
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: LD_INT 1
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 2
71120: NEG
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 2
71131: NEG
71132: PUSH
71133: LD_INT 1
71135: NEG
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 2
71143: NEG
71144: PUSH
71145: LD_INT 2
71147: NEG
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71174: LD_ADDR_VAR 0 59
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 1
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 1
71212: PUSH
71213: LD_INT 1
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 0
71222: PUSH
71223: LD_INT 1
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 1
71232: NEG
71233: PUSH
71234: LD_INT 0
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 1
71243: NEG
71244: PUSH
71245: LD_INT 1
71247: NEG
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71262: LD_ADDR_VAR 0 60
71266: PUSH
71267: LD_INT 0
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 0
71279: PUSH
71280: LD_INT 1
71282: NEG
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 1
71290: PUSH
71291: LD_INT 0
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: LD_INT 1
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 0
71310: PUSH
71311: LD_INT 1
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 1
71320: NEG
71321: PUSH
71322: LD_INT 0
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 1
71331: NEG
71332: PUSH
71333: LD_INT 1
71335: NEG
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71350: LD_ADDR_VAR 0 61
71354: PUSH
71355: LD_INT 0
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 0
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 1
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 0
71398: PUSH
71399: LD_INT 1
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 1
71408: NEG
71409: PUSH
71410: LD_INT 0
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: NEG
71420: PUSH
71421: LD_INT 1
71423: NEG
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71438: LD_ADDR_VAR 0 62
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 0
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: PUSH
71467: LD_INT 0
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: LD_INT 1
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 0
71486: PUSH
71487: LD_INT 1
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 1
71496: NEG
71497: PUSH
71498: LD_INT 0
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 1
71507: NEG
71508: PUSH
71509: LD_INT 1
71511: NEG
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71526: LD_ADDR_VAR 0 63
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: LD_INT 0
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 0
71543: PUSH
71544: LD_INT 1
71546: NEG
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: PUSH
71562: LD_INT 1
71564: PUSH
71565: LD_INT 1
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 0
71574: PUSH
71575: LD_INT 1
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 1
71584: NEG
71585: PUSH
71586: LD_INT 0
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 1
71595: NEG
71596: PUSH
71597: LD_INT 1
71599: NEG
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71614: LD_ADDR_VAR 0 64
71618: PUSH
71619: LD_INT 0
71621: PUSH
71622: LD_INT 0
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 0
71631: PUSH
71632: LD_INT 1
71634: NEG
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PUSH
71640: LD_INT 1
71642: PUSH
71643: LD_INT 0
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: LD_INT 1
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: LD_INT 1
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 1
71683: NEG
71684: PUSH
71685: LD_INT 1
71687: NEG
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: ST_TO_ADDR
// end ; 1 :
71702: GO 77599
71704: LD_INT 1
71706: DOUBLE
71707: EQUAL
71708: IFTRUE 71712
71710: GO 74335
71712: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
71713: LD_ADDR_VAR 0 11
71717: PUSH
71718: LD_INT 1
71720: NEG
71721: PUSH
71722: LD_INT 3
71724: NEG
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 0
71732: PUSH
71733: LD_INT 3
71735: NEG
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: PUSH
71744: LD_INT 2
71746: NEG
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: LIST
71756: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
71757: LD_ADDR_VAR 0 12
71761: PUSH
71762: LD_INT 2
71764: PUSH
71765: LD_INT 1
71767: NEG
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 3
71775: PUSH
71776: LD_INT 0
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 3
71785: PUSH
71786: LD_INT 1
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: LIST
71797: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
71798: LD_ADDR_VAR 0 13
71802: PUSH
71803: LD_INT 3
71805: PUSH
71806: LD_INT 2
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 3
71815: PUSH
71816: LD_INT 3
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 2
71825: PUSH
71826: LD_INT 3
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: LIST
71837: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71838: LD_ADDR_VAR 0 14
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: LD_INT 3
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 0
71855: PUSH
71856: LD_INT 3
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 1
71865: NEG
71866: PUSH
71867: LD_INT 2
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: LIST
71878: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71879: LD_ADDR_VAR 0 15
71883: PUSH
71884: LD_INT 2
71886: NEG
71887: PUSH
71888: LD_INT 1
71890: PUSH
71891: EMPTY
71892: LIST
71893: LIST
71894: PUSH
71895: LD_INT 3
71897: NEG
71898: PUSH
71899: LD_INT 0
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 3
71908: NEG
71909: PUSH
71910: LD_INT 1
71912: NEG
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: LIST
71922: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71923: LD_ADDR_VAR 0 16
71927: PUSH
71928: LD_INT 2
71930: NEG
71931: PUSH
71932: LD_INT 3
71934: NEG
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PUSH
71940: LD_INT 3
71942: NEG
71943: PUSH
71944: LD_INT 2
71946: NEG
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 3
71954: NEG
71955: PUSH
71956: LD_INT 3
71958: NEG
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: LIST
71968: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
71969: LD_ADDR_VAR 0 17
71973: PUSH
71974: LD_INT 1
71976: NEG
71977: PUSH
71978: LD_INT 3
71980: NEG
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: PUSH
71986: LD_INT 0
71988: PUSH
71989: LD_INT 3
71991: NEG
71992: PUSH
71993: EMPTY
71994: LIST
71995: LIST
71996: PUSH
71997: LD_INT 1
71999: PUSH
72000: LD_INT 2
72002: NEG
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: LIST
72012: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72013: LD_ADDR_VAR 0 18
72017: PUSH
72018: LD_INT 2
72020: PUSH
72021: LD_INT 1
72023: NEG
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 3
72031: PUSH
72032: LD_INT 0
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 3
72041: PUSH
72042: LD_INT 1
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: LIST
72053: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72054: LD_ADDR_VAR 0 19
72058: PUSH
72059: LD_INT 3
72061: PUSH
72062: LD_INT 2
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 3
72071: PUSH
72072: LD_INT 3
72074: PUSH
72075: EMPTY
72076: LIST
72077: LIST
72078: PUSH
72079: LD_INT 2
72081: PUSH
72082: LD_INT 3
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: LIST
72093: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72094: LD_ADDR_VAR 0 20
72098: PUSH
72099: LD_INT 1
72101: PUSH
72102: LD_INT 3
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: LD_INT 3
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 1
72121: NEG
72122: PUSH
72123: LD_INT 2
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: LIST
72134: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72135: LD_ADDR_VAR 0 21
72139: PUSH
72140: LD_INT 2
72142: NEG
72143: PUSH
72144: LD_INT 1
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 3
72153: NEG
72154: PUSH
72155: LD_INT 0
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: LD_INT 3
72164: NEG
72165: PUSH
72166: LD_INT 1
72168: NEG
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: LIST
72178: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72179: LD_ADDR_VAR 0 22
72183: PUSH
72184: LD_INT 2
72186: NEG
72187: PUSH
72188: LD_INT 3
72190: NEG
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 3
72198: NEG
72199: PUSH
72200: LD_INT 2
72202: NEG
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 3
72210: NEG
72211: PUSH
72212: LD_INT 3
72214: NEG
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
72225: LD_ADDR_VAR 0 23
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: LD_INT 3
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 1
72243: NEG
72244: PUSH
72245: LD_INT 4
72247: NEG
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 1
72255: PUSH
72256: LD_INT 3
72258: NEG
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: LIST
72268: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
72269: LD_ADDR_VAR 0 24
72273: PUSH
72274: LD_INT 3
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 3
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 4
72297: PUSH
72298: LD_INT 1
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: LIST
72309: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
72310: LD_ADDR_VAR 0 25
72314: PUSH
72315: LD_INT 3
72317: PUSH
72318: LD_INT 3
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 4
72327: PUSH
72328: LD_INT 3
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: LD_INT 3
72337: PUSH
72338: LD_INT 4
72340: PUSH
72341: EMPTY
72342: LIST
72343: LIST
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: LIST
72349: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
72350: LD_ADDR_VAR 0 26
72354: PUSH
72355: LD_INT 0
72357: PUSH
72358: LD_INT 3
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 4
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 1
72377: NEG
72378: PUSH
72379: LD_INT 3
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: LIST
72390: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
72391: LD_ADDR_VAR 0 27
72395: PUSH
72396: LD_INT 3
72398: NEG
72399: PUSH
72400: LD_INT 0
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 3
72409: NEG
72410: PUSH
72411: LD_INT 1
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 4
72420: NEG
72421: PUSH
72422: LD_INT 1
72424: NEG
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: LIST
72434: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
72435: LD_ADDR_VAR 0 28
72439: PUSH
72440: LD_INT 3
72442: NEG
72443: PUSH
72444: LD_INT 3
72446: NEG
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: PUSH
72452: LD_INT 3
72454: NEG
72455: PUSH
72456: LD_INT 4
72458: NEG
72459: PUSH
72460: EMPTY
72461: LIST
72462: LIST
72463: PUSH
72464: LD_INT 4
72466: NEG
72467: PUSH
72468: LD_INT 3
72470: NEG
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: LIST
72480: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
72481: LD_ADDR_VAR 0 29
72485: PUSH
72486: LD_INT 1
72488: NEG
72489: PUSH
72490: LD_INT 3
72492: NEG
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: LD_INT 3
72503: NEG
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: PUSH
72512: LD_INT 2
72514: NEG
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: LD_INT 1
72522: NEG
72523: PUSH
72524: LD_INT 4
72526: NEG
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: LD_INT 4
72537: NEG
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: LD_INT 3
72548: NEG
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 5
72560: NEG
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 0
72568: PUSH
72569: LD_INT 5
72571: NEG
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 1
72579: PUSH
72580: LD_INT 4
72582: NEG
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 1
72590: NEG
72591: PUSH
72592: LD_INT 6
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 0
72602: PUSH
72603: LD_INT 6
72605: NEG
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 1
72613: PUSH
72614: LD_INT 5
72616: NEG
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: LIST
72630: LIST
72631: LIST
72632: LIST
72633: LIST
72634: LIST
72635: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
72636: LD_ADDR_VAR 0 30
72640: PUSH
72641: LD_INT 2
72643: PUSH
72644: LD_INT 1
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 3
72654: PUSH
72655: LD_INT 0
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 3
72664: PUSH
72665: LD_INT 1
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: LD_INT 3
72674: PUSH
72675: LD_INT 1
72677: NEG
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 4
72685: PUSH
72686: LD_INT 0
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 4
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 4
72705: PUSH
72706: LD_INT 1
72708: NEG
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 5
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 5
72726: PUSH
72727: LD_INT 1
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 5
72736: PUSH
72737: LD_INT 1
72739: NEG
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 6
72747: PUSH
72748: LD_INT 0
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: PUSH
72755: LD_INT 6
72757: PUSH
72758: LD_INT 1
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
72779: LD_ADDR_VAR 0 31
72783: PUSH
72784: LD_INT 3
72786: PUSH
72787: LD_INT 2
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: LD_INT 3
72796: PUSH
72797: LD_INT 3
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 2
72806: PUSH
72807: LD_INT 3
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 4
72816: PUSH
72817: LD_INT 3
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PUSH
72824: LD_INT 4
72826: PUSH
72827: LD_INT 4
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 3
72836: PUSH
72837: LD_INT 4
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 5
72846: PUSH
72847: LD_INT 4
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 5
72856: PUSH
72857: LD_INT 5
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 4
72866: PUSH
72867: LD_INT 5
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 6
72876: PUSH
72877: LD_INT 5
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 6
72886: PUSH
72887: LD_INT 6
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: LD_INT 5
72896: PUSH
72897: LD_INT 6
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
72918: LD_ADDR_VAR 0 32
72922: PUSH
72923: LD_INT 1
72925: PUSH
72926: LD_INT 3
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 0
72935: PUSH
72936: LD_INT 3
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 1
72945: NEG
72946: PUSH
72947: LD_INT 2
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 1
72956: PUSH
72957: LD_INT 4
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 0
72966: PUSH
72967: LD_INT 4
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 1
72976: NEG
72977: PUSH
72978: LD_INT 3
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: LD_INT 5
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 0
72997: PUSH
72998: LD_INT 5
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 1
73007: NEG
73008: PUSH
73009: LD_INT 4
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 1
73018: PUSH
73019: LD_INT 6
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 0
73028: PUSH
73029: LD_INT 6
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 1
73038: NEG
73039: PUSH
73040: LD_INT 5
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: LIST
73051: LIST
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
73061: LD_ADDR_VAR 0 33
73065: PUSH
73066: LD_INT 2
73068: NEG
73069: PUSH
73070: LD_INT 1
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 3
73079: NEG
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 3
73090: NEG
73091: PUSH
73092: LD_INT 1
73094: NEG
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 3
73102: NEG
73103: PUSH
73104: LD_INT 1
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 4
73113: NEG
73114: PUSH
73115: LD_INT 0
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 4
73124: NEG
73125: PUSH
73126: LD_INT 1
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 4
73136: NEG
73137: PUSH
73138: LD_INT 1
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 5
73147: NEG
73148: PUSH
73149: LD_INT 0
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 5
73158: NEG
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 5
73170: NEG
73171: PUSH
73172: LD_INT 1
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 6
73181: NEG
73182: PUSH
73183: LD_INT 0
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 6
73192: NEG
73193: PUSH
73194: LD_INT 1
73196: NEG
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
73216: LD_ADDR_VAR 0 34
73220: PUSH
73221: LD_INT 2
73223: NEG
73224: PUSH
73225: LD_INT 3
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 3
73235: NEG
73236: PUSH
73237: LD_INT 2
73239: NEG
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 3
73247: NEG
73248: PUSH
73249: LD_INT 3
73251: NEG
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 3
73259: NEG
73260: PUSH
73261: LD_INT 4
73263: NEG
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 4
73271: NEG
73272: PUSH
73273: LD_INT 3
73275: NEG
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 4
73283: NEG
73284: PUSH
73285: LD_INT 4
73287: NEG
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: LD_INT 4
73295: NEG
73296: PUSH
73297: LD_INT 5
73299: NEG
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 5
73307: NEG
73308: PUSH
73309: LD_INT 4
73311: NEG
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 5
73319: NEG
73320: PUSH
73321: LD_INT 5
73323: NEG
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 5
73331: NEG
73332: PUSH
73333: LD_INT 6
73335: NEG
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 6
73343: NEG
73344: PUSH
73345: LD_INT 5
73347: NEG
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PUSH
73353: LD_INT 6
73355: NEG
73356: PUSH
73357: LD_INT 6
73359: NEG
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
73379: LD_ADDR_VAR 0 41
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 2
73389: NEG
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 1
73397: NEG
73398: PUSH
73399: LD_INT 3
73401: NEG
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 1
73409: PUSH
73410: LD_INT 2
73412: NEG
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: LIST
73422: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
73423: LD_ADDR_VAR 0 42
73427: PUSH
73428: LD_INT 2
73430: PUSH
73431: LD_INT 0
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: LD_INT 2
73440: PUSH
73441: LD_INT 1
73443: NEG
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 3
73451: PUSH
73452: LD_INT 1
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: LIST
73463: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
73464: LD_ADDR_VAR 0 43
73468: PUSH
73469: LD_INT 2
73471: PUSH
73472: LD_INT 2
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 3
73481: PUSH
73482: LD_INT 2
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 2
73491: PUSH
73492: LD_INT 3
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: LIST
73503: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
73504: LD_ADDR_VAR 0 44
73508: PUSH
73509: LD_INT 0
73511: PUSH
73512: LD_INT 2
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 1
73521: PUSH
73522: LD_INT 3
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: LD_INT 1
73531: NEG
73532: PUSH
73533: LD_INT 2
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: LIST
73544: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73545: LD_ADDR_VAR 0 45
73549: PUSH
73550: LD_INT 2
73552: NEG
73553: PUSH
73554: LD_INT 0
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: PUSH
73561: LD_INT 2
73563: NEG
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 3
73574: NEG
73575: PUSH
73576: LD_INT 1
73578: NEG
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: LIST
73588: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
73589: LD_ADDR_VAR 0 46
73593: PUSH
73594: LD_INT 2
73596: NEG
73597: PUSH
73598: LD_INT 2
73600: NEG
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: LD_INT 3
73612: NEG
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 3
73620: NEG
73621: PUSH
73622: LD_INT 2
73624: NEG
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: LIST
73634: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
73635: LD_ADDR_VAR 0 47
73639: PUSH
73640: LD_INT 2
73642: NEG
73643: PUSH
73644: LD_INT 3
73646: NEG
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 1
73654: NEG
73655: PUSH
73656: LD_INT 3
73658: NEG
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
73668: LD_ADDR_VAR 0 48
73672: PUSH
73673: LD_INT 1
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 2
73686: PUSH
73687: LD_INT 1
73689: NEG
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
73699: LD_ADDR_VAR 0 49
73703: PUSH
73704: LD_INT 3
73706: PUSH
73707: LD_INT 1
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PUSH
73714: LD_INT 3
73716: PUSH
73717: LD_INT 2
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
73728: LD_ADDR_VAR 0 50
73732: PUSH
73733: LD_INT 2
73735: PUSH
73736: LD_INT 3
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 1
73745: PUSH
73746: LD_INT 3
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
73757: LD_ADDR_VAR 0 51
73761: PUSH
73762: LD_INT 1
73764: NEG
73765: PUSH
73766: LD_INT 2
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 2
73775: NEG
73776: PUSH
73777: LD_INT 1
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73788: LD_ADDR_VAR 0 52
73792: PUSH
73793: LD_INT 3
73795: NEG
73796: PUSH
73797: LD_INT 1
73799: NEG
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 3
73807: NEG
73808: PUSH
73809: LD_INT 2
73811: NEG
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73821: LD_ADDR_VAR 0 53
73825: PUSH
73826: LD_INT 1
73828: NEG
73829: PUSH
73830: LD_INT 3
73832: NEG
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: LD_INT 0
73840: PUSH
73841: LD_INT 3
73843: NEG
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 1
73851: PUSH
73852: LD_INT 2
73854: NEG
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: LIST
73864: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73865: LD_ADDR_VAR 0 54
73869: PUSH
73870: LD_INT 2
73872: PUSH
73873: LD_INT 1
73875: NEG
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 3
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 3
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: LIST
73905: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73906: LD_ADDR_VAR 0 55
73910: PUSH
73911: LD_INT 3
73913: PUSH
73914: LD_INT 2
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 3
73923: PUSH
73924: LD_INT 3
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 2
73933: PUSH
73934: LD_INT 3
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: LIST
73945: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73946: LD_ADDR_VAR 0 56
73950: PUSH
73951: LD_INT 1
73953: PUSH
73954: LD_INT 3
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: LD_INT 3
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 1
73973: NEG
73974: PUSH
73975: LD_INT 2
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: LIST
73986: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73987: LD_ADDR_VAR 0 57
73991: PUSH
73992: LD_INT 2
73994: NEG
73995: PUSH
73996: LD_INT 1
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 3
74005: NEG
74006: PUSH
74007: LD_INT 0
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 3
74016: NEG
74017: PUSH
74018: LD_INT 1
74020: NEG
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: LIST
74030: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74031: LD_ADDR_VAR 0 58
74035: PUSH
74036: LD_INT 2
74038: NEG
74039: PUSH
74040: LD_INT 3
74042: NEG
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: LD_INT 3
74050: NEG
74051: PUSH
74052: LD_INT 2
74054: NEG
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: LD_INT 3
74062: NEG
74063: PUSH
74064: LD_INT 3
74066: NEG
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: LIST
74076: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
74077: LD_ADDR_VAR 0 59
74081: PUSH
74082: LD_INT 1
74084: NEG
74085: PUSH
74086: LD_INT 2
74088: NEG
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: LD_INT 0
74096: PUSH
74097: LD_INT 2
74099: NEG
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 1
74107: PUSH
74108: LD_INT 1
74110: NEG
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: LIST
74120: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74121: LD_ADDR_VAR 0 60
74125: PUSH
74126: LD_INT 1
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 2
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 2
74149: PUSH
74150: LD_INT 1
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: LIST
74161: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74162: LD_ADDR_VAR 0 61
74166: PUSH
74167: LD_INT 2
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 2
74179: PUSH
74180: LD_INT 2
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 2
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: LIST
74201: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74202: LD_ADDR_VAR 0 62
74206: PUSH
74207: LD_INT 1
74209: PUSH
74210: LD_INT 2
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 0
74219: PUSH
74220: LD_INT 2
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 1
74229: NEG
74230: PUSH
74231: LD_INT 1
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: LIST
74242: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74243: LD_ADDR_VAR 0 63
74247: PUSH
74248: LD_INT 1
74250: NEG
74251: PUSH
74252: LD_INT 1
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: LD_INT 2
74261: NEG
74262: PUSH
74263: LD_INT 0
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 2
74272: NEG
74273: PUSH
74274: LD_INT 1
74276: NEG
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: LIST
74286: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74287: LD_ADDR_VAR 0 64
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: LD_INT 2
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 2
74306: NEG
74307: PUSH
74308: LD_INT 1
74310: NEG
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 2
74318: NEG
74319: PUSH
74320: LD_INT 2
74322: NEG
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: LIST
74332: ST_TO_ADDR
// end ; 2 :
74333: GO 77599
74335: LD_INT 2
74337: DOUBLE
74338: EQUAL
74339: IFTRUE 74343
74341: GO 77598
74343: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
74344: LD_ADDR_VAR 0 29
74348: PUSH
74349: LD_INT 4
74351: PUSH
74352: LD_INT 0
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 4
74361: PUSH
74362: LD_INT 1
74364: NEG
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 5
74372: PUSH
74373: LD_INT 0
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 5
74382: PUSH
74383: LD_INT 1
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 4
74392: PUSH
74393: LD_INT 1
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PUSH
74400: LD_INT 3
74402: PUSH
74403: LD_INT 0
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 3
74412: PUSH
74413: LD_INT 1
74415: NEG
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 3
74423: PUSH
74424: LD_INT 2
74426: NEG
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: LD_INT 5
74434: PUSH
74435: LD_INT 2
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PUSH
74442: LD_INT 3
74444: PUSH
74445: LD_INT 3
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PUSH
74452: LD_INT 3
74454: PUSH
74455: LD_INT 2
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: PUSH
74462: LD_INT 4
74464: PUSH
74465: LD_INT 3
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 4
74474: PUSH
74475: LD_INT 4
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 3
74484: PUSH
74485: LD_INT 4
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 2
74494: PUSH
74495: LD_INT 3
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 2
74504: PUSH
74505: LD_INT 2
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 4
74514: PUSH
74515: LD_INT 2
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 2
74524: PUSH
74525: LD_INT 4
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: LD_INT 0
74534: PUSH
74535: LD_INT 4
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 0
74544: PUSH
74545: LD_INT 3
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 1
74554: PUSH
74555: LD_INT 4
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 1
74564: PUSH
74565: LD_INT 5
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 0
74574: PUSH
74575: LD_INT 5
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: LD_INT 1
74584: NEG
74585: PUSH
74586: LD_INT 4
74588: PUSH
74589: EMPTY
74590: LIST
74591: LIST
74592: PUSH
74593: LD_INT 1
74595: NEG
74596: PUSH
74597: LD_INT 3
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: LD_INT 2
74606: PUSH
74607: LD_INT 5
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 2
74616: NEG
74617: PUSH
74618: LD_INT 3
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 3
74627: NEG
74628: PUSH
74629: LD_INT 0
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 3
74638: NEG
74639: PUSH
74640: LD_INT 1
74642: NEG
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: LD_INT 2
74650: NEG
74651: PUSH
74652: LD_INT 0
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: LD_INT 2
74661: NEG
74662: PUSH
74663: LD_INT 1
74665: PUSH
74666: EMPTY
74667: LIST
74668: LIST
74669: PUSH
74670: LD_INT 3
74672: NEG
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: PUSH
74681: LD_INT 4
74683: NEG
74684: PUSH
74685: LD_INT 0
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: LD_INT 4
74694: NEG
74695: PUSH
74696: LD_INT 1
74698: NEG
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 4
74706: NEG
74707: PUSH
74708: LD_INT 2
74710: NEG
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 2
74718: NEG
74719: PUSH
74720: LD_INT 2
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 4
74729: NEG
74730: PUSH
74731: LD_INT 4
74733: NEG
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: PUSH
74739: LD_INT 4
74741: NEG
74742: PUSH
74743: LD_INT 5
74745: NEG
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 3
74753: NEG
74754: PUSH
74755: LD_INT 4
74757: NEG
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 3
74765: NEG
74766: PUSH
74767: LD_INT 3
74769: NEG
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PUSH
74775: LD_INT 4
74777: NEG
74778: PUSH
74779: LD_INT 3
74781: NEG
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 5
74789: NEG
74790: PUSH
74791: LD_INT 4
74793: NEG
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: PUSH
74799: LD_INT 5
74801: NEG
74802: PUSH
74803: LD_INT 5
74805: NEG
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 3
74813: NEG
74814: PUSH
74815: LD_INT 5
74817: NEG
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 5
74825: NEG
74826: PUSH
74827: LD_INT 3
74829: NEG
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: LIST
74839: LIST
74840: LIST
74841: LIST
74842: LIST
74843: LIST
74844: LIST
74845: LIST
74846: LIST
74847: LIST
74848: LIST
74849: LIST
74850: LIST
74851: LIST
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
74882: LD_ADDR_VAR 0 30
74886: PUSH
74887: LD_INT 4
74889: PUSH
74890: LD_INT 4
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 4
74899: PUSH
74900: LD_INT 3
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 5
74909: PUSH
74910: LD_INT 4
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 5
74919: PUSH
74920: LD_INT 5
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 4
74929: PUSH
74930: LD_INT 5
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 3
74939: PUSH
74940: LD_INT 4
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 3
74949: PUSH
74950: LD_INT 3
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 5
74959: PUSH
74960: LD_INT 3
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 3
74969: PUSH
74970: LD_INT 5
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: LD_INT 3
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 0
74989: PUSH
74990: LD_INT 2
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 1
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: PUSH
75010: LD_INT 4
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 0
75019: PUSH
75020: LD_INT 4
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 1
75029: NEG
75030: PUSH
75031: LD_INT 3
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: LD_INT 1
75040: NEG
75041: PUSH
75042: LD_INT 2
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 2
75051: PUSH
75052: LD_INT 4
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: LD_INT 2
75061: NEG
75062: PUSH
75063: LD_INT 2
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 4
75072: NEG
75073: PUSH
75074: LD_INT 0
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 4
75083: NEG
75084: PUSH
75085: LD_INT 1
75087: NEG
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 3
75095: NEG
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 3
75106: NEG
75107: PUSH
75108: LD_INT 1
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 4
75117: NEG
75118: PUSH
75119: LD_INT 1
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 5
75128: NEG
75129: PUSH
75130: LD_INT 0
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 5
75139: NEG
75140: PUSH
75141: LD_INT 1
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 5
75151: NEG
75152: PUSH
75153: LD_INT 2
75155: NEG
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 3
75163: NEG
75164: PUSH
75165: LD_INT 2
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 3
75174: NEG
75175: PUSH
75176: LD_INT 3
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 3
75186: NEG
75187: PUSH
75188: LD_INT 4
75190: NEG
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 2
75198: NEG
75199: PUSH
75200: LD_INT 3
75202: NEG
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 2
75210: NEG
75211: PUSH
75212: LD_INT 2
75214: NEG
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 3
75222: NEG
75223: PUSH
75224: LD_INT 2
75226: NEG
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 4
75234: NEG
75235: PUSH
75236: LD_INT 3
75238: NEG
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 4
75246: NEG
75247: PUSH
75248: LD_INT 4
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 2
75258: NEG
75259: PUSH
75260: LD_INT 4
75262: NEG
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 4
75270: NEG
75271: PUSH
75272: LD_INT 2
75274: NEG
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: PUSH
75280: LD_INT 0
75282: PUSH
75283: LD_INT 4
75285: NEG
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 0
75293: PUSH
75294: LD_INT 5
75296: NEG
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: LD_INT 4
75307: NEG
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: LD_INT 3
75318: NEG
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: LD_INT 3
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: NEG
75338: PUSH
75339: LD_INT 4
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 1
75349: NEG
75350: PUSH
75351: LD_INT 5
75353: NEG
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 2
75361: PUSH
75362: LD_INT 3
75364: NEG
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 2
75372: NEG
75373: PUSH
75374: LD_INT 5
75376: NEG
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: LIST
75391: LIST
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: LIST
75427: LIST
75428: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
75429: LD_ADDR_VAR 0 31
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: LD_INT 4
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 0
75446: PUSH
75447: LD_INT 3
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: LD_INT 4
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: LD_INT 1
75466: PUSH
75467: LD_INT 5
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 0
75476: PUSH
75477: LD_INT 5
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: LD_INT 4
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 1
75497: NEG
75498: PUSH
75499: LD_INT 3
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 2
75508: PUSH
75509: LD_INT 5
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: LD_INT 2
75518: NEG
75519: PUSH
75520: LD_INT 3
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PUSH
75527: LD_INT 3
75529: NEG
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 3
75540: NEG
75541: PUSH
75542: LD_INT 1
75544: NEG
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 2
75552: NEG
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 2
75563: NEG
75564: PUSH
75565: LD_INT 1
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 3
75574: NEG
75575: PUSH
75576: LD_INT 1
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 4
75585: NEG
75586: PUSH
75587: LD_INT 0
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 4
75596: NEG
75597: PUSH
75598: LD_INT 1
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 4
75608: NEG
75609: PUSH
75610: LD_INT 2
75612: NEG
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 2
75620: NEG
75621: PUSH
75622: LD_INT 2
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 4
75631: NEG
75632: PUSH
75633: LD_INT 4
75635: NEG
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 4
75643: NEG
75644: PUSH
75645: LD_INT 5
75647: NEG
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 3
75655: NEG
75656: PUSH
75657: LD_INT 4
75659: NEG
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 3
75667: NEG
75668: PUSH
75669: LD_INT 3
75671: NEG
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PUSH
75677: LD_INT 4
75679: NEG
75680: PUSH
75681: LD_INT 3
75683: NEG
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 5
75691: NEG
75692: PUSH
75693: LD_INT 4
75695: NEG
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 5
75703: NEG
75704: PUSH
75705: LD_INT 5
75707: NEG
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 3
75715: NEG
75716: PUSH
75717: LD_INT 5
75719: NEG
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 5
75727: NEG
75728: PUSH
75729: LD_INT 3
75731: NEG
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 0
75739: PUSH
75740: LD_INT 3
75742: NEG
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: LD_INT 0
75750: PUSH
75751: LD_INT 4
75753: NEG
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 1
75761: PUSH
75762: LD_INT 3
75764: NEG
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 1
75772: PUSH
75773: LD_INT 2
75775: NEG
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 0
75783: PUSH
75784: LD_INT 2
75786: NEG
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 1
75794: NEG
75795: PUSH
75796: LD_INT 3
75798: NEG
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 1
75806: NEG
75807: PUSH
75808: LD_INT 4
75810: NEG
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 2
75818: PUSH
75819: LD_INT 2
75821: NEG
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 2
75829: NEG
75830: PUSH
75831: LD_INT 4
75833: NEG
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 4
75841: PUSH
75842: LD_INT 0
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 4
75851: PUSH
75852: LD_INT 1
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 5
75862: PUSH
75863: LD_INT 0
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PUSH
75870: LD_INT 5
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 4
75882: PUSH
75883: LD_INT 1
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 3
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 3
75902: PUSH
75903: LD_INT 1
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 3
75913: PUSH
75914: LD_INT 2
75916: NEG
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 5
75924: PUSH
75925: LD_INT 2
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: LIST
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: LIST
75948: LIST
75949: LIST
75950: LIST
75951: LIST
75952: LIST
75953: LIST
75954: LIST
75955: LIST
75956: LIST
75957: LIST
75958: LIST
75959: LIST
75960: LIST
75961: LIST
75962: LIST
75963: LIST
75964: LIST
75965: LIST
75966: LIST
75967: LIST
75968: LIST
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
75979: LD_ADDR_VAR 0 32
75983: PUSH
75984: LD_INT 4
75986: NEG
75987: PUSH
75988: LD_INT 0
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 4
75997: NEG
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 3
76009: NEG
76010: PUSH
76011: LD_INT 0
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: LD_INT 3
76020: NEG
76021: PUSH
76022: LD_INT 1
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 4
76031: NEG
76032: PUSH
76033: LD_INT 1
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 5
76042: NEG
76043: PUSH
76044: LD_INT 0
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: LD_INT 5
76053: NEG
76054: PUSH
76055: LD_INT 1
76057: NEG
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 5
76065: NEG
76066: PUSH
76067: LD_INT 2
76069: NEG
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 3
76077: NEG
76078: PUSH
76079: LD_INT 2
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 3
76088: NEG
76089: PUSH
76090: LD_INT 3
76092: NEG
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 3
76100: NEG
76101: PUSH
76102: LD_INT 4
76104: NEG
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 2
76112: NEG
76113: PUSH
76114: LD_INT 3
76116: NEG
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 2
76124: NEG
76125: PUSH
76126: LD_INT 2
76128: NEG
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: LD_INT 3
76136: NEG
76137: PUSH
76138: LD_INT 2
76140: NEG
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 4
76148: NEG
76149: PUSH
76150: LD_INT 3
76152: NEG
76153: PUSH
76154: EMPTY
76155: LIST
76156: LIST
76157: PUSH
76158: LD_INT 4
76160: NEG
76161: PUSH
76162: LD_INT 4
76164: NEG
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 2
76172: NEG
76173: PUSH
76174: LD_INT 4
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 4
76184: NEG
76185: PUSH
76186: LD_INT 2
76188: NEG
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: LD_INT 0
76196: PUSH
76197: LD_INT 4
76199: NEG
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 0
76207: PUSH
76208: LD_INT 5
76210: NEG
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 1
76218: PUSH
76219: LD_INT 4
76221: NEG
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 1
76229: PUSH
76230: LD_INT 3
76232: NEG
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 0
76240: PUSH
76241: LD_INT 3
76243: NEG
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: LD_INT 1
76251: NEG
76252: PUSH
76253: LD_INT 4
76255: NEG
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: PUSH
76261: LD_INT 1
76263: NEG
76264: PUSH
76265: LD_INT 5
76267: NEG
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 2
76275: PUSH
76276: LD_INT 3
76278: NEG
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 2
76286: NEG
76287: PUSH
76288: LD_INT 5
76290: NEG
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 3
76298: PUSH
76299: LD_INT 0
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 3
76308: PUSH
76309: LD_INT 1
76311: NEG
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 4
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 4
76329: PUSH
76330: LD_INT 1
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 3
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 2
76349: PUSH
76350: LD_INT 0
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 2
76359: PUSH
76360: LD_INT 1
76362: NEG
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 2
76370: PUSH
76371: LD_INT 2
76373: NEG
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 4
76381: PUSH
76382: LD_INT 2
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 4
76391: PUSH
76392: LD_INT 4
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 4
76401: PUSH
76402: LD_INT 3
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 5
76411: PUSH
76412: LD_INT 4
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: PUSH
76419: LD_INT 5
76421: PUSH
76422: LD_INT 5
76424: PUSH
76425: EMPTY
76426: LIST
76427: LIST
76428: PUSH
76429: LD_INT 4
76431: PUSH
76432: LD_INT 5
76434: PUSH
76435: EMPTY
76436: LIST
76437: LIST
76438: PUSH
76439: LD_INT 3
76441: PUSH
76442: LD_INT 4
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 3
76451: PUSH
76452: LD_INT 3
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 5
76461: PUSH
76462: LD_INT 3
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: PUSH
76469: LD_INT 3
76471: PUSH
76472: LD_INT 5
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: LIST
76503: LIST
76504: LIST
76505: LIST
76506: LIST
76507: LIST
76508: LIST
76509: LIST
76510: LIST
76511: LIST
76512: LIST
76513: LIST
76514: LIST
76515: LIST
76516: LIST
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
76526: LD_ADDR_VAR 0 33
76530: PUSH
76531: LD_INT 4
76533: NEG
76534: PUSH
76535: LD_INT 4
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 4
76545: NEG
76546: PUSH
76547: LD_INT 5
76549: NEG
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 3
76557: NEG
76558: PUSH
76559: LD_INT 4
76561: NEG
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 3
76569: NEG
76570: PUSH
76571: LD_INT 3
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 4
76581: NEG
76582: PUSH
76583: LD_INT 3
76585: NEG
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 5
76593: NEG
76594: PUSH
76595: LD_INT 4
76597: NEG
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 5
76605: NEG
76606: PUSH
76607: LD_INT 5
76609: NEG
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 3
76617: NEG
76618: PUSH
76619: LD_INT 5
76621: NEG
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: LD_INT 5
76629: NEG
76630: PUSH
76631: LD_INT 3
76633: NEG
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 0
76641: PUSH
76642: LD_INT 3
76644: NEG
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 0
76652: PUSH
76653: LD_INT 4
76655: NEG
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: PUSH
76661: LD_INT 1
76663: PUSH
76664: LD_INT 3
76666: NEG
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: LD_INT 1
76674: PUSH
76675: LD_INT 2
76677: NEG
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: LD_INT 0
76685: PUSH
76686: LD_INT 2
76688: NEG
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 1
76696: NEG
76697: PUSH
76698: LD_INT 3
76700: NEG
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PUSH
76706: LD_INT 1
76708: NEG
76709: PUSH
76710: LD_INT 4
76712: NEG
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 2
76720: PUSH
76721: LD_INT 2
76723: NEG
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 2
76731: NEG
76732: PUSH
76733: LD_INT 4
76735: NEG
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 4
76743: PUSH
76744: LD_INT 0
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 4
76753: PUSH
76754: LD_INT 1
76756: NEG
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 5
76764: PUSH
76765: LD_INT 0
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 5
76774: PUSH
76775: LD_INT 1
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 4
76784: PUSH
76785: LD_INT 1
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 3
76794: PUSH
76795: LD_INT 0
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: LD_INT 3
76804: PUSH
76805: LD_INT 1
76807: NEG
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 3
76815: PUSH
76816: LD_INT 2
76818: NEG
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 5
76826: PUSH
76827: LD_INT 2
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 3
76836: PUSH
76837: LD_INT 3
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 3
76846: PUSH
76847: LD_INT 2
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 4
76856: PUSH
76857: LD_INT 3
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: LD_INT 4
76866: PUSH
76867: LD_INT 4
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 3
76876: PUSH
76877: LD_INT 4
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 2
76886: PUSH
76887: LD_INT 3
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 2
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 4
76906: PUSH
76907: LD_INT 2
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 2
76916: PUSH
76917: LD_INT 4
76919: PUSH
76920: EMPTY
76921: LIST
76922: LIST
76923: PUSH
76924: LD_INT 0
76926: PUSH
76927: LD_INT 4
76929: PUSH
76930: EMPTY
76931: LIST
76932: LIST
76933: PUSH
76934: LD_INT 0
76936: PUSH
76937: LD_INT 3
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: PUSH
76944: LD_INT 1
76946: PUSH
76947: LD_INT 4
76949: PUSH
76950: EMPTY
76951: LIST
76952: LIST
76953: PUSH
76954: LD_INT 1
76956: PUSH
76957: LD_INT 5
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 0
76966: PUSH
76967: LD_INT 5
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 1
76976: NEG
76977: PUSH
76978: LD_INT 4
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: LD_INT 1
76987: NEG
76988: PUSH
76989: LD_INT 3
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 2
76998: PUSH
76999: LD_INT 5
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: LD_INT 3
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: LIST
77021: LIST
77022: LIST
77023: LIST
77024: LIST
77025: LIST
77026: LIST
77027: LIST
77028: LIST
77029: LIST
77030: LIST
77031: LIST
77032: LIST
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: LIST
77039: LIST
77040: LIST
77041: LIST
77042: LIST
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
77064: LD_ADDR_VAR 0 34
77068: PUSH
77069: LD_INT 0
77071: PUSH
77072: LD_INT 4
77074: NEG
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 0
77082: PUSH
77083: LD_INT 5
77085: NEG
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: LD_INT 4
77096: NEG
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: LD_INT 1
77104: PUSH
77105: LD_INT 3
77107: NEG
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: LD_INT 3
77118: NEG
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 1
77126: NEG
77127: PUSH
77128: LD_INT 4
77130: NEG
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 1
77138: NEG
77139: PUSH
77140: LD_INT 5
77142: NEG
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 2
77150: PUSH
77151: LD_INT 3
77153: NEG
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 2
77161: NEG
77162: PUSH
77163: LD_INT 5
77165: NEG
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 3
77173: PUSH
77174: LD_INT 0
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 3
77183: PUSH
77184: LD_INT 1
77186: NEG
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 4
77194: PUSH
77195: LD_INT 0
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 4
77204: PUSH
77205: LD_INT 1
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 3
77214: PUSH
77215: LD_INT 1
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 2
77224: PUSH
77225: LD_INT 0
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 2
77234: PUSH
77235: LD_INT 1
77237: NEG
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: LD_INT 2
77245: PUSH
77246: LD_INT 2
77248: NEG
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: PUSH
77254: LD_INT 4
77256: PUSH
77257: LD_INT 2
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 4
77266: PUSH
77267: LD_INT 4
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 4
77276: PUSH
77277: LD_INT 3
77279: PUSH
77280: EMPTY
77281: LIST
77282: LIST
77283: PUSH
77284: LD_INT 5
77286: PUSH
77287: LD_INT 4
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 5
77296: PUSH
77297: LD_INT 5
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 4
77306: PUSH
77307: LD_INT 5
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 3
77316: PUSH
77317: LD_INT 4
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 3
77326: PUSH
77327: LD_INT 3
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 5
77336: PUSH
77337: LD_INT 3
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 3
77346: PUSH
77347: LD_INT 5
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 0
77356: PUSH
77357: LD_INT 3
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 0
77366: PUSH
77367: LD_INT 2
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: LD_INT 3
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 1
77386: PUSH
77387: LD_INT 4
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 0
77396: PUSH
77397: LD_INT 4
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 1
77406: NEG
77407: PUSH
77408: LD_INT 3
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 1
77417: NEG
77418: PUSH
77419: LD_INT 2
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 2
77428: PUSH
77429: LD_INT 4
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 2
77438: NEG
77439: PUSH
77440: LD_INT 2
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 4
77449: NEG
77450: PUSH
77451: LD_INT 0
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 4
77460: NEG
77461: PUSH
77462: LD_INT 1
77464: NEG
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 3
77472: NEG
77473: PUSH
77474: LD_INT 0
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 3
77483: NEG
77484: PUSH
77485: LD_INT 1
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 4
77494: NEG
77495: PUSH
77496: LD_INT 1
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 5
77505: NEG
77506: PUSH
77507: LD_INT 0
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 5
77516: NEG
77517: PUSH
77518: LD_INT 1
77520: NEG
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 5
77528: NEG
77529: PUSH
77530: LD_INT 2
77532: NEG
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 3
77540: NEG
77541: PUSH
77542: LD_INT 2
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: LIST
77568: LIST
77569: LIST
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: ST_TO_ADDR
// end ; end ;
77596: GO 77599
77598: POP
// case btype of b_depot , b_warehouse :
77599: LD_VAR 0 1
77603: PUSH
77604: LD_INT 0
77606: DOUBLE
77607: EQUAL
77608: IFTRUE 77618
77610: LD_INT 1
77612: DOUBLE
77613: EQUAL
77614: IFTRUE 77618
77616: GO 77819
77618: POP
// case nation of nation_american :
77619: LD_VAR 0 5
77623: PUSH
77624: LD_INT 1
77626: DOUBLE
77627: EQUAL
77628: IFTRUE 77632
77630: GO 77688
77632: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
77633: LD_ADDR_VAR 0 9
77637: PUSH
77638: LD_VAR 0 11
77642: PUSH
77643: LD_VAR 0 12
77647: PUSH
77648: LD_VAR 0 13
77652: PUSH
77653: LD_VAR 0 14
77657: PUSH
77658: LD_VAR 0 15
77662: PUSH
77663: LD_VAR 0 16
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: PUSH
77676: LD_VAR 0 4
77680: PUSH
77681: LD_INT 1
77683: PLUS
77684: ARRAY
77685: ST_TO_ADDR
77686: GO 77817
77688: LD_INT 2
77690: DOUBLE
77691: EQUAL
77692: IFTRUE 77696
77694: GO 77752
77696: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
77697: LD_ADDR_VAR 0 9
77701: PUSH
77702: LD_VAR 0 17
77706: PUSH
77707: LD_VAR 0 18
77711: PUSH
77712: LD_VAR 0 19
77716: PUSH
77717: LD_VAR 0 20
77721: PUSH
77722: LD_VAR 0 21
77726: PUSH
77727: LD_VAR 0 22
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: PUSH
77740: LD_VAR 0 4
77744: PUSH
77745: LD_INT 1
77747: PLUS
77748: ARRAY
77749: ST_TO_ADDR
77750: GO 77817
77752: LD_INT 3
77754: DOUBLE
77755: EQUAL
77756: IFTRUE 77760
77758: GO 77816
77760: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
77761: LD_ADDR_VAR 0 9
77765: PUSH
77766: LD_VAR 0 23
77770: PUSH
77771: LD_VAR 0 24
77775: PUSH
77776: LD_VAR 0 25
77780: PUSH
77781: LD_VAR 0 26
77785: PUSH
77786: LD_VAR 0 27
77790: PUSH
77791: LD_VAR 0 28
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: LIST
77800: LIST
77801: LIST
77802: LIST
77803: PUSH
77804: LD_VAR 0 4
77808: PUSH
77809: LD_INT 1
77811: PLUS
77812: ARRAY
77813: ST_TO_ADDR
77814: GO 77817
77816: POP
77817: GO 78366
77819: LD_INT 2
77821: DOUBLE
77822: EQUAL
77823: IFTRUE 77833
77825: LD_INT 3
77827: DOUBLE
77828: EQUAL
77829: IFTRUE 77833
77831: GO 77889
77833: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
77834: LD_ADDR_VAR 0 9
77838: PUSH
77839: LD_VAR 0 29
77843: PUSH
77844: LD_VAR 0 30
77848: PUSH
77849: LD_VAR 0 31
77853: PUSH
77854: LD_VAR 0 32
77858: PUSH
77859: LD_VAR 0 33
77863: PUSH
77864: LD_VAR 0 34
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: LIST
77875: LIST
77876: PUSH
77877: LD_VAR 0 4
77881: PUSH
77882: LD_INT 1
77884: PLUS
77885: ARRAY
77886: ST_TO_ADDR
77887: GO 78366
77889: LD_INT 16
77891: DOUBLE
77892: EQUAL
77893: IFTRUE 77945
77895: LD_INT 17
77897: DOUBLE
77898: EQUAL
77899: IFTRUE 77945
77901: LD_INT 18
77903: DOUBLE
77904: EQUAL
77905: IFTRUE 77945
77907: LD_INT 19
77909: DOUBLE
77910: EQUAL
77911: IFTRUE 77945
77913: LD_INT 20
77915: DOUBLE
77916: EQUAL
77917: IFTRUE 77945
77919: LD_INT 21
77921: DOUBLE
77922: EQUAL
77923: IFTRUE 77945
77925: LD_INT 23
77927: DOUBLE
77928: EQUAL
77929: IFTRUE 77945
77931: LD_INT 24
77933: DOUBLE
77934: EQUAL
77935: IFTRUE 77945
77937: LD_INT 25
77939: DOUBLE
77940: EQUAL
77941: IFTRUE 77945
77943: GO 78001
77945: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
77946: LD_ADDR_VAR 0 9
77950: PUSH
77951: LD_VAR 0 35
77955: PUSH
77956: LD_VAR 0 36
77960: PUSH
77961: LD_VAR 0 37
77965: PUSH
77966: LD_VAR 0 38
77970: PUSH
77971: LD_VAR 0 39
77975: PUSH
77976: LD_VAR 0 40
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: PUSH
77989: LD_VAR 0 4
77993: PUSH
77994: LD_INT 1
77996: PLUS
77997: ARRAY
77998: ST_TO_ADDR
77999: GO 78366
78001: LD_INT 6
78003: DOUBLE
78004: EQUAL
78005: IFTRUE 78057
78007: LD_INT 7
78009: DOUBLE
78010: EQUAL
78011: IFTRUE 78057
78013: LD_INT 8
78015: DOUBLE
78016: EQUAL
78017: IFTRUE 78057
78019: LD_INT 13
78021: DOUBLE
78022: EQUAL
78023: IFTRUE 78057
78025: LD_INT 12
78027: DOUBLE
78028: EQUAL
78029: IFTRUE 78057
78031: LD_INT 15
78033: DOUBLE
78034: EQUAL
78035: IFTRUE 78057
78037: LD_INT 11
78039: DOUBLE
78040: EQUAL
78041: IFTRUE 78057
78043: LD_INT 14
78045: DOUBLE
78046: EQUAL
78047: IFTRUE 78057
78049: LD_INT 10
78051: DOUBLE
78052: EQUAL
78053: IFTRUE 78057
78055: GO 78113
78057: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
78058: LD_ADDR_VAR 0 9
78062: PUSH
78063: LD_VAR 0 41
78067: PUSH
78068: LD_VAR 0 42
78072: PUSH
78073: LD_VAR 0 43
78077: PUSH
78078: LD_VAR 0 44
78082: PUSH
78083: LD_VAR 0 45
78087: PUSH
78088: LD_VAR 0 46
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: LIST
78097: LIST
78098: LIST
78099: LIST
78100: PUSH
78101: LD_VAR 0 4
78105: PUSH
78106: LD_INT 1
78108: PLUS
78109: ARRAY
78110: ST_TO_ADDR
78111: GO 78366
78113: LD_INT 36
78115: DOUBLE
78116: EQUAL
78117: IFTRUE 78121
78119: GO 78177
78121: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
78122: LD_ADDR_VAR 0 9
78126: PUSH
78127: LD_VAR 0 47
78131: PUSH
78132: LD_VAR 0 48
78136: PUSH
78137: LD_VAR 0 49
78141: PUSH
78142: LD_VAR 0 50
78146: PUSH
78147: LD_VAR 0 51
78151: PUSH
78152: LD_VAR 0 52
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: PUSH
78165: LD_VAR 0 4
78169: PUSH
78170: LD_INT 1
78172: PLUS
78173: ARRAY
78174: ST_TO_ADDR
78175: GO 78366
78177: LD_INT 4
78179: DOUBLE
78180: EQUAL
78181: IFTRUE 78203
78183: LD_INT 5
78185: DOUBLE
78186: EQUAL
78187: IFTRUE 78203
78189: LD_INT 34
78191: DOUBLE
78192: EQUAL
78193: IFTRUE 78203
78195: LD_INT 37
78197: DOUBLE
78198: EQUAL
78199: IFTRUE 78203
78201: GO 78259
78203: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
78204: LD_ADDR_VAR 0 9
78208: PUSH
78209: LD_VAR 0 53
78213: PUSH
78214: LD_VAR 0 54
78218: PUSH
78219: LD_VAR 0 55
78223: PUSH
78224: LD_VAR 0 56
78228: PUSH
78229: LD_VAR 0 57
78233: PUSH
78234: LD_VAR 0 58
78238: PUSH
78239: EMPTY
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: PUSH
78247: LD_VAR 0 4
78251: PUSH
78252: LD_INT 1
78254: PLUS
78255: ARRAY
78256: ST_TO_ADDR
78257: GO 78366
78259: LD_INT 31
78261: DOUBLE
78262: EQUAL
78263: IFTRUE 78309
78265: LD_INT 32
78267: DOUBLE
78268: EQUAL
78269: IFTRUE 78309
78271: LD_INT 33
78273: DOUBLE
78274: EQUAL
78275: IFTRUE 78309
78277: LD_INT 27
78279: DOUBLE
78280: EQUAL
78281: IFTRUE 78309
78283: LD_INT 26
78285: DOUBLE
78286: EQUAL
78287: IFTRUE 78309
78289: LD_INT 28
78291: DOUBLE
78292: EQUAL
78293: IFTRUE 78309
78295: LD_INT 29
78297: DOUBLE
78298: EQUAL
78299: IFTRUE 78309
78301: LD_INT 30
78303: DOUBLE
78304: EQUAL
78305: IFTRUE 78309
78307: GO 78365
78309: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
78310: LD_ADDR_VAR 0 9
78314: PUSH
78315: LD_VAR 0 59
78319: PUSH
78320: LD_VAR 0 60
78324: PUSH
78325: LD_VAR 0 61
78329: PUSH
78330: LD_VAR 0 62
78334: PUSH
78335: LD_VAR 0 63
78339: PUSH
78340: LD_VAR 0 64
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: PUSH
78353: LD_VAR 0 4
78357: PUSH
78358: LD_INT 1
78360: PLUS
78361: ARRAY
78362: ST_TO_ADDR
78363: GO 78366
78365: POP
// temp_list2 = [ ] ;
78366: LD_ADDR_VAR 0 10
78370: PUSH
78371: EMPTY
78372: ST_TO_ADDR
// for i in temp_list do
78373: LD_ADDR_VAR 0 8
78377: PUSH
78378: LD_VAR 0 9
78382: PUSH
78383: FOR_IN
78384: IFFALSE 78436
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
78386: LD_ADDR_VAR 0 10
78390: PUSH
78391: LD_VAR 0 10
78395: PUSH
78396: LD_VAR 0 8
78400: PUSH
78401: LD_INT 1
78403: ARRAY
78404: PUSH
78405: LD_VAR 0 2
78409: PLUS
78410: PUSH
78411: LD_VAR 0 8
78415: PUSH
78416: LD_INT 2
78418: ARRAY
78419: PUSH
78420: LD_VAR 0 3
78424: PLUS
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: EMPTY
78431: LIST
78432: ADD
78433: ST_TO_ADDR
78434: GO 78383
78436: POP
78437: POP
// result = temp_list2 ;
78438: LD_ADDR_VAR 0 7
78442: PUSH
78443: LD_VAR 0 10
78447: ST_TO_ADDR
// end ;
78448: LD_VAR 0 7
78452: RET
// export function EnemyInRange ( unit , dist ) ; begin
78453: LD_INT 0
78455: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
78456: LD_ADDR_VAR 0 3
78460: PUSH
78461: LD_VAR 0 1
78465: PPUSH
78466: CALL_OW 255
78470: PPUSH
78471: LD_VAR 0 1
78475: PPUSH
78476: CALL_OW 250
78480: PPUSH
78481: LD_VAR 0 1
78485: PPUSH
78486: CALL_OW 251
78490: PPUSH
78491: LD_VAR 0 2
78495: PPUSH
78496: CALL 52581 0 4
78500: PUSH
78501: LD_INT 4
78503: ARRAY
78504: ST_TO_ADDR
// end ;
78505: LD_VAR 0 3
78509: RET
// export function PlayerSeeMe ( unit ) ; begin
78510: LD_INT 0
78512: PPUSH
// result := See ( your_side , unit ) ;
78513: LD_ADDR_VAR 0 2
78517: PUSH
78518: LD_OWVAR 2
78522: PPUSH
78523: LD_VAR 0 1
78527: PPUSH
78528: CALL_OW 292
78532: ST_TO_ADDR
// end ;
78533: LD_VAR 0 2
78537: RET
// export function ReverseDir ( unit ) ; begin
78538: LD_INT 0
78540: PPUSH
// if not unit then
78541: LD_VAR 0 1
78545: NOT
78546: IFFALSE 78550
// exit ;
78548: GO 78596
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
78550: LD_ADDR_VAR 0 2
78554: PUSH
78555: LD_INT 3
78557: PUSH
78558: LD_INT 4
78560: PUSH
78561: LD_INT 5
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: LD_INT 1
78569: PUSH
78570: LD_INT 2
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: PUSH
78581: LD_VAR 0 1
78585: PPUSH
78586: CALL_OW 254
78590: PUSH
78591: LD_INT 1
78593: PLUS
78594: ARRAY
78595: ST_TO_ADDR
// end ;
78596: LD_VAR 0 2
78600: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
78601: LD_INT 0
78603: PPUSH
78604: PPUSH
78605: PPUSH
78606: PPUSH
78607: PPUSH
// if not hexes then
78608: LD_VAR 0 2
78612: NOT
78613: IFFALSE 78617
// exit ;
78615: GO 78765
// dist := 9999 ;
78617: LD_ADDR_VAR 0 5
78621: PUSH
78622: LD_INT 9999
78624: ST_TO_ADDR
// for i = 1 to hexes do
78625: LD_ADDR_VAR 0 4
78629: PUSH
78630: DOUBLE
78631: LD_INT 1
78633: DEC
78634: ST_TO_ADDR
78635: LD_VAR 0 2
78639: PUSH
78640: FOR_TO
78641: IFFALSE 78753
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
78643: LD_VAR 0 1
78647: PPUSH
78648: LD_VAR 0 2
78652: PUSH
78653: LD_VAR 0 4
78657: ARRAY
78658: PUSH
78659: LD_INT 1
78661: ARRAY
78662: PPUSH
78663: LD_VAR 0 2
78667: PUSH
78668: LD_VAR 0 4
78672: ARRAY
78673: PUSH
78674: LD_INT 2
78676: ARRAY
78677: PPUSH
78678: CALL_OW 297
78682: PUSH
78683: LD_VAR 0 5
78687: LESS
78688: IFFALSE 78751
// begin hex := hexes [ i ] ;
78690: LD_ADDR_VAR 0 7
78694: PUSH
78695: LD_VAR 0 2
78699: PUSH
78700: LD_VAR 0 4
78704: ARRAY
78705: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78706: LD_ADDR_VAR 0 5
78710: PUSH
78711: LD_VAR 0 1
78715: PPUSH
78716: LD_VAR 0 2
78720: PUSH
78721: LD_VAR 0 4
78725: ARRAY
78726: PUSH
78727: LD_INT 1
78729: ARRAY
78730: PPUSH
78731: LD_VAR 0 2
78735: PUSH
78736: LD_VAR 0 4
78740: ARRAY
78741: PUSH
78742: LD_INT 2
78744: ARRAY
78745: PPUSH
78746: CALL_OW 297
78750: ST_TO_ADDR
// end ; end ;
78751: GO 78640
78753: POP
78754: POP
// result := hex ;
78755: LD_ADDR_VAR 0 3
78759: PUSH
78760: LD_VAR 0 7
78764: ST_TO_ADDR
// end ;
78765: LD_VAR 0 3
78769: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
78770: LD_INT 0
78772: PPUSH
78773: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
78774: LD_VAR 0 1
78778: NOT
78779: PUSH
78780: LD_VAR 0 1
78784: PUSH
78785: LD_INT 21
78787: PUSH
78788: LD_INT 2
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 23
78797: PUSH
78798: LD_INT 2
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PPUSH
78809: CALL_OW 69
78813: IN
78814: NOT
78815: OR
78816: IFFALSE 78820
// exit ;
78818: GO 78867
// for i = 1 to 3 do
78820: LD_ADDR_VAR 0 3
78824: PUSH
78825: DOUBLE
78826: LD_INT 1
78828: DEC
78829: ST_TO_ADDR
78830: LD_INT 3
78832: PUSH
78833: FOR_TO
78834: IFFALSE 78865
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
78836: LD_VAR 0 1
78840: PPUSH
78841: CALL_OW 250
78845: PPUSH
78846: LD_VAR 0 1
78850: PPUSH
78851: CALL_OW 251
78855: PPUSH
78856: LD_INT 1
78858: PPUSH
78859: CALL_OW 453
78863: GO 78833
78865: POP
78866: POP
// end ;
78867: LD_VAR 0 2
78871: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
78872: LD_INT 0
78874: PPUSH
78875: PPUSH
78876: PPUSH
78877: PPUSH
78878: PPUSH
78879: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
78880: LD_VAR 0 1
78884: NOT
78885: PUSH
78886: LD_VAR 0 2
78890: NOT
78891: OR
78892: PUSH
78893: LD_VAR 0 1
78897: PPUSH
78898: CALL_OW 314
78902: OR
78903: IFFALSE 78907
// exit ;
78905: GO 79348
// x := GetX ( enemy_unit ) ;
78907: LD_ADDR_VAR 0 7
78911: PUSH
78912: LD_VAR 0 2
78916: PPUSH
78917: CALL_OW 250
78921: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
78922: LD_ADDR_VAR 0 8
78926: PUSH
78927: LD_VAR 0 2
78931: PPUSH
78932: CALL_OW 251
78936: ST_TO_ADDR
// if not x or not y then
78937: LD_VAR 0 7
78941: NOT
78942: PUSH
78943: LD_VAR 0 8
78947: NOT
78948: OR
78949: IFFALSE 78953
// exit ;
78951: GO 79348
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
78953: LD_ADDR_VAR 0 6
78957: PUSH
78958: LD_VAR 0 7
78962: PPUSH
78963: LD_INT 0
78965: PPUSH
78966: LD_INT 4
78968: PPUSH
78969: CALL_OW 272
78973: PUSH
78974: LD_VAR 0 8
78978: PPUSH
78979: LD_INT 0
78981: PPUSH
78982: LD_INT 4
78984: PPUSH
78985: CALL_OW 273
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_VAR 0 7
78998: PPUSH
78999: LD_INT 1
79001: PPUSH
79002: LD_INT 4
79004: PPUSH
79005: CALL_OW 272
79009: PUSH
79010: LD_VAR 0 8
79014: PPUSH
79015: LD_INT 1
79017: PPUSH
79018: LD_INT 4
79020: PPUSH
79021: CALL_OW 273
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_VAR 0 7
79034: PPUSH
79035: LD_INT 2
79037: PPUSH
79038: LD_INT 4
79040: PPUSH
79041: CALL_OW 272
79045: PUSH
79046: LD_VAR 0 8
79050: PPUSH
79051: LD_INT 2
79053: PPUSH
79054: LD_INT 4
79056: PPUSH
79057: CALL_OW 273
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: PUSH
79066: LD_VAR 0 7
79070: PPUSH
79071: LD_INT 3
79073: PPUSH
79074: LD_INT 4
79076: PPUSH
79077: CALL_OW 272
79081: PUSH
79082: LD_VAR 0 8
79086: PPUSH
79087: LD_INT 3
79089: PPUSH
79090: LD_INT 4
79092: PPUSH
79093: CALL_OW 273
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_VAR 0 7
79106: PPUSH
79107: LD_INT 4
79109: PPUSH
79110: LD_INT 4
79112: PPUSH
79113: CALL_OW 272
79117: PUSH
79118: LD_VAR 0 8
79122: PPUSH
79123: LD_INT 4
79125: PPUSH
79126: LD_INT 4
79128: PPUSH
79129: CALL_OW 273
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_VAR 0 7
79142: PPUSH
79143: LD_INT 5
79145: PPUSH
79146: LD_INT 4
79148: PPUSH
79149: CALL_OW 272
79153: PUSH
79154: LD_VAR 0 8
79158: PPUSH
79159: LD_INT 5
79161: PPUSH
79162: LD_INT 4
79164: PPUSH
79165: CALL_OW 273
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: ST_TO_ADDR
// for i = tmp downto 1 do
79182: LD_ADDR_VAR 0 4
79186: PUSH
79187: DOUBLE
79188: LD_VAR 0 6
79192: INC
79193: ST_TO_ADDR
79194: LD_INT 1
79196: PUSH
79197: FOR_DOWNTO
79198: IFFALSE 79299
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
79200: LD_VAR 0 6
79204: PUSH
79205: LD_VAR 0 4
79209: ARRAY
79210: PUSH
79211: LD_INT 1
79213: ARRAY
79214: PPUSH
79215: LD_VAR 0 6
79219: PUSH
79220: LD_VAR 0 4
79224: ARRAY
79225: PUSH
79226: LD_INT 2
79228: ARRAY
79229: PPUSH
79230: CALL_OW 488
79234: NOT
79235: PUSH
79236: LD_VAR 0 6
79240: PUSH
79241: LD_VAR 0 4
79245: ARRAY
79246: PUSH
79247: LD_INT 1
79249: ARRAY
79250: PPUSH
79251: LD_VAR 0 6
79255: PUSH
79256: LD_VAR 0 4
79260: ARRAY
79261: PUSH
79262: LD_INT 2
79264: ARRAY
79265: PPUSH
79266: CALL_OW 428
79270: PUSH
79271: LD_INT 0
79273: NONEQUAL
79274: OR
79275: IFFALSE 79297
// tmp := Delete ( tmp , i ) ;
79277: LD_ADDR_VAR 0 6
79281: PUSH
79282: LD_VAR 0 6
79286: PPUSH
79287: LD_VAR 0 4
79291: PPUSH
79292: CALL_OW 3
79296: ST_TO_ADDR
79297: GO 79197
79299: POP
79300: POP
// j := GetClosestHex ( unit , tmp ) ;
79301: LD_ADDR_VAR 0 5
79305: PUSH
79306: LD_VAR 0 1
79310: PPUSH
79311: LD_VAR 0 6
79315: PPUSH
79316: CALL 78601 0 2
79320: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
79321: LD_VAR 0 1
79325: PPUSH
79326: LD_VAR 0 5
79330: PUSH
79331: LD_INT 1
79333: ARRAY
79334: PPUSH
79335: LD_VAR 0 5
79339: PUSH
79340: LD_INT 2
79342: ARRAY
79343: PPUSH
79344: CALL_OW 111
// end ;
79348: LD_VAR 0 3
79352: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
79353: LD_INT 0
79355: PPUSH
79356: PPUSH
79357: PPUSH
// uc_side = 0 ;
79358: LD_ADDR_OWVAR 20
79362: PUSH
79363: LD_INT 0
79365: ST_TO_ADDR
// uc_nation = 0 ;
79366: LD_ADDR_OWVAR 21
79370: PUSH
79371: LD_INT 0
79373: ST_TO_ADDR
// InitHc ;
79374: CALL_OW 19
// InitVc ;
79378: CALL_OW 20
// if mastodonts then
79382: LD_VAR 0 6
79386: IFFALSE 79453
// for i = 1 to mastodonts do
79388: LD_ADDR_VAR 0 11
79392: PUSH
79393: DOUBLE
79394: LD_INT 1
79396: DEC
79397: ST_TO_ADDR
79398: LD_VAR 0 6
79402: PUSH
79403: FOR_TO
79404: IFFALSE 79451
// begin vc_chassis := 31 ;
79406: LD_ADDR_OWVAR 37
79410: PUSH
79411: LD_INT 31
79413: ST_TO_ADDR
// vc_control := control_rider ;
79414: LD_ADDR_OWVAR 38
79418: PUSH
79419: LD_INT 4
79421: ST_TO_ADDR
// animal := CreateVehicle ;
79422: LD_ADDR_VAR 0 12
79426: PUSH
79427: CALL_OW 45
79431: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79432: LD_VAR 0 12
79436: PPUSH
79437: LD_VAR 0 8
79441: PPUSH
79442: LD_INT 0
79444: PPUSH
79445: CALL 86159 0 3
// end ;
79449: GO 79403
79451: POP
79452: POP
// if horses then
79453: LD_VAR 0 5
79457: IFFALSE 79524
// for i = 1 to horses do
79459: LD_ADDR_VAR 0 11
79463: PUSH
79464: DOUBLE
79465: LD_INT 1
79467: DEC
79468: ST_TO_ADDR
79469: LD_VAR 0 5
79473: PUSH
79474: FOR_TO
79475: IFFALSE 79522
// begin hc_class := 21 ;
79477: LD_ADDR_OWVAR 28
79481: PUSH
79482: LD_INT 21
79484: ST_TO_ADDR
// hc_gallery :=  ;
79485: LD_ADDR_OWVAR 33
79489: PUSH
79490: LD_STRING 
79492: ST_TO_ADDR
// animal := CreateHuman ;
79493: LD_ADDR_VAR 0 12
79497: PUSH
79498: CALL_OW 44
79502: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79503: LD_VAR 0 12
79507: PPUSH
79508: LD_VAR 0 8
79512: PPUSH
79513: LD_INT 0
79515: PPUSH
79516: CALL 86159 0 3
// end ;
79520: GO 79474
79522: POP
79523: POP
// if birds then
79524: LD_VAR 0 1
79528: IFFALSE 79595
// for i = 1 to birds do
79530: LD_ADDR_VAR 0 11
79534: PUSH
79535: DOUBLE
79536: LD_INT 1
79538: DEC
79539: ST_TO_ADDR
79540: LD_VAR 0 1
79544: PUSH
79545: FOR_TO
79546: IFFALSE 79593
// begin hc_class = 18 ;
79548: LD_ADDR_OWVAR 28
79552: PUSH
79553: LD_INT 18
79555: ST_TO_ADDR
// hc_gallery =  ;
79556: LD_ADDR_OWVAR 33
79560: PUSH
79561: LD_STRING 
79563: ST_TO_ADDR
// animal := CreateHuman ;
79564: LD_ADDR_VAR 0 12
79568: PUSH
79569: CALL_OW 44
79573: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79574: LD_VAR 0 12
79578: PPUSH
79579: LD_VAR 0 8
79583: PPUSH
79584: LD_INT 0
79586: PPUSH
79587: CALL 86159 0 3
// end ;
79591: GO 79545
79593: POP
79594: POP
// if tigers then
79595: LD_VAR 0 2
79599: IFFALSE 79683
// for i = 1 to tigers do
79601: LD_ADDR_VAR 0 11
79605: PUSH
79606: DOUBLE
79607: LD_INT 1
79609: DEC
79610: ST_TO_ADDR
79611: LD_VAR 0 2
79615: PUSH
79616: FOR_TO
79617: IFFALSE 79681
// begin hc_class = class_tiger ;
79619: LD_ADDR_OWVAR 28
79623: PUSH
79624: LD_INT 14
79626: ST_TO_ADDR
// hc_gallery =  ;
79627: LD_ADDR_OWVAR 33
79631: PUSH
79632: LD_STRING 
79634: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
79635: LD_ADDR_OWVAR 35
79639: PUSH
79640: LD_INT 7
79642: NEG
79643: PPUSH
79644: LD_INT 7
79646: PPUSH
79647: CALL_OW 12
79651: ST_TO_ADDR
// animal := CreateHuman ;
79652: LD_ADDR_VAR 0 12
79656: PUSH
79657: CALL_OW 44
79661: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79662: LD_VAR 0 12
79666: PPUSH
79667: LD_VAR 0 8
79671: PPUSH
79672: LD_INT 0
79674: PPUSH
79675: CALL 86159 0 3
// end ;
79679: GO 79616
79681: POP
79682: POP
// if apemans then
79683: LD_VAR 0 3
79687: IFFALSE 79810
// for i = 1 to apemans do
79689: LD_ADDR_VAR 0 11
79693: PUSH
79694: DOUBLE
79695: LD_INT 1
79697: DEC
79698: ST_TO_ADDR
79699: LD_VAR 0 3
79703: PUSH
79704: FOR_TO
79705: IFFALSE 79808
// begin hc_class = class_apeman ;
79707: LD_ADDR_OWVAR 28
79711: PUSH
79712: LD_INT 12
79714: ST_TO_ADDR
// hc_gallery =  ;
79715: LD_ADDR_OWVAR 33
79719: PUSH
79720: LD_STRING 
79722: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
79723: LD_ADDR_OWVAR 35
79727: PUSH
79728: LD_INT 5
79730: NEG
79731: PPUSH
79732: LD_INT 5
79734: PPUSH
79735: CALL_OW 12
79739: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
79740: LD_ADDR_OWVAR 31
79744: PUSH
79745: LD_INT 1
79747: PPUSH
79748: LD_INT 3
79750: PPUSH
79751: CALL_OW 12
79755: PUSH
79756: LD_INT 1
79758: PPUSH
79759: LD_INT 3
79761: PPUSH
79762: CALL_OW 12
79766: PUSH
79767: LD_INT 0
79769: PUSH
79770: LD_INT 0
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: LIST
79777: LIST
79778: ST_TO_ADDR
// animal := CreateHuman ;
79779: LD_ADDR_VAR 0 12
79783: PUSH
79784: CALL_OW 44
79788: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79789: LD_VAR 0 12
79793: PPUSH
79794: LD_VAR 0 8
79798: PPUSH
79799: LD_INT 0
79801: PPUSH
79802: CALL 86159 0 3
// end ;
79806: GO 79704
79808: POP
79809: POP
// if enchidnas then
79810: LD_VAR 0 4
79814: IFFALSE 79881
// for i = 1 to enchidnas do
79816: LD_ADDR_VAR 0 11
79820: PUSH
79821: DOUBLE
79822: LD_INT 1
79824: DEC
79825: ST_TO_ADDR
79826: LD_VAR 0 4
79830: PUSH
79831: FOR_TO
79832: IFFALSE 79879
// begin hc_class = 13 ;
79834: LD_ADDR_OWVAR 28
79838: PUSH
79839: LD_INT 13
79841: ST_TO_ADDR
// hc_gallery =  ;
79842: LD_ADDR_OWVAR 33
79846: PUSH
79847: LD_STRING 
79849: ST_TO_ADDR
// animal := CreateHuman ;
79850: LD_ADDR_VAR 0 12
79854: PUSH
79855: CALL_OW 44
79859: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79860: LD_VAR 0 12
79864: PPUSH
79865: LD_VAR 0 8
79869: PPUSH
79870: LD_INT 0
79872: PPUSH
79873: CALL 86159 0 3
// end ;
79877: GO 79831
79879: POP
79880: POP
// if fishes then
79881: LD_VAR 0 7
79885: IFFALSE 79952
// for i = 1 to fishes do
79887: LD_ADDR_VAR 0 11
79891: PUSH
79892: DOUBLE
79893: LD_INT 1
79895: DEC
79896: ST_TO_ADDR
79897: LD_VAR 0 7
79901: PUSH
79902: FOR_TO
79903: IFFALSE 79950
// begin hc_class = 20 ;
79905: LD_ADDR_OWVAR 28
79909: PUSH
79910: LD_INT 20
79912: ST_TO_ADDR
// hc_gallery =  ;
79913: LD_ADDR_OWVAR 33
79917: PUSH
79918: LD_STRING 
79920: ST_TO_ADDR
// animal := CreateHuman ;
79921: LD_ADDR_VAR 0 12
79925: PUSH
79926: CALL_OW 44
79930: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
79931: LD_VAR 0 12
79935: PPUSH
79936: LD_VAR 0 9
79940: PPUSH
79941: LD_INT 0
79943: PPUSH
79944: CALL 86159 0 3
// end ;
79948: GO 79902
79950: POP
79951: POP
// end ;
79952: LD_VAR 0 10
79956: RET
// export function WantHeal ( sci , unit ) ; begin
79957: LD_INT 0
79959: PPUSH
// if GetTaskList ( sci ) > 0 then
79960: LD_VAR 0 1
79964: PPUSH
79965: CALL_OW 437
79969: PUSH
79970: LD_INT 0
79972: GREATER
79973: IFFALSE 80043
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
79975: LD_VAR 0 1
79979: PPUSH
79980: CALL_OW 437
79984: PUSH
79985: LD_INT 1
79987: ARRAY
79988: PUSH
79989: LD_INT 1
79991: ARRAY
79992: PUSH
79993: LD_STRING l
79995: EQUAL
79996: PUSH
79997: LD_VAR 0 1
80001: PPUSH
80002: CALL_OW 437
80006: PUSH
80007: LD_INT 1
80009: ARRAY
80010: PUSH
80011: LD_INT 4
80013: ARRAY
80014: PUSH
80015: LD_VAR 0 2
80019: EQUAL
80020: AND
80021: IFFALSE 80033
// result := true else
80023: LD_ADDR_VAR 0 3
80027: PUSH
80028: LD_INT 1
80030: ST_TO_ADDR
80031: GO 80041
// result := false ;
80033: LD_ADDR_VAR 0 3
80037: PUSH
80038: LD_INT 0
80040: ST_TO_ADDR
// end else
80041: GO 80051
// result := false ;
80043: LD_ADDR_VAR 0 3
80047: PUSH
80048: LD_INT 0
80050: ST_TO_ADDR
// end ;
80051: LD_VAR 0 3
80055: RET
// export function HealTarget ( sci ) ; begin
80056: LD_INT 0
80058: PPUSH
// if not sci then
80059: LD_VAR 0 1
80063: NOT
80064: IFFALSE 80068
// exit ;
80066: GO 80133
// result := 0 ;
80068: LD_ADDR_VAR 0 2
80072: PUSH
80073: LD_INT 0
80075: ST_TO_ADDR
// if GetTaskList ( sci ) then
80076: LD_VAR 0 1
80080: PPUSH
80081: CALL_OW 437
80085: IFFALSE 80133
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
80087: LD_VAR 0 1
80091: PPUSH
80092: CALL_OW 437
80096: PUSH
80097: LD_INT 1
80099: ARRAY
80100: PUSH
80101: LD_INT 1
80103: ARRAY
80104: PUSH
80105: LD_STRING l
80107: EQUAL
80108: IFFALSE 80133
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
80110: LD_ADDR_VAR 0 2
80114: PUSH
80115: LD_VAR 0 1
80119: PPUSH
80120: CALL_OW 437
80124: PUSH
80125: LD_INT 1
80127: ARRAY
80128: PUSH
80129: LD_INT 4
80131: ARRAY
80132: ST_TO_ADDR
// end ;
80133: LD_VAR 0 2
80137: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
80138: LD_INT 0
80140: PPUSH
80141: PPUSH
80142: PPUSH
80143: PPUSH
80144: PPUSH
80145: PPUSH
80146: PPUSH
80147: PPUSH
80148: PPUSH
80149: PPUSH
80150: PPUSH
80151: PPUSH
80152: PPUSH
80153: PPUSH
80154: PPUSH
80155: PPUSH
80156: PPUSH
80157: PPUSH
80158: PPUSH
80159: PPUSH
80160: PPUSH
80161: PPUSH
80162: PPUSH
80163: PPUSH
80164: PPUSH
80165: PPUSH
80166: PPUSH
80167: PPUSH
80168: PPUSH
80169: PPUSH
80170: PPUSH
80171: PPUSH
80172: PPUSH
// if not list then
80173: LD_VAR 0 1
80177: NOT
80178: IFFALSE 80182
// exit ;
80180: GO 84770
// base := list [ 1 ] ;
80182: LD_ADDR_VAR 0 3
80186: PUSH
80187: LD_VAR 0 1
80191: PUSH
80192: LD_INT 1
80194: ARRAY
80195: ST_TO_ADDR
// group := list [ 2 ] ;
80196: LD_ADDR_VAR 0 4
80200: PUSH
80201: LD_VAR 0 1
80205: PUSH
80206: LD_INT 2
80208: ARRAY
80209: ST_TO_ADDR
// path := list [ 3 ] ;
80210: LD_ADDR_VAR 0 5
80214: PUSH
80215: LD_VAR 0 1
80219: PUSH
80220: LD_INT 3
80222: ARRAY
80223: ST_TO_ADDR
// flags := list [ 4 ] ;
80224: LD_ADDR_VAR 0 6
80228: PUSH
80229: LD_VAR 0 1
80233: PUSH
80234: LD_INT 4
80236: ARRAY
80237: ST_TO_ADDR
// mined := [ ] ;
80238: LD_ADDR_VAR 0 27
80242: PUSH
80243: EMPTY
80244: ST_TO_ADDR
// bombed := [ ] ;
80245: LD_ADDR_VAR 0 28
80249: PUSH
80250: EMPTY
80251: ST_TO_ADDR
// healers := [ ] ;
80252: LD_ADDR_VAR 0 31
80256: PUSH
80257: EMPTY
80258: ST_TO_ADDR
// to_heal := [ ] ;
80259: LD_ADDR_VAR 0 30
80263: PUSH
80264: EMPTY
80265: ST_TO_ADDR
// repairs := [ ] ;
80266: LD_ADDR_VAR 0 33
80270: PUSH
80271: EMPTY
80272: ST_TO_ADDR
// to_repair := [ ] ;
80273: LD_ADDR_VAR 0 32
80277: PUSH
80278: EMPTY
80279: ST_TO_ADDR
// if not group or not path then
80280: LD_VAR 0 4
80284: NOT
80285: PUSH
80286: LD_VAR 0 5
80290: NOT
80291: OR
80292: IFFALSE 80296
// exit ;
80294: GO 84770
// if flags then
80296: LD_VAR 0 6
80300: IFFALSE 80444
// begin f_ignore_area := flags [ 1 ] ;
80302: LD_ADDR_VAR 0 17
80306: PUSH
80307: LD_VAR 0 6
80311: PUSH
80312: LD_INT 1
80314: ARRAY
80315: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80316: LD_ADDR_VAR 0 18
80320: PUSH
80321: LD_VAR 0 6
80325: PUSH
80326: LD_INT 2
80328: ARRAY
80329: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80330: LD_ADDR_VAR 0 19
80334: PUSH
80335: LD_VAR 0 6
80339: PUSH
80340: LD_INT 3
80342: ARRAY
80343: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80344: LD_ADDR_VAR 0 20
80348: PUSH
80349: LD_VAR 0 6
80353: PUSH
80354: LD_INT 4
80356: ARRAY
80357: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80358: LD_ADDR_VAR 0 21
80362: PUSH
80363: LD_VAR 0 6
80367: PUSH
80368: LD_INT 5
80370: ARRAY
80371: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80372: LD_ADDR_VAR 0 22
80376: PUSH
80377: LD_VAR 0 6
80381: PUSH
80382: LD_INT 6
80384: ARRAY
80385: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
80386: LD_ADDR_VAR 0 23
80390: PUSH
80391: LD_VAR 0 6
80395: PUSH
80396: LD_INT 7
80398: ARRAY
80399: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
80400: LD_ADDR_VAR 0 24
80404: PUSH
80405: LD_VAR 0 6
80409: PUSH
80410: LD_INT 8
80412: ARRAY
80413: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
80414: LD_ADDR_VAR 0 25
80418: PUSH
80419: LD_VAR 0 6
80423: PUSH
80424: LD_INT 9
80426: ARRAY
80427: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
80428: LD_ADDR_VAR 0 26
80432: PUSH
80433: LD_VAR 0 6
80437: PUSH
80438: LD_INT 10
80440: ARRAY
80441: ST_TO_ADDR
// end else
80442: GO 80524
// begin f_ignore_area := false ;
80444: LD_ADDR_VAR 0 17
80448: PUSH
80449: LD_INT 0
80451: ST_TO_ADDR
// f_capture := false ;
80452: LD_ADDR_VAR 0 18
80456: PUSH
80457: LD_INT 0
80459: ST_TO_ADDR
// f_ignore_civ := false ;
80460: LD_ADDR_VAR 0 19
80464: PUSH
80465: LD_INT 0
80467: ST_TO_ADDR
// f_murder := false ;
80468: LD_ADDR_VAR 0 20
80472: PUSH
80473: LD_INT 0
80475: ST_TO_ADDR
// f_mines := false ;
80476: LD_ADDR_VAR 0 21
80480: PUSH
80481: LD_INT 0
80483: ST_TO_ADDR
// f_repair := false ;
80484: LD_ADDR_VAR 0 22
80488: PUSH
80489: LD_INT 0
80491: ST_TO_ADDR
// f_heal := false ;
80492: LD_ADDR_VAR 0 23
80496: PUSH
80497: LD_INT 0
80499: ST_TO_ADDR
// f_spacetime := false ;
80500: LD_ADDR_VAR 0 24
80504: PUSH
80505: LD_INT 0
80507: ST_TO_ADDR
// f_attack_depot := false ;
80508: LD_ADDR_VAR 0 25
80512: PUSH
80513: LD_INT 0
80515: ST_TO_ADDR
// f_crawl := false ;
80516: LD_ADDR_VAR 0 26
80520: PUSH
80521: LD_INT 0
80523: ST_TO_ADDR
// end ; if f_heal then
80524: LD_VAR 0 23
80528: IFFALSE 80555
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
80530: LD_ADDR_VAR 0 31
80534: PUSH
80535: LD_VAR 0 4
80539: PPUSH
80540: LD_INT 25
80542: PUSH
80543: LD_INT 4
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PPUSH
80550: CALL_OW 72
80554: ST_TO_ADDR
// if f_repair then
80555: LD_VAR 0 22
80559: IFFALSE 80586
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
80561: LD_ADDR_VAR 0 33
80565: PUSH
80566: LD_VAR 0 4
80570: PPUSH
80571: LD_INT 25
80573: PUSH
80574: LD_INT 3
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PPUSH
80581: CALL_OW 72
80585: ST_TO_ADDR
// units_path := [ ] ;
80586: LD_ADDR_VAR 0 16
80590: PUSH
80591: EMPTY
80592: ST_TO_ADDR
// for i = 1 to group do
80593: LD_ADDR_VAR 0 7
80597: PUSH
80598: DOUBLE
80599: LD_INT 1
80601: DEC
80602: ST_TO_ADDR
80603: LD_VAR 0 4
80607: PUSH
80608: FOR_TO
80609: IFFALSE 80638
// units_path := Replace ( units_path , i , path ) ;
80611: LD_ADDR_VAR 0 16
80615: PUSH
80616: LD_VAR 0 16
80620: PPUSH
80621: LD_VAR 0 7
80625: PPUSH
80626: LD_VAR 0 5
80630: PPUSH
80631: CALL_OW 1
80635: ST_TO_ADDR
80636: GO 80608
80638: POP
80639: POP
// repeat for i = group downto 1 do
80640: LD_ADDR_VAR 0 7
80644: PUSH
80645: DOUBLE
80646: LD_VAR 0 4
80650: INC
80651: ST_TO_ADDR
80652: LD_INT 1
80654: PUSH
80655: FOR_DOWNTO
80656: IFFALSE 84752
// begin wait ( 5 ) ;
80658: LD_INT 5
80660: PPUSH
80661: CALL_OW 67
// tmp := [ ] ;
80665: LD_ADDR_VAR 0 14
80669: PUSH
80670: EMPTY
80671: ST_TO_ADDR
// attacking := false ;
80672: LD_ADDR_VAR 0 29
80676: PUSH
80677: LD_INT 0
80679: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
80680: LD_VAR 0 4
80684: PUSH
80685: LD_VAR 0 7
80689: ARRAY
80690: PPUSH
80691: CALL_OW 301
80695: PUSH
80696: LD_VAR 0 4
80700: PUSH
80701: LD_VAR 0 7
80705: ARRAY
80706: NOT
80707: OR
80708: IFFALSE 80817
// begin if GetType ( group [ i ] ) = unit_human then
80710: LD_VAR 0 4
80714: PUSH
80715: LD_VAR 0 7
80719: ARRAY
80720: PPUSH
80721: CALL_OW 247
80725: PUSH
80726: LD_INT 1
80728: EQUAL
80729: IFFALSE 80775
// begin to_heal := to_heal diff group [ i ] ;
80731: LD_ADDR_VAR 0 30
80735: PUSH
80736: LD_VAR 0 30
80740: PUSH
80741: LD_VAR 0 4
80745: PUSH
80746: LD_VAR 0 7
80750: ARRAY
80751: DIFF
80752: ST_TO_ADDR
// healers := healers diff group [ i ] ;
80753: LD_ADDR_VAR 0 31
80757: PUSH
80758: LD_VAR 0 31
80762: PUSH
80763: LD_VAR 0 4
80767: PUSH
80768: LD_VAR 0 7
80772: ARRAY
80773: DIFF
80774: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
80775: LD_ADDR_VAR 0 4
80779: PUSH
80780: LD_VAR 0 4
80784: PPUSH
80785: LD_VAR 0 7
80789: PPUSH
80790: CALL_OW 3
80794: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
80795: LD_ADDR_VAR 0 16
80799: PUSH
80800: LD_VAR 0 16
80804: PPUSH
80805: LD_VAR 0 7
80809: PPUSH
80810: CALL_OW 3
80814: ST_TO_ADDR
// continue ;
80815: GO 80655
// end ; if f_repair then
80817: LD_VAR 0 22
80821: IFFALSE 81310
// begin if GetType ( group [ i ] ) = unit_vehicle then
80823: LD_VAR 0 4
80827: PUSH
80828: LD_VAR 0 7
80832: ARRAY
80833: PPUSH
80834: CALL_OW 247
80838: PUSH
80839: LD_INT 2
80841: EQUAL
80842: IFFALSE 81032
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
80844: LD_VAR 0 4
80848: PUSH
80849: LD_VAR 0 7
80853: ARRAY
80854: PPUSH
80855: CALL_OW 256
80859: PUSH
80860: LD_INT 700
80862: LESS
80863: PUSH
80864: LD_VAR 0 4
80868: PUSH
80869: LD_VAR 0 7
80873: ARRAY
80874: PUSH
80875: LD_VAR 0 32
80879: IN
80880: NOT
80881: AND
80882: IFFALSE 80906
// to_repair := to_repair union group [ i ] ;
80884: LD_ADDR_VAR 0 32
80888: PUSH
80889: LD_VAR 0 32
80893: PUSH
80894: LD_VAR 0 4
80898: PUSH
80899: LD_VAR 0 7
80903: ARRAY
80904: UNION
80905: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
80906: LD_VAR 0 4
80910: PUSH
80911: LD_VAR 0 7
80915: ARRAY
80916: PPUSH
80917: CALL_OW 256
80921: PUSH
80922: LD_INT 1000
80924: EQUAL
80925: PUSH
80926: LD_VAR 0 4
80930: PUSH
80931: LD_VAR 0 7
80935: ARRAY
80936: PUSH
80937: LD_VAR 0 32
80941: IN
80942: AND
80943: IFFALSE 80967
// to_repair := to_repair diff group [ i ] ;
80945: LD_ADDR_VAR 0 32
80949: PUSH
80950: LD_VAR 0 32
80954: PUSH
80955: LD_VAR 0 4
80959: PUSH
80960: LD_VAR 0 7
80964: ARRAY
80965: DIFF
80966: ST_TO_ADDR
// if group [ i ] in to_repair then
80967: LD_VAR 0 4
80971: PUSH
80972: LD_VAR 0 7
80976: ARRAY
80977: PUSH
80978: LD_VAR 0 32
80982: IN
80983: IFFALSE 81030
// begin if not IsInArea ( group [ i ] , f_repair ) then
80985: LD_VAR 0 4
80989: PUSH
80990: LD_VAR 0 7
80994: ARRAY
80995: PPUSH
80996: LD_VAR 0 22
81000: PPUSH
81001: CALL_OW 308
81005: NOT
81006: IFFALSE 81028
// ComMoveToArea ( group [ i ] , f_repair ) ;
81008: LD_VAR 0 4
81012: PUSH
81013: LD_VAR 0 7
81017: ARRAY
81018: PPUSH
81019: LD_VAR 0 22
81023: PPUSH
81024: CALL_OW 113
// continue ;
81028: GO 80655
// end ; end else
81030: GO 81310
// if group [ i ] in repairs then
81032: LD_VAR 0 4
81036: PUSH
81037: LD_VAR 0 7
81041: ARRAY
81042: PUSH
81043: LD_VAR 0 33
81047: IN
81048: IFFALSE 81310
// begin if IsInUnit ( group [ i ] ) then
81050: LD_VAR 0 4
81054: PUSH
81055: LD_VAR 0 7
81059: ARRAY
81060: PPUSH
81061: CALL_OW 310
81065: IFFALSE 81133
// begin z := IsInUnit ( group [ i ] ) ;
81067: LD_ADDR_VAR 0 13
81071: PUSH
81072: LD_VAR 0 4
81076: PUSH
81077: LD_VAR 0 7
81081: ARRAY
81082: PPUSH
81083: CALL_OW 310
81087: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81088: LD_VAR 0 13
81092: PUSH
81093: LD_VAR 0 32
81097: IN
81098: PUSH
81099: LD_VAR 0 13
81103: PPUSH
81104: LD_VAR 0 22
81108: PPUSH
81109: CALL_OW 308
81113: AND
81114: IFFALSE 81131
// ComExitVehicle ( group [ i ] ) ;
81116: LD_VAR 0 4
81120: PUSH
81121: LD_VAR 0 7
81125: ARRAY
81126: PPUSH
81127: CALL_OW 121
// end else
81131: GO 81310
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81133: LD_ADDR_VAR 0 13
81137: PUSH
81138: LD_VAR 0 4
81142: PPUSH
81143: LD_INT 95
81145: PUSH
81146: LD_VAR 0 22
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 58
81157: PUSH
81158: EMPTY
81159: LIST
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PPUSH
81165: CALL_OW 72
81169: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81170: LD_VAR 0 4
81174: PUSH
81175: LD_VAR 0 7
81179: ARRAY
81180: PPUSH
81181: CALL_OW 314
81185: NOT
81186: IFFALSE 81308
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81188: LD_ADDR_VAR 0 10
81192: PUSH
81193: LD_VAR 0 13
81197: PPUSH
81198: LD_VAR 0 4
81202: PUSH
81203: LD_VAR 0 7
81207: ARRAY
81208: PPUSH
81209: CALL_OW 74
81213: ST_TO_ADDR
// if not x then
81214: LD_VAR 0 10
81218: NOT
81219: IFFALSE 81223
// continue ;
81221: GO 80655
// if GetLives ( x ) < 1000 then
81223: LD_VAR 0 10
81227: PPUSH
81228: CALL_OW 256
81232: PUSH
81233: LD_INT 1000
81235: LESS
81236: IFFALSE 81260
// ComRepairVehicle ( group [ i ] , x ) else
81238: LD_VAR 0 4
81242: PUSH
81243: LD_VAR 0 7
81247: ARRAY
81248: PPUSH
81249: LD_VAR 0 10
81253: PPUSH
81254: CALL_OW 129
81258: GO 81308
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81260: LD_VAR 0 23
81264: PUSH
81265: LD_VAR 0 4
81269: PUSH
81270: LD_VAR 0 7
81274: ARRAY
81275: PPUSH
81276: CALL_OW 256
81280: PUSH
81281: LD_INT 1000
81283: LESS
81284: AND
81285: NOT
81286: IFFALSE 81308
// ComEnterUnit ( group [ i ] , x ) ;
81288: LD_VAR 0 4
81292: PUSH
81293: LD_VAR 0 7
81297: ARRAY
81298: PPUSH
81299: LD_VAR 0 10
81303: PPUSH
81304: CALL_OW 120
// end ; continue ;
81308: GO 80655
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81310: LD_VAR 0 23
81314: PUSH
81315: LD_VAR 0 4
81319: PUSH
81320: LD_VAR 0 7
81324: ARRAY
81325: PPUSH
81326: CALL_OW 247
81330: PUSH
81331: LD_INT 1
81333: EQUAL
81334: AND
81335: IFFALSE 81813
// begin if group [ i ] in healers then
81337: LD_VAR 0 4
81341: PUSH
81342: LD_VAR 0 7
81346: ARRAY
81347: PUSH
81348: LD_VAR 0 31
81352: IN
81353: IFFALSE 81626
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81355: LD_VAR 0 4
81359: PUSH
81360: LD_VAR 0 7
81364: ARRAY
81365: PPUSH
81366: LD_VAR 0 23
81370: PPUSH
81371: CALL_OW 308
81375: NOT
81376: PUSH
81377: LD_VAR 0 4
81381: PUSH
81382: LD_VAR 0 7
81386: ARRAY
81387: PPUSH
81388: CALL_OW 314
81392: NOT
81393: AND
81394: IFFALSE 81418
// ComMoveToArea ( group [ i ] , f_heal ) else
81396: LD_VAR 0 4
81400: PUSH
81401: LD_VAR 0 7
81405: ARRAY
81406: PPUSH
81407: LD_VAR 0 23
81411: PPUSH
81412: CALL_OW 113
81416: GO 81624
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
81418: LD_VAR 0 4
81422: PUSH
81423: LD_VAR 0 7
81427: ARRAY
81428: PPUSH
81429: CALL 80056 0 1
81433: PPUSH
81434: CALL_OW 256
81438: PUSH
81439: LD_INT 1000
81441: EQUAL
81442: IFFALSE 81461
// ComStop ( group [ i ] ) else
81444: LD_VAR 0 4
81448: PUSH
81449: LD_VAR 0 7
81453: ARRAY
81454: PPUSH
81455: CALL_OW 141
81459: GO 81624
// if not HasTask ( group [ i ] ) and to_heal then
81461: LD_VAR 0 4
81465: PUSH
81466: LD_VAR 0 7
81470: ARRAY
81471: PPUSH
81472: CALL_OW 314
81476: NOT
81477: PUSH
81478: LD_VAR 0 30
81482: AND
81483: IFFALSE 81624
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
81485: LD_ADDR_VAR 0 13
81489: PUSH
81490: LD_VAR 0 30
81494: PPUSH
81495: LD_INT 3
81497: PUSH
81498: LD_INT 54
81500: PUSH
81501: EMPTY
81502: LIST
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PPUSH
81508: CALL_OW 72
81512: PPUSH
81513: LD_VAR 0 4
81517: PUSH
81518: LD_VAR 0 7
81522: ARRAY
81523: PPUSH
81524: CALL_OW 74
81528: ST_TO_ADDR
// if z then
81529: LD_VAR 0 13
81533: IFFALSE 81624
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
81535: LD_INT 91
81537: PUSH
81538: LD_VAR 0 13
81542: PUSH
81543: LD_INT 10
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 81
81553: PUSH
81554: LD_VAR 0 13
81558: PPUSH
81559: CALL_OW 255
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PPUSH
81572: CALL_OW 69
81576: PUSH
81577: LD_INT 0
81579: EQUAL
81580: IFFALSE 81604
// ComHeal ( group [ i ] , z ) else
81582: LD_VAR 0 4
81586: PUSH
81587: LD_VAR 0 7
81591: ARRAY
81592: PPUSH
81593: LD_VAR 0 13
81597: PPUSH
81598: CALL_OW 128
81602: GO 81624
// ComMoveToArea ( group [ i ] , f_heal ) ;
81604: LD_VAR 0 4
81608: PUSH
81609: LD_VAR 0 7
81613: ARRAY
81614: PPUSH
81615: LD_VAR 0 23
81619: PPUSH
81620: CALL_OW 113
// end ; continue ;
81624: GO 80655
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
81626: LD_VAR 0 4
81630: PUSH
81631: LD_VAR 0 7
81635: ARRAY
81636: PPUSH
81637: CALL_OW 256
81641: PUSH
81642: LD_INT 700
81644: LESS
81645: PUSH
81646: LD_VAR 0 4
81650: PUSH
81651: LD_VAR 0 7
81655: ARRAY
81656: PUSH
81657: LD_VAR 0 30
81661: IN
81662: NOT
81663: AND
81664: IFFALSE 81688
// to_heal := to_heal union group [ i ] ;
81666: LD_ADDR_VAR 0 30
81670: PUSH
81671: LD_VAR 0 30
81675: PUSH
81676: LD_VAR 0 4
81680: PUSH
81681: LD_VAR 0 7
81685: ARRAY
81686: UNION
81687: ST_TO_ADDR
// if group [ i ] in to_heal then
81688: LD_VAR 0 4
81692: PUSH
81693: LD_VAR 0 7
81697: ARRAY
81698: PUSH
81699: LD_VAR 0 30
81703: IN
81704: IFFALSE 81813
// begin if GetLives ( group [ i ] ) = 1000 then
81706: LD_VAR 0 4
81710: PUSH
81711: LD_VAR 0 7
81715: ARRAY
81716: PPUSH
81717: CALL_OW 256
81721: PUSH
81722: LD_INT 1000
81724: EQUAL
81725: IFFALSE 81751
// to_heal := to_heal diff group [ i ] else
81727: LD_ADDR_VAR 0 30
81731: PUSH
81732: LD_VAR 0 30
81736: PUSH
81737: LD_VAR 0 4
81741: PUSH
81742: LD_VAR 0 7
81746: ARRAY
81747: DIFF
81748: ST_TO_ADDR
81749: GO 81813
// begin if not IsInArea ( group [ i ] , to_heal ) then
81751: LD_VAR 0 4
81755: PUSH
81756: LD_VAR 0 7
81760: ARRAY
81761: PPUSH
81762: LD_VAR 0 30
81766: PPUSH
81767: CALL_OW 308
81771: NOT
81772: IFFALSE 81796
// ComMoveToArea ( group [ i ] , f_heal ) else
81774: LD_VAR 0 4
81778: PUSH
81779: LD_VAR 0 7
81783: ARRAY
81784: PPUSH
81785: LD_VAR 0 23
81789: PPUSH
81790: CALL_OW 113
81794: GO 81811
// ComHold ( group [ i ] ) ;
81796: LD_VAR 0 4
81800: PUSH
81801: LD_VAR 0 7
81805: ARRAY
81806: PPUSH
81807: CALL_OW 140
// continue ;
81811: GO 80655
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
81813: LD_VAR 0 4
81817: PUSH
81818: LD_VAR 0 7
81822: ARRAY
81823: PPUSH
81824: LD_INT 10
81826: PPUSH
81827: CALL 78453 0 2
81831: NOT
81832: PUSH
81833: LD_VAR 0 16
81837: PUSH
81838: LD_VAR 0 7
81842: ARRAY
81843: PUSH
81844: EMPTY
81845: EQUAL
81846: NOT
81847: AND
81848: IFFALSE 82114
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
81850: LD_VAR 0 4
81854: PUSH
81855: LD_VAR 0 7
81859: ARRAY
81860: PPUSH
81861: CALL_OW 262
81865: PUSH
81866: LD_INT 1
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: IN
81876: IFFALSE 81917
// if GetFuel ( group [ i ] ) < 10 then
81878: LD_VAR 0 4
81882: PUSH
81883: LD_VAR 0 7
81887: ARRAY
81888: PPUSH
81889: CALL_OW 261
81893: PUSH
81894: LD_INT 10
81896: LESS
81897: IFFALSE 81917
// SetFuel ( group [ i ] , 12 ) ;
81899: LD_VAR 0 4
81903: PUSH
81904: LD_VAR 0 7
81908: ARRAY
81909: PPUSH
81910: LD_INT 12
81912: PPUSH
81913: CALL_OW 240
// if units_path [ i ] then
81917: LD_VAR 0 16
81921: PUSH
81922: LD_VAR 0 7
81926: ARRAY
81927: IFFALSE 82112
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
81929: LD_VAR 0 4
81933: PUSH
81934: LD_VAR 0 7
81938: ARRAY
81939: PPUSH
81940: LD_VAR 0 16
81944: PUSH
81945: LD_VAR 0 7
81949: ARRAY
81950: PUSH
81951: LD_INT 1
81953: ARRAY
81954: PUSH
81955: LD_INT 1
81957: ARRAY
81958: PPUSH
81959: LD_VAR 0 16
81963: PUSH
81964: LD_VAR 0 7
81968: ARRAY
81969: PUSH
81970: LD_INT 1
81972: ARRAY
81973: PUSH
81974: LD_INT 2
81976: ARRAY
81977: PPUSH
81978: CALL_OW 297
81982: PUSH
81983: LD_INT 6
81985: GREATER
81986: IFFALSE 82061
// begin if not HasTask ( group [ i ] ) then
81988: LD_VAR 0 4
81992: PUSH
81993: LD_VAR 0 7
81997: ARRAY
81998: PPUSH
81999: CALL_OW 314
82003: NOT
82004: IFFALSE 82059
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82006: LD_VAR 0 4
82010: PUSH
82011: LD_VAR 0 7
82015: ARRAY
82016: PPUSH
82017: LD_VAR 0 16
82021: PUSH
82022: LD_VAR 0 7
82026: ARRAY
82027: PUSH
82028: LD_INT 1
82030: ARRAY
82031: PUSH
82032: LD_INT 1
82034: ARRAY
82035: PPUSH
82036: LD_VAR 0 16
82040: PUSH
82041: LD_VAR 0 7
82045: ARRAY
82046: PUSH
82047: LD_INT 1
82049: ARRAY
82050: PUSH
82051: LD_INT 2
82053: ARRAY
82054: PPUSH
82055: CALL_OW 114
// end else
82059: GO 82112
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82061: LD_ADDR_VAR 0 15
82065: PUSH
82066: LD_VAR 0 16
82070: PUSH
82071: LD_VAR 0 7
82075: ARRAY
82076: PPUSH
82077: LD_INT 1
82079: PPUSH
82080: CALL_OW 3
82084: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82085: LD_ADDR_VAR 0 16
82089: PUSH
82090: LD_VAR 0 16
82094: PPUSH
82095: LD_VAR 0 7
82099: PPUSH
82100: LD_VAR 0 15
82104: PPUSH
82105: CALL_OW 1
82109: ST_TO_ADDR
// continue ;
82110: GO 80655
// end ; end ; end else
82112: GO 84750
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82114: LD_ADDR_VAR 0 14
82118: PUSH
82119: LD_INT 81
82121: PUSH
82122: LD_VAR 0 4
82126: PUSH
82127: LD_VAR 0 7
82131: ARRAY
82132: PPUSH
82133: CALL_OW 255
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PPUSH
82142: CALL_OW 69
82146: ST_TO_ADDR
// if not tmp then
82147: LD_VAR 0 14
82151: NOT
82152: IFFALSE 82156
// continue ;
82154: GO 80655
// if f_ignore_area then
82156: LD_VAR 0 17
82160: IFFALSE 82248
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82162: LD_ADDR_VAR 0 15
82166: PUSH
82167: LD_VAR 0 14
82171: PPUSH
82172: LD_INT 3
82174: PUSH
82175: LD_INT 92
82177: PUSH
82178: LD_VAR 0 17
82182: PUSH
82183: LD_INT 1
82185: ARRAY
82186: PUSH
82187: LD_VAR 0 17
82191: PUSH
82192: LD_INT 2
82194: ARRAY
82195: PUSH
82196: LD_VAR 0 17
82200: PUSH
82201: LD_INT 3
82203: ARRAY
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PPUSH
82215: CALL_OW 72
82219: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82220: LD_VAR 0 14
82224: PUSH
82225: LD_VAR 0 15
82229: DIFF
82230: IFFALSE 82248
// tmp := tmp diff tmp2 ;
82232: LD_ADDR_VAR 0 14
82236: PUSH
82237: LD_VAR 0 14
82241: PUSH
82242: LD_VAR 0 15
82246: DIFF
82247: ST_TO_ADDR
// end ; if not f_murder then
82248: LD_VAR 0 20
82252: NOT
82253: IFFALSE 82311
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82255: LD_ADDR_VAR 0 15
82259: PUSH
82260: LD_VAR 0 14
82264: PPUSH
82265: LD_INT 3
82267: PUSH
82268: LD_INT 50
82270: PUSH
82271: EMPTY
82272: LIST
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PPUSH
82278: CALL_OW 72
82282: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82283: LD_VAR 0 14
82287: PUSH
82288: LD_VAR 0 15
82292: DIFF
82293: IFFALSE 82311
// tmp := tmp diff tmp2 ;
82295: LD_ADDR_VAR 0 14
82299: PUSH
82300: LD_VAR 0 14
82304: PUSH
82305: LD_VAR 0 15
82309: DIFF
82310: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82311: LD_ADDR_VAR 0 14
82315: PUSH
82316: LD_VAR 0 4
82320: PUSH
82321: LD_VAR 0 7
82325: ARRAY
82326: PPUSH
82327: LD_VAR 0 14
82331: PPUSH
82332: LD_INT 1
82334: PPUSH
82335: LD_INT 1
82337: PPUSH
82338: CALL 52120 0 4
82342: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82343: LD_VAR 0 4
82347: PUSH
82348: LD_VAR 0 7
82352: ARRAY
82353: PPUSH
82354: CALL_OW 257
82358: PUSH
82359: LD_INT 1
82361: EQUAL
82362: IFFALSE 82810
// begin if WantPlant ( group [ i ] ) then
82364: LD_VAR 0 4
82368: PUSH
82369: LD_VAR 0 7
82373: ARRAY
82374: PPUSH
82375: CALL 51621 0 1
82379: IFFALSE 82383
// continue ;
82381: GO 80655
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
82383: LD_VAR 0 18
82387: PUSH
82388: LD_VAR 0 4
82392: PUSH
82393: LD_VAR 0 7
82397: ARRAY
82398: PPUSH
82399: CALL_OW 310
82403: NOT
82404: AND
82405: PUSH
82406: LD_VAR 0 14
82410: PUSH
82411: LD_INT 1
82413: ARRAY
82414: PUSH
82415: LD_VAR 0 14
82419: PPUSH
82420: LD_INT 21
82422: PUSH
82423: LD_INT 2
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 58
82432: PUSH
82433: EMPTY
82434: LIST
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PPUSH
82440: CALL_OW 72
82444: IN
82445: AND
82446: IFFALSE 82482
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
82448: LD_VAR 0 4
82452: PUSH
82453: LD_VAR 0 7
82457: ARRAY
82458: PPUSH
82459: LD_VAR 0 14
82463: PUSH
82464: LD_INT 1
82466: ARRAY
82467: PPUSH
82468: CALL_OW 120
// attacking := true ;
82472: LD_ADDR_VAR 0 29
82476: PUSH
82477: LD_INT 1
82479: ST_TO_ADDR
// continue ;
82480: GO 80655
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
82482: LD_VAR 0 26
82486: PUSH
82487: LD_VAR 0 4
82491: PUSH
82492: LD_VAR 0 7
82496: ARRAY
82497: PPUSH
82498: CALL_OW 257
82502: PUSH
82503: LD_INT 1
82505: EQUAL
82506: AND
82507: PUSH
82508: LD_VAR 0 4
82512: PUSH
82513: LD_VAR 0 7
82517: ARRAY
82518: PPUSH
82519: CALL_OW 256
82523: PUSH
82524: LD_INT 800
82526: LESS
82527: AND
82528: PUSH
82529: LD_VAR 0 4
82533: PUSH
82534: LD_VAR 0 7
82538: ARRAY
82539: PPUSH
82540: CALL_OW 318
82544: NOT
82545: AND
82546: IFFALSE 82563
// ComCrawl ( group [ i ] ) ;
82548: LD_VAR 0 4
82552: PUSH
82553: LD_VAR 0 7
82557: ARRAY
82558: PPUSH
82559: CALL_OW 137
// if f_mines then
82563: LD_VAR 0 21
82567: IFFALSE 82810
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
82569: LD_VAR 0 14
82573: PUSH
82574: LD_INT 1
82576: ARRAY
82577: PPUSH
82578: CALL_OW 247
82582: PUSH
82583: LD_INT 3
82585: EQUAL
82586: PUSH
82587: LD_VAR 0 14
82591: PUSH
82592: LD_INT 1
82594: ARRAY
82595: PUSH
82596: LD_VAR 0 27
82600: IN
82601: NOT
82602: AND
82603: IFFALSE 82810
// begin x := GetX ( tmp [ 1 ] ) ;
82605: LD_ADDR_VAR 0 10
82609: PUSH
82610: LD_VAR 0 14
82614: PUSH
82615: LD_INT 1
82617: ARRAY
82618: PPUSH
82619: CALL_OW 250
82623: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
82624: LD_ADDR_VAR 0 11
82628: PUSH
82629: LD_VAR 0 14
82633: PUSH
82634: LD_INT 1
82636: ARRAY
82637: PPUSH
82638: CALL_OW 251
82642: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
82643: LD_ADDR_VAR 0 12
82647: PUSH
82648: LD_VAR 0 4
82652: PUSH
82653: LD_VAR 0 7
82657: ARRAY
82658: PPUSH
82659: CALL 78538 0 1
82663: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
82664: LD_VAR 0 4
82668: PUSH
82669: LD_VAR 0 7
82673: ARRAY
82674: PPUSH
82675: LD_VAR 0 10
82679: PPUSH
82680: LD_VAR 0 11
82684: PPUSH
82685: LD_VAR 0 14
82689: PUSH
82690: LD_INT 1
82692: ARRAY
82693: PPUSH
82694: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
82698: LD_VAR 0 4
82702: PUSH
82703: LD_VAR 0 7
82707: ARRAY
82708: PPUSH
82709: LD_VAR 0 10
82713: PPUSH
82714: LD_VAR 0 12
82718: PPUSH
82719: LD_INT 7
82721: PPUSH
82722: CALL_OW 272
82726: PPUSH
82727: LD_VAR 0 11
82731: PPUSH
82732: LD_VAR 0 12
82736: PPUSH
82737: LD_INT 7
82739: PPUSH
82740: CALL_OW 273
82744: PPUSH
82745: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
82749: LD_VAR 0 4
82753: PUSH
82754: LD_VAR 0 7
82758: ARRAY
82759: PPUSH
82760: LD_INT 71
82762: PPUSH
82763: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
82767: LD_ADDR_VAR 0 27
82771: PUSH
82772: LD_VAR 0 27
82776: PPUSH
82777: LD_VAR 0 27
82781: PUSH
82782: LD_INT 1
82784: PLUS
82785: PPUSH
82786: LD_VAR 0 14
82790: PUSH
82791: LD_INT 1
82793: ARRAY
82794: PPUSH
82795: CALL_OW 1
82799: ST_TO_ADDR
// attacking := true ;
82800: LD_ADDR_VAR 0 29
82804: PUSH
82805: LD_INT 1
82807: ST_TO_ADDR
// continue ;
82808: GO 80655
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
82810: LD_VAR 0 4
82814: PUSH
82815: LD_VAR 0 7
82819: ARRAY
82820: PPUSH
82821: CALL_OW 257
82825: PUSH
82826: LD_INT 17
82828: EQUAL
82829: PUSH
82830: LD_VAR 0 4
82834: PUSH
82835: LD_VAR 0 7
82839: ARRAY
82840: PPUSH
82841: CALL_OW 110
82845: PUSH
82846: LD_INT 71
82848: EQUAL
82849: NOT
82850: AND
82851: IFFALSE 82997
// begin attacking := false ;
82853: LD_ADDR_VAR 0 29
82857: PUSH
82858: LD_INT 0
82860: ST_TO_ADDR
// k := 5 ;
82861: LD_ADDR_VAR 0 9
82865: PUSH
82866: LD_INT 5
82868: ST_TO_ADDR
// if tmp < k then
82869: LD_VAR 0 14
82873: PUSH
82874: LD_VAR 0 9
82878: LESS
82879: IFFALSE 82891
// k := tmp ;
82881: LD_ADDR_VAR 0 9
82885: PUSH
82886: LD_VAR 0 14
82890: ST_TO_ADDR
// for j = 1 to k do
82891: LD_ADDR_VAR 0 8
82895: PUSH
82896: DOUBLE
82897: LD_INT 1
82899: DEC
82900: ST_TO_ADDR
82901: LD_VAR 0 9
82905: PUSH
82906: FOR_TO
82907: IFFALSE 82995
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
82909: LD_VAR 0 14
82913: PUSH
82914: LD_VAR 0 8
82918: ARRAY
82919: PUSH
82920: LD_VAR 0 14
82924: PPUSH
82925: LD_INT 58
82927: PUSH
82928: EMPTY
82929: LIST
82930: PPUSH
82931: CALL_OW 72
82935: IN
82936: NOT
82937: IFFALSE 82993
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82939: LD_VAR 0 4
82943: PUSH
82944: LD_VAR 0 7
82948: ARRAY
82949: PPUSH
82950: LD_VAR 0 14
82954: PUSH
82955: LD_VAR 0 8
82959: ARRAY
82960: PPUSH
82961: CALL_OW 115
// attacking := true ;
82965: LD_ADDR_VAR 0 29
82969: PUSH
82970: LD_INT 1
82972: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
82973: LD_VAR 0 4
82977: PUSH
82978: LD_VAR 0 7
82982: ARRAY
82983: PPUSH
82984: LD_INT 71
82986: PPUSH
82987: CALL_OW 109
// continue ;
82991: GO 82906
// end ; end ;
82993: GO 82906
82995: POP
82996: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
82997: LD_VAR 0 4
83001: PUSH
83002: LD_VAR 0 7
83006: ARRAY
83007: PPUSH
83008: CALL_OW 257
83012: PUSH
83013: LD_INT 8
83015: EQUAL
83016: PUSH
83017: LD_VAR 0 4
83021: PUSH
83022: LD_VAR 0 7
83026: ARRAY
83027: PPUSH
83028: CALL_OW 264
83032: PUSH
83033: LD_INT 28
83035: PUSH
83036: LD_INT 45
83038: PUSH
83039: LD_INT 7
83041: PUSH
83042: LD_INT 47
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: IN
83051: OR
83052: IFFALSE 83282
// begin attacking := false ;
83054: LD_ADDR_VAR 0 29
83058: PUSH
83059: LD_INT 0
83061: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83062: LD_VAR 0 14
83066: PUSH
83067: LD_INT 1
83069: ARRAY
83070: PPUSH
83071: CALL_OW 266
83075: PUSH
83076: LD_INT 32
83078: PUSH
83079: LD_INT 31
83081: PUSH
83082: LD_INT 33
83084: PUSH
83085: LD_INT 4
83087: PUSH
83088: LD_INT 5
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: IN
83098: IFFALSE 83282
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83100: LD_ADDR_VAR 0 9
83104: PUSH
83105: LD_VAR 0 14
83109: PUSH
83110: LD_INT 1
83112: ARRAY
83113: PPUSH
83114: CALL_OW 266
83118: PPUSH
83119: LD_VAR 0 14
83123: PUSH
83124: LD_INT 1
83126: ARRAY
83127: PPUSH
83128: CALL_OW 250
83132: PPUSH
83133: LD_VAR 0 14
83137: PUSH
83138: LD_INT 1
83140: ARRAY
83141: PPUSH
83142: CALL_OW 251
83146: PPUSH
83147: LD_VAR 0 14
83151: PUSH
83152: LD_INT 1
83154: ARRAY
83155: PPUSH
83156: CALL_OW 254
83160: PPUSH
83161: LD_VAR 0 14
83165: PUSH
83166: LD_INT 1
83168: ARRAY
83169: PPUSH
83170: CALL_OW 248
83174: PPUSH
83175: LD_INT 0
83177: PPUSH
83178: CALL 59914 0 6
83182: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83183: LD_ADDR_VAR 0 8
83187: PUSH
83188: LD_VAR 0 4
83192: PUSH
83193: LD_VAR 0 7
83197: ARRAY
83198: PPUSH
83199: LD_VAR 0 9
83203: PPUSH
83204: CALL 78601 0 2
83208: ST_TO_ADDR
// if j then
83209: LD_VAR 0 8
83213: IFFALSE 83282
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83215: LD_VAR 0 8
83219: PUSH
83220: LD_INT 1
83222: ARRAY
83223: PPUSH
83224: LD_VAR 0 8
83228: PUSH
83229: LD_INT 2
83231: ARRAY
83232: PPUSH
83233: CALL_OW 488
83237: IFFALSE 83282
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83239: LD_VAR 0 4
83243: PUSH
83244: LD_VAR 0 7
83248: ARRAY
83249: PPUSH
83250: LD_VAR 0 8
83254: PUSH
83255: LD_INT 1
83257: ARRAY
83258: PPUSH
83259: LD_VAR 0 8
83263: PUSH
83264: LD_INT 2
83266: ARRAY
83267: PPUSH
83268: CALL_OW 116
// attacking := true ;
83272: LD_ADDR_VAR 0 29
83276: PUSH
83277: LD_INT 1
83279: ST_TO_ADDR
// continue ;
83280: GO 80655
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83282: LD_VAR 0 4
83286: PUSH
83287: LD_VAR 0 7
83291: ARRAY
83292: PPUSH
83293: CALL_OW 265
83297: PUSH
83298: LD_INT 11
83300: EQUAL
83301: IFFALSE 83579
// begin k := 10 ;
83303: LD_ADDR_VAR 0 9
83307: PUSH
83308: LD_INT 10
83310: ST_TO_ADDR
// x := 0 ;
83311: LD_ADDR_VAR 0 10
83315: PUSH
83316: LD_INT 0
83318: ST_TO_ADDR
// if tmp < k then
83319: LD_VAR 0 14
83323: PUSH
83324: LD_VAR 0 9
83328: LESS
83329: IFFALSE 83341
// k := tmp ;
83331: LD_ADDR_VAR 0 9
83335: PUSH
83336: LD_VAR 0 14
83340: ST_TO_ADDR
// for j = k downto 1 do
83341: LD_ADDR_VAR 0 8
83345: PUSH
83346: DOUBLE
83347: LD_VAR 0 9
83351: INC
83352: ST_TO_ADDR
83353: LD_INT 1
83355: PUSH
83356: FOR_DOWNTO
83357: IFFALSE 83432
// begin if GetType ( tmp [ j ] ) = unit_human then
83359: LD_VAR 0 14
83363: PUSH
83364: LD_VAR 0 8
83368: ARRAY
83369: PPUSH
83370: CALL_OW 247
83374: PUSH
83375: LD_INT 1
83377: EQUAL
83378: IFFALSE 83430
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
83380: LD_VAR 0 4
83384: PUSH
83385: LD_VAR 0 7
83389: ARRAY
83390: PPUSH
83391: LD_VAR 0 14
83395: PUSH
83396: LD_VAR 0 8
83400: ARRAY
83401: PPUSH
83402: CALL 78872 0 2
// x := tmp [ j ] ;
83406: LD_ADDR_VAR 0 10
83410: PUSH
83411: LD_VAR 0 14
83415: PUSH
83416: LD_VAR 0 8
83420: ARRAY
83421: ST_TO_ADDR
// attacking := true ;
83422: LD_ADDR_VAR 0 29
83426: PUSH
83427: LD_INT 1
83429: ST_TO_ADDR
// end ; end ;
83430: GO 83356
83432: POP
83433: POP
// if not x then
83434: LD_VAR 0 10
83438: NOT
83439: IFFALSE 83579
// begin attacking := true ;
83441: LD_ADDR_VAR 0 29
83445: PUSH
83446: LD_INT 1
83448: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
83449: LD_VAR 0 4
83453: PUSH
83454: LD_VAR 0 7
83458: ARRAY
83459: PPUSH
83460: CALL_OW 250
83464: PPUSH
83465: LD_VAR 0 4
83469: PUSH
83470: LD_VAR 0 7
83474: ARRAY
83475: PPUSH
83476: CALL_OW 251
83480: PPUSH
83481: CALL_OW 546
83485: PUSH
83486: LD_INT 2
83488: ARRAY
83489: PUSH
83490: LD_VAR 0 14
83494: PUSH
83495: LD_INT 1
83497: ARRAY
83498: PPUSH
83499: CALL_OW 250
83503: PPUSH
83504: LD_VAR 0 14
83508: PUSH
83509: LD_INT 1
83511: ARRAY
83512: PPUSH
83513: CALL_OW 251
83517: PPUSH
83518: CALL_OW 546
83522: PUSH
83523: LD_INT 2
83525: ARRAY
83526: EQUAL
83527: IFFALSE 83555
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
83529: LD_VAR 0 4
83533: PUSH
83534: LD_VAR 0 7
83538: ARRAY
83539: PPUSH
83540: LD_VAR 0 14
83544: PUSH
83545: LD_INT 1
83547: ARRAY
83548: PPUSH
83549: CALL 78872 0 2
83553: GO 83579
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83555: LD_VAR 0 4
83559: PUSH
83560: LD_VAR 0 7
83564: ARRAY
83565: PPUSH
83566: LD_VAR 0 14
83570: PUSH
83571: LD_INT 1
83573: ARRAY
83574: PPUSH
83575: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
83579: LD_VAR 0 4
83583: PUSH
83584: LD_VAR 0 7
83588: ARRAY
83589: PPUSH
83590: CALL_OW 264
83594: PUSH
83595: LD_INT 29
83597: EQUAL
83598: IFFALSE 83964
// begin if WantsToAttack ( group [ i ] ) in bombed then
83600: LD_VAR 0 4
83604: PUSH
83605: LD_VAR 0 7
83609: ARRAY
83610: PPUSH
83611: CALL_OW 319
83615: PUSH
83616: LD_VAR 0 28
83620: IN
83621: IFFALSE 83625
// continue ;
83623: GO 80655
// k := 8 ;
83625: LD_ADDR_VAR 0 9
83629: PUSH
83630: LD_INT 8
83632: ST_TO_ADDR
// x := 0 ;
83633: LD_ADDR_VAR 0 10
83637: PUSH
83638: LD_INT 0
83640: ST_TO_ADDR
// if tmp < k then
83641: LD_VAR 0 14
83645: PUSH
83646: LD_VAR 0 9
83650: LESS
83651: IFFALSE 83663
// k := tmp ;
83653: LD_ADDR_VAR 0 9
83657: PUSH
83658: LD_VAR 0 14
83662: ST_TO_ADDR
// for j = 1 to k do
83663: LD_ADDR_VAR 0 8
83667: PUSH
83668: DOUBLE
83669: LD_INT 1
83671: DEC
83672: ST_TO_ADDR
83673: LD_VAR 0 9
83677: PUSH
83678: FOR_TO
83679: IFFALSE 83811
// begin if GetType ( tmp [ j ] ) = unit_building then
83681: LD_VAR 0 14
83685: PUSH
83686: LD_VAR 0 8
83690: ARRAY
83691: PPUSH
83692: CALL_OW 247
83696: PUSH
83697: LD_INT 3
83699: EQUAL
83700: IFFALSE 83809
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
83702: LD_VAR 0 14
83706: PUSH
83707: LD_VAR 0 8
83711: ARRAY
83712: PUSH
83713: LD_VAR 0 28
83717: IN
83718: NOT
83719: PUSH
83720: LD_VAR 0 14
83724: PUSH
83725: LD_VAR 0 8
83729: ARRAY
83730: PPUSH
83731: CALL_OW 313
83735: AND
83736: IFFALSE 83809
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83738: LD_VAR 0 4
83742: PUSH
83743: LD_VAR 0 7
83747: ARRAY
83748: PPUSH
83749: LD_VAR 0 14
83753: PUSH
83754: LD_VAR 0 8
83758: ARRAY
83759: PPUSH
83760: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
83764: LD_ADDR_VAR 0 28
83768: PUSH
83769: LD_VAR 0 28
83773: PPUSH
83774: LD_VAR 0 28
83778: PUSH
83779: LD_INT 1
83781: PLUS
83782: PPUSH
83783: LD_VAR 0 14
83787: PUSH
83788: LD_VAR 0 8
83792: ARRAY
83793: PPUSH
83794: CALL_OW 1
83798: ST_TO_ADDR
// attacking := true ;
83799: LD_ADDR_VAR 0 29
83803: PUSH
83804: LD_INT 1
83806: ST_TO_ADDR
// break ;
83807: GO 83811
// end ; end ;
83809: GO 83678
83811: POP
83812: POP
// if not attacking and f_attack_depot then
83813: LD_VAR 0 29
83817: NOT
83818: PUSH
83819: LD_VAR 0 25
83823: AND
83824: IFFALSE 83919
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83826: LD_ADDR_VAR 0 13
83830: PUSH
83831: LD_VAR 0 14
83835: PPUSH
83836: LD_INT 2
83838: PUSH
83839: LD_INT 30
83841: PUSH
83842: LD_INT 0
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: PUSH
83849: LD_INT 30
83851: PUSH
83852: LD_INT 1
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: LIST
83863: PPUSH
83864: CALL_OW 72
83868: ST_TO_ADDR
// if z then
83869: LD_VAR 0 13
83873: IFFALSE 83919
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
83875: LD_VAR 0 4
83879: PUSH
83880: LD_VAR 0 7
83884: ARRAY
83885: PPUSH
83886: LD_VAR 0 13
83890: PPUSH
83891: LD_VAR 0 4
83895: PUSH
83896: LD_VAR 0 7
83900: ARRAY
83901: PPUSH
83902: CALL_OW 74
83906: PPUSH
83907: CALL_OW 115
// attacking := true ;
83911: LD_ADDR_VAR 0 29
83915: PUSH
83916: LD_INT 1
83918: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
83919: LD_VAR 0 4
83923: PUSH
83924: LD_VAR 0 7
83928: ARRAY
83929: PPUSH
83930: CALL_OW 256
83934: PUSH
83935: LD_INT 500
83937: LESS
83938: IFFALSE 83964
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83940: LD_VAR 0 4
83944: PUSH
83945: LD_VAR 0 7
83949: ARRAY
83950: PPUSH
83951: LD_VAR 0 14
83955: PUSH
83956: LD_INT 1
83958: ARRAY
83959: PPUSH
83960: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
83964: LD_VAR 0 4
83968: PUSH
83969: LD_VAR 0 7
83973: ARRAY
83974: PPUSH
83975: CALL_OW 264
83979: PUSH
83980: LD_INT 49
83982: EQUAL
83983: IFFALSE 84104
// begin if not HasTask ( group [ i ] ) then
83985: LD_VAR 0 4
83989: PUSH
83990: LD_VAR 0 7
83994: ARRAY
83995: PPUSH
83996: CALL_OW 314
84000: NOT
84001: IFFALSE 84104
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84003: LD_ADDR_VAR 0 9
84007: PUSH
84008: LD_INT 81
84010: PUSH
84011: LD_VAR 0 4
84015: PUSH
84016: LD_VAR 0 7
84020: ARRAY
84021: PPUSH
84022: CALL_OW 255
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PPUSH
84031: CALL_OW 69
84035: PPUSH
84036: LD_VAR 0 4
84040: PUSH
84041: LD_VAR 0 7
84045: ARRAY
84046: PPUSH
84047: CALL_OW 74
84051: ST_TO_ADDR
// if k then
84052: LD_VAR 0 9
84056: IFFALSE 84104
// if GetDistUnits ( group [ i ] , k ) > 10 then
84058: LD_VAR 0 4
84062: PUSH
84063: LD_VAR 0 7
84067: ARRAY
84068: PPUSH
84069: LD_VAR 0 9
84073: PPUSH
84074: CALL_OW 296
84078: PUSH
84079: LD_INT 10
84081: GREATER
84082: IFFALSE 84104
// ComMoveUnit ( group [ i ] , k ) ;
84084: LD_VAR 0 4
84088: PUSH
84089: LD_VAR 0 7
84093: ARRAY
84094: PPUSH
84095: LD_VAR 0 9
84099: PPUSH
84100: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84104: LD_VAR 0 4
84108: PUSH
84109: LD_VAR 0 7
84113: ARRAY
84114: PPUSH
84115: CALL_OW 256
84119: PUSH
84120: LD_INT 250
84122: LESS
84123: PUSH
84124: LD_VAR 0 4
84128: PUSH
84129: LD_VAR 0 7
84133: ARRAY
84134: PUSH
84135: LD_INT 21
84137: PUSH
84138: LD_INT 2
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 23
84147: PUSH
84148: LD_INT 2
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PPUSH
84159: CALL_OW 69
84163: IN
84164: AND
84165: IFFALSE 84290
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84167: LD_ADDR_VAR 0 9
84171: PUSH
84172: LD_OWVAR 3
84176: PUSH
84177: LD_VAR 0 4
84181: PUSH
84182: LD_VAR 0 7
84186: ARRAY
84187: DIFF
84188: PPUSH
84189: LD_VAR 0 4
84193: PUSH
84194: LD_VAR 0 7
84198: ARRAY
84199: PPUSH
84200: CALL_OW 74
84204: ST_TO_ADDR
// if not k then
84205: LD_VAR 0 9
84209: NOT
84210: IFFALSE 84214
// continue ;
84212: GO 80655
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84214: LD_VAR 0 9
84218: PUSH
84219: LD_INT 81
84221: PUSH
84222: LD_VAR 0 4
84226: PUSH
84227: LD_VAR 0 7
84231: ARRAY
84232: PPUSH
84233: CALL_OW 255
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PPUSH
84242: CALL_OW 69
84246: IN
84247: PUSH
84248: LD_VAR 0 9
84252: PPUSH
84253: LD_VAR 0 4
84257: PUSH
84258: LD_VAR 0 7
84262: ARRAY
84263: PPUSH
84264: CALL_OW 296
84268: PUSH
84269: LD_INT 5
84271: LESS
84272: AND
84273: IFFALSE 84290
// ComAutodestruct ( group [ i ] ) ;
84275: LD_VAR 0 4
84279: PUSH
84280: LD_VAR 0 7
84284: ARRAY
84285: PPUSH
84286: CALL 78770 0 1
// end ; if f_attack_depot then
84290: LD_VAR 0 25
84294: IFFALSE 84406
// begin k := 6 ;
84296: LD_ADDR_VAR 0 9
84300: PUSH
84301: LD_INT 6
84303: ST_TO_ADDR
// if tmp < k then
84304: LD_VAR 0 14
84308: PUSH
84309: LD_VAR 0 9
84313: LESS
84314: IFFALSE 84326
// k := tmp ;
84316: LD_ADDR_VAR 0 9
84320: PUSH
84321: LD_VAR 0 14
84325: ST_TO_ADDR
// for j = 1 to k do
84326: LD_ADDR_VAR 0 8
84330: PUSH
84331: DOUBLE
84332: LD_INT 1
84334: DEC
84335: ST_TO_ADDR
84336: LD_VAR 0 9
84340: PUSH
84341: FOR_TO
84342: IFFALSE 84404
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84344: LD_VAR 0 8
84348: PPUSH
84349: CALL_OW 266
84353: PUSH
84354: LD_INT 0
84356: PUSH
84357: LD_INT 1
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: IN
84364: IFFALSE 84402
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84366: LD_VAR 0 4
84370: PUSH
84371: LD_VAR 0 7
84375: ARRAY
84376: PPUSH
84377: LD_VAR 0 14
84381: PUSH
84382: LD_VAR 0 8
84386: ARRAY
84387: PPUSH
84388: CALL_OW 115
// attacking := true ;
84392: LD_ADDR_VAR 0 29
84396: PUSH
84397: LD_INT 1
84399: ST_TO_ADDR
// break ;
84400: GO 84404
// end ;
84402: GO 84341
84404: POP
84405: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
84406: LD_VAR 0 4
84410: PUSH
84411: LD_VAR 0 7
84415: ARRAY
84416: PPUSH
84417: CALL_OW 302
84421: PUSH
84422: LD_VAR 0 29
84426: NOT
84427: AND
84428: IFFALSE 84750
// begin if GetTag ( group [ i ] ) = 71 then
84430: LD_VAR 0 4
84434: PUSH
84435: LD_VAR 0 7
84439: ARRAY
84440: PPUSH
84441: CALL_OW 110
84445: PUSH
84446: LD_INT 71
84448: EQUAL
84449: IFFALSE 84490
// begin if HasTask ( group [ i ] ) then
84451: LD_VAR 0 4
84455: PUSH
84456: LD_VAR 0 7
84460: ARRAY
84461: PPUSH
84462: CALL_OW 314
84466: IFFALSE 84472
// continue else
84468: GO 80655
84470: GO 84490
// SetTag ( group [ i ] , 0 ) ;
84472: LD_VAR 0 4
84476: PUSH
84477: LD_VAR 0 7
84481: ARRAY
84482: PPUSH
84483: LD_INT 0
84485: PPUSH
84486: CALL_OW 109
// end ; k := 8 ;
84490: LD_ADDR_VAR 0 9
84494: PUSH
84495: LD_INT 8
84497: ST_TO_ADDR
// x := 0 ;
84498: LD_ADDR_VAR 0 10
84502: PUSH
84503: LD_INT 0
84505: ST_TO_ADDR
// if tmp < k then
84506: LD_VAR 0 14
84510: PUSH
84511: LD_VAR 0 9
84515: LESS
84516: IFFALSE 84528
// k := tmp ;
84518: LD_ADDR_VAR 0 9
84522: PUSH
84523: LD_VAR 0 14
84527: ST_TO_ADDR
// for j = 1 to k do
84528: LD_ADDR_VAR 0 8
84532: PUSH
84533: DOUBLE
84534: LD_INT 1
84536: DEC
84537: ST_TO_ADDR
84538: LD_VAR 0 9
84542: PUSH
84543: FOR_TO
84544: IFFALSE 84642
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
84546: LD_VAR 0 14
84550: PUSH
84551: LD_VAR 0 8
84555: ARRAY
84556: PPUSH
84557: CALL_OW 247
84561: PUSH
84562: LD_INT 1
84564: EQUAL
84565: PUSH
84566: LD_VAR 0 14
84570: PUSH
84571: LD_VAR 0 8
84575: ARRAY
84576: PPUSH
84577: CALL_OW 256
84581: PUSH
84582: LD_INT 250
84584: LESS
84585: PUSH
84586: LD_VAR 0 20
84590: AND
84591: PUSH
84592: LD_VAR 0 20
84596: NOT
84597: PUSH
84598: LD_VAR 0 14
84602: PUSH
84603: LD_VAR 0 8
84607: ARRAY
84608: PPUSH
84609: CALL_OW 256
84613: PUSH
84614: LD_INT 250
84616: GREATEREQUAL
84617: AND
84618: OR
84619: AND
84620: IFFALSE 84640
// begin x := tmp [ j ] ;
84622: LD_ADDR_VAR 0 10
84626: PUSH
84627: LD_VAR 0 14
84631: PUSH
84632: LD_VAR 0 8
84636: ARRAY
84637: ST_TO_ADDR
// break ;
84638: GO 84642
// end ;
84640: GO 84543
84642: POP
84643: POP
// if x then
84644: LD_VAR 0 10
84648: IFFALSE 84672
// ComAttackUnit ( group [ i ] , x ) else
84650: LD_VAR 0 4
84654: PUSH
84655: LD_VAR 0 7
84659: ARRAY
84660: PPUSH
84661: LD_VAR 0 10
84665: PPUSH
84666: CALL_OW 115
84670: GO 84696
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84672: LD_VAR 0 4
84676: PUSH
84677: LD_VAR 0 7
84681: ARRAY
84682: PPUSH
84683: LD_VAR 0 14
84687: PUSH
84688: LD_INT 1
84690: ARRAY
84691: PPUSH
84692: CALL_OW 115
// if not HasTask ( group [ i ] ) then
84696: LD_VAR 0 4
84700: PUSH
84701: LD_VAR 0 7
84705: ARRAY
84706: PPUSH
84707: CALL_OW 314
84711: NOT
84712: IFFALSE 84750
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
84714: LD_VAR 0 4
84718: PUSH
84719: LD_VAR 0 7
84723: ARRAY
84724: PPUSH
84725: LD_VAR 0 14
84729: PPUSH
84730: LD_VAR 0 4
84734: PUSH
84735: LD_VAR 0 7
84739: ARRAY
84740: PPUSH
84741: CALL_OW 74
84745: PPUSH
84746: CALL_OW 115
// end ; end ; end ;
84750: GO 80655
84752: POP
84753: POP
// wait ( 0 0$1 ) ;
84754: LD_INT 35
84756: PPUSH
84757: CALL_OW 67
// until group = [ ] ;
84761: LD_VAR 0 4
84765: PUSH
84766: EMPTY
84767: EQUAL
84768: IFFALSE 80640
// end ;
84770: LD_VAR 0 2
84774: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84775: LD_INT 0
84777: PPUSH
84778: PPUSH
84779: PPUSH
84780: PPUSH
// if not base_units then
84781: LD_VAR 0 1
84785: NOT
84786: IFFALSE 84790
// exit ;
84788: GO 84877
// result := false ;
84790: LD_ADDR_VAR 0 2
84794: PUSH
84795: LD_INT 0
84797: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84798: LD_ADDR_VAR 0 5
84802: PUSH
84803: LD_VAR 0 1
84807: PPUSH
84808: LD_INT 21
84810: PUSH
84811: LD_INT 3
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PPUSH
84818: CALL_OW 72
84822: ST_TO_ADDR
// if not tmp then
84823: LD_VAR 0 5
84827: NOT
84828: IFFALSE 84832
// exit ;
84830: GO 84877
// for i in tmp do
84832: LD_ADDR_VAR 0 3
84836: PUSH
84837: LD_VAR 0 5
84841: PUSH
84842: FOR_IN
84843: IFFALSE 84875
// begin result := EnemyInRange ( i , 22 ) ;
84845: LD_ADDR_VAR 0 2
84849: PUSH
84850: LD_VAR 0 3
84854: PPUSH
84855: LD_INT 22
84857: PPUSH
84858: CALL 78453 0 2
84862: ST_TO_ADDR
// if result then
84863: LD_VAR 0 2
84867: IFFALSE 84873
// exit ;
84869: POP
84870: POP
84871: GO 84877
// end ;
84873: GO 84842
84875: POP
84876: POP
// end ;
84877: LD_VAR 0 2
84881: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84882: LD_INT 0
84884: PPUSH
84885: PPUSH
// if not units then
84886: LD_VAR 0 1
84890: NOT
84891: IFFALSE 84895
// exit ;
84893: GO 84965
// result := [ ] ;
84895: LD_ADDR_VAR 0 3
84899: PUSH
84900: EMPTY
84901: ST_TO_ADDR
// for i in units do
84902: LD_ADDR_VAR 0 4
84906: PUSH
84907: LD_VAR 0 1
84911: PUSH
84912: FOR_IN
84913: IFFALSE 84963
// if GetTag ( i ) = tag then
84915: LD_VAR 0 4
84919: PPUSH
84920: CALL_OW 110
84924: PUSH
84925: LD_VAR 0 2
84929: EQUAL
84930: IFFALSE 84961
// result := Insert ( result , result + 1 , i ) ;
84932: LD_ADDR_VAR 0 3
84936: PUSH
84937: LD_VAR 0 3
84941: PPUSH
84942: LD_VAR 0 3
84946: PUSH
84947: LD_INT 1
84949: PLUS
84950: PPUSH
84951: LD_VAR 0 4
84955: PPUSH
84956: CALL_OW 2
84960: ST_TO_ADDR
84961: GO 84912
84963: POP
84964: POP
// end ;
84965: LD_VAR 0 3
84969: RET
// export function IsDriver ( un ) ; begin
84970: LD_INT 0
84972: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84973: LD_ADDR_VAR 0 2
84977: PUSH
84978: LD_VAR 0 1
84982: PUSH
84983: LD_INT 55
84985: PUSH
84986: EMPTY
84987: LIST
84988: PPUSH
84989: CALL_OW 69
84993: IN
84994: ST_TO_ADDR
// end ;
84995: LD_VAR 0 2
84999: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85000: LD_INT 0
85002: PPUSH
85003: PPUSH
// list := [ ] ;
85004: LD_ADDR_VAR 0 5
85008: PUSH
85009: EMPTY
85010: ST_TO_ADDR
// case d of 0 :
85011: LD_VAR 0 3
85015: PUSH
85016: LD_INT 0
85018: DOUBLE
85019: EQUAL
85020: IFTRUE 85024
85022: GO 85157
85024: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85025: LD_ADDR_VAR 0 5
85029: PUSH
85030: LD_VAR 0 1
85034: PUSH
85035: LD_INT 4
85037: MINUS
85038: PUSH
85039: LD_VAR 0 2
85043: PUSH
85044: LD_INT 4
85046: MINUS
85047: PUSH
85048: LD_INT 2
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: LIST
85055: PUSH
85056: LD_VAR 0 1
85060: PUSH
85061: LD_INT 3
85063: MINUS
85064: PUSH
85065: LD_VAR 0 2
85069: PUSH
85070: LD_INT 1
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: LIST
85077: PUSH
85078: LD_VAR 0 1
85082: PUSH
85083: LD_INT 4
85085: PLUS
85086: PUSH
85087: LD_VAR 0 2
85091: PUSH
85092: LD_INT 4
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: LIST
85099: PUSH
85100: LD_VAR 0 1
85104: PUSH
85105: LD_INT 3
85107: PLUS
85108: PUSH
85109: LD_VAR 0 2
85113: PUSH
85114: LD_INT 3
85116: PLUS
85117: PUSH
85118: LD_INT 5
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: LIST
85125: PUSH
85126: LD_VAR 0 1
85130: PUSH
85131: LD_VAR 0 2
85135: PUSH
85136: LD_INT 4
85138: PLUS
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: LIST
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: ST_TO_ADDR
// end ; 1 :
85155: GO 85855
85157: LD_INT 1
85159: DOUBLE
85160: EQUAL
85161: IFTRUE 85165
85163: GO 85298
85165: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85166: LD_ADDR_VAR 0 5
85170: PUSH
85171: LD_VAR 0 1
85175: PUSH
85176: LD_VAR 0 2
85180: PUSH
85181: LD_INT 4
85183: MINUS
85184: PUSH
85185: LD_INT 3
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: LIST
85192: PUSH
85193: LD_VAR 0 1
85197: PUSH
85198: LD_INT 3
85200: MINUS
85201: PUSH
85202: LD_VAR 0 2
85206: PUSH
85207: LD_INT 3
85209: MINUS
85210: PUSH
85211: LD_INT 2
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: LIST
85218: PUSH
85219: LD_VAR 0 1
85223: PUSH
85224: LD_INT 4
85226: MINUS
85227: PUSH
85228: LD_VAR 0 2
85232: PUSH
85233: LD_INT 1
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: LIST
85240: PUSH
85241: LD_VAR 0 1
85245: PUSH
85246: LD_VAR 0 2
85250: PUSH
85251: LD_INT 3
85253: PLUS
85254: PUSH
85255: LD_INT 0
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: LIST
85262: PUSH
85263: LD_VAR 0 1
85267: PUSH
85268: LD_INT 4
85270: PLUS
85271: PUSH
85272: LD_VAR 0 2
85276: PUSH
85277: LD_INT 4
85279: PLUS
85280: PUSH
85281: LD_INT 5
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: LIST
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: ST_TO_ADDR
// end ; 2 :
85296: GO 85855
85298: LD_INT 2
85300: DOUBLE
85301: EQUAL
85302: IFTRUE 85306
85304: GO 85435
85306: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85307: LD_ADDR_VAR 0 5
85311: PUSH
85312: LD_VAR 0 1
85316: PUSH
85317: LD_VAR 0 2
85321: PUSH
85322: LD_INT 3
85324: MINUS
85325: PUSH
85326: LD_INT 3
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: LIST
85333: PUSH
85334: LD_VAR 0 1
85338: PUSH
85339: LD_INT 4
85341: PLUS
85342: PUSH
85343: LD_VAR 0 2
85347: PUSH
85348: LD_INT 4
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: LIST
85355: PUSH
85356: LD_VAR 0 1
85360: PUSH
85361: LD_VAR 0 2
85365: PUSH
85366: LD_INT 4
85368: PLUS
85369: PUSH
85370: LD_INT 0
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: LIST
85377: PUSH
85378: LD_VAR 0 1
85382: PUSH
85383: LD_INT 3
85385: MINUS
85386: PUSH
85387: LD_VAR 0 2
85391: PUSH
85392: LD_INT 1
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: LIST
85399: PUSH
85400: LD_VAR 0 1
85404: PUSH
85405: LD_INT 4
85407: MINUS
85408: PUSH
85409: LD_VAR 0 2
85413: PUSH
85414: LD_INT 4
85416: MINUS
85417: PUSH
85418: LD_INT 2
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: LIST
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: ST_TO_ADDR
// end ; 3 :
85433: GO 85855
85435: LD_INT 3
85437: DOUBLE
85438: EQUAL
85439: IFTRUE 85443
85441: GO 85576
85443: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
85444: LD_ADDR_VAR 0 5
85448: PUSH
85449: LD_VAR 0 1
85453: PUSH
85454: LD_INT 3
85456: PLUS
85457: PUSH
85458: LD_VAR 0 2
85462: PUSH
85463: LD_INT 4
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: LIST
85470: PUSH
85471: LD_VAR 0 1
85475: PUSH
85476: LD_INT 4
85478: PLUS
85479: PUSH
85480: LD_VAR 0 2
85484: PUSH
85485: LD_INT 4
85487: PLUS
85488: PUSH
85489: LD_INT 5
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: LIST
85496: PUSH
85497: LD_VAR 0 1
85501: PUSH
85502: LD_INT 4
85504: MINUS
85505: PUSH
85506: LD_VAR 0 2
85510: PUSH
85511: LD_INT 1
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: LIST
85518: PUSH
85519: LD_VAR 0 1
85523: PUSH
85524: LD_VAR 0 2
85528: PUSH
85529: LD_INT 4
85531: MINUS
85532: PUSH
85533: LD_INT 3
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: LIST
85540: PUSH
85541: LD_VAR 0 1
85545: PUSH
85546: LD_INT 3
85548: MINUS
85549: PUSH
85550: LD_VAR 0 2
85554: PUSH
85555: LD_INT 3
85557: MINUS
85558: PUSH
85559: LD_INT 2
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: LIST
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: ST_TO_ADDR
// end ; 4 :
85574: GO 85855
85576: LD_INT 4
85578: DOUBLE
85579: EQUAL
85580: IFTRUE 85584
85582: GO 85717
85584: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85585: LD_ADDR_VAR 0 5
85589: PUSH
85590: LD_VAR 0 1
85594: PUSH
85595: LD_VAR 0 2
85599: PUSH
85600: LD_INT 4
85602: PLUS
85603: PUSH
85604: LD_INT 0
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: LIST
85611: PUSH
85612: LD_VAR 0 1
85616: PUSH
85617: LD_INT 3
85619: PLUS
85620: PUSH
85621: LD_VAR 0 2
85625: PUSH
85626: LD_INT 3
85628: PLUS
85629: PUSH
85630: LD_INT 5
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: LIST
85637: PUSH
85638: LD_VAR 0 1
85642: PUSH
85643: LD_INT 4
85645: PLUS
85646: PUSH
85647: LD_VAR 0 2
85651: PUSH
85652: LD_INT 4
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: LIST
85659: PUSH
85660: LD_VAR 0 1
85664: PUSH
85665: LD_VAR 0 2
85669: PUSH
85670: LD_INT 3
85672: MINUS
85673: PUSH
85674: LD_INT 3
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: LIST
85681: PUSH
85682: LD_VAR 0 1
85686: PUSH
85687: LD_INT 4
85689: MINUS
85690: PUSH
85691: LD_VAR 0 2
85695: PUSH
85696: LD_INT 4
85698: MINUS
85699: PUSH
85700: LD_INT 2
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: LIST
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: ST_TO_ADDR
// end ; 5 :
85715: GO 85855
85717: LD_INT 5
85719: DOUBLE
85720: EQUAL
85721: IFTRUE 85725
85723: GO 85854
85725: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85726: LD_ADDR_VAR 0 5
85730: PUSH
85731: LD_VAR 0 1
85735: PUSH
85736: LD_INT 4
85738: MINUS
85739: PUSH
85740: LD_VAR 0 2
85744: PUSH
85745: LD_INT 1
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: LIST
85752: PUSH
85753: LD_VAR 0 1
85757: PUSH
85758: LD_VAR 0 2
85762: PUSH
85763: LD_INT 4
85765: MINUS
85766: PUSH
85767: LD_INT 3
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: LIST
85774: PUSH
85775: LD_VAR 0 1
85779: PUSH
85780: LD_INT 4
85782: PLUS
85783: PUSH
85784: LD_VAR 0 2
85788: PUSH
85789: LD_INT 4
85791: PLUS
85792: PUSH
85793: LD_INT 5
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: LIST
85800: PUSH
85801: LD_VAR 0 1
85805: PUSH
85806: LD_INT 3
85808: PLUS
85809: PUSH
85810: LD_VAR 0 2
85814: PUSH
85815: LD_INT 4
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: LIST
85822: PUSH
85823: LD_VAR 0 1
85827: PUSH
85828: LD_VAR 0 2
85832: PUSH
85833: LD_INT 3
85835: PLUS
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: LIST
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: ST_TO_ADDR
// end ; end ;
85852: GO 85855
85854: POP
// result := list ;
85855: LD_ADDR_VAR 0 4
85859: PUSH
85860: LD_VAR 0 5
85864: ST_TO_ADDR
// end ;
85865: LD_VAR 0 4
85869: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85870: LD_INT 0
85872: PPUSH
85873: PPUSH
85874: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85875: LD_VAR 0 1
85879: NOT
85880: PUSH
85881: LD_VAR 0 2
85885: PUSH
85886: LD_INT 1
85888: PUSH
85889: LD_INT 2
85891: PUSH
85892: LD_INT 3
85894: PUSH
85895: LD_INT 4
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: IN
85904: NOT
85905: OR
85906: IFFALSE 85910
// exit ;
85908: GO 86002
// tmp := [ ] ;
85910: LD_ADDR_VAR 0 5
85914: PUSH
85915: EMPTY
85916: ST_TO_ADDR
// for i in units do
85917: LD_ADDR_VAR 0 4
85921: PUSH
85922: LD_VAR 0 1
85926: PUSH
85927: FOR_IN
85928: IFFALSE 85971
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85930: LD_ADDR_VAR 0 5
85934: PUSH
85935: LD_VAR 0 5
85939: PPUSH
85940: LD_VAR 0 5
85944: PUSH
85945: LD_INT 1
85947: PLUS
85948: PPUSH
85949: LD_VAR 0 4
85953: PPUSH
85954: LD_VAR 0 2
85958: PPUSH
85959: CALL_OW 259
85963: PPUSH
85964: CALL_OW 2
85968: ST_TO_ADDR
85969: GO 85927
85971: POP
85972: POP
// if not tmp then
85973: LD_VAR 0 5
85977: NOT
85978: IFFALSE 85982
// exit ;
85980: GO 86002
// result := SortListByListDesc ( units , tmp ) ;
85982: LD_ADDR_VAR 0 3
85986: PUSH
85987: LD_VAR 0 1
85991: PPUSH
85992: LD_VAR 0 5
85996: PPUSH
85997: CALL_OW 77
86001: ST_TO_ADDR
// end ;
86002: LD_VAR 0 3
86006: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86007: LD_INT 0
86009: PPUSH
86010: PPUSH
86011: PPUSH
// x := GetX ( building ) ;
86012: LD_ADDR_VAR 0 4
86016: PUSH
86017: LD_VAR 0 2
86021: PPUSH
86022: CALL_OW 250
86026: ST_TO_ADDR
// y := GetY ( building ) ;
86027: LD_ADDR_VAR 0 5
86031: PUSH
86032: LD_VAR 0 2
86036: PPUSH
86037: CALL_OW 251
86041: ST_TO_ADDR
// if GetTaskList ( unit ) then
86042: LD_VAR 0 1
86046: PPUSH
86047: CALL_OW 437
86051: IFFALSE 86146
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86053: LD_STRING e
86055: PUSH
86056: LD_VAR 0 1
86060: PPUSH
86061: CALL_OW 437
86065: PUSH
86066: LD_INT 1
86068: ARRAY
86069: PUSH
86070: LD_INT 1
86072: ARRAY
86073: EQUAL
86074: PUSH
86075: LD_VAR 0 4
86079: PUSH
86080: LD_VAR 0 1
86084: PPUSH
86085: CALL_OW 437
86089: PUSH
86090: LD_INT 1
86092: ARRAY
86093: PUSH
86094: LD_INT 2
86096: ARRAY
86097: EQUAL
86098: AND
86099: PUSH
86100: LD_VAR 0 5
86104: PUSH
86105: LD_VAR 0 1
86109: PPUSH
86110: CALL_OW 437
86114: PUSH
86115: LD_INT 1
86117: ARRAY
86118: PUSH
86119: LD_INT 3
86121: ARRAY
86122: EQUAL
86123: AND
86124: IFFALSE 86136
// result := true else
86126: LD_ADDR_VAR 0 3
86130: PUSH
86131: LD_INT 1
86133: ST_TO_ADDR
86134: GO 86144
// result := false ;
86136: LD_ADDR_VAR 0 3
86140: PUSH
86141: LD_INT 0
86143: ST_TO_ADDR
// end else
86144: GO 86154
// result := false ;
86146: LD_ADDR_VAR 0 3
86150: PUSH
86151: LD_INT 0
86153: ST_TO_ADDR
// end ;
86154: LD_VAR 0 3
86158: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86159: LD_INT 0
86161: PPUSH
86162: PPUSH
86163: PPUSH
86164: PPUSH
// if not unit or not area then
86165: LD_VAR 0 1
86169: NOT
86170: PUSH
86171: LD_VAR 0 2
86175: NOT
86176: OR
86177: IFFALSE 86181
// exit ;
86179: GO 86346
// tmp := AreaToList ( area , i ) ;
86181: LD_ADDR_VAR 0 6
86185: PUSH
86186: LD_VAR 0 2
86190: PPUSH
86191: LD_VAR 0 5
86195: PPUSH
86196: CALL_OW 517
86200: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86201: LD_ADDR_VAR 0 5
86205: PUSH
86206: DOUBLE
86207: LD_INT 1
86209: DEC
86210: ST_TO_ADDR
86211: LD_VAR 0 6
86215: PUSH
86216: LD_INT 1
86218: ARRAY
86219: PUSH
86220: FOR_TO
86221: IFFALSE 86336
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86223: LD_ADDR_VAR 0 7
86227: PUSH
86228: LD_VAR 0 6
86232: PUSH
86233: LD_INT 1
86235: ARRAY
86236: PUSH
86237: LD_VAR 0 5
86241: ARRAY
86242: PUSH
86243: LD_VAR 0 6
86247: PUSH
86248: LD_INT 2
86250: ARRAY
86251: PUSH
86252: LD_VAR 0 5
86256: ARRAY
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
86262: LD_VAR 0 7
86266: PUSH
86267: LD_INT 1
86269: ARRAY
86270: PPUSH
86271: LD_VAR 0 7
86275: PUSH
86276: LD_INT 2
86278: ARRAY
86279: PPUSH
86280: CALL_OW 428
86284: PUSH
86285: LD_INT 0
86287: EQUAL
86288: IFFALSE 86334
// begin result := true ;
86290: LD_ADDR_VAR 0 4
86294: PUSH
86295: LD_INT 1
86297: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
86298: LD_VAR 0 1
86302: PPUSH
86303: LD_VAR 0 7
86307: PUSH
86308: LD_INT 1
86310: ARRAY
86311: PPUSH
86312: LD_VAR 0 7
86316: PUSH
86317: LD_INT 2
86319: ARRAY
86320: PPUSH
86321: LD_VAR 0 3
86325: PPUSH
86326: CALL_OW 48
// exit ;
86330: POP
86331: POP
86332: GO 86346
// end ; end ;
86334: GO 86220
86336: POP
86337: POP
// result := false ;
86338: LD_ADDR_VAR 0 4
86342: PUSH
86343: LD_INT 0
86345: ST_TO_ADDR
// end ;
86346: LD_VAR 0 4
86350: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
86351: LD_INT 0
86353: PPUSH
86354: PPUSH
86355: PPUSH
// if not side or side > 8 then
86356: LD_VAR 0 1
86360: NOT
86361: PUSH
86362: LD_VAR 0 1
86366: PUSH
86367: LD_INT 8
86369: GREATER
86370: OR
86371: IFFALSE 86375
// exit ;
86373: GO 86562
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86375: LD_ADDR_VAR 0 4
86379: PUSH
86380: LD_INT 22
86382: PUSH
86383: LD_VAR 0 1
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_INT 21
86394: PUSH
86395: LD_INT 3
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PPUSH
86406: CALL_OW 69
86410: ST_TO_ADDR
// if not tmp then
86411: LD_VAR 0 4
86415: NOT
86416: IFFALSE 86420
// exit ;
86418: GO 86562
// enable_addtolog := true ;
86420: LD_ADDR_OWVAR 81
86424: PUSH
86425: LD_INT 1
86427: ST_TO_ADDR
// AddToLog ( [ ) ;
86428: LD_STRING [
86430: PPUSH
86431: CALL_OW 561
// for i in tmp do
86435: LD_ADDR_VAR 0 3
86439: PUSH
86440: LD_VAR 0 4
86444: PUSH
86445: FOR_IN
86446: IFFALSE 86553
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86448: LD_STRING [
86450: PUSH
86451: LD_VAR 0 3
86455: PPUSH
86456: CALL_OW 266
86460: STR
86461: PUSH
86462: LD_STRING , 
86464: STR
86465: PUSH
86466: LD_VAR 0 3
86470: PPUSH
86471: CALL_OW 250
86475: STR
86476: PUSH
86477: LD_STRING , 
86479: STR
86480: PUSH
86481: LD_VAR 0 3
86485: PPUSH
86486: CALL_OW 251
86490: STR
86491: PUSH
86492: LD_STRING , 
86494: STR
86495: PUSH
86496: LD_VAR 0 3
86500: PPUSH
86501: CALL_OW 254
86505: STR
86506: PUSH
86507: LD_STRING , 
86509: STR
86510: PUSH
86511: LD_VAR 0 3
86515: PPUSH
86516: LD_INT 1
86518: PPUSH
86519: CALL_OW 268
86523: STR
86524: PUSH
86525: LD_STRING , 
86527: STR
86528: PUSH
86529: LD_VAR 0 3
86533: PPUSH
86534: LD_INT 2
86536: PPUSH
86537: CALL_OW 268
86541: STR
86542: PUSH
86543: LD_STRING ],
86545: STR
86546: PPUSH
86547: CALL_OW 561
// end ;
86551: GO 86445
86553: POP
86554: POP
// AddToLog ( ]; ) ;
86555: LD_STRING ];
86557: PPUSH
86558: CALL_OW 561
// end ;
86562: LD_VAR 0 2
86566: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86567: LD_INT 0
86569: PPUSH
86570: PPUSH
86571: PPUSH
86572: PPUSH
86573: PPUSH
// if not area or not rate or not max then
86574: LD_VAR 0 1
86578: NOT
86579: PUSH
86580: LD_VAR 0 2
86584: NOT
86585: OR
86586: PUSH
86587: LD_VAR 0 4
86591: NOT
86592: OR
86593: IFFALSE 86597
// exit ;
86595: GO 86789
// while 1 do
86597: LD_INT 1
86599: IFFALSE 86789
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86601: LD_ADDR_VAR 0 9
86605: PUSH
86606: LD_VAR 0 1
86610: PPUSH
86611: LD_INT 1
86613: PPUSH
86614: CALL_OW 287
86618: PUSH
86619: LD_INT 10
86621: MUL
86622: ST_TO_ADDR
// r := rate / 10 ;
86623: LD_ADDR_VAR 0 7
86627: PUSH
86628: LD_VAR 0 2
86632: PUSH
86633: LD_INT 10
86635: DIVREAL
86636: ST_TO_ADDR
// time := 1 1$00 ;
86637: LD_ADDR_VAR 0 8
86641: PUSH
86642: LD_INT 2100
86644: ST_TO_ADDR
// if amount < min then
86645: LD_VAR 0 9
86649: PUSH
86650: LD_VAR 0 3
86654: LESS
86655: IFFALSE 86673
// r := r * 2 else
86657: LD_ADDR_VAR 0 7
86661: PUSH
86662: LD_VAR 0 7
86666: PUSH
86667: LD_INT 2
86669: MUL
86670: ST_TO_ADDR
86671: GO 86699
// if amount > max then
86673: LD_VAR 0 9
86677: PUSH
86678: LD_VAR 0 4
86682: GREATER
86683: IFFALSE 86699
// r := r / 2 ;
86685: LD_ADDR_VAR 0 7
86689: PUSH
86690: LD_VAR 0 7
86694: PUSH
86695: LD_INT 2
86697: DIVREAL
86698: ST_TO_ADDR
// time := time / r ;
86699: LD_ADDR_VAR 0 8
86703: PUSH
86704: LD_VAR 0 8
86708: PUSH
86709: LD_VAR 0 7
86713: DIVREAL
86714: ST_TO_ADDR
// if time < 0 then
86715: LD_VAR 0 8
86719: PUSH
86720: LD_INT 0
86722: LESS
86723: IFFALSE 86740
// time := time * - 1 ;
86725: LD_ADDR_VAR 0 8
86729: PUSH
86730: LD_VAR 0 8
86734: PUSH
86735: LD_INT 1
86737: NEG
86738: MUL
86739: ST_TO_ADDR
// wait ( time ) ;
86740: LD_VAR 0 8
86744: PPUSH
86745: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86749: LD_INT 35
86751: PPUSH
86752: LD_INT 875
86754: PPUSH
86755: CALL_OW 12
86759: PPUSH
86760: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86764: LD_INT 1
86766: PPUSH
86767: LD_INT 5
86769: PPUSH
86770: CALL_OW 12
86774: PPUSH
86775: LD_VAR 0 1
86779: PPUSH
86780: LD_INT 1
86782: PPUSH
86783: CALL_OW 55
// end ;
86787: GO 86597
// end ;
86789: LD_VAR 0 5
86793: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86794: LD_INT 0
86796: PPUSH
86797: PPUSH
86798: PPUSH
86799: PPUSH
86800: PPUSH
86801: PPUSH
86802: PPUSH
86803: PPUSH
// if not turrets or not factories then
86804: LD_VAR 0 1
86808: NOT
86809: PUSH
86810: LD_VAR 0 2
86814: NOT
86815: OR
86816: IFFALSE 86820
// exit ;
86818: GO 87127
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86820: LD_ADDR_VAR 0 10
86824: PUSH
86825: LD_INT 5
86827: PUSH
86828: LD_INT 6
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 2
86837: PUSH
86838: LD_INT 4
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 3
86847: PUSH
86848: LD_INT 5
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: LIST
86859: PUSH
86860: LD_INT 24
86862: PUSH
86863: LD_INT 25
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 23
86872: PUSH
86873: LD_INT 27
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 42
86886: PUSH
86887: LD_INT 43
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 44
86896: PUSH
86897: LD_INT 46
86899: PUSH
86900: EMPTY
86901: LIST
86902: LIST
86903: PUSH
86904: LD_INT 45
86906: PUSH
86907: LD_INT 47
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: LIST
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: LIST
86923: ST_TO_ADDR
// result := [ ] ;
86924: LD_ADDR_VAR 0 3
86928: PUSH
86929: EMPTY
86930: ST_TO_ADDR
// for i in turrets do
86931: LD_ADDR_VAR 0 4
86935: PUSH
86936: LD_VAR 0 1
86940: PUSH
86941: FOR_IN
86942: IFFALSE 87125
// begin nat := GetNation ( i ) ;
86944: LD_ADDR_VAR 0 7
86948: PUSH
86949: LD_VAR 0 4
86953: PPUSH
86954: CALL_OW 248
86958: ST_TO_ADDR
// weapon := 0 ;
86959: LD_ADDR_VAR 0 8
86963: PUSH
86964: LD_INT 0
86966: ST_TO_ADDR
// if not nat then
86967: LD_VAR 0 7
86971: NOT
86972: IFFALSE 86976
// continue ;
86974: GO 86941
// for j in list [ nat ] do
86976: LD_ADDR_VAR 0 5
86980: PUSH
86981: LD_VAR 0 10
86985: PUSH
86986: LD_VAR 0 7
86990: ARRAY
86991: PUSH
86992: FOR_IN
86993: IFFALSE 87034
// if GetBWeapon ( i ) = j [ 1 ] then
86995: LD_VAR 0 4
86999: PPUSH
87000: CALL_OW 269
87004: PUSH
87005: LD_VAR 0 5
87009: PUSH
87010: LD_INT 1
87012: ARRAY
87013: EQUAL
87014: IFFALSE 87032
// begin weapon := j [ 2 ] ;
87016: LD_ADDR_VAR 0 8
87020: PUSH
87021: LD_VAR 0 5
87025: PUSH
87026: LD_INT 2
87028: ARRAY
87029: ST_TO_ADDR
// break ;
87030: GO 87034
// end ;
87032: GO 86992
87034: POP
87035: POP
// if not weapon then
87036: LD_VAR 0 8
87040: NOT
87041: IFFALSE 87045
// continue ;
87043: GO 86941
// for k in factories do
87045: LD_ADDR_VAR 0 6
87049: PUSH
87050: LD_VAR 0 2
87054: PUSH
87055: FOR_IN
87056: IFFALSE 87121
// begin weapons := AvailableWeaponList ( k ) ;
87058: LD_ADDR_VAR 0 9
87062: PUSH
87063: LD_VAR 0 6
87067: PPUSH
87068: CALL_OW 478
87072: ST_TO_ADDR
// if not weapons then
87073: LD_VAR 0 9
87077: NOT
87078: IFFALSE 87082
// continue ;
87080: GO 87055
// if weapon in weapons then
87082: LD_VAR 0 8
87086: PUSH
87087: LD_VAR 0 9
87091: IN
87092: IFFALSE 87119
// begin result := [ i , weapon ] ;
87094: LD_ADDR_VAR 0 3
87098: PUSH
87099: LD_VAR 0 4
87103: PUSH
87104: LD_VAR 0 8
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: ST_TO_ADDR
// exit ;
87113: POP
87114: POP
87115: POP
87116: POP
87117: GO 87127
// end ; end ;
87119: GO 87055
87121: POP
87122: POP
// end ;
87123: GO 86941
87125: POP
87126: POP
// end ;
87127: LD_VAR 0 3
87131: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87132: LD_INT 0
87134: PPUSH
// if not side or side > 8 then
87135: LD_VAR 0 3
87139: NOT
87140: PUSH
87141: LD_VAR 0 3
87145: PUSH
87146: LD_INT 8
87148: GREATER
87149: OR
87150: IFFALSE 87154
// exit ;
87152: GO 87213
// if not range then
87154: LD_VAR 0 4
87158: NOT
87159: IFFALSE 87170
// range := - 12 ;
87161: LD_ADDR_VAR 0 4
87165: PUSH
87166: LD_INT 12
87168: NEG
87169: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87170: LD_VAR 0 1
87174: PPUSH
87175: LD_VAR 0 2
87179: PPUSH
87180: LD_VAR 0 3
87184: PPUSH
87185: LD_VAR 0 4
87189: PPUSH
87190: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87194: LD_VAR 0 1
87198: PPUSH
87199: LD_VAR 0 2
87203: PPUSH
87204: LD_VAR 0 3
87208: PPUSH
87209: CALL_OW 331
// end ;
87213: LD_VAR 0 5
87217: RET
// export function Video ( mode ) ; begin
87218: LD_INT 0
87220: PPUSH
// ingame_video = mode ;
87221: LD_ADDR_OWVAR 52
87225: PUSH
87226: LD_VAR 0 1
87230: ST_TO_ADDR
// interface_hidden = mode ;
87231: LD_ADDR_OWVAR 54
87235: PUSH
87236: LD_VAR 0 1
87240: ST_TO_ADDR
// end ;
87241: LD_VAR 0 2
87245: RET
// export function Join ( array , element ) ; begin
87246: LD_INT 0
87248: PPUSH
// result := array ^ element ;
87249: LD_ADDR_VAR 0 3
87253: PUSH
87254: LD_VAR 0 1
87258: PUSH
87259: LD_VAR 0 2
87263: ADD
87264: ST_TO_ADDR
// end ;
87265: LD_VAR 0 3
87269: RET
// export function JoinUnion ( array , element ) ; begin
87270: LD_INT 0
87272: PPUSH
// result := array union element ;
87273: LD_ADDR_VAR 0 3
87277: PUSH
87278: LD_VAR 0 1
87282: PUSH
87283: LD_VAR 0 2
87287: UNION
87288: ST_TO_ADDR
// end ;
87289: LD_VAR 0 3
87293: RET
// export function GetBehemoths ( side ) ; begin
87294: LD_INT 0
87296: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
87297: LD_ADDR_VAR 0 2
87301: PUSH
87302: LD_INT 22
87304: PUSH
87305: LD_VAR 0 1
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 31
87316: PUSH
87317: LD_INT 25
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PPUSH
87328: CALL_OW 69
87332: ST_TO_ADDR
// end ;
87333: LD_VAR 0 2
87337: RET
// export function Shuffle ( array ) ; var i , index ; begin
87338: LD_INT 0
87340: PPUSH
87341: PPUSH
87342: PPUSH
// result := [ ] ;
87343: LD_ADDR_VAR 0 2
87347: PUSH
87348: EMPTY
87349: ST_TO_ADDR
// if not array then
87350: LD_VAR 0 1
87354: NOT
87355: IFFALSE 87359
// exit ;
87357: GO 87458
// Randomize ;
87359: CALL_OW 10
// for i = array downto 1 do
87363: LD_ADDR_VAR 0 3
87367: PUSH
87368: DOUBLE
87369: LD_VAR 0 1
87373: INC
87374: ST_TO_ADDR
87375: LD_INT 1
87377: PUSH
87378: FOR_DOWNTO
87379: IFFALSE 87456
// begin index := rand ( 1 , array ) ;
87381: LD_ADDR_VAR 0 4
87385: PUSH
87386: LD_INT 1
87388: PPUSH
87389: LD_VAR 0 1
87393: PPUSH
87394: CALL_OW 12
87398: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87399: LD_ADDR_VAR 0 2
87403: PUSH
87404: LD_VAR 0 2
87408: PPUSH
87409: LD_VAR 0 2
87413: PUSH
87414: LD_INT 1
87416: PLUS
87417: PPUSH
87418: LD_VAR 0 1
87422: PUSH
87423: LD_VAR 0 4
87427: ARRAY
87428: PPUSH
87429: CALL_OW 2
87433: ST_TO_ADDR
// array := Delete ( array , index ) ;
87434: LD_ADDR_VAR 0 1
87438: PUSH
87439: LD_VAR 0 1
87443: PPUSH
87444: LD_VAR 0 4
87448: PPUSH
87449: CALL_OW 3
87453: ST_TO_ADDR
// end ;
87454: GO 87378
87456: POP
87457: POP
// end ; end_of_file
87458: LD_VAR 0 2
87462: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87463: GO 87465
87465: DISABLE
// begin ru_radar := 98 ;
87466: LD_ADDR_EXP 92
87470: PUSH
87471: LD_INT 98
87473: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87474: LD_ADDR_EXP 93
87478: PUSH
87479: LD_INT 89
87481: ST_TO_ADDR
// us_hack := 99 ;
87482: LD_ADDR_EXP 94
87486: PUSH
87487: LD_INT 99
87489: ST_TO_ADDR
// us_artillery := 97 ;
87490: LD_ADDR_EXP 95
87494: PUSH
87495: LD_INT 97
87497: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87498: LD_ADDR_EXP 96
87502: PUSH
87503: LD_INT 91
87505: ST_TO_ADDR
// end ;
87506: END
