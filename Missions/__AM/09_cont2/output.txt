// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 169 0 0
// PrepareNature ;
  16: CALL 344 0 0
// PrepareRussian ;
  20: CALL 12121 0 0
// PrepareAmerican ;
  24: CALL 1077 0 0
// PrepareOvsyenko ;
  28: CALL 1737 0 0
// Action ;
  32: CALL 2541 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// end ;
 164: LD_VAR 0 1
 168: RET
// function DebugMode ; begin
 169: LD_INT 0
 171: PPUSH
// if not debug then
 172: LD_EXP 2
 176: NOT
 177: IFFALSE 181
// exit ;
 179: GO 188
// FogOff ( 1 ) ;
 181: LD_INT 1
 183: PPUSH
 184: CALL_OW 344
// end ; end_of_file
 188: LD_VAR 0 1
 192: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 193: LD_INT 0
 195: PPUSH
 196: PPUSH
// if exist_mode then
 197: LD_VAR 0 2
 201: IFFALSE 226
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 203: LD_ADDR_VAR 0 5
 207: PUSH
 208: LD_VAR 0 3
 212: PUSH
 213: LD_VAR 0 1
 217: STR
 218: PPUSH
 219: CALL_OW 34
 223: ST_TO_ADDR
 224: GO 241
// unit := NewCharacter ( ident ) ;
 226: LD_ADDR_VAR 0 5
 230: PUSH
 231: LD_VAR 0 1
 235: PPUSH
 236: CALL_OW 25
 240: ST_TO_ADDR
// result := unit ;
 241: LD_ADDR_VAR 0 4
 245: PUSH
 246: LD_VAR 0 5
 250: ST_TO_ADDR
// end ;
 251: LD_VAR 0 4
 255: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 256: LD_INT 0
 258: PPUSH
// uc_side := side ;
 259: LD_ADDR_OWVAR 20
 263: PUSH
 264: LD_VAR 0 1
 268: ST_TO_ADDR
// uc_nation := nation ;
 269: LD_ADDR_OWVAR 21
 273: PUSH
 274: LD_VAR 0 2
 278: ST_TO_ADDR
// vc_chassis := chassis ;
 279: LD_ADDR_OWVAR 37
 283: PUSH
 284: LD_VAR 0 3
 288: ST_TO_ADDR
// vc_engine := engine ;
 289: LD_ADDR_OWVAR 39
 293: PUSH
 294: LD_VAR 0 4
 298: ST_TO_ADDR
// vc_control := control ;
 299: LD_ADDR_OWVAR 38
 303: PUSH
 304: LD_VAR 0 5
 308: ST_TO_ADDR
// vc_weapon := weapon ;
 309: LD_ADDR_OWVAR 40
 313: PUSH
 314: LD_VAR 0 6
 318: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 319: LD_ADDR_OWVAR 41
 323: PUSH
 324: LD_VAR 0 7
 328: ST_TO_ADDR
// result := CreateVehicle ;
 329: LD_ADDR_VAR 0 8
 333: PUSH
 334: CALL_OW 45
 338: ST_TO_ADDR
// end ;
 339: LD_VAR 0 8
 343: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 344: LD_INT 0
 346: PPUSH
 347: PPUSH
 348: PPUSH
 349: PPUSH
// uc_side = 0 ;
 350: LD_ADDR_OWVAR 20
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// uc_nation = 0 ;
 358: LD_ADDR_OWVAR 21
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// nat_area := natureArea ;
 366: LD_ADDR_VAR 0 4
 370: PUSH
 371: LD_INT 1
 373: ST_TO_ADDR
// InitHc ;
 374: CALL_OW 19
// for i = 1 to 4 do
 378: LD_ADDR_VAR 0 2
 382: PUSH
 383: DOUBLE
 384: LD_INT 1
 386: DEC
 387: ST_TO_ADDR
 388: LD_INT 4
 390: PUSH
 391: FOR_TO
 392: IFFALSE 447
// begin hc_class = 18 ;
 394: LD_ADDR_OWVAR 28
 398: PUSH
 399: LD_INT 18
 401: ST_TO_ADDR
// hc_gallery =  ;
 402: LD_ADDR_OWVAR 33
 406: PUSH
 407: LD_STRING 
 409: ST_TO_ADDR
// hc_face_number = 1 ;
 410: LD_ADDR_OWVAR 34
 414: PUSH
 415: LD_INT 1
 417: ST_TO_ADDR
// animal := CreateHuman ;
 418: LD_ADDR_VAR 0 3
 422: PUSH
 423: CALL_OW 44
 427: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 428: LD_VAR 0 3
 432: PPUSH
 433: LD_VAR 0 4
 437: PPUSH
 438: LD_INT 0
 440: PPUSH
 441: CALL_OW 49
// end ;
 445: GO 391
 447: POP
 448: POP
// for i = 1 to 4 do
 449: LD_ADDR_VAR 0 2
 453: PUSH
 454: DOUBLE
 455: LD_INT 1
 457: DEC
 458: ST_TO_ADDR
 459: LD_INT 4
 461: PUSH
 462: FOR_TO
 463: IFFALSE 535
// begin hc_class = class_tiger ;
 465: LD_ADDR_OWVAR 28
 469: PUSH
 470: LD_INT 14
 472: ST_TO_ADDR
// hc_gallery =  ;
 473: LD_ADDR_OWVAR 33
 477: PUSH
 478: LD_STRING 
 480: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 481: LD_ADDR_OWVAR 35
 485: PUSH
 486: LD_INT 5
 488: NEG
 489: PPUSH
 490: LD_INT 5
 492: PPUSH
 493: CALL_OW 12
 497: ST_TO_ADDR
// hc_face_number = 3 ;
 498: LD_ADDR_OWVAR 34
 502: PUSH
 503: LD_INT 3
 505: ST_TO_ADDR
// animal := CreateHuman ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: CALL_OW 44
 515: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 516: LD_VAR 0 3
 520: PPUSH
 521: LD_VAR 0 4
 525: PPUSH
 526: LD_INT 0
 528: PPUSH
 529: CALL_OW 49
// end ;
 533: GO 462
 535: POP
 536: POP
// for i = 1 to 8 do
 537: LD_ADDR_VAR 0 2
 541: PUSH
 542: DOUBLE
 543: LD_INT 1
 545: DEC
 546: ST_TO_ADDR
 547: LD_INT 8
 549: PUSH
 550: FOR_TO
 551: IFFALSE 654
// begin hc_class = class_apeman ;
 553: LD_ADDR_OWVAR 28
 557: PUSH
 558: LD_INT 12
 560: ST_TO_ADDR
// hc_gallery =  ;
 561: LD_ADDR_OWVAR 33
 565: PUSH
 566: LD_STRING 
 568: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 569: LD_ADDR_OWVAR 35
 573: PUSH
 574: LD_INT 2
 576: NEG
 577: PPUSH
 578: LD_INT 2
 580: PPUSH
 581: CALL_OW 12
 585: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 586: LD_ADDR_OWVAR 31
 590: PUSH
 591: LD_INT 1
 593: PPUSH
 594: LD_INT 3
 596: PPUSH
 597: CALL_OW 12
 601: PUSH
 602: LD_INT 1
 604: PPUSH
 605: LD_INT 3
 607: PPUSH
 608: CALL_OW 12
 612: PUSH
 613: LD_INT 0
 615: PUSH
 616: LD_INT 0
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: ST_TO_ADDR
// animal := CreateHuman ;
 625: LD_ADDR_VAR 0 3
 629: PUSH
 630: CALL_OW 44
 634: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 635: LD_VAR 0 3
 639: PPUSH
 640: LD_VAR 0 4
 644: PPUSH
 645: LD_INT 0
 647: PPUSH
 648: CALL_OW 49
// end ;
 652: GO 550
 654: POP
 655: POP
// for i = 1 to 6 do
 656: LD_ADDR_VAR 0 2
 660: PUSH
 661: DOUBLE
 662: LD_INT 1
 664: DEC
 665: ST_TO_ADDR
 666: LD_INT 6
 668: PUSH
 669: FOR_TO
 670: IFFALSE 725
// begin hc_class = 13 ;
 672: LD_ADDR_OWVAR 28
 676: PUSH
 677: LD_INT 13
 679: ST_TO_ADDR
// hc_gallery =  ;
 680: LD_ADDR_OWVAR 33
 684: PUSH
 685: LD_STRING 
 687: ST_TO_ADDR
// hc_face_number = 4 ;
 688: LD_ADDR_OWVAR 34
 692: PUSH
 693: LD_INT 4
 695: ST_TO_ADDR
// animal := CreateHuman ;
 696: LD_ADDR_VAR 0 3
 700: PUSH
 701: CALL_OW 44
 705: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 706: LD_VAR 0 3
 710: PPUSH
 711: LD_VAR 0 4
 715: PPUSH
 716: LD_INT 0
 718: PPUSH
 719: CALL_OW 49
// end ;
 723: GO 669
 725: POP
 726: POP
// vc_chassis := 31 ;
 727: LD_ADDR_OWVAR 37
 731: PUSH
 732: LD_INT 31
 734: ST_TO_ADDR
// vc_control := control_rider ;
 735: LD_ADDR_OWVAR 38
 739: PUSH
 740: LD_INT 4
 742: ST_TO_ADDR
// animal := CreateVehicle ;
 743: LD_ADDR_VAR 0 3
 747: PUSH
 748: CALL_OW 45
 752: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 753: LD_VAR 0 3
 757: PPUSH
 758: LD_INT 21
 760: PPUSH
 761: LD_INT 22
 763: PPUSH
 764: LD_INT 0
 766: PPUSH
 767: CALL_OW 48
// end ;
 771: LD_VAR 0 1
 775: RET
// export function GetTerminalCargo ; begin
 776: LD_INT 0
 778: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 779: LD_ADDR_VAR 0 1
 783: PUSH
 784: LD_EXP 3
 788: PPUSH
 789: CALL_OW 274
 793: PPUSH
 794: LD_INT 3
 796: PPUSH
 797: CALL_OW 275
 801: ST_TO_ADDR
// end ;
 802: LD_VAR 0 1
 806: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 807: LD_INT 0
 809: PPUSH
 810: PPUSH
 811: PPUSH
// result := 0 ;
 812: LD_ADDR_VAR 0 2
 816: PUSH
 817: LD_INT 0
 819: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 820: LD_ADDR_VAR 0 4
 824: PUSH
 825: LD_INT 22
 827: PUSH
 828: LD_VAR 0 1
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: PUSH
 837: LD_INT 2
 839: PUSH
 840: LD_INT 30
 842: PUSH
 843: LD_INT 0
 845: PUSH
 846: EMPTY
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: EMPTY
 857: LIST
 858: LIST
 859: PUSH
 860: EMPTY
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: EMPTY
 866: LIST
 867: LIST
 868: PPUSH
 869: CALL_OW 69
 873: ST_TO_ADDR
// if not tmp then
 874: LD_VAR 0 4
 878: NOT
 879: IFFALSE 883
// exit ;
 881: GO 929
// for i in tmp do
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_VAR 0 4
 892: PUSH
 893: FOR_IN
 894: IFFALSE 927
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 896: LD_ADDR_VAR 0 2
 900: PUSH
 901: LD_VAR 0 2
 905: PUSH
 906: LD_VAR 0 3
 910: PPUSH
 911: CALL_OW 274
 915: PPUSH
 916: LD_INT 3
 918: PPUSH
 919: CALL_OW 275
 923: PLUS
 924: ST_TO_ADDR
 925: GO 893
 927: POP
 928: POP
// end ;
 929: LD_VAR 0 2
 933: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 934: LD_INT 0
 936: PPUSH
 937: PPUSH
// area = ListEnvironmentArea ( area ) ;
 938: LD_ADDR_VAR 0 2
 942: PUSH
 943: LD_VAR 0 2
 947: PPUSH
 948: CALL_OW 353
 952: ST_TO_ADDR
// if bulldozer > 0 then
 953: LD_VAR 0 1
 957: PUSH
 958: LD_INT 0
 960: GREATER
 961: IFFALSE 1072
// for i = area downto 1 do
 963: LD_ADDR_VAR 0 4
 967: PUSH
 968: DOUBLE
 969: LD_VAR 0 2
 973: INC
 974: ST_TO_ADDR
 975: LD_INT 1
 977: PUSH
 978: FOR_DOWNTO
 979: IFFALSE 1070
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 981: LD_VAR 0 2
 985: PUSH
 986: LD_VAR 0 4
 990: ARRAY
 991: PUSH
 992: LD_INT 1
 994: ARRAY
 995: PPUSH
 996: LD_VAR 0 2
1000: PUSH
1001: LD_VAR 0 4
1005: ARRAY
1006: PUSH
1007: LD_INT 2
1009: ARRAY
1010: PPUSH
1011: CALL_OW 351
1015: IFFALSE 1068
// if not HasTask ( bulldozer ) then
1017: LD_VAR 0 1
1021: PPUSH
1022: CALL_OW 314
1026: NOT
1027: IFFALSE 1068
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1029: LD_VAR 0 1
1033: PPUSH
1034: LD_VAR 0 2
1038: PUSH
1039: LD_VAR 0 4
1043: ARRAY
1044: PUSH
1045: LD_INT 1
1047: ARRAY
1048: PPUSH
1049: LD_VAR 0 2
1053: PUSH
1054: LD_VAR 0 4
1058: ARRAY
1059: PUSH
1060: LD_INT 2
1062: ARRAY
1063: PPUSH
1064: CALL_OW 171
1068: GO 978
1070: POP
1071: POP
// end ; end_of_file
1072: LD_VAR 0 3
1076: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1077: LD_INT 0
1079: PPUSH
1080: PPUSH
1081: PPUSH
1082: PPUSH
1083: PPUSH
// uc_side := 1 ;
1084: LD_ADDR_OWVAR 20
1088: PUSH
1089: LD_INT 1
1091: ST_TO_ADDR
// uc_nation := 1 ;
1092: LD_ADDR_OWVAR 21
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1100: LD_ADDR_EXP 17
1104: PUSH
1105: LD_STRING JMM
1107: PPUSH
1108: LD_EXP 2
1112: NOT
1113: PPUSH
1114: LD_STRING 08_
1116: PPUSH
1117: CALL 193 0 3
1121: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1122: LD_ADDR_VAR 0 4
1126: PUSH
1127: LD_INT 1
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 2
1138: PPUSH
1139: LD_INT 1
1141: PPUSH
1142: LD_INT 5
1144: PPUSH
1145: LD_INT 55
1147: PPUSH
1148: CALL 256 0 7
1152: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1153: LD_VAR 0 4
1157: PPUSH
1158: LD_INT 3
1160: PPUSH
1161: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1165: LD_VAR 0 4
1169: PPUSH
1170: LD_INT 43
1172: PPUSH
1173: LD_INT 3
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1183: LD_EXP 17
1187: PPUSH
1188: LD_VAR 0 4
1192: PPUSH
1193: CALL_OW 52
// tmp := [ ] ;
1197: LD_ADDR_VAR 0 2
1201: PUSH
1202: EMPTY
1203: ST_TO_ADDR
// uc_side := 4 ;
1204: LD_ADDR_OWVAR 20
1208: PUSH
1209: LD_INT 4
1211: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1212: LD_ADDR_OWVAR 33
1216: PUSH
1217: LD_STRING SecondCharsGal
1219: ST_TO_ADDR
// hc_class := 2 ;
1220: LD_ADDR_OWVAR 28
1224: PUSH
1225: LD_INT 2
1227: ST_TO_ADDR
// hc_sex := sex_female ;
1228: LD_ADDR_OWVAR 27
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1236: LD_ADDR_OWVAR 30
1240: PUSH
1241: LD_INT 0
1243: PUSH
1244: LD_INT 1
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 0
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1259: LD_ADDR_OWVAR 31
1263: PUSH
1264: LD_INT 3
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: LD_INT 2
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1282: LD_ADDR_OWVAR 29
1286: PUSH
1287: LD_INT 10
1289: PUSH
1290: LD_INT 11
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1297: LD_ADDR_OWVAR 26
1301: PUSH
1302: LD_STRING Naoma Goichman
1304: ST_TO_ADDR
// hc_face_number := 43 ;
1305: LD_ADDR_OWVAR 34
1309: PUSH
1310: LD_INT 43
1312: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1313: LD_ADDR_VAR 0 2
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: CALL_OW 44
1327: ADD
1328: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1329: LD_ADDR_OWVAR 30
1333: PUSH
1334: LD_INT 0
1336: PUSH
1337: LD_INT 2
1339: PUSH
1340: LD_INT 0
1342: PUSH
1343: LD_INT 1
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1352: LD_ADDR_OWVAR 31
1356: PUSH
1357: LD_INT 0
1359: PUSH
1360: LD_INT 5
1362: PUSH
1363: LD_INT 3
1365: PUSH
1366: LD_INT 1
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1375: LD_ADDR_OWVAR 29
1379: PUSH
1380: LD_INT 10
1382: PUSH
1383: LD_INT 10
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1390: LD_ADDR_OWVAR 26
1394: PUSH
1395: LD_STRING Magdalene Glance
1397: ST_TO_ADDR
// hc_face_number := 44 ;
1398: LD_ADDR_OWVAR 34
1402: PUSH
1403: LD_INT 44
1405: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1406: LD_ADDR_VAR 0 2
1410: PUSH
1411: LD_VAR 0 2
1415: PUSH
1416: CALL_OW 44
1420: ADD
1421: ST_TO_ADDR
// hc_sex := sex_male ;
1422: LD_ADDR_OWVAR 27
1426: PUSH
1427: LD_INT 1
1429: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1430: LD_ADDR_OWVAR 30
1434: PUSH
1435: LD_INT 2
1437: PUSH
1438: LD_INT 2
1440: PUSH
1441: LD_INT 0
1443: PUSH
1444: LD_INT 0
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1453: LD_ADDR_OWVAR 31
1457: PUSH
1458: LD_INT 3
1460: PUSH
1461: LD_INT 4
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 0
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1476: LD_ADDR_OWVAR 29
1480: PUSH
1481: LD_INT 12
1483: PUSH
1484: LD_INT 10
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// hc_name := Steve Holland ;
1491: LD_ADDR_OWVAR 26
1495: PUSH
1496: LD_STRING Steve Holland
1498: ST_TO_ADDR
// hc_face_number := 60 ;
1499: LD_ADDR_OWVAR 34
1503: PUSH
1504: LD_INT 60
1506: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1507: LD_ADDR_VAR 0 2
1511: PUSH
1512: LD_VAR 0 2
1516: PUSH
1517: CALL_OW 44
1521: ADD
1522: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1523: LD_ADDR_EXP 22
1527: PUSH
1528: LD_VAR 0 2
1532: PUSH
1533: LD_INT 0
1535: DIFF
1536: ST_TO_ADDR
// for un in alpha_engs do
1537: LD_ADDR_VAR 0 3
1541: PUSH
1542: LD_EXP 22
1546: PUSH
1547: FOR_IN
1548: IFFALSE 1573
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1550: LD_VAR 0 3
1554: PPUSH
1555: LD_INT 52
1557: PPUSH
1558: LD_INT 35
1560: PPUSH
1561: LD_INT 3
1563: PPUSH
1564: LD_INT 0
1566: PPUSH
1567: CALL_OW 50
1571: GO 1547
1573: POP
1574: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1575: LD_ADDR_VAR 0 2
1579: PUSH
1580: DOUBLE
1581: LD_INT 1
1583: DEC
1584: ST_TO_ADDR
1585: LD_INT 1
1587: PUSH
1588: LD_STRING 06_crates_1
1590: PPUSH
1591: LD_INT 0
1593: PPUSH
1594: CALL_OW 30
1598: PLUS
1599: PUSH
1600: LD_INT 2
1602: MUL
1603: PUSH
1604: FOR_TO
1605: IFFALSE 1631
// CreateResourcesXYR ( mat_cans , 5 , 54 , 40 , 2 , false ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 5
1612: PPUSH
1613: LD_INT 54
1615: PPUSH
1616: LD_INT 40
1618: PPUSH
1619: LD_INT 2
1621: PPUSH
1622: LD_INT 0
1624: PPUSH
1625: CALL_OW 60
1629: GO 1604
1631: POP
1632: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1633: LD_STRING gamma_commander
1635: PPUSH
1636: LD_INT 0
1638: PPUSH
1639: CALL_OW 30
1643: PUSH
1644: LD_INT 3
1646: LESS
1647: IFFALSE 1705
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1649: LD_ADDR_EXP 21
1653: PUSH
1654: LD_STRING VanHouten
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: LD_STRING 
1662: PPUSH
1663: CALL 193 0 3
1667: ST_TO_ADDR
// for i = 1 to 4 do
1668: LD_ADDR_VAR 0 5
1672: PUSH
1673: DOUBLE
1674: LD_INT 1
1676: DEC
1677: ST_TO_ADDR
1678: LD_INT 4
1680: PUSH
1681: FOR_TO
1682: IFFALSE 1703
// AddExperience ( Houten , i , 10000 ) ;
1684: LD_EXP 21
1688: PPUSH
1689: LD_VAR 0 5
1693: PPUSH
1694: LD_INT 10000
1696: PPUSH
1697: CALL_OW 492
1701: GO 1681
1703: POP
1704: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1705: LD_ADDR_EXP 24
1709: PUSH
1710: LD_STRING Powell
1712: PPUSH
1713: LD_INT 0
1715: PPUSH
1716: LD_STRING 
1718: PPUSH
1719: CALL 193 0 3
1723: ST_TO_ADDR
// InitHc ;
1724: CALL_OW 19
// InitUc ;
1728: CALL_OW 18
// end ;
1732: LD_VAR 0 1
1736: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1737: LD_INT 0
1739: PPUSH
1740: PPUSH
1741: PPUSH
1742: PPUSH
1743: PPUSH
// uc_side := 4 ;
1744: LD_ADDR_OWVAR 20
1748: PUSH
1749: LD_INT 4
1751: ST_TO_ADDR
// uc_nation := 3 ;
1752: LD_ADDR_OWVAR 21
1756: PUSH
1757: LD_INT 3
1759: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 ] , [ b_breastwork , 109 , 114 , 4 ] , [ b_breastwork , 115 , 132 , 5 ] , [ b_breastwork , 98 , 120 , 1 ] ] ) ;
1760: LD_ADDR_VAR 0 4
1764: PUSH
1765: LD_STRING 09_ovsyenko_base
1767: PPUSH
1768: LD_INT 0
1770: PUSH
1771: LD_INT 101
1773: PUSH
1774: LD_INT 118
1776: PUSH
1777: LD_INT 2
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 31
1788: PUSH
1789: LD_INT 109
1791: PUSH
1792: LD_INT 114
1794: PUSH
1795: LD_INT 4
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 31
1806: PUSH
1807: LD_INT 115
1809: PUSH
1810: LD_INT 132
1812: PUSH
1813: LD_INT 5
1815: PUSH
1816: EMPTY
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: PUSH
1822: LD_INT 31
1824: PUSH
1825: LD_INT 98
1827: PUSH
1828: LD_INT 120
1830: PUSH
1831: LD_INT 1
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: PPUSH
1846: CALL_OW 30
1850: ST_TO_ADDR
// for i in tmp do
1851: LD_ADDR_VAR 0 2
1855: PUSH
1856: LD_VAR 0 4
1860: PUSH
1861: FOR_IN
1862: IFFALSE 2018
// begin bc_type := i [ 1 ] ;
1864: LD_ADDR_OWVAR 42
1868: PUSH
1869: LD_VAR 0 2
1873: PUSH
1874: LD_INT 1
1876: ARRAY
1877: ST_TO_ADDR
// bc_level := 3 ;
1878: LD_ADDR_OWVAR 43
1882: PUSH
1883: LD_INT 3
1885: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1886: LD_ADDR_VAR 0 3
1890: PUSH
1891: LD_VAR 0 2
1895: PUSH
1896: LD_INT 2
1898: ARRAY
1899: PPUSH
1900: LD_VAR 0 2
1904: PUSH
1905: LD_INT 3
1907: ARRAY
1908: PPUSH
1909: LD_VAR 0 2
1913: PUSH
1914: LD_INT 4
1916: ARRAY
1917: PPUSH
1918: CALL_OW 47
1922: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1923: LD_VAR 0 3
1927: PPUSH
1928: CALL_OW 266
1932: PUSH
1933: LD_INT 0
1935: EQUAL
1936: IFFALSE 1970
// begin SetBName ( b , ovsyenko ) ;
1938: LD_VAR 0 3
1942: PPUSH
1943: LD_STRING ovsyenko
1945: PPUSH
1946: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 274
1959: PPUSH
1960: LD_INT 1
1962: PPUSH
1963: LD_INT 50
1965: PPUSH
1966: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1970: LD_VAR 0 2
1974: PUSH
1975: LD_INT 5
1977: ARRAY
1978: PUSH
1979: LD_INT 250
1981: LESS
1982: IFFALSE 1998
// SetLives ( b , 333 ) else
1984: LD_VAR 0 3
1988: PPUSH
1989: LD_INT 333
1991: PPUSH
1992: CALL_OW 234
1996: GO 2016
// SetLives ( b , i [ 5 ] ) ;
1998: LD_VAR 0 3
2002: PPUSH
2003: LD_VAR 0 2
2007: PUSH
2008: LD_INT 5
2010: ARRAY
2011: PPUSH
2012: CALL_OW 234
// end ;
2016: GO 1861
2018: POP
2019: POP
// uc_nation := 1 ;
2020: LD_ADDR_OWVAR 21
2024: PUSH
2025: LD_INT 1
2027: ST_TO_ADDR
// tmp := [ ] ;
2028: LD_ADDR_VAR 0 4
2032: PUSH
2033: EMPTY
2034: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2035: LD_ADDR_EXP 18
2039: PUSH
2040: LD_STRING Gary
2042: PPUSH
2043: LD_EXP 2
2047: NOT
2048: PPUSH
2049: LD_STRING 
2051: PPUSH
2052: CALL 193 0 3
2056: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2057: LD_ADDR_VAR 0 4
2061: PUSH
2062: LD_VAR 0 4
2066: PUSH
2067: LD_EXP 18
2071: ADD
2072: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2073: LD_ADDR_EXP 19
2077: PUSH
2078: LD_STRING Bobby
2080: PPUSH
2081: LD_EXP 2
2085: NOT
2086: PPUSH
2087: LD_STRING 03_
2089: PPUSH
2090: CALL 193 0 3
2094: ST_TO_ADDR
// if Bobby then
2095: LD_EXP 19
2099: IFFALSE 2117
// tmp := tmp ^ Bobby ;
2101: LD_ADDR_VAR 0 4
2105: PUSH
2106: LD_VAR 0 4
2110: PUSH
2111: LD_EXP 19
2115: ADD
2116: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2117: LD_ADDR_EXP 20
2121: PUSH
2122: LD_STRING Cyrus
2124: PPUSH
2125: LD_EXP 2
2129: NOT
2130: PPUSH
2131: LD_STRING 03_
2133: PPUSH
2134: CALL 193 0 3
2138: ST_TO_ADDR
// if Cyrus then
2139: LD_EXP 20
2143: IFFALSE 2161
// tmp := tmp ^ Cyrus ;
2145: LD_ADDR_VAR 0 4
2149: PUSH
2150: LD_VAR 0 4
2154: PUSH
2155: LD_EXP 20
2159: ADD
2160: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2161: LD_ADDR_VAR 0 4
2165: PUSH
2166: LD_VAR 0 4
2170: PUSH
2171: LD_STRING 09_prev_squad
2173: PPUSH
2174: CALL_OW 31
2178: ADD
2179: ST_TO_ADDR
// tmp := tmp diff 0 ;
2180: LD_ADDR_VAR 0 4
2184: PUSH
2185: LD_VAR 0 4
2189: PUSH
2190: LD_INT 0
2192: DIFF
2193: ST_TO_ADDR
// for i in tmp do
2194: LD_ADDR_VAR 0 2
2198: PUSH
2199: LD_VAR 0 4
2203: PUSH
2204: FOR_IN
2205: IFFALSE 2264
// begin if GetClass ( i ) in [ 2 , 3 ] then
2207: LD_VAR 0 2
2211: PPUSH
2212: CALL_OW 257
2216: PUSH
2217: LD_INT 2
2219: PUSH
2220: LD_INT 3
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: IN
2227: IFFALSE 2241
// SetClass ( i , 1 ) ;
2229: LD_VAR 0 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2241: LD_VAR 0 2
2245: PPUSH
2246: LD_INT 106
2248: PPUSH
2249: LD_INT 122
2251: PPUSH
2252: LD_INT 5
2254: PPUSH
2255: LD_INT 0
2257: PPUSH
2258: CALL_OW 50
// end ;
2262: GO 2204
2264: POP
2265: POP
// tmp := tmp diff Gary ;
2266: LD_ADDR_VAR 0 4
2270: PUSH
2271: LD_VAR 0 4
2275: PUSH
2276: LD_EXP 18
2280: DIFF
2281: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2282: LD_ADDR_VAR 0 3
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 4
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 30
2299: PUSH
2300: LD_INT 31
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PPUSH
2311: CALL_OW 69
2315: ST_TO_ADDR
// for i = 1 to b do
2316: LD_ADDR_VAR 0 2
2320: PUSH
2321: DOUBLE
2322: LD_INT 1
2324: DEC
2325: ST_TO_ADDR
2326: LD_VAR 0 3
2330: PUSH
2331: FOR_TO
2332: IFFALSE 2362
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2334: LD_VAR 0 4
2338: PUSH
2339: LD_VAR 0 2
2343: ARRAY
2344: PPUSH
2345: LD_VAR 0 3
2349: PUSH
2350: LD_VAR 0 2
2354: ARRAY
2355: PPUSH
2356: CALL_OW 120
// end ;
2360: GO 2331
2362: POP
2363: POP
// InitHc ;
2364: CALL_OW 19
// InitUc ;
2368: CALL_OW 18
// end ;
2372: LD_VAR 0 1
2376: RET
// export function PowellTransport ; var i , un ; begin
2377: LD_INT 0
2379: PPUSH
2380: PPUSH
2381: PPUSH
// uc_side := 4 ;
2382: LD_ADDR_OWVAR 20
2386: PUSH
2387: LD_INT 4
2389: ST_TO_ADDR
// uc_nation := 1 ;
2390: LD_ADDR_OWVAR 21
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2398: LD_INT 1
2400: PPUSH
2401: LD_INT 3
2403: PPUSH
2404: LD_INT 6
2406: PPUSH
2407: CALL_OW 380
// hc_name :=  ;
2411: LD_ADDR_OWVAR 26
2415: PUSH
2416: LD_STRING 
2418: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2419: LD_ADDR_OWVAR 33
2423: PUSH
2424: LD_STRING SecondCharsGal
2426: ST_TO_ADDR
// hc_face_number := 30 ;
2427: LD_ADDR_OWVAR 34
2431: PUSH
2432: LD_INT 30
2434: ST_TO_ADDR
// powell_trans := CreateHuman ;
2435: LD_ADDR_EXP 23
2439: PUSH
2440: CALL_OW 44
2444: ST_TO_ADDR
// hc_face_number := 31 ;
2445: LD_ADDR_OWVAR 34
2449: PUSH
2450: LD_INT 31
2452: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2453: LD_ADDR_EXP 23
2457: PUSH
2458: LD_EXP 23
2462: PUSH
2463: CALL_OW 44
2467: ADD
2468: ST_TO_ADDR
// for i = 1 to 2 do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 2
2481: PUSH
2482: FOR_TO
2483: IFFALSE 2534
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2485: LD_ADDR_VAR 0 3
2489: PUSH
2490: LD_INT 4
2492: PPUSH
2493: LD_INT 1
2495: PPUSH
2496: LD_INT 3
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 12
2507: PPUSH
2508: LD_INT 66
2510: PPUSH
2511: CALL 256 0 7
2515: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2516: LD_ADDR_EXP 23
2520: PUSH
2521: LD_EXP 23
2525: PUSH
2526: LD_VAR 0 3
2530: ADD
2531: ST_TO_ADDR
// end ;
2532: GO 2482
2534: POP
2535: POP
// end ; end_of_file
2536: LD_VAR 0 1
2540: RET
// export function Action ; var i , veh ; begin
2541: LD_INT 0
2543: PPUSH
2544: PPUSH
2545: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2546: LD_EXP 22
2550: PPUSH
2551: LD_INT 0
2553: PPUSH
2554: LD_INT 50
2556: PPUSH
2557: LD_INT 38
2559: PPUSH
2560: LD_INT 2
2562: PPUSH
2563: CALL_OW 145
// InGameOn ;
2567: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2571: LD_INT 43
2573: PPUSH
2574: LD_INT 9
2576: PPUSH
2577: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2581: LD_EXP 17
2585: PPUSH
2586: LD_INT 54
2588: PPUSH
2589: LD_INT 34
2591: PPUSH
2592: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2596: LD_EXP 17
2600: PPUSH
2601: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2605: LD_EXP 17
2609: PPUSH
2610: LD_EXP 22
2614: PUSH
2615: LD_INT 1
2617: ARRAY
2618: PPUSH
2619: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2623: LD_INT 35
2625: PPUSH
2626: CALL_OW 67
// until See ( 4 , JMM ) ;
2630: LD_INT 4
2632: PPUSH
2633: LD_EXP 17
2637: PPUSH
2638: CALL_OW 292
2642: IFFALSE 2623
// CenterNowOnUnits ( JMM ) ;
2644: LD_EXP 17
2648: PPUSH
2649: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2653: LD_EXP 17
2657: PPUSH
2658: LD_STRING D2-JMM-1
2660: PPUSH
2661: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2665: LD_EXP 22
2669: PUSH
2670: LD_INT 3
2672: ARRAY
2673: PPUSH
2674: LD_EXP 17
2678: PPUSH
2679: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2683: LD_EXP 22
2687: PUSH
2688: LD_INT 3
2690: ARRAY
2691: PPUSH
2692: LD_STRING D2-Eng1-1
2694: PPUSH
2695: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2699: LD_EXP 17
2703: PPUSH
2704: LD_STRING D2-JMM-2
2706: PPUSH
2707: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2711: LD_EXP 22
2715: PUSH
2716: LD_INT 3
2718: ARRAY
2719: PPUSH
2720: LD_STRING D2-Eng1-2
2722: PPUSH
2723: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2727: LD_EXP 17
2731: PPUSH
2732: LD_STRING D2-JMM-3
2734: PPUSH
2735: CALL_OW 88
// if Houten then
2739: LD_EXP 21
2743: IFFALSE 2941
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2745: LD_ADDR_VAR 0 3
2749: PUSH
2750: LD_INT 4
2752: PPUSH
2753: LD_INT 1
2755: PPUSH
2756: LD_INT 3
2758: PPUSH
2759: LD_INT 2
2761: PPUSH
2762: LD_INT 1
2764: PPUSH
2765: LD_INT 4
2767: PPUSH
2768: LD_INT 55
2770: PPUSH
2771: CALL 256 0 7
2775: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2776: LD_VAR 0 3
2780: PPUSH
2781: LD_INT 3
2783: PPUSH
2784: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2788: LD_VAR 0 3
2792: PPUSH
2793: LD_INT 46
2795: PPUSH
2796: LD_INT 19
2798: PPUSH
2799: LD_INT 0
2801: PPUSH
2802: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2806: LD_EXP 21
2810: PPUSH
2811: LD_VAR 0 3
2815: PPUSH
2816: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2820: LD_EXP 21
2824: PPUSH
2825: LD_INT 49
2827: PPUSH
2828: LD_INT 33
2830: PPUSH
2831: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2835: LD_EXP 21
2839: PPUSH
2840: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2844: LD_EXP 21
2848: PPUSH
2849: LD_EXP 17
2853: PPUSH
2854: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2858: LD_INT 35
2860: PPUSH
2861: CALL_OW 67
// until See ( 1 , Houten ) ;
2865: LD_INT 1
2867: PPUSH
2868: LD_EXP 21
2872: PPUSH
2873: CALL_OW 292
2877: IFFALSE 2858
// ComTurnUnit ( JMM , Houten ) ;
2879: LD_EXP 17
2883: PPUSH
2884: LD_EXP 21
2888: PPUSH
2889: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2893: LD_EXP 17
2897: PPUSH
2898: LD_STRING D1d-JMM-1
2900: PPUSH
2901: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2905: LD_EXP 21
2909: PPUSH
2910: LD_STRING D1-VanH-1
2912: PPUSH
2913: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2917: LD_EXP 17
2921: PPUSH
2922: LD_STRING D1-JMM-1v
2924: PPUSH
2925: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2929: LD_EXP 17
2933: PPUSH
2934: LD_STRING D1-JMM-2v
2936: PPUSH
2937: CALL_OW 88
// end ; InGameOff ;
2941: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2945: LD_STRING M1
2947: PPUSH
2948: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2952: LD_INT 22
2954: PUSH
2955: LD_INT 4
2957: PUSH
2958: EMPTY
2959: LIST
2960: LIST
2961: PUSH
2962: LD_INT 92
2964: PUSH
2965: LD_EXP 17
2969: PPUSH
2970: CALL_OW 250
2974: PUSH
2975: LD_EXP 17
2979: PPUSH
2980: CALL_OW 251
2984: PUSH
2985: LD_INT 15
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: PPUSH
2998: CALL_OW 69
3002: PPUSH
3003: LD_INT 1
3005: PPUSH
3006: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3010: LD_EXP 22
3014: PUSH
3015: LD_EXP 17
3019: ADD
3020: PUSH
3021: LD_EXP 21
3025: ADD
3026: PPUSH
3027: CALL_OW 141
// end ;
3031: LD_VAR 0 1
3035: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3036: LD_INT 1
3038: PPUSH
3039: LD_EXP 18
3043: PPUSH
3044: CALL_OW 292
3048: PUSH
3049: LD_EXP 17
3053: PPUSH
3054: LD_EXP 18
3058: PPUSH
3059: CALL_OW 296
3063: PUSH
3064: LD_INT 6
3066: LESS
3067: AND
3068: IFFALSE 3831
3070: GO 3072
3072: DISABLE
3073: LD_INT 0
3075: PPUSH
3076: PPUSH
3077: PPUSH
3078: PPUSH
3079: PPUSH
// begin InGameOn ;
3080: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3084: LD_INT 22
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PPUSH
3094: CALL_OW 69
3098: PPUSH
3099: LD_INT 1
3101: PPUSH
3102: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3106: LD_ADDR_VAR 0 4
3110: PUSH
3111: LD_INT 22
3113: PUSH
3114: LD_INT 1
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 2
3123: PUSH
3124: LD_INT 25
3126: PUSH
3127: LD_INT 1
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: PUSH
3134: LD_INT 25
3136: PUSH
3137: LD_INT 2
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: PUSH
3144: LD_INT 25
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 25
3156: PUSH
3157: LD_INT 4
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: PPUSH
3175: CALL_OW 69
3179: ST_TO_ADDR
// ComHold ( tmp ) ;
3180: LD_VAR 0 4
3184: PPUSH
3185: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3189: LD_EXP 17
3193: PPUSH
3194: LD_STRING D2-JMM-3a
3196: PPUSH
3197: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3201: LD_EXP 18
3205: PPUSH
3206: LD_EXP 17
3210: PPUSH
3211: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3215: LD_EXP 18
3219: PPUSH
3220: LD_STRING D2-Gary-3
3222: PPUSH
3223: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3227: LD_EXP 17
3231: PPUSH
3232: LD_EXP 18
3236: PPUSH
3237: CALL_OW 119
// for i in tmp do
3241: LD_ADDR_VAR 0 5
3245: PUSH
3246: LD_VAR 0 4
3250: PUSH
3251: FOR_IN
3252: IFFALSE 3297
// begin if IsInUnit ( i ) then
3254: LD_VAR 0 5
3258: PPUSH
3259: CALL_OW 310
3263: IFFALSE 3274
// ComExitBuilding ( i ) ;
3265: LD_VAR 0 5
3269: PPUSH
3270: CALL_OW 122
// wait ( 1 ) ;
3274: LD_INT 1
3276: PPUSH
3277: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3281: LD_VAR 0 5
3285: PPUSH
3286: LD_EXP 17
3290: PPUSH
3291: CALL_OW 119
// end ;
3295: GO 3251
3297: POP
3298: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3299: LD_ADDR_VAR 0 4
3303: PUSH
3304: LD_VAR 0 4
3308: PUSH
3309: LD_EXP 17
3313: PUSH
3314: LD_EXP 21
3318: PUSH
3319: LD_EXP 18
3323: PUSH
3324: LD_EXP 20
3328: PUSH
3329: LD_EXP 19
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: LIST
3340: PUSH
3341: LD_EXP 22
3345: ADD
3346: DIFF
3347: ST_TO_ADDR
// if Bobby then
3348: LD_EXP 19
3352: IFFALSE 3366
// Say ( Bobby , D2-Bobby-3 ) ;
3354: LD_EXP 19
3358: PPUSH
3359: LD_STRING D2-Bobby-3
3361: PPUSH
3362: CALL_OW 88
// if Cyrus then
3366: LD_EXP 20
3370: IFFALSE 3384
// Say ( Cyrus , D2-Cyrus-3 ) ;
3372: LD_EXP 20
3376: PPUSH
3377: LD_STRING D2-Cyrus-3
3379: PPUSH
3380: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3384: LD_EXP 17
3388: PPUSH
3389: LD_STRING D2-JMM-4
3391: PPUSH
3392: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3396: LD_EXP 18
3400: PPUSH
3401: LD_STRING D2-Gary-4
3403: PPUSH
3404: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3408: LD_ADDR_VAR 0 1
3412: PUSH
3413: LD_VAR 0 4
3417: PPUSH
3418: LD_INT 26
3420: PUSH
3421: LD_INT 1
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: PPUSH
3428: CALL_OW 72
3432: PUSH
3433: LD_INT 1
3435: ARRAY
3436: ST_TO_ADDR
// if Cyrus then
3437: LD_EXP 20
3441: IFFALSE 3457
// Say ( Cyrus , D2-Cyrus-4 ) else
3443: LD_EXP 20
3447: PPUSH
3448: LD_STRING D2-Cyrus-4
3450: PPUSH
3451: CALL_OW 88
3455: GO 3469
// Say ( un1 , D2-Sol1-4 ) ;
3457: LD_VAR 0 1
3461: PPUSH
3462: LD_STRING D2-Sol1-4
3464: PPUSH
3465: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3469: LD_EXP 17
3473: PPUSH
3474: LD_STRING D2-JMM-5
3476: PPUSH
3477: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3481: LD_ADDR_VAR 0 2
3485: PUSH
3486: LD_EXP 22
3490: PPUSH
3491: LD_INT 91
3493: PUSH
3494: LD_EXP 17
3498: PUSH
3499: LD_INT 10
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: PUSH
3507: LD_INT 26
3509: PUSH
3510: LD_INT 2
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PPUSH
3521: CALL_OW 72
3525: ST_TO_ADDR
// if un2 then
3526: LD_VAR 0 2
3530: IFFALSE 3584
// begin un2 := un2 [ un2 ] ;
3532: LD_ADDR_VAR 0 2
3536: PUSH
3537: LD_VAR 0 2
3541: PUSH
3542: LD_VAR 0 2
3546: ARRAY
3547: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3548: LD_VAR 0 2
3552: PPUSH
3553: LD_STRING D2-FEng1-5
3555: PPUSH
3556: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3560: LD_EXP 17
3564: PPUSH
3565: LD_STRING D2-JMM-6
3567: PPUSH
3568: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3572: LD_VAR 0 2
3576: PPUSH
3577: LD_STRING D2-FEng1-6
3579: PPUSH
3580: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3584: LD_ADDR_VAR 0 3
3588: PUSH
3589: LD_EXP 22
3593: PPUSH
3594: LD_INT 91
3596: PUSH
3597: LD_EXP 17
3601: PUSH
3602: LD_INT 10
3604: PUSH
3605: EMPTY
3606: LIST
3607: LIST
3608: LIST
3609: PUSH
3610: LD_INT 26
3612: PUSH
3613: LD_INT 1
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PPUSH
3624: CALL_OW 72
3628: ST_TO_ADDR
// if un3 then
3629: LD_VAR 0 3
3633: IFFALSE 3688
// begin un3 := un3 [ 1 ] ;
3635: LD_ADDR_VAR 0 3
3639: PUSH
3640: LD_VAR 0 3
3644: PUSH
3645: LD_INT 1
3647: ARRAY
3648: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3649: LD_VAR 0 3
3653: PPUSH
3654: LD_INT 114
3656: PPUSH
3657: LD_INT 122
3659: PPUSH
3660: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3664: LD_VAR 0 3
3668: PPUSH
3669: LD_STRING D2-Eng1-6
3671: PPUSH
3672: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3676: LD_EXP 17
3680: PPUSH
3681: LD_STRING D2-JMM-7
3683: PPUSH
3684: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3688: LD_EXP 18
3692: PPUSH
3693: LD_STRING D2-Gary-7
3695: PPUSH
3696: CALL_OW 88
// if un2 then
3700: LD_VAR 0 2
3704: IFFALSE 3718
// Say ( un2 , D2-FEng1-7 ) ;
3706: LD_VAR 0 2
3710: PPUSH
3711: LD_STRING D2-FEng1-7
3713: PPUSH
3714: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3718: LD_VAR 0 1
3722: PPUSH
3723: LD_STRING D2-Sol1-7
3725: PPUSH
3726: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3730: LD_EXP 17
3734: PPUSH
3735: LD_STRING D2-JMM-8
3737: PPUSH
3738: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3742: LD_INT 22
3744: PUSH
3745: LD_INT 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: PPUSH
3757: CALL_OW 141
// InGameOff ;
3761: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3765: LD_STRING M1a
3767: PPUSH
3768: CALL_OW 337
// jmm_in_ovsyenko := true ;
3772: LD_ADDR_EXP 4
3776: PUSH
3777: LD_INT 1
3779: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3780: LD_INT 1050
3782: PPUSH
3783: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3787: LD_ADDR_VAR 0 4
3791: PUSH
3792: LD_INT 25
3794: PUSH
3795: LD_INT 14
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: ST_TO_ADDR
// if not tmp then
3807: LD_VAR 0 4
3811: NOT
3812: IFFALSE 3816
// exit ;
3814: GO 3831
// ComMoveXY ( tmp , 75 , 75 ) ;
3816: LD_VAR 0 4
3820: PPUSH
3821: LD_INT 75
3823: PPUSH
3824: LD_INT 75
3826: PPUSH
3827: CALL_OW 111
// end ;
3831: PPOPN 5
3833: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3834: LD_INT 22
3836: PUSH
3837: LD_INT 1
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: LD_INT 30
3846: PUSH
3847: LD_INT 30
3849: PUSH
3850: EMPTY
3851: LIST
3852: LIST
3853: PUSH
3854: LD_INT 3
3856: PUSH
3857: LD_INT 57
3859: PUSH
3860: EMPTY
3861: LIST
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PUSH
3867: EMPTY
3868: LIST
3869: LIST
3870: LIST
3871: PPUSH
3872: CALL_OW 69
3876: IFFALSE 3918
3878: GO 3880
3880: DISABLE
3881: LD_INT 0
3883: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3884: LD_ADDR_VAR 0 1
3888: PUSH
3889: LD_STRING M2easy
3891: PUSH
3892: LD_STRING M2
3894: PUSH
3895: LD_STRING M2hard
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: LIST
3902: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3903: LD_VAR 0 1
3907: PUSH
3908: LD_OWVAR 67
3912: ARRAY
3913: PPUSH
3914: CALL_OW 337
// end ;
3918: PPOPN 1
3920: END
// every 3 3$00 do
3921: GO 3923
3923: DISABLE
// begin DialogueOn ;
3924: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3928: LD_EXP 24
3932: PPUSH
3933: LD_STRING D3-Pow-1
3935: PPUSH
3936: CALL_OW 94
// if jmm_in_ovsyenko then
3940: LD_EXP 4
3944: IFFALSE 3972
// begin Say ( JMM , D3-JMM-1 ) ;
3946: LD_EXP 17
3950: PPUSH
3951: LD_STRING D3-JMM-1
3953: PPUSH
3954: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
3958: LD_EXP 17
3962: PPUSH
3963: LD_STRING D3-JMM-1b
3965: PPUSH
3966: CALL_OW 88
// end else
3970: GO 3984
// Say ( JMM , D3-JMM-1a ) ;
3972: LD_EXP 17
3976: PPUSH
3977: LD_STRING D3-JMM-1a
3979: PPUSH
3980: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
3984: LD_EXP 24
3988: PPUSH
3989: LD_STRING D3-Pow-2
3991: PPUSH
3992: CALL_OW 94
// DialogueOff ;
3996: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4000: LD_STRING M3
4002: PPUSH
4003: CALL_OW 337
// powell_want_sib := true ;
4007: LD_ADDR_EXP 5
4011: PUSH
4012: LD_INT 1
4014: ST_TO_ADDR
// end ;
4015: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo ;
4016: LD_EXP 6
4020: PUSH
4021: LD_INT 0
4023: EQUAL
4024: IFFALSE 5299
4026: GO 4028
4028: DISABLE
4029: LD_INT 0
4031: PPUSH
4032: PPUSH
4033: PPUSH
4034: PPUSH
4035: PPUSH
4036: PPUSH
4037: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4038: LD_INT 4
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: CALL_OW 343
// PowellTransport ;
4048: CALL 2377 0 0
// for i = 1 to 3 do
4052: LD_ADDR_VAR 0 4
4056: PUSH
4057: DOUBLE
4058: LD_INT 1
4060: DEC
4061: ST_TO_ADDR
4062: LD_INT 3
4064: PUSH
4065: FOR_TO
4066: IFFALSE 4133
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4068: LD_ADDR_VAR 0 1
4072: PUSH
4073: LD_INT 6
4075: PPUSH
4076: LD_VAR 0 4
4080: PPUSH
4081: CALL_OW 287
4085: ST_TO_ADDR
// if not tmp then
4086: LD_VAR 0 1
4090: NOT
4091: IFFALSE 4095
// continue ;
4093: GO 4065
// EraseResourceArea ( terminalArea , i ) ;
4095: LD_INT 6
4097: PPUSH
4098: LD_VAR 0 4
4102: PPUSH
4103: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4107: LD_EXP 3
4111: PPUSH
4112: CALL_OW 274
4116: PPUSH
4117: LD_VAR 0 4
4121: PPUSH
4122: LD_VAR 0 1
4126: PPUSH
4127: CALL_OW 276
// end ;
4131: GO 4065
4133: POP
4134: POP
// x := 43 ;
4135: LD_ADDR_VAR 0 2
4139: PUSH
4140: LD_INT 43
4142: ST_TO_ADDR
// y := 3 ;
4143: LD_ADDR_VAR 0 3
4147: PUSH
4148: LD_INT 3
4150: ST_TO_ADDR
// for i = 3 to 4 do
4151: LD_ADDR_VAR 0 4
4155: PUSH
4156: DOUBLE
4157: LD_INT 3
4159: DEC
4160: ST_TO_ADDR
4161: LD_INT 4
4163: PUSH
4164: FOR_TO
4165: IFFALSE 4375
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4167: LD_EXP 23
4171: PUSH
4172: LD_VAR 0 4
4176: ARRAY
4177: PPUSH
4178: LD_INT 4
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4185: LD_EXP 23
4189: PUSH
4190: LD_VAR 0 4
4194: ARRAY
4195: PPUSH
4196: LD_VAR 0 2
4200: PPUSH
4201: LD_VAR 0 3
4205: PPUSH
4206: LD_INT 0
4208: PPUSH
4209: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4213: LD_EXP 23
4217: PUSH
4218: LD_VAR 0 4
4222: PUSH
4223: LD_INT 2
4225: MINUS
4226: ARRAY
4227: PPUSH
4228: LD_EXP 23
4232: PUSH
4233: LD_VAR 0 4
4237: ARRAY
4238: PPUSH
4239: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4243: LD_EXP 23
4247: PUSH
4248: LD_VAR 0 4
4252: ARRAY
4253: PPUSH
4254: LD_INT 1
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4264: LD_EXP 23
4268: PUSH
4269: LD_VAR 0 4
4273: PUSH
4274: LD_INT 2
4276: MINUS
4277: ARRAY
4278: PPUSH
4279: LD_INT 54
4281: PPUSH
4282: LD_INT 42
4284: PPUSH
4285: CALL_OW 111
// AddComUnload ( powell_trans [ i - 2 ] ) ;
4289: LD_EXP 23
4293: PUSH
4294: LD_VAR 0 4
4298: PUSH
4299: LD_INT 2
4301: MINUS
4302: ARRAY
4303: PPUSH
4304: CALL_OW 219
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4308: LD_EXP 23
4312: PUSH
4313: LD_VAR 0 4
4317: PUSH
4318: LD_INT 2
4320: MINUS
4321: ARRAY
4322: PPUSH
4323: LD_EXP 3
4327: PPUSH
4328: CALL_OW 250
4332: PPUSH
4333: LD_EXP 3
4337: PPUSH
4338: CALL_OW 251
4342: PPUSH
4343: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4347: LD_EXP 23
4351: PUSH
4352: LD_VAR 0 4
4356: PUSH
4357: LD_INT 2
4359: MINUS
4360: ARRAY
4361: PPUSH
4362: CALL_OW 200
// Wait ( 0 0$02 ) ;
4366: LD_INT 70
4368: PPUSH
4369: CALL_OW 67
// end ;
4373: GO 4164
4375: POP
4376: POP
// repeat wait ( 0 0$01 ) ;
4377: LD_INT 35
4379: PPUSH
4380: CALL_OW 67
// for i = 3 to 4 do
4384: LD_ADDR_VAR 0 4
4388: PUSH
4389: DOUBLE
4390: LD_INT 3
4392: DEC
4393: ST_TO_ADDR
4394: LD_INT 4
4396: PUSH
4397: FOR_TO
4398: IFFALSE 4548
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4400: LD_EXP 23
4404: PUSH
4405: LD_VAR 0 4
4409: ARRAY
4410: PPUSH
4411: LD_INT 1
4413: PPUSH
4414: CALL_OW 289
4418: PUSH
4419: LD_INT 0
4421: GREATER
4422: PUSH
4423: LD_EXP 23
4427: PUSH
4428: LD_VAR 0 4
4432: ARRAY
4433: PPUSH
4434: CALL_OW 314
4438: NOT
4439: AND
4440: IFFALSE 4546
// begin ComUnload ( powell_trans [ i ] ) ;
4442: LD_EXP 23
4446: PUSH
4447: LD_VAR 0 4
4451: ARRAY
4452: PPUSH
4453: CALL_OW 159
// x := rand ( 0 , 5 ) ;
4457: LD_ADDR_VAR 0 2
4461: PUSH
4462: LD_INT 0
4464: PPUSH
4465: LD_INT 5
4467: PPUSH
4468: CALL_OW 12
4472: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4473: LD_EXP 23
4477: PUSH
4478: LD_VAR 0 4
4482: ARRAY
4483: PPUSH
4484: LD_EXP 23
4488: PUSH
4489: LD_VAR 0 4
4493: ARRAY
4494: PPUSH
4495: CALL_OW 250
4499: PPUSH
4500: LD_VAR 0 2
4504: PPUSH
4505: LD_INT 3
4507: PPUSH
4508: CALL_OW 272
4512: PPUSH
4513: LD_EXP 23
4517: PUSH
4518: LD_VAR 0 4
4522: ARRAY
4523: PPUSH
4524: CALL_OW 251
4528: PPUSH
4529: LD_VAR 0 2
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 273
4541: PPUSH
4542: CALL_OW 171
// end ;
4546: GO 4397
4548: POP
4549: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 and ( GetCargo ( powell_trans [ 3 ] , mat_cans ) = 0 ) and ( GetCargo ( powell_trans [ 4 ] , mat_cans ) = 0 ) ;
4550: LD_EXP 23
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 54
4561: PPUSH
4562: LD_INT 42
4564: PPUSH
4565: CALL_OW 297
4569: PUSH
4570: LD_INT 4
4572: LESS
4573: PUSH
4574: LD_EXP 23
4578: PUSH
4579: LD_INT 3
4581: ARRAY
4582: PPUSH
4583: LD_INT 1
4585: PPUSH
4586: CALL_OW 289
4590: PUSH
4591: LD_INT 0
4593: EQUAL
4594: AND
4595: PUSH
4596: LD_EXP 23
4600: PUSH
4601: LD_INT 4
4603: ARRAY
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL_OW 289
4612: PUSH
4613: LD_INT 0
4615: EQUAL
4616: AND
4617: IFFALSE 4377
// DialogueOn ;
4619: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4623: LD_INT 53
4625: PPUSH
4626: LD_INT 35
4628: PPUSH
4629: CALL_OW 86
// un := powell_trans [ 1 ] ;
4633: LD_ADDR_VAR 0 5
4637: PUSH
4638: LD_EXP 23
4642: PUSH
4643: LD_INT 1
4645: ARRAY
4646: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4647: LD_VAR 0 5
4651: PPUSH
4652: LD_STRING D4-Mech1-1
4654: PPUSH
4655: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4659: LD_EXP 17
4663: PPUSH
4664: LD_STRING D4-JMM-1
4666: PPUSH
4667: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4671: LD_VAR 0 5
4675: PPUSH
4676: LD_STRING D4-Mech1-2
4678: PPUSH
4679: CALL_OW 88
// powell_happy := false ;
4683: LD_ADDR_VAR 0 6
4687: PUSH
4688: LD_INT 0
4690: ST_TO_ADDR
// take_cargo := false ;
4691: LD_ADDR_VAR 0 7
4695: PUSH
4696: LD_INT 0
4698: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4699: CALL 776 0 0
4703: PUSH
4704: LD_INT 60
4706: GREATEREQUAL
4707: IFFALSE 4755
// begin Say ( JMM , D5-JMM-1 ) ;
4709: LD_EXP 17
4713: PPUSH
4714: LD_STRING D5-JMM-1
4716: PPUSH
4717: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4721: LD_VAR 0 5
4725: PPUSH
4726: LD_STRING D6-Mech1-1
4728: PPUSH
4729: CALL_OW 88
// powell_happy := true ;
4733: LD_ADDR_VAR 0 6
4737: PUSH
4738: LD_INT 1
4740: ST_TO_ADDR
// take_cargo := true ;
4741: LD_ADDR_VAR 0 7
4745: PUSH
4746: LD_INT 1
4748: ST_TO_ADDR
// DialogueOff ;
4749: CALL_OW 7
// end else
4753: GO 4989
// if GetTerminalCargo > 0 then
4755: CALL 776 0 0
4759: PUSH
4760: LD_INT 0
4762: GREATER
4763: IFFALSE 4961
// begin case Query ( QWait ) of 1 :
4765: LD_STRING QWait
4767: PPUSH
4768: CALL_OW 97
4772: PUSH
4773: LD_INT 1
4775: DOUBLE
4776: EQUAL
4777: IFTRUE 4781
4779: GO 4872
4781: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4782: LD_EXP 17
4786: PPUSH
4787: LD_STRING D5b-JMM-1
4789: PPUSH
4790: CALL_OW 88
// DialogueOff ;
4794: CALL_OW 7
// wait ( 5 5$00 ) ;
4798: LD_INT 10500
4800: PPUSH
4801: CALL_OW 67
// if GetTerminalCargo < 60 then
4805: CALL 776 0 0
4809: PUSH
4810: LD_INT 60
4812: LESS
4813: IFFALSE 4854
// begin DialogueOn ;
4815: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4819: LD_EXP 3
4823: PPUSH
4824: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4828: LD_VAR 0 5
4832: PPUSH
4833: LD_STRING D6-Mech1-1a
4835: PPUSH
4836: CALL_OW 88
// DialogueOff ;
4840: CALL_OW 7
// powell_happy := false ;
4844: LD_ADDR_VAR 0 6
4848: PUSH
4849: LD_INT 0
4851: ST_TO_ADDR
// end else
4852: GO 4870
// begin powell_happy := true ;
4854: LD_ADDR_VAR 0 6
4858: PUSH
4859: LD_INT 1
4861: ST_TO_ADDR
// take_cargo := true ;
4862: LD_ADDR_VAR 0 7
4866: PUSH
4867: LD_INT 1
4869: ST_TO_ADDR
// end ; end ; 2 :
4870: GO 4959
4872: LD_INT 2
4874: DOUBLE
4875: EQUAL
4876: IFTRUE 4880
4878: GO 4919
4880: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4881: LD_EXP 17
4885: PPUSH
4886: LD_STRING D5b-JMM-1
4888: PPUSH
4889: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4893: LD_VAR 0 5
4897: PPUSH
4898: LD_STRING D6-Mech1-1a
4900: PPUSH
4901: CALL_OW 88
// DialogueOff ;
4905: CALL_OW 7
// take_cargo := true ;
4909: LD_ADDR_VAR 0 7
4913: PUSH
4914: LD_INT 1
4916: ST_TO_ADDR
// end ; 3 :
4917: GO 4959
4919: LD_INT 3
4921: DOUBLE
4922: EQUAL
4923: IFTRUE 4927
4925: GO 4958
4927: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4928: LD_EXP 17
4932: PPUSH
4933: LD_STRING D5c-JMM-1
4935: PPUSH
4936: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4940: LD_VAR 0 5
4944: PPUSH
4945: LD_STRING D6-Mech1-1b
4947: PPUSH
4948: CALL_OW 88
// DialogueOff ;
4952: CALL_OW 7
// end ; end ;
4956: GO 4959
4958: POP
// end else
4959: GO 4989
// begin Say ( JMM , D5c-JMM-1 ) ;
4961: LD_EXP 17
4965: PPUSH
4966: LD_STRING D5c-JMM-1
4968: PPUSH
4969: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4973: LD_VAR 0 5
4977: PPUSH
4978: LD_STRING D6-Mech1-1b
4980: PPUSH
4981: CALL_OW 88
// DialogueOff ;
4985: CALL_OW 7
// end ; if take_cargo then
4989: LD_VAR 0 7
4993: IFFALSE 5072
// begin x := GetTerminalCargo ;
4995: LD_ADDR_VAR 0 2
4999: PUSH
5000: CALL 776 0 0
5004: ST_TO_ADDR
// if x > 60 then
5005: LD_VAR 0 2
5009: PUSH
5010: LD_INT 60
5012: GREATER
5013: IFFALSE 5023
// x := 60 ;
5015: LD_ADDR_VAR 0 2
5019: PUSH
5020: LD_INT 60
5022: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5023: LD_EXP 3
5027: PPUSH
5028: CALL_OW 274
5032: PPUSH
5033: LD_INT 3
5035: PPUSH
5036: CALL 776 0 0
5040: PUSH
5041: LD_VAR 0 2
5045: MINUS
5046: PPUSH
5047: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5051: LD_EXP 23
5055: PUSH
5056: LD_INT 3
5058: ARRAY
5059: PPUSH
5060: LD_INT 3
5062: PPUSH
5063: LD_VAR 0 2
5067: PPUSH
5068: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5072: LD_EXP 23
5076: PPUSH
5077: LD_INT 43
5079: PPUSH
5080: LD_INT 3
5082: PPUSH
5083: CALL_OW 171
// x := 0 0$20 ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: LD_INT 700
5094: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5095: LD_INT 35
5097: PPUSH
5098: CALL_OW 67
// x := x - 0 0$01 ;
5102: LD_ADDR_VAR 0 2
5106: PUSH
5107: LD_VAR 0 2
5111: PUSH
5112: LD_INT 35
5114: MINUS
5115: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5116: LD_VAR 0 2
5120: PUSH
5121: LD_INT 0
5123: EQUAL
5124: PUSH
5125: LD_EXP 23
5129: PUSH
5130: LD_INT 3
5132: ARRAY
5133: PPUSH
5134: LD_INT 43
5136: PPUSH
5137: LD_INT 3
5139: PPUSH
5140: CALL_OW 297
5144: PUSH
5145: LD_INT 4
5147: LESS
5148: PUSH
5149: LD_EXP 23
5153: PUSH
5154: LD_INT 3
5156: ARRAY
5157: PPUSH
5158: LD_INT 43
5160: PPUSH
5161: LD_INT 3
5163: PPUSH
5164: CALL_OW 297
5168: PUSH
5169: LD_INT 4
5171: LESS
5172: AND
5173: OR
5174: IFFALSE 5095
// for i in powell_trans do
5176: LD_ADDR_VAR 0 4
5180: PUSH
5181: LD_EXP 23
5185: PUSH
5186: FOR_IN
5187: IFFALSE 5200
// RemoveUnit ( i ) ;
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 64
5198: GO 5186
5200: POP
5201: POP
// if not powell_happy then
5202: LD_VAR 0 6
5206: NOT
5207: IFFALSE 5218
// powell_happy := - 1 ;
5209: LD_ADDR_VAR 0 6
5213: PUSH
5214: LD_INT 1
5216: NEG
5217: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5218: LD_VAR 0 6
5222: PPUSH
5223: LD_STRING EarlySiberite
5225: PPUSH
5226: CALL_OW 101
// if powell_happy then
5230: LD_VAR 0 6
5234: IFFALSE 5245
// ChangeMissionObjectives ( M3a ) else
5236: LD_STRING M3a
5238: PPUSH
5239: CALL_OW 337
5243: GO 5252
// ChangeMissionObjectives ( M3b ) ;
5245: LD_STRING M3b
5247: PPUSH
5248: CALL_OW 337
// ru_can_attack_terminal := true ;
5252: LD_ADDR_EXP 9
5256: PUSH
5257: LD_INT 1
5259: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5260: LD_INT 12600
5262: PPUSH
5263: CALL_OW 67
// repeat wait ( 0 0$03 ) ;
5267: LD_INT 105
5269: PPUSH
5270: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5274: LD_EXP 8
5278: NOT
5279: PUSH
5280: LD_EXP 33
5284: PUSH
5285: LD_INT 3
5287: LESS
5288: OR
5289: IFFALSE 5267
// ar_can_arrive := true ;
5291: LD_ADDR_EXP 10
5295: PUSH
5296: LD_INT 1
5298: ST_TO_ADDR
// end ;
5299: PPOPN 7
5301: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5302: LD_INT 1
5304: PPUSH
5305: LD_INT 20
5307: PPUSH
5308: CALL_OW 325
5312: IFFALSE 5453
5314: GO 5316
5316: DISABLE
5317: LD_INT 0
5319: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5320: LD_ADDR_VAR 0 1
5324: PUSH
5325: LD_INT 22
5327: PUSH
5328: LD_INT 1
5330: PUSH
5331: EMPTY
5332: LIST
5333: LIST
5334: PUSH
5335: LD_INT 26
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PUSH
5345: LD_INT 25
5347: PUSH
5348: LD_INT 4
5350: PUSH
5351: EMPTY
5352: LIST
5353: LIST
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: LIST
5359: PPUSH
5360: CALL_OW 69
5364: PUSH
5365: LD_EXP 17
5369: PUSH
5370: LD_EXP 20
5374: PUSH
5375: LD_EXP 19
5379: PUSH
5380: LD_EXP 21
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: LIST
5389: LIST
5390: DIFF
5391: ST_TO_ADDR
// if not un then
5392: LD_VAR 0 1
5396: NOT
5397: IFFALSE 5401
// exit ;
5399: GO 5453
// DialogueOn ;
5401: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5405: LD_VAR 0 1
5409: PUSH
5410: LD_INT 1
5412: ARRAY
5413: PPUSH
5414: LD_STRING D13-Sci1-1
5416: PPUSH
5417: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5421: LD_EXP 17
5425: PPUSH
5426: LD_STRING D13-JMM-1
5428: PPUSH
5429: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: LD_STRING D13-Sci1-2
5444: PPUSH
5445: CALL_OW 88
// DialogueOff ;
5449: CALL_OW 7
// end ;
5453: PPOPN 1
5455: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5456: LD_INT 1
5458: PPUSH
5459: CALL 807 0 1
5463: PUSH
5464: LD_INT 77
5466: GREATER
5467: PUSH
5468: LD_EXP 8
5472: NOT
5473: AND
5474: PUSH
5475: LD_INT 22
5477: PUSH
5478: LD_INT 1
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PUSH
5485: LD_INT 25
5487: PUSH
5488: LD_INT 4
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: PUSH
5495: LD_INT 26
5497: PUSH
5498: LD_INT 1
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: PPUSH
5510: CALL_OW 69
5514: PUSH
5515: LD_EXP 17
5519: PUSH
5520: LD_EXP 19
5524: PUSH
5525: LD_EXP 20
5529: PUSH
5530: LD_EXP 18
5534: PUSH
5535: LD_EXP 21
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: LIST
5545: LIST
5546: DIFF
5547: AND
5548: IFFALSE 5726
5550: GO 5552
5552: DISABLE
5553: LD_INT 0
5555: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5556: LD_ADDR_VAR 0 1
5560: PUSH
5561: LD_INT 22
5563: PUSH
5564: LD_INT 1
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 25
5573: PUSH
5574: LD_INT 4
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: PUSH
5581: LD_INT 26
5583: PUSH
5584: LD_INT 1
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PPUSH
5596: CALL_OW 69
5600: PUSH
5601: LD_EXP 17
5605: PUSH
5606: LD_EXP 19
5610: PUSH
5611: LD_EXP 20
5615: PUSH
5616: LD_EXP 18
5620: PUSH
5621: LD_EXP 21
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: LIST
5632: DIFF
5633: ST_TO_ADDR
// DialogueOn ;
5634: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5638: LD_VAR 0 1
5642: PUSH
5643: LD_INT 1
5645: ARRAY
5646: PPUSH
5647: LD_STRING D7-Sci1-1
5649: PPUSH
5650: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5654: LD_EXP 17
5658: PPUSH
5659: LD_STRING D7-JMM-1
5661: PPUSH
5662: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5666: LD_VAR 0 1
5670: PUSH
5671: LD_INT 1
5673: ARRAY
5674: PPUSH
5675: LD_STRING D7-Sci1-2
5677: PPUSH
5678: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5682: LD_EXP 17
5686: PPUSH
5687: LD_STRING D7-JMM-2
5689: PPUSH
5690: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5694: LD_VAR 0 1
5698: PUSH
5699: LD_INT 1
5701: ARRAY
5702: PPUSH
5703: LD_STRING D7-Sci1-3
5705: PPUSH
5706: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5710: LD_EXP 17
5714: PPUSH
5715: LD_STRING D7-JMM-3
5717: PPUSH
5718: CALL_OW 88
// DialogueOff ;
5722: CALL_OW 7
// end ;
5726: PPOPN 1
5728: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5729: LD_EXP 10
5733: IFFALSE 8987
5735: GO 5737
5737: DISABLE
5738: LD_INT 0
5740: PPUSH
5741: PPUSH
5742: PPUSH
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
5747: PPUSH
// begin PrepareArabian ;
5748: CALL 11244 0 0
// repeat wait ( 0 0$01 ) ;
5752: LD_INT 35
5754: PPUSH
5755: CALL_OW 67
// until ar_spawned ;
5759: LD_EXP 11
5763: IFFALSE 5752
// DialogueOn ;
5765: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5769: LD_EXP 25
5773: PPUSH
5774: LD_STRING D8-Ar1-1
5776: PPUSH
5777: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5781: LD_EXP 17
5785: PPUSH
5786: LD_STRING D8-JMM-1
5788: PPUSH
5789: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5793: LD_EXP 25
5797: PPUSH
5798: LD_STRING D8-Ar1-2
5800: PPUSH
5801: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
5805: LD_EXP 17
5809: PPUSH
5810: LD_STRING D8-JMM-2
5812: PPUSH
5813: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
5817: LD_EXP 25
5821: PPUSH
5822: LD_STRING D8-Ar1-3
5824: PPUSH
5825: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
5829: LD_EXP 17
5833: PPUSH
5834: LD_STRING D8-JMM-3
5836: PPUSH
5837: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
5841: LD_EXP 25
5845: PPUSH
5846: LD_STRING D8-Ar1-4
5848: PPUSH
5849: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
5853: LD_EXP 17
5857: PPUSH
5858: LD_STRING D8-JMM-4
5860: PPUSH
5861: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
5865: LD_EXP 25
5869: PPUSH
5870: LD_STRING D8-Ar1-5
5872: PPUSH
5873: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
5877: LD_EXP 17
5881: PPUSH
5882: LD_STRING D8-JMM-5
5884: PPUSH
5885: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
5889: LD_EXP 25
5893: PPUSH
5894: LD_STRING D8-Ar1-6
5896: PPUSH
5897: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
5901: LD_EXP 26
5905: PPUSH
5906: LD_STRING D8-Ar2-6
5908: PPUSH
5909: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
5913: LD_EXP 17
5917: PPUSH
5918: LD_STRING D8-JMM-6
5920: PPUSH
5921: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
5925: LD_EXP 26
5929: PPUSH
5930: LD_STRING D8-Ar2-7
5932: PPUSH
5933: CALL_OW 94
// case Query ( QBarracks ) of 1 :
5937: LD_STRING QBarracks
5939: PPUSH
5940: CALL_OW 97
5944: PUSH
5945: LD_INT 1
5947: DOUBLE
5948: EQUAL
5949: IFTRUE 5953
5951: GO 5988
5953: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
5954: LD_EXP 17
5958: PPUSH
5959: LD_STRING D8a-JMM-1
5961: PPUSH
5962: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
5966: LD_EXP 25
5970: PPUSH
5971: LD_STRING D8a-Ar1-1
5973: PPUSH
5974: CALL_OW 94
// player_want_mortar := true ;
5978: LD_ADDR_EXP 12
5982: PUSH
5983: LD_INT 1
5985: ST_TO_ADDR
// end ; 2 :
5986: GO 6146
5988: LD_INT 2
5990: DOUBLE
5991: EQUAL
5992: IFTRUE 5996
5994: GO 6110
5996: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
5997: LD_EXP 17
6001: PPUSH
6002: LD_STRING D8b-JMM-1
6004: PPUSH
6005: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6009: LD_EXP 25
6013: PPUSH
6014: LD_STRING D8b-Ar1-1
6016: PPUSH
6017: CALL_OW 94
// case Query ( QInfo ) of 1 :
6021: LD_STRING QInfo
6023: PPUSH
6024: CALL_OW 97
6028: PUSH
6029: LD_INT 1
6031: DOUBLE
6032: EQUAL
6033: IFTRUE 6037
6035: GO 6072
6037: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6038: LD_EXP 17
6042: PPUSH
6043: LD_STRING D8b1-JMM-1
6045: PPUSH
6046: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6050: LD_EXP 25
6054: PPUSH
6055: LD_STRING D8b1-Ar1-1
6057: PPUSH
6058: CALL_OW 94
// player_want_info := 2 ;
6062: LD_ADDR_EXP 13
6066: PUSH
6067: LD_INT 2
6069: ST_TO_ADDR
// end ; 2 :
6070: GO 6108
6072: LD_INT 2
6074: DOUBLE
6075: EQUAL
6076: IFTRUE 6080
6078: GO 6107
6080: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6081: LD_EXP 17
6085: PPUSH
6086: LD_STRING D8b2-JMM-1
6088: PPUSH
6089: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6093: LD_EXP 25
6097: PPUSH
6098: LD_STRING D8b2-Ar1-1
6100: PPUSH
6101: CALL_OW 94
// end ; end ;
6105: GO 6108
6107: POP
// end ; 3 :
6108: GO 6146
6110: LD_INT 3
6112: DOUBLE
6113: EQUAL
6114: IFTRUE 6118
6116: GO 6145
6118: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6119: LD_EXP 17
6123: PPUSH
6124: LD_STRING D8c-JMM-1
6126: PPUSH
6127: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6131: LD_EXP 25
6135: PPUSH
6136: LD_STRING D8c-Ar1-1
6138: PPUSH
6139: CALL_OW 94
// end ; end ;
6143: GO 6146
6145: POP
// DialogueOff ;
6146: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6150: LD_ADDR_VAR 0 4
6154: PUSH
6155: LD_INT 22
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: LD_INT 30
6170: PUSH
6171: LD_INT 0
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: LD_INT 30
6180: PUSH
6181: LD_INT 1
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PPUSH
6197: CALL_OW 69
6201: PPUSH
6202: LD_EXP 26
6206: PPUSH
6207: CALL_OW 74
6211: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6212: LD_ADDR_VAR 0 3
6216: PUSH
6217: LD_INT 22
6219: PUSH
6220: LD_INT 2
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 21
6229: PUSH
6230: LD_INT 2
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PPUSH
6241: CALL_OW 69
6245: ST_TO_ADDR
// time := 1 1$35 ;
6246: LD_ADDR_VAR 0 5
6250: PUSH
6251: LD_INT 3325
6253: ST_TO_ADDR
// no_oil_gain := false ;
6254: LD_ADDR_VAR 0 6
6258: PUSH
6259: LD_INT 0
6261: ST_TO_ADDR
// first_warn := false ;
6262: LD_ADDR_VAR 0 7
6266: PUSH
6267: LD_INT 0
6269: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6270: LD_EXP 12
6274: PUSH
6275: LD_EXP 13
6279: OR
6280: IFFALSE 6385
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6282: LD_EXP 32
6286: PPUSH
6287: LD_INT 25
6289: PUSH
6290: LD_INT 1
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: PPUSH
6302: LD_VAR 0 4
6306: PPUSH
6307: CALL_OW 250
6311: PPUSH
6312: LD_VAR 0 4
6316: PPUSH
6317: CALL_OW 251
6321: PPUSH
6322: LD_VAR 0 4
6326: PPUSH
6327: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6331: LD_EXP 32
6335: PPUSH
6336: LD_INT 25
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: PPUSH
6346: CALL_OW 72
6350: PPUSH
6351: LD_INT 86
6353: PPUSH
6354: LD_INT 121
6356: PPUSH
6357: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6361: LD_EXP 32
6365: PPUSH
6366: LD_INT 25
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PPUSH
6376: CALL_OW 72
6380: PPUSH
6381: CALL_OW 200
// end ; if player_attacked_ar then
6385: LD_EXP 16
6389: IFFALSE 6393
// exit ;
6391: GO 8987
// if player_want_mortar then
6393: LD_EXP 12
6397: IFFALSE 7789
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6399: LD_EXP 26
6403: PPUSH
6404: LD_VAR 0 4
6408: PPUSH
6409: CALL_OW 250
6413: PUSH
6414: LD_INT 1
6416: PLUS
6417: PPUSH
6418: LD_VAR 0 4
6422: PPUSH
6423: CALL_OW 251
6427: PUSH
6428: LD_INT 1
6430: PLUS
6431: PPUSH
6432: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6436: LD_INT 35
6438: PPUSH
6439: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6443: LD_EXP 26
6447: PPUSH
6448: LD_VAR 0 4
6452: PPUSH
6453: CALL_OW 296
6457: PUSH
6458: LD_INT 4
6460: LESS
6461: IFFALSE 6436
// for i = 1 to 6 do
6463: LD_ADDR_VAR 0 1
6467: PUSH
6468: DOUBLE
6469: LD_INT 1
6471: DEC
6472: ST_TO_ADDR
6473: LD_INT 6
6475: PUSH
6476: FOR_TO
6477: IFFALSE 6674
// begin if player_attacked_ar then
6479: LD_EXP 16
6483: IFFALSE 6489
// exit ;
6485: POP
6486: POP
6487: GO 8987
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6489: LD_VAR 0 4
6493: PPUSH
6494: CALL_OW 274
6498: PPUSH
6499: LD_INT 2
6501: PPUSH
6502: CALL_OW 275
6506: PUSH
6507: LD_INT 10
6509: LESS
6510: PUSH
6511: LD_VAR 0 7
6515: NOT
6516: AND
6517: IFFALSE 6580
// begin first_warn := true ;
6519: LD_ADDR_VAR 0 7
6523: PUSH
6524: LD_INT 1
6526: ST_TO_ADDR
// DialogueOn ;
6527: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6531: LD_EXP 27
6535: PPUSH
6536: LD_STRING D9a-FAr1-1
6538: PPUSH
6539: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6543: LD_EXP 17
6547: PPUSH
6548: LD_STRING D9a-JMM-1
6550: PPUSH
6551: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6555: LD_EXP 25
6559: PPUSH
6560: LD_STRING D9a2-Ar1-1
6562: PPUSH
6563: CALL_OW 88
// DialogueOff ;
6567: CALL_OW 7
// wait ( time ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6580: LD_VAR 0 4
6584: PPUSH
6585: CALL_OW 274
6589: PPUSH
6590: LD_INT 2
6592: PPUSH
6593: CALL_OW 275
6597: PUSH
6598: LD_INT 10
6600: LESS
6601: IFFALSE 6627
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6603: LD_EXP 25
6607: PPUSH
6608: LD_STRING D9a3-Ar1-1
6610: PPUSH
6611: CALL_OW 88
// no_oil_gain := true ;
6615: LD_ADDR_VAR 0 6
6619: PUSH
6620: LD_INT 1
6622: ST_TO_ADDR
// break ;
6623: GO 6674
// end else
6625: GO 6672
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6627: LD_EXP 26
6631: PPUSH
6632: LD_VAR 0 4
6636: PPUSH
6637: LD_INT 2
6639: PPUSH
6640: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6644: LD_EXP 26
6648: PPUSH
6649: LD_VAR 0 3
6653: PUSH
6654: LD_VAR 0 1
6658: PUSH
6659: LD_INT 3
6661: MOD
6662: PUSH
6663: LD_INT 1
6665: PLUS
6666: ARRAY
6667: PPUSH
6668: CALL_OW 210
// end ; end ;
6672: GO 6476
6674: POP
6675: POP
// if not no_oil_gain then
6676: LD_VAR 0 6
6680: NOT
6681: IFFALSE 7789
// begin repeat wait ( 0 0$01 ) ;
6683: LD_INT 35
6685: PPUSH
6686: CALL_OW 67
// if player_attacked_ar then
6690: LD_EXP 16
6694: IFFALSE 6698
// exit ;
6696: GO 8987
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6698: LD_VAR 0 3
6702: PUSH
6703: LD_INT 1
6705: ARRAY
6706: PPUSH
6707: CALL_OW 261
6711: PUSH
6712: LD_INT 80
6714: GREATER
6715: PUSH
6716: LD_VAR 0 3
6720: PUSH
6721: LD_INT 2
6723: ARRAY
6724: PPUSH
6725: CALL_OW 261
6729: PUSH
6730: LD_INT 80
6732: GREATER
6733: AND
6734: PUSH
6735: LD_VAR 0 3
6739: PUSH
6740: LD_INT 3
6742: ARRAY
6743: PPUSH
6744: CALL_OW 261
6748: PUSH
6749: LD_INT 80
6751: GREATER
6752: AND
6753: IFFALSE 6683
// ComMoveXY ( Gali , 105 , 127 ) ;
6755: LD_EXP 26
6759: PPUSH
6760: LD_INT 105
6762: PPUSH
6763: LD_INT 127
6765: PPUSH
6766: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6770: LD_EXP 26
6774: PPUSH
6775: LD_INT 2
6777: PPUSH
6778: CALL_OW 173
// AddComHold ( Gali ) ;
6782: LD_EXP 26
6786: PPUSH
6787: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6791: LD_INT 35
6793: PPUSH
6794: CALL_OW 67
// if player_attacked_ar then
6798: LD_EXP 16
6802: IFFALSE 6806
// exit ;
6804: GO 8987
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
6806: LD_EXP 26
6810: PPUSH
6811: LD_INT 105
6813: PPUSH
6814: LD_INT 127
6816: PPUSH
6817: CALL_OW 297
6821: PUSH
6822: LD_INT 4
6824: LESS
6825: IFFALSE 6791
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6827: LD_VAR 0 4
6831: PPUSH
6832: CALL_OW 274
6836: PPUSH
6837: LD_INT 1
6839: PPUSH
6840: CALL_OW 275
6844: PUSH
6845: LD_INT 50
6847: LESS
6848: IFFALSE 7144
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
6850: LD_VAR 0 4
6854: PPUSH
6855: CALL_OW 274
6859: PPUSH
6860: LD_INT 1
6862: PPUSH
6863: CALL_OW 275
6867: PUSH
6868: LD_INT 0
6870: DOUBLE
6871: GREATEREQUAL
6872: IFFALSE 6880
6874: LD_INT 24
6876: DOUBLE
6877: LESSEQUAL
6878: IFTRUE 6882
6880: GO 6897
6882: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
6883: LD_EXP 26
6887: PPUSH
6888: LD_STRING D9b-Ar2-1
6890: PPUSH
6891: CALL_OW 88
6895: GO 6927
6897: LD_INT 25
6899: DOUBLE
6900: GREATEREQUAL
6901: IFFALSE 6909
6903: LD_INT 49
6905: DOUBLE
6906: LESSEQUAL
6907: IFTRUE 6911
6909: GO 6926
6911: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
6912: LD_EXP 26
6916: PPUSH
6917: LD_STRING D9b-Ar2-1a
6919: PPUSH
6920: CALL_OW 88
6924: GO 6927
6926: POP
// Say ( JMM , D9b-JMM-1 ) ;
6927: LD_EXP 17
6931: PPUSH
6932: LD_STRING D9b-JMM-1
6934: PPUSH
6935: CALL_OW 88
// x := 0 0$0 ;
6939: LD_ADDR_VAR 0 2
6943: PUSH
6944: LD_INT 0
6946: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6947: LD_INT 35
6949: PPUSH
6950: CALL_OW 67
// x := x + 0 0$1 ;
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 35
6966: PLUS
6967: ST_TO_ADDR
// if player_attacked_ar then
6968: LD_EXP 16
6972: IFFALSE 6976
// exit ;
6974: GO 8987
// until x >= time ;
6976: LD_VAR 0 2
6980: PUSH
6981: LD_VAR 0 5
6985: GREATEREQUAL
6986: IFFALSE 6947
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6988: LD_VAR 0 4
6992: PPUSH
6993: CALL_OW 274
6997: PPUSH
6998: LD_INT 1
7000: PPUSH
7001: CALL_OW 275
7005: PUSH
7006: LD_INT 50
7008: LESS
7009: IFFALSE 7142
// begin DialogueOn ;
7011: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7015: LD_EXP 25
7019: PPUSH
7020: LD_STRING D9c-Ar1-1
7022: PPUSH
7023: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7027: LD_EXP 17
7031: PPUSH
7032: LD_STRING D9c-JMM-1
7034: PPUSH
7035: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7039: LD_EXP 25
7043: PPUSH
7044: LD_STRING D9c-Ar1-2
7046: PPUSH
7047: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7051: LD_EXP 27
7055: PPUSH
7056: LD_STRING D9c-FAr1-2
7058: PPUSH
7059: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7063: LD_EXP 25
7067: PPUSH
7068: LD_STRING D9c-Ar1-3
7070: PPUSH
7071: CALL_OW 88
// case Query ( QInfo ) of 1 :
7075: LD_STRING QInfo
7077: PPUSH
7078: CALL_OW 97
7082: PUSH
7083: LD_INT 1
7085: DOUBLE
7086: EQUAL
7087: IFTRUE 7091
7089: GO 7114
7091: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7092: LD_EXP 17
7096: PPUSH
7097: LD_STRING D8b1-JMM-1
7099: PPUSH
7100: CALL_OW 88
// player_want_info := 2 ;
7104: LD_ADDR_EXP 13
7108: PUSH
7109: LD_INT 2
7111: ST_TO_ADDR
// end ; 2 :
7112: GO 7138
7114: LD_INT 2
7116: DOUBLE
7117: EQUAL
7118: IFTRUE 7122
7120: GO 7137
7122: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7123: LD_EXP 25
7127: PPUSH
7128: LD_STRING D8b2-Ar1-1
7130: PPUSH
7131: CALL_OW 88
// end ; end ;
7135: GO 7138
7137: POP
// DialogueOff ;
7138: CALL_OW 7
// end ; end else
7142: GO 7789
// begin RemoveEnvironmentArea ( mortarArea ) ;
7144: LD_INT 2
7146: PPUSH
7147: CALL_OW 355
// wait ( 1 ) ;
7151: LD_INT 1
7153: PPUSH
7154: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7158: LD_EXP 26
7162: PPUSH
7163: LD_INT 1
7165: PPUSH
7166: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7170: LD_EXP 26
7174: PPUSH
7175: LD_INT 4
7177: PPUSH
7178: LD_INT 107
7180: PPUSH
7181: LD_INT 131
7183: PPUSH
7184: LD_INT 0
7186: PPUSH
7187: CALL_OW 145
// repeat wait ( 1 ) ;
7191: LD_INT 1
7193: PPUSH
7194: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7198: LD_INT 30
7200: PUSH
7201: LD_INT 4
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 23
7210: PUSH
7211: LD_INT 2
7213: PUSH
7214: EMPTY
7215: LIST
7216: LIST
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PPUSH
7222: CALL_OW 69
7226: IFFALSE 7191
// SetSide ( Gali , 2 ) ;
7228: LD_EXP 26
7232: PPUSH
7233: LD_INT 2
7235: PPUSH
7236: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7240: LD_ADDR_VAR 0 8
7244: PUSH
7245: LD_INT 30
7247: PUSH
7248: LD_INT 4
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PUSH
7255: LD_INT 23
7257: PUSH
7258: LD_INT 2
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PPUSH
7269: CALL_OW 69
7273: PUSH
7274: LD_INT 1
7276: ARRAY
7277: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7278: LD_INT 35
7280: PPUSH
7281: CALL_OW 67
// if player_attacked_ar then
7285: LD_EXP 16
7289: IFFALSE 7293
// exit ;
7291: GO 8987
// until BuildingStatus ( b ) <> bs_build ;
7293: LD_VAR 0 8
7297: PPUSH
7298: CALL_OW 461
7302: PUSH
7303: LD_INT 1
7305: NONEQUAL
7306: IFFALSE 7278
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7308: LD_VAR 0 8
7312: PPUSH
7313: CALL_OW 302
7317: PUSH
7318: LD_VAR 0 4
7322: PPUSH
7323: CALL_OW 274
7327: PPUSH
7328: LD_INT 1
7330: PPUSH
7331: CALL_OW 275
7335: PUSH
7336: LD_INT 25
7338: GREATEREQUAL
7339: AND
7340: IFFALSE 7439
// begin ComUpgrade ( b ) ;
7342: LD_VAR 0 8
7346: PPUSH
7347: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7351: LD_EXP 26
7355: PPUSH
7356: LD_STRING h
7358: PUSH
7359: LD_VAR 0 8
7363: PPUSH
7364: CALL_OW 250
7368: PUSH
7369: LD_VAR 0 8
7373: PPUSH
7374: CALL_OW 251
7378: PUSH
7379: LD_VAR 0 8
7383: PUSH
7384: LD_INT 0
7386: PUSH
7387: LD_INT 0
7389: PUSH
7390: LD_INT 0
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: PUSH
7402: EMPTY
7403: LIST
7404: PPUSH
7405: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7409: LD_INT 35
7411: PPUSH
7412: CALL_OW 67
// if player_attacked_ar then
7416: LD_EXP 16
7420: IFFALSE 7424
// exit ;
7422: GO 8987
// until BuildingStatus ( b ) <> bs_build ;
7424: LD_VAR 0 8
7428: PPUSH
7429: CALL_OW 461
7433: PUSH
7434: LD_INT 1
7436: NONEQUAL
7437: IFFALSE 7409
// end ; if b then
7439: LD_VAR 0 8
7443: IFFALSE 7454
// CenterNowOnUnits ( b ) ;
7445: LD_VAR 0 8
7449: PPUSH
7450: CALL_OW 87
// DialogueOn ;
7454: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7458: LD_EXP 26
7462: PPUSH
7463: LD_STRING D9d-Ar2-1
7465: PPUSH
7466: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7470: LD_EXP 25
7474: PPUSH
7475: LD_STRING D9d-Ar1-1
7477: PPUSH
7478: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7482: LD_EXP 17
7486: PPUSH
7487: LD_STRING D9d-JMM-1
7489: PPUSH
7490: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7494: LD_EXP 25
7498: PPUSH
7499: LD_STRING D9d-Ar1-2
7501: PPUSH
7502: CALL_OW 88
// DialogueOff ;
7506: CALL_OW 7
// i := [ ] ;
7510: LD_ADDR_VAR 0 1
7514: PUSH
7515: EMPTY
7516: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7517: LD_VAR 0 4
7521: PPUSH
7522: CALL_OW 274
7526: PPUSH
7527: LD_INT 3
7529: PPUSH
7530: CALL_OW 275
7534: PUSH
7535: LD_INT 20
7537: GREATEREQUAL
7538: IFFALSE 7557
// i := i ^ [ 1 ] ;
7540: LD_ADDR_VAR 0 1
7544: PUSH
7545: LD_VAR 0 1
7549: PUSH
7550: LD_INT 1
7552: PUSH
7553: EMPTY
7554: LIST
7555: ADD
7556: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7557: LD_VAR 0 4
7561: PPUSH
7562: CALL_OW 274
7566: PPUSH
7567: LD_INT 1
7569: PPUSH
7570: CALL_OW 275
7574: PUSH
7575: LD_INT 50
7577: GREATEREQUAL
7578: IFFALSE 7597
// i := i ^ [ 2 ] ;
7580: LD_ADDR_VAR 0 1
7584: PUSH
7585: LD_VAR 0 1
7589: PUSH
7590: LD_INT 2
7592: PUSH
7593: EMPTY
7594: LIST
7595: ADD
7596: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7597: LD_VAR 0 4
7601: PPUSH
7602: CALL_OW 274
7606: PPUSH
7607: LD_INT 2
7609: PPUSH
7610: CALL_OW 275
7614: PUSH
7615: LD_INT 80
7617: GREATEREQUAL
7618: IFFALSE 7637
// i := i ^ [ 3 ] ;
7620: LD_ADDR_VAR 0 1
7624: PUSH
7625: LD_VAR 0 1
7629: PUSH
7630: LD_INT 3
7632: PUSH
7633: EMPTY
7634: LIST
7635: ADD
7636: ST_TO_ADDR
// i := i diff 0 ;
7637: LD_ADDR_VAR 0 1
7641: PUSH
7642: LD_VAR 0 1
7646: PUSH
7647: LD_INT 0
7649: DIFF
7650: ST_TO_ADDR
// if i then
7651: LD_VAR 0 1
7655: IFFALSE 7761
// begin i := i ^ [ 4 ] ;
7657: LD_ADDR_VAR 0 1
7661: PUSH
7662: LD_VAR 0 1
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: EMPTY
7671: LIST
7672: ADD
7673: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7674: LD_STRING QInfo2
7676: PPUSH
7677: CALL_OW 97
7681: PUSH
7682: LD_INT 1
7684: DOUBLE
7685: EQUAL
7686: IFTRUE 7690
7688: GO 7701
7690: POP
// player_want_info := 3 ; 2 :
7691: LD_ADDR_EXP 13
7695: PUSH
7696: LD_INT 3
7698: ST_TO_ADDR
7699: GO 7759
7701: LD_INT 2
7703: DOUBLE
7704: EQUAL
7705: IFTRUE 7709
7707: GO 7720
7709: POP
// player_want_info := 1 ; 3 :
7710: LD_ADDR_EXP 13
7714: PUSH
7715: LD_INT 1
7717: ST_TO_ADDR
7718: GO 7759
7720: LD_INT 3
7722: DOUBLE
7723: EQUAL
7724: IFTRUE 7728
7726: GO 7739
7728: POP
// player_want_info := 2 ; 4 :
7729: LD_ADDR_EXP 13
7733: PUSH
7734: LD_INT 2
7736: ST_TO_ADDR
7737: GO 7759
7739: LD_INT 4
7741: DOUBLE
7742: EQUAL
7743: IFTRUE 7747
7745: GO 7758
7747: POP
// player_want_info := 0 ; end ;
7748: LD_ADDR_EXP 13
7752: PUSH
7753: LD_INT 0
7755: ST_TO_ADDR
7756: GO 7759
7758: POP
// end else
7759: GO 7789
// case Query ( QInfoNothing ) of 1 :
7761: LD_STRING QInfoNothing
7763: PPUSH
7764: CALL_OW 97
7768: PUSH
7769: LD_INT 1
7771: DOUBLE
7772: EQUAL
7773: IFTRUE 7777
7775: GO 7788
7777: POP
// player_want_info := 0 ; end ;
7778: LD_ADDR_EXP 13
7782: PUSH
7783: LD_INT 0
7785: ST_TO_ADDR
7786: GO 7789
7788: POP
// end ; end ; end ; if player_want_info then
7789: LD_EXP 13
7793: IFFALSE 8807
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7795: LD_ADDR_VAR 0 3
7799: PUSH
7800: LD_VAR 0 3
7804: PPUSH
7805: LD_INT 34
7807: PUSH
7808: LD_INT 32
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PPUSH
7815: CALL_OW 72
7819: ST_TO_ADDR
// if player_want_mortar then
7820: LD_EXP 12
7824: IFFALSE 8146
// begin case player_want_info of 1 :
7826: LD_EXP 13
7830: PUSH
7831: LD_INT 1
7833: DOUBLE
7834: EQUAL
7835: IFTRUE 7839
7837: GO 7850
7839: POP
// x := 5 ; 2 :
7840: LD_ADDR_VAR 0 2
7844: PUSH
7845: LD_INT 5
7847: ST_TO_ADDR
7848: GO 7889
7850: LD_INT 2
7852: DOUBLE
7853: EQUAL
7854: IFTRUE 7858
7856: GO 7869
7858: POP
// x := 8 ; 3 :
7859: LD_ADDR_VAR 0 2
7863: PUSH
7864: LD_INT 8
7866: ST_TO_ADDR
7867: GO 7889
7869: LD_INT 3
7871: DOUBLE
7872: EQUAL
7873: IFTRUE 7877
7875: GO 7888
7877: POP
// x := 2 ; end ;
7878: LD_ADDR_VAR 0 2
7882: PUSH
7883: LD_INT 2
7885: ST_TO_ADDR
7886: GO 7889
7888: POP
// repeat wait ( 0 0$1 ) ;
7889: LD_INT 35
7891: PPUSH
7892: CALL_OW 67
// until not HasTask ( Gali ) ;
7896: LD_EXP 26
7900: PPUSH
7901: CALL_OW 314
7905: NOT
7906: IFFALSE 7889
// for i = 1 to x do
7908: LD_ADDR_VAR 0 1
7912: PUSH
7913: DOUBLE
7914: LD_INT 1
7916: DEC
7917: ST_TO_ADDR
7918: LD_VAR 0 2
7922: PUSH
7923: FOR_TO
7924: IFFALSE 8089
// begin AddComTransport ( Gali , dep , player_want_info ) ;
7926: LD_EXP 26
7930: PPUSH
7931: LD_VAR 0 4
7935: PPUSH
7936: LD_EXP 13
7940: PPUSH
7941: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
7945: LD_EXP 26
7949: PPUSH
7950: LD_VAR 0 3
7954: PUSH
7955: LD_INT 1
7957: ARRAY
7958: PPUSH
7959: CALL_OW 172
// AddComHold ( Gali ) ;
7963: LD_EXP 26
7967: PPUSH
7968: CALL_OW 200
// repeat wait ( 3 ) ;
7972: LD_INT 3
7974: PPUSH
7975: CALL_OW 67
// if player_attacked_ar then
7979: LD_EXP 16
7983: IFFALSE 7989
// exit ;
7985: POP
7986: POP
7987: GO 8987
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
7989: LD_EXP 26
7993: PPUSH
7994: LD_VAR 0 3
7998: PUSH
7999: LD_INT 1
8001: ARRAY
8002: PPUSH
8003: CALL_OW 296
8007: PUSH
8008: LD_INT 4
8010: LESS
8011: PUSH
8012: LD_EXP 26
8016: PPUSH
8017: LD_EXP 13
8021: PPUSH
8022: CALL_OW 289
8026: AND
8027: IFFALSE 7972
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8029: LD_VAR 0 3
8033: PUSH
8034: LD_INT 1
8036: ARRAY
8037: PPUSH
8038: LD_EXP 13
8042: PPUSH
8043: LD_VAR 0 3
8047: PUSH
8048: LD_INT 1
8050: ARRAY
8051: PPUSH
8052: LD_EXP 13
8056: PPUSH
8057: CALL_OW 289
8061: PUSH
8062: LD_INT 10
8064: PLUS
8065: PPUSH
8066: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8070: LD_EXP 26
8074: PPUSH
8075: LD_EXP 13
8079: PPUSH
8080: LD_INT 0
8082: PPUSH
8083: CALL_OW 290
// end ;
8087: GO 7923
8089: POP
8090: POP
// repeat wait ( 0 0$1 ) ;
8091: LD_INT 35
8093: PPUSH
8094: CALL_OW 67
// if player_attacked_ar then
8098: LD_EXP 16
8102: IFFALSE 8106
// exit ;
8104: GO 8987
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8106: LD_VAR 0 3
8110: PUSH
8111: LD_INT 1
8113: ARRAY
8114: PPUSH
8115: LD_EXP 13
8119: PPUSH
8120: CALL_OW 289
8124: PUSH
8125: LD_VAR 0 2
8129: PUSH
8130: LD_INT 10
8132: MUL
8133: EQUAL
8134: IFFALSE 8091
// no_oil_gain := false ;
8136: LD_ADDR_VAR 0 6
8140: PUSH
8141: LD_INT 0
8143: ST_TO_ADDR
// end else
8144: GO 8628
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8146: LD_ADDR_VAR 0 3
8150: PUSH
8151: LD_INT 22
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 21
8163: PUSH
8164: LD_INT 2
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: PPUSH
8175: CALL_OW 69
8179: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8180: LD_EXP 26
8184: PPUSH
8185: LD_VAR 0 4
8189: PPUSH
8190: CALL_OW 250
8194: PUSH
8195: LD_INT 1
8197: PLUS
8198: PPUSH
8199: LD_VAR 0 4
8203: PPUSH
8204: CALL_OW 251
8208: PUSH
8209: LD_INT 1
8211: PLUS
8212: PPUSH
8213: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8217: LD_INT 35
8219: PPUSH
8220: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8224: LD_EXP 26
8228: PPUSH
8229: LD_VAR 0 4
8233: PPUSH
8234: CALL_OW 296
8238: PUSH
8239: LD_INT 4
8241: LESS
8242: IFFALSE 8217
// for i = 1 to 6 do
8244: LD_ADDR_VAR 0 1
8248: PUSH
8249: DOUBLE
8250: LD_INT 1
8252: DEC
8253: ST_TO_ADDR
8254: LD_INT 6
8256: PUSH
8257: FOR_TO
8258: IFFALSE 8455
// begin if player_attacked_ar then
8260: LD_EXP 16
8264: IFFALSE 8270
// exit ;
8266: POP
8267: POP
8268: GO 8987
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8270: LD_VAR 0 4
8274: PPUSH
8275: CALL_OW 274
8279: PPUSH
8280: LD_INT 2
8282: PPUSH
8283: CALL_OW 275
8287: PUSH
8288: LD_INT 10
8290: LESS
8291: PUSH
8292: LD_VAR 0 7
8296: NOT
8297: AND
8298: IFFALSE 8361
// begin first_warn := true ;
8300: LD_ADDR_VAR 0 7
8304: PUSH
8305: LD_INT 1
8307: ST_TO_ADDR
// DialogueOn ;
8308: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8312: LD_EXP 27
8316: PPUSH
8317: LD_STRING D9a-FAr1-1
8319: PPUSH
8320: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8324: LD_EXP 17
8328: PPUSH
8329: LD_STRING D9a-JMM-1
8331: PPUSH
8332: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8336: LD_EXP 25
8340: PPUSH
8341: LD_STRING D9a2-Ar1-1
8343: PPUSH
8344: CALL_OW 88
// DialogueOff ;
8348: CALL_OW 7
// wait ( time ) ;
8352: LD_VAR 0 5
8356: PPUSH
8357: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8361: LD_VAR 0 4
8365: PPUSH
8366: CALL_OW 274
8370: PPUSH
8371: LD_INT 2
8373: PPUSH
8374: CALL_OW 275
8378: PUSH
8379: LD_INT 10
8381: LESS
8382: IFFALSE 8408
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8384: LD_EXP 25
8388: PPUSH
8389: LD_STRING D9a3-Ar1-1
8391: PPUSH
8392: CALL_OW 88
// no_oil_gain := true ;
8396: LD_ADDR_VAR 0 6
8400: PUSH
8401: LD_INT 1
8403: ST_TO_ADDR
// break ;
8404: GO 8455
// end else
8406: GO 8453
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8408: LD_EXP 26
8412: PPUSH
8413: LD_VAR 0 4
8417: PPUSH
8418: LD_INT 2
8420: PPUSH
8421: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8425: LD_EXP 26
8429: PPUSH
8430: LD_VAR 0 3
8434: PUSH
8435: LD_VAR 0 1
8439: PUSH
8440: LD_INT 3
8442: MOD
8443: PUSH
8444: LD_INT 1
8446: PLUS
8447: ARRAY
8448: PPUSH
8449: CALL_OW 210
// end ; end ;
8453: GO 8257
8455: POP
8456: POP
// repeat wait ( 0 0$1 ) ;
8457: LD_INT 35
8459: PPUSH
8460: CALL_OW 67
// if player_attacked_ar then
8464: LD_EXP 16
8468: IFFALSE 8472
// exit ;
8470: GO 8987
// for i in tmp do
8472: LD_ADDR_VAR 0 1
8476: PUSH
8477: LD_VAR 0 3
8481: PUSH
8482: FOR_IN
8483: IFFALSE 8514
// if GetFuel ( i ) < 100 then
8485: LD_VAR 0 1
8489: PPUSH
8490: CALL_OW 261
8494: PUSH
8495: LD_INT 100
8497: LESS
8498: IFFALSE 8512
// begin x := i ;
8500: LD_ADDR_VAR 0 2
8504: PUSH
8505: LD_VAR 0 1
8509: ST_TO_ADDR
// break ;
8510: GO 8514
// end ;
8512: GO 8482
8514: POP
8515: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8516: LD_EXP 26
8520: PPUSH
8521: CALL_OW 314
8525: NOT
8526: PUSH
8527: LD_EXP 26
8531: PPUSH
8532: CALL_OW 281
8536: NOT
8537: AND
8538: IFFALSE 8571
// begin ComTransport ( Gali , dep , mat_oil ) ;
8540: LD_EXP 26
8544: PPUSH
8545: LD_VAR 0 4
8549: PPUSH
8550: LD_INT 2
8552: PPUSH
8553: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8557: LD_EXP 26
8561: PPUSH
8562: LD_VAR 0 2
8566: PPUSH
8567: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8571: LD_VAR 0 3
8575: PUSH
8576: LD_INT 1
8578: ARRAY
8579: PPUSH
8580: CALL_OW 261
8584: PUSH
8585: LD_INT 80
8587: GREATER
8588: PUSH
8589: LD_VAR 0 3
8593: PUSH
8594: LD_INT 2
8596: ARRAY
8597: PPUSH
8598: CALL_OW 261
8602: PUSH
8603: LD_INT 80
8605: GREATER
8606: AND
8607: PUSH
8608: LD_VAR 0 3
8612: PUSH
8613: LD_INT 3
8615: ARRAY
8616: PPUSH
8617: CALL_OW 261
8621: PUSH
8622: LD_INT 80
8624: GREATER
8625: AND
8626: IFFALSE 8457
// end ; ComHold ( Gali ) ;
8628: LD_EXP 26
8632: PPUSH
8633: CALL_OW 140
// if not no_oil_gain then
8637: LD_VAR 0 6
8641: NOT
8642: IFFALSE 8807
// begin DialogueOn ;
8644: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8648: LD_EXP 25
8652: PPUSH
8653: CALL_OW 87
// if player_want_mortar then
8657: LD_EXP 12
8661: IFFALSE 8687
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8663: LD_EXP 25
8667: PPUSH
8668: LD_STRING D9e-Ar1-1
8670: PPUSH
8671: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8675: LD_EXP 17
8679: PPUSH
8680: LD_STRING D10a-JMM-1
8682: PPUSH
8683: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8687: LD_EXP 25
8691: PPUSH
8692: LD_STRING D10a-Ar1-1
8694: PPUSH
8695: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8699: LD_EXP 26
8703: PPUSH
8704: LD_STRING D10a-Ar2-1
8706: PPUSH
8707: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8711: LD_EXP 27
8715: PPUSH
8716: LD_STRING D10a-FAr1-1
8718: PPUSH
8719: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8723: LD_EXP 26
8727: PPUSH
8728: LD_STRING D10a-Ar2-2
8730: PPUSH
8731: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8735: LD_EXP 27
8739: PPUSH
8740: LD_STRING D10a-FAr1-2
8742: PPUSH
8743: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8747: LD_EXP 25
8751: PPUSH
8752: LD_STRING D10a-Ar1-2
8754: PPUSH
8755: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8759: LD_EXP 17
8763: PPUSH
8764: LD_STRING D10a-JMM-2
8766: PPUSH
8767: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8771: LD_EXP 25
8775: PPUSH
8776: LD_STRING D10a-Ar1-3
8778: PPUSH
8779: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8783: LD_EXP 17
8787: PPUSH
8788: LD_STRING D10a-JMM-3
8790: PPUSH
8791: CALL_OW 88
// player_get_info := true ;
8795: LD_ADDR_EXP 15
8799: PUSH
8800: LD_INT 1
8802: ST_TO_ADDR
// DialogueOff ;
8803: CALL_OW 7
// end ; end ; if player_attacked_ar then
8807: LD_EXP 16
8811: IFFALSE 8815
// exit ;
8813: GO 8987
// if player_want_mortar or player_want_info then
8815: LD_EXP 12
8819: PUSH
8820: LD_EXP 13
8824: OR
8825: IFFALSE 8839
// Say ( Vervecken , D9f-Ar1-1 ) ;
8827: LD_EXP 25
8831: PPUSH
8832: LD_STRING D9f-Ar1-1
8834: PPUSH
8835: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8839: LD_INT 22
8841: PUSH
8842: LD_INT 2
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 69
8853: PPUSH
8854: LD_INT 51
8856: PPUSH
8857: LD_INT 99
8859: PPUSH
8860: CALL_OW 111
// wait ( 0 0$1 ) ;
8864: LD_INT 35
8866: PPUSH
8867: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
8871: LD_INT 22
8873: PUSH
8874: LD_INT 2
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: LD_INT 92
8883: PUSH
8884: LD_INT 51
8886: PUSH
8887: LD_INT 99
8889: PUSH
8890: LD_INT 2
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: EMPTY
8900: LIST
8901: LIST
8902: PPUSH
8903: CALL_OW 69
8907: IFFALSE 8967
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
8909: LD_ADDR_VAR 0 1
8913: PUSH
8914: LD_INT 22
8916: PUSH
8917: LD_INT 2
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: PUSH
8924: LD_INT 92
8926: PUSH
8927: LD_INT 51
8929: PUSH
8930: LD_INT 99
8932: PUSH
8933: LD_INT 2
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: LIST
8940: LIST
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PPUSH
8946: CALL_OW 69
8950: PUSH
8951: FOR_IN
8952: IFFALSE 8965
// RemoveUnit ( i ) ;
8954: LD_VAR 0 1
8958: PPUSH
8959: CALL_OW 64
8963: GO 8951
8965: POP
8966: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
8967: LD_INT 22
8969: PUSH
8970: LD_INT 2
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PPUSH
8977: CALL_OW 69
8981: PUSH
8982: LD_INT 0
8984: EQUAL
8985: IFFALSE 8839
// end ;
8987: PPOPN 8
8989: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
8990: LD_EXP 16
8994: IFFALSE 9347
8996: GO 8998
8998: DISABLE
8999: LD_INT 0
9001: PPUSH
9002: PPUSH
9003: PPUSH
9004: PPUSH
// begin ru_can_attack := true ;
9005: LD_ADDR_EXP 8
9009: PUSH
9010: LD_INT 1
9012: ST_TO_ADDR
// mine_launched := false ;
9013: LD_ADDR_VAR 0 3
9017: PUSH
9018: LD_INT 0
9020: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9021: LD_INT 22
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: PPUSH
9031: CALL_OW 69
9035: PPUSH
9036: LD_INT 51
9038: PPUSH
9039: LD_INT 99
9041: PPUSH
9042: CALL_OW 111
// if IsOk ( Vervecken ) then
9046: LD_EXP 25
9050: PPUSH
9051: CALL_OW 302
9055: IFFALSE 9069
// Say ( Vervecken , D11a-Ar1-1 ) ;
9057: LD_EXP 25
9061: PPUSH
9062: LD_STRING D11a-Ar1-1
9064: PPUSH
9065: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9069: LD_ADDR_VAR 0 2
9073: PUSH
9074: LD_EXP 32
9078: PPUSH
9079: LD_INT 25
9081: PUSH
9082: LD_INT 1
9084: PUSH
9085: EMPTY
9086: LIST
9087: LIST
9088: PPUSH
9089: CALL_OW 72
9093: ST_TO_ADDR
// for i in tmp do
9094: LD_ADDR_VAR 0 1
9098: PUSH
9099: LD_VAR 0 2
9103: PUSH
9104: FOR_IN
9105: IFFALSE 9168
// if MineOfUnit ( i ) then
9107: LD_VAR 0 1
9111: PPUSH
9112: CALL_OW 459
9116: IFFALSE 9166
// begin x := MineOfUnit ( i ) ;
9118: LD_ADDR_VAR 0 4
9122: PUSH
9123: LD_VAR 0 1
9127: PPUSH
9128: CALL_OW 459
9132: ST_TO_ADDR
// mine_launched := true ;
9133: LD_ADDR_VAR 0 3
9137: PUSH
9138: LD_INT 1
9140: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9141: LD_VAR 0 4
9145: PUSH
9146: LD_INT 1
9148: ARRAY
9149: PPUSH
9150: LD_VAR 0 4
9154: PUSH
9155: LD_INT 2
9157: ARRAY
9158: PPUSH
9159: LD_INT 2
9161: PPUSH
9162: CALL_OW 456
// end ;
9166: GO 9104
9168: POP
9169: POP
// if mine_launched and IsOk ( Vervecken ) then
9170: LD_VAR 0 3
9174: PUSH
9175: LD_EXP 25
9179: PPUSH
9180: CALL_OW 302
9184: AND
9185: IFFALSE 9199
// Say ( Vervecken , D11b-Ar1-1 ) ;
9187: LD_EXP 25
9191: PPUSH
9192: LD_STRING D11b-Ar1-1
9194: PPUSH
9195: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9199: LD_INT 22
9201: PUSH
9202: LD_INT 2
9204: PUSH
9205: EMPTY
9206: LIST
9207: LIST
9208: PPUSH
9209: CALL_OW 69
9213: PPUSH
9214: LD_INT 51
9216: PPUSH
9217: LD_INT 99
9219: PPUSH
9220: CALL_OW 111
// wait ( 0 0$1 ) ;
9224: LD_INT 35
9226: PPUSH
9227: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9231: LD_INT 22
9233: PUSH
9234: LD_INT 2
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: PUSH
9241: LD_INT 92
9243: PUSH
9244: LD_INT 51
9246: PUSH
9247: LD_INT 99
9249: PUSH
9250: LD_INT 2
9252: PUSH
9253: EMPTY
9254: LIST
9255: LIST
9256: LIST
9257: LIST
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: PPUSH
9263: CALL_OW 69
9267: IFFALSE 9327
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9269: LD_ADDR_VAR 0 1
9273: PUSH
9274: LD_INT 22
9276: PUSH
9277: LD_INT 2
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: PUSH
9284: LD_INT 92
9286: PUSH
9287: LD_INT 51
9289: PUSH
9290: LD_INT 99
9292: PUSH
9293: LD_INT 2
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: LIST
9300: LIST
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PPUSH
9306: CALL_OW 69
9310: PUSH
9311: FOR_IN
9312: IFFALSE 9325
// RemoveUnit ( i ) ;
9314: LD_VAR 0 1
9318: PPUSH
9319: CALL_OW 64
9323: GO 9311
9325: POP
9326: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9327: LD_INT 22
9329: PUSH
9330: LD_INT 2
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PPUSH
9337: CALL_OW 69
9341: PUSH
9342: LD_INT 0
9344: EQUAL
9345: IFFALSE 9199
// end ;
9347: PPOPN 4
9349: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9350: LD_EXP 10
9354: IFFALSE 9533
9356: GO 9358
9358: DISABLE
9359: LD_INT 0
9361: PPUSH
// begin Wait ( 10 10$00 ) ;
9362: LD_INT 21000
9364: PPUSH
9365: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9369: LD_INT 22
9371: PUSH
9372: LD_INT 2
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: IFFALSE 9533
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9385: LD_INT 22
9387: PUSH
9388: LD_INT 2
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PPUSH
9395: CALL_OW 69
9399: PPUSH
9400: LD_INT 51
9402: PPUSH
9403: LD_INT 99
9405: PPUSH
9406: CALL_OW 114
// wait ( 0 0$1 ) ;
9410: LD_INT 35
9412: PPUSH
9413: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9417: LD_INT 22
9419: PUSH
9420: LD_INT 2
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PUSH
9427: LD_INT 92
9429: PUSH
9430: LD_INT 51
9432: PUSH
9433: LD_INT 99
9435: PUSH
9436: LD_INT 2
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PPUSH
9449: CALL_OW 69
9453: IFFALSE 9513
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9455: LD_ADDR_VAR 0 1
9459: PUSH
9460: LD_INT 22
9462: PUSH
9463: LD_INT 2
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: PUSH
9470: LD_INT 92
9472: PUSH
9473: LD_INT 51
9475: PUSH
9476: LD_INT 99
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: LIST
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: PPUSH
9492: CALL_OW 69
9496: PUSH
9497: FOR_IN
9498: IFFALSE 9511
// RemoveUnit ( i ) ;
9500: LD_VAR 0 1
9504: PPUSH
9505: CALL_OW 64
9509: GO 9497
9511: POP
9512: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9513: LD_INT 22
9515: PUSH
9516: LD_INT 2
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PPUSH
9523: CALL_OW 69
9527: PUSH
9528: LD_INT 0
9530: EQUAL
9531: IFFALSE 9385
// end ; end ;
9533: PPOPN 1
9535: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9536: LD_EXP 4
9540: IFFALSE 10334
9542: GO 9544
9544: DISABLE
9545: LD_INT 0
9547: PPUSH
9548: PPUSH
9549: PPUSH
// begin Wait ( game_time ) ;
9550: LD_EXP 7
9554: PPUSH
9555: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9559: LD_INT 35
9561: PPUSH
9562: CALL_OW 67
// until ( not ru_can_attack ) ;
9566: LD_EXP 8
9570: NOT
9571: IFFALSE 9559
// Wait ( 0 0$35 ) ;
9573: LD_INT 1225
9575: PPUSH
9576: CALL_OW 67
// DialogueOn ;
9580: CALL_OW 6
// InGameOn ;
9584: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9588: LD_EXP 24
9592: PPUSH
9593: LD_STRING D12-Pow-1
9595: PPUSH
9596: CALL_OW 94
// InGameOff ;
9600: CALL_OW 9
// DialogueOff ;
9604: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9608: LD_STRING M4
9610: PPUSH
9611: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9615: LD_INT 5
9617: PPUSH
9618: LD_INT 1
9620: PPUSH
9621: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9632: LD_INT 22
9634: PUSH
9635: LD_INT 1
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: PUSH
9642: LD_INT 21
9644: PUSH
9645: LD_INT 1
9647: PUSH
9648: EMPTY
9649: LIST
9650: LIST
9651: PUSH
9652: EMPTY
9653: LIST
9654: LIST
9655: PPUSH
9656: CALL_OW 69
9660: PUSH
9661: LD_INT 5
9663: PPUSH
9664: LD_INT 22
9666: PUSH
9667: LD_INT 1
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 21
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: EMPTY
9685: LIST
9686: LIST
9687: PPUSH
9688: CALL_OW 70
9692: PUSH
9693: LD_INT 22
9695: PUSH
9696: LD_INT 1
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: PUSH
9703: LD_INT 55
9705: PUSH
9706: EMPTY
9707: LIST
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PPUSH
9713: CALL_OW 69
9717: PLUS
9718: LESSEQUAL
9719: IFFALSE 9625
// if not player_get_info then
9721: LD_EXP 15
9725: NOT
9726: IFFALSE 9737
// player_get_info := - 1 ;
9728: LD_ADDR_EXP 15
9732: PUSH
9733: LD_INT 1
9735: NEG
9736: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
9737: LD_STRING Information
9739: PPUSH
9740: LD_EXP 15
9744: PPUSH
9745: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9749: LD_ADDR_VAR 0 2
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 1
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 2
9766: PUSH
9767: LD_INT 25
9769: PUSH
9770: LD_INT 2
9772: PUSH
9773: EMPTY
9774: LIST
9775: LIST
9776: PUSH
9777: LD_INT 25
9779: PUSH
9780: LD_INT 16
9782: PUSH
9783: EMPTY
9784: LIST
9785: LIST
9786: PUSH
9787: LD_INT 34
9789: PUSH
9790: LD_INT 12
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: EMPTY
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PPUSH
9807: CALL_OW 69
9811: ST_TO_ADDR
// sib := GetTerminalCargo ;
9812: LD_ADDR_VAR 0 3
9816: PUSH
9817: CALL 776 0 0
9821: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
9822: LD_ADDR_VAR 0 3
9826: PUSH
9827: LD_VAR 0 3
9831: PUSH
9832: LD_INT 6
9834: PPUSH
9835: LD_INT 3
9837: PPUSH
9838: CALL_OW 287
9842: PLUS
9843: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
9844: LD_ADDR_VAR 0 3
9848: PUSH
9849: LD_VAR 0 3
9853: PUSH
9854: LD_VAR 0 2
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: CALL_OW 289
9866: PLUS
9867: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
9868: LD_VAR 0 3
9872: PUSH
9873: LD_INT 2
9875: PUSH
9876: LD_OWVAR 67
9880: PLUS
9881: PUSH
9882: LD_INT 50
9884: MUL
9885: LESS
9886: IFFALSE 9911
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
9888: LD_STRING MuchSiberite
9890: PPUSH
9891: LD_INT 2
9893: NEG
9894: PUSH
9895: LD_OWVAR 67
9899: MUL
9900: PUSH
9901: LD_INT 1
9903: PLUS
9904: PPUSH
9905: CALL_OW 101
9909: GO 9921
// AddMedal ( MuchSiberite , 1 ) ;
9911: LD_STRING MuchSiberite
9913: PPUSH
9914: LD_INT 1
9916: PPUSH
9917: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
9921: LD_INT 22
9923: PUSH
9924: LD_INT 1
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PUSH
9931: LD_INT 2
9933: PUSH
9934: LD_INT 25
9936: PUSH
9937: LD_INT 1
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 25
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: LD_INT 25
9956: PUSH
9957: LD_INT 3
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: LD_INT 25
9966: PUSH
9967: LD_INT 4
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: LD_INT 25
9976: PUSH
9977: LD_INT 8
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: PPUSH
10001: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10005: LD_ADDR_VAR 0 2
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 1
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 25
10022: PUSH
10023: LD_INT 8
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PUSH
10030: EMPTY
10031: LIST
10032: LIST
10033: PPUSH
10034: CALL_OW 69
10038: ST_TO_ADDR
// if tmp then
10039: LD_VAR 0 2
10043: IFFALSE 10074
// for i in tmp do
10045: LD_ADDR_VAR 0 1
10049: PUSH
10050: LD_VAR 0 2
10054: PUSH
10055: FOR_IN
10056: IFFALSE 10072
// SetClass ( i , 1 ) ;
10058: LD_VAR 0 1
10062: PPUSH
10063: LD_INT 1
10065: PPUSH
10066: CALL_OW 336
10070: GO 10055
10072: POP
10073: POP
// SaveVariable ( sib , 09_sibRes ) ;
10074: LD_VAR 0 3
10078: PPUSH
10079: LD_STRING 09_sibRes
10081: PPUSH
10082: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10086: LD_EXP 15
10090: PPUSH
10091: LD_STRING 09_arInfo
10093: PPUSH
10094: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10098: LD_EXP 17
10102: PPUSH
10103: LD_EXP 1
10107: PUSH
10108: LD_STRING JMM
10110: STR
10111: PPUSH
10112: CALL_OW 38
// if IsLive ( Gary ) then
10116: LD_EXP 18
10120: PPUSH
10121: CALL_OW 300
10125: IFFALSE 10145
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10127: LD_EXP 18
10131: PPUSH
10132: LD_EXP 1
10136: PUSH
10137: LD_STRING Gary
10139: STR
10140: PPUSH
10141: CALL_OW 38
// if IsLive ( Bobby ) then
10145: LD_EXP 19
10149: PPUSH
10150: CALL_OW 300
10154: IFFALSE 10174
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10156: LD_EXP 19
10160: PPUSH
10161: LD_EXP 1
10165: PUSH
10166: LD_STRING Bobby
10168: STR
10169: PPUSH
10170: CALL_OW 38
// if IsLive ( Cyrus ) then
10174: LD_EXP 20
10178: PPUSH
10179: CALL_OW 300
10183: IFFALSE 10203
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10185: LD_EXP 20
10189: PPUSH
10190: LD_EXP 1
10194: PUSH
10195: LD_STRING Cyrus
10197: STR
10198: PPUSH
10199: CALL_OW 38
// if IsLive ( Houten ) then
10203: LD_EXP 21
10207: PPUSH
10208: CALL_OW 300
10212: IFFALSE 10232
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10214: LD_EXP 21
10218: PPUSH
10219: LD_EXP 1
10223: PUSH
10224: LD_STRING Houten
10226: STR
10227: PPUSH
10228: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10232: LD_ADDR_VAR 0 2
10236: PUSH
10237: LD_INT 22
10239: PUSH
10240: LD_INT 1
10242: PUSH
10243: EMPTY
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 2
10249: PUSH
10250: LD_INT 25
10252: PUSH
10253: LD_INT 1
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: PUSH
10260: LD_INT 25
10262: PUSH
10263: LD_INT 2
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: PUSH
10270: LD_INT 25
10272: PUSH
10273: LD_INT 3
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 25
10282: PUSH
10283: LD_INT 4
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: PPUSH
10301: CALL_OW 69
10305: ST_TO_ADDR
// if tmp then
10306: LD_VAR 0 2
10310: IFFALSE 10330
// SaveCharacters ( tmp , mission_prefix & others ) ;
10312: LD_VAR 0 2
10316: PPUSH
10317: LD_EXP 1
10321: PUSH
10322: LD_STRING others
10324: STR
10325: PPUSH
10326: CALL_OW 38
// YouWin ;
10330: CALL_OW 103
// end ; end_of_file
10334: PPOPN 3
10336: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10337: LD_VAR 0 1
10341: PPUSH
10342: CALL_OW 266
10346: PUSH
10347: LD_INT 0
10349: EQUAL
10350: PUSH
10351: LD_EXP 3
10355: NOT
10356: AND
10357: IFFALSE 10381
// begin terminal := b ;
10359: LD_ADDR_EXP 3
10363: PUSH
10364: LD_VAR 0 1
10368: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10369: LD_EXP 3
10373: PPUSH
10374: LD_STRING terminal
10376: PPUSH
10377: CALL_OW 500
// end ; end ;
10381: PPOPN 2
10383: END
// on BuildingComplete ( b ) do var i ;
10384: LD_INT 0
10386: PPUSH
// begin if GetSide ( b ) = 3 then
10387: LD_VAR 0 1
10391: PPUSH
10392: CALL_OW 255
10396: PUSH
10397: LD_INT 3
10399: EQUAL
10400: IFFALSE 10440
// for i = 1 to 4 do
10402: LD_ADDR_VAR 0 2
10406: PUSH
10407: DOUBLE
10408: LD_INT 1
10410: DEC
10411: ST_TO_ADDR
10412: LD_INT 4
10414: PUSH
10415: FOR_TO
10416: IFFALSE 10438
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10418: LD_ADDR_EXP 34
10422: PUSH
10423: LD_EXP 34
10427: PPUSH
10428: LD_INT 1
10430: PPUSH
10431: CALL_OW 3
10435: ST_TO_ADDR
10436: GO 10415
10438: POP
10439: POP
// end ;
10440: PPOPN 2
10442: END
// on VehicleConstructed ( veh , fac ) do var i ;
10443: LD_INT 0
10445: PPUSH
// begin if GetSide ( veh ) = 3 then
10446: LD_VAR 0 1
10450: PPUSH
10451: CALL_OW 255
10455: PUSH
10456: LD_INT 3
10458: EQUAL
10459: IFFALSE 10584
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10461: LD_VAR 0 1
10465: PPUSH
10466: CALL_OW 264
10470: PUSH
10471: LD_INT 53
10473: PUSH
10474: LD_INT 52
10476: PUSH
10477: LD_INT 51
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: LIST
10484: IN
10485: NOT
10486: IFFALSE 10504
// ru_force := ru_force ^ veh ;
10488: LD_ADDR_EXP 33
10492: PUSH
10493: LD_EXP 33
10497: PUSH
10498: LD_VAR 0 1
10502: ADD
10503: ST_TO_ADDR
// for i = 1 to 4 do
10504: LD_ADDR_VAR 0 3
10508: PUSH
10509: DOUBLE
10510: LD_INT 1
10512: DEC
10513: ST_TO_ADDR
10514: LD_INT 4
10516: PUSH
10517: FOR_TO
10518: IFFALSE 10540
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10520: LD_ADDR_EXP 35
10524: PUSH
10525: LD_EXP 35
10529: PPUSH
10530: LD_INT 1
10532: PPUSH
10533: CALL_OW 3
10537: ST_TO_ADDR
10538: GO 10517
10540: POP
10541: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10542: LD_VAR 0 1
10546: PPUSH
10547: CALL_OW 264
10551: PUSH
10552: LD_INT 53
10554: EQUAL
10555: IFFALSE 10584
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10557: LD_VAR 0 1
10561: PPUSH
10562: LD_INT 7
10564: PPUSH
10565: CALL 934 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10569: LD_VAR 0 1
10573: PPUSH
10574: LD_INT 170
10576: PPUSH
10577: LD_INT 235
10579: PPUSH
10580: CALL_OW 171
// end ; end ; end ;
10584: PPOPN 3
10586: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1
10594: EQUAL
10595: PUSH
10596: LD_VAR 0 2
10600: PUSH
10601: LD_INT 2
10603: EQUAL
10604: AND
10605: PUSH
10606: LD_VAR 0 1
10610: PUSH
10611: LD_INT 2
10613: EQUAL
10614: PUSH
10615: LD_VAR 0 2
10619: PUSH
10620: LD_INT 1
10622: EQUAL
10623: AND
10624: OR
10625: IFFALSE 10635
// player_attacked_ar := true ;
10627: LD_ADDR_EXP 16
10631: PUSH
10632: LD_INT 1
10634: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
10635: LD_VAR 0 1
10639: PUSH
10640: LD_INT 1
10642: EQUAL
10643: PUSH
10644: LD_VAR 0 2
10648: PUSH
10649: LD_INT 4
10651: EQUAL
10652: AND
10653: PUSH
10654: LD_VAR 0 1
10658: PUSH
10659: LD_INT 4
10661: EQUAL
10662: PUSH
10663: LD_VAR 0 2
10667: PUSH
10668: LD_INT 1
10670: EQUAL
10671: AND
10672: OR
10673: IFFALSE 10682
// YouLost ( Traitor ) ;
10675: LD_STRING Traitor
10677: PPUSH
10678: CALL_OW 104
// end ;
10682: PPOPN 2
10684: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10685: LD_VAR 0 1
10689: PUSH
10690: LD_EXP 17
10694: EQUAL
10695: IFFALSE 10704
// YouLost ( JMM ) ;
10697: LD_STRING JMM
10699: PPUSH
10700: CALL_OW 104
// if un = terminal then
10704: LD_VAR 0 1
10708: PUSH
10709: LD_EXP 3
10713: EQUAL
10714: IFFALSE 10723
// YouLost ( Terminal ) ;
10716: LD_STRING Terminal
10718: PPUSH
10719: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10723: LD_VAR 0 1
10727: PUSH
10728: LD_INT 22
10730: PUSH
10731: LD_INT 3
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PUSH
10738: LD_INT 21
10740: PUSH
10741: LD_INT 3
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PUSH
10748: EMPTY
10749: LIST
10750: LIST
10751: PPUSH
10752: CALL_OW 69
10756: IN
10757: IFFALSE 10903
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10759: LD_VAR 0 1
10763: PPUSH
10764: CALL_OW 266
10768: PUSH
10769: LD_INT 33
10771: PUSH
10772: LD_INT 26
10774: PUSH
10775: EMPTY
10776: LIST
10777: LIST
10778: IN
10779: IFFALSE 10838
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10781: LD_ADDR_EXP 34
10785: PUSH
10786: LD_EXP 34
10790: PUSH
10791: LD_VAR 0 1
10795: PPUSH
10796: CALL_OW 266
10800: PUSH
10801: LD_VAR 0 1
10805: PPUSH
10806: CALL_OW 250
10810: PUSH
10811: LD_VAR 0 1
10815: PPUSH
10816: CALL_OW 251
10820: PUSH
10821: LD_VAR 0 1
10825: PPUSH
10826: CALL_OW 254
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: ADD
10837: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 266
10847: PUSH
10848: LD_INT 5
10850: EQUAL
10851: IFFALSE 10903
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10853: LD_ADDR_EXP 34
10857: PUSH
10858: LD_EXP 34
10862: PUSH
10863: LD_INT 4
10865: PUSH
10866: LD_VAR 0 1
10870: PPUSH
10871: CALL_OW 250
10875: PUSH
10876: LD_VAR 0 1
10880: PPUSH
10881: CALL_OW 251
10885: PUSH
10886: LD_VAR 0 1
10890: PPUSH
10891: CALL_OW 254
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: ADD
10902: ST_TO_ADDR
// end ; if un in ru_force then
10903: LD_VAR 0 1
10907: PUSH
10908: LD_EXP 33
10912: IN
10913: IFFALSE 10946
// begin ru_force := ru_force diff un ;
10915: LD_ADDR_EXP 33
10919: PUSH
10920: LD_EXP 33
10924: PUSH
10925: LD_VAR 0 1
10929: DIFF
10930: ST_TO_ADDR
// if not ru_force then
10931: LD_EXP 33
10935: NOT
10936: IFFALSE 10946
// ru_can_attack := false ;
10938: LD_ADDR_EXP 8
10942: PUSH
10943: LD_INT 0
10945: ST_TO_ADDR
// end ; end ; end_of_file
10946: PPOPN 1
10948: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
10949: LD_EXP 5
10953: PUSH
10954: LD_EXP 6
10958: AND
10959: IFFALSE 11037
10961: GO 10963
10963: DISABLE
10964: LD_INT 0
10966: PPUSH
// begin enable ;
10967: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
10968: LD_ADDR_VAR 0 1
10972: PUSH
10973: LD_INT 60
10975: PUSH
10976: CALL 776 0 0
10980: MINUS
10981: ST_TO_ADDR
// if sib < 0 then
10982: LD_VAR 0 1
10986: PUSH
10987: LD_INT 0
10989: LESS
10990: IFFALSE 11000
// sib := 0 ;
10992: LD_ADDR_VAR 0 1
10996: PUSH
10997: LD_INT 0
10999: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11000: LD_ADDR_OWVAR 47
11004: PUSH
11005: LD_STRING #Am09-1
11007: PUSH
11008: LD_VAR 0 1
11012: PUSH
11013: LD_EXP 6
11017: PUSH
11018: EMPTY
11019: LIST
11020: LIST
11021: LIST
11022: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11023: LD_ADDR_EXP 6
11027: PUSH
11028: LD_EXP 6
11032: PUSH
11033: LD_INT 35
11035: MINUS
11036: ST_TO_ADDR
// end ;
11037: PPOPN 1
11039: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11040: LD_EXP 6
11044: PUSH
11045: LD_INT 0
11047: EQUAL
11048: IFFALSE 11060
11050: GO 11052
11052: DISABLE
// display_strings := [ ] ;
11053: LD_ADDR_OWVAR 47
11057: PUSH
11058: EMPTY
11059: ST_TO_ADDR
11060: END
// every 1 1$35 do var i , tmp ;
11061: GO 11063
11063: DISABLE
11064: LD_INT 0
11066: PPUSH
11067: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11068: LD_ADDR_VAR 0 2
11072: PUSH
11073: LD_INT 1155
11075: PUSH
11076: LD_INT 1225
11078: PUSH
11079: LD_INT 1435
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: LIST
11086: PUSH
11087: LD_OWVAR 67
11091: ARRAY
11092: ST_TO_ADDR
// i := 0 ;
11093: LD_ADDR_VAR 0 1
11097: PUSH
11098: LD_INT 0
11100: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11101: LD_INT 1
11103: PPUSH
11104: LD_INT 5
11106: PPUSH
11107: CALL_OW 12
11111: PPUSH
11112: LD_INT 75
11114: PPUSH
11115: LD_INT 75
11117: PPUSH
11118: LD_INT 20
11120: PPUSH
11121: LD_INT 1
11123: PPUSH
11124: CALL_OW 56
// wait ( tmp ) ;
11128: LD_VAR 0 2
11132: PPUSH
11133: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11137: LD_ADDR_VAR 0 2
11141: PUSH
11142: LD_VAR 0 2
11146: PUSH
11147: LD_INT 105
11149: PPUSH
11150: LD_INT 315
11152: PPUSH
11153: CALL_OW 12
11157: PLUS
11158: ST_TO_ADDR
// i := i + 1 ;
11159: LD_ADDR_VAR 0 1
11163: PUSH
11164: LD_VAR 0 1
11168: PUSH
11169: LD_INT 1
11171: PLUS
11172: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11173: LD_VAR 0 1
11177: PUSH
11178: LD_INT 3
11180: MOD
11181: PUSH
11182: LD_INT 0
11184: EQUAL
11185: PUSH
11186: LD_EXP 4
11190: AND
11191: IFFALSE 11229
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11193: LD_INT 2
11195: PPUSH
11196: LD_INT 5
11198: PPUSH
11199: CALL_OW 12
11203: PPUSH
11204: LD_INT 8
11206: PPUSH
11207: LD_INT 1
11209: PPUSH
11210: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11214: LD_INT 665
11216: PPUSH
11217: LD_INT 735
11219: PPUSH
11220: CALL_OW 12
11224: PPUSH
11225: CALL_OW 67
// end ; until tick > game_time ;
11229: LD_OWVAR 1
11233: PUSH
11234: LD_EXP 7
11238: GREATER
11239: IFFALSE 11101
// end ; end_of_file
11241: PPOPN 2
11243: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11244: LD_INT 0
11246: PPUSH
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
// x := 76 ;
11252: LD_ADDR_VAR 0 5
11256: PUSH
11257: LD_INT 76
11259: ST_TO_ADDR
// y := 147 ;
11260: LD_ADDR_VAR 0 6
11264: PUSH
11265: LD_INT 147
11267: ST_TO_ADDR
// uc_side := 2 ;
11268: LD_ADDR_OWVAR 20
11272: PUSH
11273: LD_INT 2
11275: ST_TO_ADDR
// uc_nation := 2 ;
11276: LD_ADDR_OWVAR 21
11280: PUSH
11281: LD_INT 2
11283: ST_TO_ADDR
// InitHc ;
11284: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11288: LD_INT 1
11290: PPUSH
11291: LD_INT 1
11293: PPUSH
11294: LD_INT 6
11296: PPUSH
11297: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11301: LD_ADDR_OWVAR 26
11305: PUSH
11306: LD_STRING Nicolas Vervecken
11308: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11309: LD_ADDR_OWVAR 33
11313: PUSH
11314: LD_STRING SecondCharsGal
11316: ST_TO_ADDR
// hc_face_number := 3 ;
11317: LD_ADDR_OWVAR 34
11321: PUSH
11322: LD_INT 3
11324: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11325: LD_ADDR_OWVAR 29
11329: PUSH
11330: LD_INT 11
11332: PUSH
11333: LD_INT 10
11335: PUSH
11336: EMPTY
11337: LIST
11338: LIST
11339: ST_TO_ADDR
// Vervecken := CreateHuman ;
11340: LD_ADDR_EXP 25
11344: PUSH
11345: CALL_OW 44
11349: ST_TO_ADDR
// ar_force := Vervecken ;
11350: LD_ADDR_EXP 32
11354: PUSH
11355: LD_EXP 25
11359: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11360: LD_INT 1
11362: PPUSH
11363: LD_INT 2
11365: PPUSH
11366: LD_INT 6
11368: PPUSH
11369: CALL_OW 380
// hc_name := Louis Gali ;
11373: LD_ADDR_OWVAR 26
11377: PUSH
11378: LD_STRING Louis Gali
11380: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11381: LD_ADDR_OWVAR 33
11385: PUSH
11386: LD_STRING SecondCharsGal
11388: ST_TO_ADDR
// hc_face_number := 2 ;
11389: LD_ADDR_OWVAR 34
11393: PUSH
11394: LD_INT 2
11396: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11397: LD_ADDR_OWVAR 29
11401: PUSH
11402: LD_INT 10
11404: PUSH
11405: LD_INT 11
11407: PUSH
11408: EMPTY
11409: LIST
11410: LIST
11411: ST_TO_ADDR
// Gali := CreateHuman ;
11412: LD_ADDR_EXP 26
11416: PUSH
11417: CALL_OW 44
11421: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11422: LD_ADDR_EXP 32
11426: PUSH
11427: LD_EXP 32
11431: PUSH
11432: LD_EXP 26
11436: ADD
11437: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11438: LD_INT 2
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: LD_INT 6
11446: PPUSH
11447: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11451: LD_ADDR_OWVAR 26
11455: PUSH
11456: LD_STRING Maria Bogdanovic
11458: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11459: LD_ADDR_OWVAR 33
11463: PUSH
11464: LD_STRING SecondCharsGal
11466: ST_TO_ADDR
// hc_face_number := 14 ;
11467: LD_ADDR_OWVAR 34
11471: PUSH
11472: LD_INT 14
11474: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11475: LD_ADDR_OWVAR 29
11479: PUSH
11480: LD_INT 12
11482: PUSH
11483: LD_INT 9
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11490: LD_ADDR_EXP 27
11494: PUSH
11495: CALL_OW 44
11499: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11500: LD_ADDR_EXP 32
11504: PUSH
11505: LD_EXP 32
11509: PUSH
11510: LD_EXP 27
11514: ADD
11515: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11516: LD_INT 1
11518: PPUSH
11519: LD_INT 3
11521: PPUSH
11522: LD_INT 6
11524: PPUSH
11525: CALL_OW 380
// hc_name = Kntor Radomr ;
11529: LD_ADDR_OWVAR 26
11533: PUSH
11534: LD_STRING Kntor Radomr
11536: ST_TO_ADDR
// hc_gallery = sandar ;
11537: LD_ADDR_OWVAR 33
11541: PUSH
11542: LD_STRING sandar
11544: ST_TO_ADDR
// hc_face_number = 12 ;
11545: LD_ADDR_OWVAR 34
11549: PUSH
11550: LD_INT 12
11552: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11553: LD_ADDR_OWVAR 29
11557: PUSH
11558: LD_INT 9
11560: PUSH
11561: LD_INT 9
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: ST_TO_ADDR
// Kantor = CreateHuman ;
11568: LD_ADDR_EXP 28
11572: PUSH
11573: CALL_OW 44
11577: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11578: LD_ADDR_EXP 32
11582: PUSH
11583: LD_EXP 32
11587: PUSH
11588: LD_EXP 28
11592: ADD
11593: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11594: LD_INT 1
11596: PPUSH
11597: LD_INT 3
11599: PPUSH
11600: LD_INT 6
11602: PPUSH
11603: CALL_OW 380
// hc_name = Herczeg Farkas ;
11607: LD_ADDR_OWVAR 26
11611: PUSH
11612: LD_STRING Herczeg Farkas
11614: ST_TO_ADDR
// hc_gallery = sandar ;
11615: LD_ADDR_OWVAR 33
11619: PUSH
11620: LD_STRING sandar
11622: ST_TO_ADDR
// hc_face_number = 28 ;
11623: LD_ADDR_OWVAR 34
11627: PUSH
11628: LD_INT 28
11630: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11631: LD_ADDR_OWVAR 29
11635: PUSH
11636: LD_INT 10
11638: PUSH
11639: LD_INT 9
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: ST_TO_ADDR
// Herczeg = CreateHuman ;
11646: LD_ADDR_EXP 29
11650: PUSH
11651: CALL_OW 44
11655: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11656: LD_ADDR_EXP 32
11660: PUSH
11661: LD_EXP 32
11665: PUSH
11666: LD_EXP 29
11670: ADD
11671: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11672: LD_INT 1
11674: PPUSH
11675: LD_INT 1
11677: PPUSH
11678: LD_INT 6
11680: PPUSH
11681: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11685: LD_ADDR_OWVAR 26
11689: PUSH
11690: LD_STRING Ronn Horntvedt
11692: ST_TO_ADDR
// hc_gallery = sandar ;
11693: LD_ADDR_OWVAR 33
11697: PUSH
11698: LD_STRING sandar
11700: ST_TO_ADDR
// hc_face_number = 29 ;
11701: LD_ADDR_OWVAR 34
11705: PUSH
11706: LD_INT 29
11708: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11709: LD_ADDR_OWVAR 29
11713: PUSH
11714: LD_INT 11
11716: PUSH
11717: LD_INT 11
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: ST_TO_ADDR
// Ronn = CreateHuman ;
11724: LD_ADDR_EXP 30
11728: PUSH
11729: CALL_OW 44
11733: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11734: LD_ADDR_EXP 32
11738: PUSH
11739: LD_EXP 32
11743: PUSH
11744: LD_EXP 30
11748: ADD
11749: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11750: LD_INT 2
11752: PPUSH
11753: LD_INT 3
11755: PPUSH
11756: LD_INT 6
11758: PPUSH
11759: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11763: LD_ADDR_OWVAR 26
11767: PUSH
11768: LD_STRING Mia D. Mathiasen
11770: ST_TO_ADDR
// hc_gallery = sandar ;
11771: LD_ADDR_OWVAR 33
11775: PUSH
11776: LD_STRING sandar
11778: ST_TO_ADDR
// hc_face_number = 31 ;
11779: LD_ADDR_OWVAR 34
11783: PUSH
11784: LD_INT 31
11786: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
11787: LD_ADDR_OWVAR 29
11791: PUSH
11792: LD_INT 10
11794: PUSH
11795: LD_INT 10
11797: PUSH
11798: EMPTY
11799: LIST
11800: LIST
11801: ST_TO_ADDR
// Mia = CreateHuman ;
11802: LD_ADDR_EXP 31
11806: PUSH
11807: CALL_OW 44
11811: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
11812: LD_ADDR_EXP 32
11816: PUSH
11817: LD_EXP 32
11821: PUSH
11822: LD_EXP 31
11826: ADD
11827: ST_TO_ADDR
// for i = 1 to 2 do
11828: LD_ADDR_VAR 0 4
11832: PUSH
11833: DOUBLE
11834: LD_INT 1
11836: DEC
11837: ST_TO_ADDR
11838: LD_INT 2
11840: PUSH
11841: FOR_TO
11842: IFFALSE 11883
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
11844: LD_ADDR_VAR 0 3
11848: PUSH
11849: LD_VAR 0 3
11853: PUSH
11854: LD_INT 2
11856: PPUSH
11857: LD_INT 2
11859: PPUSH
11860: LD_INT 14
11862: PPUSH
11863: LD_INT 1
11865: PPUSH
11866: LD_INT 1
11868: PPUSH
11869: LD_INT 32
11871: PPUSH
11872: LD_INT 30
11874: PPUSH
11875: CALL 256 0 7
11879: ADD
11880: ST_TO_ADDR
11881: GO 11841
11883: POP
11884: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
11885: LD_ADDR_VAR 0 3
11889: PUSH
11890: LD_VAR 0 3
11894: PUSH
11895: LD_INT 2
11897: PPUSH
11898: LD_INT 2
11900: PPUSH
11901: LD_INT 14
11903: PPUSH
11904: LD_INT 1
11906: PPUSH
11907: LD_INT 1
11909: PPUSH
11910: LD_INT 26
11912: PPUSH
11913: LD_INT 33
11915: PPUSH
11916: CALL 256 0 7
11920: ADD
11921: ST_TO_ADDR
// tmp := tmp diff 0 ;
11922: LD_ADDR_VAR 0 3
11926: PUSH
11927: LD_VAR 0 3
11931: PUSH
11932: LD_INT 0
11934: DIFF
11935: ST_TO_ADDR
// for i in ar_force do
11936: LD_ADDR_VAR 0 4
11940: PUSH
11941: LD_EXP 32
11945: PUSH
11946: FOR_IN
11947: IFFALSE 12090
// begin if GetClass ( i ) = 3 then
11949: LD_VAR 0 4
11953: PPUSH
11954: CALL_OW 257
11958: PUSH
11959: LD_INT 3
11961: EQUAL
11962: IFFALSE 12044
// begin SetDir ( tmp [ 1 ] , 1 ) ;
11964: LD_VAR 0 3
11968: PUSH
11969: LD_INT 1
11971: ARRAY
11972: PPUSH
11973: LD_INT 1
11975: PPUSH
11976: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
11980: LD_VAR 0 3
11984: PUSH
11985: LD_INT 1
11987: ARRAY
11988: PPUSH
11989: LD_VAR 0 5
11993: PPUSH
11994: LD_VAR 0 6
11998: PPUSH
11999: LD_INT 0
12001: PPUSH
12002: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12006: LD_VAR 0 4
12010: PPUSH
12011: LD_VAR 0 3
12015: PUSH
12016: LD_INT 1
12018: ARRAY
12019: PPUSH
12020: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12024: LD_ADDR_VAR 0 3
12028: PUSH
12029: LD_VAR 0 3
12033: PPUSH
12034: LD_INT 1
12036: PPUSH
12037: CALL_OW 3
12041: ST_TO_ADDR
// end else
12042: GO 12066
// PlaceUnitXY ( i , x , y , false ) ;
12044: LD_VAR 0 4
12048: PPUSH
12049: LD_VAR 0 5
12053: PPUSH
12054: LD_VAR 0 6
12058: PPUSH
12059: LD_INT 0
12061: PPUSH
12062: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12066: LD_VAR 0 4
12070: PPUSH
12071: LD_INT 86
12073: PPUSH
12074: LD_INT 121
12076: PPUSH
12077: CALL_OW 111
// wait ( 0 0$2 ) ;
12081: LD_INT 70
12083: PPUSH
12084: CALL_OW 67
// end ;
12088: GO 11946
12090: POP
12091: POP
// ar_force := ar_force ^ tmp ;
12092: LD_ADDR_EXP 32
12096: PUSH
12097: LD_EXP 32
12101: PUSH
12102: LD_VAR 0 3
12106: ADD
12107: ST_TO_ADDR
// ar_spawned := true ;
12108: LD_ADDR_EXP 11
12112: PUSH
12113: LD_INT 1
12115: ST_TO_ADDR
// end ; end_of_file
12116: LD_VAR 0 1
12120: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12121: LD_INT 0
12123: PPUSH
12124: PPUSH
12125: PPUSH
12126: PPUSH
12127: PPUSH
12128: PPUSH
12129: PPUSH
// InitHc ;
12130: CALL_OW 19
// uc_side := 3 ;
12134: LD_ADDR_OWVAR 20
12138: PUSH
12139: LD_INT 3
12141: ST_TO_ADDR
// uc_nation := 3 ;
12142: LD_ADDR_OWVAR 21
12146: PUSH
12147: LD_INT 3
12149: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12150: LD_ADDR_VAR 0 5
12154: PUSH
12155: LD_INT 5
12157: PUSH
12158: LD_INT 6
12160: PUSH
12161: LD_INT 7
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: LIST
12168: PUSH
12169: LD_OWVAR 67
12173: ARRAY
12174: ST_TO_ADDR
// ru_force := [ ] ;
12175: LD_ADDR_EXP 33
12179: PUSH
12180: EMPTY
12181: ST_TO_ADDR
// ru_rebuild := [ ] ;
12182: LD_ADDR_EXP 34
12186: PUSH
12187: EMPTY
12188: ST_TO_ADDR
// ru_produce_list := [ ] ;
12189: LD_ADDR_EXP 35
12193: PUSH
12194: EMPTY
12195: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12196: LD_ADDR_VAR 0 6
12200: PUSH
12201: LD_INT 22
12203: PUSH
12204: LD_INT 3
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: PUSH
12211: LD_INT 30
12213: PUSH
12214: LD_INT 8
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: PPUSH
12225: CALL_OW 69
12229: PUSH
12230: LD_INT 1
12232: ARRAY
12233: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12234: LD_ADDR_VAR 0 4
12238: PUSH
12239: LD_INT 43
12241: PUSH
12242: LD_INT 46
12244: PUSH
12245: LD_INT 45
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12253: LD_ADDR_VAR 0 7
12257: PUSH
12258: LD_INT 22
12260: PUSH
12261: LD_INT 3
12263: PUSH
12264: EMPTY
12265: LIST
12266: LIST
12267: PUSH
12268: LD_INT 30
12270: PUSH
12271: LD_INT 1
12273: PUSH
12274: EMPTY
12275: LIST
12276: LIST
12277: PUSH
12278: EMPTY
12279: LIST
12280: LIST
12281: PPUSH
12282: CALL_OW 69
12286: PUSH
12287: LD_INT 1
12289: ARRAY
12290: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12291: LD_VAR 0 7
12295: PPUSH
12296: CALL_OW 274
12300: PPUSH
12301: LD_INT 1
12303: PPUSH
12304: LD_INT 5000
12306: PPUSH
12307: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12311: LD_VAR 0 7
12315: PPUSH
12316: CALL_OW 274
12320: PPUSH
12321: LD_INT 2
12323: PPUSH
12324: LD_INT 1000
12326: PPUSH
12327: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12331: LD_VAR 0 7
12335: PPUSH
12336: CALL_OW 274
12340: PPUSH
12341: LD_INT 3
12343: PPUSH
12344: LD_INT 30
12346: PPUSH
12347: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12351: LD_ADDR_VAR 0 2
12355: PUSH
12356: LD_INT 22
12358: PUSH
12359: LD_INT 3
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: PUSH
12366: LD_INT 30
12368: PUSH
12369: LD_INT 33
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PUSH
12376: EMPTY
12377: LIST
12378: LIST
12379: PPUSH
12380: CALL_OW 69
12384: PUSH
12385: FOR_IN
12386: IFFALSE 12418
// begin PlaceWeaponTurret ( i , tmp [ rand ( 1 , tmp ) ] ) ;
12388: LD_VAR 0 2
12392: PPUSH
12393: LD_VAR 0 4
12397: PUSH
12398: LD_INT 1
12400: PPUSH
12401: LD_VAR 0 4
12405: PPUSH
12406: CALL_OW 12
12410: ARRAY
12411: PPUSH
12412: CALL_OW 431
// end ;
12416: GO 12385
12418: POP
12419: POP
// for i = 1 to 4 do
12420: LD_ADDR_VAR 0 2
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_INT 4
12432: PUSH
12433: FOR_TO
12434: IFFALSE 12495
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12436: LD_INT 0
12438: PPUSH
12439: LD_INT 9
12441: PPUSH
12442: LD_VAR 0 5
12446: PPUSH
12447: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12451: CALL_OW 44
12455: PPUSH
12456: LD_INT 22
12458: PUSH
12459: LD_INT 3
12461: PUSH
12462: EMPTY
12463: LIST
12464: LIST
12465: PUSH
12466: LD_INT 30
12468: PUSH
12469: LD_INT 5
12471: PUSH
12472: EMPTY
12473: LIST
12474: LIST
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PPUSH
12480: CALL_OW 69
12484: PUSH
12485: LD_INT 1
12487: ARRAY
12488: PPUSH
12489: CALL_OW 52
// end ;
12493: GO 12433
12495: POP
12496: POP
// for i = 1 to 5 do
12497: LD_ADDR_VAR 0 2
12501: PUSH
12502: DOUBLE
12503: LD_INT 1
12505: DEC
12506: ST_TO_ADDR
12507: LD_INT 5
12509: PUSH
12510: FOR_TO
12511: IFFALSE 12572
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12513: LD_INT 0
12515: PPUSH
12516: LD_INT 3
12518: PPUSH
12519: LD_VAR 0 5
12523: PPUSH
12524: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12528: CALL_OW 44
12532: PPUSH
12533: LD_INT 22
12535: PUSH
12536: LD_INT 3
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: PUSH
12543: LD_INT 30
12545: PUSH
12546: LD_INT 3
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: PPUSH
12557: CALL_OW 69
12561: PUSH
12562: LD_INT 1
12564: ARRAY
12565: PPUSH
12566: CALL_OW 52
// end ;
12570: GO 12510
12572: POP
12573: POP
// for i = 1 to 4 do
12574: LD_ADDR_VAR 0 2
12578: PUSH
12579: DOUBLE
12580: LD_INT 1
12582: DEC
12583: ST_TO_ADDR
12584: LD_INT 4
12586: PUSH
12587: FOR_TO
12588: IFFALSE 12649
// begin PrepareHuman ( false , class_engineer , skill ) ;
12590: LD_INT 0
12592: PPUSH
12593: LD_INT 2
12595: PPUSH
12596: LD_VAR 0 5
12600: PPUSH
12601: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12605: CALL_OW 44
12609: PPUSH
12610: LD_INT 22
12612: PUSH
12613: LD_INT 3
12615: PUSH
12616: EMPTY
12617: LIST
12618: LIST
12619: PUSH
12620: LD_INT 30
12622: PUSH
12623: LD_INT 1
12625: PUSH
12626: EMPTY
12627: LIST
12628: LIST
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PPUSH
12634: CALL_OW 69
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: CALL_OW 52
// end ;
12647: GO 12587
12649: POP
12650: POP
// for i = 1 to 3 do
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: DOUBLE
12657: LD_INT 1
12659: DEC
12660: ST_TO_ADDR
12661: LD_INT 3
12663: PUSH
12664: FOR_TO
12665: IFFALSE 12698
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12667: LD_INT 0
12669: PPUSH
12670: LD_INT 4
12672: PPUSH
12673: LD_VAR 0 5
12677: PPUSH
12678: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12682: CALL_OW 44
12686: PPUSH
12687: LD_VAR 0 6
12691: PPUSH
12692: CALL_OW 52
// end ;
12696: GO 12664
12698: POP
12699: POP
// AddComResearch ( lab , tech_tech2 ) ;
12700: LD_VAR 0 6
12704: PPUSH
12705: LD_INT 49
12707: PPUSH
12708: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12712: LD_VAR 0 6
12716: PPUSH
12717: LD_INT 50
12719: PPUSH
12720: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12724: LD_VAR 0 6
12728: PPUSH
12729: LD_INT 51
12731: PPUSH
12732: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12736: LD_VAR 0 6
12740: PPUSH
12741: LD_INT 52
12743: PPUSH
12744: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12748: LD_VAR 0 6
12752: PPUSH
12753: LD_INT 69
12755: PPUSH
12756: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12760: LD_VAR 0 6
12764: PPUSH
12765: LD_INT 39
12767: PPUSH
12768: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
12772: LD_VAR 0 6
12776: PPUSH
12777: LD_INT 34
12779: PPUSH
12780: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
12784: LD_VAR 0 6
12788: PPUSH
12789: LD_INT 40
12791: PPUSH
12792: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
12796: LD_VAR 0 6
12800: PPUSH
12801: LD_INT 57
12803: PPUSH
12804: CALL_OW 184
// if Difficulty > 1 then
12808: LD_OWVAR 67
12812: PUSH
12813: LD_INT 1
12815: GREATER
12816: IFFALSE 12830
// AddComResearch ( lab , tech_comp2 ) ;
12818: LD_VAR 0 6
12822: PPUSH
12823: LD_INT 58
12825: PPUSH
12826: CALL_OW 184
// end ;
12830: LD_VAR 0 1
12834: RET
// every 7 7$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 do
12835: LD_INT 7
12837: PPUSH
12838: CALL_OW 353
12842: PUSH
12843: LD_INT 3
12845: GREATER
12846: IFFALSE 12881
12848: GO 12850
12850: DISABLE
// begin enable ;
12851: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
12852: LD_ADDR_EXP 35
12856: PUSH
12857: LD_EXP 35
12861: PUSH
12862: LD_INT 24
12864: PUSH
12865: LD_INT 1
12867: PUSH
12868: LD_INT 3
12870: PUSH
12871: LD_INT 53
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: ADD
12880: ST_TO_ADDR
// end ;
12881: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
12882: LD_INT 22
12884: PUSH
12885: LD_INT 3
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 21
12894: PUSH
12895: LD_INT 3
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: EMPTY
12903: LIST
12904: LIST
12905: PPUSH
12906: CALL_OW 69
12910: IFFALSE 13688
12912: GO 12914
12914: DISABLE
12915: LD_INT 0
12917: PPUSH
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
12923: PPUSH
12924: PPUSH
// begin enable ;
12925: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12926: LD_ADDR_VAR 0 3
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 3
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 21
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 3
12953: PUSH
12954: LD_INT 24
12956: PUSH
12957: LD_INT 1000
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 3
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 25
12995: PUSH
12996: LD_INT 2
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13012: LD_ADDR_VAR 0 5
13016: PUSH
13017: LD_INT 22
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: EMPTY
13024: LIST
13025: LIST
13026: PUSH
13027: LD_INT 30
13029: PUSH
13030: LD_INT 1
13032: PUSH
13033: EMPTY
13034: LIST
13035: LIST
13036: PUSH
13037: EMPTY
13038: LIST
13039: LIST
13040: PPUSH
13041: CALL_OW 69
13045: PUSH
13046: LD_INT 1
13048: ARRAY
13049: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13050: LD_ADDR_VAR 0 8
13054: PUSH
13055: LD_INT 22
13057: PUSH
13058: LD_INT 3
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 2
13067: PUSH
13068: LD_INT 30
13070: PUSH
13071: LD_INT 6
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 30
13080: PUSH
13081: LD_INT 7
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 30
13090: PUSH
13091: LD_INT 8
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: LIST
13102: LIST
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: PPUSH
13108: CALL_OW 69
13112: PUSH
13113: LD_INT 1
13115: ARRAY
13116: ST_TO_ADDR
// if not engs then
13117: LD_VAR 0 4
13121: NOT
13122: IFFALSE 13126
// exit ;
13124: GO 13688
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13126: LD_ADDR_VAR 0 6
13130: PUSH
13131: LD_VAR 0 4
13135: PPUSH
13136: LD_INT 3
13138: PUSH
13139: LD_INT 24
13141: PUSH
13142: LD_INT 600
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: PPUSH
13153: CALL_OW 72
13157: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13158: LD_ADDR_VAR 0 7
13162: PUSH
13163: LD_INT 22
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 25
13175: PUSH
13176: LD_INT 4
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PUSH
13183: EMPTY
13184: LIST
13185: LIST
13186: PPUSH
13187: CALL_OW 69
13191: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13192: LD_VAR 0 3
13196: NOT
13197: PUSH
13198: LD_EXP 34
13202: NOT
13203: AND
13204: IFFALSE 13264
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13206: LD_VAR 0 4
13210: PPUSH
13211: LD_INT 3
13213: PUSH
13214: LD_INT 54
13216: PUSH
13217: EMPTY
13218: LIST
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PPUSH
13224: CALL_OW 72
13228: IFFALSE 13262
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13230: LD_VAR 0 4
13234: PPUSH
13235: LD_INT 3
13237: PUSH
13238: LD_INT 54
13240: PUSH
13241: EMPTY
13242: LIST
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: PPUSH
13248: CALL_OW 72
13252: PPUSH
13253: LD_VAR 0 5
13257: PPUSH
13258: CALL_OW 120
// exit ;
13262: GO 13688
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13264: LD_VAR 0 4
13268: PPUSH
13269: LD_INT 54
13271: PUSH
13272: EMPTY
13273: LIST
13274: PPUSH
13275: CALL_OW 72
13279: IFFALSE 13301
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13281: LD_VAR 0 4
13285: PPUSH
13286: LD_INT 54
13288: PUSH
13289: EMPTY
13290: LIST
13291: PPUSH
13292: CALL_OW 72
13296: PPUSH
13297: CALL_OW 122
// if not tmp then
13301: LD_VAR 0 3
13305: NOT
13306: IFFALSE 13438
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13308: LD_INT 81
13310: PUSH
13311: LD_INT 3
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: PUSH
13318: LD_INT 92
13320: PUSH
13321: LD_INT 147
13323: PUSH
13324: LD_INT 212
13326: PUSH
13327: LD_INT 30
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: LIST
13334: LIST
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PPUSH
13340: CALL_OW 69
13344: NOT
13345: IFFALSE 13438
// begin if not HasTask ( engs [ 1 ] ) then
13347: LD_VAR 0 4
13351: PUSH
13352: LD_INT 1
13354: ARRAY
13355: PPUSH
13356: CALL_OW 314
13360: NOT
13361: IFFALSE 13438
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13363: LD_ADDR_VAR 0 2
13367: PUSH
13368: LD_VAR 0 4
13372: PPUSH
13373: LD_EXP 34
13377: PUSH
13378: LD_INT 1
13380: ARRAY
13381: PPUSH
13382: LD_EXP 34
13386: PUSH
13387: LD_INT 2
13389: ARRAY
13390: PPUSH
13391: LD_EXP 34
13395: PUSH
13396: LD_INT 3
13398: ARRAY
13399: PPUSH
13400: LD_EXP 34
13404: PUSH
13405: LD_INT 4
13407: ARRAY
13408: PPUSH
13409: CALL_OW 145
13413: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13414: LD_VAR 0 2
13418: PPUSH
13419: CALL_OW 266
13423: PUSH
13424: LD_INT 4
13426: EQUAL
13427: IFFALSE 13438
// AddComUpgrade ( i ) ;
13429: LD_VAR 0 2
13433: PPUSH
13434: CALL_OW 206
// end ; end ; end ; for i in engs do
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_VAR 0 4
13447: PUSH
13448: FOR_IN
13449: IFFALSE 13567
// begin if i in to_heal and sci then
13451: LD_VAR 0 2
13455: PUSH
13456: LD_VAR 0 6
13460: IN
13461: PUSH
13462: LD_VAR 0 7
13466: AND
13467: IFFALSE 13518
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13469: LD_VAR 0 2
13473: PPUSH
13474: LD_INT 149
13476: PPUSH
13477: LD_INT 220
13479: PPUSH
13480: CALL_OW 297
13484: PUSH
13485: LD_INT 5
13487: LESS
13488: IFFALSE 13492
// continue ;
13490: GO 13448
// ComMoveXY ( i , 149 , 220 ) ;
13492: LD_VAR 0 2
13496: PPUSH
13497: LD_INT 149
13499: PPUSH
13500: LD_INT 220
13502: PPUSH
13503: CALL_OW 111
// AddComHold ( i ) ;
13507: LD_VAR 0 2
13511: PPUSH
13512: CALL_OW 200
// end else
13516: GO 13565
// if not HasTask ( i ) or WantsToAttack ( i ) then
13518: LD_VAR 0 2
13522: PPUSH
13523: CALL_OW 314
13527: NOT
13528: PUSH
13529: LD_VAR 0 2
13533: PPUSH
13534: CALL_OW 319
13538: OR
13539: IFFALSE 13565
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13541: LD_VAR 0 2
13545: PPUSH
13546: LD_VAR 0 3
13550: PPUSH
13551: LD_VAR 0 2
13555: PPUSH
13556: CALL_OW 74
13560: PPUSH
13561: CALL_OW 130
// end ;
13565: GO 13448
13567: POP
13568: POP
// if to_heal and sci then
13569: LD_VAR 0 6
13573: PUSH
13574: LD_VAR 0 7
13578: AND
13579: IFFALSE 13640
// begin if UnitFilter ( sci , [ f_inside ] ) then
13581: LD_VAR 0 7
13585: PPUSH
13586: LD_INT 54
13588: PUSH
13589: EMPTY
13590: LIST
13591: PPUSH
13592: CALL_OW 72
13596: IFFALSE 13620
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13598: LD_VAR 0 7
13602: PPUSH
13603: LD_INT 54
13605: PUSH
13606: EMPTY
13607: LIST
13608: PPUSH
13609: CALL_OW 72
13613: PPUSH
13614: CALL_OW 122
13618: GO 13638
// ComHeal ( sci , to_heal [ 1 ] ) ;
13620: LD_VAR 0 7
13624: PPUSH
13625: LD_VAR 0 6
13629: PUSH
13630: LD_INT 1
13632: ARRAY
13633: PPUSH
13634: CALL_OW 128
// end else
13638: GO 13688
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_INT 56
13647: PUSH
13648: EMPTY
13649: LIST
13650: PPUSH
13651: CALL_OW 72
13655: PUSH
13656: LD_VAR 0 8
13660: AND
13661: IFFALSE 13688
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13663: LD_VAR 0 7
13667: PPUSH
13668: LD_INT 56
13670: PUSH
13671: EMPTY
13672: LIST
13673: PPUSH
13674: CALL_OW 72
13678: PPUSH
13679: LD_VAR 0 8
13683: PPUSH
13684: CALL_OW 120
// end ;
13688: PPOPN 8
13690: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13691: LD_INT 22
13693: PUSH
13694: LD_INT 3
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: PUSH
13701: LD_INT 30
13703: PUSH
13704: LD_INT 3
13706: PUSH
13707: EMPTY
13708: LIST
13709: LIST
13710: PUSH
13711: EMPTY
13712: LIST
13713: LIST
13714: PPUSH
13715: CALL_OW 69
13719: PUSH
13720: LD_EXP 35
13724: AND
13725: IFFALSE 13851
13727: GO 13729
13729: DISABLE
13730: LD_INT 0
13732: PPUSH
13733: PPUSH
13734: PPUSH
// begin enable ;
13735: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13736: LD_ADDR_VAR 0 3
13740: PUSH
13741: LD_INT 22
13743: PUSH
13744: LD_INT 3
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: LD_INT 30
13753: PUSH
13754: LD_INT 3
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: PPUSH
13765: CALL_OW 69
13769: PUSH
13770: LD_INT 1
13772: ARRAY
13773: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL_OW 313
13783: PUSH
13784: LD_INT 0
13786: EQUAL
13787: IFFALSE 13791
// exit ;
13789: GO 13851
// if BuildingStatus ( fac ) = bs_idle then
13791: LD_VAR 0 3
13795: PPUSH
13796: CALL_OW 461
13800: PUSH
13801: LD_INT 2
13803: EQUAL
13804: IFFALSE 13851
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
13806: LD_VAR 0 3
13810: PPUSH
13811: LD_EXP 35
13815: PUSH
13816: LD_INT 1
13818: ARRAY
13819: PPUSH
13820: LD_EXP 35
13824: PUSH
13825: LD_INT 2
13827: ARRAY
13828: PPUSH
13829: LD_EXP 35
13833: PUSH
13834: LD_INT 3
13836: ARRAY
13837: PPUSH
13838: LD_EXP 35
13842: PUSH
13843: LD_INT 4
13845: ARRAY
13846: PPUSH
13847: CALL_OW 125
// end ;
13851: PPOPN 3
13853: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
13854: LD_INT 0
13856: PPUSH
13857: PPUSH
13858: PPUSH
13859: PPUSH
13860: PPUSH
// uc_side := 3 ;
13861: LD_ADDR_OWVAR 20
13865: PUSH
13866: LD_INT 3
13868: ST_TO_ADDR
// uc_nation := 3 ;
13869: LD_ADDR_OWVAR 21
13873: PUSH
13874: LD_INT 3
13876: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
13877: LD_ADDR_VAR 0 6
13881: PUSH
13882: LD_INT 22
13884: PUSH
13885: LD_INT 3
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PUSH
13892: LD_INT 30
13894: PUSH
13895: LD_INT 3
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PPUSH
13906: CALL_OW 69
13910: ST_TO_ADDR
// if fac then
13911: LD_VAR 0 6
13915: IFFALSE 14073
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
13917: LD_ADDR_EXP 35
13921: PUSH
13922: LD_INT 24
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: LD_INT 3
13930: PUSH
13931: LD_INT 43
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: ST_TO_ADDR
// for i = 1 to Difficulty do
13940: LD_ADDR_VAR 0 3
13944: PUSH
13945: DOUBLE
13946: LD_INT 1
13948: DEC
13949: ST_TO_ADDR
13950: LD_OWVAR 67
13954: PUSH
13955: FOR_TO
13956: IFFALSE 14005
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher , ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ;
13958: LD_ADDR_EXP 35
13962: PUSH
13963: LD_EXP 35
13967: PUSH
13968: LD_INT 24
13970: PUSH
13971: LD_INT 1
13973: PUSH
13974: LD_INT 3
13976: PUSH
13977: LD_INT 45
13979: PUSH
13980: LD_INT 24
13982: PUSH
13983: LD_INT 1
13985: PUSH
13986: LD_INT 3
13988: PUSH
13989: LD_INT 46
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: ADD
14002: ST_TO_ADDR
14003: GO 13955
14005: POP
14006: POP
// repeat wait ( 0 0$1 ) ;
14007: LD_INT 35
14009: PPUSH
14010: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14014: LD_EXP 35
14018: PUSH
14019: LD_INT 4
14021: LESS
14022: PUSH
14023: LD_VAR 0 6
14027: PUSH
14028: LD_INT 1
14030: ARRAY
14031: PPUSH
14032: CALL_OW 313
14036: PUSH
14037: LD_INT 0
14039: EQUAL
14040: OR
14041: PUSH
14042: LD_VAR 0 6
14046: PUSH
14047: LD_INT 1
14049: ARRAY
14050: PPUSH
14051: CALL_OW 461
14055: PUSH
14056: LD_INT 8
14058: PUSH
14059: LD_INT 6
14061: PUSH
14062: LD_INT 7
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: LIST
14069: IN
14070: OR
14071: IFFALSE 14007
// end ; case wave of 1 :
14073: LD_VAR 0 1
14077: PUSH
14078: LD_INT 1
14080: DOUBLE
14081: EQUAL
14082: IFTRUE 14086
14084: GO 14171
14086: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14087: LD_ADDR_VAR 0 3
14091: PUSH
14092: DOUBLE
14093: LD_INT 1
14095: DEC
14096: ST_TO_ADDR
14097: LD_INT 4
14099: PUSH
14100: LD_INT 5
14102: PUSH
14103: LD_INT 6
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: PUSH
14111: LD_OWVAR 67
14115: ARRAY
14116: PUSH
14117: FOR_TO
14118: IFFALSE 14126
// Sold ;
14120: CALL 14296 0 0
14124: GO 14117
14126: POP
14127: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14128: LD_ADDR_VAR 0 3
14132: PUSH
14133: DOUBLE
14134: LD_INT 1
14136: DEC
14137: ST_TO_ADDR
14138: LD_INT 2
14140: PUSH
14141: LD_INT 3
14143: PUSH
14144: LD_INT 3
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: LIST
14151: PUSH
14152: LD_OWVAR 67
14156: ARRAY
14157: PUSH
14158: FOR_TO
14159: IFFALSE 14167
// Tank ;
14161: CALL 14410 0 0
14165: GO 14158
14167: POP
14168: POP
// end ; 2 .. 9 :
14169: GO 14291
14171: LD_INT 2
14173: DOUBLE
14174: GREATEREQUAL
14175: IFFALSE 14183
14177: LD_INT 9
14179: DOUBLE
14180: LESSEQUAL
14181: IFTRUE 14185
14183: GO 14290
14185: POP
// begin for i = 1 to [ 6 , 6 , 8 ] [ Difficulty ] + ( wave div 2 ) do
14186: LD_ADDR_VAR 0 3
14190: PUSH
14191: DOUBLE
14192: LD_INT 1
14194: DEC
14195: ST_TO_ADDR
14196: LD_INT 6
14198: PUSH
14199: LD_INT 6
14201: PUSH
14202: LD_INT 8
14204: PUSH
14205: EMPTY
14206: LIST
14207: LIST
14208: LIST
14209: PUSH
14210: LD_OWVAR 67
14214: ARRAY
14215: PUSH
14216: LD_VAR 0 1
14220: PUSH
14221: LD_INT 2
14223: DIV
14224: PLUS
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14235
// Sold ;
14229: CALL 14296 0 0
14233: GO 14226
14235: POP
14236: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14237: LD_ADDR_VAR 0 3
14241: PUSH
14242: DOUBLE
14243: LD_INT 1
14245: DEC
14246: ST_TO_ADDR
14247: LD_INT 3
14249: PUSH
14250: LD_INT 4
14252: PUSH
14253: LD_INT 4
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: LIST
14260: PUSH
14261: LD_OWVAR 67
14265: ARRAY
14266: PUSH
14267: LD_VAR 0 1
14271: PUSH
14272: LD_INT 2
14274: DIV
14275: PLUS
14276: PUSH
14277: FOR_TO
14278: IFFALSE 14286
// Tank ;
14280: CALL 14410 0 0
14284: GO 14277
14286: POP
14287: POP
// end ; end ;
14288: GO 14291
14290: POP
// end ;
14291: LD_VAR 0 2
14295: RET
// function Sold ( ) ; var un , skill ; begin
14296: LD_INT 0
14298: PPUSH
14299: PPUSH
14300: PPUSH
// InitHc ;
14301: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14305: LD_ADDR_VAR 0 3
14309: PUSH
14310: LD_INT 6
14312: PUSH
14313: LD_INT 7
14315: PUSH
14316: LD_INT 7
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: LIST
14323: PUSH
14324: LD_OWVAR 67
14328: ARRAY
14329: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14330: LD_INT 0
14332: PPUSH
14333: LD_INT 1
14335: PUSH
14336: LD_INT 9
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 1
14345: PPUSH
14346: LD_INT 2
14348: PPUSH
14349: CALL_OW 12
14353: ARRAY
14354: PPUSH
14355: LD_VAR 0 3
14359: PPUSH
14360: CALL_OW 380
// un := CreateHuman ;
14364: LD_ADDR_VAR 0 2
14368: PUSH
14369: CALL_OW 44
14373: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14374: LD_VAR 0 2
14378: PPUSH
14379: LD_INT 4
14381: PPUSH
14382: LD_INT 0
14384: PPUSH
14385: CALL_OW 49
// ru_force := ru_force ^ un ;
14389: LD_ADDR_EXP 33
14393: PUSH
14394: LD_EXP 33
14398: PUSH
14399: LD_VAR 0 2
14403: ADD
14404: ST_TO_ADDR
// end ;
14405: LD_VAR 0 1
14409: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14410: LD_INT 0
14412: PPUSH
14413: PPUSH
14414: PPUSH
14415: PPUSH
14416: PPUSH
// InitHc ;
14417: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14421: LD_ADDR_VAR 0 5
14425: PUSH
14426: LD_INT 5
14428: PUSH
14429: LD_INT 6
14431: PUSH
14432: LD_INT 7
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: LIST
14439: PUSH
14440: LD_OWVAR 67
14444: ARRAY
14445: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14446: LD_ADDR_VAR 0 3
14450: PUSH
14451: LD_INT 22
14453: PUSH
14454: LD_INT 24
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: LD_INT 1
14463: PPUSH
14464: LD_INT 2
14466: PPUSH
14467: CALL_OW 12
14471: ARRAY
14472: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14473: LD_VAR 0 3
14477: PUSH
14478: LD_INT 22
14480: EQUAL
14481: IFFALSE 14516
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14483: LD_ADDR_VAR 0 4
14487: PUSH
14488: LD_INT 45
14490: PUSH
14491: LD_INT 43
14493: PUSH
14494: LD_INT 44
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: LIST
14501: PUSH
14502: LD_INT 1
14504: PPUSH
14505: LD_INT 3
14507: PPUSH
14508: CALL_OW 12
14512: ARRAY
14513: ST_TO_ADDR
14514: GO 14547
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14516: LD_ADDR_VAR 0 4
14520: PUSH
14521: LD_INT 46
14523: PUSH
14524: LD_INT 44
14526: PUSH
14527: LD_INT 45
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: LIST
14534: PUSH
14535: LD_INT 1
14537: PPUSH
14538: LD_INT 3
14540: PPUSH
14541: CALL_OW 12
14545: ARRAY
14546: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14547: LD_ADDR_VAR 0 2
14551: PUSH
14552: LD_INT 3
14554: PPUSH
14555: LD_INT 3
14557: PPUSH
14558: LD_VAR 0 3
14562: PPUSH
14563: LD_INT 1
14565: PPUSH
14566: LD_INT 3
14568: PUSH
14569: LD_INT 3
14571: PUSH
14572: LD_INT 3
14574: PUSH
14575: LD_INT 1
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: PUSH
14584: LD_INT 1
14586: PPUSH
14587: LD_INT 4
14589: PPUSH
14590: CALL_OW 12
14594: ARRAY
14595: PPUSH
14596: LD_VAR 0 4
14600: PPUSH
14601: LD_INT 99
14603: PPUSH
14604: CALL 256 0 7
14608: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14609: LD_VAR 0 2
14613: PPUSH
14614: CALL_OW 263
14618: PUSH
14619: LD_INT 1
14621: EQUAL
14622: IFFALSE 14653
// begin PrepareHuman ( false , 3 , skill ) ;
14624: LD_INT 0
14626: PPUSH
14627: LD_INT 3
14629: PPUSH
14630: LD_VAR 0 5
14634: PPUSH
14635: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
14639: CALL_OW 44
14643: PPUSH
14644: LD_VAR 0 2
14648: PPUSH
14649: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
14653: LD_VAR 0 2
14657: PPUSH
14658: LD_INT 3
14660: PPUSH
14661: LD_INT 0
14663: PPUSH
14664: CALL_OW 49
// ru_force := ru_force ^ un ;
14668: LD_ADDR_EXP 33
14672: PUSH
14673: LD_EXP 33
14677: PUSH
14678: LD_VAR 0 2
14682: ADD
14683: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
14684: LD_VAR 0 2
14688: PPUSH
14689: LD_INT 126
14691: PPUSH
14692: LD_INT 158
14694: PPUSH
14695: CALL_OW 111
// Wait ( 0 0$3 ) ;
14699: LD_INT 105
14701: PPUSH
14702: CALL_OW 67
// ComStop ( un ) ;
14706: LD_VAR 0 2
14710: PPUSH
14711: CALL_OW 141
// end ;
14715: LD_VAR 0 1
14719: RET
// every 0 0$1 do var i , time , wave ;
14720: GO 14722
14722: DISABLE
14723: LD_INT 0
14725: PPUSH
14726: PPUSH
14727: PPUSH
// begin time := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
14728: LD_ADDR_VAR 0 2
14732: PUSH
14733: LD_INT 25200
14735: PUSH
14736: LD_INT 23100
14738: PUSH
14739: LD_INT 21000
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: LIST
14746: PUSH
14747: LD_OWVAR 67
14751: ARRAY
14752: ST_TO_ADDR
// wait ( time ) ;
14753: LD_VAR 0 2
14757: PPUSH
14758: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
14762: LD_ADDR_VAR 0 2
14766: PUSH
14767: LD_INT 17850
14769: PUSH
14770: LD_INT 16450
14772: PUSH
14773: LD_INT 15750
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: LIST
14780: PUSH
14781: LD_OWVAR 67
14785: ARRAY
14786: ST_TO_ADDR
// wave := 0 ;
14787: LD_ADDR_VAR 0 3
14791: PUSH
14792: LD_INT 0
14794: ST_TO_ADDR
// while true do
14795: LD_INT 1
14797: IFFALSE 14894
// begin wave := wave + 1 ;
14799: LD_ADDR_VAR 0 3
14803: PUSH
14804: LD_VAR 0 3
14808: PUSH
14809: LD_INT 1
14811: PLUS
14812: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
14813: LD_INT 22
14815: PUSH
14816: LD_INT 2
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PPUSH
14823: CALL_OW 69
14827: IFFALSE 14856
// repeat wait ( 0 0$1 ) ;
14829: LD_INT 35
14831: PPUSH
14832: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
14836: LD_INT 22
14838: PUSH
14839: LD_INT 2
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: PPUSH
14846: CALL_OW 69
14850: PUSH
14851: LD_INT 0
14853: EQUAL
14854: IFFALSE 14829
// if ru_force < 20 then
14856: LD_EXP 33
14860: PUSH
14861: LD_INT 20
14863: LESS
14864: IFFALSE 14875
// PrepareAttack ( wave ) ;
14866: LD_VAR 0 3
14870: PPUSH
14871: CALL 13854 0 1
// ru_can_attack := true ;
14875: LD_ADDR_EXP 8
14879: PUSH
14880: LD_INT 1
14882: ST_TO_ADDR
// wait ( time ) ;
14883: LD_VAR 0 2
14887: PPUSH
14888: CALL_OW 67
// end ;
14892: GO 14795
// end ;
14894: PPOPN 3
14896: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
14897: LD_EXP 8
14901: PUSH
14902: LD_EXP 33
14906: AND
14907: IFFALSE 15649
14909: GO 14911
14911: DISABLE
14912: LD_INT 0
14914: PPUSH
14915: PPUSH
14916: PPUSH
14917: PPUSH
14918: PPUSH
14919: PPUSH
14920: PPUSH
14921: PPUSH
14922: PPUSH
// begin enable ;
14923: ENABLE
// points1 := [ 107 , 123 ] ;
14924: LD_ADDR_VAR 0 4
14928: PUSH
14929: LD_INT 107
14931: PUSH
14932: LD_INT 123
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
14939: LD_ADDR_VAR 0 5
14943: PUSH
14944: LD_INT 55
14946: PUSH
14947: LD_INT 42
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
14954: LD_ADDR_VAR 0 6
14958: PUSH
14959: LD_INT 102
14961: PUSH
14962: LD_INT 140
14964: PUSH
14965: EMPTY
14966: LIST
14967: LIST
14968: PUSH
14969: LD_INT 105
14971: PUSH
14972: LD_INT 142
14974: PUSH
14975: EMPTY
14976: LIST
14977: LIST
14978: PUSH
14979: LD_INT 129
14981: PUSH
14982: LD_INT 131
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: PUSH
14989: EMPTY
14990: LIST
14991: LIST
14992: LIST
14993: ST_TO_ADDR
// for i in ru_force do
14994: LD_ADDR_VAR 0 1
14998: PUSH
14999: LD_EXP 33
15003: PUSH
15004: FOR_IN
15005: IFFALSE 15647
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15007: LD_ADDR_VAR 0 3
15011: PUSH
15012: LD_INT 81
15014: PUSH
15015: LD_INT 3
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: PPUSH
15022: CALL_OW 69
15026: PPUSH
15027: LD_VAR 0 1
15031: PPUSH
15032: CALL_OW 74
15036: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 10 then
15037: LD_VAR 0 1
15041: PPUSH
15042: LD_VAR 0 3
15046: PPUSH
15047: CALL_OW 296
15051: PUSH
15052: LD_INT 10
15054: LESS
15055: IFFALSE 15200
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15057: LD_VAR 0 1
15061: PPUSH
15062: CALL_OW 247
15066: PUSH
15067: LD_INT 1
15069: EQUAL
15070: PUSH
15071: LD_VAR 0 1
15075: PPUSH
15076: CALL_OW 257
15080: PUSH
15081: LD_INT 1
15083: EQUAL
15084: AND
15085: PUSH
15086: LD_VAR 0 3
15090: PUSH
15091: LD_INT 21
15093: PUSH
15094: LD_INT 2
15096: PUSH
15097: EMPTY
15098: LIST
15099: LIST
15100: PUSH
15101: LD_INT 58
15103: PUSH
15104: EMPTY
15105: LIST
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: PPUSH
15111: CALL_OW 69
15115: IN
15116: AND
15117: IFFALSE 15135
// ComEnterUnit ( i , un ) else
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_VAR 0 3
15128: PPUSH
15129: CALL_OW 120
15133: GO 15198
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15135: LD_VAR 0 3
15139: PUSH
15140: LD_INT 21
15142: PUSH
15143: LD_INT 2
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PUSH
15150: LD_INT 58
15152: PUSH
15153: EMPTY
15154: LIST
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PPUSH
15160: CALL_OW 69
15164: IN
15165: NOT
15166: IFFALSE 15184
// ComAttackUnit ( i , un ) else
15168: LD_VAR 0 1
15172: PPUSH
15173: LD_VAR 0 3
15177: PPUSH
15178: CALL_OW 115
15182: GO 15198
// ComAttackUnit ( i , JMM ) ;
15184: LD_VAR 0 1
15188: PPUSH
15189: LD_EXP 17
15193: PPUSH
15194: CALL_OW 115
// end else
15198: GO 15645
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
15200: LD_VAR 0 1
15204: PPUSH
15205: LD_VAR 0 4
15209: PUSH
15210: LD_INT 1
15212: ARRAY
15213: PPUSH
15214: LD_VAR 0 4
15218: PUSH
15219: LD_INT 2
15221: ARRAY
15222: PPUSH
15223: CALL_OW 297
15227: PUSH
15228: LD_VAR 0 1
15232: PPUSH
15233: LD_VAR 0 5
15237: PUSH
15238: LD_INT 1
15240: ARRAY
15241: PPUSH
15242: LD_VAR 0 5
15246: PUSH
15247: LD_INT 2
15249: ARRAY
15250: PPUSH
15251: CALL_OW 297
15255: GREATER
15256: PUSH
15257: LD_EXP 9
15261: AND
15262: PUSH
15263: LD_INT 9
15265: PPUSH
15266: LD_INT 22
15268: PUSH
15269: LD_INT 1
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: PPUSH
15276: CALL_OW 70
15280: PUSH
15281: LD_INT 0
15283: EQUAL
15284: OR
15285: IFFALSE 15316
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15287: LD_VAR 0 1
15291: PPUSH
15292: LD_VAR 0 5
15296: PUSH
15297: LD_INT 1
15299: ARRAY
15300: PPUSH
15301: LD_VAR 0 5
15305: PUSH
15306: LD_INT 2
15308: ARRAY
15309: PPUSH
15310: CALL_OW 114
15314: GO 15645
// begin if GetWeapon ( i ) = ru_rocket_launcher then
15316: LD_VAR 0 1
15320: PPUSH
15321: CALL_OW 264
15325: PUSH
15326: LD_INT 45
15328: EQUAL
15329: IFFALSE 15510
// begin dist := 9999 ;
15331: LD_ADDR_VAR 0 8
15335: PUSH
15336: LD_INT 9999
15338: ST_TO_ADDR
// xy := 0 ;
15339: LD_ADDR_VAR 0 9
15343: PUSH
15344: LD_INT 0
15346: ST_TO_ADDR
// for x in pointsr do
15347: LD_ADDR_VAR 0 7
15351: PUSH
15352: LD_VAR 0 6
15356: PUSH
15357: FOR_IN
15358: IFFALSE 15506
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15360: LD_VAR 0 1
15364: PPUSH
15365: LD_VAR 0 7
15369: PUSH
15370: LD_INT 1
15372: ARRAY
15373: PPUSH
15374: LD_VAR 0 7
15378: PUSH
15379: LD_INT 2
15381: ARRAY
15382: PPUSH
15383: CALL_OW 297
15387: PUSH
15388: LD_VAR 0 8
15392: LESS
15393: IFFALSE 15438
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15395: LD_ADDR_VAR 0 8
15399: PUSH
15400: LD_VAR 0 1
15404: PPUSH
15405: LD_VAR 0 7
15409: PUSH
15410: LD_INT 1
15412: ARRAY
15413: PPUSH
15414: LD_VAR 0 7
15418: PUSH
15419: LD_INT 2
15421: ARRAY
15422: PPUSH
15423: CALL_OW 297
15427: ST_TO_ADDR
// xy := x ;
15428: LD_ADDR_VAR 0 9
15432: PUSH
15433: LD_VAR 0 7
15437: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15438: LD_VAR 0 9
15442: PUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 9
15452: PUSH
15453: LD_INT 1
15455: ARRAY
15456: PPUSH
15457: LD_VAR 0 9
15461: PUSH
15462: LD_INT 2
15464: ARRAY
15465: PPUSH
15466: CALL_OW 297
15470: PUSH
15471: LD_INT 9
15473: GREATER
15474: AND
15475: IFFALSE 15504
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15477: LD_VAR 0 1
15481: PPUSH
15482: LD_VAR 0 9
15486: PUSH
15487: LD_INT 1
15489: ARRAY
15490: PPUSH
15491: LD_VAR 0 9
15495: PUSH
15496: LD_INT 2
15498: ARRAY
15499: PPUSH
15500: CALL_OW 114
// end ;
15504: GO 15357
15506: POP
15507: POP
// end else
15508: GO 15645
// begin un := NearestUnitToUnit ( un , all_units diff un ) ;
15510: LD_ADDR_VAR 0 3
15514: PUSH
15515: LD_VAR 0 3
15519: PPUSH
15520: LD_OWVAR 3
15524: PUSH
15525: LD_VAR 0 3
15529: DIFF
15530: PPUSH
15531: CALL_OW 74
15535: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15536: LD_VAR 0 3
15540: PUSH
15541: LD_INT 21
15543: PUSH
15544: LD_INT 2
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: LD_INT 58
15553: PUSH
15554: EMPTY
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PPUSH
15561: CALL_OW 69
15565: IN
15566: PUSH
15567: LD_VAR 0 3
15571: PUSH
15572: LD_INT 22
15574: PUSH
15575: LD_INT 3
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: PUSH
15582: LD_INT 24
15584: PUSH
15585: LD_INT 249
15587: PUSH
15588: EMPTY
15589: LIST
15590: LIST
15591: PUSH
15592: EMPTY
15593: LIST
15594: LIST
15595: PPUSH
15596: CALL_OW 69
15600: IN
15601: OR
15602: IFFALSE 15618
// ComAttackUnit ( i , un ) ;
15604: LD_VAR 0 1
15608: PPUSH
15609: LD_VAR 0 3
15613: PPUSH
15614: CALL_OW 115
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
15618: LD_VAR 0 1
15622: PPUSH
15623: LD_VAR 0 4
15627: PUSH
15628: LD_INT 1
15630: ARRAY
15631: PPUSH
15632: LD_VAR 0 4
15636: PUSH
15637: LD_INT 2
15639: ARRAY
15640: PPUSH
15641: CALL_OW 114
// end ; end ; end ; end ;
15645: GO 15004
15647: POP
15648: POP
// end ;
15649: PPOPN 9
15651: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
15652: LD_INT 22
15654: PUSH
15655: LD_INT 3
15657: PUSH
15658: EMPTY
15659: LIST
15660: LIST
15661: PUSH
15662: LD_INT 32
15664: PUSH
15665: LD_INT 1
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: PPUSH
15676: CALL_OW 69
15680: IFFALSE 15768
15682: GO 15684
15684: DISABLE
15685: LD_INT 0
15687: PPUSH
15688: PPUSH
// begin enable ;
15689: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
15690: LD_ADDR_VAR 0 2
15694: PUSH
15695: LD_INT 22
15697: PUSH
15698: LD_INT 3
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: PUSH
15705: LD_INT 32
15707: PUSH
15708: LD_INT 1
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PUSH
15715: EMPTY
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: ST_TO_ADDR
// for i in tmp do
15724: LD_ADDR_VAR 0 1
15728: PUSH
15729: LD_VAR 0 2
15733: PUSH
15734: FOR_IN
15735: IFFALSE 15766
// if GetFuel ( i ) < 12 then
15737: LD_VAR 0 1
15741: PPUSH
15742: CALL_OW 261
15746: PUSH
15747: LD_INT 12
15749: LESS
15750: IFFALSE 15764
// SetFuel ( i , 12 ) ;
15752: LD_VAR 0 1
15756: PPUSH
15757: LD_INT 12
15759: PPUSH
15760: CALL_OW 240
15764: GO 15734
15766: POP
15767: POP
// end ;
15768: PPOPN 2
15770: END
