// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12616 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1708 0 0
// Action ;
  32: CALL 2641 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1676
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1676: LD_ADDR_EXP 25
1680: PUSH
1681: LD_STRING Powell
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_STRING 
1689: PPUSH
1690: CALL 201 0 3
1694: ST_TO_ADDR
// InitHc ;
1695: CALL_OW 19
// InitUc ;
1699: CALL_OW 18
// end ;
1703: LD_VAR 0 1
1707: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1708: LD_INT 0
1710: PPUSH
1711: PPUSH
1712: PPUSH
1713: PPUSH
1714: PPUSH
// uc_side := 4 ;
1715: LD_ADDR_OWVAR 20
1719: PUSH
1720: LD_INT 4
1722: ST_TO_ADDR
// uc_nation := 3 ;
1723: LD_ADDR_OWVAR 21
1727: PUSH
1728: LD_INT 3
1730: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_STRING 09_ovsyenko_base
1738: PPUSH
1739: LD_INT 0
1741: PUSH
1742: LD_INT 101
1744: PUSH
1745: LD_INT 118
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 500
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: LD_INT 31
1763: PUSH
1764: LD_INT 109
1766: PUSH
1767: LD_INT 114
1769: PUSH
1770: LD_INT 4
1772: PUSH
1773: LD_INT 500
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 115
1788: PUSH
1789: LD_INT 132
1791: PUSH
1792: LD_INT 5
1794: PUSH
1795: LD_INT 500
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 31
1807: PUSH
1808: LD_INT 98
1810: PUSH
1811: LD_INT 120
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 500
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL_OW 30
1837: ST_TO_ADDR
// for i in tmp do
1838: LD_ADDR_VAR 0 2
1842: PUSH
1843: LD_VAR 0 4
1847: PUSH
1848: FOR_IN
1849: IFFALSE 2005
// begin bc_type := i [ 1 ] ;
1851: LD_ADDR_OWVAR 42
1855: PUSH
1856: LD_VAR 0 2
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: ST_TO_ADDR
// bc_level := 3 ;
1865: LD_ADDR_OWVAR 43
1869: PUSH
1870: LD_INT 3
1872: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_VAR 0 2
1882: PUSH
1883: LD_INT 2
1885: ARRAY
1886: PPUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_INT 3
1894: ARRAY
1895: PPUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 4
1903: ARRAY
1904: PPUSH
1905: CALL_OW 47
1909: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 266
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: IFFALSE 1957
// begin SetBName ( b , ovsyenko ) ;
1925: LD_VAR 0 3
1929: PPUSH
1930: LD_STRING ovsyenko
1932: PPUSH
1933: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: CALL_OW 274
1946: PPUSH
1947: LD_INT 1
1949: PPUSH
1950: LD_INT 50
1952: PPUSH
1953: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 5
1964: ARRAY
1965: PUSH
1966: LD_INT 250
1968: LESS
1969: IFFALSE 1985
// SetLives ( b , 333 ) else
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_INT 333
1978: PPUSH
1979: CALL_OW 234
1983: GO 2003
// SetLives ( b , i [ 5 ] ) ;
1985: LD_VAR 0 3
1989: PPUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 5
1997: ARRAY
1998: PPUSH
1999: CALL_OW 234
// end ;
2003: GO 1848
2005: POP
2006: POP
// uc_nation := 1 ;
2007: LD_ADDR_OWVAR 21
2011: PUSH
2012: LD_INT 1
2014: ST_TO_ADDR
// tmp := [ ] ;
2015: LD_ADDR_VAR 0 4
2019: PUSH
2020: EMPTY
2021: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2022: LD_ADDR_EXP 19
2026: PUSH
2027: LD_STRING Gary
2029: PPUSH
2030: LD_EXP 2
2034: NOT
2035: PPUSH
2036: LD_STRING 
2038: PPUSH
2039: CALL 201 0 3
2043: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2044: LD_ADDR_VAR 0 4
2048: PUSH
2049: LD_VAR 0 4
2053: PUSH
2054: LD_EXP 19
2058: ADD
2059: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2060: LD_ADDR_EXP 20
2064: PUSH
2065: LD_STRING Bobby
2067: PPUSH
2068: LD_EXP 2
2072: NOT
2073: PPUSH
2074: LD_STRING 08_
2076: PPUSH
2077: CALL 201 0 3
2081: ST_TO_ADDR
// if not Bobby then
2082: LD_EXP 20
2086: NOT
2087: IFFALSE 2111
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2089: LD_ADDR_EXP 20
2093: PUSH
2094: LD_STRING Bobby
2096: PPUSH
2097: LD_EXP 2
2101: NOT
2102: PPUSH
2103: LD_STRING 03_
2105: PPUSH
2106: CALL 201 0 3
2110: ST_TO_ADDR
// if Bobby then
2111: LD_EXP 20
2115: IFFALSE 2133
// tmp := tmp ^ Bobby ;
2117: LD_ADDR_VAR 0 4
2121: PUSH
2122: LD_VAR 0 4
2126: PUSH
2127: LD_EXP 20
2131: ADD
2132: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2133: LD_ADDR_EXP 21
2137: PUSH
2138: LD_STRING Cyrus
2140: PPUSH
2141: LD_EXP 2
2145: NOT
2146: PPUSH
2147: LD_STRING 08_
2149: PPUSH
2150: CALL 201 0 3
2154: ST_TO_ADDR
// if not Cyrus then
2155: LD_EXP 21
2159: NOT
2160: IFFALSE 2184
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2162: LD_ADDR_EXP 21
2166: PUSH
2167: LD_STRING Cyrus
2169: PPUSH
2170: LD_EXP 2
2174: NOT
2175: PPUSH
2176: LD_STRING 03_
2178: PPUSH
2179: CALL 201 0 3
2183: ST_TO_ADDR
// if Cyrus then
2184: LD_EXP 21
2188: IFFALSE 2206
// tmp := tmp ^ Cyrus ;
2190: LD_ADDR_VAR 0 4
2194: PUSH
2195: LD_VAR 0 4
2199: PUSH
2200: LD_EXP 21
2204: ADD
2205: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2206: LD_ADDR_VAR 0 4
2210: PUSH
2211: LD_VAR 0 4
2215: PUSH
2216: LD_STRING 09_prev_squad
2218: PPUSH
2219: CALL_OW 31
2223: ADD
2224: ST_TO_ADDR
// tmp := tmp diff 0 ;
2225: LD_ADDR_VAR 0 4
2229: PUSH
2230: LD_VAR 0 4
2234: PUSH
2235: LD_INT 0
2237: DIFF
2238: ST_TO_ADDR
// if debug then
2239: LD_EXP 2
2243: IFFALSE 2294
// begin for i = 1 to 6 do
2245: LD_ADDR_VAR 0 2
2249: PUSH
2250: DOUBLE
2251: LD_INT 1
2253: DEC
2254: ST_TO_ADDR
2255: LD_INT 6
2257: PUSH
2258: FOR_TO
2259: IFFALSE 2292
// begin PrepareHuman ( false , 1 , 6 ) ;
2261: LD_INT 0
2263: PPUSH
2264: LD_INT 1
2266: PPUSH
2267: LD_INT 6
2269: PPUSH
2270: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2274: LD_ADDR_VAR 0 4
2278: PUSH
2279: LD_VAR 0 4
2283: PUSH
2284: CALL_OW 44
2288: ADD
2289: ST_TO_ADDR
// end ;
2290: GO 2258
2292: POP
2293: POP
// end ; for i in tmp do
2294: LD_ADDR_VAR 0 2
2298: PUSH
2299: LD_VAR 0 4
2303: PUSH
2304: FOR_IN
2305: IFFALSE 2364
// begin if GetClass ( i ) in [ 2 , 3 ] then
2307: LD_VAR 0 2
2311: PPUSH
2312: CALL_OW 257
2316: PUSH
2317: LD_INT 2
2319: PUSH
2320: LD_INT 3
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: IN
2327: IFFALSE 2341
// SetClass ( i , 1 ) ;
2329: LD_VAR 0 2
2333: PPUSH
2334: LD_INT 1
2336: PPUSH
2337: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2341: LD_VAR 0 2
2345: PPUSH
2346: LD_INT 106
2348: PPUSH
2349: LD_INT 122
2351: PPUSH
2352: LD_INT 5
2354: PPUSH
2355: LD_INT 0
2357: PPUSH
2358: CALL_OW 50
// end ;
2362: GO 2304
2364: POP
2365: POP
// tmp := tmp diff Gary ;
2366: LD_ADDR_VAR 0 4
2370: PUSH
2371: LD_VAR 0 4
2375: PUSH
2376: LD_EXP 19
2380: DIFF
2381: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2382: LD_ADDR_VAR 0 3
2386: PUSH
2387: LD_INT 22
2389: PUSH
2390: LD_INT 4
2392: PUSH
2393: EMPTY
2394: LIST
2395: LIST
2396: PUSH
2397: LD_INT 30
2399: PUSH
2400: LD_INT 31
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PUSH
2407: EMPTY
2408: LIST
2409: LIST
2410: PPUSH
2411: CALL_OW 69
2415: ST_TO_ADDR
// for i = 1 to b do
2416: LD_ADDR_VAR 0 2
2420: PUSH
2421: DOUBLE
2422: LD_INT 1
2424: DEC
2425: ST_TO_ADDR
2426: LD_VAR 0 3
2430: PUSH
2431: FOR_TO
2432: IFFALSE 2462
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2434: LD_VAR 0 4
2438: PUSH
2439: LD_VAR 0 2
2443: ARRAY
2444: PPUSH
2445: LD_VAR 0 3
2449: PUSH
2450: LD_VAR 0 2
2454: ARRAY
2455: PPUSH
2456: CALL_OW 120
// end ;
2460: GO 2431
2462: POP
2463: POP
// InitHc ;
2464: CALL_OW 19
// InitUc ;
2468: CALL_OW 18
// end ;
2472: LD_VAR 0 1
2476: RET
// export function PowellTransport ; var i , un ; begin
2477: LD_INT 0
2479: PPUSH
2480: PPUSH
2481: PPUSH
// uc_side := 4 ;
2482: LD_ADDR_OWVAR 20
2486: PUSH
2487: LD_INT 4
2489: ST_TO_ADDR
// uc_nation := 1 ;
2490: LD_ADDR_OWVAR 21
2494: PUSH
2495: LD_INT 1
2497: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2498: LD_INT 1
2500: PPUSH
2501: LD_INT 3
2503: PPUSH
2504: LD_INT 6
2506: PPUSH
2507: CALL_OW 380
// hc_name :=  ;
2511: LD_ADDR_OWVAR 26
2515: PUSH
2516: LD_STRING 
2518: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2519: LD_ADDR_OWVAR 33
2523: PUSH
2524: LD_STRING SecondCharsGal
2526: ST_TO_ADDR
// hc_face_number := 30 ;
2527: LD_ADDR_OWVAR 34
2531: PUSH
2532: LD_INT 30
2534: ST_TO_ADDR
// powell_trans := CreateHuman ;
2535: LD_ADDR_EXP 24
2539: PUSH
2540: CALL_OW 44
2544: ST_TO_ADDR
// hc_face_number := 31 ;
2545: LD_ADDR_OWVAR 34
2549: PUSH
2550: LD_INT 31
2552: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2553: LD_ADDR_EXP 24
2557: PUSH
2558: LD_EXP 24
2562: PUSH
2563: CALL_OW 44
2567: ADD
2568: ST_TO_ADDR
// for i = 1 to 2 do
2569: LD_ADDR_VAR 0 2
2573: PUSH
2574: DOUBLE
2575: LD_INT 1
2577: DEC
2578: ST_TO_ADDR
2579: LD_INT 2
2581: PUSH
2582: FOR_TO
2583: IFFALSE 2634
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_INT 4
2592: PPUSH
2593: LD_INT 1
2595: PPUSH
2596: LD_INT 3
2598: PPUSH
2599: LD_INT 1
2601: PPUSH
2602: LD_INT 1
2604: PPUSH
2605: LD_INT 12
2607: PPUSH
2608: LD_INT 66
2610: PPUSH
2611: CALL 264 0 7
2615: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2616: LD_ADDR_EXP 24
2620: PUSH
2621: LD_EXP 24
2625: PUSH
2626: LD_VAR 0 3
2630: ADD
2631: ST_TO_ADDR
// end ;
2632: GO 2582
2634: POP
2635: POP
// end ; end_of_file
2636: LD_VAR 0 1
2640: RET
// export function Action ; var i , veh ; begin
2641: LD_INT 0
2643: PPUSH
2644: PPUSH
2645: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2646: LD_EXP 23
2650: PPUSH
2651: LD_INT 0
2653: PPUSH
2654: LD_INT 50
2656: PPUSH
2657: LD_INT 38
2659: PPUSH
2660: LD_INT 2
2662: PPUSH
2663: CALL_OW 145
// InGameOn ;
2667: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2671: LD_INT 43
2673: PPUSH
2674: LD_INT 9
2676: PPUSH
2677: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2681: LD_EXP 18
2685: PPUSH
2686: LD_INT 54
2688: PPUSH
2689: LD_INT 34
2691: PPUSH
2692: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2696: LD_EXP 18
2700: PPUSH
2701: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2705: LD_EXP 18
2709: PPUSH
2710: LD_EXP 23
2714: PUSH
2715: LD_INT 1
2717: ARRAY
2718: PPUSH
2719: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2723: LD_INT 35
2725: PPUSH
2726: CALL_OW 67
// until See ( 4 , JMM ) ;
2730: LD_INT 4
2732: PPUSH
2733: LD_EXP 18
2737: PPUSH
2738: CALL_OW 292
2742: IFFALSE 2723
// CenterNowOnUnits ( JMM ) ;
2744: LD_EXP 18
2748: PPUSH
2749: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2753: LD_EXP 18
2757: PPUSH
2758: LD_STRING D2-JMM-1
2760: PPUSH
2761: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2765: LD_EXP 23
2769: PUSH
2770: LD_INT 3
2772: ARRAY
2773: PPUSH
2774: LD_EXP 18
2778: PPUSH
2779: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2783: LD_EXP 23
2787: PUSH
2788: LD_INT 3
2790: ARRAY
2791: PPUSH
2792: LD_STRING D2-Eng1-1
2794: PPUSH
2795: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2799: LD_EXP 18
2803: PPUSH
2804: LD_STRING D2-JMM-2
2806: PPUSH
2807: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2811: LD_EXP 23
2815: PUSH
2816: LD_INT 3
2818: ARRAY
2819: PPUSH
2820: LD_STRING D2-Eng1-2
2822: PPUSH
2823: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2827: LD_EXP 18
2831: PPUSH
2832: LD_STRING D2-JMM-3
2834: PPUSH
2835: CALL_OW 88
// if Houten then
2839: LD_EXP 22
2843: IFFALSE 3041
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2845: LD_ADDR_VAR 0 3
2849: PUSH
2850: LD_INT 4
2852: PPUSH
2853: LD_INT 1
2855: PPUSH
2856: LD_INT 3
2858: PPUSH
2859: LD_INT 2
2861: PPUSH
2862: LD_INT 1
2864: PPUSH
2865: LD_INT 4
2867: PPUSH
2868: LD_INT 55
2870: PPUSH
2871: CALL 264 0 7
2875: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2876: LD_VAR 0 3
2880: PPUSH
2881: LD_INT 3
2883: PPUSH
2884: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2888: LD_VAR 0 3
2892: PPUSH
2893: LD_INT 46
2895: PPUSH
2896: LD_INT 19
2898: PPUSH
2899: LD_INT 0
2901: PPUSH
2902: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2906: LD_EXP 22
2910: PPUSH
2911: LD_VAR 0 3
2915: PPUSH
2916: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2920: LD_EXP 22
2924: PPUSH
2925: LD_INT 49
2927: PPUSH
2928: LD_INT 33
2930: PPUSH
2931: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2935: LD_EXP 22
2939: PPUSH
2940: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2944: LD_EXP 22
2948: PPUSH
2949: LD_EXP 18
2953: PPUSH
2954: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2958: LD_INT 35
2960: PPUSH
2961: CALL_OW 67
// until See ( 1 , Houten ) ;
2965: LD_INT 1
2967: PPUSH
2968: LD_EXP 22
2972: PPUSH
2973: CALL_OW 292
2977: IFFALSE 2958
// ComTurnUnit ( JMM , Houten ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_EXP 22
2988: PPUSH
2989: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2993: LD_EXP 18
2997: PPUSH
2998: LD_STRING D1d-JMM-1
3000: PPUSH
3001: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3005: LD_EXP 22
3009: PPUSH
3010: LD_STRING D1-VanH-1
3012: PPUSH
3013: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3017: LD_EXP 18
3021: PPUSH
3022: LD_STRING D1-JMM-1v
3024: PPUSH
3025: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3029: LD_EXP 18
3033: PPUSH
3034: LD_STRING D1-JMM-2v
3036: PPUSH
3037: CALL_OW 88
// end ; InGameOff ;
3041: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3045: LD_STRING M1
3047: PPUSH
3048: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3052: LD_INT 22
3054: PUSH
3055: LD_INT 4
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: LD_INT 92
3064: PUSH
3065: LD_EXP 18
3069: PPUSH
3070: CALL_OW 250
3074: PUSH
3075: LD_EXP 18
3079: PPUSH
3080: CALL_OW 251
3084: PUSH
3085: LD_INT 15
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PPUSH
3098: CALL_OW 69
3102: PPUSH
3103: LD_INT 1
3105: PPUSH
3106: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3110: LD_EXP 23
3114: PUSH
3115: LD_EXP 18
3119: ADD
3120: PUSH
3121: LD_EXP 22
3125: ADD
3126: PPUSH
3127: CALL_OW 141
// end ;
3131: LD_VAR 0 1
3135: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3136: LD_INT 1
3138: PPUSH
3139: LD_EXP 19
3143: PPUSH
3144: CALL_OW 292
3148: PUSH
3149: LD_EXP 18
3153: PPUSH
3154: LD_EXP 19
3158: PPUSH
3159: CALL_OW 296
3163: PUSH
3164: LD_INT 6
3166: LESS
3167: AND
3168: IFFALSE 3931
3170: GO 3172
3172: DISABLE
3173: LD_INT 0
3175: PPUSH
3176: PPUSH
3177: PPUSH
3178: PPUSH
3179: PPUSH
// begin InGameOn ;
3180: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3184: LD_INT 22
3186: PUSH
3187: LD_INT 4
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: PPUSH
3194: CALL_OW 69
3198: PPUSH
3199: LD_INT 1
3201: PPUSH
3202: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3206: LD_ADDR_VAR 0 4
3210: PUSH
3211: LD_INT 22
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PUSH
3221: LD_INT 2
3223: PUSH
3224: LD_INT 25
3226: PUSH
3227: LD_INT 1
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: LD_INT 25
3236: PUSH
3237: LD_INT 2
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PUSH
3244: LD_INT 25
3246: PUSH
3247: LD_INT 3
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: PUSH
3254: LD_INT 25
3256: PUSH
3257: LD_INT 4
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: PPUSH
3275: CALL_OW 69
3279: ST_TO_ADDR
// ComHold ( tmp ) ;
3280: LD_VAR 0 4
3284: PPUSH
3285: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3289: LD_EXP 18
3293: PPUSH
3294: LD_STRING D2-JMM-3a
3296: PPUSH
3297: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3301: LD_EXP 19
3305: PPUSH
3306: LD_EXP 18
3310: PPUSH
3311: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3315: LD_EXP 19
3319: PPUSH
3320: LD_STRING D2-Gary-3
3322: PPUSH
3323: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3327: LD_EXP 18
3331: PPUSH
3332: LD_EXP 19
3336: PPUSH
3337: CALL_OW 119
// for i in tmp do
3341: LD_ADDR_VAR 0 5
3345: PUSH
3346: LD_VAR 0 4
3350: PUSH
3351: FOR_IN
3352: IFFALSE 3397
// begin if IsInUnit ( i ) then
3354: LD_VAR 0 5
3358: PPUSH
3359: CALL_OW 310
3363: IFFALSE 3374
// ComExitBuilding ( i ) ;
3365: LD_VAR 0 5
3369: PPUSH
3370: CALL_OW 122
// wait ( 1 ) ;
3374: LD_INT 1
3376: PPUSH
3377: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3381: LD_VAR 0 5
3385: PPUSH
3386: LD_EXP 18
3390: PPUSH
3391: CALL_OW 119
// end ;
3395: GO 3351
3397: POP
3398: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3399: LD_ADDR_VAR 0 4
3403: PUSH
3404: LD_VAR 0 4
3408: PUSH
3409: LD_EXP 18
3413: PUSH
3414: LD_EXP 22
3418: PUSH
3419: LD_EXP 19
3423: PUSH
3424: LD_EXP 21
3428: PUSH
3429: LD_EXP 20
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: LD_EXP 23
3445: ADD
3446: DIFF
3447: ST_TO_ADDR
// if Bobby then
3448: LD_EXP 20
3452: IFFALSE 3466
// Say ( Bobby , D2-Bobby-3 ) ;
3454: LD_EXP 20
3458: PPUSH
3459: LD_STRING D2-Bobby-3
3461: PPUSH
3462: CALL_OW 88
// if Cyrus then
3466: LD_EXP 21
3470: IFFALSE 3484
// Say ( Cyrus , D2-Cyrus-3 ) ;
3472: LD_EXP 21
3476: PPUSH
3477: LD_STRING D2-Cyrus-3
3479: PPUSH
3480: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3484: LD_EXP 18
3488: PPUSH
3489: LD_STRING D2-JMM-4
3491: PPUSH
3492: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3496: LD_EXP 19
3500: PPUSH
3501: LD_STRING D2-Gary-4
3503: PPUSH
3504: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3508: LD_ADDR_VAR 0 1
3512: PUSH
3513: LD_VAR 0 4
3517: PPUSH
3518: LD_INT 26
3520: PUSH
3521: LD_INT 1
3523: PUSH
3524: EMPTY
3525: LIST
3526: LIST
3527: PPUSH
3528: CALL_OW 72
3532: PUSH
3533: LD_INT 1
3535: ARRAY
3536: ST_TO_ADDR
// if Cyrus then
3537: LD_EXP 21
3541: IFFALSE 3557
// Say ( Cyrus , D2-Cyrus-4 ) else
3543: LD_EXP 21
3547: PPUSH
3548: LD_STRING D2-Cyrus-4
3550: PPUSH
3551: CALL_OW 88
3555: GO 3569
// Say ( un1 , D2-Sol1-4 ) ;
3557: LD_VAR 0 1
3561: PPUSH
3562: LD_STRING D2-Sol1-4
3564: PPUSH
3565: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3569: LD_EXP 18
3573: PPUSH
3574: LD_STRING D2-JMM-5
3576: PPUSH
3577: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3581: LD_ADDR_VAR 0 2
3585: PUSH
3586: LD_EXP 23
3590: PPUSH
3591: LD_INT 91
3593: PUSH
3594: LD_EXP 18
3598: PUSH
3599: LD_INT 10
3601: PUSH
3602: EMPTY
3603: LIST
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 26
3609: PUSH
3610: LD_INT 2
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 72
3625: ST_TO_ADDR
// if un2 then
3626: LD_VAR 0 2
3630: IFFALSE 3684
// begin un2 := un2 [ un2 ] ;
3632: LD_ADDR_VAR 0 2
3636: PUSH
3637: LD_VAR 0 2
3641: PUSH
3642: LD_VAR 0 2
3646: ARRAY
3647: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_STRING D2-FEng1-5
3655: PPUSH
3656: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3660: LD_EXP 18
3664: PPUSH
3665: LD_STRING D2-JMM-6
3667: PPUSH
3668: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3672: LD_VAR 0 2
3676: PPUSH
3677: LD_STRING D2-FEng1-6
3679: PPUSH
3680: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3684: LD_ADDR_VAR 0 3
3688: PUSH
3689: LD_EXP 23
3693: PPUSH
3694: LD_INT 91
3696: PUSH
3697: LD_EXP 18
3701: PUSH
3702: LD_INT 10
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: LIST
3709: PUSH
3710: LD_INT 26
3712: PUSH
3713: LD_INT 1
3715: PUSH
3716: EMPTY
3717: LIST
3718: LIST
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PPUSH
3724: CALL_OW 72
3728: ST_TO_ADDR
// if un3 then
3729: LD_VAR 0 3
3733: IFFALSE 3788
// begin un3 := un3 [ 1 ] ;
3735: LD_ADDR_VAR 0 3
3739: PUSH
3740: LD_VAR 0 3
3744: PUSH
3745: LD_INT 1
3747: ARRAY
3748: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 114
3756: PPUSH
3757: LD_INT 122
3759: PPUSH
3760: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3764: LD_VAR 0 3
3768: PPUSH
3769: LD_STRING D2-Eng1-6
3771: PPUSH
3772: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3776: LD_EXP 18
3780: PPUSH
3781: LD_STRING D2-JMM-7
3783: PPUSH
3784: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3788: LD_EXP 19
3792: PPUSH
3793: LD_STRING D2-Gary-7
3795: PPUSH
3796: CALL_OW 88
// if un2 then
3800: LD_VAR 0 2
3804: IFFALSE 3818
// Say ( un2 , D2-FEng1-7 ) ;
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_STRING D2-FEng1-7
3813: PPUSH
3814: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3818: LD_VAR 0 1
3822: PPUSH
3823: LD_STRING D2-Sol1-7
3825: PPUSH
3826: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3830: LD_EXP 18
3834: PPUSH
3835: LD_STRING D2-JMM-8
3837: PPUSH
3838: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3842: LD_INT 22
3844: PUSH
3845: LD_INT 1
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PPUSH
3852: CALL_OW 69
3856: PPUSH
3857: CALL_OW 141
// InGameOff ;
3861: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3865: LD_STRING M1a
3867: PPUSH
3868: CALL_OW 337
// jmm_in_ovsyenko := true ;
3872: LD_ADDR_EXP 4
3876: PUSH
3877: LD_INT 1
3879: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3880: LD_INT 1050
3882: PPUSH
3883: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3887: LD_ADDR_VAR 0 4
3891: PUSH
3892: LD_INT 25
3894: PUSH
3895: LD_INT 14
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PPUSH
3902: CALL_OW 69
3906: ST_TO_ADDR
// if not tmp then
3907: LD_VAR 0 4
3911: NOT
3912: IFFALSE 3916
// exit ;
3914: GO 3931
// ComMoveXY ( tmp , 75 , 75 ) ;
3916: LD_VAR 0 4
3920: PPUSH
3921: LD_INT 75
3923: PPUSH
3924: LD_INT 75
3926: PPUSH
3927: CALL_OW 111
// end ;
3931: PPOPN 5
3933: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3934: LD_INT 22
3936: PUSH
3937: LD_INT 1
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: PUSH
3944: LD_INT 30
3946: PUSH
3947: LD_INT 30
3949: PUSH
3950: EMPTY
3951: LIST
3952: LIST
3953: PUSH
3954: LD_INT 3
3956: PUSH
3957: LD_INT 57
3959: PUSH
3960: EMPTY
3961: LIST
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: PUSH
3967: EMPTY
3968: LIST
3969: LIST
3970: LIST
3971: PPUSH
3972: CALL_OW 69
3976: IFFALSE 4018
3978: GO 3980
3980: DISABLE
3981: LD_INT 0
3983: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3984: LD_ADDR_VAR 0 1
3988: PUSH
3989: LD_STRING M2easy
3991: PUSH
3992: LD_STRING M2
3994: PUSH
3995: LD_STRING M2hard
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: LIST
4002: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4003: LD_VAR 0 1
4007: PUSH
4008: LD_OWVAR 67
4012: ARRAY
4013: PPUSH
4014: CALL_OW 337
// end ;
4018: PPOPN 1
4020: END
// every 3 3$00 do
4021: GO 4023
4023: DISABLE
// begin DialogueOn ;
4024: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4028: LD_EXP 25
4032: PPUSH
4033: LD_STRING D3-Pow-1
4035: PPUSH
4036: CALL_OW 94
// if jmm_in_ovsyenko then
4040: LD_EXP 4
4044: IFFALSE 4072
// begin Say ( JMM , D3-JMM-1 ) ;
4046: LD_EXP 18
4050: PPUSH
4051: LD_STRING D3-JMM-1
4053: PPUSH
4054: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4058: LD_EXP 18
4062: PPUSH
4063: LD_STRING D3-JMM-1b
4065: PPUSH
4066: CALL_OW 88
// end else
4070: GO 4084
// Say ( JMM , D3-JMM-1a ) ;
4072: LD_EXP 18
4076: PPUSH
4077: LD_STRING D3-JMM-1a
4079: PPUSH
4080: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4084: LD_EXP 25
4088: PPUSH
4089: LD_STRING D3-Pow-2
4091: PPUSH
4092: CALL_OW 94
// DialogueOff ;
4096: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4100: LD_STRING M3
4102: PPUSH
4103: CALL_OW 337
// powell_want_sib := true ;
4107: LD_ADDR_EXP 5
4111: PUSH
4112: LD_INT 1
4114: ST_TO_ADDR
// end ;
4115: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4116: LD_EXP 6
4120: PUSH
4121: LD_INT 0
4123: EQUAL
4124: IFFALSE 5571
4126: GO 4128
4128: DISABLE
4129: LD_INT 0
4131: PPUSH
4132: PPUSH
4133: PPUSH
4134: PPUSH
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4139: LD_INT 4
4141: PPUSH
4142: LD_INT 1
4144: PPUSH
4145: CALL_OW 343
// PowellTransport ;
4149: CALL 2477 0 0
// for i = 1 to 3 do
4153: LD_ADDR_VAR 0 4
4157: PUSH
4158: DOUBLE
4159: LD_INT 1
4161: DEC
4162: ST_TO_ADDR
4163: LD_INT 3
4165: PUSH
4166: FOR_TO
4167: IFFALSE 4234
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4169: LD_ADDR_VAR 0 1
4173: PUSH
4174: LD_INT 6
4176: PPUSH
4177: LD_VAR 0 4
4181: PPUSH
4182: CALL_OW 287
4186: ST_TO_ADDR
// if not tmp then
4187: LD_VAR 0 1
4191: NOT
4192: IFFALSE 4196
// continue ;
4194: GO 4166
// EraseResourceArea ( terminalArea , i ) ;
4196: LD_INT 6
4198: PPUSH
4199: LD_VAR 0 4
4203: PPUSH
4204: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4208: LD_EXP 3
4212: PPUSH
4213: CALL_OW 274
4217: PPUSH
4218: LD_VAR 0 4
4222: PPUSH
4223: LD_VAR 0 1
4227: PPUSH
4228: CALL_OW 276
// end ;
4232: GO 4166
4234: POP
4235: POP
// x := 43 ;
4236: LD_ADDR_VAR 0 2
4240: PUSH
4241: LD_INT 43
4243: ST_TO_ADDR
// y := 3 ;
4244: LD_ADDR_VAR 0 3
4248: PUSH
4249: LD_INT 3
4251: ST_TO_ADDR
// for i = 3 to 4 do
4252: LD_ADDR_VAR 0 4
4256: PUSH
4257: DOUBLE
4258: LD_INT 3
4260: DEC
4261: ST_TO_ADDR
4262: LD_INT 4
4264: PUSH
4265: FOR_TO
4266: IFFALSE 4457
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4268: LD_EXP 24
4272: PUSH
4273: LD_VAR 0 4
4277: ARRAY
4278: PPUSH
4279: LD_INT 4
4281: PPUSH
4282: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4286: LD_EXP 24
4290: PUSH
4291: LD_VAR 0 4
4295: ARRAY
4296: PPUSH
4297: LD_VAR 0 2
4301: PPUSH
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 0
4309: PPUSH
4310: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4314: LD_EXP 24
4318: PUSH
4319: LD_VAR 0 4
4323: PUSH
4324: LD_INT 2
4326: MINUS
4327: ARRAY
4328: PPUSH
4329: LD_EXP 24
4333: PUSH
4334: LD_VAR 0 4
4338: ARRAY
4339: PPUSH
4340: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4344: LD_EXP 24
4348: PUSH
4349: LD_VAR 0 4
4353: ARRAY
4354: PPUSH
4355: LD_INT 1
4357: PPUSH
4358: LD_INT 100
4360: PPUSH
4361: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4365: LD_EXP 24
4369: PUSH
4370: LD_VAR 0 4
4374: PUSH
4375: LD_INT 2
4377: MINUS
4378: ARRAY
4379: PPUSH
4380: LD_INT 54
4382: PPUSH
4383: LD_INT 42
4385: PPUSH
4386: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4390: LD_EXP 24
4394: PUSH
4395: LD_VAR 0 4
4399: PUSH
4400: LD_INT 2
4402: MINUS
4403: ARRAY
4404: PPUSH
4405: LD_EXP 3
4409: PPUSH
4410: CALL_OW 250
4414: PPUSH
4415: LD_EXP 3
4419: PPUSH
4420: CALL_OW 251
4424: PPUSH
4425: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4429: LD_EXP 24
4433: PUSH
4434: LD_VAR 0 4
4438: PUSH
4439: LD_INT 2
4441: MINUS
4442: ARRAY
4443: PPUSH
4444: CALL_OW 200
// Wait ( 0 0$02 ) ;
4448: LD_INT 70
4450: PPUSH
4451: CALL_OW 67
// end ;
4455: GO 4265
4457: POP
4458: POP
// time := 0 0$20 ;
4459: LD_ADDR_VAR 0 8
4463: PUSH
4464: LD_INT 700
4466: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4467: LD_INT 35
4469: PPUSH
4470: CALL_OW 67
// time := time - 0 0$01 ;
4474: LD_ADDR_VAR 0 8
4478: PUSH
4479: LD_VAR 0 8
4483: PUSH
4484: LD_INT 35
4486: MINUS
4487: ST_TO_ADDR
// for i = 3 to 4 do
4488: LD_ADDR_VAR 0 4
4492: PUSH
4493: DOUBLE
4494: LD_INT 3
4496: DEC
4497: ST_TO_ADDR
4498: LD_INT 4
4500: PUSH
4501: FOR_TO
4502: IFFALSE 4637
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4504: LD_EXP 24
4508: PUSH
4509: LD_VAR 0 4
4513: ARRAY
4514: PPUSH
4515: LD_INT 1
4517: PPUSH
4518: CALL_OW 289
4522: PUSH
4523: LD_INT 0
4525: GREATER
4526: PUSH
4527: LD_EXP 24
4531: PUSH
4532: LD_VAR 0 4
4536: ARRAY
4537: PPUSH
4538: CALL_OW 314
4542: NOT
4543: AND
4544: IFFALSE 4635
// begin x := rand ( 0 , 5 ) ;
4546: LD_ADDR_VAR 0 2
4550: PUSH
4551: LD_INT 0
4553: PPUSH
4554: LD_INT 5
4556: PPUSH
4557: CALL_OW 12
4561: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4562: LD_EXP 24
4566: PUSH
4567: LD_VAR 0 4
4571: ARRAY
4572: PPUSH
4573: LD_EXP 24
4577: PUSH
4578: LD_VAR 0 4
4582: ARRAY
4583: PPUSH
4584: CALL_OW 250
4588: PPUSH
4589: LD_VAR 0 2
4593: PPUSH
4594: LD_INT 3
4596: PPUSH
4597: CALL_OW 272
4601: PPUSH
4602: LD_EXP 24
4606: PUSH
4607: LD_VAR 0 4
4611: ARRAY
4612: PPUSH
4613: CALL_OW 251
4617: PPUSH
4618: LD_VAR 0 2
4622: PPUSH
4623: LD_INT 3
4625: PPUSH
4626: CALL_OW 273
4630: PPUSH
4631: CALL_OW 171
// end ;
4635: GO 4501
4637: POP
4638: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4639: LD_EXP 24
4643: PUSH
4644: LD_INT 1
4646: ARRAY
4647: PPUSH
4648: LD_INT 54
4650: PPUSH
4651: LD_INT 42
4653: PPUSH
4654: CALL_OW 297
4658: PUSH
4659: LD_INT 4
4661: LESS
4662: PUSH
4663: LD_VAR 0 8
4667: PUSH
4668: LD_INT 0
4670: EQUAL
4671: OR
4672: IFFALSE 4467
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4674: LD_EXP 24
4678: PUSH
4679: LD_INT 3
4681: ARRAY
4682: PPUSH
4683: LD_INT 1
4685: PPUSH
4686: LD_INT 0
4688: PPUSH
4689: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4693: LD_EXP 24
4697: PUSH
4698: LD_INT 4
4700: ARRAY
4701: PPUSH
4702: LD_INT 1
4704: PPUSH
4705: LD_INT 0
4707: PPUSH
4708: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4712: LD_EXP 3
4716: PPUSH
4717: CALL_OW 274
4721: PPUSH
4722: LD_INT 1
4724: PPUSH
4725: LD_INT 200
4727: PPUSH
4728: CALL_OW 276
// DialogueOn ;
4732: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4736: LD_INT 53
4738: PPUSH
4739: LD_INT 35
4741: PPUSH
4742: CALL_OW 86
// un := powell_trans [ 1 ] ;
4746: LD_ADDR_VAR 0 5
4750: PUSH
4751: LD_EXP 24
4755: PUSH
4756: LD_INT 1
4758: ARRAY
4759: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4760: LD_VAR 0 5
4764: PPUSH
4765: LD_STRING D4-Mech1-1
4767: PPUSH
4768: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4772: LD_EXP 18
4776: PPUSH
4777: LD_STRING D4-JMM-1
4779: PPUSH
4780: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4784: LD_VAR 0 5
4788: PPUSH
4789: LD_STRING D4-Mech1-2
4791: PPUSH
4792: CALL_OW 88
// powell_happy := false ;
4796: LD_ADDR_VAR 0 6
4800: PUSH
4801: LD_INT 0
4803: ST_TO_ADDR
// take_cargo := false ;
4804: LD_ADDR_VAR 0 7
4808: PUSH
4809: LD_INT 0
4811: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4812: CALL 784 0 0
4816: PUSH
4817: LD_INT 60
4819: GREATEREQUAL
4820: IFFALSE 4868
// begin Say ( JMM , D5-JMM-1 ) ;
4822: LD_EXP 18
4826: PPUSH
4827: LD_STRING D5-JMM-1
4829: PPUSH
4830: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4834: LD_VAR 0 5
4838: PPUSH
4839: LD_STRING D6-Mech1-1
4841: PPUSH
4842: CALL_OW 88
// powell_happy := true ;
4846: LD_ADDR_VAR 0 6
4850: PUSH
4851: LD_INT 1
4853: ST_TO_ADDR
// take_cargo := true ;
4854: LD_ADDR_VAR 0 7
4858: PUSH
4859: LD_INT 1
4861: ST_TO_ADDR
// DialogueOff ;
4862: CALL_OW 7
// end else
4866: GO 5102
// if GetTerminalCargo > 0 then
4868: CALL 784 0 0
4872: PUSH
4873: LD_INT 0
4875: GREATER
4876: IFFALSE 5074
// begin case Query ( QWait ) of 1 :
4878: LD_STRING QWait
4880: PPUSH
4881: CALL_OW 97
4885: PUSH
4886: LD_INT 1
4888: DOUBLE
4889: EQUAL
4890: IFTRUE 4894
4892: GO 4985
4894: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4895: LD_EXP 18
4899: PPUSH
4900: LD_STRING D5b-JMM-1
4902: PPUSH
4903: CALL_OW 88
// DialogueOff ;
4907: CALL_OW 7
// wait ( 5 5$00 ) ;
4911: LD_INT 10500
4913: PPUSH
4914: CALL_OW 67
// if GetTerminalCargo < 60 then
4918: CALL 784 0 0
4922: PUSH
4923: LD_INT 60
4925: LESS
4926: IFFALSE 4967
// begin DialogueOn ;
4928: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4932: LD_EXP 3
4936: PPUSH
4937: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4941: LD_VAR 0 5
4945: PPUSH
4946: LD_STRING D6-Mech1-1a
4948: PPUSH
4949: CALL_OW 88
// DialogueOff ;
4953: CALL_OW 7
// powell_happy := false ;
4957: LD_ADDR_VAR 0 6
4961: PUSH
4962: LD_INT 0
4964: ST_TO_ADDR
// end else
4965: GO 4983
// begin powell_happy := true ;
4967: LD_ADDR_VAR 0 6
4971: PUSH
4972: LD_INT 1
4974: ST_TO_ADDR
// take_cargo := true ;
4975: LD_ADDR_VAR 0 7
4979: PUSH
4980: LD_INT 1
4982: ST_TO_ADDR
// end ; end ; 2 :
4983: GO 5072
4985: LD_INT 2
4987: DOUBLE
4988: EQUAL
4989: IFTRUE 4993
4991: GO 5032
4993: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4994: LD_EXP 18
4998: PPUSH
4999: LD_STRING D5b-JMM-1
5001: PPUSH
5002: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5006: LD_VAR 0 5
5010: PPUSH
5011: LD_STRING D6-Mech1-1a
5013: PPUSH
5014: CALL_OW 88
// DialogueOff ;
5018: CALL_OW 7
// take_cargo := true ;
5022: LD_ADDR_VAR 0 7
5026: PUSH
5027: LD_INT 1
5029: ST_TO_ADDR
// end ; 3 :
5030: GO 5072
5032: LD_INT 3
5034: DOUBLE
5035: EQUAL
5036: IFTRUE 5040
5038: GO 5071
5040: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5041: LD_EXP 18
5045: PPUSH
5046: LD_STRING D5c-JMM-1
5048: PPUSH
5049: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5053: LD_VAR 0 5
5057: PPUSH
5058: LD_STRING D6-Mech1-1b
5060: PPUSH
5061: CALL_OW 88
// DialogueOff ;
5065: CALL_OW 7
// end ; end ;
5069: GO 5072
5071: POP
// end else
5072: GO 5102
// begin Say ( JMM , D5c-JMM-1 ) ;
5074: LD_EXP 18
5078: PPUSH
5079: LD_STRING D5c-JMM-1
5081: PPUSH
5082: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5086: LD_VAR 0 5
5090: PPUSH
5091: LD_STRING D6-Mech1-1b
5093: PPUSH
5094: CALL_OW 88
// DialogueOff ;
5098: CALL_OW 7
// end ; if take_cargo then
5102: LD_VAR 0 7
5106: IFFALSE 5185
// begin x := GetTerminalCargo ;
5108: LD_ADDR_VAR 0 2
5112: PUSH
5113: CALL 784 0 0
5117: ST_TO_ADDR
// if x > 60 then
5118: LD_VAR 0 2
5122: PUSH
5123: LD_INT 60
5125: GREATER
5126: IFFALSE 5136
// x := 60 ;
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: LD_INT 60
5135: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5136: LD_EXP 3
5140: PPUSH
5141: CALL_OW 274
5145: PPUSH
5146: LD_INT 3
5148: PPUSH
5149: CALL 784 0 0
5153: PUSH
5154: LD_VAR 0 2
5158: MINUS
5159: PPUSH
5160: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5164: LD_EXP 24
5168: PUSH
5169: LD_INT 3
5171: ARRAY
5172: PPUSH
5173: LD_INT 3
5175: PPUSH
5176: LD_VAR 0 2
5180: PPUSH
5181: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5185: LD_EXP 24
5189: PPUSH
5190: LD_INT 43
5192: PPUSH
5193: LD_INT 3
5195: PPUSH
5196: CALL_OW 171
// x := 0 0$20 ;
5200: LD_ADDR_VAR 0 2
5204: PUSH
5205: LD_INT 700
5207: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5208: LD_INT 35
5210: PPUSH
5211: CALL_OW 67
// x := x - 0 0$01 ;
5215: LD_ADDR_VAR 0 2
5219: PUSH
5220: LD_VAR 0 2
5224: PUSH
5225: LD_INT 35
5227: MINUS
5228: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5229: LD_VAR 0 2
5233: PUSH
5234: LD_INT 0
5236: EQUAL
5237: PUSH
5238: LD_EXP 24
5242: PUSH
5243: LD_INT 3
5245: ARRAY
5246: PPUSH
5247: LD_INT 43
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: CALL_OW 297
5257: PUSH
5258: LD_INT 4
5260: LESS
5261: PUSH
5262: LD_EXP 24
5266: PUSH
5267: LD_INT 3
5269: ARRAY
5270: PPUSH
5271: LD_INT 43
5273: PPUSH
5274: LD_INT 3
5276: PPUSH
5277: CALL_OW 297
5281: PUSH
5282: LD_INT 4
5284: LESS
5285: AND
5286: OR
5287: IFFALSE 5208
// for i in powell_trans do
5289: LD_ADDR_VAR 0 4
5293: PUSH
5294: LD_EXP 24
5298: PUSH
5299: FOR_IN
5300: IFFALSE 5313
// RemoveUnit ( i ) ;
5302: LD_VAR 0 4
5306: PPUSH
5307: CALL_OW 64
5311: GO 5299
5313: POP
5314: POP
// if not powell_happy then
5315: LD_VAR 0 6
5319: NOT
5320: IFFALSE 5331
// powell_happy := - 1 ;
5322: LD_ADDR_VAR 0 6
5326: PUSH
5327: LD_INT 1
5329: NEG
5330: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5331: LD_STRING EarlySiberite
5333: PPUSH
5334: LD_VAR 0 6
5338: PPUSH
5339: CALL_OW 101
// if powell_happy then
5343: LD_VAR 0 6
5347: IFFALSE 5358
// ChangeMissionObjectives ( M3a ) else
5349: LD_STRING M3a
5351: PPUSH
5352: CALL_OW 337
5356: GO 5365
// ChangeMissionObjectives ( M3b ) ;
5358: LD_STRING M3b
5360: PPUSH
5361: CALL_OW 337
// ru_can_attack_terminal := true ;
5365: LD_ADDR_EXP 9
5369: PUSH
5370: LD_INT 1
5372: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5373: LD_INT 25200
5375: PPUSH
5376: CALL_OW 67
// time := 2 2$00 ;
5380: LD_ADDR_VAR 0 8
5384: PUSH
5385: LD_INT 4200
5387: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5388: LD_INT 35
5390: PPUSH
5391: CALL_OW 67
// time := time - 0 0$1 ;
5395: LD_ADDR_VAR 0 8
5399: PUSH
5400: LD_VAR 0 8
5404: PUSH
5405: LD_INT 35
5407: MINUS
5408: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5409: LD_EXP 8
5413: NOT
5414: PUSH
5415: LD_EXP 35
5419: PUSH
5420: LD_INT 0
5422: EQUAL
5423: OR
5424: PUSH
5425: LD_VAR 0 8
5429: PUSH
5430: LD_INT 0
5432: EQUAL
5433: OR
5434: IFFALSE 5388
// if ru_force then
5436: LD_EXP 35
5440: IFFALSE 5539
// for i in ru_force do
5442: LD_ADDR_VAR 0 4
5446: PUSH
5447: LD_EXP 35
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5537
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5455: LD_INT 1
5457: PPUSH
5458: LD_VAR 0 4
5462: PPUSH
5463: CALL_OW 292
5467: NOT
5468: PUSH
5469: LD_VAR 0 4
5473: PPUSH
5474: LD_INT 81
5476: PUSH
5477: LD_INT 3
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PPUSH
5484: CALL_OW 69
5488: PPUSH
5489: LD_VAR 0 4
5493: PPUSH
5494: CALL_OW 74
5498: PPUSH
5499: CALL_OW 296
5503: PUSH
5504: LD_INT 10
5506: GREATER
5507: AND
5508: IFFALSE 5535
// begin RemoveUnit ( i ) ;
5510: LD_VAR 0 4
5514: PPUSH
5515: CALL_OW 64
// ru_force := ru_force diff i ;
5519: LD_ADDR_EXP 35
5523: PUSH
5524: LD_EXP 35
5528: PUSH
5529: LD_VAR 0 4
5533: DIFF
5534: ST_TO_ADDR
// end ;
5535: GO 5452
5537: POP
5538: POP
// repeat wait ( 0 0$03 ) ;
5539: LD_INT 105
5541: PPUSH
5542: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5546: LD_EXP 8
5550: NOT
5551: PUSH
5552: LD_EXP 35
5556: PUSH
5557: LD_INT 3
5559: LESS
5560: OR
5561: IFFALSE 5539
// ar_can_arrive := true ;
5563: LD_ADDR_EXP 10
5567: PUSH
5568: LD_INT 1
5570: ST_TO_ADDR
// end ;
5571: PPOPN 8
5573: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5574: LD_INT 1
5576: PPUSH
5577: LD_INT 20
5579: PPUSH
5580: CALL_OW 325
5584: IFFALSE 5725
5586: GO 5588
5588: DISABLE
5589: LD_INT 0
5591: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5592: LD_ADDR_VAR 0 1
5596: PUSH
5597: LD_INT 22
5599: PUSH
5600: LD_INT 1
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 26
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: EMPTY
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 25
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: CALL_OW 69
5636: PUSH
5637: LD_EXP 18
5641: PUSH
5642: LD_EXP 21
5646: PUSH
5647: LD_EXP 20
5651: PUSH
5652: LD_EXP 22
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: LIST
5661: LIST
5662: DIFF
5663: ST_TO_ADDR
// if not un then
5664: LD_VAR 0 1
5668: NOT
5669: IFFALSE 5673
// exit ;
5671: GO 5725
// DialogueOn ;
5673: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5677: LD_VAR 0 1
5681: PUSH
5682: LD_INT 1
5684: ARRAY
5685: PPUSH
5686: LD_STRING D13-Sci1-1
5688: PPUSH
5689: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5693: LD_EXP 18
5697: PPUSH
5698: LD_STRING D13-JMM-1
5700: PPUSH
5701: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5705: LD_VAR 0 1
5709: PUSH
5710: LD_INT 1
5712: ARRAY
5713: PPUSH
5714: LD_STRING D13-Sci1-2
5716: PPUSH
5717: CALL_OW 88
// DialogueOff ;
5721: CALL_OW 7
// end ;
5725: PPOPN 1
5727: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5728: LD_INT 1
5730: PPUSH
5731: CALL 815 0 1
5735: PUSH
5736: LD_INT 77
5738: GREATER
5739: PUSH
5740: LD_EXP 8
5744: NOT
5745: AND
5746: PUSH
5747: LD_INT 22
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 25
5759: PUSH
5760: LD_INT 4
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 26
5769: PUSH
5770: LD_INT 1
5772: PUSH
5773: EMPTY
5774: LIST
5775: LIST
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: PPUSH
5782: CALL_OW 69
5786: PUSH
5787: LD_EXP 18
5791: PUSH
5792: LD_EXP 20
5796: PUSH
5797: LD_EXP 21
5801: PUSH
5802: LD_EXP 19
5806: PUSH
5807: LD_EXP 22
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: LIST
5818: DIFF
5819: AND
5820: IFFALSE 5998
5822: GO 5824
5824: DISABLE
5825: LD_INT 0
5827: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5828: LD_ADDR_VAR 0 1
5832: PUSH
5833: LD_INT 22
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: LD_INT 25
5845: PUSH
5846: LD_INT 4
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: PUSH
5853: LD_INT 26
5855: PUSH
5856: LD_INT 1
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: PPUSH
5868: CALL_OW 69
5872: PUSH
5873: LD_EXP 18
5877: PUSH
5878: LD_EXP 20
5882: PUSH
5883: LD_EXP 21
5887: PUSH
5888: LD_EXP 19
5892: PUSH
5893: LD_EXP 22
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: DIFF
5905: ST_TO_ADDR
// DialogueOn ;
5906: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5910: LD_VAR 0 1
5914: PUSH
5915: LD_INT 1
5917: ARRAY
5918: PPUSH
5919: LD_STRING D7-Sci1-1
5921: PPUSH
5922: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5926: LD_EXP 18
5930: PPUSH
5931: LD_STRING D7-JMM-1
5933: PPUSH
5934: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5938: LD_VAR 0 1
5942: PUSH
5943: LD_INT 1
5945: ARRAY
5946: PPUSH
5947: LD_STRING D7-Sci1-2
5949: PPUSH
5950: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5954: LD_EXP 18
5958: PPUSH
5959: LD_STRING D7-JMM-2
5961: PPUSH
5962: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5966: LD_VAR 0 1
5970: PUSH
5971: LD_INT 1
5973: ARRAY
5974: PPUSH
5975: LD_STRING D7-Sci1-3
5977: PPUSH
5978: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5982: LD_EXP 18
5986: PPUSH
5987: LD_STRING D7-JMM-3
5989: PPUSH
5990: CALL_OW 88
// DialogueOff ;
5994: CALL_OW 7
// end ;
5998: PPOPN 1
6000: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
6001: LD_EXP 10
6005: IFFALSE 9318
6007: GO 6009
6009: DISABLE
6010: LD_INT 0
6012: PPUSH
6013: PPUSH
6014: PPUSH
6015: PPUSH
6016: PPUSH
6017: PPUSH
6018: PPUSH
6019: PPUSH
// begin PrepareArabian ;
6020: CALL 11739 0 0
// repeat wait ( 0 0$01 ) ;
6024: LD_INT 35
6026: PPUSH
6027: CALL_OW 67
// until ar_spawned ;
6031: LD_EXP 11
6035: IFFALSE 6024
// DialogueOn ;
6037: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6041: LD_EXP 26
6045: PPUSH
6046: LD_STRING D8-Ar1-1
6048: PPUSH
6049: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6053: LD_EXP 18
6057: PPUSH
6058: LD_STRING D8-JMM-1
6060: PPUSH
6061: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6065: LD_EXP 26
6069: PPUSH
6070: LD_STRING D8-Ar1-2
6072: PPUSH
6073: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6077: LD_EXP 18
6081: PPUSH
6082: LD_STRING D8-JMM-2
6084: PPUSH
6085: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6089: LD_EXP 26
6093: PPUSH
6094: LD_STRING D8-Ar1-3
6096: PPUSH
6097: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6101: LD_EXP 18
6105: PPUSH
6106: LD_STRING D8-JMM-3
6108: PPUSH
6109: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6113: LD_EXP 26
6117: PPUSH
6118: LD_STRING D8-Ar1-4
6120: PPUSH
6121: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6125: LD_EXP 18
6129: PPUSH
6130: LD_STRING D8-JMM-4
6132: PPUSH
6133: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6137: LD_EXP 26
6141: PPUSH
6142: LD_STRING D8-Ar1-5
6144: PPUSH
6145: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6149: LD_EXP 18
6153: PPUSH
6154: LD_STRING D8-JMM-5
6156: PPUSH
6157: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6161: LD_EXP 26
6165: PPUSH
6166: LD_STRING D8-Ar1-6
6168: PPUSH
6169: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6173: LD_EXP 27
6177: PPUSH
6178: LD_STRING D8-Ar2-6
6180: PPUSH
6181: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6185: LD_EXP 18
6189: PPUSH
6190: LD_STRING D8-JMM-6
6192: PPUSH
6193: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6197: LD_EXP 27
6201: PPUSH
6202: LD_STRING D8-Ar2-7
6204: PPUSH
6205: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6209: LD_STRING QBarracks
6211: PPUSH
6212: CALL_OW 97
6216: PUSH
6217: LD_INT 1
6219: DOUBLE
6220: EQUAL
6221: IFTRUE 6225
6223: GO 6260
6225: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6226: LD_EXP 18
6230: PPUSH
6231: LD_STRING D8a-JMM-1
6233: PPUSH
6234: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6238: LD_EXP 26
6242: PPUSH
6243: LD_STRING D8a-Ar1-1
6245: PPUSH
6246: CALL_OW 94
// player_want_mortar := true ;
6250: LD_ADDR_EXP 12
6254: PUSH
6255: LD_INT 1
6257: ST_TO_ADDR
// end ; 2 :
6258: GO 6418
6260: LD_INT 2
6262: DOUBLE
6263: EQUAL
6264: IFTRUE 6268
6266: GO 6382
6268: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6269: LD_EXP 18
6273: PPUSH
6274: LD_STRING D8b-JMM-1
6276: PPUSH
6277: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6281: LD_EXP 26
6285: PPUSH
6286: LD_STRING D8b-Ar1-1
6288: PPUSH
6289: CALL_OW 94
// case Query ( QInfo ) of 1 :
6293: LD_STRING QInfo
6295: PPUSH
6296: CALL_OW 97
6300: PUSH
6301: LD_INT 1
6303: DOUBLE
6304: EQUAL
6305: IFTRUE 6309
6307: GO 6344
6309: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6310: LD_EXP 18
6314: PPUSH
6315: LD_STRING D8b1-JMM-1
6317: PPUSH
6318: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6322: LD_EXP 26
6326: PPUSH
6327: LD_STRING D8b1-Ar1-1
6329: PPUSH
6330: CALL_OW 94
// player_want_info := 2 ;
6334: LD_ADDR_EXP 13
6338: PUSH
6339: LD_INT 2
6341: ST_TO_ADDR
// end ; 2 :
6342: GO 6380
6344: LD_INT 2
6346: DOUBLE
6347: EQUAL
6348: IFTRUE 6352
6350: GO 6379
6352: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6353: LD_EXP 18
6357: PPUSH
6358: LD_STRING D8b2-JMM-1
6360: PPUSH
6361: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6365: LD_EXP 26
6369: PPUSH
6370: LD_STRING D8b2-Ar1-1
6372: PPUSH
6373: CALL_OW 94
// end ; end ;
6377: GO 6380
6379: POP
// end ; 3 :
6380: GO 6418
6382: LD_INT 3
6384: DOUBLE
6385: EQUAL
6386: IFTRUE 6390
6388: GO 6417
6390: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6391: LD_EXP 18
6395: PPUSH
6396: LD_STRING D8c-JMM-1
6398: PPUSH
6399: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6403: LD_EXP 26
6407: PPUSH
6408: LD_STRING D8c-Ar1-1
6410: PPUSH
6411: CALL_OW 94
// end ; end ;
6415: GO 6418
6417: POP
// DialogueOff ;
6418: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: LD_INT 9
6429: PPUSH
6430: LD_INT 2
6432: PUSH
6433: LD_INT 30
6435: PUSH
6436: LD_INT 0
6438: PUSH
6439: EMPTY
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 30
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: LIST
6457: PPUSH
6458: CALL_OW 70
6462: ST_TO_ADDR
// if dep then
6463: LD_VAR 0 4
6467: IFFALSE 6483
// dep := dep [ 1 ] ;
6469: LD_ADDR_VAR 0 4
6473: PUSH
6474: LD_VAR 0 4
6478: PUSH
6479: LD_INT 1
6481: ARRAY
6482: ST_TO_ADDR
// if not dep then
6483: LD_VAR 0 4
6487: NOT
6488: IFFALSE 6526
// begin case Query ( QInfoNothing ) of 1 :
6490: LD_STRING QInfoNothing
6492: PPUSH
6493: CALL_OW 97
6497: PUSH
6498: LD_INT 1
6500: DOUBLE
6501: EQUAL
6502: IFTRUE 6506
6504: GO 6509
6506: POP
// ; end ;
6507: GO 6510
6509: POP
// player_want_info := false ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 0
6517: ST_TO_ADDR
// player_want_mortar := false ;
6518: LD_ADDR_EXP 12
6522: PUSH
6523: LD_INT 0
6525: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6526: LD_ADDR_VAR 0 3
6530: PUSH
6531: LD_INT 22
6533: PUSH
6534: LD_INT 2
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: LD_INT 21
6543: PUSH
6544: LD_INT 2
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: PPUSH
6555: CALL_OW 69
6559: ST_TO_ADDR
// time := 1 1$35 ;
6560: LD_ADDR_VAR 0 5
6564: PUSH
6565: LD_INT 3325
6567: ST_TO_ADDR
// no_oil_gain := false ;
6568: LD_ADDR_VAR 0 6
6572: PUSH
6573: LD_INT 0
6575: ST_TO_ADDR
// first_warn := false ;
6576: LD_ADDR_VAR 0 7
6580: PUSH
6581: LD_INT 0
6583: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6584: LD_EXP 12
6588: PUSH
6589: LD_EXP 13
6593: OR
6594: IFFALSE 6699
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6596: LD_EXP 33
6600: PPUSH
6601: LD_INT 25
6603: PUSH
6604: LD_INT 1
6606: PUSH
6607: EMPTY
6608: LIST
6609: LIST
6610: PPUSH
6611: CALL_OW 72
6615: PPUSH
6616: LD_VAR 0 4
6620: PPUSH
6621: CALL_OW 250
6625: PPUSH
6626: LD_VAR 0 4
6630: PPUSH
6631: CALL_OW 251
6635: PPUSH
6636: LD_VAR 0 4
6640: PPUSH
6641: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6645: LD_EXP 33
6649: PPUSH
6650: LD_INT 25
6652: PUSH
6653: LD_INT 1
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: PPUSH
6660: CALL_OW 72
6664: PPUSH
6665: LD_INT 86
6667: PPUSH
6668: LD_INT 121
6670: PPUSH
6671: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6675: LD_EXP 33
6679: PPUSH
6680: LD_INT 25
6682: PUSH
6683: LD_INT 1
6685: PUSH
6686: EMPTY
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 72
6694: PPUSH
6695: CALL_OW 200
// end ; if player_attacked_ar then
6699: LD_EXP 16
6703: IFFALSE 6707
// exit ;
6705: GO 9318
// if player_want_mortar then
6707: LD_EXP 12
6711: IFFALSE 8120
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6713: LD_EXP 27
6717: PPUSH
6718: LD_VAR 0 4
6722: PPUSH
6723: CALL_OW 250
6727: PUSH
6728: LD_INT 1
6730: PLUS
6731: PPUSH
6732: LD_VAR 0 4
6736: PPUSH
6737: CALL_OW 251
6741: PUSH
6742: LD_INT 1
6744: PLUS
6745: PPUSH
6746: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6750: LD_INT 35
6752: PPUSH
6753: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6757: LD_EXP 27
6761: PPUSH
6762: LD_VAR 0 4
6766: PPUSH
6767: CALL_OW 296
6771: PUSH
6772: LD_INT 4
6774: LESS
6775: IFFALSE 6750
// for i = 1 to 6 do
6777: LD_ADDR_VAR 0 1
6781: PUSH
6782: DOUBLE
6783: LD_INT 1
6785: DEC
6786: ST_TO_ADDR
6787: LD_INT 6
6789: PUSH
6790: FOR_TO
6791: IFFALSE 6988
// begin if player_attacked_ar then
6793: LD_EXP 16
6797: IFFALSE 6803
// exit ;
6799: POP
6800: POP
6801: GO 9318
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6803: LD_VAR 0 4
6807: PPUSH
6808: CALL_OW 274
6812: PPUSH
6813: LD_INT 2
6815: PPUSH
6816: CALL_OW 275
6820: PUSH
6821: LD_INT 10
6823: LESS
6824: PUSH
6825: LD_VAR 0 7
6829: NOT
6830: AND
6831: IFFALSE 6894
// begin first_warn := true ;
6833: LD_ADDR_VAR 0 7
6837: PUSH
6838: LD_INT 1
6840: ST_TO_ADDR
// DialogueOn ;
6841: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6845: LD_EXP 28
6849: PPUSH
6850: LD_STRING D9a-FAr1-1
6852: PPUSH
6853: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6857: LD_EXP 18
6861: PPUSH
6862: LD_STRING D9a-JMM-1
6864: PPUSH
6865: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6869: LD_EXP 26
6873: PPUSH
6874: LD_STRING D9a2-Ar1-1
6876: PPUSH
6877: CALL_OW 88
// DialogueOff ;
6881: CALL_OW 7
// wait ( time ) ;
6885: LD_VAR 0 5
6889: PPUSH
6890: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6894: LD_VAR 0 4
6898: PPUSH
6899: CALL_OW 274
6903: PPUSH
6904: LD_INT 2
6906: PPUSH
6907: CALL_OW 275
6911: PUSH
6912: LD_INT 10
6914: LESS
6915: IFFALSE 6941
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6917: LD_EXP 26
6921: PPUSH
6922: LD_STRING D9a3-Ar1-1
6924: PPUSH
6925: CALL_OW 88
// no_oil_gain := true ;
6929: LD_ADDR_VAR 0 6
6933: PUSH
6934: LD_INT 1
6936: ST_TO_ADDR
// break ;
6937: GO 6988
// end else
6939: GO 6986
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6941: LD_EXP 27
6945: PPUSH
6946: LD_VAR 0 4
6950: PPUSH
6951: LD_INT 2
6953: PPUSH
6954: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6958: LD_EXP 27
6962: PPUSH
6963: LD_VAR 0 3
6967: PUSH
6968: LD_VAR 0 1
6972: PUSH
6973: LD_INT 3
6975: MOD
6976: PUSH
6977: LD_INT 1
6979: PLUS
6980: ARRAY
6981: PPUSH
6982: CALL_OW 210
// end ; end ;
6986: GO 6790
6988: POP
6989: POP
// if not no_oil_gain then
6990: LD_VAR 0 6
6994: NOT
6995: IFFALSE 8120
// begin repeat wait ( 0 0$01 ) ;
6997: LD_INT 35
6999: PPUSH
7000: CALL_OW 67
// if player_attacked_ar then
7004: LD_EXP 16
7008: IFFALSE 7012
// exit ;
7010: GO 9318
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7012: LD_VAR 0 3
7016: PUSH
7017: LD_INT 1
7019: ARRAY
7020: PPUSH
7021: CALL_OW 261
7025: PUSH
7026: LD_INT 80
7028: GREATER
7029: PUSH
7030: LD_VAR 0 3
7034: PUSH
7035: LD_INT 2
7037: ARRAY
7038: PPUSH
7039: CALL_OW 261
7043: PUSH
7044: LD_INT 80
7046: GREATER
7047: AND
7048: PUSH
7049: LD_VAR 0 3
7053: PUSH
7054: LD_INT 3
7056: ARRAY
7057: PPUSH
7058: CALL_OW 261
7062: PUSH
7063: LD_INT 80
7065: GREATER
7066: AND
7067: IFFALSE 6997
// ComMoveXY ( Gali , 105 , 127 ) ;
7069: LD_EXP 27
7073: PPUSH
7074: LD_INT 105
7076: PPUSH
7077: LD_INT 127
7079: PPUSH
7080: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7084: LD_EXP 27
7088: PPUSH
7089: LD_INT 2
7091: PPUSH
7092: CALL_OW 173
// AddComHold ( Gali ) ;
7096: LD_EXP 27
7100: PPUSH
7101: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7105: LD_INT 35
7107: PPUSH
7108: CALL_OW 67
// if player_attacked_ar then
7112: LD_EXP 16
7116: IFFALSE 7120
// exit ;
7118: GO 9318
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7120: LD_EXP 27
7124: PPUSH
7125: LD_INT 105
7127: PPUSH
7128: LD_INT 127
7130: PPUSH
7131: CALL_OW 297
7135: PUSH
7136: LD_INT 4
7138: LESS
7139: IFFALSE 7105
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7141: LD_VAR 0 4
7145: PPUSH
7146: CALL_OW 274
7150: PPUSH
7151: LD_INT 1
7153: PPUSH
7154: CALL_OW 275
7158: PUSH
7159: LD_INT 50
7161: LESS
7162: IFFALSE 7458
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7164: LD_VAR 0 4
7168: PPUSH
7169: CALL_OW 274
7173: PPUSH
7174: LD_INT 1
7176: PPUSH
7177: CALL_OW 275
7181: PUSH
7182: LD_INT 0
7184: DOUBLE
7185: GREATEREQUAL
7186: IFFALSE 7194
7188: LD_INT 24
7190: DOUBLE
7191: LESSEQUAL
7192: IFTRUE 7196
7194: GO 7211
7196: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7197: LD_EXP 27
7201: PPUSH
7202: LD_STRING D9b-Ar2-1
7204: PPUSH
7205: CALL_OW 88
7209: GO 7241
7211: LD_INT 25
7213: DOUBLE
7214: GREATEREQUAL
7215: IFFALSE 7223
7217: LD_INT 49
7219: DOUBLE
7220: LESSEQUAL
7221: IFTRUE 7225
7223: GO 7240
7225: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7226: LD_EXP 27
7230: PPUSH
7231: LD_STRING D9b-Ar2-1a
7233: PPUSH
7234: CALL_OW 88
7238: GO 7241
7240: POP
// Say ( JMM , D9b-JMM-1 ) ;
7241: LD_EXP 18
7245: PPUSH
7246: LD_STRING D9b-JMM-1
7248: PPUSH
7249: CALL_OW 88
// x := 0 0$0 ;
7253: LD_ADDR_VAR 0 2
7257: PUSH
7258: LD_INT 0
7260: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7261: LD_INT 35
7263: PPUSH
7264: CALL_OW 67
// x := x + 0 0$1 ;
7268: LD_ADDR_VAR 0 2
7272: PUSH
7273: LD_VAR 0 2
7277: PUSH
7278: LD_INT 35
7280: PLUS
7281: ST_TO_ADDR
// if player_attacked_ar then
7282: LD_EXP 16
7286: IFFALSE 7290
// exit ;
7288: GO 9318
// until x >= time ;
7290: LD_VAR 0 2
7294: PUSH
7295: LD_VAR 0 5
7299: GREATEREQUAL
7300: IFFALSE 7261
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7302: LD_VAR 0 4
7306: PPUSH
7307: CALL_OW 274
7311: PPUSH
7312: LD_INT 1
7314: PPUSH
7315: CALL_OW 275
7319: PUSH
7320: LD_INT 50
7322: LESS
7323: IFFALSE 7456
// begin DialogueOn ;
7325: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7329: LD_EXP 26
7333: PPUSH
7334: LD_STRING D9c-Ar1-1
7336: PPUSH
7337: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7341: LD_EXP 18
7345: PPUSH
7346: LD_STRING D9c-JMM-1
7348: PPUSH
7349: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7353: LD_EXP 26
7357: PPUSH
7358: LD_STRING D9c-Ar1-2
7360: PPUSH
7361: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7365: LD_EXP 28
7369: PPUSH
7370: LD_STRING D9c-FAr1-2
7372: PPUSH
7373: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7377: LD_EXP 26
7381: PPUSH
7382: LD_STRING D9c-Ar1-3
7384: PPUSH
7385: CALL_OW 88
// case Query ( QInfo ) of 1 :
7389: LD_STRING QInfo
7391: PPUSH
7392: CALL_OW 97
7396: PUSH
7397: LD_INT 1
7399: DOUBLE
7400: EQUAL
7401: IFTRUE 7405
7403: GO 7428
7405: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7406: LD_EXP 18
7410: PPUSH
7411: LD_STRING D8b1-JMM-1
7413: PPUSH
7414: CALL_OW 88
// player_want_info := 2 ;
7418: LD_ADDR_EXP 13
7422: PUSH
7423: LD_INT 2
7425: ST_TO_ADDR
// end ; 2 :
7426: GO 7452
7428: LD_INT 2
7430: DOUBLE
7431: EQUAL
7432: IFTRUE 7436
7434: GO 7451
7436: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7437: LD_EXP 26
7441: PPUSH
7442: LD_STRING D8b2-Ar1-1
7444: PPUSH
7445: CALL_OW 88
// end ; end ;
7449: GO 7452
7451: POP
// DialogueOff ;
7452: CALL_OW 7
// end ; end else
7456: GO 8120
// begin RemoveEnvironmentArea ( mortarArea ) ;
7458: LD_INT 2
7460: PPUSH
7461: CALL_OW 355
// wait ( 1 ) ;
7465: LD_INT 1
7467: PPUSH
7468: CALL_OW 67
// InGameOn ;
7472: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7476: LD_EXP 27
7480: PPUSH
7481: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7485: LD_EXP 27
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7497: LD_EXP 27
7501: PPUSH
7502: LD_INT 4
7504: PPUSH
7505: LD_INT 107
7507: PPUSH
7508: LD_INT 131
7510: PPUSH
7511: LD_INT 0
7513: PPUSH
7514: CALL_OW 145
// repeat wait ( 1 ) ;
7518: LD_INT 1
7520: PPUSH
7521: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7525: LD_INT 30
7527: PUSH
7528: LD_INT 4
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 23
7537: PUSH
7538: LD_INT 2
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PPUSH
7549: CALL_OW 69
7553: IFFALSE 7518
// SetSide ( Gali , 2 ) ;
7555: LD_EXP 27
7559: PPUSH
7560: LD_INT 2
7562: PPUSH
7563: CALL_OW 235
// InGameOff ;
7567: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7571: LD_ADDR_VAR 0 8
7575: PUSH
7576: LD_INT 30
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: LD_INT 23
7588: PUSH
7589: LD_INT 2
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PPUSH
7600: CALL_OW 69
7604: PUSH
7605: LD_INT 1
7607: ARRAY
7608: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 9318
// until BuildingStatus ( b ) <> bs_build ;
7624: LD_VAR 0 8
7628: PPUSH
7629: CALL_OW 461
7633: PUSH
7634: LD_INT 1
7636: NONEQUAL
7637: IFFALSE 7609
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7639: LD_VAR 0 8
7643: PPUSH
7644: CALL_OW 302
7648: PUSH
7649: LD_VAR 0 4
7653: PPUSH
7654: CALL_OW 274
7658: PPUSH
7659: LD_INT 1
7661: PPUSH
7662: CALL_OW 275
7666: PUSH
7667: LD_INT 25
7669: GREATEREQUAL
7670: AND
7671: IFFALSE 7770
// begin ComUpgrade ( b ) ;
7673: LD_VAR 0 8
7677: PPUSH
7678: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7682: LD_EXP 27
7686: PPUSH
7687: LD_STRING h
7689: PUSH
7690: LD_VAR 0 8
7694: PPUSH
7695: CALL_OW 250
7699: PUSH
7700: LD_VAR 0 8
7704: PPUSH
7705: CALL_OW 251
7709: PUSH
7710: LD_VAR 0 8
7714: PUSH
7715: LD_INT 0
7717: PUSH
7718: LD_INT 0
7720: PUSH
7721: LD_INT 0
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: PUSH
7733: EMPTY
7734: LIST
7735: PPUSH
7736: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7740: LD_INT 35
7742: PPUSH
7743: CALL_OW 67
// if player_attacked_ar then
7747: LD_EXP 16
7751: IFFALSE 7755
// exit ;
7753: GO 9318
// until BuildingStatus ( b ) <> bs_build ;
7755: LD_VAR 0 8
7759: PPUSH
7760: CALL_OW 461
7764: PUSH
7765: LD_INT 1
7767: NONEQUAL
7768: IFFALSE 7740
// end ; if b then
7770: LD_VAR 0 8
7774: IFFALSE 7785
// CenterNowOnUnits ( b ) ;
7776: LD_VAR 0 8
7780: PPUSH
7781: CALL_OW 87
// DialogueOn ;
7785: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7789: LD_EXP 27
7793: PPUSH
7794: LD_STRING D9d-Ar2-1
7796: PPUSH
7797: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7801: LD_EXP 26
7805: PPUSH
7806: LD_STRING D9d-Ar1-1
7808: PPUSH
7809: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7813: LD_EXP 18
7817: PPUSH
7818: LD_STRING D9d-JMM-1
7820: PPUSH
7821: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7825: LD_EXP 26
7829: PPUSH
7830: LD_STRING D9d-Ar1-2
7832: PPUSH
7833: CALL_OW 88
// DialogueOff ;
7837: CALL_OW 7
// i := [ ] ;
7841: LD_ADDR_VAR 0 1
7845: PUSH
7846: EMPTY
7847: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7848: LD_VAR 0 4
7852: PPUSH
7853: CALL_OW 274
7857: PPUSH
7858: LD_INT 3
7860: PPUSH
7861: CALL_OW 275
7865: PUSH
7866: LD_INT 20
7868: GREATEREQUAL
7869: IFFALSE 7888
// i := i ^ [ 1 ] ;
7871: LD_ADDR_VAR 0 1
7875: PUSH
7876: LD_VAR 0 1
7880: PUSH
7881: LD_INT 1
7883: PUSH
7884: EMPTY
7885: LIST
7886: ADD
7887: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7888: LD_VAR 0 4
7892: PPUSH
7893: CALL_OW 274
7897: PPUSH
7898: LD_INT 1
7900: PPUSH
7901: CALL_OW 275
7905: PUSH
7906: LD_INT 50
7908: GREATEREQUAL
7909: IFFALSE 7928
// i := i ^ [ 2 ] ;
7911: LD_ADDR_VAR 0 1
7915: PUSH
7916: LD_VAR 0 1
7920: PUSH
7921: LD_INT 2
7923: PUSH
7924: EMPTY
7925: LIST
7926: ADD
7927: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7928: LD_VAR 0 4
7932: PPUSH
7933: CALL_OW 274
7937: PPUSH
7938: LD_INT 2
7940: PPUSH
7941: CALL_OW 275
7945: PUSH
7946: LD_INT 80
7948: GREATEREQUAL
7949: IFFALSE 7968
// i := i ^ [ 3 ] ;
7951: LD_ADDR_VAR 0 1
7955: PUSH
7956: LD_VAR 0 1
7960: PUSH
7961: LD_INT 3
7963: PUSH
7964: EMPTY
7965: LIST
7966: ADD
7967: ST_TO_ADDR
// i := i diff 0 ;
7968: LD_ADDR_VAR 0 1
7972: PUSH
7973: LD_VAR 0 1
7977: PUSH
7978: LD_INT 0
7980: DIFF
7981: ST_TO_ADDR
// if i then
7982: LD_VAR 0 1
7986: IFFALSE 8092
// begin i := i ^ [ 4 ] ;
7988: LD_ADDR_VAR 0 1
7992: PUSH
7993: LD_VAR 0 1
7997: PUSH
7998: LD_INT 4
8000: PUSH
8001: EMPTY
8002: LIST
8003: ADD
8004: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8005: LD_STRING QInfo2
8007: PPUSH
8008: CALL_OW 97
8012: PUSH
8013: LD_INT 1
8015: DOUBLE
8016: EQUAL
8017: IFTRUE 8021
8019: GO 8032
8021: POP
// player_want_info := 3 ; 2 :
8022: LD_ADDR_EXP 13
8026: PUSH
8027: LD_INT 3
8029: ST_TO_ADDR
8030: GO 8090
8032: LD_INT 2
8034: DOUBLE
8035: EQUAL
8036: IFTRUE 8040
8038: GO 8051
8040: POP
// player_want_info := 1 ; 3 :
8041: LD_ADDR_EXP 13
8045: PUSH
8046: LD_INT 1
8048: ST_TO_ADDR
8049: GO 8090
8051: LD_INT 3
8053: DOUBLE
8054: EQUAL
8055: IFTRUE 8059
8057: GO 8070
8059: POP
// player_want_info := 2 ; 4 :
8060: LD_ADDR_EXP 13
8064: PUSH
8065: LD_INT 2
8067: ST_TO_ADDR
8068: GO 8090
8070: LD_INT 4
8072: DOUBLE
8073: EQUAL
8074: IFTRUE 8078
8076: GO 8089
8078: POP
// player_want_info := 0 ; end ;
8079: LD_ADDR_EXP 13
8083: PUSH
8084: LD_INT 0
8086: ST_TO_ADDR
8087: GO 8090
8089: POP
// end else
8090: GO 8120
// case Query ( QInfoNothing ) of 1 :
8092: LD_STRING QInfoNothing
8094: PPUSH
8095: CALL_OW 97
8099: PUSH
8100: LD_INT 1
8102: DOUBLE
8103: EQUAL
8104: IFTRUE 8108
8106: GO 8119
8108: POP
// player_want_info := 0 ; end ;
8109: LD_ADDR_EXP 13
8113: PUSH
8114: LD_INT 0
8116: ST_TO_ADDR
8117: GO 8120
8119: POP
// end ; end ; end ; if player_want_info then
8120: LD_EXP 13
8124: IFFALSE 9138
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8126: LD_ADDR_VAR 0 3
8130: PUSH
8131: LD_VAR 0 3
8135: PPUSH
8136: LD_INT 34
8138: PUSH
8139: LD_INT 32
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: PPUSH
8146: CALL_OW 72
8150: ST_TO_ADDR
// if player_want_mortar then
8151: LD_EXP 12
8155: IFFALSE 8477
// begin case player_want_info of 1 :
8157: LD_EXP 13
8161: PUSH
8162: LD_INT 1
8164: DOUBLE
8165: EQUAL
8166: IFTRUE 8170
8168: GO 8181
8170: POP
// x := 5 ; 2 :
8171: LD_ADDR_VAR 0 2
8175: PUSH
8176: LD_INT 5
8178: ST_TO_ADDR
8179: GO 8220
8181: LD_INT 2
8183: DOUBLE
8184: EQUAL
8185: IFTRUE 8189
8187: GO 8200
8189: POP
// x := 8 ; 3 :
8190: LD_ADDR_VAR 0 2
8194: PUSH
8195: LD_INT 8
8197: ST_TO_ADDR
8198: GO 8220
8200: LD_INT 3
8202: DOUBLE
8203: EQUAL
8204: IFTRUE 8208
8206: GO 8219
8208: POP
// x := 2 ; end ;
8209: LD_ADDR_VAR 0 2
8213: PUSH
8214: LD_INT 2
8216: ST_TO_ADDR
8217: GO 8220
8219: POP
// repeat wait ( 0 0$1 ) ;
8220: LD_INT 35
8222: PPUSH
8223: CALL_OW 67
// until not HasTask ( Gali ) ;
8227: LD_EXP 27
8231: PPUSH
8232: CALL_OW 314
8236: NOT
8237: IFFALSE 8220
// for i = 1 to x do
8239: LD_ADDR_VAR 0 1
8243: PUSH
8244: DOUBLE
8245: LD_INT 1
8247: DEC
8248: ST_TO_ADDR
8249: LD_VAR 0 2
8253: PUSH
8254: FOR_TO
8255: IFFALSE 8420
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8257: LD_EXP 27
8261: PPUSH
8262: LD_VAR 0 4
8266: PPUSH
8267: LD_EXP 13
8271: PPUSH
8272: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8276: LD_EXP 27
8280: PPUSH
8281: LD_VAR 0 3
8285: PUSH
8286: LD_INT 1
8288: ARRAY
8289: PPUSH
8290: CALL_OW 172
// AddComHold ( Gali ) ;
8294: LD_EXP 27
8298: PPUSH
8299: CALL_OW 200
// repeat wait ( 3 ) ;
8303: LD_INT 3
8305: PPUSH
8306: CALL_OW 67
// if player_attacked_ar then
8310: LD_EXP 16
8314: IFFALSE 8320
// exit ;
8316: POP
8317: POP
8318: GO 9318
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8320: LD_EXP 27
8324: PPUSH
8325: LD_VAR 0 3
8329: PUSH
8330: LD_INT 1
8332: ARRAY
8333: PPUSH
8334: CALL_OW 296
8338: PUSH
8339: LD_INT 4
8341: LESS
8342: PUSH
8343: LD_EXP 27
8347: PPUSH
8348: LD_EXP 13
8352: PPUSH
8353: CALL_OW 289
8357: AND
8358: IFFALSE 8303
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8360: LD_VAR 0 3
8364: PUSH
8365: LD_INT 1
8367: ARRAY
8368: PPUSH
8369: LD_EXP 13
8373: PPUSH
8374: LD_VAR 0 3
8378: PUSH
8379: LD_INT 1
8381: ARRAY
8382: PPUSH
8383: LD_EXP 13
8387: PPUSH
8388: CALL_OW 289
8392: PUSH
8393: LD_INT 10
8395: PLUS
8396: PPUSH
8397: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8401: LD_EXP 27
8405: PPUSH
8406: LD_EXP 13
8410: PPUSH
8411: LD_INT 0
8413: PPUSH
8414: CALL_OW 290
// end ;
8418: GO 8254
8420: POP
8421: POP
// repeat wait ( 0 0$1 ) ;
8422: LD_INT 35
8424: PPUSH
8425: CALL_OW 67
// if player_attacked_ar then
8429: LD_EXP 16
8433: IFFALSE 8437
// exit ;
8435: GO 9318
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8437: LD_VAR 0 3
8441: PUSH
8442: LD_INT 1
8444: ARRAY
8445: PPUSH
8446: LD_EXP 13
8450: PPUSH
8451: CALL_OW 289
8455: PUSH
8456: LD_VAR 0 2
8460: PUSH
8461: LD_INT 10
8463: MUL
8464: EQUAL
8465: IFFALSE 8422
// no_oil_gain := false ;
8467: LD_ADDR_VAR 0 6
8471: PUSH
8472: LD_INT 0
8474: ST_TO_ADDR
// end else
8475: GO 8959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8477: LD_ADDR_VAR 0 3
8481: PUSH
8482: LD_INT 22
8484: PUSH
8485: LD_INT 2
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: PUSH
8492: LD_INT 21
8494: PUSH
8495: LD_INT 2
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PUSH
8502: EMPTY
8503: LIST
8504: LIST
8505: PPUSH
8506: CALL_OW 69
8510: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8511: LD_EXP 27
8515: PPUSH
8516: LD_VAR 0 4
8520: PPUSH
8521: CALL_OW 250
8525: PUSH
8526: LD_INT 1
8528: PLUS
8529: PPUSH
8530: LD_VAR 0 4
8534: PPUSH
8535: CALL_OW 251
8539: PUSH
8540: LD_INT 1
8542: PLUS
8543: PPUSH
8544: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8548: LD_INT 35
8550: PPUSH
8551: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8555: LD_EXP 27
8559: PPUSH
8560: LD_VAR 0 4
8564: PPUSH
8565: CALL_OW 296
8569: PUSH
8570: LD_INT 4
8572: LESS
8573: IFFALSE 8548
// for i = 1 to 6 do
8575: LD_ADDR_VAR 0 1
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_INT 6
8587: PUSH
8588: FOR_TO
8589: IFFALSE 8786
// begin if player_attacked_ar then
8591: LD_EXP 16
8595: IFFALSE 8601
// exit ;
8597: POP
8598: POP
8599: GO 9318
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8601: LD_VAR 0 4
8605: PPUSH
8606: CALL_OW 274
8610: PPUSH
8611: LD_INT 2
8613: PPUSH
8614: CALL_OW 275
8618: PUSH
8619: LD_INT 10
8621: LESS
8622: PUSH
8623: LD_VAR 0 7
8627: NOT
8628: AND
8629: IFFALSE 8692
// begin first_warn := true ;
8631: LD_ADDR_VAR 0 7
8635: PUSH
8636: LD_INT 1
8638: ST_TO_ADDR
// DialogueOn ;
8639: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8643: LD_EXP 28
8647: PPUSH
8648: LD_STRING D9a-FAr1-1
8650: PPUSH
8651: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8655: LD_EXP 18
8659: PPUSH
8660: LD_STRING D9a-JMM-1
8662: PPUSH
8663: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8667: LD_EXP 26
8671: PPUSH
8672: LD_STRING D9a2-Ar1-1
8674: PPUSH
8675: CALL_OW 88
// DialogueOff ;
8679: CALL_OW 7
// wait ( time ) ;
8683: LD_VAR 0 5
8687: PPUSH
8688: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8692: LD_VAR 0 4
8696: PPUSH
8697: CALL_OW 274
8701: PPUSH
8702: LD_INT 2
8704: PPUSH
8705: CALL_OW 275
8709: PUSH
8710: LD_INT 10
8712: LESS
8713: IFFALSE 8739
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8715: LD_EXP 26
8719: PPUSH
8720: LD_STRING D9a3-Ar1-1
8722: PPUSH
8723: CALL_OW 88
// no_oil_gain := true ;
8727: LD_ADDR_VAR 0 6
8731: PUSH
8732: LD_INT 1
8734: ST_TO_ADDR
// break ;
8735: GO 8786
// end else
8737: GO 8784
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8739: LD_EXP 27
8743: PPUSH
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8756: LD_EXP 27
8760: PPUSH
8761: LD_VAR 0 3
8765: PUSH
8766: LD_VAR 0 1
8770: PUSH
8771: LD_INT 3
8773: MOD
8774: PUSH
8775: LD_INT 1
8777: PLUS
8778: ARRAY
8779: PPUSH
8780: CALL_OW 210
// end ; end ;
8784: GO 8588
8786: POP
8787: POP
// repeat wait ( 0 0$1 ) ;
8788: LD_INT 35
8790: PPUSH
8791: CALL_OW 67
// if player_attacked_ar then
8795: LD_EXP 16
8799: IFFALSE 8803
// exit ;
8801: GO 9318
// for i in tmp do
8803: LD_ADDR_VAR 0 1
8807: PUSH
8808: LD_VAR 0 3
8812: PUSH
8813: FOR_IN
8814: IFFALSE 8845
// if GetFuel ( i ) < 100 then
8816: LD_VAR 0 1
8820: PPUSH
8821: CALL_OW 261
8825: PUSH
8826: LD_INT 100
8828: LESS
8829: IFFALSE 8843
// begin x := i ;
8831: LD_ADDR_VAR 0 2
8835: PUSH
8836: LD_VAR 0 1
8840: ST_TO_ADDR
// break ;
8841: GO 8845
// end ;
8843: GO 8813
8845: POP
8846: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8847: LD_EXP 27
8851: PPUSH
8852: CALL_OW 314
8856: NOT
8857: PUSH
8858: LD_EXP 27
8862: PPUSH
8863: CALL_OW 281
8867: NOT
8868: AND
8869: IFFALSE 8902
// begin ComTransport ( Gali , dep , mat_oil ) ;
8871: LD_EXP 27
8875: PPUSH
8876: LD_VAR 0 4
8880: PPUSH
8881: LD_INT 2
8883: PPUSH
8884: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8888: LD_EXP 27
8892: PPUSH
8893: LD_VAR 0 2
8897: PPUSH
8898: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8902: LD_VAR 0 3
8906: PUSH
8907: LD_INT 1
8909: ARRAY
8910: PPUSH
8911: CALL_OW 261
8915: PUSH
8916: LD_INT 80
8918: GREATER
8919: PUSH
8920: LD_VAR 0 3
8924: PUSH
8925: LD_INT 2
8927: ARRAY
8928: PPUSH
8929: CALL_OW 261
8933: PUSH
8934: LD_INT 80
8936: GREATER
8937: AND
8938: PUSH
8939: LD_VAR 0 3
8943: PUSH
8944: LD_INT 3
8946: ARRAY
8947: PPUSH
8948: CALL_OW 261
8952: PUSH
8953: LD_INT 80
8955: GREATER
8956: AND
8957: IFFALSE 8788
// end ; ComHold ( Gali ) ;
8959: LD_EXP 27
8963: PPUSH
8964: CALL_OW 140
// if not no_oil_gain then
8968: LD_VAR 0 6
8972: NOT
8973: IFFALSE 9138
// begin DialogueOn ;
8975: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8979: LD_EXP 26
8983: PPUSH
8984: CALL_OW 87
// if player_want_mortar then
8988: LD_EXP 12
8992: IFFALSE 9018
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8994: LD_EXP 26
8998: PPUSH
8999: LD_STRING D9e-Ar1-1
9001: PPUSH
9002: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9006: LD_EXP 18
9010: PPUSH
9011: LD_STRING D10a-JMM-1
9013: PPUSH
9014: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9018: LD_EXP 26
9022: PPUSH
9023: LD_STRING D10a-Ar1-1
9025: PPUSH
9026: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9030: LD_EXP 27
9034: PPUSH
9035: LD_STRING D10a-Ar2-1
9037: PPUSH
9038: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9042: LD_EXP 28
9046: PPUSH
9047: LD_STRING D10a-FAr1-1
9049: PPUSH
9050: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9054: LD_EXP 27
9058: PPUSH
9059: LD_STRING D10a-Ar2-2
9061: PPUSH
9062: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9066: LD_EXP 28
9070: PPUSH
9071: LD_STRING D10a-FAr1-2
9073: PPUSH
9074: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9078: LD_EXP 26
9082: PPUSH
9083: LD_STRING D10a-Ar1-2
9085: PPUSH
9086: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9090: LD_EXP 18
9094: PPUSH
9095: LD_STRING D10a-JMM-2
9097: PPUSH
9098: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9102: LD_EXP 26
9106: PPUSH
9107: LD_STRING D10a-Ar1-3
9109: PPUSH
9110: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9114: LD_EXP 18
9118: PPUSH
9119: LD_STRING D10a-JMM-3
9121: PPUSH
9122: CALL_OW 88
// player_get_info := true ;
9126: LD_ADDR_EXP 15
9130: PUSH
9131: LD_INT 1
9133: ST_TO_ADDR
// DialogueOff ;
9134: CALL_OW 7
// end ; end ; if player_attacked_ar then
9138: LD_EXP 16
9142: IFFALSE 9146
// exit ;
9144: GO 9318
// if player_want_mortar or player_want_info then
9146: LD_EXP 12
9150: PUSH
9151: LD_EXP 13
9155: OR
9156: IFFALSE 9170
// Say ( Vervecken , D9f-Ar1-1 ) ;
9158: LD_EXP 26
9162: PPUSH
9163: LD_STRING D9f-Ar1-1
9165: PPUSH
9166: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9170: LD_INT 22
9172: PUSH
9173: LD_INT 2
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PPUSH
9180: CALL_OW 69
9184: PPUSH
9185: LD_INT 51
9187: PPUSH
9188: LD_INT 99
9190: PPUSH
9191: CALL_OW 111
// wait ( 0 0$1 ) ;
9195: LD_INT 35
9197: PPUSH
9198: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9202: LD_INT 22
9204: PUSH
9205: LD_INT 2
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PUSH
9212: LD_INT 92
9214: PUSH
9215: LD_INT 51
9217: PUSH
9218: LD_INT 99
9220: PUSH
9221: LD_INT 2
9223: PUSH
9224: EMPTY
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: PPUSH
9234: CALL_OW 69
9238: IFFALSE 9298
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9240: LD_ADDR_VAR 0 1
9244: PUSH
9245: LD_INT 22
9247: PUSH
9248: LD_INT 2
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: PUSH
9255: LD_INT 92
9257: PUSH
9258: LD_INT 51
9260: PUSH
9261: LD_INT 99
9263: PUSH
9264: LD_INT 2
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: EMPTY
9274: LIST
9275: LIST
9276: PPUSH
9277: CALL_OW 69
9281: PUSH
9282: FOR_IN
9283: IFFALSE 9296
// RemoveUnit ( i ) ;
9285: LD_VAR 0 1
9289: PPUSH
9290: CALL_OW 64
9294: GO 9282
9296: POP
9297: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9298: LD_INT 22
9300: PUSH
9301: LD_INT 2
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PPUSH
9308: CALL_OW 69
9312: PUSH
9313: LD_INT 0
9315: EQUAL
9316: IFFALSE 9170
// end ;
9318: PPOPN 8
9320: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9321: LD_EXP 16
9325: IFFALSE 9678
9327: GO 9329
9329: DISABLE
9330: LD_INT 0
9332: PPUSH
9333: PPUSH
9334: PPUSH
9335: PPUSH
// begin ru_can_attack := true ;
9336: LD_ADDR_EXP 8
9340: PUSH
9341: LD_INT 1
9343: ST_TO_ADDR
// mine_launched := false ;
9344: LD_ADDR_VAR 0 3
9348: PUSH
9349: LD_INT 0
9351: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9352: LD_INT 22
9354: PUSH
9355: LD_INT 2
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PPUSH
9362: CALL_OW 69
9366: PPUSH
9367: LD_INT 51
9369: PPUSH
9370: LD_INT 99
9372: PPUSH
9373: CALL_OW 111
// if IsOk ( Vervecken ) then
9377: LD_EXP 26
9381: PPUSH
9382: CALL_OW 302
9386: IFFALSE 9400
// Say ( Vervecken , D11a-Ar1-1 ) ;
9388: LD_EXP 26
9392: PPUSH
9393: LD_STRING D11a-Ar1-1
9395: PPUSH
9396: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9400: LD_ADDR_VAR 0 2
9404: PUSH
9405: LD_EXP 33
9409: PPUSH
9410: LD_INT 25
9412: PUSH
9413: LD_INT 1
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 72
9424: ST_TO_ADDR
// for i in tmp do
9425: LD_ADDR_VAR 0 1
9429: PUSH
9430: LD_VAR 0 2
9434: PUSH
9435: FOR_IN
9436: IFFALSE 9499
// if MineOfUnit ( i ) then
9438: LD_VAR 0 1
9442: PPUSH
9443: CALL_OW 459
9447: IFFALSE 9497
// begin x := MineOfUnit ( i ) ;
9449: LD_ADDR_VAR 0 4
9453: PUSH
9454: LD_VAR 0 1
9458: PPUSH
9459: CALL_OW 459
9463: ST_TO_ADDR
// mine_launched := true ;
9464: LD_ADDR_VAR 0 3
9468: PUSH
9469: LD_INT 1
9471: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9472: LD_VAR 0 4
9476: PUSH
9477: LD_INT 1
9479: ARRAY
9480: PPUSH
9481: LD_VAR 0 4
9485: PUSH
9486: LD_INT 2
9488: ARRAY
9489: PPUSH
9490: LD_INT 2
9492: PPUSH
9493: CALL_OW 456
// end ;
9497: GO 9435
9499: POP
9500: POP
// if mine_launched and IsOk ( Vervecken ) then
9501: LD_VAR 0 3
9505: PUSH
9506: LD_EXP 26
9510: PPUSH
9511: CALL_OW 302
9515: AND
9516: IFFALSE 9530
// Say ( Vervecken , D11b-Ar1-1 ) ;
9518: LD_EXP 26
9522: PPUSH
9523: LD_STRING D11b-Ar1-1
9525: PPUSH
9526: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9530: LD_INT 22
9532: PUSH
9533: LD_INT 2
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 69
9544: PPUSH
9545: LD_INT 51
9547: PPUSH
9548: LD_INT 99
9550: PPUSH
9551: CALL_OW 111
// wait ( 0 0$1 ) ;
9555: LD_INT 35
9557: PPUSH
9558: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9562: LD_INT 22
9564: PUSH
9565: LD_INT 2
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: PUSH
9572: LD_INT 92
9574: PUSH
9575: LD_INT 51
9577: PUSH
9578: LD_INT 99
9580: PUSH
9581: LD_INT 2
9583: PUSH
9584: EMPTY
9585: LIST
9586: LIST
9587: LIST
9588: LIST
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: PPUSH
9594: CALL_OW 69
9598: IFFALSE 9658
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9600: LD_ADDR_VAR 0 1
9604: PUSH
9605: LD_INT 22
9607: PUSH
9608: LD_INT 2
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: PUSH
9615: LD_INT 92
9617: PUSH
9618: LD_INT 51
9620: PUSH
9621: LD_INT 99
9623: PUSH
9624: LD_INT 2
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: LIST
9631: LIST
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: PPUSH
9637: CALL_OW 69
9641: PUSH
9642: FOR_IN
9643: IFFALSE 9656
// RemoveUnit ( i ) ;
9645: LD_VAR 0 1
9649: PPUSH
9650: CALL_OW 64
9654: GO 9642
9656: POP
9657: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9658: LD_INT 22
9660: PUSH
9661: LD_INT 2
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: PUSH
9673: LD_INT 0
9675: EQUAL
9676: IFFALSE 9530
// end ;
9678: PPOPN 4
9680: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9681: LD_EXP 10
9685: IFFALSE 9864
9687: GO 9689
9689: DISABLE
9690: LD_INT 0
9692: PPUSH
// begin Wait ( 10 10$00 ) ;
9693: LD_INT 21000
9695: PPUSH
9696: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9700: LD_INT 22
9702: PUSH
9703: LD_INT 2
9705: PUSH
9706: EMPTY
9707: LIST
9708: LIST
9709: PPUSH
9710: CALL_OW 69
9714: IFFALSE 9864
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 2
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PPUSH
9726: CALL_OW 69
9730: PPUSH
9731: LD_INT 51
9733: PPUSH
9734: LD_INT 99
9736: PPUSH
9737: CALL_OW 114
// wait ( 0 0$1 ) ;
9741: LD_INT 35
9743: PPUSH
9744: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9748: LD_INT 22
9750: PUSH
9751: LD_INT 2
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: PUSH
9758: LD_INT 92
9760: PUSH
9761: LD_INT 51
9763: PUSH
9764: LD_INT 99
9766: PUSH
9767: LD_INT 2
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PPUSH
9780: CALL_OW 69
9784: IFFALSE 9844
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9786: LD_ADDR_VAR 0 1
9790: PUSH
9791: LD_INT 22
9793: PUSH
9794: LD_INT 2
9796: PUSH
9797: EMPTY
9798: LIST
9799: LIST
9800: PUSH
9801: LD_INT 92
9803: PUSH
9804: LD_INT 51
9806: PUSH
9807: LD_INT 99
9809: PUSH
9810: LD_INT 2
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: PPUSH
9823: CALL_OW 69
9827: PUSH
9828: FOR_IN
9829: IFFALSE 9842
// RemoveUnit ( i ) ;
9831: LD_VAR 0 1
9835: PPUSH
9836: CALL_OW 64
9840: GO 9828
9842: POP
9843: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9844: LD_INT 22
9846: PUSH
9847: LD_INT 2
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PPUSH
9854: CALL_OW 69
9858: PUSH
9859: LD_INT 0
9861: EQUAL
9862: IFFALSE 9716
// end ; end ;
9864: PPOPN 1
9866: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9867: LD_EXP 4
9871: IFFALSE 10799
9873: GO 9875
9875: DISABLE
9876: LD_INT 0
9878: PPUSH
9879: PPUSH
9880: PPUSH
// begin Wait ( game_time ) ;
9881: LD_EXP 7
9885: PPUSH
9886: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9890: LD_INT 35
9892: PPUSH
9893: CALL_OW 67
// until ( not ru_can_attack ) ;
9897: LD_EXP 8
9901: NOT
9902: IFFALSE 9890
// Wait ( 0 0$35 ) ;
9904: LD_INT 1225
9906: PPUSH
9907: CALL_OW 67
// DialogueOn ;
9911: CALL_OW 6
// InGameOn ;
9915: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9919: LD_EXP 25
9923: PPUSH
9924: LD_STRING D12-Pow-1
9926: PPUSH
9927: CALL_OW 94
// InGameOff ;
9931: CALL_OW 9
// DialogueOff ;
9935: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9939: LD_STRING M4
9941: PPUSH
9942: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9946: LD_INT 5
9948: PPUSH
9949: LD_INT 1
9951: PPUSH
9952: CALL_OW 424
// can_end := true ;
9956: LD_ADDR_EXP 17
9960: PUSH
9961: LD_INT 1
9963: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9964: LD_INT 35
9966: PPUSH
9967: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9971: CALL 784 0 0
9975: PUSH
9976: LD_INT 20
9978: GREATEREQUAL
9979: PUSH
9980: LD_INT 22
9982: PUSH
9983: LD_INT 1
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 5
10011: PPUSH
10012: LD_INT 22
10014: PUSH
10015: LD_INT 1
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: PUSH
10022: LD_INT 21
10024: PUSH
10025: LD_INT 1
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 70
10040: PUSH
10041: LD_INT 22
10043: PUSH
10044: LD_INT 1
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: LD_INT 55
10053: PUSH
10054: EMPTY
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PLUS
10066: LESSEQUAL
10067: AND
10068: IFFALSE 9964
// if not player_get_info then
10070: LD_EXP 15
10074: NOT
10075: IFFALSE 10086
// player_get_info := - 1 ;
10077: LD_ADDR_EXP 15
10081: PUSH
10082: LD_INT 1
10084: NEG
10085: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10086: LD_STRING Information
10088: PPUSH
10089: LD_EXP 15
10093: PPUSH
10094: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 22
10105: PUSH
10106: LD_INT 1
10108: PUSH
10109: EMPTY
10110: LIST
10111: LIST
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: LD_INT 25
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: LD_INT 25
10128: PUSH
10129: LD_INT 16
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 34
10138: PUSH
10139: LD_INT 12
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: PUSH
10152: EMPTY
10153: LIST
10154: LIST
10155: PPUSH
10156: CALL_OW 69
10160: ST_TO_ADDR
// sib := GetTerminalCargo ;
10161: LD_ADDR_VAR 0 3
10165: PUSH
10166: CALL 784 0 0
10170: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10171: LD_ADDR_VAR 0 3
10175: PUSH
10176: LD_VAR 0 3
10180: PUSH
10181: LD_INT 6
10183: PPUSH
10184: LD_INT 3
10186: PPUSH
10187: CALL_OW 287
10191: PLUS
10192: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10193: LD_ADDR_VAR 0 3
10197: PUSH
10198: LD_VAR 0 3
10202: PUSH
10203: LD_VAR 0 2
10207: PPUSH
10208: LD_INT 3
10210: PPUSH
10211: CALL_OW 289
10215: PLUS
10216: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10217: LD_VAR 0 3
10221: PUSH
10222: LD_INT 2
10224: PUSH
10225: LD_OWVAR 67
10229: PLUS
10230: PUSH
10231: LD_INT 50
10233: MUL
10234: LESS
10235: IFFALSE 10260
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10237: LD_STRING MuchSiberite
10239: PPUSH
10240: LD_INT 2
10242: NEG
10243: PUSH
10244: LD_OWVAR 67
10248: MUL
10249: PUSH
10250: LD_INT 1
10252: PLUS
10253: PPUSH
10254: CALL_OW 101
10258: GO 10270
// AddMedal ( MuchSiberite , 1 ) ;
10260: LD_STRING MuchSiberite
10262: PPUSH
10263: LD_INT 1
10265: PPUSH
10266: CALL_OW 101
// GiveMedals ( MAIN ) ;
10270: LD_STRING MAIN
10272: PPUSH
10273: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10277: LD_INT 22
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: LD_INT 2
10289: PUSH
10290: LD_INT 25
10292: PUSH
10293: LD_INT 1
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 25
10302: PUSH
10303: LD_INT 2
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 25
10312: PUSH
10313: LD_INT 3
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: LD_INT 25
10322: PUSH
10323: LD_INT 4
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: PUSH
10330: LD_INT 25
10332: PUSH
10333: LD_INT 8
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: PPUSH
10352: CALL_OW 69
10356: PPUSH
10357: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10361: LD_ADDR_VAR 0 2
10365: PUSH
10366: LD_INT 22
10368: PUSH
10369: LD_INT 1
10371: PUSH
10372: EMPTY
10373: LIST
10374: LIST
10375: PUSH
10376: LD_INT 25
10378: PUSH
10379: LD_INT 8
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PPUSH
10390: CALL_OW 69
10394: ST_TO_ADDR
// if tmp then
10395: LD_VAR 0 2
10399: IFFALSE 10430
// for i in tmp do
10401: LD_ADDR_VAR 0 1
10405: PUSH
10406: LD_VAR 0 2
10410: PUSH
10411: FOR_IN
10412: IFFALSE 10428
// SetClass ( i , 1 ) ;
10414: LD_VAR 0 1
10418: PPUSH
10419: LD_INT 1
10421: PPUSH
10422: CALL_OW 336
10426: GO 10411
10428: POP
10429: POP
// SaveVariable ( sib , 09_sibRes ) ;
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_STRING 09_sibRes
10437: PPUSH
10438: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10442: LD_EXP 15
10446: PPUSH
10447: LD_STRING 09_arInfo
10449: PPUSH
10450: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10454: LD_EXP 18
10458: PPUSH
10459: LD_EXP 1
10463: PUSH
10464: LD_STRING JMM
10466: STR
10467: PPUSH
10468: CALL_OW 38
// if IsLive ( Gary ) then
10472: LD_EXP 19
10476: PPUSH
10477: CALL_OW 300
10481: IFFALSE 10501
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10483: LD_EXP 19
10487: PPUSH
10488: LD_EXP 1
10492: PUSH
10493: LD_STRING Gary
10495: STR
10496: PPUSH
10497: CALL_OW 38
// if IsLive ( Bobby ) then
10501: LD_EXP 20
10505: PPUSH
10506: CALL_OW 300
10510: IFFALSE 10530
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10512: LD_EXP 20
10516: PPUSH
10517: LD_EXP 1
10521: PUSH
10522: LD_STRING Bobby
10524: STR
10525: PPUSH
10526: CALL_OW 38
// if IsLive ( Cyrus ) then
10530: LD_EXP 21
10534: PPUSH
10535: CALL_OW 300
10539: IFFALSE 10559
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10541: LD_EXP 21
10545: PPUSH
10546: LD_EXP 1
10550: PUSH
10551: LD_STRING Cyrus
10553: STR
10554: PPUSH
10555: CALL_OW 38
// if IsLive ( Houten ) then
10559: LD_EXP 22
10563: PPUSH
10564: CALL_OW 300
10568: IFFALSE 10588
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10570: LD_EXP 22
10574: PPUSH
10575: LD_EXP 1
10579: PUSH
10580: LD_STRING Houten
10582: STR
10583: PPUSH
10584: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10588: LD_ADDR_VAR 0 2
10592: PUSH
10593: LD_INT 22
10595: PUSH
10596: LD_INT 1
10598: PUSH
10599: EMPTY
10600: LIST
10601: LIST
10602: PUSH
10603: LD_INT 2
10605: PUSH
10606: LD_INT 25
10608: PUSH
10609: LD_INT 1
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PUSH
10616: LD_INT 25
10618: PUSH
10619: LD_INT 2
10621: PUSH
10622: EMPTY
10623: LIST
10624: LIST
10625: PUSH
10626: LD_INT 25
10628: PUSH
10629: LD_INT 3
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: LD_INT 4
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: LIST
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PPUSH
10657: CALL_OW 69
10661: PUSH
10662: LD_EXP 18
10666: PUSH
10667: LD_EXP 21
10671: PUSH
10672: LD_EXP 20
10676: PUSH
10677: LD_EXP 22
10681: PUSH
10682: LD_EXP 19
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: LIST
10691: LIST
10692: LIST
10693: DIFF
10694: ST_TO_ADDR
// if tmp then
10695: LD_VAR 0 2
10699: IFFALSE 10719
// SaveCharacters ( tmp , mission_prefix & others ) ;
10701: LD_VAR 0 2
10705: PPUSH
10706: LD_EXP 1
10710: PUSH
10711: LD_STRING others
10713: STR
10714: PPUSH
10715: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10719: LD_ADDR_VAR 0 2
10723: PUSH
10724: LD_INT 22
10726: PUSH
10727: LD_INT 1
10729: PUSH
10730: EMPTY
10731: LIST
10732: LIST
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: LD_INT 25
10739: PUSH
10740: LD_INT 12
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: PUSH
10747: LD_INT 25
10749: PUSH
10750: LD_INT 16
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: LIST
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PPUSH
10766: CALL_OW 69
10770: ST_TO_ADDR
// if tmp then
10771: LD_VAR 0 2
10775: IFFALSE 10795
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10777: LD_VAR 0 2
10781: PPUSH
10782: LD_EXP 1
10786: PUSH
10787: LD_STRING apes
10789: STR
10790: PPUSH
10791: CALL_OW 38
// YouWin ;
10795: CALL_OW 103
// end ; end_of_file
10799: PPOPN 3
10801: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10802: LD_VAR 0 1
10806: PPUSH
10807: CALL_OW 266
10811: PUSH
10812: LD_INT 0
10814: EQUAL
10815: PUSH
10816: LD_EXP 3
10820: NOT
10821: AND
10822: IFFALSE 10846
// begin terminal := b ;
10824: LD_ADDR_EXP 3
10828: PUSH
10829: LD_VAR 0 1
10833: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10834: LD_EXP 3
10838: PPUSH
10839: LD_STRING terminal
10841: PPUSH
10842: CALL_OW 500
// end ; end ;
10846: PPOPN 2
10848: END
// on BuildingComplete ( b ) do var i ;
10849: LD_INT 0
10851: PPUSH
// begin if GetSide ( b ) = 3 then
10852: LD_VAR 0 1
10856: PPUSH
10857: CALL_OW 255
10861: PUSH
10862: LD_INT 3
10864: EQUAL
10865: IFFALSE 10905
// for i = 1 to 4 do
10867: LD_ADDR_VAR 0 2
10871: PUSH
10872: DOUBLE
10873: LD_INT 1
10875: DEC
10876: ST_TO_ADDR
10877: LD_INT 4
10879: PUSH
10880: FOR_TO
10881: IFFALSE 10903
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10883: LD_ADDR_EXP 36
10887: PUSH
10888: LD_EXP 36
10892: PPUSH
10893: LD_INT 1
10895: PPUSH
10896: CALL_OW 3
10900: ST_TO_ADDR
10901: GO 10880
10903: POP
10904: POP
// end ;
10905: PPOPN 2
10907: END
// on VehicleConstructed ( veh , fac ) do var i ;
10908: LD_INT 0
10910: PPUSH
// begin if GetSide ( veh ) = 3 then
10911: LD_VAR 0 1
10915: PPUSH
10916: CALL_OW 255
10920: PUSH
10921: LD_INT 3
10923: EQUAL
10924: IFFALSE 11049
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10926: LD_VAR 0 1
10930: PPUSH
10931: CALL_OW 264
10935: PUSH
10936: LD_INT 53
10938: PUSH
10939: LD_INT 52
10941: PUSH
10942: LD_INT 51
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: LIST
10949: IN
10950: NOT
10951: IFFALSE 10969
// ru_force := ru_force ^ veh ;
10953: LD_ADDR_EXP 35
10957: PUSH
10958: LD_EXP 35
10962: PUSH
10963: LD_VAR 0 1
10967: ADD
10968: ST_TO_ADDR
// for i = 1 to 4 do
10969: LD_ADDR_VAR 0 3
10973: PUSH
10974: DOUBLE
10975: LD_INT 1
10977: DEC
10978: ST_TO_ADDR
10979: LD_INT 4
10981: PUSH
10982: FOR_TO
10983: IFFALSE 11005
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10985: LD_ADDR_EXP 37
10989: PUSH
10990: LD_EXP 37
10994: PPUSH
10995: LD_INT 1
10997: PPUSH
10998: CALL_OW 3
11002: ST_TO_ADDR
11003: GO 10982
11005: POP
11006: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11007: LD_VAR 0 1
11011: PPUSH
11012: CALL_OW 264
11016: PUSH
11017: LD_INT 53
11019: EQUAL
11020: IFFALSE 11049
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11022: LD_VAR 0 1
11026: PPUSH
11027: LD_INT 7
11029: PPUSH
11030: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11034: LD_VAR 0 1
11038: PPUSH
11039: LD_INT 170
11041: PPUSH
11042: LD_INT 235
11044: PPUSH
11045: CALL_OW 171
// end ; end ; end ;
11049: PPOPN 3
11051: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11052: LD_VAR 0 1
11056: PUSH
11057: LD_INT 1
11059: EQUAL
11060: PUSH
11061: LD_VAR 0 2
11065: PUSH
11066: LD_INT 2
11068: EQUAL
11069: AND
11070: PUSH
11071: LD_VAR 0 1
11075: PUSH
11076: LD_INT 2
11078: EQUAL
11079: PUSH
11080: LD_VAR 0 2
11084: PUSH
11085: LD_INT 1
11087: EQUAL
11088: AND
11089: OR
11090: IFFALSE 11100
// player_attacked_ar := true ;
11092: LD_ADDR_EXP 16
11096: PUSH
11097: LD_INT 1
11099: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11100: LD_VAR 0 1
11104: PUSH
11105: LD_INT 1
11107: EQUAL
11108: PUSH
11109: LD_VAR 0 2
11113: PUSH
11114: LD_INT 4
11116: EQUAL
11117: AND
11118: PUSH
11119: LD_VAR 0 1
11123: PUSH
11124: LD_INT 4
11126: EQUAL
11127: PUSH
11128: LD_VAR 0 2
11132: PUSH
11133: LD_INT 1
11135: EQUAL
11136: AND
11137: OR
11138: IFFALSE 11147
// YouLost ( Traitor ) ;
11140: LD_STRING Traitor
11142: PPUSH
11143: CALL_OW 104
// end ;
11147: PPOPN 2
11149: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11150: LD_VAR 0 1
11154: PUSH
11155: LD_EXP 18
11159: EQUAL
11160: IFFALSE 11169
// YouLost ( JMM ) ;
11162: LD_STRING JMM
11164: PPUSH
11165: CALL_OW 104
// if un = terminal then
11169: LD_VAR 0 1
11173: PUSH
11174: LD_EXP 3
11178: EQUAL
11179: IFFALSE 11188
// YouLost ( Terminal ) ;
11181: LD_STRING Terminal
11183: PPUSH
11184: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11188: LD_VAR 0 1
11192: PUSH
11193: LD_INT 22
11195: PUSH
11196: LD_INT 3
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 21
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: PPUSH
11217: CALL_OW 69
11221: IN
11222: IFFALSE 11368
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11224: LD_VAR 0 1
11228: PPUSH
11229: CALL_OW 266
11233: PUSH
11234: LD_INT 33
11236: PUSH
11237: LD_INT 26
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: IN
11244: IFFALSE 11303
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11246: LD_ADDR_EXP 36
11250: PUSH
11251: LD_EXP 36
11255: PUSH
11256: LD_VAR 0 1
11260: PPUSH
11261: CALL_OW 266
11265: PUSH
11266: LD_VAR 0 1
11270: PPUSH
11271: CALL_OW 250
11275: PUSH
11276: LD_VAR 0 1
11280: PPUSH
11281: CALL_OW 251
11285: PUSH
11286: LD_VAR 0 1
11290: PPUSH
11291: CALL_OW 254
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: ADD
11302: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11303: LD_VAR 0 1
11307: PPUSH
11308: CALL_OW 266
11312: PUSH
11313: LD_INT 5
11315: EQUAL
11316: IFFALSE 11368
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11318: LD_ADDR_EXP 36
11322: PUSH
11323: LD_EXP 36
11327: PUSH
11328: LD_INT 4
11330: PUSH
11331: LD_VAR 0 1
11335: PPUSH
11336: CALL_OW 250
11340: PUSH
11341: LD_VAR 0 1
11345: PPUSH
11346: CALL_OW 251
11350: PUSH
11351: LD_VAR 0 1
11355: PPUSH
11356: CALL_OW 254
11360: PUSH
11361: EMPTY
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: ADD
11367: ST_TO_ADDR
// end ; if un in ru_force then
11368: LD_VAR 0 1
11372: PUSH
11373: LD_EXP 35
11377: IN
11378: IFFALSE 11414
// begin ru_force := ru_force diff un ;
11380: LD_ADDR_EXP 35
11384: PUSH
11385: LD_EXP 35
11389: PUSH
11390: LD_VAR 0 1
11394: DIFF
11395: ST_TO_ADDR
// if ru_force = 0 then
11396: LD_EXP 35
11400: PUSH
11401: LD_INT 0
11403: EQUAL
11404: IFFALSE 11414
// ru_can_attack := false ;
11406: LD_ADDR_EXP 8
11410: PUSH
11411: LD_INT 0
11413: ST_TO_ADDR
// end ; end ; end_of_file
11414: PPOPN 1
11416: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11417: LD_EXP 5
11421: PUSH
11422: LD_EXP 6
11426: AND
11427: IFFALSE 11505
11429: GO 11431
11431: DISABLE
11432: LD_INT 0
11434: PPUSH
// begin enable ;
11435: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11436: LD_ADDR_VAR 0 1
11440: PUSH
11441: LD_INT 60
11443: PUSH
11444: CALL 784 0 0
11448: MINUS
11449: ST_TO_ADDR
// if sib < 0 then
11450: LD_VAR 0 1
11454: PUSH
11455: LD_INT 0
11457: LESS
11458: IFFALSE 11468
// sib := 0 ;
11460: LD_ADDR_VAR 0 1
11464: PUSH
11465: LD_INT 0
11467: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11468: LD_ADDR_OWVAR 47
11472: PUSH
11473: LD_STRING #Am09-1
11475: PUSH
11476: LD_VAR 0 1
11480: PUSH
11481: LD_EXP 6
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: LIST
11490: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11491: LD_ADDR_EXP 6
11495: PUSH
11496: LD_EXP 6
11500: PUSH
11501: LD_INT 35
11503: MINUS
11504: ST_TO_ADDR
// end ;
11505: PPOPN 1
11507: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11508: LD_EXP 6
11512: PUSH
11513: LD_INT 0
11515: EQUAL
11516: IFFALSE 11528
11518: GO 11520
11520: DISABLE
// display_strings := [ ] ;
11521: LD_ADDR_OWVAR 47
11525: PUSH
11526: EMPTY
11527: ST_TO_ADDR
11528: END
// every 0 0$01 trigger ru_force and debug do
11529: LD_EXP 35
11533: PUSH
11534: LD_EXP 2
11538: AND
11539: IFFALSE 11555
11541: GO 11543
11543: DISABLE
// begin enable ;
11544: ENABLE
// display_strings := ru_force ;
11545: LD_ADDR_OWVAR 47
11549: PUSH
11550: LD_EXP 35
11554: ST_TO_ADDR
// end ;
11555: END
// every 1 1$35 do var i , tmp ;
11556: GO 11558
11558: DISABLE
11559: LD_INT 0
11561: PPUSH
11562: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11563: LD_ADDR_VAR 0 2
11567: PUSH
11568: LD_INT 1155
11570: PUSH
11571: LD_INT 1225
11573: PUSH
11574: LD_INT 1435
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: LIST
11581: PUSH
11582: LD_OWVAR 67
11586: ARRAY
11587: ST_TO_ADDR
// i := 0 ;
11588: LD_ADDR_VAR 0 1
11592: PUSH
11593: LD_INT 0
11595: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11596: LD_INT 1
11598: PPUSH
11599: LD_INT 5
11601: PPUSH
11602: CALL_OW 12
11606: PPUSH
11607: LD_INT 75
11609: PPUSH
11610: LD_INT 75
11612: PPUSH
11613: LD_INT 20
11615: PPUSH
11616: LD_INT 1
11618: PPUSH
11619: CALL_OW 56
// wait ( tmp ) ;
11623: LD_VAR 0 2
11627: PPUSH
11628: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11632: LD_ADDR_VAR 0 2
11636: PUSH
11637: LD_VAR 0 2
11641: PUSH
11642: LD_INT 105
11644: PPUSH
11645: LD_INT 315
11647: PPUSH
11648: CALL_OW 12
11652: PLUS
11653: ST_TO_ADDR
// i := i + 1 ;
11654: LD_ADDR_VAR 0 1
11658: PUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 1
11666: PLUS
11667: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11668: LD_VAR 0 1
11672: PUSH
11673: LD_INT 3
11675: MOD
11676: PUSH
11677: LD_INT 0
11679: EQUAL
11680: PUSH
11681: LD_EXP 4
11685: AND
11686: IFFALSE 11724
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11688: LD_INT 2
11690: PPUSH
11691: LD_INT 5
11693: PPUSH
11694: CALL_OW 12
11698: PPUSH
11699: LD_INT 8
11701: PPUSH
11702: LD_INT 1
11704: PPUSH
11705: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11709: LD_INT 665
11711: PPUSH
11712: LD_INT 735
11714: PPUSH
11715: CALL_OW 12
11719: PPUSH
11720: CALL_OW 67
// end ; until tick > game_time ;
11724: LD_OWVAR 1
11728: PUSH
11729: LD_EXP 7
11733: GREATER
11734: IFFALSE 11596
// end ; end_of_file
11736: PPOPN 2
11738: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11739: LD_INT 0
11741: PPUSH
11742: PPUSH
11743: PPUSH
11744: PPUSH
11745: PPUSH
11746: PPUSH
// x := 76 ;
11747: LD_ADDR_VAR 0 5
11751: PUSH
11752: LD_INT 76
11754: ST_TO_ADDR
// y := 147 ;
11755: LD_ADDR_VAR 0 6
11759: PUSH
11760: LD_INT 147
11762: ST_TO_ADDR
// uc_side := 2 ;
11763: LD_ADDR_OWVAR 20
11767: PUSH
11768: LD_INT 2
11770: ST_TO_ADDR
// uc_nation := 2 ;
11771: LD_ADDR_OWVAR 21
11775: PUSH
11776: LD_INT 2
11778: ST_TO_ADDR
// InitHc ;
11779: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11783: LD_INT 1
11785: PPUSH
11786: LD_INT 1
11788: PPUSH
11789: LD_INT 6
11791: PPUSH
11792: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11796: LD_ADDR_OWVAR 26
11800: PUSH
11801: LD_STRING Nicolas Vervecken
11803: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11804: LD_ADDR_OWVAR 33
11808: PUSH
11809: LD_STRING SecondCharsGal
11811: ST_TO_ADDR
// hc_face_number := 3 ;
11812: LD_ADDR_OWVAR 34
11816: PUSH
11817: LD_INT 3
11819: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11820: LD_ADDR_OWVAR 29
11824: PUSH
11825: LD_INT 11
11827: PUSH
11828: LD_INT 10
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// Vervecken := CreateHuman ;
11835: LD_ADDR_EXP 26
11839: PUSH
11840: CALL_OW 44
11844: ST_TO_ADDR
// ar_force := Vervecken ;
11845: LD_ADDR_EXP 33
11849: PUSH
11850: LD_EXP 26
11854: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11855: LD_INT 1
11857: PPUSH
11858: LD_INT 2
11860: PPUSH
11861: LD_INT 6
11863: PPUSH
11864: CALL_OW 380
// hc_name := Louis Gali ;
11868: LD_ADDR_OWVAR 26
11872: PUSH
11873: LD_STRING Louis Gali
11875: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11876: LD_ADDR_OWVAR 33
11880: PUSH
11881: LD_STRING SecondCharsGal
11883: ST_TO_ADDR
// hc_face_number := 2 ;
11884: LD_ADDR_OWVAR 34
11888: PUSH
11889: LD_INT 2
11891: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11892: LD_ADDR_OWVAR 29
11896: PUSH
11897: LD_INT 10
11899: PUSH
11900: LD_INT 11
11902: PUSH
11903: EMPTY
11904: LIST
11905: LIST
11906: ST_TO_ADDR
// Gali := CreateHuman ;
11907: LD_ADDR_EXP 27
11911: PUSH
11912: CALL_OW 44
11916: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11917: LD_ADDR_EXP 33
11921: PUSH
11922: LD_EXP 33
11926: PUSH
11927: LD_EXP 27
11931: ADD
11932: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11933: LD_INT 2
11935: PPUSH
11936: LD_INT 1
11938: PPUSH
11939: LD_INT 6
11941: PPUSH
11942: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11946: LD_ADDR_OWVAR 26
11950: PUSH
11951: LD_STRING Maria Bogdanovic
11953: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11954: LD_ADDR_OWVAR 33
11958: PUSH
11959: LD_STRING SecondCharsGal
11961: ST_TO_ADDR
// hc_face_number := 14 ;
11962: LD_ADDR_OWVAR 34
11966: PUSH
11967: LD_INT 14
11969: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11970: LD_ADDR_OWVAR 29
11974: PUSH
11975: LD_INT 12
11977: PUSH
11978: LD_INT 9
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11985: LD_ADDR_EXP 28
11989: PUSH
11990: CALL_OW 44
11994: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11995: LD_ADDR_EXP 33
11999: PUSH
12000: LD_EXP 33
12004: PUSH
12005: LD_EXP 28
12009: ADD
12010: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12011: LD_INT 1
12013: PPUSH
12014: LD_INT 3
12016: PPUSH
12017: LD_INT 6
12019: PPUSH
12020: CALL_OW 380
// hc_name = Kntor Radomr ;
12024: LD_ADDR_OWVAR 26
12028: PUSH
12029: LD_STRING Kntor Radomr
12031: ST_TO_ADDR
// hc_gallery = sandar ;
12032: LD_ADDR_OWVAR 33
12036: PUSH
12037: LD_STRING sandar
12039: ST_TO_ADDR
// hc_face_number = 12 ;
12040: LD_ADDR_OWVAR 34
12044: PUSH
12045: LD_INT 12
12047: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12048: LD_ADDR_OWVAR 29
12052: PUSH
12053: LD_INT 9
12055: PUSH
12056: LD_INT 9
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: ST_TO_ADDR
// Kantor = CreateHuman ;
12063: LD_ADDR_EXP 29
12067: PUSH
12068: CALL_OW 44
12072: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12073: LD_ADDR_EXP 33
12077: PUSH
12078: LD_EXP 33
12082: PUSH
12083: LD_EXP 29
12087: ADD
12088: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12089: LD_INT 1
12091: PPUSH
12092: LD_INT 3
12094: PPUSH
12095: LD_INT 6
12097: PPUSH
12098: CALL_OW 380
// hc_name = Herczeg Farkas ;
12102: LD_ADDR_OWVAR 26
12106: PUSH
12107: LD_STRING Herczeg Farkas
12109: ST_TO_ADDR
// hc_gallery = sandar ;
12110: LD_ADDR_OWVAR 33
12114: PUSH
12115: LD_STRING sandar
12117: ST_TO_ADDR
// hc_face_number = 28 ;
12118: LD_ADDR_OWVAR 34
12122: PUSH
12123: LD_INT 28
12125: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12126: LD_ADDR_OWVAR 29
12130: PUSH
12131: LD_INT 10
12133: PUSH
12134: LD_INT 9
12136: PUSH
12137: EMPTY
12138: LIST
12139: LIST
12140: ST_TO_ADDR
// Herczeg = CreateHuman ;
12141: LD_ADDR_EXP 30
12145: PUSH
12146: CALL_OW 44
12150: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12151: LD_ADDR_EXP 33
12155: PUSH
12156: LD_EXP 33
12160: PUSH
12161: LD_EXP 30
12165: ADD
12166: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12167: LD_INT 1
12169: PPUSH
12170: LD_INT 1
12172: PPUSH
12173: LD_INT 6
12175: PPUSH
12176: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12180: LD_ADDR_OWVAR 26
12184: PUSH
12185: LD_STRING Ronn Horntvedt
12187: ST_TO_ADDR
// hc_gallery = sandar ;
12188: LD_ADDR_OWVAR 33
12192: PUSH
12193: LD_STRING sandar
12195: ST_TO_ADDR
// hc_face_number = 29 ;
12196: LD_ADDR_OWVAR 34
12200: PUSH
12201: LD_INT 29
12203: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12204: LD_ADDR_OWVAR 29
12208: PUSH
12209: LD_INT 11
12211: PUSH
12212: LD_INT 11
12214: PUSH
12215: EMPTY
12216: LIST
12217: LIST
12218: ST_TO_ADDR
// Ronn = CreateHuman ;
12219: LD_ADDR_EXP 31
12223: PUSH
12224: CALL_OW 44
12228: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12229: LD_ADDR_EXP 33
12233: PUSH
12234: LD_EXP 33
12238: PUSH
12239: LD_EXP 31
12243: ADD
12244: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12245: LD_INT 2
12247: PPUSH
12248: LD_INT 3
12250: PPUSH
12251: LD_INT 6
12253: PPUSH
12254: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12258: LD_ADDR_OWVAR 26
12262: PUSH
12263: LD_STRING Mia D. Mathiasen
12265: ST_TO_ADDR
// hc_gallery = sandar ;
12266: LD_ADDR_OWVAR 33
12270: PUSH
12271: LD_STRING sandar
12273: ST_TO_ADDR
// hc_face_number = 31 ;
12274: LD_ADDR_OWVAR 34
12278: PUSH
12279: LD_INT 31
12281: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12282: LD_ADDR_OWVAR 29
12286: PUSH
12287: LD_INT 10
12289: PUSH
12290: LD_INT 10
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: ST_TO_ADDR
// Mia = CreateHuman ;
12297: LD_ADDR_EXP 32
12301: PUSH
12302: CALL_OW 44
12306: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12307: LD_ADDR_EXP 33
12311: PUSH
12312: LD_EXP 33
12316: PUSH
12317: LD_EXP 32
12321: ADD
12322: ST_TO_ADDR
// for i = 1 to 2 do
12323: LD_ADDR_VAR 0 4
12327: PUSH
12328: DOUBLE
12329: LD_INT 1
12331: DEC
12332: ST_TO_ADDR
12333: LD_INT 2
12335: PUSH
12336: FOR_TO
12337: IFFALSE 12378
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_INT 2
12351: PPUSH
12352: LD_INT 2
12354: PPUSH
12355: LD_INT 14
12357: PPUSH
12358: LD_INT 1
12360: PPUSH
12361: LD_INT 1
12363: PPUSH
12364: LD_INT 32
12366: PPUSH
12367: LD_INT 30
12369: PPUSH
12370: CALL 264 0 7
12374: ADD
12375: ST_TO_ADDR
12376: GO 12336
12378: POP
12379: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12380: LD_ADDR_VAR 0 3
12384: PUSH
12385: LD_VAR 0 3
12389: PUSH
12390: LD_INT 2
12392: PPUSH
12393: LD_INT 2
12395: PPUSH
12396: LD_INT 14
12398: PPUSH
12399: LD_INT 1
12401: PPUSH
12402: LD_INT 1
12404: PPUSH
12405: LD_INT 26
12407: PPUSH
12408: LD_INT 33
12410: PPUSH
12411: CALL 264 0 7
12415: ADD
12416: ST_TO_ADDR
// tmp := tmp diff 0 ;
12417: LD_ADDR_VAR 0 3
12421: PUSH
12422: LD_VAR 0 3
12426: PUSH
12427: LD_INT 0
12429: DIFF
12430: ST_TO_ADDR
// for i in ar_force do
12431: LD_ADDR_VAR 0 4
12435: PUSH
12436: LD_EXP 33
12440: PUSH
12441: FOR_IN
12442: IFFALSE 12585
// begin if GetClass ( i ) = 3 then
12444: LD_VAR 0 4
12448: PPUSH
12449: CALL_OW 257
12453: PUSH
12454: LD_INT 3
12456: EQUAL
12457: IFFALSE 12539
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12459: LD_VAR 0 3
12463: PUSH
12464: LD_INT 1
12466: ARRAY
12467: PPUSH
12468: LD_INT 1
12470: PPUSH
12471: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12475: LD_VAR 0 3
12479: PUSH
12480: LD_INT 1
12482: ARRAY
12483: PPUSH
12484: LD_VAR 0 5
12488: PPUSH
12489: LD_VAR 0 6
12493: PPUSH
12494: LD_INT 0
12496: PPUSH
12497: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12501: LD_VAR 0 4
12505: PPUSH
12506: LD_VAR 0 3
12510: PUSH
12511: LD_INT 1
12513: ARRAY
12514: PPUSH
12515: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_VAR 0 3
12528: PPUSH
12529: LD_INT 1
12531: PPUSH
12532: CALL_OW 3
12536: ST_TO_ADDR
// end else
12537: GO 12561
// PlaceUnitXY ( i , x , y , false ) ;
12539: LD_VAR 0 4
12543: PPUSH
12544: LD_VAR 0 5
12548: PPUSH
12549: LD_VAR 0 6
12553: PPUSH
12554: LD_INT 0
12556: PPUSH
12557: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12561: LD_VAR 0 4
12565: PPUSH
12566: LD_INT 86
12568: PPUSH
12569: LD_INT 121
12571: PPUSH
12572: CALL_OW 111
// wait ( 0 0$2 ) ;
12576: LD_INT 70
12578: PPUSH
12579: CALL_OW 67
// end ;
12583: GO 12441
12585: POP
12586: POP
// ar_force := ar_force ^ tmp ;
12587: LD_ADDR_EXP 33
12591: PUSH
12592: LD_EXP 33
12596: PUSH
12597: LD_VAR 0 3
12601: ADD
12602: ST_TO_ADDR
// ar_spawned := true ;
12603: LD_ADDR_EXP 11
12607: PUSH
12608: LD_INT 1
12610: ST_TO_ADDR
// end ; end_of_file
12611: LD_VAR 0 1
12615: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12616: LD_INT 0
12618: PPUSH
12619: PPUSH
12620: PPUSH
12621: PPUSH
12622: PPUSH
12623: PPUSH
12624: PPUSH
// InitHc ;
12625: CALL_OW 19
// uc_side := 3 ;
12629: LD_ADDR_OWVAR 20
12633: PUSH
12634: LD_INT 3
12636: ST_TO_ADDR
// uc_nation := 3 ;
12637: LD_ADDR_OWVAR 21
12641: PUSH
12642: LD_INT 3
12644: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12645: LD_ADDR_VAR 0 5
12649: PUSH
12650: LD_INT 5
12652: PUSH
12653: LD_INT 6
12655: PUSH
12656: LD_INT 7
12658: PUSH
12659: EMPTY
12660: LIST
12661: LIST
12662: LIST
12663: PUSH
12664: LD_OWVAR 67
12668: ARRAY
12669: ST_TO_ADDR
// ru_force := [ ] ;
12670: LD_ADDR_EXP 35
12674: PUSH
12675: EMPTY
12676: ST_TO_ADDR
// ru_rebuild := [ ] ;
12677: LD_ADDR_EXP 36
12681: PUSH
12682: EMPTY
12683: ST_TO_ADDR
// ru_produce_list := [ ] ;
12684: LD_ADDR_EXP 37
12688: PUSH
12689: EMPTY
12690: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12691: LD_ADDR_VAR 0 6
12695: PUSH
12696: LD_INT 22
12698: PUSH
12699: LD_INT 3
12701: PUSH
12702: EMPTY
12703: LIST
12704: LIST
12705: PUSH
12706: LD_INT 30
12708: PUSH
12709: LD_INT 8
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PPUSH
12720: CALL_OW 69
12724: PUSH
12725: LD_INT 1
12727: ARRAY
12728: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12729: LD_ADDR_VAR 0 4
12733: PUSH
12734: LD_INT 43
12736: PUSH
12737: LD_INT 46
12739: PUSH
12740: LD_INT 45
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12748: LD_ADDR_VAR 0 7
12752: PUSH
12753: LD_INT 22
12755: PUSH
12756: LD_INT 3
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 30
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PPUSH
12777: CALL_OW 69
12781: PUSH
12782: LD_INT 1
12784: ARRAY
12785: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12786: LD_VAR 0 7
12790: PPUSH
12791: CALL_OW 274
12795: PPUSH
12796: LD_INT 1
12798: PPUSH
12799: LD_INT 5000
12801: PPUSH
12802: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12806: LD_VAR 0 7
12810: PPUSH
12811: CALL_OW 274
12815: PPUSH
12816: LD_INT 2
12818: PPUSH
12819: LD_INT 1000
12821: PPUSH
12822: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12826: LD_VAR 0 7
12830: PPUSH
12831: CALL_OW 274
12835: PPUSH
12836: LD_INT 3
12838: PPUSH
12839: LD_INT 30
12841: PPUSH
12842: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12846: LD_ADDR_VAR 0 2
12850: PUSH
12851: LD_INT 22
12853: PUSH
12854: LD_INT 3
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: LD_INT 30
12863: PUSH
12864: LD_INT 33
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PPUSH
12875: CALL_OW 69
12879: PUSH
12880: FOR_IN
12881: IFFALSE 12913
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12883: LD_VAR 0 2
12887: PPUSH
12888: LD_VAR 0 4
12892: PUSH
12893: LD_VAR 0 2
12897: PUSH
12898: LD_INT 3
12900: MOD
12901: PUSH
12902: LD_INT 1
12904: PLUS
12905: ARRAY
12906: PPUSH
12907: CALL_OW 431
// end ;
12911: GO 12880
12913: POP
12914: POP
// for i = 1 to 4 do
12915: LD_ADDR_VAR 0 2
12919: PUSH
12920: DOUBLE
12921: LD_INT 1
12923: DEC
12924: ST_TO_ADDR
12925: LD_INT 4
12927: PUSH
12928: FOR_TO
12929: IFFALSE 12990
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12931: LD_INT 0
12933: PPUSH
12934: LD_INT 9
12936: PPUSH
12937: LD_VAR 0 5
12941: PPUSH
12942: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12946: CALL_OW 44
12950: PPUSH
12951: LD_INT 22
12953: PUSH
12954: LD_INT 3
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 30
12963: PUSH
12964: LD_INT 5
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: PPUSH
12975: CALL_OW 69
12979: PUSH
12980: LD_INT 1
12982: ARRAY
12983: PPUSH
12984: CALL_OW 52
// end ;
12988: GO 12928
12990: POP
12991: POP
// for i = 1 to 5 do
12992: LD_ADDR_VAR 0 2
12996: PUSH
12997: DOUBLE
12998: LD_INT 1
13000: DEC
13001: ST_TO_ADDR
13002: LD_INT 5
13004: PUSH
13005: FOR_TO
13006: IFFALSE 13067
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13008: LD_INT 0
13010: PPUSH
13011: LD_INT 3
13013: PPUSH
13014: LD_VAR 0 5
13018: PPUSH
13019: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13023: CALL_OW 44
13027: PPUSH
13028: LD_INT 22
13030: PUSH
13031: LD_INT 3
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 30
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: PPUSH
13052: CALL_OW 69
13056: PUSH
13057: LD_INT 1
13059: ARRAY
13060: PPUSH
13061: CALL_OW 52
// end ;
13065: GO 13005
13067: POP
13068: POP
// for i = 1 to 4 do
13069: LD_ADDR_VAR 0 2
13073: PUSH
13074: DOUBLE
13075: LD_INT 1
13077: DEC
13078: ST_TO_ADDR
13079: LD_INT 4
13081: PUSH
13082: FOR_TO
13083: IFFALSE 13144
// begin PrepareHuman ( false , class_engineer , skill ) ;
13085: LD_INT 0
13087: PPUSH
13088: LD_INT 2
13090: PPUSH
13091: LD_VAR 0 5
13095: PPUSH
13096: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13100: CALL_OW 44
13104: PPUSH
13105: LD_INT 22
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PUSH
13115: LD_INT 30
13117: PUSH
13118: LD_INT 1
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: PPUSH
13129: CALL_OW 69
13133: PUSH
13134: LD_INT 1
13136: ARRAY
13137: PPUSH
13138: CALL_OW 52
// end ;
13142: GO 13082
13144: POP
13145: POP
// for i = 1 to 3 do
13146: LD_ADDR_VAR 0 2
13150: PUSH
13151: DOUBLE
13152: LD_INT 1
13154: DEC
13155: ST_TO_ADDR
13156: LD_INT 3
13158: PUSH
13159: FOR_TO
13160: IFFALSE 13193
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13162: LD_INT 0
13164: PPUSH
13165: LD_INT 4
13167: PPUSH
13168: LD_VAR 0 5
13172: PPUSH
13173: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13177: CALL_OW 44
13181: PPUSH
13182: LD_VAR 0 6
13186: PPUSH
13187: CALL_OW 52
// end ;
13191: GO 13159
13193: POP
13194: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13195: LD_ADDR_EXP 34
13199: PUSH
13200: LD_STRING Yakotich
13202: PPUSH
13203: LD_EXP 2
13207: NOT
13208: PPUSH
13209: LD_STRING 
13211: PPUSH
13212: CALL 201 0 3
13216: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13217: LD_EXP 34
13221: PPUSH
13222: LD_INT 74
13224: PPUSH
13225: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13229: LD_VAR 0 6
13233: PPUSH
13234: LD_INT 49
13236: PPUSH
13237: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13241: LD_VAR 0 6
13245: PPUSH
13246: LD_INT 50
13248: PPUSH
13249: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13253: LD_VAR 0 6
13257: PPUSH
13258: LD_INT 51
13260: PPUSH
13261: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13265: LD_VAR 0 6
13269: PPUSH
13270: LD_INT 52
13272: PPUSH
13273: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13277: LD_VAR 0 6
13281: PPUSH
13282: LD_INT 69
13284: PPUSH
13285: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13289: LD_VAR 0 6
13293: PPUSH
13294: LD_INT 39
13296: PPUSH
13297: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13301: LD_VAR 0 6
13305: PPUSH
13306: LD_INT 34
13308: PPUSH
13309: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13313: LD_VAR 0 6
13317: PPUSH
13318: LD_INT 40
13320: PPUSH
13321: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13325: LD_VAR 0 6
13329: PPUSH
13330: LD_INT 57
13332: PPUSH
13333: CALL_OW 184
// if Difficulty > 1 then
13337: LD_OWVAR 67
13341: PUSH
13342: LD_INT 1
13344: GREATER
13345: IFFALSE 13359
// AddComResearch ( lab , tech_comp2 ) ;
13347: LD_VAR 0 6
13351: PPUSH
13352: LD_INT 58
13354: PPUSH
13355: CALL_OW 184
// end ;
13359: LD_VAR 0 1
13363: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13364: LD_INT 7
13366: PPUSH
13367: CALL_OW 353
13371: PUSH
13372: LD_INT 3
13374: GREATER
13375: PUSH
13376: LD_INT 22
13378: PUSH
13379: LD_INT 3
13381: PUSH
13382: EMPTY
13383: LIST
13384: LIST
13385: PUSH
13386: LD_INT 34
13388: PUSH
13389: LD_INT 53
13391: PUSH
13392: EMPTY
13393: LIST
13394: LIST
13395: PUSH
13396: EMPTY
13397: LIST
13398: LIST
13399: PPUSH
13400: CALL_OW 69
13404: NOT
13405: AND
13406: IFFALSE 13441
13408: GO 13410
13410: DISABLE
// begin enable ;
13411: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13412: LD_ADDR_EXP 37
13416: PUSH
13417: LD_EXP 37
13421: PUSH
13422: LD_INT 24
13424: PUSH
13425: LD_INT 1
13427: PUSH
13428: LD_INT 3
13430: PUSH
13431: LD_INT 53
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: LIST
13438: LIST
13439: ADD
13440: ST_TO_ADDR
// end ;
13441: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13442: LD_INT 22
13444: PUSH
13445: LD_INT 3
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PUSH
13452: LD_INT 21
13454: PUSH
13455: LD_INT 3
13457: PUSH
13458: EMPTY
13459: LIST
13460: LIST
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PPUSH
13466: CALL_OW 69
13470: IFFALSE 14248
13472: GO 13474
13474: DISABLE
13475: LD_INT 0
13477: PPUSH
13478: PPUSH
13479: PPUSH
13480: PPUSH
13481: PPUSH
13482: PPUSH
13483: PPUSH
13484: PPUSH
// begin enable ;
13485: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13486: LD_ADDR_VAR 0 3
13490: PUSH
13491: LD_INT 22
13493: PUSH
13494: LD_INT 3
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PUSH
13501: LD_INT 21
13503: PUSH
13504: LD_INT 3
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: LD_INT 3
13513: PUSH
13514: LD_INT 24
13516: PUSH
13517: LD_INT 1000
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: EMPTY
13529: LIST
13530: LIST
13531: LIST
13532: PPUSH
13533: CALL_OW 69
13537: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13538: LD_ADDR_VAR 0 4
13542: PUSH
13543: LD_INT 22
13545: PUSH
13546: LD_INT 3
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 25
13555: PUSH
13556: LD_INT 2
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PPUSH
13567: CALL_OW 69
13571: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13572: LD_ADDR_VAR 0 5
13576: PUSH
13577: LD_INT 22
13579: PUSH
13580: LD_INT 3
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: LD_INT 30
13589: PUSH
13590: LD_INT 1
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PPUSH
13601: CALL_OW 69
13605: PUSH
13606: LD_INT 1
13608: ARRAY
13609: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13610: LD_ADDR_VAR 0 8
13614: PUSH
13615: LD_INT 22
13617: PUSH
13618: LD_INT 3
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PUSH
13625: LD_INT 2
13627: PUSH
13628: LD_INT 30
13630: PUSH
13631: LD_INT 6
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: LD_INT 30
13640: PUSH
13641: LD_INT 7
13643: PUSH
13644: EMPTY
13645: LIST
13646: LIST
13647: PUSH
13648: LD_INT 30
13650: PUSH
13651: LD_INT 8
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PPUSH
13668: CALL_OW 69
13672: PUSH
13673: LD_INT 1
13675: ARRAY
13676: ST_TO_ADDR
// if not engs then
13677: LD_VAR 0 4
13681: NOT
13682: IFFALSE 13686
// exit ;
13684: GO 14248
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13686: LD_ADDR_VAR 0 6
13690: PUSH
13691: LD_VAR 0 4
13695: PPUSH
13696: LD_INT 3
13698: PUSH
13699: LD_INT 24
13701: PUSH
13702: LD_INT 600
13704: PUSH
13705: EMPTY
13706: LIST
13707: LIST
13708: PUSH
13709: EMPTY
13710: LIST
13711: LIST
13712: PPUSH
13713: CALL_OW 72
13717: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13718: LD_ADDR_VAR 0 7
13722: PUSH
13723: LD_INT 22
13725: PUSH
13726: LD_INT 3
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: PUSH
13733: LD_INT 25
13735: PUSH
13736: LD_INT 4
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PPUSH
13747: CALL_OW 69
13751: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13752: LD_VAR 0 3
13756: NOT
13757: PUSH
13758: LD_EXP 36
13762: NOT
13763: AND
13764: IFFALSE 13824
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13766: LD_VAR 0 4
13770: PPUSH
13771: LD_INT 3
13773: PUSH
13774: LD_INT 54
13776: PUSH
13777: EMPTY
13778: LIST
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PPUSH
13784: CALL_OW 72
13788: IFFALSE 13822
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13790: LD_VAR 0 4
13794: PPUSH
13795: LD_INT 3
13797: PUSH
13798: LD_INT 54
13800: PUSH
13801: EMPTY
13802: LIST
13803: PUSH
13804: EMPTY
13805: LIST
13806: LIST
13807: PPUSH
13808: CALL_OW 72
13812: PPUSH
13813: LD_VAR 0 5
13817: PPUSH
13818: CALL_OW 120
// exit ;
13822: GO 14248
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13824: LD_VAR 0 4
13828: PPUSH
13829: LD_INT 54
13831: PUSH
13832: EMPTY
13833: LIST
13834: PPUSH
13835: CALL_OW 72
13839: IFFALSE 13861
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13841: LD_VAR 0 4
13845: PPUSH
13846: LD_INT 54
13848: PUSH
13849: EMPTY
13850: LIST
13851: PPUSH
13852: CALL_OW 72
13856: PPUSH
13857: CALL_OW 122
// if not tmp then
13861: LD_VAR 0 3
13865: NOT
13866: IFFALSE 13998
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13868: LD_INT 81
13870: PUSH
13871: LD_INT 3
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 92
13880: PUSH
13881: LD_INT 147
13883: PUSH
13884: LD_INT 212
13886: PUSH
13887: LD_INT 30
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PPUSH
13900: CALL_OW 69
13904: NOT
13905: IFFALSE 13998
// begin if not HasTask ( engs [ 1 ] ) then
13907: LD_VAR 0 4
13911: PUSH
13912: LD_INT 1
13914: ARRAY
13915: PPUSH
13916: CALL_OW 314
13920: NOT
13921: IFFALSE 13998
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13923: LD_ADDR_VAR 0 2
13927: PUSH
13928: LD_VAR 0 4
13932: PPUSH
13933: LD_EXP 36
13937: PUSH
13938: LD_INT 1
13940: ARRAY
13941: PPUSH
13942: LD_EXP 36
13946: PUSH
13947: LD_INT 2
13949: ARRAY
13950: PPUSH
13951: LD_EXP 36
13955: PUSH
13956: LD_INT 3
13958: ARRAY
13959: PPUSH
13960: LD_EXP 36
13964: PUSH
13965: LD_INT 4
13967: ARRAY
13968: PPUSH
13969: CALL_OW 145
13973: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13974: LD_VAR 0 2
13978: PPUSH
13979: CALL_OW 266
13983: PUSH
13984: LD_INT 4
13986: EQUAL
13987: IFFALSE 13998
// AddComUpgrade ( i ) ;
13989: LD_VAR 0 2
13993: PPUSH
13994: CALL_OW 206
// end ; end ; end ; for i in engs do
13998: LD_ADDR_VAR 0 2
14002: PUSH
14003: LD_VAR 0 4
14007: PUSH
14008: FOR_IN
14009: IFFALSE 14127
// begin if i in to_heal and sci then
14011: LD_VAR 0 2
14015: PUSH
14016: LD_VAR 0 6
14020: IN
14021: PUSH
14022: LD_VAR 0 7
14026: AND
14027: IFFALSE 14078
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14029: LD_VAR 0 2
14033: PPUSH
14034: LD_INT 149
14036: PPUSH
14037: LD_INT 220
14039: PPUSH
14040: CALL_OW 297
14044: PUSH
14045: LD_INT 5
14047: LESS
14048: IFFALSE 14052
// continue ;
14050: GO 14008
// ComMoveXY ( i , 149 , 220 ) ;
14052: LD_VAR 0 2
14056: PPUSH
14057: LD_INT 149
14059: PPUSH
14060: LD_INT 220
14062: PPUSH
14063: CALL_OW 111
// AddComHold ( i ) ;
14067: LD_VAR 0 2
14071: PPUSH
14072: CALL_OW 200
// end else
14076: GO 14125
// if not HasTask ( i ) or WantsToAttack ( i ) then
14078: LD_VAR 0 2
14082: PPUSH
14083: CALL_OW 314
14087: NOT
14088: PUSH
14089: LD_VAR 0 2
14093: PPUSH
14094: CALL_OW 319
14098: OR
14099: IFFALSE 14125
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14101: LD_VAR 0 2
14105: PPUSH
14106: LD_VAR 0 3
14110: PPUSH
14111: LD_VAR 0 2
14115: PPUSH
14116: CALL_OW 74
14120: PPUSH
14121: CALL_OW 130
// end ;
14125: GO 14008
14127: POP
14128: POP
// if to_heal and sci then
14129: LD_VAR 0 6
14133: PUSH
14134: LD_VAR 0 7
14138: AND
14139: IFFALSE 14200
// begin if UnitFilter ( sci , [ f_inside ] ) then
14141: LD_VAR 0 7
14145: PPUSH
14146: LD_INT 54
14148: PUSH
14149: EMPTY
14150: LIST
14151: PPUSH
14152: CALL_OW 72
14156: IFFALSE 14180
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14158: LD_VAR 0 7
14162: PPUSH
14163: LD_INT 54
14165: PUSH
14166: EMPTY
14167: LIST
14168: PPUSH
14169: CALL_OW 72
14173: PPUSH
14174: CALL_OW 122
14178: GO 14198
// ComHeal ( sci , to_heal [ 1 ] ) ;
14180: LD_VAR 0 7
14184: PPUSH
14185: LD_VAR 0 6
14189: PUSH
14190: LD_INT 1
14192: ARRAY
14193: PPUSH
14194: CALL_OW 128
// end else
14198: GO 14248
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14200: LD_VAR 0 7
14204: PPUSH
14205: LD_INT 56
14207: PUSH
14208: EMPTY
14209: LIST
14210: PPUSH
14211: CALL_OW 72
14215: PUSH
14216: LD_VAR 0 8
14220: AND
14221: IFFALSE 14248
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14223: LD_VAR 0 7
14227: PPUSH
14228: LD_INT 56
14230: PUSH
14231: EMPTY
14232: LIST
14233: PPUSH
14234: CALL_OW 72
14238: PPUSH
14239: LD_VAR 0 8
14243: PPUSH
14244: CALL_OW 120
// end ;
14248: PPOPN 8
14250: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14251: LD_INT 22
14253: PUSH
14254: LD_INT 3
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PUSH
14261: LD_INT 30
14263: PUSH
14264: LD_INT 3
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: PPUSH
14275: CALL_OW 69
14279: PUSH
14280: LD_EXP 37
14284: AND
14285: IFFALSE 14411
14287: GO 14289
14289: DISABLE
14290: LD_INT 0
14292: PPUSH
14293: PPUSH
14294: PPUSH
// begin enable ;
14295: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14296: LD_ADDR_VAR 0 3
14300: PUSH
14301: LD_INT 22
14303: PUSH
14304: LD_INT 3
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PUSH
14311: LD_INT 30
14313: PUSH
14314: LD_INT 3
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: PPUSH
14325: CALL_OW 69
14329: PUSH
14330: LD_INT 1
14332: ARRAY
14333: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14334: LD_VAR 0 3
14338: PPUSH
14339: CALL_OW 313
14343: PUSH
14344: LD_INT 0
14346: EQUAL
14347: IFFALSE 14351
// exit ;
14349: GO 14411
// if BuildingStatus ( fac ) = bs_idle then
14351: LD_VAR 0 3
14355: PPUSH
14356: CALL_OW 461
14360: PUSH
14361: LD_INT 2
14363: EQUAL
14364: IFFALSE 14411
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14366: LD_VAR 0 3
14370: PPUSH
14371: LD_EXP 37
14375: PUSH
14376: LD_INT 1
14378: ARRAY
14379: PPUSH
14380: LD_EXP 37
14384: PUSH
14385: LD_INT 2
14387: ARRAY
14388: PPUSH
14389: LD_EXP 37
14393: PUSH
14394: LD_INT 3
14396: ARRAY
14397: PPUSH
14398: LD_EXP 37
14402: PUSH
14403: LD_INT 4
14405: ARRAY
14406: PPUSH
14407: CALL_OW 125
// end ;
14411: PPOPN 3
14413: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14414: LD_INT 0
14416: PPUSH
14417: PPUSH
14418: PPUSH
14419: PPUSH
14420: PPUSH
// uc_side := 3 ;
14421: LD_ADDR_OWVAR 20
14425: PUSH
14426: LD_INT 3
14428: ST_TO_ADDR
// uc_nation := 3 ;
14429: LD_ADDR_OWVAR 21
14433: PUSH
14434: LD_INT 3
14436: ST_TO_ADDR
// ru_can_attack := false ;
14437: LD_ADDR_EXP 8
14441: PUSH
14442: LD_INT 0
14444: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14445: LD_ADDR_VAR 0 6
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 3
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 30
14462: PUSH
14463: LD_INT 3
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: ST_TO_ADDR
// if fac then
14479: LD_VAR 0 6
14483: IFFALSE 14635
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14485: LD_ADDR_EXP 37
14489: PUSH
14490: LD_INT 24
14492: PUSH
14493: LD_INT 1
14495: PUSH
14496: LD_INT 3
14498: PUSH
14499: LD_INT 43
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: ST_TO_ADDR
// if wave > 1 then
14508: LD_VAR 0 1
14512: PUSH
14513: LD_INT 1
14515: GREATER
14516: IFFALSE 14569
// for i = 1 to Difficulty do
14518: LD_ADDR_VAR 0 3
14522: PUSH
14523: DOUBLE
14524: LD_INT 1
14526: DEC
14527: ST_TO_ADDR
14528: LD_OWVAR 67
14532: PUSH
14533: FOR_TO
14534: IFFALSE 14567
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14536: LD_ADDR_EXP 37
14540: PUSH
14541: LD_EXP 37
14545: PUSH
14546: LD_INT 24
14548: PUSH
14549: LD_INT 1
14551: PUSH
14552: LD_INT 3
14554: PUSH
14555: LD_INT 45
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: ADD
14564: ST_TO_ADDR
14565: GO 14533
14567: POP
14568: POP
// repeat wait ( 0 0$1 ) ;
14569: LD_INT 35
14571: PPUSH
14572: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14576: LD_EXP 37
14580: PUSH
14581: LD_INT 4
14583: LESS
14584: PUSH
14585: LD_VAR 0 6
14589: PUSH
14590: LD_INT 1
14592: ARRAY
14593: PPUSH
14594: CALL_OW 313
14598: PUSH
14599: LD_INT 0
14601: EQUAL
14602: OR
14603: PUSH
14604: LD_VAR 0 6
14608: PUSH
14609: LD_INT 1
14611: ARRAY
14612: PPUSH
14613: CALL_OW 461
14617: PUSH
14618: LD_INT 8
14620: PUSH
14621: LD_INT 6
14623: PUSH
14624: LD_INT 7
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: LIST
14631: IN
14632: OR
14633: IFFALSE 14569
// end ; case wave of 1 :
14635: LD_VAR 0 1
14639: PUSH
14640: LD_INT 1
14642: DOUBLE
14643: EQUAL
14644: IFTRUE 14648
14646: GO 14733
14648: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14649: LD_ADDR_VAR 0 3
14653: PUSH
14654: DOUBLE
14655: LD_INT 1
14657: DEC
14658: ST_TO_ADDR
14659: LD_INT 4
14661: PUSH
14662: LD_INT 5
14664: PUSH
14665: LD_INT 6
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: LIST
14672: PUSH
14673: LD_OWVAR 67
14677: ARRAY
14678: PUSH
14679: FOR_TO
14680: IFFALSE 14688
// Sold ;
14682: CALL 14959 0 0
14686: GO 14679
14688: POP
14689: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14690: LD_ADDR_VAR 0 3
14694: PUSH
14695: DOUBLE
14696: LD_INT 1
14698: DEC
14699: ST_TO_ADDR
14700: LD_INT 2
14702: PUSH
14703: LD_INT 3
14705: PUSH
14706: LD_INT 3
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: LIST
14713: PUSH
14714: LD_OWVAR 67
14718: ARRAY
14719: PUSH
14720: FOR_TO
14721: IFFALSE 14729
// Tank ;
14723: CALL 15089 0 0
14727: GO 14720
14729: POP
14730: POP
// end ; 2 .. 9 :
14731: GO 14946
14733: LD_INT 2
14735: DOUBLE
14736: GREATEREQUAL
14737: IFFALSE 14745
14739: LD_INT 9
14741: DOUBLE
14742: LESSEQUAL
14743: IFTRUE 14747
14745: GO 14852
14747: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14748: LD_ADDR_VAR 0 3
14752: PUSH
14753: DOUBLE
14754: LD_INT 1
14756: DEC
14757: ST_TO_ADDR
14758: LD_INT 4
14760: PUSH
14761: LD_INT 5
14763: PUSH
14764: LD_INT 6
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: LIST
14771: PUSH
14772: LD_OWVAR 67
14776: ARRAY
14777: PUSH
14778: LD_VAR 0 1
14782: PUSH
14783: LD_INT 2
14785: DIV
14786: PLUS
14787: PUSH
14788: FOR_TO
14789: IFFALSE 14797
// Sold ;
14791: CALL 14959 0 0
14795: GO 14788
14797: POP
14798: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14799: LD_ADDR_VAR 0 3
14803: PUSH
14804: DOUBLE
14805: LD_INT 1
14807: DEC
14808: ST_TO_ADDR
14809: LD_INT 3
14811: PUSH
14812: LD_INT 4
14814: PUSH
14815: LD_INT 4
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: LIST
14822: PUSH
14823: LD_OWVAR 67
14827: ARRAY
14828: PUSH
14829: LD_VAR 0 1
14833: PUSH
14834: LD_INT 2
14836: DIV
14837: PLUS
14838: PUSH
14839: FOR_TO
14840: IFFALSE 14848
// Tank ;
14842: CALL 15089 0 0
14846: GO 14839
14848: POP
14849: POP
// end ; 10 :
14850: GO 14946
14852: LD_INT 10
14854: DOUBLE
14855: EQUAL
14856: IFTRUE 14860
14858: GO 14945
14860: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14861: LD_ADDR_VAR 0 3
14865: PUSH
14866: DOUBLE
14867: LD_INT 1
14869: DEC
14870: ST_TO_ADDR
14871: LD_INT 10
14873: PUSH
14874: LD_INT 12
14876: PUSH
14877: LD_INT 14
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: LIST
14884: PUSH
14885: LD_OWVAR 67
14889: ARRAY
14890: PUSH
14891: FOR_TO
14892: IFFALSE 14900
// Sold ;
14894: CALL 14959 0 0
14898: GO 14891
14900: POP
14901: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
14902: LD_ADDR_VAR 0 3
14906: PUSH
14907: DOUBLE
14908: LD_INT 1
14910: DEC
14911: ST_TO_ADDR
14912: LD_INT 11
14914: PUSH
14915: LD_INT 13
14917: PUSH
14918: LD_INT 15
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: LIST
14925: PUSH
14926: LD_OWVAR 67
14930: ARRAY
14931: PUSH
14932: FOR_TO
14933: IFFALSE 14941
// Tank ;
14935: CALL 15089 0 0
14939: GO 14932
14941: POP
14942: POP
// end ; end ;
14943: GO 14946
14945: POP
// ru_can_attack := true ;
14946: LD_ADDR_EXP 8
14950: PUSH
14951: LD_INT 1
14953: ST_TO_ADDR
// end ;
14954: LD_VAR 0 2
14958: RET
// function Sold ( ) ; var un , skill ; begin
14959: LD_INT 0
14961: PPUSH
14962: PPUSH
14963: PPUSH
// uc_side := 3 ;
14964: LD_ADDR_OWVAR 20
14968: PUSH
14969: LD_INT 3
14971: ST_TO_ADDR
// uc_nation := 3 ;
14972: LD_ADDR_OWVAR 21
14976: PUSH
14977: LD_INT 3
14979: ST_TO_ADDR
// InitHc ;
14980: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14984: LD_ADDR_VAR 0 3
14988: PUSH
14989: LD_INT 6
14991: PUSH
14992: LD_INT 7
14994: PUSH
14995: LD_INT 7
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: LIST
15002: PUSH
15003: LD_OWVAR 67
15007: ARRAY
15008: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15009: LD_INT 0
15011: PPUSH
15012: LD_INT 1
15014: PUSH
15015: LD_INT 9
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: PUSH
15022: LD_INT 1
15024: PPUSH
15025: LD_INT 2
15027: PPUSH
15028: CALL_OW 12
15032: ARRAY
15033: PPUSH
15034: LD_VAR 0 3
15038: PPUSH
15039: CALL_OW 380
// un := CreateHuman ;
15043: LD_ADDR_VAR 0 2
15047: PUSH
15048: CALL_OW 44
15052: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15053: LD_VAR 0 2
15057: PPUSH
15058: LD_INT 4
15060: PPUSH
15061: LD_INT 0
15063: PPUSH
15064: CALL_OW 49
// ru_force := ru_force ^ un ;
15068: LD_ADDR_EXP 35
15072: PUSH
15073: LD_EXP 35
15077: PUSH
15078: LD_VAR 0 2
15082: ADD
15083: ST_TO_ADDR
// end ;
15084: LD_VAR 0 1
15088: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15089: LD_INT 0
15091: PPUSH
15092: PPUSH
15093: PPUSH
15094: PPUSH
15095: PPUSH
// uc_side := 3 ;
15096: LD_ADDR_OWVAR 20
15100: PUSH
15101: LD_INT 3
15103: ST_TO_ADDR
// uc_nation := 3 ;
15104: LD_ADDR_OWVAR 21
15108: PUSH
15109: LD_INT 3
15111: ST_TO_ADDR
// InitHc ;
15112: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15116: LD_ADDR_VAR 0 5
15120: PUSH
15121: LD_INT 5
15123: PUSH
15124: LD_INT 6
15126: PUSH
15127: LD_INT 7
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: LIST
15134: PUSH
15135: LD_OWVAR 67
15139: ARRAY
15140: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15141: LD_ADDR_VAR 0 3
15145: PUSH
15146: LD_INT 22
15148: PUSH
15149: LD_INT 24
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: PUSH
15156: LD_INT 1
15158: PPUSH
15159: LD_INT 2
15161: PPUSH
15162: CALL_OW 12
15166: ARRAY
15167: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15168: LD_VAR 0 3
15172: PUSH
15173: LD_INT 22
15175: EQUAL
15176: IFFALSE 15211
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15178: LD_ADDR_VAR 0 4
15182: PUSH
15183: LD_INT 45
15185: PUSH
15186: LD_INT 43
15188: PUSH
15189: LD_INT 44
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: LIST
15196: PUSH
15197: LD_INT 1
15199: PPUSH
15200: LD_INT 3
15202: PPUSH
15203: CALL_OW 12
15207: ARRAY
15208: ST_TO_ADDR
15209: GO 15242
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 46
15218: PUSH
15219: LD_INT 44
15221: PUSH
15222: LD_INT 45
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: LIST
15229: PUSH
15230: LD_INT 1
15232: PPUSH
15233: LD_INT 3
15235: PPUSH
15236: CALL_OW 12
15240: ARRAY
15241: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 3
15249: PPUSH
15250: LD_INT 3
15252: PPUSH
15253: LD_VAR 0 3
15257: PPUSH
15258: LD_INT 1
15260: PPUSH
15261: LD_INT 3
15263: PUSH
15264: LD_INT 3
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: LD_INT 1
15272: PUSH
15273: EMPTY
15274: LIST
15275: LIST
15276: LIST
15277: LIST
15278: PUSH
15279: LD_INT 1
15281: PPUSH
15282: LD_INT 4
15284: PPUSH
15285: CALL_OW 12
15289: ARRAY
15290: PPUSH
15291: LD_VAR 0 4
15295: PPUSH
15296: LD_INT 99
15298: PPUSH
15299: CALL 264 0 7
15303: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15304: LD_VAR 0 2
15308: PPUSH
15309: CALL_OW 263
15313: PUSH
15314: LD_INT 1
15316: EQUAL
15317: IFFALSE 15348
// begin PrepareHuman ( false , 3 , skill ) ;
15319: LD_INT 0
15321: PPUSH
15322: LD_INT 3
15324: PPUSH
15325: LD_VAR 0 5
15329: PPUSH
15330: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15334: CALL_OW 44
15338: PPUSH
15339: LD_VAR 0 2
15343: PPUSH
15344: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15348: LD_VAR 0 2
15352: PPUSH
15353: LD_INT 3
15355: PPUSH
15356: LD_INT 0
15358: PPUSH
15359: CALL_OW 49
// ru_force := ru_force ^ un ;
15363: LD_ADDR_EXP 35
15367: PUSH
15368: LD_EXP 35
15372: PUSH
15373: LD_VAR 0 2
15377: ADD
15378: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15379: LD_VAR 0 2
15383: PPUSH
15384: LD_INT 126
15386: PPUSH
15387: LD_INT 158
15389: PPUSH
15390: CALL_OW 111
// Wait ( 0 0$3 ) ;
15394: LD_INT 105
15396: PPUSH
15397: CALL_OW 67
// ComStop ( un ) ;
15401: LD_VAR 0 2
15405: PPUSH
15406: CALL_OW 141
// end ;
15410: LD_VAR 0 1
15414: RET
// every 0 0$1 do var i , time , wave ;
15415: GO 15417
15417: DISABLE
15418: LD_INT 0
15420: PPUSH
15421: PPUSH
15422: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_INT 25200
15430: PUSH
15431: LD_INT 24150
15433: PUSH
15434: LD_INT 23100
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: LIST
15441: PUSH
15442: LD_OWVAR 67
15446: ARRAY
15447: ST_TO_ADDR
// wait ( time ) ;
15448: LD_VAR 0 2
15452: PPUSH
15453: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15457: LD_ADDR_VAR 0 2
15461: PUSH
15462: LD_INT 15750
15464: PUSH
15465: LD_INT 15050
15467: PUSH
15468: LD_INT 14350
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: LIST
15475: PUSH
15476: LD_OWVAR 67
15480: ARRAY
15481: ST_TO_ADDR
// wave := 0 ;
15482: LD_ADDR_VAR 0 3
15486: PUSH
15487: LD_INT 0
15489: ST_TO_ADDR
// while true do
15490: LD_INT 1
15492: IFFALSE 15589
// begin wave := wave + 1 ;
15494: LD_ADDR_VAR 0 3
15498: PUSH
15499: LD_VAR 0 3
15503: PUSH
15504: LD_INT 1
15506: PLUS
15507: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15508: LD_INT 22
15510: PUSH
15511: LD_INT 2
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PPUSH
15518: CALL_OW 69
15522: IFFALSE 15551
// repeat wait ( 0 0$1 ) ;
15524: LD_INT 35
15526: PPUSH
15527: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15531: LD_INT 22
15533: PUSH
15534: LD_INT 2
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PPUSH
15541: CALL_OW 69
15545: PUSH
15546: LD_INT 0
15548: EQUAL
15549: IFFALSE 15524
// if ru_force < 20 then
15551: LD_EXP 35
15555: PUSH
15556: LD_INT 20
15558: LESS
15559: IFFALSE 15570
// PrepareAttack ( wave ) ;
15561: LD_VAR 0 3
15565: PPUSH
15566: CALL 14414 0 1
// ru_can_attack := true ;
15570: LD_ADDR_EXP 8
15574: PUSH
15575: LD_INT 1
15577: ST_TO_ADDR
// wait ( time ) ;
15578: LD_VAR 0 2
15582: PPUSH
15583: CALL_OW 67
// end ;
15587: GO 15490
// end ;
15589: PPOPN 3
15591: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15592: LD_EXP 8
15596: PUSH
15597: LD_EXP 35
15601: AND
15602: IFFALSE 16436
15604: GO 15606
15606: DISABLE
15607: LD_INT 0
15609: PPUSH
15610: PPUSH
15611: PPUSH
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
15616: PPUSH
15617: PPUSH
// begin enable ;
15618: ENABLE
// points1 := [ 107 , 123 ] ;
15619: LD_ADDR_VAR 0 4
15623: PUSH
15624: LD_INT 107
15626: PUSH
15627: LD_INT 123
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15634: LD_ADDR_VAR 0 5
15638: PUSH
15639: LD_INT 55
15641: PUSH
15642: LD_INT 42
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15649: LD_ADDR_VAR 0 6
15653: PUSH
15654: LD_INT 102
15656: PUSH
15657: LD_INT 140
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 105
15666: PUSH
15667: LD_INT 142
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PUSH
15674: LD_INT 129
15676: PUSH
15677: LD_INT 131
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: LIST
15688: ST_TO_ADDR
// for i in ru_force do
15689: LD_ADDR_VAR 0 1
15693: PUSH
15694: LD_EXP 35
15698: PUSH
15699: FOR_IN
15700: IFFALSE 16434
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15702: LD_ADDR_VAR 0 3
15706: PUSH
15707: LD_INT 81
15709: PUSH
15710: LD_INT 3
15712: PUSH
15713: EMPTY
15714: LIST
15715: LIST
15716: PPUSH
15717: CALL_OW 69
15721: PPUSH
15722: LD_VAR 0 1
15726: PPUSH
15727: CALL_OW 74
15731: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15732: LD_VAR 0 1
15736: PPUSH
15737: LD_VAR 0 3
15741: PPUSH
15742: CALL_OW 296
15746: PUSH
15747: LD_INT 12
15749: LESS
15750: IFFALSE 15895
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15752: LD_VAR 0 1
15756: PPUSH
15757: CALL_OW 247
15761: PUSH
15762: LD_INT 1
15764: EQUAL
15765: PUSH
15766: LD_VAR 0 1
15770: PPUSH
15771: CALL_OW 257
15775: PUSH
15776: LD_INT 1
15778: EQUAL
15779: AND
15780: PUSH
15781: LD_VAR 0 3
15785: PUSH
15786: LD_INT 21
15788: PUSH
15789: LD_INT 2
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: LD_INT 58
15798: PUSH
15799: EMPTY
15800: LIST
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PPUSH
15806: CALL_OW 69
15810: IN
15811: AND
15812: IFFALSE 15830
// ComEnterUnit ( i , un ) else
15814: LD_VAR 0 1
15818: PPUSH
15819: LD_VAR 0 3
15823: PPUSH
15824: CALL_OW 120
15828: GO 15893
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15830: LD_VAR 0 3
15834: PUSH
15835: LD_INT 21
15837: PUSH
15838: LD_INT 2
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: PUSH
15845: LD_INT 58
15847: PUSH
15848: EMPTY
15849: LIST
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PPUSH
15855: CALL_OW 69
15859: IN
15860: NOT
15861: IFFALSE 15879
// ComAttackUnit ( i , un ) else
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_VAR 0 3
15872: PPUSH
15873: CALL_OW 115
15877: GO 15893
// ComAttackUnit ( i , JMM ) ;
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_EXP 18
15888: PPUSH
15889: CALL_OW 115
// end else
15893: GO 16432
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15895: LD_VAR 0 1
15899: PPUSH
15900: LD_VAR 0 4
15904: PUSH
15905: LD_INT 1
15907: ARRAY
15908: PPUSH
15909: LD_VAR 0 4
15913: PUSH
15914: LD_INT 2
15916: ARRAY
15917: PPUSH
15918: CALL_OW 297
15922: PUSH
15923: LD_VAR 0 1
15927: PPUSH
15928: LD_VAR 0 5
15932: PUSH
15933: LD_INT 1
15935: ARRAY
15936: PPUSH
15937: LD_VAR 0 5
15941: PUSH
15942: LD_INT 2
15944: ARRAY
15945: PPUSH
15946: CALL_OW 297
15950: GREATER
15951: PUSH
15952: LD_EXP 9
15956: AND
15957: PUSH
15958: LD_INT 9
15960: PPUSH
15961: LD_INT 81
15963: PUSH
15964: LD_INT 3
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PPUSH
15971: CALL_OW 70
15975: PUSH
15976: LD_INT 0
15978: EQUAL
15979: OR
15980: IFFALSE 16018
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 81
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PPUSH
15997: CALL_OW 69
16001: PPUSH
16002: LD_VAR 0 1
16006: PPUSH
16007: CALL_OW 74
16011: PPUSH
16012: CALL_OW 115
16016: GO 16432
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16018: LD_VAR 0 1
16022: PPUSH
16023: CALL_OW 264
16027: PUSH
16028: LD_INT 45
16030: EQUAL
16031: PUSH
16032: LD_EXP 35
16036: PPUSH
16037: LD_INT 3
16039: PUSH
16040: LD_INT 34
16042: PUSH
16043: LD_INT 45
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: PUSH
16050: EMPTY
16051: LIST
16052: LIST
16053: PPUSH
16054: CALL_OW 72
16058: PUSH
16059: LD_INT 6
16061: GREATER
16062: AND
16063: IFFALSE 16244
// begin dist := 9999 ;
16065: LD_ADDR_VAR 0 8
16069: PUSH
16070: LD_INT 9999
16072: ST_TO_ADDR
// xy := 0 ;
16073: LD_ADDR_VAR 0 9
16077: PUSH
16078: LD_INT 0
16080: ST_TO_ADDR
// for x in pointsr do
16081: LD_ADDR_VAR 0 7
16085: PUSH
16086: LD_VAR 0 6
16090: PUSH
16091: FOR_IN
16092: IFFALSE 16240
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16094: LD_VAR 0 1
16098: PPUSH
16099: LD_VAR 0 7
16103: PUSH
16104: LD_INT 1
16106: ARRAY
16107: PPUSH
16108: LD_VAR 0 7
16112: PUSH
16113: LD_INT 2
16115: ARRAY
16116: PPUSH
16117: CALL_OW 297
16121: PUSH
16122: LD_VAR 0 8
16126: LESS
16127: IFFALSE 16172
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16129: LD_ADDR_VAR 0 8
16133: PUSH
16134: LD_VAR 0 1
16138: PPUSH
16139: LD_VAR 0 7
16143: PUSH
16144: LD_INT 1
16146: ARRAY
16147: PPUSH
16148: LD_VAR 0 7
16152: PUSH
16153: LD_INT 2
16155: ARRAY
16156: PPUSH
16157: CALL_OW 297
16161: ST_TO_ADDR
// xy := x ;
16162: LD_ADDR_VAR 0 9
16166: PUSH
16167: LD_VAR 0 7
16171: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16172: LD_VAR 0 9
16176: PUSH
16177: LD_VAR 0 1
16181: PPUSH
16182: LD_VAR 0 9
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PPUSH
16191: LD_VAR 0 9
16195: PUSH
16196: LD_INT 2
16198: ARRAY
16199: PPUSH
16200: CALL_OW 297
16204: PUSH
16205: LD_INT 9
16207: GREATER
16208: AND
16209: IFFALSE 16238
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16211: LD_VAR 0 1
16215: PPUSH
16216: LD_VAR 0 9
16220: PUSH
16221: LD_INT 1
16223: ARRAY
16224: PPUSH
16225: LD_VAR 0 9
16229: PUSH
16230: LD_INT 2
16232: ARRAY
16233: PPUSH
16234: CALL_OW 114
// end ;
16238: GO 16091
16240: POP
16241: POP
// end else
16242: GO 16432
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16244: LD_ADDR_VAR 0 3
16248: PUSH
16249: LD_OWVAR 3
16253: PUSH
16254: LD_VAR 0 1
16258: DIFF
16259: PPUSH
16260: LD_VAR 0 1
16264: PPUSH
16265: CALL_OW 74
16269: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16270: LD_VAR 0 1
16274: PPUSH
16275: CALL_OW 320
16279: NOT
16280: PUSH
16281: LD_VAR 0 3
16285: PUSH
16286: LD_INT 21
16288: PUSH
16289: LD_INT 2
16291: PUSH
16292: EMPTY
16293: LIST
16294: LIST
16295: PUSH
16296: LD_INT 33
16298: PUSH
16299: LD_INT 1
16301: PUSH
16302: EMPTY
16303: LIST
16304: LIST
16305: PUSH
16306: LD_INT 58
16308: PUSH
16309: EMPTY
16310: LIST
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: LIST
16316: PPUSH
16317: CALL_OW 69
16321: IN
16322: PUSH
16323: LD_VAR 0 3
16327: PUSH
16328: LD_INT 22
16330: PUSH
16331: LD_INT 3
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PUSH
16338: LD_INT 21
16340: PUSH
16341: LD_INT 2
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: PUSH
16348: LD_INT 3
16350: PUSH
16351: LD_INT 24
16353: PUSH
16354: LD_INT 249
16356: PUSH
16357: EMPTY
16358: LIST
16359: LIST
16360: PUSH
16361: EMPTY
16362: LIST
16363: LIST
16364: PUSH
16365: EMPTY
16366: LIST
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: IN
16375: OR
16376: AND
16377: IFFALSE 16395
// ComAttackUnit ( i , un ) else
16379: LD_VAR 0 1
16383: PPUSH
16384: LD_VAR 0 3
16388: PPUSH
16389: CALL_OW 115
16393: GO 16432
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16395: LD_VAR 0 1
16399: PPUSH
16400: LD_INT 9
16402: PPUSH
16403: LD_INT 81
16405: PUSH
16406: LD_INT 3
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: PPUSH
16413: CALL_OW 70
16417: PPUSH
16418: LD_VAR 0 1
16422: PPUSH
16423: CALL_OW 74
16427: PPUSH
16428: CALL_OW 115
// end ; end ; end ; end ;
16432: GO 15699
16434: POP
16435: POP
// end ;
16436: PPOPN 9
16438: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16439: LD_INT 22
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: PUSH
16449: LD_INT 32
16451: PUSH
16452: LD_INT 1
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: PPUSH
16463: CALL_OW 69
16467: IFFALSE 16555
16469: GO 16471
16471: DISABLE
16472: LD_INT 0
16474: PPUSH
16475: PPUSH
// begin enable ;
16476: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16477: LD_ADDR_VAR 0 2
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 32
16494: PUSH
16495: LD_INT 1
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PPUSH
16506: CALL_OW 69
16510: ST_TO_ADDR
// for i in tmp do
16511: LD_ADDR_VAR 0 1
16515: PUSH
16516: LD_VAR 0 2
16520: PUSH
16521: FOR_IN
16522: IFFALSE 16553
// if GetFuel ( i ) < 12 then
16524: LD_VAR 0 1
16528: PPUSH
16529: CALL_OW 261
16533: PUSH
16534: LD_INT 12
16536: LESS
16537: IFFALSE 16551
// SetFuel ( i , 12 ) ;
16539: LD_VAR 0 1
16543: PPUSH
16544: LD_INT 12
16546: PPUSH
16547: CALL_OW 240
16551: GO 16521
16553: POP
16554: POP
// end ;
16555: PPOPN 2
16557: END
// every 0 0$1 trigger can_end do
16558: LD_EXP 17
16562: IFFALSE 16581
16564: GO 16566
16566: DISABLE
// begin Wait ( 1 1$35 ) ;
16567: LD_INT 3325
16569: PPUSH
16570: CALL_OW 67
// PrepareAttack ( 10 ) ;
16574: LD_INT 10
16576: PPUSH
16577: CALL 14414 0 1
// end ;
16581: END
