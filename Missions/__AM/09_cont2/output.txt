// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 169 0 0
// PrepareNature ;
  16: CALL 344 0 0
// PrepareRussian ;
  20: CALL 12105 0 0
// PrepareAmerican ;
  24: CALL 1077 0 0
// PrepareOvsyenko ;
  28: CALL 1721 0 0
// Action ;
  32: CALL 2525 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// end ;
 164: LD_VAR 0 1
 168: RET
// function DebugMode ; begin
 169: LD_INT 0
 171: PPUSH
// if not debug then
 172: LD_EXP 2
 176: NOT
 177: IFFALSE 181
// exit ;
 179: GO 188
// FogOff ( 1 ) ;
 181: LD_INT 1
 183: PPUSH
 184: CALL_OW 344
// end ; end_of_file
 188: LD_VAR 0 1
 192: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 193: LD_INT 0
 195: PPUSH
 196: PPUSH
// if exist_mode then
 197: LD_VAR 0 2
 201: IFFALSE 226
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 203: LD_ADDR_VAR 0 5
 207: PUSH
 208: LD_VAR 0 3
 212: PUSH
 213: LD_VAR 0 1
 217: STR
 218: PPUSH
 219: CALL_OW 34
 223: ST_TO_ADDR
 224: GO 241
// unit := NewCharacter ( ident ) ;
 226: LD_ADDR_VAR 0 5
 230: PUSH
 231: LD_VAR 0 1
 235: PPUSH
 236: CALL_OW 25
 240: ST_TO_ADDR
// result := unit ;
 241: LD_ADDR_VAR 0 4
 245: PUSH
 246: LD_VAR 0 5
 250: ST_TO_ADDR
// end ;
 251: LD_VAR 0 4
 255: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 256: LD_INT 0
 258: PPUSH
// uc_side := side ;
 259: LD_ADDR_OWVAR 20
 263: PUSH
 264: LD_VAR 0 1
 268: ST_TO_ADDR
// uc_nation := nation ;
 269: LD_ADDR_OWVAR 21
 273: PUSH
 274: LD_VAR 0 2
 278: ST_TO_ADDR
// vc_chassis := chassis ;
 279: LD_ADDR_OWVAR 37
 283: PUSH
 284: LD_VAR 0 3
 288: ST_TO_ADDR
// vc_engine := engine ;
 289: LD_ADDR_OWVAR 39
 293: PUSH
 294: LD_VAR 0 4
 298: ST_TO_ADDR
// vc_control := control ;
 299: LD_ADDR_OWVAR 38
 303: PUSH
 304: LD_VAR 0 5
 308: ST_TO_ADDR
// vc_weapon := weapon ;
 309: LD_ADDR_OWVAR 40
 313: PUSH
 314: LD_VAR 0 6
 318: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 319: LD_ADDR_OWVAR 41
 323: PUSH
 324: LD_VAR 0 7
 328: ST_TO_ADDR
// result := CreateVehicle ;
 329: LD_ADDR_VAR 0 8
 333: PUSH
 334: CALL_OW 45
 338: ST_TO_ADDR
// end ;
 339: LD_VAR 0 8
 343: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 344: LD_INT 0
 346: PPUSH
 347: PPUSH
 348: PPUSH
 349: PPUSH
// uc_side = 0 ;
 350: LD_ADDR_OWVAR 20
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// uc_nation = 0 ;
 358: LD_ADDR_OWVAR 21
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// nat_area := natureArea ;
 366: LD_ADDR_VAR 0 4
 370: PUSH
 371: LD_INT 1
 373: ST_TO_ADDR
// InitHc ;
 374: CALL_OW 19
// for i = 1 to 4 do
 378: LD_ADDR_VAR 0 2
 382: PUSH
 383: DOUBLE
 384: LD_INT 1
 386: DEC
 387: ST_TO_ADDR
 388: LD_INT 4
 390: PUSH
 391: FOR_TO
 392: IFFALSE 447
// begin hc_class = 18 ;
 394: LD_ADDR_OWVAR 28
 398: PUSH
 399: LD_INT 18
 401: ST_TO_ADDR
// hc_gallery =  ;
 402: LD_ADDR_OWVAR 33
 406: PUSH
 407: LD_STRING 
 409: ST_TO_ADDR
// hc_face_number = 1 ;
 410: LD_ADDR_OWVAR 34
 414: PUSH
 415: LD_INT 1
 417: ST_TO_ADDR
// animal := CreateHuman ;
 418: LD_ADDR_VAR 0 3
 422: PUSH
 423: CALL_OW 44
 427: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 428: LD_VAR 0 3
 432: PPUSH
 433: LD_VAR 0 4
 437: PPUSH
 438: LD_INT 0
 440: PPUSH
 441: CALL_OW 49
// end ;
 445: GO 391
 447: POP
 448: POP
// for i = 1 to 4 do
 449: LD_ADDR_VAR 0 2
 453: PUSH
 454: DOUBLE
 455: LD_INT 1
 457: DEC
 458: ST_TO_ADDR
 459: LD_INT 4
 461: PUSH
 462: FOR_TO
 463: IFFALSE 535
// begin hc_class = class_tiger ;
 465: LD_ADDR_OWVAR 28
 469: PUSH
 470: LD_INT 14
 472: ST_TO_ADDR
// hc_gallery =  ;
 473: LD_ADDR_OWVAR 33
 477: PUSH
 478: LD_STRING 
 480: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 481: LD_ADDR_OWVAR 35
 485: PUSH
 486: LD_INT 5
 488: NEG
 489: PPUSH
 490: LD_INT 5
 492: PPUSH
 493: CALL_OW 12
 497: ST_TO_ADDR
// hc_face_number = 3 ;
 498: LD_ADDR_OWVAR 34
 502: PUSH
 503: LD_INT 3
 505: ST_TO_ADDR
// animal := CreateHuman ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: CALL_OW 44
 515: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 516: LD_VAR 0 3
 520: PPUSH
 521: LD_VAR 0 4
 525: PPUSH
 526: LD_INT 0
 528: PPUSH
 529: CALL_OW 49
// end ;
 533: GO 462
 535: POP
 536: POP
// for i = 1 to 8 do
 537: LD_ADDR_VAR 0 2
 541: PUSH
 542: DOUBLE
 543: LD_INT 1
 545: DEC
 546: ST_TO_ADDR
 547: LD_INT 8
 549: PUSH
 550: FOR_TO
 551: IFFALSE 654
// begin hc_class = class_apeman ;
 553: LD_ADDR_OWVAR 28
 557: PUSH
 558: LD_INT 12
 560: ST_TO_ADDR
// hc_gallery =  ;
 561: LD_ADDR_OWVAR 33
 565: PUSH
 566: LD_STRING 
 568: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 569: LD_ADDR_OWVAR 35
 573: PUSH
 574: LD_INT 2
 576: NEG
 577: PPUSH
 578: LD_INT 2
 580: PPUSH
 581: CALL_OW 12
 585: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 586: LD_ADDR_OWVAR 31
 590: PUSH
 591: LD_INT 1
 593: PPUSH
 594: LD_INT 3
 596: PPUSH
 597: CALL_OW 12
 601: PUSH
 602: LD_INT 1
 604: PPUSH
 605: LD_INT 3
 607: PPUSH
 608: CALL_OW 12
 612: PUSH
 613: LD_INT 0
 615: PUSH
 616: LD_INT 0
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: ST_TO_ADDR
// animal := CreateHuman ;
 625: LD_ADDR_VAR 0 3
 629: PUSH
 630: CALL_OW 44
 634: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 635: LD_VAR 0 3
 639: PPUSH
 640: LD_VAR 0 4
 644: PPUSH
 645: LD_INT 0
 647: PPUSH
 648: CALL_OW 49
// end ;
 652: GO 550
 654: POP
 655: POP
// for i = 1 to 6 do
 656: LD_ADDR_VAR 0 2
 660: PUSH
 661: DOUBLE
 662: LD_INT 1
 664: DEC
 665: ST_TO_ADDR
 666: LD_INT 6
 668: PUSH
 669: FOR_TO
 670: IFFALSE 725
// begin hc_class = 13 ;
 672: LD_ADDR_OWVAR 28
 676: PUSH
 677: LD_INT 13
 679: ST_TO_ADDR
// hc_gallery =  ;
 680: LD_ADDR_OWVAR 33
 684: PUSH
 685: LD_STRING 
 687: ST_TO_ADDR
// hc_face_number = 4 ;
 688: LD_ADDR_OWVAR 34
 692: PUSH
 693: LD_INT 4
 695: ST_TO_ADDR
// animal := CreateHuman ;
 696: LD_ADDR_VAR 0 3
 700: PUSH
 701: CALL_OW 44
 705: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 706: LD_VAR 0 3
 710: PPUSH
 711: LD_VAR 0 4
 715: PPUSH
 716: LD_INT 0
 718: PPUSH
 719: CALL_OW 49
// end ;
 723: GO 669
 725: POP
 726: POP
// vc_chassis := 31 ;
 727: LD_ADDR_OWVAR 37
 731: PUSH
 732: LD_INT 31
 734: ST_TO_ADDR
// vc_control := control_rider ;
 735: LD_ADDR_OWVAR 38
 739: PUSH
 740: LD_INT 4
 742: ST_TO_ADDR
// animal := CreateVehicle ;
 743: LD_ADDR_VAR 0 3
 747: PUSH
 748: CALL_OW 45
 752: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 753: LD_VAR 0 3
 757: PPUSH
 758: LD_INT 21
 760: PPUSH
 761: LD_INT 22
 763: PPUSH
 764: LD_INT 0
 766: PPUSH
 767: CALL_OW 48
// end ;
 771: LD_VAR 0 1
 775: RET
// export function GetTerminalCargo ; begin
 776: LD_INT 0
 778: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 779: LD_ADDR_VAR 0 1
 783: PUSH
 784: LD_EXP 3
 788: PPUSH
 789: CALL_OW 274
 793: PPUSH
 794: LD_INT 3
 796: PPUSH
 797: CALL_OW 275
 801: ST_TO_ADDR
// end ;
 802: LD_VAR 0 1
 806: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 807: LD_INT 0
 809: PPUSH
 810: PPUSH
 811: PPUSH
// result := 0 ;
 812: LD_ADDR_VAR 0 2
 816: PUSH
 817: LD_INT 0
 819: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 820: LD_ADDR_VAR 0 4
 824: PUSH
 825: LD_INT 22
 827: PUSH
 828: LD_VAR 0 1
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: PUSH
 837: LD_INT 2
 839: PUSH
 840: LD_INT 30
 842: PUSH
 843: LD_INT 0
 845: PUSH
 846: EMPTY
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: EMPTY
 857: LIST
 858: LIST
 859: PUSH
 860: EMPTY
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: EMPTY
 866: LIST
 867: LIST
 868: PPUSH
 869: CALL_OW 69
 873: ST_TO_ADDR
// if not tmp then
 874: LD_VAR 0 4
 878: NOT
 879: IFFALSE 883
// exit ;
 881: GO 929
// for i in tmp do
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_VAR 0 4
 892: PUSH
 893: FOR_IN
 894: IFFALSE 927
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 896: LD_ADDR_VAR 0 2
 900: PUSH
 901: LD_VAR 0 2
 905: PUSH
 906: LD_VAR 0 3
 910: PPUSH
 911: CALL_OW 274
 915: PPUSH
 916: LD_INT 3
 918: PPUSH
 919: CALL_OW 275
 923: PLUS
 924: ST_TO_ADDR
 925: GO 893
 927: POP
 928: POP
// end ;
 929: LD_VAR 0 2
 933: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 934: LD_INT 0
 936: PPUSH
 937: PPUSH
// area = ListEnvironmentArea ( area ) ;
 938: LD_ADDR_VAR 0 2
 942: PUSH
 943: LD_VAR 0 2
 947: PPUSH
 948: CALL_OW 353
 952: ST_TO_ADDR
// if bulldozer > 0 then
 953: LD_VAR 0 1
 957: PUSH
 958: LD_INT 0
 960: GREATER
 961: IFFALSE 1072
// for i = area downto 1 do
 963: LD_ADDR_VAR 0 4
 967: PUSH
 968: DOUBLE
 969: LD_VAR 0 2
 973: INC
 974: ST_TO_ADDR
 975: LD_INT 1
 977: PUSH
 978: FOR_DOWNTO
 979: IFFALSE 1070
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 981: LD_VAR 0 2
 985: PUSH
 986: LD_VAR 0 4
 990: ARRAY
 991: PUSH
 992: LD_INT 1
 994: ARRAY
 995: PPUSH
 996: LD_VAR 0 2
1000: PUSH
1001: LD_VAR 0 4
1005: ARRAY
1006: PUSH
1007: LD_INT 2
1009: ARRAY
1010: PPUSH
1011: CALL_OW 351
1015: IFFALSE 1068
// if not HasTask ( bulldozer ) then
1017: LD_VAR 0 1
1021: PPUSH
1022: CALL_OW 314
1026: NOT
1027: IFFALSE 1068
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1029: LD_VAR 0 1
1033: PPUSH
1034: LD_VAR 0 2
1038: PUSH
1039: LD_VAR 0 4
1043: ARRAY
1044: PUSH
1045: LD_INT 1
1047: ARRAY
1048: PPUSH
1049: LD_VAR 0 2
1053: PUSH
1054: LD_VAR 0 4
1058: ARRAY
1059: PUSH
1060: LD_INT 2
1062: ARRAY
1063: PPUSH
1064: CALL_OW 171
1068: GO 978
1070: POP
1071: POP
// end ; end_of_file
1072: LD_VAR 0 3
1076: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1077: LD_INT 0
1079: PPUSH
1080: PPUSH
1081: PPUSH
1082: PPUSH
1083: PPUSH
// uc_side := 1 ;
1084: LD_ADDR_OWVAR 20
1088: PUSH
1089: LD_INT 1
1091: ST_TO_ADDR
// uc_nation := 1 ;
1092: LD_ADDR_OWVAR 21
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1100: LD_ADDR_EXP 17
1104: PUSH
1105: LD_STRING JMM
1107: PPUSH
1108: LD_EXP 2
1112: NOT
1113: PPUSH
1114: LD_STRING 08_
1116: PPUSH
1117: CALL 193 0 3
1121: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1122: LD_ADDR_VAR 0 4
1126: PUSH
1127: LD_INT 1
1129: PPUSH
1130: LD_INT 1
1132: PPUSH
1133: LD_INT 3
1135: PPUSH
1136: LD_INT 2
1138: PPUSH
1139: LD_INT 1
1141: PPUSH
1142: LD_INT 5
1144: PPUSH
1145: LD_INT 55
1147: PPUSH
1148: CALL 256 0 7
1152: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1153: LD_VAR 0 4
1157: PPUSH
1158: LD_INT 3
1160: PPUSH
1161: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1165: LD_VAR 0 4
1169: PPUSH
1170: LD_INT 43
1172: PPUSH
1173: LD_INT 3
1175: PPUSH
1176: LD_INT 0
1178: PPUSH
1179: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1183: LD_EXP 17
1187: PPUSH
1188: LD_VAR 0 4
1192: PPUSH
1193: CALL_OW 52
// tmp := [ ] ;
1197: LD_ADDR_VAR 0 2
1201: PUSH
1202: EMPTY
1203: ST_TO_ADDR
// uc_side := 4 ;
1204: LD_ADDR_OWVAR 20
1208: PUSH
1209: LD_INT 4
1211: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1212: LD_ADDR_OWVAR 33
1216: PUSH
1217: LD_STRING SecondCharsGal
1219: ST_TO_ADDR
// hc_class := 2 ;
1220: LD_ADDR_OWVAR 28
1224: PUSH
1225: LD_INT 2
1227: ST_TO_ADDR
// hc_sex := sex_female ;
1228: LD_ADDR_OWVAR 27
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1236: LD_ADDR_OWVAR 30
1240: PUSH
1241: LD_INT 0
1243: PUSH
1244: LD_INT 1
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 0
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1259: LD_ADDR_OWVAR 31
1263: PUSH
1264: LD_INT 3
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: LD_INT 2
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1282: LD_ADDR_OWVAR 29
1286: PUSH
1287: LD_INT 10
1289: PUSH
1290: LD_INT 11
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1297: LD_ADDR_OWVAR 26
1301: PUSH
1302: LD_STRING Naoma Goichman
1304: ST_TO_ADDR
// hc_face_number := 43 ;
1305: LD_ADDR_OWVAR 34
1309: PUSH
1310: LD_INT 43
1312: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1313: LD_ADDR_VAR 0 2
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: CALL_OW 44
1327: ADD
1328: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1329: LD_ADDR_OWVAR 30
1333: PUSH
1334: LD_INT 0
1336: PUSH
1337: LD_INT 2
1339: PUSH
1340: LD_INT 0
1342: PUSH
1343: LD_INT 1
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1352: LD_ADDR_OWVAR 31
1356: PUSH
1357: LD_INT 0
1359: PUSH
1360: LD_INT 5
1362: PUSH
1363: LD_INT 3
1365: PUSH
1366: LD_INT 1
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1375: LD_ADDR_OWVAR 29
1379: PUSH
1380: LD_INT 10
1382: PUSH
1383: LD_INT 10
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1390: LD_ADDR_OWVAR 26
1394: PUSH
1395: LD_STRING Magdalene Glance
1397: ST_TO_ADDR
// hc_face_number := 44 ;
1398: LD_ADDR_OWVAR 34
1402: PUSH
1403: LD_INT 44
1405: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1406: LD_ADDR_VAR 0 2
1410: PUSH
1411: LD_VAR 0 2
1415: PUSH
1416: CALL_OW 44
1420: ADD
1421: ST_TO_ADDR
// hc_sex := sex_male ;
1422: LD_ADDR_OWVAR 27
1426: PUSH
1427: LD_INT 1
1429: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1430: LD_ADDR_OWVAR 30
1434: PUSH
1435: LD_INT 2
1437: PUSH
1438: LD_INT 2
1440: PUSH
1441: LD_INT 0
1443: PUSH
1444: LD_INT 0
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1453: LD_ADDR_OWVAR 31
1457: PUSH
1458: LD_INT 3
1460: PUSH
1461: LD_INT 4
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 0
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1476: LD_ADDR_OWVAR 29
1480: PUSH
1481: LD_INT 12
1483: PUSH
1484: LD_INT 10
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// hc_name := Steve Holland ;
1491: LD_ADDR_OWVAR 26
1495: PUSH
1496: LD_STRING Steve Holland
1498: ST_TO_ADDR
// hc_face_number := 60 ;
1499: LD_ADDR_OWVAR 34
1503: PUSH
1504: LD_INT 60
1506: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1507: LD_ADDR_VAR 0 2
1511: PUSH
1512: LD_VAR 0 2
1516: PUSH
1517: CALL_OW 44
1521: ADD
1522: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1523: LD_ADDR_EXP 22
1527: PUSH
1528: LD_VAR 0 2
1532: PUSH
1533: LD_INT 0
1535: DIFF
1536: ST_TO_ADDR
// for un in alpha_engs do
1537: LD_ADDR_VAR 0 3
1541: PUSH
1542: LD_EXP 22
1546: PUSH
1547: FOR_IN
1548: IFFALSE 1573
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1550: LD_VAR 0 3
1554: PPUSH
1555: LD_INT 52
1557: PPUSH
1558: LD_INT 35
1560: PPUSH
1561: LD_INT 3
1563: PPUSH
1564: LD_INT 0
1566: PPUSH
1567: CALL_OW 50
1571: GO 1547
1573: POP
1574: POP
// for tmp = 1 to 4 do
1575: LD_ADDR_VAR 0 2
1579: PUSH
1580: DOUBLE
1581: LD_INT 1
1583: DEC
1584: ST_TO_ADDR
1585: LD_INT 4
1587: PUSH
1588: FOR_TO
1589: IFFALSE 1615
// CreateResourcesXYR ( mat_cans , 5 , 54 , 40 , 2 , false ) ;
1591: LD_INT 1
1593: PPUSH
1594: LD_INT 5
1596: PPUSH
1597: LD_INT 54
1599: PPUSH
1600: LD_INT 40
1602: PPUSH
1603: LD_INT 2
1605: PPUSH
1606: LD_INT 0
1608: PPUSH
1609: CALL_OW 60
1613: GO 1588
1615: POP
1616: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1617: LD_STRING gamma_commander
1619: PPUSH
1620: LD_INT 0
1622: PPUSH
1623: CALL_OW 30
1627: PUSH
1628: LD_INT 3
1630: LESS
1631: IFFALSE 1689
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1633: LD_ADDR_EXP 21
1637: PUSH
1638: LD_STRING VanHouten
1640: PPUSH
1641: LD_INT 0
1643: PPUSH
1644: LD_STRING 
1646: PPUSH
1647: CALL 193 0 3
1651: ST_TO_ADDR
// for i = 1 to 4 do
1652: LD_ADDR_VAR 0 5
1656: PUSH
1657: DOUBLE
1658: LD_INT 1
1660: DEC
1661: ST_TO_ADDR
1662: LD_INT 4
1664: PUSH
1665: FOR_TO
1666: IFFALSE 1687
// AddExperience ( Houten , i , 10000 ) ;
1668: LD_EXP 21
1672: PPUSH
1673: LD_VAR 0 5
1677: PPUSH
1678: LD_INT 10000
1680: PPUSH
1681: CALL_OW 492
1685: GO 1665
1687: POP
1688: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1689: LD_ADDR_EXP 24
1693: PUSH
1694: LD_STRING Powell
1696: PPUSH
1697: LD_INT 0
1699: PPUSH
1700: LD_STRING 
1702: PPUSH
1703: CALL 193 0 3
1707: ST_TO_ADDR
// InitHc ;
1708: CALL_OW 19
// InitUc ;
1712: CALL_OW 18
// end ;
1716: LD_VAR 0 1
1720: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1721: LD_INT 0
1723: PPUSH
1724: PPUSH
1725: PPUSH
1726: PPUSH
1727: PPUSH
// uc_side := 4 ;
1728: LD_ADDR_OWVAR 20
1732: PUSH
1733: LD_INT 4
1735: ST_TO_ADDR
// uc_nation := 3 ;
1736: LD_ADDR_OWVAR 21
1740: PUSH
1741: LD_INT 3
1743: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 ] , [ b_breastwork , 109 , 114 , 4 ] , [ b_breastwork , 115 , 132 , 5 ] , [ b_breastwork , 98 , 120 , 1 ] ] ) ;
1744: LD_ADDR_VAR 0 4
1748: PUSH
1749: LD_STRING 09_ovsyenko_base
1751: PPUSH
1752: LD_INT 0
1754: PUSH
1755: LD_INT 101
1757: PUSH
1758: LD_INT 118
1760: PUSH
1761: LD_INT 2
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: LIST
1768: LIST
1769: PUSH
1770: LD_INT 31
1772: PUSH
1773: LD_INT 109
1775: PUSH
1776: LD_INT 114
1778: PUSH
1779: LD_INT 4
1781: PUSH
1782: EMPTY
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 31
1790: PUSH
1791: LD_INT 115
1793: PUSH
1794: LD_INT 132
1796: PUSH
1797: LD_INT 5
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 31
1808: PUSH
1809: LD_INT 98
1811: PUSH
1812: LD_INT 120
1814: PUSH
1815: LD_INT 1
1817: PUSH
1818: EMPTY
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: PUSH
1824: EMPTY
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PPUSH
1830: CALL_OW 30
1834: ST_TO_ADDR
// for i in tmp do
1835: LD_ADDR_VAR 0 2
1839: PUSH
1840: LD_VAR 0 4
1844: PUSH
1845: FOR_IN
1846: IFFALSE 2002
// begin bc_type := i [ 1 ] ;
1848: LD_ADDR_OWVAR 42
1852: PUSH
1853: LD_VAR 0 2
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: ST_TO_ADDR
// bc_level := 3 ;
1862: LD_ADDR_OWVAR 43
1866: PUSH
1867: LD_INT 3
1869: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1870: LD_ADDR_VAR 0 3
1874: PUSH
1875: LD_VAR 0 2
1879: PUSH
1880: LD_INT 2
1882: ARRAY
1883: PPUSH
1884: LD_VAR 0 2
1888: PUSH
1889: LD_INT 3
1891: ARRAY
1892: PPUSH
1893: LD_VAR 0 2
1897: PUSH
1898: LD_INT 4
1900: ARRAY
1901: PPUSH
1902: CALL_OW 47
1906: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1907: LD_VAR 0 3
1911: PPUSH
1912: CALL_OW 266
1916: PUSH
1917: LD_INT 0
1919: EQUAL
1920: IFFALSE 1954
// begin SetBName ( b , ovsyenko ) ;
1922: LD_VAR 0 3
1926: PPUSH
1927: LD_STRING ovsyenko
1929: PPUSH
1930: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1934: LD_VAR 0 3
1938: PPUSH
1939: CALL_OW 274
1943: PPUSH
1944: LD_INT 1
1946: PPUSH
1947: LD_INT 50
1949: PPUSH
1950: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1954: LD_VAR 0 2
1958: PUSH
1959: LD_INT 5
1961: ARRAY
1962: PUSH
1963: LD_INT 250
1965: LESS
1966: IFFALSE 1982
// SetLives ( b , 333 ) else
1968: LD_VAR 0 3
1972: PPUSH
1973: LD_INT 333
1975: PPUSH
1976: CALL_OW 234
1980: GO 2000
// SetLives ( b , i [ 5 ] ) ;
1982: LD_VAR 0 3
1986: PPUSH
1987: LD_VAR 0 2
1991: PUSH
1992: LD_INT 5
1994: ARRAY
1995: PPUSH
1996: CALL_OW 234
// end ;
2000: GO 1845
2002: POP
2003: POP
// uc_nation := 1 ;
2004: LD_ADDR_OWVAR 21
2008: PUSH
2009: LD_INT 1
2011: ST_TO_ADDR
// tmp := [ ] ;
2012: LD_ADDR_VAR 0 4
2016: PUSH
2017: EMPTY
2018: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2019: LD_ADDR_EXP 18
2023: PUSH
2024: LD_STRING Gary
2026: PPUSH
2027: LD_EXP 2
2031: NOT
2032: PPUSH
2033: LD_STRING 
2035: PPUSH
2036: CALL 193 0 3
2040: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2041: LD_ADDR_VAR 0 4
2045: PUSH
2046: LD_VAR 0 4
2050: PUSH
2051: LD_EXP 18
2055: ADD
2056: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2057: LD_ADDR_EXP 19
2061: PUSH
2062: LD_STRING Bobby
2064: PPUSH
2065: LD_EXP 2
2069: NOT
2070: PPUSH
2071: LD_STRING 03_
2073: PPUSH
2074: CALL 193 0 3
2078: ST_TO_ADDR
// if Bobby then
2079: LD_EXP 19
2083: IFFALSE 2101
// tmp := tmp ^ Bobby ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_VAR 0 4
2094: PUSH
2095: LD_EXP 19
2099: ADD
2100: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2101: LD_ADDR_EXP 20
2105: PUSH
2106: LD_STRING Cyrus
2108: PPUSH
2109: LD_EXP 2
2113: NOT
2114: PPUSH
2115: LD_STRING 03_
2117: PPUSH
2118: CALL 193 0 3
2122: ST_TO_ADDR
// if Cyrus then
2123: LD_EXP 20
2127: IFFALSE 2145
// tmp := tmp ^ Cyrus ;
2129: LD_ADDR_VAR 0 4
2133: PUSH
2134: LD_VAR 0 4
2138: PUSH
2139: LD_EXP 20
2143: ADD
2144: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2145: LD_ADDR_VAR 0 4
2149: PUSH
2150: LD_VAR 0 4
2154: PUSH
2155: LD_STRING 09_prev_squad
2157: PPUSH
2158: CALL_OW 31
2162: ADD
2163: ST_TO_ADDR
// tmp := tmp diff 0 ;
2164: LD_ADDR_VAR 0 4
2168: PUSH
2169: LD_VAR 0 4
2173: PUSH
2174: LD_INT 0
2176: DIFF
2177: ST_TO_ADDR
// for i in tmp do
2178: LD_ADDR_VAR 0 2
2182: PUSH
2183: LD_VAR 0 4
2187: PUSH
2188: FOR_IN
2189: IFFALSE 2248
// begin if GetClass ( i ) in [ 2 , 3 ] then
2191: LD_VAR 0 2
2195: PPUSH
2196: CALL_OW 257
2200: PUSH
2201: LD_INT 2
2203: PUSH
2204: LD_INT 3
2206: PUSH
2207: EMPTY
2208: LIST
2209: LIST
2210: IN
2211: IFFALSE 2225
// SetClass ( i , 1 ) ;
2213: LD_VAR 0 2
2217: PPUSH
2218: LD_INT 1
2220: PPUSH
2221: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2225: LD_VAR 0 2
2229: PPUSH
2230: LD_INT 106
2232: PPUSH
2233: LD_INT 122
2235: PPUSH
2236: LD_INT 5
2238: PPUSH
2239: LD_INT 0
2241: PPUSH
2242: CALL_OW 50
// end ;
2246: GO 2188
2248: POP
2249: POP
// tmp := tmp diff Gary ;
2250: LD_ADDR_VAR 0 4
2254: PUSH
2255: LD_VAR 0 4
2259: PUSH
2260: LD_EXP 18
2264: DIFF
2265: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2266: LD_ADDR_VAR 0 3
2270: PUSH
2271: LD_INT 22
2273: PUSH
2274: LD_INT 4
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: PUSH
2281: LD_INT 30
2283: PUSH
2284: LD_INT 31
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: PUSH
2291: EMPTY
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL_OW 69
2299: ST_TO_ADDR
// for i = 1 to b do
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: DOUBLE
2306: LD_INT 1
2308: DEC
2309: ST_TO_ADDR
2310: LD_VAR 0 3
2314: PUSH
2315: FOR_TO
2316: IFFALSE 2346
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2318: LD_VAR 0 4
2322: PUSH
2323: LD_VAR 0 2
2327: ARRAY
2328: PPUSH
2329: LD_VAR 0 3
2333: PUSH
2334: LD_VAR 0 2
2338: ARRAY
2339: PPUSH
2340: CALL_OW 120
// end ;
2344: GO 2315
2346: POP
2347: POP
// InitHc ;
2348: CALL_OW 19
// InitUc ;
2352: CALL_OW 18
// end ;
2356: LD_VAR 0 1
2360: RET
// export function PowellTransport ; var i , un ; begin
2361: LD_INT 0
2363: PPUSH
2364: PPUSH
2365: PPUSH
// uc_side := 4 ;
2366: LD_ADDR_OWVAR 20
2370: PUSH
2371: LD_INT 4
2373: ST_TO_ADDR
// uc_nation := 1 ;
2374: LD_ADDR_OWVAR 21
2378: PUSH
2379: LD_INT 1
2381: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2382: LD_INT 1
2384: PPUSH
2385: LD_INT 3
2387: PPUSH
2388: LD_INT 6
2390: PPUSH
2391: CALL_OW 380
// hc_name :=  ;
2395: LD_ADDR_OWVAR 26
2399: PUSH
2400: LD_STRING 
2402: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2403: LD_ADDR_OWVAR 33
2407: PUSH
2408: LD_STRING SecondCharsGal
2410: ST_TO_ADDR
// hc_face_number := 30 ;
2411: LD_ADDR_OWVAR 34
2415: PUSH
2416: LD_INT 30
2418: ST_TO_ADDR
// powell_trans := CreateHuman ;
2419: LD_ADDR_EXP 23
2423: PUSH
2424: CALL_OW 44
2428: ST_TO_ADDR
// hc_face_number := 31 ;
2429: LD_ADDR_OWVAR 34
2433: PUSH
2434: LD_INT 31
2436: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2437: LD_ADDR_EXP 23
2441: PUSH
2442: LD_EXP 23
2446: PUSH
2447: CALL_OW 44
2451: ADD
2452: ST_TO_ADDR
// for i = 1 to 2 do
2453: LD_ADDR_VAR 0 2
2457: PUSH
2458: DOUBLE
2459: LD_INT 1
2461: DEC
2462: ST_TO_ADDR
2463: LD_INT 2
2465: PUSH
2466: FOR_TO
2467: IFFALSE 2518
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2469: LD_ADDR_VAR 0 3
2473: PUSH
2474: LD_INT 4
2476: PPUSH
2477: LD_INT 1
2479: PPUSH
2480: LD_INT 3
2482: PPUSH
2483: LD_INT 1
2485: PPUSH
2486: LD_INT 1
2488: PPUSH
2489: LD_INT 12
2491: PPUSH
2492: LD_INT 66
2494: PPUSH
2495: CALL 256 0 7
2499: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2500: LD_ADDR_EXP 23
2504: PUSH
2505: LD_EXP 23
2509: PUSH
2510: LD_VAR 0 3
2514: ADD
2515: ST_TO_ADDR
// end ;
2516: GO 2466
2518: POP
2519: POP
// end ; end_of_file
2520: LD_VAR 0 1
2524: RET
// export function Action ; var i , veh ; begin
2525: LD_INT 0
2527: PPUSH
2528: PPUSH
2529: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2530: LD_EXP 22
2534: PPUSH
2535: LD_INT 0
2537: PPUSH
2538: LD_INT 50
2540: PPUSH
2541: LD_INT 38
2543: PPUSH
2544: LD_INT 2
2546: PPUSH
2547: CALL_OW 145
// InGameOn ;
2551: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2555: LD_INT 43
2557: PPUSH
2558: LD_INT 9
2560: PPUSH
2561: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2565: LD_EXP 17
2569: PPUSH
2570: LD_INT 54
2572: PPUSH
2573: LD_INT 34
2575: PPUSH
2576: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2580: LD_EXP 17
2584: PPUSH
2585: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2589: LD_EXP 17
2593: PPUSH
2594: LD_EXP 22
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2607: LD_INT 35
2609: PPUSH
2610: CALL_OW 67
// until See ( 4 , JMM ) ;
2614: LD_INT 4
2616: PPUSH
2617: LD_EXP 17
2621: PPUSH
2622: CALL_OW 292
2626: IFFALSE 2607
// CenterNowOnUnits ( JMM ) ;
2628: LD_EXP 17
2632: PPUSH
2633: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2637: LD_EXP 17
2641: PPUSH
2642: LD_STRING D2-JMM-1
2644: PPUSH
2645: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2649: LD_EXP 22
2653: PUSH
2654: LD_INT 3
2656: ARRAY
2657: PPUSH
2658: LD_EXP 17
2662: PPUSH
2663: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2667: LD_EXP 22
2671: PUSH
2672: LD_INT 3
2674: ARRAY
2675: PPUSH
2676: LD_STRING D2-Eng1-1
2678: PPUSH
2679: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2683: LD_EXP 17
2687: PPUSH
2688: LD_STRING D2-JMM-2
2690: PPUSH
2691: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2695: LD_EXP 22
2699: PUSH
2700: LD_INT 3
2702: ARRAY
2703: PPUSH
2704: LD_STRING D2-Eng1-2
2706: PPUSH
2707: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2711: LD_EXP 17
2715: PPUSH
2716: LD_STRING D2-JMM-3
2718: PPUSH
2719: CALL_OW 88
// if Houten then
2723: LD_EXP 21
2727: IFFALSE 2925
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2729: LD_ADDR_VAR 0 3
2733: PUSH
2734: LD_INT 4
2736: PPUSH
2737: LD_INT 1
2739: PPUSH
2740: LD_INT 3
2742: PPUSH
2743: LD_INT 2
2745: PPUSH
2746: LD_INT 1
2748: PPUSH
2749: LD_INT 4
2751: PPUSH
2752: LD_INT 55
2754: PPUSH
2755: CALL 256 0 7
2759: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 3
2767: PPUSH
2768: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2772: LD_VAR 0 3
2776: PPUSH
2777: LD_INT 46
2779: PPUSH
2780: LD_INT 19
2782: PPUSH
2783: LD_INT 0
2785: PPUSH
2786: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2790: LD_EXP 21
2794: PPUSH
2795: LD_VAR 0 3
2799: PPUSH
2800: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2804: LD_EXP 21
2808: PPUSH
2809: LD_INT 49
2811: PPUSH
2812: LD_INT 33
2814: PPUSH
2815: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2819: LD_EXP 21
2823: PPUSH
2824: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2828: LD_EXP 21
2832: PPUSH
2833: LD_EXP 17
2837: PPUSH
2838: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2842: LD_INT 35
2844: PPUSH
2845: CALL_OW 67
// until See ( 1 , Houten ) ;
2849: LD_INT 1
2851: PPUSH
2852: LD_EXP 21
2856: PPUSH
2857: CALL_OW 292
2861: IFFALSE 2842
// ComTurnUnit ( JMM , Houten ) ;
2863: LD_EXP 17
2867: PPUSH
2868: LD_EXP 21
2872: PPUSH
2873: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2877: LD_EXP 17
2881: PPUSH
2882: LD_STRING D1d-JMM-1
2884: PPUSH
2885: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2889: LD_EXP 21
2893: PPUSH
2894: LD_STRING D1-VanH-1
2896: PPUSH
2897: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2901: LD_EXP 17
2905: PPUSH
2906: LD_STRING D1-JMM-1v
2908: PPUSH
2909: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2913: LD_EXP 17
2917: PPUSH
2918: LD_STRING D1-JMM-2v
2920: PPUSH
2921: CALL_OW 88
// end ; InGameOff ;
2925: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2929: LD_STRING M1
2931: PPUSH
2932: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2936: LD_INT 22
2938: PUSH
2939: LD_INT 4
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: PUSH
2946: LD_INT 92
2948: PUSH
2949: LD_EXP 17
2953: PPUSH
2954: CALL_OW 250
2958: PUSH
2959: LD_EXP 17
2963: PPUSH
2964: CALL_OW 251
2968: PUSH
2969: LD_INT 15
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: LIST
2976: LIST
2977: PUSH
2978: EMPTY
2979: LIST
2980: LIST
2981: PPUSH
2982: CALL_OW 69
2986: PPUSH
2987: LD_INT 1
2989: PPUSH
2990: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
2994: LD_EXP 22
2998: PUSH
2999: LD_EXP 17
3003: ADD
3004: PUSH
3005: LD_EXP 21
3009: ADD
3010: PPUSH
3011: CALL_OW 141
// end ;
3015: LD_VAR 0 1
3019: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3020: LD_INT 1
3022: PPUSH
3023: LD_EXP 18
3027: PPUSH
3028: CALL_OW 292
3032: PUSH
3033: LD_EXP 17
3037: PPUSH
3038: LD_EXP 18
3042: PPUSH
3043: CALL_OW 296
3047: PUSH
3048: LD_INT 6
3050: LESS
3051: AND
3052: IFFALSE 3815
3054: GO 3056
3056: DISABLE
3057: LD_INT 0
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
// begin InGameOn ;
3064: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3068: LD_INT 22
3070: PUSH
3071: LD_INT 4
3073: PUSH
3074: EMPTY
3075: LIST
3076: LIST
3077: PPUSH
3078: CALL_OW 69
3082: PPUSH
3083: LD_INT 1
3085: PPUSH
3086: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3090: LD_ADDR_VAR 0 4
3094: PUSH
3095: LD_INT 22
3097: PUSH
3098: LD_INT 1
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PUSH
3105: LD_INT 2
3107: PUSH
3108: LD_INT 25
3110: PUSH
3111: LD_INT 1
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PUSH
3118: LD_INT 25
3120: PUSH
3121: LD_INT 2
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: PUSH
3128: LD_INT 25
3130: PUSH
3131: LD_INT 3
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: PUSH
3138: LD_INT 25
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PPUSH
3159: CALL_OW 69
3163: ST_TO_ADDR
// ComHold ( tmp ) ;
3164: LD_VAR 0 4
3168: PPUSH
3169: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3173: LD_EXP 17
3177: PPUSH
3178: LD_STRING D2-JMM-3a
3180: PPUSH
3181: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3185: LD_EXP 18
3189: PPUSH
3190: LD_EXP 17
3194: PPUSH
3195: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3199: LD_EXP 18
3203: PPUSH
3204: LD_STRING D2-Gary-3
3206: PPUSH
3207: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3211: LD_EXP 17
3215: PPUSH
3216: LD_EXP 18
3220: PPUSH
3221: CALL_OW 119
// for i in tmp do
3225: LD_ADDR_VAR 0 5
3229: PUSH
3230: LD_VAR 0 4
3234: PUSH
3235: FOR_IN
3236: IFFALSE 3281
// begin if IsInUnit ( i ) then
3238: LD_VAR 0 5
3242: PPUSH
3243: CALL_OW 310
3247: IFFALSE 3258
// ComExitBuilding ( i ) ;
3249: LD_VAR 0 5
3253: PPUSH
3254: CALL_OW 122
// wait ( 1 ) ;
3258: LD_INT 1
3260: PPUSH
3261: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3265: LD_VAR 0 5
3269: PPUSH
3270: LD_EXP 17
3274: PPUSH
3275: CALL_OW 119
// end ;
3279: GO 3235
3281: POP
3282: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3283: LD_ADDR_VAR 0 4
3287: PUSH
3288: LD_VAR 0 4
3292: PUSH
3293: LD_EXP 17
3297: PUSH
3298: LD_EXP 21
3302: PUSH
3303: LD_EXP 18
3307: PUSH
3308: LD_EXP 20
3312: PUSH
3313: LD_EXP 19
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_EXP 22
3329: ADD
3330: DIFF
3331: ST_TO_ADDR
// if Bobby then
3332: LD_EXP 19
3336: IFFALSE 3350
// Say ( Bobby , D2-Bobby-3 ) ;
3338: LD_EXP 19
3342: PPUSH
3343: LD_STRING D2-Bobby-3
3345: PPUSH
3346: CALL_OW 88
// if Cyrus then
3350: LD_EXP 20
3354: IFFALSE 3368
// Say ( Cyrus , D2-Cyrus-3 ) ;
3356: LD_EXP 20
3360: PPUSH
3361: LD_STRING D2-Cyrus-3
3363: PPUSH
3364: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3368: LD_EXP 17
3372: PPUSH
3373: LD_STRING D2-JMM-4
3375: PPUSH
3376: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3380: LD_EXP 18
3384: PPUSH
3385: LD_STRING D2-Gary-4
3387: PPUSH
3388: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3392: LD_ADDR_VAR 0 1
3396: PUSH
3397: LD_VAR 0 4
3401: PPUSH
3402: LD_INT 26
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PPUSH
3412: CALL_OW 72
3416: PUSH
3417: LD_INT 1
3419: ARRAY
3420: ST_TO_ADDR
// if Cyrus then
3421: LD_EXP 20
3425: IFFALSE 3441
// Say ( Cyrus , D2-Cyrus-4 ) else
3427: LD_EXP 20
3431: PPUSH
3432: LD_STRING D2-Cyrus-4
3434: PPUSH
3435: CALL_OW 88
3439: GO 3453
// Say ( un1 , D2-Sol1-4 ) ;
3441: LD_VAR 0 1
3445: PPUSH
3446: LD_STRING D2-Sol1-4
3448: PPUSH
3449: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3453: LD_EXP 17
3457: PPUSH
3458: LD_STRING D2-JMM-5
3460: PPUSH
3461: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3465: LD_ADDR_VAR 0 2
3469: PUSH
3470: LD_EXP 22
3474: PPUSH
3475: LD_INT 91
3477: PUSH
3478: LD_EXP 17
3482: PUSH
3483: LD_INT 10
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: PUSH
3491: LD_INT 26
3493: PUSH
3494: LD_INT 2
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: PUSH
3501: EMPTY
3502: LIST
3503: LIST
3504: PPUSH
3505: CALL_OW 72
3509: ST_TO_ADDR
// if un2 then
3510: LD_VAR 0 2
3514: IFFALSE 3568
// begin un2 := un2 [ un2 ] ;
3516: LD_ADDR_VAR 0 2
3520: PUSH
3521: LD_VAR 0 2
3525: PUSH
3526: LD_VAR 0 2
3530: ARRAY
3531: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3532: LD_VAR 0 2
3536: PPUSH
3537: LD_STRING D2-FEng1-5
3539: PPUSH
3540: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3544: LD_EXP 17
3548: PPUSH
3549: LD_STRING D2-JMM-6
3551: PPUSH
3552: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3556: LD_VAR 0 2
3560: PPUSH
3561: LD_STRING D2-FEng1-6
3563: PPUSH
3564: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3568: LD_ADDR_VAR 0 3
3572: PUSH
3573: LD_EXP 22
3577: PPUSH
3578: LD_INT 91
3580: PUSH
3581: LD_EXP 17
3585: PUSH
3586: LD_INT 10
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: PUSH
3594: LD_INT 26
3596: PUSH
3597: LD_INT 1
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: PPUSH
3608: CALL_OW 72
3612: ST_TO_ADDR
// if un3 then
3613: LD_VAR 0 3
3617: IFFALSE 3672
// begin un3 := un3 [ 1 ] ;
3619: LD_ADDR_VAR 0 3
3623: PUSH
3624: LD_VAR 0 3
3628: PUSH
3629: LD_INT 1
3631: ARRAY
3632: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3633: LD_VAR 0 3
3637: PPUSH
3638: LD_INT 114
3640: PPUSH
3641: LD_INT 122
3643: PPUSH
3644: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_STRING D2-Eng1-6
3655: PPUSH
3656: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3660: LD_EXP 17
3664: PPUSH
3665: LD_STRING D2-JMM-7
3667: PPUSH
3668: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3672: LD_EXP 18
3676: PPUSH
3677: LD_STRING D2-Gary-7
3679: PPUSH
3680: CALL_OW 88
// if un2 then
3684: LD_VAR 0 2
3688: IFFALSE 3702
// Say ( un2 , D2-FEng1-7 ) ;
3690: LD_VAR 0 2
3694: PPUSH
3695: LD_STRING D2-FEng1-7
3697: PPUSH
3698: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3702: LD_VAR 0 1
3706: PPUSH
3707: LD_STRING D2-Sol1-7
3709: PPUSH
3710: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3714: LD_EXP 17
3718: PPUSH
3719: LD_STRING D2-JMM-8
3721: PPUSH
3722: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3726: LD_INT 22
3728: PUSH
3729: LD_INT 1
3731: PUSH
3732: EMPTY
3733: LIST
3734: LIST
3735: PPUSH
3736: CALL_OW 69
3740: PPUSH
3741: CALL_OW 141
// InGameOff ;
3745: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3749: LD_STRING M1a
3751: PPUSH
3752: CALL_OW 337
// jmm_in_ovsyenko := true ;
3756: LD_ADDR_EXP 4
3760: PUSH
3761: LD_INT 1
3763: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3764: LD_INT 1050
3766: PPUSH
3767: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3771: LD_ADDR_VAR 0 4
3775: PUSH
3776: LD_INT 25
3778: PUSH
3779: LD_INT 14
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: ST_TO_ADDR
// if not tmp then
3791: LD_VAR 0 4
3795: NOT
3796: IFFALSE 3800
// exit ;
3798: GO 3815
// ComMoveXY ( tmp , 75 , 75 ) ;
3800: LD_VAR 0 4
3804: PPUSH
3805: LD_INT 75
3807: PPUSH
3808: LD_INT 75
3810: PPUSH
3811: CALL_OW 111
// end ;
3815: PPOPN 5
3817: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3818: LD_INT 22
3820: PUSH
3821: LD_INT 1
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PUSH
3828: LD_INT 30
3830: PUSH
3831: LD_INT 30
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PUSH
3838: LD_INT 3
3840: PUSH
3841: LD_INT 57
3843: PUSH
3844: EMPTY
3845: LIST
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: LIST
3855: PPUSH
3856: CALL_OW 69
3860: IFFALSE 3902
3862: GO 3864
3864: DISABLE
3865: LD_INT 0
3867: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3868: LD_ADDR_VAR 0 1
3872: PUSH
3873: LD_STRING M2easy
3875: PUSH
3876: LD_STRING M2
3878: PUSH
3879: LD_STRING M2hard
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: LIST
3886: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3887: LD_VAR 0 1
3891: PUSH
3892: LD_OWVAR 67
3896: ARRAY
3897: PPUSH
3898: CALL_OW 337
// end ;
3902: PPOPN 1
3904: END
// every 3 3$00 do
3905: GO 3907
3907: DISABLE
// begin DialogueOn ;
3908: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3912: LD_EXP 24
3916: PPUSH
3917: LD_STRING D3-Pow-1
3919: PPUSH
3920: CALL_OW 94
// if jmm_in_ovsyenko then
3924: LD_EXP 4
3928: IFFALSE 3956
// begin Say ( JMM , D3-JMM-1 ) ;
3930: LD_EXP 17
3934: PPUSH
3935: LD_STRING D3-JMM-1
3937: PPUSH
3938: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
3942: LD_EXP 17
3946: PPUSH
3947: LD_STRING D3-JMM-1b
3949: PPUSH
3950: CALL_OW 88
// end else
3954: GO 3968
// Say ( JMM , D3-JMM-1a ) ;
3956: LD_EXP 17
3960: PPUSH
3961: LD_STRING D3-JMM-1a
3963: PPUSH
3964: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
3968: LD_EXP 24
3972: PPUSH
3973: LD_STRING D3-Pow-2
3975: PPUSH
3976: CALL_OW 94
// DialogueOff ;
3980: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
3984: LD_STRING M3
3986: PPUSH
3987: CALL_OW 337
// powell_want_sib := true ;
3991: LD_ADDR_EXP 5
3995: PUSH
3996: LD_INT 1
3998: ST_TO_ADDR
// end ;
3999: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo ;
4000: LD_EXP 6
4004: PUSH
4005: LD_INT 0
4007: EQUAL
4008: IFFALSE 5283
4010: GO 4012
4012: DISABLE
4013: LD_INT 0
4015: PPUSH
4016: PPUSH
4017: PPUSH
4018: PPUSH
4019: PPUSH
4020: PPUSH
4021: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4022: LD_INT 4
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: CALL_OW 343
// PowellTransport ;
4032: CALL 2361 0 0
// for i = 1 to 3 do
4036: LD_ADDR_VAR 0 4
4040: PUSH
4041: DOUBLE
4042: LD_INT 1
4044: DEC
4045: ST_TO_ADDR
4046: LD_INT 3
4048: PUSH
4049: FOR_TO
4050: IFFALSE 4117
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4052: LD_ADDR_VAR 0 1
4056: PUSH
4057: LD_INT 6
4059: PPUSH
4060: LD_VAR 0 4
4064: PPUSH
4065: CALL_OW 287
4069: ST_TO_ADDR
// if not tmp then
4070: LD_VAR 0 1
4074: NOT
4075: IFFALSE 4079
// continue ;
4077: GO 4049
// EraseResourceArea ( terminalArea , i ) ;
4079: LD_INT 6
4081: PPUSH
4082: LD_VAR 0 4
4086: PPUSH
4087: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4091: LD_EXP 3
4095: PPUSH
4096: CALL_OW 274
4100: PPUSH
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_VAR 0 1
4110: PPUSH
4111: CALL_OW 276
// end ;
4115: GO 4049
4117: POP
4118: POP
// x := 43 ;
4119: LD_ADDR_VAR 0 2
4123: PUSH
4124: LD_INT 43
4126: ST_TO_ADDR
// y := 3 ;
4127: LD_ADDR_VAR 0 3
4131: PUSH
4132: LD_INT 3
4134: ST_TO_ADDR
// for i = 3 to 4 do
4135: LD_ADDR_VAR 0 4
4139: PUSH
4140: DOUBLE
4141: LD_INT 3
4143: DEC
4144: ST_TO_ADDR
4145: LD_INT 4
4147: PUSH
4148: FOR_TO
4149: IFFALSE 4359
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4151: LD_EXP 23
4155: PUSH
4156: LD_VAR 0 4
4160: ARRAY
4161: PPUSH
4162: LD_INT 4
4164: PPUSH
4165: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4169: LD_EXP 23
4173: PUSH
4174: LD_VAR 0 4
4178: ARRAY
4179: PPUSH
4180: LD_VAR 0 2
4184: PPUSH
4185: LD_VAR 0 3
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4197: LD_EXP 23
4201: PUSH
4202: LD_VAR 0 4
4206: PUSH
4207: LD_INT 2
4209: MINUS
4210: ARRAY
4211: PPUSH
4212: LD_EXP 23
4216: PUSH
4217: LD_VAR 0 4
4221: ARRAY
4222: PPUSH
4223: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4227: LD_EXP 23
4231: PUSH
4232: LD_VAR 0 4
4236: ARRAY
4237: PPUSH
4238: LD_INT 1
4240: PPUSH
4241: LD_INT 100
4243: PPUSH
4244: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4248: LD_EXP 23
4252: PUSH
4253: LD_VAR 0 4
4257: PUSH
4258: LD_INT 2
4260: MINUS
4261: ARRAY
4262: PPUSH
4263: LD_INT 54
4265: PPUSH
4266: LD_INT 42
4268: PPUSH
4269: CALL_OW 111
// AddComUnload ( powell_trans [ i - 2 ] ) ;
4273: LD_EXP 23
4277: PUSH
4278: LD_VAR 0 4
4282: PUSH
4283: LD_INT 2
4285: MINUS
4286: ARRAY
4287: PPUSH
4288: CALL_OW 219
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4292: LD_EXP 23
4296: PUSH
4297: LD_VAR 0 4
4301: PUSH
4302: LD_INT 2
4304: MINUS
4305: ARRAY
4306: PPUSH
4307: LD_EXP 3
4311: PPUSH
4312: CALL_OW 250
4316: PPUSH
4317: LD_EXP 3
4321: PPUSH
4322: CALL_OW 251
4326: PPUSH
4327: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4331: LD_EXP 23
4335: PUSH
4336: LD_VAR 0 4
4340: PUSH
4341: LD_INT 2
4343: MINUS
4344: ARRAY
4345: PPUSH
4346: CALL_OW 200
// Wait ( 0 0$02 ) ;
4350: LD_INT 70
4352: PPUSH
4353: CALL_OW 67
// end ;
4357: GO 4148
4359: POP
4360: POP
// repeat wait ( 0 0$01 ) ;
4361: LD_INT 35
4363: PPUSH
4364: CALL_OW 67
// for i = 3 to 4 do
4368: LD_ADDR_VAR 0 4
4372: PUSH
4373: DOUBLE
4374: LD_INT 3
4376: DEC
4377: ST_TO_ADDR
4378: LD_INT 4
4380: PUSH
4381: FOR_TO
4382: IFFALSE 4532
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4384: LD_EXP 23
4388: PUSH
4389: LD_VAR 0 4
4393: ARRAY
4394: PPUSH
4395: LD_INT 1
4397: PPUSH
4398: CALL_OW 289
4402: PUSH
4403: LD_INT 0
4405: GREATER
4406: PUSH
4407: LD_EXP 23
4411: PUSH
4412: LD_VAR 0 4
4416: ARRAY
4417: PPUSH
4418: CALL_OW 314
4422: NOT
4423: AND
4424: IFFALSE 4530
// begin ComUnload ( powell_trans [ i ] ) ;
4426: LD_EXP 23
4430: PUSH
4431: LD_VAR 0 4
4435: ARRAY
4436: PPUSH
4437: CALL_OW 159
// x := rand ( 0 , 5 ) ;
4441: LD_ADDR_VAR 0 2
4445: PUSH
4446: LD_INT 0
4448: PPUSH
4449: LD_INT 5
4451: PPUSH
4452: CALL_OW 12
4456: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4457: LD_EXP 23
4461: PUSH
4462: LD_VAR 0 4
4466: ARRAY
4467: PPUSH
4468: LD_EXP 23
4472: PUSH
4473: LD_VAR 0 4
4477: ARRAY
4478: PPUSH
4479: CALL_OW 250
4483: PPUSH
4484: LD_VAR 0 2
4488: PPUSH
4489: LD_INT 3
4491: PPUSH
4492: CALL_OW 272
4496: PPUSH
4497: LD_EXP 23
4501: PUSH
4502: LD_VAR 0 4
4506: ARRAY
4507: PPUSH
4508: CALL_OW 251
4512: PPUSH
4513: LD_VAR 0 2
4517: PPUSH
4518: LD_INT 3
4520: PPUSH
4521: CALL_OW 273
4525: PPUSH
4526: CALL_OW 171
// end ;
4530: GO 4381
4532: POP
4533: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 and ( GetCargo ( powell_trans [ 3 ] , mat_cans ) = 0 ) and ( GetCargo ( powell_trans [ 4 ] , mat_cans ) = 0 ) ;
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 1
4541: ARRAY
4542: PPUSH
4543: LD_INT 54
4545: PPUSH
4546: LD_INT 42
4548: PPUSH
4549: CALL_OW 297
4553: PUSH
4554: LD_INT 4
4556: LESS
4557: PUSH
4558: LD_EXP 23
4562: PUSH
4563: LD_INT 3
4565: ARRAY
4566: PPUSH
4567: LD_INT 1
4569: PPUSH
4570: CALL_OW 289
4574: PUSH
4575: LD_INT 0
4577: EQUAL
4578: AND
4579: PUSH
4580: LD_EXP 23
4584: PUSH
4585: LD_INT 4
4587: ARRAY
4588: PPUSH
4589: LD_INT 1
4591: PPUSH
4592: CALL_OW 289
4596: PUSH
4597: LD_INT 0
4599: EQUAL
4600: AND
4601: IFFALSE 4361
// DialogueOn ;
4603: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4607: LD_INT 53
4609: PPUSH
4610: LD_INT 35
4612: PPUSH
4613: CALL_OW 86
// un := powell_trans [ 1 ] ;
4617: LD_ADDR_VAR 0 5
4621: PUSH
4622: LD_EXP 23
4626: PUSH
4627: LD_INT 1
4629: ARRAY
4630: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4631: LD_VAR 0 5
4635: PPUSH
4636: LD_STRING D4-Mech1-1
4638: PPUSH
4639: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4643: LD_EXP 17
4647: PPUSH
4648: LD_STRING D4-JMM-1
4650: PPUSH
4651: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4655: LD_VAR 0 5
4659: PPUSH
4660: LD_STRING D4-Mech1-2
4662: PPUSH
4663: CALL_OW 88
// powell_happy := false ;
4667: LD_ADDR_VAR 0 6
4671: PUSH
4672: LD_INT 0
4674: ST_TO_ADDR
// take_cargo := false ;
4675: LD_ADDR_VAR 0 7
4679: PUSH
4680: LD_INT 0
4682: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4683: CALL 776 0 0
4687: PUSH
4688: LD_INT 60
4690: GREATEREQUAL
4691: IFFALSE 4739
// begin Say ( JMM , D5-JMM-1 ) ;
4693: LD_EXP 17
4697: PPUSH
4698: LD_STRING D5-JMM-1
4700: PPUSH
4701: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4705: LD_VAR 0 5
4709: PPUSH
4710: LD_STRING D6-Mech1-1
4712: PPUSH
4713: CALL_OW 88
// powell_happy := true ;
4717: LD_ADDR_VAR 0 6
4721: PUSH
4722: LD_INT 1
4724: ST_TO_ADDR
// take_cargo := true ;
4725: LD_ADDR_VAR 0 7
4729: PUSH
4730: LD_INT 1
4732: ST_TO_ADDR
// DialogueOff ;
4733: CALL_OW 7
// end else
4737: GO 4973
// if GetTerminalCargo > 0 then
4739: CALL 776 0 0
4743: PUSH
4744: LD_INT 0
4746: GREATER
4747: IFFALSE 4945
// begin case Query ( QWait ) of 1 :
4749: LD_STRING QWait
4751: PPUSH
4752: CALL_OW 97
4756: PUSH
4757: LD_INT 1
4759: DOUBLE
4760: EQUAL
4761: IFTRUE 4765
4763: GO 4856
4765: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4766: LD_EXP 17
4770: PPUSH
4771: LD_STRING D5b-JMM-1
4773: PPUSH
4774: CALL_OW 88
// DialogueOff ;
4778: CALL_OW 7
// wait ( 5 5$00 ) ;
4782: LD_INT 10500
4784: PPUSH
4785: CALL_OW 67
// if GetTerminalCargo < 60 then
4789: CALL 776 0 0
4793: PUSH
4794: LD_INT 60
4796: LESS
4797: IFFALSE 4838
// begin DialogueOn ;
4799: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4803: LD_EXP 3
4807: PPUSH
4808: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4812: LD_VAR 0 5
4816: PPUSH
4817: LD_STRING D6-Mech1-1a
4819: PPUSH
4820: CALL_OW 88
// DialogueOff ;
4824: CALL_OW 7
// powell_happy := false ;
4828: LD_ADDR_VAR 0 6
4832: PUSH
4833: LD_INT 0
4835: ST_TO_ADDR
// end else
4836: GO 4854
// begin powell_happy := true ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: LD_INT 1
4845: ST_TO_ADDR
// take_cargo := true ;
4846: LD_ADDR_VAR 0 7
4850: PUSH
4851: LD_INT 1
4853: ST_TO_ADDR
// end ; end ; 2 :
4854: GO 4943
4856: LD_INT 2
4858: DOUBLE
4859: EQUAL
4860: IFTRUE 4864
4862: GO 4903
4864: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4865: LD_EXP 17
4869: PPUSH
4870: LD_STRING D5b-JMM-1
4872: PPUSH
4873: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4877: LD_VAR 0 5
4881: PPUSH
4882: LD_STRING D6-Mech1-1a
4884: PPUSH
4885: CALL_OW 88
// DialogueOff ;
4889: CALL_OW 7
// take_cargo := true ;
4893: LD_ADDR_VAR 0 7
4897: PUSH
4898: LD_INT 1
4900: ST_TO_ADDR
// end ; 3 :
4901: GO 4943
4903: LD_INT 3
4905: DOUBLE
4906: EQUAL
4907: IFTRUE 4911
4909: GO 4942
4911: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4912: LD_EXP 17
4916: PPUSH
4917: LD_STRING D5c-JMM-1
4919: PPUSH
4920: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4924: LD_VAR 0 5
4928: PPUSH
4929: LD_STRING D6-Mech1-1b
4931: PPUSH
4932: CALL_OW 88
// DialogueOff ;
4936: CALL_OW 7
// end ; end ;
4940: GO 4943
4942: POP
// end else
4943: GO 4973
// begin Say ( JMM , D5c-JMM-1 ) ;
4945: LD_EXP 17
4949: PPUSH
4950: LD_STRING D5c-JMM-1
4952: PPUSH
4953: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4957: LD_VAR 0 5
4961: PPUSH
4962: LD_STRING D6-Mech1-1b
4964: PPUSH
4965: CALL_OW 88
// DialogueOff ;
4969: CALL_OW 7
// end ; if take_cargo then
4973: LD_VAR 0 7
4977: IFFALSE 5056
// begin x := GetTerminalCargo ;
4979: LD_ADDR_VAR 0 2
4983: PUSH
4984: CALL 776 0 0
4988: ST_TO_ADDR
// if x > 60 then
4989: LD_VAR 0 2
4993: PUSH
4994: LD_INT 60
4996: GREATER
4997: IFFALSE 5007
// x := 60 ;
4999: LD_ADDR_VAR 0 2
5003: PUSH
5004: LD_INT 60
5006: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5007: LD_EXP 3
5011: PPUSH
5012: CALL_OW 274
5016: PPUSH
5017: LD_INT 3
5019: PPUSH
5020: CALL 776 0 0
5024: PUSH
5025: LD_VAR 0 2
5029: MINUS
5030: PPUSH
5031: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5035: LD_EXP 23
5039: PUSH
5040: LD_INT 3
5042: ARRAY
5043: PPUSH
5044: LD_INT 3
5046: PPUSH
5047: LD_VAR 0 2
5051: PPUSH
5052: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5056: LD_EXP 23
5060: PPUSH
5061: LD_INT 43
5063: PPUSH
5064: LD_INT 3
5066: PPUSH
5067: CALL_OW 171
// x := 0 0$20 ;
5071: LD_ADDR_VAR 0 2
5075: PUSH
5076: LD_INT 700
5078: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5079: LD_INT 35
5081: PPUSH
5082: CALL_OW 67
// x := x - 0 0$01 ;
5086: LD_ADDR_VAR 0 2
5090: PUSH
5091: LD_VAR 0 2
5095: PUSH
5096: LD_INT 35
5098: MINUS
5099: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5100: LD_VAR 0 2
5104: PUSH
5105: LD_INT 0
5107: EQUAL
5108: PUSH
5109: LD_EXP 23
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 43
5120: PPUSH
5121: LD_INT 3
5123: PPUSH
5124: CALL_OW 297
5128: PUSH
5129: LD_INT 4
5131: LESS
5132: PUSH
5133: LD_EXP 23
5137: PUSH
5138: LD_INT 3
5140: ARRAY
5141: PPUSH
5142: LD_INT 43
5144: PPUSH
5145: LD_INT 3
5147: PPUSH
5148: CALL_OW 297
5152: PUSH
5153: LD_INT 4
5155: LESS
5156: AND
5157: OR
5158: IFFALSE 5079
// for i in powell_trans do
5160: LD_ADDR_VAR 0 4
5164: PUSH
5165: LD_EXP 23
5169: PUSH
5170: FOR_IN
5171: IFFALSE 5184
// RemoveUnit ( i ) ;
5173: LD_VAR 0 4
5177: PPUSH
5178: CALL_OW 64
5182: GO 5170
5184: POP
5185: POP
// if not powell_happy then
5186: LD_VAR 0 6
5190: NOT
5191: IFFALSE 5202
// powell_happy := - 1 ;
5193: LD_ADDR_VAR 0 6
5197: PUSH
5198: LD_INT 1
5200: NEG
5201: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5202: LD_VAR 0 6
5206: PPUSH
5207: LD_STRING EarlySiberite
5209: PPUSH
5210: CALL_OW 101
// if powell_happy then
5214: LD_VAR 0 6
5218: IFFALSE 5229
// ChangeMissionObjectives ( M3a ) else
5220: LD_STRING M3a
5222: PPUSH
5223: CALL_OW 337
5227: GO 5236
// ChangeMissionObjectives ( M3b ) ;
5229: LD_STRING M3b
5231: PPUSH
5232: CALL_OW 337
// ru_can_attack_terminal := true ;
5236: LD_ADDR_EXP 9
5240: PUSH
5241: LD_INT 1
5243: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5244: LD_INT 12600
5246: PPUSH
5247: CALL_OW 67
// repeat wait ( 0 0$03 ) ;
5251: LD_INT 105
5253: PPUSH
5254: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5258: LD_EXP 8
5262: NOT
5263: PUSH
5264: LD_EXP 33
5268: PUSH
5269: LD_INT 3
5271: LESS
5272: OR
5273: IFFALSE 5251
// ar_can_arrive := true ;
5275: LD_ADDR_EXP 10
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// end ;
5283: PPOPN 7
5285: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5286: LD_INT 1
5288: PPUSH
5289: LD_INT 20
5291: PPUSH
5292: CALL_OW 325
5296: IFFALSE 5437
5298: GO 5300
5300: DISABLE
5301: LD_INT 0
5303: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5304: LD_ADDR_VAR 0 1
5308: PUSH
5309: LD_INT 22
5311: PUSH
5312: LD_INT 1
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: PUSH
5319: LD_INT 26
5321: PUSH
5322: LD_INT 1
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: PUSH
5329: LD_INT 25
5331: PUSH
5332: LD_INT 4
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL_OW 69
5348: PUSH
5349: LD_EXP 17
5353: PUSH
5354: LD_EXP 20
5358: PUSH
5359: LD_EXP 19
5363: PUSH
5364: LD_EXP 21
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: LIST
5373: LIST
5374: DIFF
5375: ST_TO_ADDR
// if not un then
5376: LD_VAR 0 1
5380: NOT
5381: IFFALSE 5385
// exit ;
5383: GO 5437
// DialogueOn ;
5385: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5389: LD_VAR 0 1
5393: PUSH
5394: LD_INT 1
5396: ARRAY
5397: PPUSH
5398: LD_STRING D13-Sci1-1
5400: PPUSH
5401: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5405: LD_EXP 17
5409: PPUSH
5410: LD_STRING D13-JMM-1
5412: PPUSH
5413: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5417: LD_VAR 0 1
5421: PUSH
5422: LD_INT 1
5424: ARRAY
5425: PPUSH
5426: LD_STRING D13-Sci1-2
5428: PPUSH
5429: CALL_OW 88
// DialogueOff ;
5433: CALL_OW 7
// end ;
5437: PPOPN 1
5439: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5440: LD_INT 1
5442: PPUSH
5443: CALL 807 0 1
5447: PUSH
5448: LD_INT 77
5450: GREATER
5451: PUSH
5452: LD_EXP 8
5456: NOT
5457: AND
5458: PUSH
5459: LD_INT 22
5461: PUSH
5462: LD_INT 1
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 25
5471: PUSH
5472: LD_INT 4
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 26
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: PPUSH
5494: CALL_OW 69
5498: PUSH
5499: LD_EXP 17
5503: PUSH
5504: LD_EXP 19
5508: PUSH
5509: LD_EXP 20
5513: PUSH
5514: LD_EXP 18
5518: PUSH
5519: LD_EXP 21
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: DIFF
5531: AND
5532: IFFALSE 5710
5534: GO 5536
5536: DISABLE
5537: LD_INT 0
5539: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5540: LD_ADDR_VAR 0 1
5544: PUSH
5545: LD_INT 22
5547: PUSH
5548: LD_INT 1
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 25
5557: PUSH
5558: LD_INT 4
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 26
5567: PUSH
5568: LD_INT 1
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: LIST
5579: PPUSH
5580: CALL_OW 69
5584: PUSH
5585: LD_EXP 17
5589: PUSH
5590: LD_EXP 19
5594: PUSH
5595: LD_EXP 20
5599: PUSH
5600: LD_EXP 18
5604: PUSH
5605: LD_EXP 21
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: DIFF
5617: ST_TO_ADDR
// DialogueOn ;
5618: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5622: LD_VAR 0 1
5626: PUSH
5627: LD_INT 1
5629: ARRAY
5630: PPUSH
5631: LD_STRING D7-Sci1-1
5633: PPUSH
5634: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5638: LD_EXP 17
5642: PPUSH
5643: LD_STRING D7-JMM-1
5645: PPUSH
5646: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5650: LD_VAR 0 1
5654: PUSH
5655: LD_INT 1
5657: ARRAY
5658: PPUSH
5659: LD_STRING D7-Sci1-2
5661: PPUSH
5662: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5666: LD_EXP 17
5670: PPUSH
5671: LD_STRING D7-JMM-2
5673: PPUSH
5674: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5678: LD_VAR 0 1
5682: PUSH
5683: LD_INT 1
5685: ARRAY
5686: PPUSH
5687: LD_STRING D7-Sci1-3
5689: PPUSH
5690: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5694: LD_EXP 17
5698: PPUSH
5699: LD_STRING D7-JMM-3
5701: PPUSH
5702: CALL_OW 88
// DialogueOff ;
5706: CALL_OW 7
// end ;
5710: PPOPN 1
5712: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5713: LD_EXP 10
5717: IFFALSE 8971
5719: GO 5721
5721: DISABLE
5722: LD_INT 0
5724: PPUSH
5725: PPUSH
5726: PPUSH
5727: PPUSH
5728: PPUSH
5729: PPUSH
5730: PPUSH
5731: PPUSH
// begin PrepareArabian ;
5732: CALL 11228 0 0
// repeat wait ( 0 0$01 ) ;
5736: LD_INT 35
5738: PPUSH
5739: CALL_OW 67
// until ar_spawned ;
5743: LD_EXP 11
5747: IFFALSE 5736
// DialogueOn ;
5749: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5753: LD_EXP 25
5757: PPUSH
5758: LD_STRING D8-Ar1-1
5760: PPUSH
5761: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5765: LD_EXP 17
5769: PPUSH
5770: LD_STRING D8-JMM-1
5772: PPUSH
5773: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5777: LD_EXP 25
5781: PPUSH
5782: LD_STRING D8-Ar1-2
5784: PPUSH
5785: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
5789: LD_EXP 17
5793: PPUSH
5794: LD_STRING D8-JMM-2
5796: PPUSH
5797: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
5801: LD_EXP 25
5805: PPUSH
5806: LD_STRING D8-Ar1-3
5808: PPUSH
5809: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
5813: LD_EXP 17
5817: PPUSH
5818: LD_STRING D8-JMM-3
5820: PPUSH
5821: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
5825: LD_EXP 25
5829: PPUSH
5830: LD_STRING D8-Ar1-4
5832: PPUSH
5833: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
5837: LD_EXP 17
5841: PPUSH
5842: LD_STRING D8-JMM-4
5844: PPUSH
5845: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
5849: LD_EXP 25
5853: PPUSH
5854: LD_STRING D8-Ar1-5
5856: PPUSH
5857: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
5861: LD_EXP 17
5865: PPUSH
5866: LD_STRING D8-JMM-5
5868: PPUSH
5869: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
5873: LD_EXP 25
5877: PPUSH
5878: LD_STRING D8-Ar1-6
5880: PPUSH
5881: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
5885: LD_EXP 26
5889: PPUSH
5890: LD_STRING D8-Ar2-6
5892: PPUSH
5893: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
5897: LD_EXP 17
5901: PPUSH
5902: LD_STRING D8-JMM-6
5904: PPUSH
5905: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
5909: LD_EXP 26
5913: PPUSH
5914: LD_STRING D8-Ar2-7
5916: PPUSH
5917: CALL_OW 94
// case Query ( QBarracks ) of 1 :
5921: LD_STRING QBarracks
5923: PPUSH
5924: CALL_OW 97
5928: PUSH
5929: LD_INT 1
5931: DOUBLE
5932: EQUAL
5933: IFTRUE 5937
5935: GO 5972
5937: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
5938: LD_EXP 17
5942: PPUSH
5943: LD_STRING D8a-JMM-1
5945: PPUSH
5946: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
5950: LD_EXP 25
5954: PPUSH
5955: LD_STRING D8a-Ar1-1
5957: PPUSH
5958: CALL_OW 94
// player_want_mortar := true ;
5962: LD_ADDR_EXP 12
5966: PUSH
5967: LD_INT 1
5969: ST_TO_ADDR
// end ; 2 :
5970: GO 6130
5972: LD_INT 2
5974: DOUBLE
5975: EQUAL
5976: IFTRUE 5980
5978: GO 6094
5980: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
5981: LD_EXP 17
5985: PPUSH
5986: LD_STRING D8b-JMM-1
5988: PPUSH
5989: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
5993: LD_EXP 25
5997: PPUSH
5998: LD_STRING D8b-Ar1-1
6000: PPUSH
6001: CALL_OW 94
// case Query ( QInfo ) of 1 :
6005: LD_STRING QInfo
6007: PPUSH
6008: CALL_OW 97
6012: PUSH
6013: LD_INT 1
6015: DOUBLE
6016: EQUAL
6017: IFTRUE 6021
6019: GO 6056
6021: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6022: LD_EXP 17
6026: PPUSH
6027: LD_STRING D8b1-JMM-1
6029: PPUSH
6030: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6034: LD_EXP 25
6038: PPUSH
6039: LD_STRING D8b1-Ar1-1
6041: PPUSH
6042: CALL_OW 94
// player_want_info := 2 ;
6046: LD_ADDR_EXP 13
6050: PUSH
6051: LD_INT 2
6053: ST_TO_ADDR
// end ; 2 :
6054: GO 6092
6056: LD_INT 2
6058: DOUBLE
6059: EQUAL
6060: IFTRUE 6064
6062: GO 6091
6064: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6065: LD_EXP 17
6069: PPUSH
6070: LD_STRING D8b2-JMM-1
6072: PPUSH
6073: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6077: LD_EXP 25
6081: PPUSH
6082: LD_STRING D8b2-Ar1-1
6084: PPUSH
6085: CALL_OW 94
// end ; end ;
6089: GO 6092
6091: POP
// end ; 3 :
6092: GO 6130
6094: LD_INT 3
6096: DOUBLE
6097: EQUAL
6098: IFTRUE 6102
6100: GO 6129
6102: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6103: LD_EXP 17
6107: PPUSH
6108: LD_STRING D8c-JMM-1
6110: PPUSH
6111: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6115: LD_EXP 25
6119: PPUSH
6120: LD_STRING D8c-Ar1-1
6122: PPUSH
6123: CALL_OW 94
// end ; end ;
6127: GO 6130
6129: POP
// DialogueOff ;
6130: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6134: LD_ADDR_VAR 0 4
6138: PUSH
6139: LD_INT 22
6141: PUSH
6142: LD_INT 1
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PUSH
6149: LD_INT 2
6151: PUSH
6152: LD_INT 30
6154: PUSH
6155: LD_INT 0
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 30
6164: PUSH
6165: LD_INT 1
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: LIST
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: PPUSH
6181: CALL_OW 69
6185: PPUSH
6186: LD_EXP 26
6190: PPUSH
6191: CALL_OW 74
6195: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6196: LD_ADDR_VAR 0 3
6200: PUSH
6201: LD_INT 22
6203: PUSH
6204: LD_INT 2
6206: PUSH
6207: EMPTY
6208: LIST
6209: LIST
6210: PUSH
6211: LD_INT 21
6213: PUSH
6214: LD_INT 2
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: ST_TO_ADDR
// time := 1 1$35 ;
6230: LD_ADDR_VAR 0 5
6234: PUSH
6235: LD_INT 3325
6237: ST_TO_ADDR
// no_oil_gain := false ;
6238: LD_ADDR_VAR 0 6
6242: PUSH
6243: LD_INT 0
6245: ST_TO_ADDR
// first_warn := false ;
6246: LD_ADDR_VAR 0 7
6250: PUSH
6251: LD_INT 0
6253: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6254: LD_EXP 12
6258: PUSH
6259: LD_EXP 13
6263: OR
6264: IFFALSE 6369
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6266: LD_EXP 32
6270: PPUSH
6271: LD_INT 25
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: CALL_OW 72
6285: PPUSH
6286: LD_VAR 0 4
6290: PPUSH
6291: CALL_OW 250
6295: PPUSH
6296: LD_VAR 0 4
6300: PPUSH
6301: CALL_OW 251
6305: PPUSH
6306: LD_VAR 0 4
6310: PPUSH
6311: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6315: LD_EXP 32
6319: PPUSH
6320: LD_INT 25
6322: PUSH
6323: LD_INT 1
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: PPUSH
6330: CALL_OW 72
6334: PPUSH
6335: LD_INT 86
6337: PPUSH
6338: LD_INT 121
6340: PPUSH
6341: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6345: LD_EXP 32
6349: PPUSH
6350: LD_INT 25
6352: PUSH
6353: LD_INT 1
6355: PUSH
6356: EMPTY
6357: LIST
6358: LIST
6359: PPUSH
6360: CALL_OW 72
6364: PPUSH
6365: CALL_OW 200
// end ; if player_attacked_ar then
6369: LD_EXP 16
6373: IFFALSE 6377
// exit ;
6375: GO 8971
// if player_want_mortar then
6377: LD_EXP 12
6381: IFFALSE 7773
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6383: LD_EXP 26
6387: PPUSH
6388: LD_VAR 0 4
6392: PPUSH
6393: CALL_OW 250
6397: PUSH
6398: LD_INT 1
6400: PLUS
6401: PPUSH
6402: LD_VAR 0 4
6406: PPUSH
6407: CALL_OW 251
6411: PUSH
6412: LD_INT 1
6414: PLUS
6415: PPUSH
6416: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6420: LD_INT 35
6422: PPUSH
6423: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6427: LD_EXP 26
6431: PPUSH
6432: LD_VAR 0 4
6436: PPUSH
6437: CALL_OW 296
6441: PUSH
6442: LD_INT 4
6444: LESS
6445: IFFALSE 6420
// for i = 1 to 6 do
6447: LD_ADDR_VAR 0 1
6451: PUSH
6452: DOUBLE
6453: LD_INT 1
6455: DEC
6456: ST_TO_ADDR
6457: LD_INT 6
6459: PUSH
6460: FOR_TO
6461: IFFALSE 6658
// begin if player_attacked_ar then
6463: LD_EXP 16
6467: IFFALSE 6473
// exit ;
6469: POP
6470: POP
6471: GO 8971
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6473: LD_VAR 0 4
6477: PPUSH
6478: CALL_OW 274
6482: PPUSH
6483: LD_INT 2
6485: PPUSH
6486: CALL_OW 275
6490: PUSH
6491: LD_INT 10
6493: LESS
6494: PUSH
6495: LD_VAR 0 7
6499: NOT
6500: AND
6501: IFFALSE 6564
// begin first_warn := true ;
6503: LD_ADDR_VAR 0 7
6507: PUSH
6508: LD_INT 1
6510: ST_TO_ADDR
// DialogueOn ;
6511: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6515: LD_EXP 27
6519: PPUSH
6520: LD_STRING D9a-FAr1-1
6522: PPUSH
6523: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6527: LD_EXP 17
6531: PPUSH
6532: LD_STRING D9a-JMM-1
6534: PPUSH
6535: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6539: LD_EXP 25
6543: PPUSH
6544: LD_STRING D9a2-Ar1-1
6546: PPUSH
6547: CALL_OW 88
// DialogueOff ;
6551: CALL_OW 7
// wait ( time ) ;
6555: LD_VAR 0 5
6559: PPUSH
6560: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6564: LD_VAR 0 4
6568: PPUSH
6569: CALL_OW 274
6573: PPUSH
6574: LD_INT 2
6576: PPUSH
6577: CALL_OW 275
6581: PUSH
6582: LD_INT 10
6584: LESS
6585: IFFALSE 6611
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6587: LD_EXP 25
6591: PPUSH
6592: LD_STRING D9a3-Ar1-1
6594: PPUSH
6595: CALL_OW 88
// no_oil_gain := true ;
6599: LD_ADDR_VAR 0 6
6603: PUSH
6604: LD_INT 1
6606: ST_TO_ADDR
// break ;
6607: GO 6658
// end else
6609: GO 6656
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6611: LD_EXP 26
6615: PPUSH
6616: LD_VAR 0 4
6620: PPUSH
6621: LD_INT 2
6623: PPUSH
6624: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6628: LD_EXP 26
6632: PPUSH
6633: LD_VAR 0 3
6637: PUSH
6638: LD_VAR 0 1
6642: PUSH
6643: LD_INT 3
6645: MOD
6646: PUSH
6647: LD_INT 1
6649: PLUS
6650: ARRAY
6651: PPUSH
6652: CALL_OW 210
// end ; end ;
6656: GO 6460
6658: POP
6659: POP
// if not no_oil_gain then
6660: LD_VAR 0 6
6664: NOT
6665: IFFALSE 7773
// begin repeat wait ( 0 0$01 ) ;
6667: LD_INT 35
6669: PPUSH
6670: CALL_OW 67
// if player_attacked_ar then
6674: LD_EXP 16
6678: IFFALSE 6682
// exit ;
6680: GO 8971
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6682: LD_VAR 0 3
6686: PUSH
6687: LD_INT 1
6689: ARRAY
6690: PPUSH
6691: CALL_OW 261
6695: PUSH
6696: LD_INT 80
6698: GREATER
6699: PUSH
6700: LD_VAR 0 3
6704: PUSH
6705: LD_INT 2
6707: ARRAY
6708: PPUSH
6709: CALL_OW 261
6713: PUSH
6714: LD_INT 80
6716: GREATER
6717: AND
6718: PUSH
6719: LD_VAR 0 3
6723: PUSH
6724: LD_INT 3
6726: ARRAY
6727: PPUSH
6728: CALL_OW 261
6732: PUSH
6733: LD_INT 80
6735: GREATER
6736: AND
6737: IFFALSE 6667
// ComMoveXY ( Gali , 105 , 127 ) ;
6739: LD_EXP 26
6743: PPUSH
6744: LD_INT 105
6746: PPUSH
6747: LD_INT 127
6749: PPUSH
6750: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6754: LD_EXP 26
6758: PPUSH
6759: LD_INT 2
6761: PPUSH
6762: CALL_OW 173
// AddComHold ( Gali ) ;
6766: LD_EXP 26
6770: PPUSH
6771: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// if player_attacked_ar then
6782: LD_EXP 16
6786: IFFALSE 6790
// exit ;
6788: GO 8971
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
6790: LD_EXP 26
6794: PPUSH
6795: LD_INT 105
6797: PPUSH
6798: LD_INT 127
6800: PPUSH
6801: CALL_OW 297
6805: PUSH
6806: LD_INT 4
6808: LESS
6809: IFFALSE 6775
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6811: LD_VAR 0 4
6815: PPUSH
6816: CALL_OW 274
6820: PPUSH
6821: LD_INT 1
6823: PPUSH
6824: CALL_OW 275
6828: PUSH
6829: LD_INT 50
6831: LESS
6832: IFFALSE 7128
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
6834: LD_VAR 0 4
6838: PPUSH
6839: CALL_OW 274
6843: PPUSH
6844: LD_INT 1
6846: PPUSH
6847: CALL_OW 275
6851: PUSH
6852: LD_INT 0
6854: DOUBLE
6855: GREATEREQUAL
6856: IFFALSE 6864
6858: LD_INT 24
6860: DOUBLE
6861: LESSEQUAL
6862: IFTRUE 6866
6864: GO 6881
6866: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
6867: LD_EXP 26
6871: PPUSH
6872: LD_STRING D9b-Ar2-1
6874: PPUSH
6875: CALL_OW 88
6879: GO 6911
6881: LD_INT 25
6883: DOUBLE
6884: GREATEREQUAL
6885: IFFALSE 6893
6887: LD_INT 49
6889: DOUBLE
6890: LESSEQUAL
6891: IFTRUE 6895
6893: GO 6910
6895: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
6896: LD_EXP 26
6900: PPUSH
6901: LD_STRING D9b-Ar2-1a
6903: PPUSH
6904: CALL_OW 88
6908: GO 6911
6910: POP
// Say ( JMM , D9b-JMM-1 ) ;
6911: LD_EXP 17
6915: PPUSH
6916: LD_STRING D9b-JMM-1
6918: PPUSH
6919: CALL_OW 88
// x := 0 0$0 ;
6923: LD_ADDR_VAR 0 2
6927: PUSH
6928: LD_INT 0
6930: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// x := x + 0 0$1 ;
6938: LD_ADDR_VAR 0 2
6942: PUSH
6943: LD_VAR 0 2
6947: PUSH
6948: LD_INT 35
6950: PLUS
6951: ST_TO_ADDR
// if player_attacked_ar then
6952: LD_EXP 16
6956: IFFALSE 6960
// exit ;
6958: GO 8971
// until x >= time ;
6960: LD_VAR 0 2
6964: PUSH
6965: LD_VAR 0 5
6969: GREATEREQUAL
6970: IFFALSE 6931
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6972: LD_VAR 0 4
6976: PPUSH
6977: CALL_OW 274
6981: PPUSH
6982: LD_INT 1
6984: PPUSH
6985: CALL_OW 275
6989: PUSH
6990: LD_INT 50
6992: LESS
6993: IFFALSE 7126
// begin DialogueOn ;
6995: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
6999: LD_EXP 25
7003: PPUSH
7004: LD_STRING D9c-Ar1-1
7006: PPUSH
7007: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7011: LD_EXP 17
7015: PPUSH
7016: LD_STRING D9c-JMM-1
7018: PPUSH
7019: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7023: LD_EXP 25
7027: PPUSH
7028: LD_STRING D9c-Ar1-2
7030: PPUSH
7031: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7035: LD_EXP 27
7039: PPUSH
7040: LD_STRING D9c-FAr1-2
7042: PPUSH
7043: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7047: LD_EXP 25
7051: PPUSH
7052: LD_STRING D9c-Ar1-3
7054: PPUSH
7055: CALL_OW 88
// case Query ( QInfo ) of 1 :
7059: LD_STRING QInfo
7061: PPUSH
7062: CALL_OW 97
7066: PUSH
7067: LD_INT 1
7069: DOUBLE
7070: EQUAL
7071: IFTRUE 7075
7073: GO 7098
7075: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7076: LD_EXP 17
7080: PPUSH
7081: LD_STRING D8b1-JMM-1
7083: PPUSH
7084: CALL_OW 88
// player_want_info := 2 ;
7088: LD_ADDR_EXP 13
7092: PUSH
7093: LD_INT 2
7095: ST_TO_ADDR
// end ; 2 :
7096: GO 7122
7098: LD_INT 2
7100: DOUBLE
7101: EQUAL
7102: IFTRUE 7106
7104: GO 7121
7106: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7107: LD_EXP 25
7111: PPUSH
7112: LD_STRING D8b2-Ar1-1
7114: PPUSH
7115: CALL_OW 88
// end ; end ;
7119: GO 7122
7121: POP
// DialogueOff ;
7122: CALL_OW 7
// end ; end else
7126: GO 7773
// begin RemoveEnvironmentArea ( mortarArea ) ;
7128: LD_INT 2
7130: PPUSH
7131: CALL_OW 355
// wait ( 1 ) ;
7135: LD_INT 1
7137: PPUSH
7138: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7142: LD_EXP 26
7146: PPUSH
7147: LD_INT 1
7149: PPUSH
7150: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7154: LD_EXP 26
7158: PPUSH
7159: LD_INT 4
7161: PPUSH
7162: LD_INT 107
7164: PPUSH
7165: LD_INT 131
7167: PPUSH
7168: LD_INT 0
7170: PPUSH
7171: CALL_OW 145
// repeat wait ( 1 ) ;
7175: LD_INT 1
7177: PPUSH
7178: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7182: LD_INT 30
7184: PUSH
7185: LD_INT 4
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: PUSH
7192: LD_INT 23
7194: PUSH
7195: LD_INT 2
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PPUSH
7206: CALL_OW 69
7210: IFFALSE 7175
// SetSide ( Gali , 2 ) ;
7212: LD_EXP 26
7216: PPUSH
7217: LD_INT 2
7219: PPUSH
7220: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7224: LD_ADDR_VAR 0 8
7228: PUSH
7229: LD_INT 30
7231: PUSH
7232: LD_INT 4
7234: PUSH
7235: EMPTY
7236: LIST
7237: LIST
7238: PUSH
7239: LD_INT 23
7241: PUSH
7242: LD_INT 2
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PPUSH
7253: CALL_OW 69
7257: PUSH
7258: LD_INT 1
7260: ARRAY
7261: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7262: LD_INT 35
7264: PPUSH
7265: CALL_OW 67
// if player_attacked_ar then
7269: LD_EXP 16
7273: IFFALSE 7277
// exit ;
7275: GO 8971
// until BuildingStatus ( b ) <> bs_build ;
7277: LD_VAR 0 8
7281: PPUSH
7282: CALL_OW 461
7286: PUSH
7287: LD_INT 1
7289: NONEQUAL
7290: IFFALSE 7262
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7292: LD_VAR 0 8
7296: PPUSH
7297: CALL_OW 302
7301: PUSH
7302: LD_VAR 0 4
7306: PPUSH
7307: CALL_OW 274
7311: PPUSH
7312: LD_INT 1
7314: PPUSH
7315: CALL_OW 275
7319: PUSH
7320: LD_INT 25
7322: GREATEREQUAL
7323: AND
7324: IFFALSE 7423
// begin ComUpgrade ( b ) ;
7326: LD_VAR 0 8
7330: PPUSH
7331: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7335: LD_EXP 26
7339: PPUSH
7340: LD_STRING h
7342: PUSH
7343: LD_VAR 0 8
7347: PPUSH
7348: CALL_OW 250
7352: PUSH
7353: LD_VAR 0 8
7357: PPUSH
7358: CALL_OW 251
7362: PUSH
7363: LD_VAR 0 8
7367: PUSH
7368: LD_INT 0
7370: PUSH
7371: LD_INT 0
7373: PUSH
7374: LD_INT 0
7376: PUSH
7377: EMPTY
7378: LIST
7379: LIST
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: PUSH
7386: EMPTY
7387: LIST
7388: PPUSH
7389: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7393: LD_INT 35
7395: PPUSH
7396: CALL_OW 67
// if player_attacked_ar then
7400: LD_EXP 16
7404: IFFALSE 7408
// exit ;
7406: GO 8971
// until BuildingStatus ( b ) <> bs_build ;
7408: LD_VAR 0 8
7412: PPUSH
7413: CALL_OW 461
7417: PUSH
7418: LD_INT 1
7420: NONEQUAL
7421: IFFALSE 7393
// end ; if b then
7423: LD_VAR 0 8
7427: IFFALSE 7438
// CenterNowOnUnits ( b ) ;
7429: LD_VAR 0 8
7433: PPUSH
7434: CALL_OW 87
// DialogueOn ;
7438: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7442: LD_EXP 26
7446: PPUSH
7447: LD_STRING D9d-Ar2-1
7449: PPUSH
7450: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7454: LD_EXP 25
7458: PPUSH
7459: LD_STRING D9d-Ar1-1
7461: PPUSH
7462: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7466: LD_EXP 17
7470: PPUSH
7471: LD_STRING D9d-JMM-1
7473: PPUSH
7474: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7478: LD_EXP 25
7482: PPUSH
7483: LD_STRING D9d-Ar1-2
7485: PPUSH
7486: CALL_OW 88
// DialogueOff ;
7490: CALL_OW 7
// i := [ ] ;
7494: LD_ADDR_VAR 0 1
7498: PUSH
7499: EMPTY
7500: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7501: LD_VAR 0 4
7505: PPUSH
7506: CALL_OW 274
7510: PPUSH
7511: LD_INT 3
7513: PPUSH
7514: CALL_OW 275
7518: PUSH
7519: LD_INT 20
7521: GREATEREQUAL
7522: IFFALSE 7541
// i := i ^ [ 1 ] ;
7524: LD_ADDR_VAR 0 1
7528: PUSH
7529: LD_VAR 0 1
7533: PUSH
7534: LD_INT 1
7536: PUSH
7537: EMPTY
7538: LIST
7539: ADD
7540: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7541: LD_VAR 0 4
7545: PPUSH
7546: CALL_OW 274
7550: PPUSH
7551: LD_INT 1
7553: PPUSH
7554: CALL_OW 275
7558: PUSH
7559: LD_INT 50
7561: GREATEREQUAL
7562: IFFALSE 7581
// i := i ^ [ 2 ] ;
7564: LD_ADDR_VAR 0 1
7568: PUSH
7569: LD_VAR 0 1
7573: PUSH
7574: LD_INT 2
7576: PUSH
7577: EMPTY
7578: LIST
7579: ADD
7580: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7581: LD_VAR 0 4
7585: PPUSH
7586: CALL_OW 274
7590: PPUSH
7591: LD_INT 2
7593: PPUSH
7594: CALL_OW 275
7598: PUSH
7599: LD_INT 80
7601: GREATEREQUAL
7602: IFFALSE 7621
// i := i ^ [ 3 ] ;
7604: LD_ADDR_VAR 0 1
7608: PUSH
7609: LD_VAR 0 1
7613: PUSH
7614: LD_INT 3
7616: PUSH
7617: EMPTY
7618: LIST
7619: ADD
7620: ST_TO_ADDR
// i := i diff 0 ;
7621: LD_ADDR_VAR 0 1
7625: PUSH
7626: LD_VAR 0 1
7630: PUSH
7631: LD_INT 0
7633: DIFF
7634: ST_TO_ADDR
// if i then
7635: LD_VAR 0 1
7639: IFFALSE 7745
// begin i := i ^ [ 4 ] ;
7641: LD_ADDR_VAR 0 1
7645: PUSH
7646: LD_VAR 0 1
7650: PUSH
7651: LD_INT 4
7653: PUSH
7654: EMPTY
7655: LIST
7656: ADD
7657: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7658: LD_STRING QInfo2
7660: PPUSH
7661: CALL_OW 97
7665: PUSH
7666: LD_INT 1
7668: DOUBLE
7669: EQUAL
7670: IFTRUE 7674
7672: GO 7685
7674: POP
// player_want_info := 3 ; 2 :
7675: LD_ADDR_EXP 13
7679: PUSH
7680: LD_INT 3
7682: ST_TO_ADDR
7683: GO 7743
7685: LD_INT 2
7687: DOUBLE
7688: EQUAL
7689: IFTRUE 7693
7691: GO 7704
7693: POP
// player_want_info := 1 ; 3 :
7694: LD_ADDR_EXP 13
7698: PUSH
7699: LD_INT 1
7701: ST_TO_ADDR
7702: GO 7743
7704: LD_INT 3
7706: DOUBLE
7707: EQUAL
7708: IFTRUE 7712
7710: GO 7723
7712: POP
// player_want_info := 2 ; 4 :
7713: LD_ADDR_EXP 13
7717: PUSH
7718: LD_INT 2
7720: ST_TO_ADDR
7721: GO 7743
7723: LD_INT 4
7725: DOUBLE
7726: EQUAL
7727: IFTRUE 7731
7729: GO 7742
7731: POP
// player_want_info := 0 ; end ;
7732: LD_ADDR_EXP 13
7736: PUSH
7737: LD_INT 0
7739: ST_TO_ADDR
7740: GO 7743
7742: POP
// end else
7743: GO 7773
// case Query ( QInfoNothing ) of 1 :
7745: LD_STRING QInfoNothing
7747: PPUSH
7748: CALL_OW 97
7752: PUSH
7753: LD_INT 1
7755: DOUBLE
7756: EQUAL
7757: IFTRUE 7761
7759: GO 7772
7761: POP
// player_want_info := 0 ; end ;
7762: LD_ADDR_EXP 13
7766: PUSH
7767: LD_INT 0
7769: ST_TO_ADDR
7770: GO 7773
7772: POP
// end ; end ; end ; if player_want_info then
7773: LD_EXP 13
7777: IFFALSE 8791
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7779: LD_ADDR_VAR 0 3
7783: PUSH
7784: LD_VAR 0 3
7788: PPUSH
7789: LD_INT 34
7791: PUSH
7792: LD_INT 32
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PPUSH
7799: CALL_OW 72
7803: ST_TO_ADDR
// if player_want_mortar then
7804: LD_EXP 12
7808: IFFALSE 8130
// begin case player_want_info of 1 :
7810: LD_EXP 13
7814: PUSH
7815: LD_INT 1
7817: DOUBLE
7818: EQUAL
7819: IFTRUE 7823
7821: GO 7834
7823: POP
// x := 5 ; 2 :
7824: LD_ADDR_VAR 0 2
7828: PUSH
7829: LD_INT 5
7831: ST_TO_ADDR
7832: GO 7873
7834: LD_INT 2
7836: DOUBLE
7837: EQUAL
7838: IFTRUE 7842
7840: GO 7853
7842: POP
// x := 8 ; 3 :
7843: LD_ADDR_VAR 0 2
7847: PUSH
7848: LD_INT 8
7850: ST_TO_ADDR
7851: GO 7873
7853: LD_INT 3
7855: DOUBLE
7856: EQUAL
7857: IFTRUE 7861
7859: GO 7872
7861: POP
// x := 2 ; end ;
7862: LD_ADDR_VAR 0 2
7866: PUSH
7867: LD_INT 2
7869: ST_TO_ADDR
7870: GO 7873
7872: POP
// repeat wait ( 0 0$1 ) ;
7873: LD_INT 35
7875: PPUSH
7876: CALL_OW 67
// until not HasTask ( Gali ) ;
7880: LD_EXP 26
7884: PPUSH
7885: CALL_OW 314
7889: NOT
7890: IFFALSE 7873
// for i = 1 to x do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: DOUBLE
7898: LD_INT 1
7900: DEC
7901: ST_TO_ADDR
7902: LD_VAR 0 2
7906: PUSH
7907: FOR_TO
7908: IFFALSE 8073
// begin AddComTransport ( Gali , dep , player_want_info ) ;
7910: LD_EXP 26
7914: PPUSH
7915: LD_VAR 0 4
7919: PPUSH
7920: LD_EXP 13
7924: PPUSH
7925: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
7929: LD_EXP 26
7933: PPUSH
7934: LD_VAR 0 3
7938: PUSH
7939: LD_INT 1
7941: ARRAY
7942: PPUSH
7943: CALL_OW 172
// AddComHold ( Gali ) ;
7947: LD_EXP 26
7951: PPUSH
7952: CALL_OW 200
// repeat wait ( 3 ) ;
7956: LD_INT 3
7958: PPUSH
7959: CALL_OW 67
// if player_attacked_ar then
7963: LD_EXP 16
7967: IFFALSE 7973
// exit ;
7969: POP
7970: POP
7971: GO 8971
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
7973: LD_EXP 26
7977: PPUSH
7978: LD_VAR 0 3
7982: PUSH
7983: LD_INT 1
7985: ARRAY
7986: PPUSH
7987: CALL_OW 296
7991: PUSH
7992: LD_INT 4
7994: LESS
7995: PUSH
7996: LD_EXP 26
8000: PPUSH
8001: LD_EXP 13
8005: PPUSH
8006: CALL_OW 289
8010: AND
8011: IFFALSE 7956
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8013: LD_VAR 0 3
8017: PUSH
8018: LD_INT 1
8020: ARRAY
8021: PPUSH
8022: LD_EXP 13
8026: PPUSH
8027: LD_VAR 0 3
8031: PUSH
8032: LD_INT 1
8034: ARRAY
8035: PPUSH
8036: LD_EXP 13
8040: PPUSH
8041: CALL_OW 289
8045: PUSH
8046: LD_INT 10
8048: PLUS
8049: PPUSH
8050: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8054: LD_EXP 26
8058: PPUSH
8059: LD_EXP 13
8063: PPUSH
8064: LD_INT 0
8066: PPUSH
8067: CALL_OW 290
// end ;
8071: GO 7907
8073: POP
8074: POP
// repeat wait ( 0 0$1 ) ;
8075: LD_INT 35
8077: PPUSH
8078: CALL_OW 67
// if player_attacked_ar then
8082: LD_EXP 16
8086: IFFALSE 8090
// exit ;
8088: GO 8971
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8090: LD_VAR 0 3
8094: PUSH
8095: LD_INT 1
8097: ARRAY
8098: PPUSH
8099: LD_EXP 13
8103: PPUSH
8104: CALL_OW 289
8108: PUSH
8109: LD_VAR 0 2
8113: PUSH
8114: LD_INT 10
8116: MUL
8117: EQUAL
8118: IFFALSE 8075
// no_oil_gain := false ;
8120: LD_ADDR_VAR 0 6
8124: PUSH
8125: LD_INT 0
8127: ST_TO_ADDR
// end else
8128: GO 8612
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8130: LD_ADDR_VAR 0 3
8134: PUSH
8135: LD_INT 22
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: PUSH
8145: LD_INT 21
8147: PUSH
8148: LD_INT 2
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PPUSH
8159: CALL_OW 69
8163: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8164: LD_EXP 26
8168: PPUSH
8169: LD_VAR 0 4
8173: PPUSH
8174: CALL_OW 250
8178: PUSH
8179: LD_INT 1
8181: PLUS
8182: PPUSH
8183: LD_VAR 0 4
8187: PPUSH
8188: CALL_OW 251
8192: PUSH
8193: LD_INT 1
8195: PLUS
8196: PPUSH
8197: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8201: LD_INT 35
8203: PPUSH
8204: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8208: LD_EXP 26
8212: PPUSH
8213: LD_VAR 0 4
8217: PPUSH
8218: CALL_OW 296
8222: PUSH
8223: LD_INT 4
8225: LESS
8226: IFFALSE 8201
// for i = 1 to 6 do
8228: LD_ADDR_VAR 0 1
8232: PUSH
8233: DOUBLE
8234: LD_INT 1
8236: DEC
8237: ST_TO_ADDR
8238: LD_INT 6
8240: PUSH
8241: FOR_TO
8242: IFFALSE 8439
// begin if player_attacked_ar then
8244: LD_EXP 16
8248: IFFALSE 8254
// exit ;
8250: POP
8251: POP
8252: GO 8971
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8254: LD_VAR 0 4
8258: PPUSH
8259: CALL_OW 274
8263: PPUSH
8264: LD_INT 2
8266: PPUSH
8267: CALL_OW 275
8271: PUSH
8272: LD_INT 10
8274: LESS
8275: PUSH
8276: LD_VAR 0 7
8280: NOT
8281: AND
8282: IFFALSE 8345
// begin first_warn := true ;
8284: LD_ADDR_VAR 0 7
8288: PUSH
8289: LD_INT 1
8291: ST_TO_ADDR
// DialogueOn ;
8292: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8296: LD_EXP 27
8300: PPUSH
8301: LD_STRING D9a-FAr1-1
8303: PPUSH
8304: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8308: LD_EXP 17
8312: PPUSH
8313: LD_STRING D9a-JMM-1
8315: PPUSH
8316: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8320: LD_EXP 25
8324: PPUSH
8325: LD_STRING D9a2-Ar1-1
8327: PPUSH
8328: CALL_OW 88
// DialogueOff ;
8332: CALL_OW 7
// wait ( time ) ;
8336: LD_VAR 0 5
8340: PPUSH
8341: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8345: LD_VAR 0 4
8349: PPUSH
8350: CALL_OW 274
8354: PPUSH
8355: LD_INT 2
8357: PPUSH
8358: CALL_OW 275
8362: PUSH
8363: LD_INT 10
8365: LESS
8366: IFFALSE 8392
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8368: LD_EXP 25
8372: PPUSH
8373: LD_STRING D9a3-Ar1-1
8375: PPUSH
8376: CALL_OW 88
// no_oil_gain := true ;
8380: LD_ADDR_VAR 0 6
8384: PUSH
8385: LD_INT 1
8387: ST_TO_ADDR
// break ;
8388: GO 8439
// end else
8390: GO 8437
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8392: LD_EXP 26
8396: PPUSH
8397: LD_VAR 0 4
8401: PPUSH
8402: LD_INT 2
8404: PPUSH
8405: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8409: LD_EXP 26
8413: PPUSH
8414: LD_VAR 0 3
8418: PUSH
8419: LD_VAR 0 1
8423: PUSH
8424: LD_INT 3
8426: MOD
8427: PUSH
8428: LD_INT 1
8430: PLUS
8431: ARRAY
8432: PPUSH
8433: CALL_OW 210
// end ; end ;
8437: GO 8241
8439: POP
8440: POP
// repeat wait ( 0 0$1 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// if player_attacked_ar then
8448: LD_EXP 16
8452: IFFALSE 8456
// exit ;
8454: GO 8971
// for i in tmp do
8456: LD_ADDR_VAR 0 1
8460: PUSH
8461: LD_VAR 0 3
8465: PUSH
8466: FOR_IN
8467: IFFALSE 8498
// if GetFuel ( i ) < 100 then
8469: LD_VAR 0 1
8473: PPUSH
8474: CALL_OW 261
8478: PUSH
8479: LD_INT 100
8481: LESS
8482: IFFALSE 8496
// begin x := i ;
8484: LD_ADDR_VAR 0 2
8488: PUSH
8489: LD_VAR 0 1
8493: ST_TO_ADDR
// break ;
8494: GO 8498
// end ;
8496: GO 8466
8498: POP
8499: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8500: LD_EXP 26
8504: PPUSH
8505: CALL_OW 314
8509: NOT
8510: PUSH
8511: LD_EXP 26
8515: PPUSH
8516: CALL_OW 281
8520: NOT
8521: AND
8522: IFFALSE 8555
// begin ComTransport ( Gali , dep , mat_oil ) ;
8524: LD_EXP 26
8528: PPUSH
8529: LD_VAR 0 4
8533: PPUSH
8534: LD_INT 2
8536: PPUSH
8537: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8541: LD_EXP 26
8545: PPUSH
8546: LD_VAR 0 2
8550: PPUSH
8551: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8555: LD_VAR 0 3
8559: PUSH
8560: LD_INT 1
8562: ARRAY
8563: PPUSH
8564: CALL_OW 261
8568: PUSH
8569: LD_INT 80
8571: GREATER
8572: PUSH
8573: LD_VAR 0 3
8577: PUSH
8578: LD_INT 2
8580: ARRAY
8581: PPUSH
8582: CALL_OW 261
8586: PUSH
8587: LD_INT 80
8589: GREATER
8590: AND
8591: PUSH
8592: LD_VAR 0 3
8596: PUSH
8597: LD_INT 3
8599: ARRAY
8600: PPUSH
8601: CALL_OW 261
8605: PUSH
8606: LD_INT 80
8608: GREATER
8609: AND
8610: IFFALSE 8441
// end ; ComHold ( Gali ) ;
8612: LD_EXP 26
8616: PPUSH
8617: CALL_OW 140
// if not no_oil_gain then
8621: LD_VAR 0 6
8625: NOT
8626: IFFALSE 8791
// begin DialogueOn ;
8628: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8632: LD_EXP 25
8636: PPUSH
8637: CALL_OW 87
// if player_want_mortar then
8641: LD_EXP 12
8645: IFFALSE 8671
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8647: LD_EXP 25
8651: PPUSH
8652: LD_STRING D9e-Ar1-1
8654: PPUSH
8655: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8659: LD_EXP 17
8663: PPUSH
8664: LD_STRING D10a-JMM-1
8666: PPUSH
8667: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8671: LD_EXP 25
8675: PPUSH
8676: LD_STRING D10a-Ar1-1
8678: PPUSH
8679: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8683: LD_EXP 26
8687: PPUSH
8688: LD_STRING D10a-Ar2-1
8690: PPUSH
8691: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8695: LD_EXP 27
8699: PPUSH
8700: LD_STRING D10a-FAr1-1
8702: PPUSH
8703: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8707: LD_EXP 26
8711: PPUSH
8712: LD_STRING D10a-Ar2-2
8714: PPUSH
8715: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8719: LD_EXP 27
8723: PPUSH
8724: LD_STRING D10a-FAr1-2
8726: PPUSH
8727: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8731: LD_EXP 25
8735: PPUSH
8736: LD_STRING D10a-Ar1-2
8738: PPUSH
8739: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8743: LD_EXP 17
8747: PPUSH
8748: LD_STRING D10a-JMM-2
8750: PPUSH
8751: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8755: LD_EXP 25
8759: PPUSH
8760: LD_STRING D10a-Ar1-3
8762: PPUSH
8763: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8767: LD_EXP 17
8771: PPUSH
8772: LD_STRING D10a-JMM-3
8774: PPUSH
8775: CALL_OW 88
// player_get_info := true ;
8779: LD_ADDR_EXP 15
8783: PUSH
8784: LD_INT 1
8786: ST_TO_ADDR
// DialogueOff ;
8787: CALL_OW 7
// end ; end ; if player_attacked_ar then
8791: LD_EXP 16
8795: IFFALSE 8799
// exit ;
8797: GO 8971
// if player_want_mortar or player_want_info then
8799: LD_EXP 12
8803: PUSH
8804: LD_EXP 13
8808: OR
8809: IFFALSE 8823
// Say ( Vervecken , D9f-Ar1-1 ) ;
8811: LD_EXP 25
8815: PPUSH
8816: LD_STRING D9f-Ar1-1
8818: PPUSH
8819: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8823: LD_INT 22
8825: PUSH
8826: LD_INT 2
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: PPUSH
8833: CALL_OW 69
8837: PPUSH
8838: LD_INT 51
8840: PPUSH
8841: LD_INT 99
8843: PPUSH
8844: CALL_OW 111
// wait ( 0 0$1 ) ;
8848: LD_INT 35
8850: PPUSH
8851: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
8855: LD_INT 22
8857: PUSH
8858: LD_INT 2
8860: PUSH
8861: EMPTY
8862: LIST
8863: LIST
8864: PUSH
8865: LD_INT 92
8867: PUSH
8868: LD_INT 51
8870: PUSH
8871: LD_INT 99
8873: PUSH
8874: LD_INT 2
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: PUSH
8883: EMPTY
8884: LIST
8885: LIST
8886: PPUSH
8887: CALL_OW 69
8891: IFFALSE 8951
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
8893: LD_ADDR_VAR 0 1
8897: PUSH
8898: LD_INT 22
8900: PUSH
8901: LD_INT 2
8903: PUSH
8904: EMPTY
8905: LIST
8906: LIST
8907: PUSH
8908: LD_INT 92
8910: PUSH
8911: LD_INT 51
8913: PUSH
8914: LD_INT 99
8916: PUSH
8917: LD_INT 2
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: PPUSH
8930: CALL_OW 69
8934: PUSH
8935: FOR_IN
8936: IFFALSE 8949
// RemoveUnit ( i ) ;
8938: LD_VAR 0 1
8942: PPUSH
8943: CALL_OW 64
8947: GO 8935
8949: POP
8950: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
8951: LD_INT 22
8953: PUSH
8954: LD_INT 2
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PPUSH
8961: CALL_OW 69
8965: PUSH
8966: LD_INT 0
8968: EQUAL
8969: IFFALSE 8823
// end ;
8971: PPOPN 8
8973: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
8974: LD_EXP 16
8978: IFFALSE 9331
8980: GO 8982
8982: DISABLE
8983: LD_INT 0
8985: PPUSH
8986: PPUSH
8987: PPUSH
8988: PPUSH
// begin ru_can_attack := true ;
8989: LD_ADDR_EXP 8
8993: PUSH
8994: LD_INT 1
8996: ST_TO_ADDR
// mine_launched := false ;
8997: LD_ADDR_VAR 0 3
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9005: LD_INT 22
9007: PUSH
9008: LD_INT 2
9010: PUSH
9011: EMPTY
9012: LIST
9013: LIST
9014: PPUSH
9015: CALL_OW 69
9019: PPUSH
9020: LD_INT 51
9022: PPUSH
9023: LD_INT 99
9025: PPUSH
9026: CALL_OW 111
// if IsOk ( Vervecken ) then
9030: LD_EXP 25
9034: PPUSH
9035: CALL_OW 302
9039: IFFALSE 9053
// Say ( Vervecken , D11a-Ar1-1 ) ;
9041: LD_EXP 25
9045: PPUSH
9046: LD_STRING D11a-Ar1-1
9048: PPUSH
9049: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9053: LD_ADDR_VAR 0 2
9057: PUSH
9058: LD_EXP 32
9062: PPUSH
9063: LD_INT 25
9065: PUSH
9066: LD_INT 1
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: PPUSH
9073: CALL_OW 72
9077: ST_TO_ADDR
// for i in tmp do
9078: LD_ADDR_VAR 0 1
9082: PUSH
9083: LD_VAR 0 2
9087: PUSH
9088: FOR_IN
9089: IFFALSE 9152
// if MineOfUnit ( i ) then
9091: LD_VAR 0 1
9095: PPUSH
9096: CALL_OW 459
9100: IFFALSE 9150
// begin x := MineOfUnit ( i ) ;
9102: LD_ADDR_VAR 0 4
9106: PUSH
9107: LD_VAR 0 1
9111: PPUSH
9112: CALL_OW 459
9116: ST_TO_ADDR
// mine_launched := true ;
9117: LD_ADDR_VAR 0 3
9121: PUSH
9122: LD_INT 1
9124: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9125: LD_VAR 0 4
9129: PUSH
9130: LD_INT 1
9132: ARRAY
9133: PPUSH
9134: LD_VAR 0 4
9138: PUSH
9139: LD_INT 2
9141: ARRAY
9142: PPUSH
9143: LD_INT 2
9145: PPUSH
9146: CALL_OW 456
// end ;
9150: GO 9088
9152: POP
9153: POP
// if mine_launched and IsOk ( Vervecken ) then
9154: LD_VAR 0 3
9158: PUSH
9159: LD_EXP 25
9163: PPUSH
9164: CALL_OW 302
9168: AND
9169: IFFALSE 9183
// Say ( Vervecken , D11b-Ar1-1 ) ;
9171: LD_EXP 25
9175: PPUSH
9176: LD_STRING D11b-Ar1-1
9178: PPUSH
9179: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9183: LD_INT 22
9185: PUSH
9186: LD_INT 2
9188: PUSH
9189: EMPTY
9190: LIST
9191: LIST
9192: PPUSH
9193: CALL_OW 69
9197: PPUSH
9198: LD_INT 51
9200: PPUSH
9201: LD_INT 99
9203: PPUSH
9204: CALL_OW 111
// wait ( 0 0$1 ) ;
9208: LD_INT 35
9210: PPUSH
9211: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9215: LD_INT 22
9217: PUSH
9218: LD_INT 2
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: PUSH
9225: LD_INT 92
9227: PUSH
9228: LD_INT 51
9230: PUSH
9231: LD_INT 99
9233: PUSH
9234: LD_INT 2
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL_OW 69
9251: IFFALSE 9311
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9253: LD_ADDR_VAR 0 1
9257: PUSH
9258: LD_INT 22
9260: PUSH
9261: LD_INT 2
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: PUSH
9268: LD_INT 92
9270: PUSH
9271: LD_INT 51
9273: PUSH
9274: LD_INT 99
9276: PUSH
9277: LD_INT 2
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: LIST
9284: LIST
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: PPUSH
9290: CALL_OW 69
9294: PUSH
9295: FOR_IN
9296: IFFALSE 9309
// RemoveUnit ( i ) ;
9298: LD_VAR 0 1
9302: PPUSH
9303: CALL_OW 64
9307: GO 9295
9309: POP
9310: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9311: LD_INT 22
9313: PUSH
9314: LD_INT 2
9316: PUSH
9317: EMPTY
9318: LIST
9319: LIST
9320: PPUSH
9321: CALL_OW 69
9325: PUSH
9326: LD_INT 0
9328: EQUAL
9329: IFFALSE 9183
// end ;
9331: PPOPN 4
9333: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9334: LD_EXP 10
9338: IFFALSE 9517
9340: GO 9342
9342: DISABLE
9343: LD_INT 0
9345: PPUSH
// begin Wait ( 10 10$00 ) ;
9346: LD_INT 21000
9348: PPUSH
9349: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9353: LD_INT 22
9355: PUSH
9356: LD_INT 2
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: PPUSH
9363: CALL_OW 69
9367: IFFALSE 9517
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9369: LD_INT 22
9371: PUSH
9372: LD_INT 2
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_INT 51
9386: PPUSH
9387: LD_INT 99
9389: PPUSH
9390: CALL_OW 114
// wait ( 0 0$1 ) ;
9394: LD_INT 35
9396: PPUSH
9397: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9401: LD_INT 22
9403: PUSH
9404: LD_INT 2
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 92
9413: PUSH
9414: LD_INT 51
9416: PUSH
9417: LD_INT 99
9419: PUSH
9420: LD_INT 2
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PPUSH
9433: CALL_OW 69
9437: IFFALSE 9497
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9439: LD_ADDR_VAR 0 1
9443: PUSH
9444: LD_INT 22
9446: PUSH
9447: LD_INT 2
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: PUSH
9454: LD_INT 92
9456: PUSH
9457: LD_INT 51
9459: PUSH
9460: LD_INT 99
9462: PUSH
9463: LD_INT 2
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: LIST
9470: LIST
9471: PUSH
9472: EMPTY
9473: LIST
9474: LIST
9475: PPUSH
9476: CALL_OW 69
9480: PUSH
9481: FOR_IN
9482: IFFALSE 9495
// RemoveUnit ( i ) ;
9484: LD_VAR 0 1
9488: PPUSH
9489: CALL_OW 64
9493: GO 9481
9495: POP
9496: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9497: LD_INT 22
9499: PUSH
9500: LD_INT 2
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PPUSH
9507: CALL_OW 69
9511: PUSH
9512: LD_INT 0
9514: EQUAL
9515: IFFALSE 9369
// end ; end ;
9517: PPOPN 1
9519: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9520: LD_EXP 4
9524: IFFALSE 10318
9526: GO 9528
9528: DISABLE
9529: LD_INT 0
9531: PPUSH
9532: PPUSH
9533: PPUSH
// begin Wait ( game_time ) ;
9534: LD_EXP 7
9538: PPUSH
9539: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9543: LD_INT 35
9545: PPUSH
9546: CALL_OW 67
// until ( not ru_can_attack ) ;
9550: LD_EXP 8
9554: NOT
9555: IFFALSE 9543
// Wait ( 0 0$35 ) ;
9557: LD_INT 1225
9559: PPUSH
9560: CALL_OW 67
// DialogueOn ;
9564: CALL_OW 6
// InGameOn ;
9568: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9572: LD_EXP 24
9576: PPUSH
9577: LD_STRING D12-Pow-1
9579: PPUSH
9580: CALL_OW 94
// InGameOff ;
9584: CALL_OW 9
// DialogueOff ;
9588: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9592: LD_STRING M4
9594: PPUSH
9595: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9599: LD_INT 5
9601: PPUSH
9602: LD_INT 1
9604: PPUSH
9605: CALL_OW 424
// repeat wait ( 0 0$1 ) ;
9609: LD_INT 35
9611: PPUSH
9612: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9616: LD_INT 22
9618: PUSH
9619: LD_INT 1
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: PUSH
9626: LD_INT 21
9628: PUSH
9629: LD_INT 1
9631: PUSH
9632: EMPTY
9633: LIST
9634: LIST
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: PPUSH
9640: CALL_OW 69
9644: PUSH
9645: LD_INT 5
9647: PPUSH
9648: LD_INT 22
9650: PUSH
9651: LD_INT 1
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PUSH
9658: LD_INT 21
9660: PUSH
9661: LD_INT 1
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: PPUSH
9672: CALL_OW 70
9676: PUSH
9677: LD_INT 22
9679: PUSH
9680: LD_INT 1
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: LD_INT 55
9689: PUSH
9690: EMPTY
9691: LIST
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: PPUSH
9697: CALL_OW 69
9701: PLUS
9702: LESSEQUAL
9703: IFFALSE 9609
// if not player_get_info then
9705: LD_EXP 15
9709: NOT
9710: IFFALSE 9721
// player_get_info := - 1 ;
9712: LD_ADDR_EXP 15
9716: PUSH
9717: LD_INT 1
9719: NEG
9720: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
9721: LD_STRING Information
9723: PPUSH
9724: LD_EXP 15
9728: PPUSH
9729: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9733: LD_ADDR_VAR 0 2
9737: PUSH
9738: LD_INT 22
9740: PUSH
9741: LD_INT 1
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: PUSH
9748: LD_INT 2
9750: PUSH
9751: LD_INT 25
9753: PUSH
9754: LD_INT 2
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: PUSH
9761: LD_INT 25
9763: PUSH
9764: LD_INT 16
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PUSH
9771: LD_INT 34
9773: PUSH
9774: LD_INT 12
9776: PUSH
9777: EMPTY
9778: LIST
9779: LIST
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: LIST
9785: LIST
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: PPUSH
9791: CALL_OW 69
9795: ST_TO_ADDR
// sib := GetTerminalCargo ;
9796: LD_ADDR_VAR 0 3
9800: PUSH
9801: CALL 776 0 0
9805: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
9806: LD_ADDR_VAR 0 3
9810: PUSH
9811: LD_VAR 0 3
9815: PUSH
9816: LD_INT 6
9818: PPUSH
9819: LD_INT 3
9821: PPUSH
9822: CALL_OW 287
9826: PLUS
9827: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
9828: LD_ADDR_VAR 0 3
9832: PUSH
9833: LD_VAR 0 3
9837: PUSH
9838: LD_VAR 0 2
9842: PPUSH
9843: LD_INT 3
9845: PPUSH
9846: CALL_OW 289
9850: PLUS
9851: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 2
9859: PUSH
9860: LD_OWVAR 67
9864: PLUS
9865: PUSH
9866: LD_INT 50
9868: MUL
9869: LESS
9870: IFFALSE 9895
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
9872: LD_STRING MuchSiberite
9874: PPUSH
9875: LD_INT 2
9877: NEG
9878: PUSH
9879: LD_OWVAR 67
9883: MUL
9884: PUSH
9885: LD_INT 1
9887: PLUS
9888: PPUSH
9889: CALL_OW 101
9893: GO 9905
// AddMedal ( MuchSiberite , 1 ) ;
9895: LD_STRING MuchSiberite
9897: PPUSH
9898: LD_INT 1
9900: PPUSH
9901: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
9905: LD_INT 22
9907: PUSH
9908: LD_INT 1
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: PUSH
9915: LD_INT 2
9917: PUSH
9918: LD_INT 25
9920: PUSH
9921: LD_INT 1
9923: PUSH
9924: EMPTY
9925: LIST
9926: LIST
9927: PUSH
9928: LD_INT 25
9930: PUSH
9931: LD_INT 2
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: PUSH
9938: LD_INT 25
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: PUSH
9948: LD_INT 25
9950: PUSH
9951: LD_INT 4
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PUSH
9958: LD_INT 25
9960: PUSH
9961: LD_INT 8
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PUSH
9968: EMPTY
9969: LIST
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: LIST
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: PPUSH
9980: CALL_OW 69
9984: PPUSH
9985: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
9989: LD_ADDR_VAR 0 2
9993: PUSH
9994: LD_INT 22
9996: PUSH
9997: LD_INT 1
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PUSH
10004: LD_INT 25
10006: PUSH
10007: LD_INT 8
10009: PUSH
10010: EMPTY
10011: LIST
10012: LIST
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: PPUSH
10018: CALL_OW 69
10022: ST_TO_ADDR
// if tmp then
10023: LD_VAR 0 2
10027: IFFALSE 10058
// for i in tmp do
10029: LD_ADDR_VAR 0 1
10033: PUSH
10034: LD_VAR 0 2
10038: PUSH
10039: FOR_IN
10040: IFFALSE 10056
// SetClass ( i , 1 ) ;
10042: LD_VAR 0 1
10046: PPUSH
10047: LD_INT 1
10049: PPUSH
10050: CALL_OW 336
10054: GO 10039
10056: POP
10057: POP
// SaveVariable ( sib , 09_sibRes ) ;
10058: LD_VAR 0 3
10062: PPUSH
10063: LD_STRING 09_sibRes
10065: PPUSH
10066: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10070: LD_EXP 15
10074: PPUSH
10075: LD_STRING 09_arInfo
10077: PPUSH
10078: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10082: LD_EXP 17
10086: PPUSH
10087: LD_EXP 1
10091: PUSH
10092: LD_STRING JMM
10094: STR
10095: PPUSH
10096: CALL_OW 38
// if IsLive ( Gary ) then
10100: LD_EXP 18
10104: PPUSH
10105: CALL_OW 300
10109: IFFALSE 10129
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10111: LD_EXP 18
10115: PPUSH
10116: LD_EXP 1
10120: PUSH
10121: LD_STRING Gary
10123: STR
10124: PPUSH
10125: CALL_OW 38
// if IsLive ( Bobby ) then
10129: LD_EXP 19
10133: PPUSH
10134: CALL_OW 300
10138: IFFALSE 10158
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10140: LD_EXP 19
10144: PPUSH
10145: LD_EXP 1
10149: PUSH
10150: LD_STRING Bobby
10152: STR
10153: PPUSH
10154: CALL_OW 38
// if IsLive ( Cyrus ) then
10158: LD_EXP 20
10162: PPUSH
10163: CALL_OW 300
10167: IFFALSE 10187
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10169: LD_EXP 20
10173: PPUSH
10174: LD_EXP 1
10178: PUSH
10179: LD_STRING Cyrus
10181: STR
10182: PPUSH
10183: CALL_OW 38
// if IsLive ( Houten ) then
10187: LD_EXP 21
10191: PPUSH
10192: CALL_OW 300
10196: IFFALSE 10216
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10198: LD_EXP 21
10202: PPUSH
10203: LD_EXP 1
10207: PUSH
10208: LD_STRING Houten
10210: STR
10211: PPUSH
10212: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10216: LD_ADDR_VAR 0 2
10220: PUSH
10221: LD_INT 22
10223: PUSH
10224: LD_INT 1
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: PUSH
10231: LD_INT 2
10233: PUSH
10234: LD_INT 25
10236: PUSH
10237: LD_INT 1
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: PUSH
10244: LD_INT 25
10246: PUSH
10247: LD_INT 2
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: PUSH
10254: LD_INT 25
10256: PUSH
10257: LD_INT 3
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 25
10266: PUSH
10267: LD_INT 4
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PPUSH
10285: CALL_OW 69
10289: ST_TO_ADDR
// if tmp then
10290: LD_VAR 0 2
10294: IFFALSE 10314
// SaveCharacters ( tmp , mission_prefix & others ) ;
10296: LD_VAR 0 2
10300: PPUSH
10301: LD_EXP 1
10305: PUSH
10306: LD_STRING others
10308: STR
10309: PPUSH
10310: CALL_OW 38
// YouWin ;
10314: CALL_OW 103
// end ; end_of_file
10318: PPOPN 3
10320: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10321: LD_VAR 0 1
10325: PPUSH
10326: CALL_OW 266
10330: PUSH
10331: LD_INT 0
10333: EQUAL
10334: PUSH
10335: LD_EXP 3
10339: NOT
10340: AND
10341: IFFALSE 10365
// begin terminal := b ;
10343: LD_ADDR_EXP 3
10347: PUSH
10348: LD_VAR 0 1
10352: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10353: LD_EXP 3
10357: PPUSH
10358: LD_STRING terminal
10360: PPUSH
10361: CALL_OW 500
// end ; end ;
10365: PPOPN 2
10367: END
// on BuildingComplete ( b ) do var i ;
10368: LD_INT 0
10370: PPUSH
// begin if GetSide ( b ) = 3 then
10371: LD_VAR 0 1
10375: PPUSH
10376: CALL_OW 255
10380: PUSH
10381: LD_INT 3
10383: EQUAL
10384: IFFALSE 10424
// for i = 1 to 4 do
10386: LD_ADDR_VAR 0 2
10390: PUSH
10391: DOUBLE
10392: LD_INT 1
10394: DEC
10395: ST_TO_ADDR
10396: LD_INT 4
10398: PUSH
10399: FOR_TO
10400: IFFALSE 10422
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10402: LD_ADDR_EXP 34
10406: PUSH
10407: LD_EXP 34
10411: PPUSH
10412: LD_INT 1
10414: PPUSH
10415: CALL_OW 3
10419: ST_TO_ADDR
10420: GO 10399
10422: POP
10423: POP
// end ;
10424: PPOPN 2
10426: END
// on VehicleConstructed ( veh , fac ) do var i ;
10427: LD_INT 0
10429: PPUSH
// begin if GetSide ( veh ) = 3 then
10430: LD_VAR 0 1
10434: PPUSH
10435: CALL_OW 255
10439: PUSH
10440: LD_INT 3
10442: EQUAL
10443: IFFALSE 10568
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 264
10454: PUSH
10455: LD_INT 53
10457: PUSH
10458: LD_INT 52
10460: PUSH
10461: LD_INT 51
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: IN
10469: NOT
10470: IFFALSE 10488
// ru_force := ru_force ^ veh ;
10472: LD_ADDR_EXP 33
10476: PUSH
10477: LD_EXP 33
10481: PUSH
10482: LD_VAR 0 1
10486: ADD
10487: ST_TO_ADDR
// for i = 1 to 4 do
10488: LD_ADDR_VAR 0 3
10492: PUSH
10493: DOUBLE
10494: LD_INT 1
10496: DEC
10497: ST_TO_ADDR
10498: LD_INT 4
10500: PUSH
10501: FOR_TO
10502: IFFALSE 10524
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10504: LD_ADDR_EXP 35
10508: PUSH
10509: LD_EXP 35
10513: PPUSH
10514: LD_INT 1
10516: PPUSH
10517: CALL_OW 3
10521: ST_TO_ADDR
10522: GO 10501
10524: POP
10525: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10526: LD_VAR 0 1
10530: PPUSH
10531: CALL_OW 264
10535: PUSH
10536: LD_INT 53
10538: EQUAL
10539: IFFALSE 10568
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10541: LD_VAR 0 1
10545: PPUSH
10546: LD_INT 7
10548: PPUSH
10549: CALL 934 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10553: LD_VAR 0 1
10557: PPUSH
10558: LD_INT 170
10560: PPUSH
10561: LD_INT 235
10563: PPUSH
10564: CALL_OW 171
// end ; end ; end ;
10568: PPOPN 3
10570: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10571: LD_VAR 0 1
10575: PUSH
10576: LD_INT 1
10578: EQUAL
10579: PUSH
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 2
10587: EQUAL
10588: AND
10589: PUSH
10590: LD_VAR 0 1
10594: PUSH
10595: LD_INT 2
10597: EQUAL
10598: PUSH
10599: LD_VAR 0 2
10603: PUSH
10604: LD_INT 1
10606: EQUAL
10607: AND
10608: OR
10609: IFFALSE 10619
// player_attacked_ar := true ;
10611: LD_ADDR_EXP 16
10615: PUSH
10616: LD_INT 1
10618: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
10619: LD_VAR 0 1
10623: PUSH
10624: LD_INT 1
10626: EQUAL
10627: PUSH
10628: LD_VAR 0 2
10632: PUSH
10633: LD_INT 4
10635: EQUAL
10636: AND
10637: PUSH
10638: LD_VAR 0 1
10642: PUSH
10643: LD_INT 4
10645: EQUAL
10646: PUSH
10647: LD_VAR 0 2
10651: PUSH
10652: LD_INT 1
10654: EQUAL
10655: AND
10656: OR
10657: IFFALSE 10666
// YouLost ( Traitor ) ;
10659: LD_STRING Traitor
10661: PPUSH
10662: CALL_OW 104
// end ;
10666: PPOPN 2
10668: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10669: LD_VAR 0 1
10673: PUSH
10674: LD_EXP 17
10678: EQUAL
10679: IFFALSE 10688
// YouLost ( JMM ) ;
10681: LD_STRING JMM
10683: PPUSH
10684: CALL_OW 104
// if un = terminal then
10688: LD_VAR 0 1
10692: PUSH
10693: LD_EXP 3
10697: EQUAL
10698: IFFALSE 10707
// YouLost ( Terminal ) ;
10700: LD_STRING Terminal
10702: PPUSH
10703: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10707: LD_VAR 0 1
10711: PUSH
10712: LD_INT 22
10714: PUSH
10715: LD_INT 3
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 21
10724: PUSH
10725: LD_INT 3
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: PPUSH
10736: CALL_OW 69
10740: IN
10741: IFFALSE 10887
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10743: LD_VAR 0 1
10747: PPUSH
10748: CALL_OW 266
10752: PUSH
10753: LD_INT 33
10755: PUSH
10756: LD_INT 26
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: IN
10763: IFFALSE 10822
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10765: LD_ADDR_EXP 34
10769: PUSH
10770: LD_EXP 34
10774: PUSH
10775: LD_VAR 0 1
10779: PPUSH
10780: CALL_OW 266
10784: PUSH
10785: LD_VAR 0 1
10789: PPUSH
10790: CALL_OW 250
10794: PUSH
10795: LD_VAR 0 1
10799: PPUSH
10800: CALL_OW 251
10804: PUSH
10805: LD_VAR 0 1
10809: PPUSH
10810: CALL_OW 254
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: LIST
10819: LIST
10820: ADD
10821: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 266
10831: PUSH
10832: LD_INT 5
10834: EQUAL
10835: IFFALSE 10887
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10837: LD_ADDR_EXP 34
10841: PUSH
10842: LD_EXP 34
10846: PUSH
10847: LD_INT 4
10849: PUSH
10850: LD_VAR 0 1
10854: PPUSH
10855: CALL_OW 250
10859: PUSH
10860: LD_VAR 0 1
10864: PPUSH
10865: CALL_OW 251
10869: PUSH
10870: LD_VAR 0 1
10874: PPUSH
10875: CALL_OW 254
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: LIST
10884: LIST
10885: ADD
10886: ST_TO_ADDR
// end ; if un in ru_force then
10887: LD_VAR 0 1
10891: PUSH
10892: LD_EXP 33
10896: IN
10897: IFFALSE 10930
// begin ru_force := ru_force diff un ;
10899: LD_ADDR_EXP 33
10903: PUSH
10904: LD_EXP 33
10908: PUSH
10909: LD_VAR 0 1
10913: DIFF
10914: ST_TO_ADDR
// if not ru_force then
10915: LD_EXP 33
10919: NOT
10920: IFFALSE 10930
// ru_can_attack := false ;
10922: LD_ADDR_EXP 8
10926: PUSH
10927: LD_INT 0
10929: ST_TO_ADDR
// end ; end ; end_of_file
10930: PPOPN 1
10932: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
10933: LD_EXP 5
10937: PUSH
10938: LD_EXP 6
10942: AND
10943: IFFALSE 11021
10945: GO 10947
10947: DISABLE
10948: LD_INT 0
10950: PPUSH
// begin enable ;
10951: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
10952: LD_ADDR_VAR 0 1
10956: PUSH
10957: LD_INT 60
10959: PUSH
10960: CALL 776 0 0
10964: MINUS
10965: ST_TO_ADDR
// if sib < 0 then
10966: LD_VAR 0 1
10970: PUSH
10971: LD_INT 0
10973: LESS
10974: IFFALSE 10984
// sib := 0 ;
10976: LD_ADDR_VAR 0 1
10980: PUSH
10981: LD_INT 0
10983: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
10984: LD_ADDR_OWVAR 47
10988: PUSH
10989: LD_STRING #Am09-1
10991: PUSH
10992: LD_VAR 0 1
10996: PUSH
10997: LD_EXP 6
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: LIST
11006: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11007: LD_ADDR_EXP 6
11011: PUSH
11012: LD_EXP 6
11016: PUSH
11017: LD_INT 35
11019: MINUS
11020: ST_TO_ADDR
// end ;
11021: PPOPN 1
11023: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11024: LD_EXP 6
11028: PUSH
11029: LD_INT 0
11031: EQUAL
11032: IFFALSE 11044
11034: GO 11036
11036: DISABLE
// display_strings := [ ] ;
11037: LD_ADDR_OWVAR 47
11041: PUSH
11042: EMPTY
11043: ST_TO_ADDR
11044: END
// every 1 1$35 do var i , tmp ;
11045: GO 11047
11047: DISABLE
11048: LD_INT 0
11050: PPUSH
11051: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11052: LD_ADDR_VAR 0 2
11056: PUSH
11057: LD_INT 1155
11059: PUSH
11060: LD_INT 1225
11062: PUSH
11063: LD_INT 1435
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: LIST
11070: PUSH
11071: LD_OWVAR 67
11075: ARRAY
11076: ST_TO_ADDR
// i := 0 ;
11077: LD_ADDR_VAR 0 1
11081: PUSH
11082: LD_INT 0
11084: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11085: LD_INT 1
11087: PPUSH
11088: LD_INT 5
11090: PPUSH
11091: CALL_OW 12
11095: PPUSH
11096: LD_INT 75
11098: PPUSH
11099: LD_INT 75
11101: PPUSH
11102: LD_INT 20
11104: PPUSH
11105: LD_INT 1
11107: PPUSH
11108: CALL_OW 56
// wait ( tmp ) ;
11112: LD_VAR 0 2
11116: PPUSH
11117: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11121: LD_ADDR_VAR 0 2
11125: PUSH
11126: LD_VAR 0 2
11130: PUSH
11131: LD_INT 105
11133: PPUSH
11134: LD_INT 315
11136: PPUSH
11137: CALL_OW 12
11141: PLUS
11142: ST_TO_ADDR
// i := i + 1 ;
11143: LD_ADDR_VAR 0 1
11147: PUSH
11148: LD_VAR 0 1
11152: PUSH
11153: LD_INT 1
11155: PLUS
11156: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11157: LD_VAR 0 1
11161: PUSH
11162: LD_INT 3
11164: MOD
11165: PUSH
11166: LD_INT 0
11168: EQUAL
11169: PUSH
11170: LD_EXP 4
11174: AND
11175: IFFALSE 11213
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11177: LD_INT 2
11179: PPUSH
11180: LD_INT 5
11182: PPUSH
11183: CALL_OW 12
11187: PPUSH
11188: LD_INT 8
11190: PPUSH
11191: LD_INT 1
11193: PPUSH
11194: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11198: LD_INT 665
11200: PPUSH
11201: LD_INT 735
11203: PPUSH
11204: CALL_OW 12
11208: PPUSH
11209: CALL_OW 67
// end ; until tick > game_time ;
11213: LD_OWVAR 1
11217: PUSH
11218: LD_EXP 7
11222: GREATER
11223: IFFALSE 11085
// end ; end_of_file
11225: PPOPN 2
11227: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11228: LD_INT 0
11230: PPUSH
11231: PPUSH
11232: PPUSH
11233: PPUSH
11234: PPUSH
11235: PPUSH
// x := 76 ;
11236: LD_ADDR_VAR 0 5
11240: PUSH
11241: LD_INT 76
11243: ST_TO_ADDR
// y := 147 ;
11244: LD_ADDR_VAR 0 6
11248: PUSH
11249: LD_INT 147
11251: ST_TO_ADDR
// uc_side := 2 ;
11252: LD_ADDR_OWVAR 20
11256: PUSH
11257: LD_INT 2
11259: ST_TO_ADDR
// uc_nation := 2 ;
11260: LD_ADDR_OWVAR 21
11264: PUSH
11265: LD_INT 2
11267: ST_TO_ADDR
// InitHc ;
11268: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11272: LD_INT 1
11274: PPUSH
11275: LD_INT 1
11277: PPUSH
11278: LD_INT 6
11280: PPUSH
11281: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11285: LD_ADDR_OWVAR 26
11289: PUSH
11290: LD_STRING Nicolas Vervecken
11292: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11293: LD_ADDR_OWVAR 33
11297: PUSH
11298: LD_STRING SecondCharsGal
11300: ST_TO_ADDR
// hc_face_number := 3 ;
11301: LD_ADDR_OWVAR 34
11305: PUSH
11306: LD_INT 3
11308: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11309: LD_ADDR_OWVAR 29
11313: PUSH
11314: LD_INT 11
11316: PUSH
11317: LD_INT 10
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: ST_TO_ADDR
// Vervecken := CreateHuman ;
11324: LD_ADDR_EXP 25
11328: PUSH
11329: CALL_OW 44
11333: ST_TO_ADDR
// ar_force := Vervecken ;
11334: LD_ADDR_EXP 32
11338: PUSH
11339: LD_EXP 25
11343: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11344: LD_INT 1
11346: PPUSH
11347: LD_INT 2
11349: PPUSH
11350: LD_INT 6
11352: PPUSH
11353: CALL_OW 380
// hc_name := Louis Gali ;
11357: LD_ADDR_OWVAR 26
11361: PUSH
11362: LD_STRING Louis Gali
11364: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11365: LD_ADDR_OWVAR 33
11369: PUSH
11370: LD_STRING SecondCharsGal
11372: ST_TO_ADDR
// hc_face_number := 2 ;
11373: LD_ADDR_OWVAR 34
11377: PUSH
11378: LD_INT 2
11380: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11381: LD_ADDR_OWVAR 29
11385: PUSH
11386: LD_INT 10
11388: PUSH
11389: LD_INT 11
11391: PUSH
11392: EMPTY
11393: LIST
11394: LIST
11395: ST_TO_ADDR
// Gali := CreateHuman ;
11396: LD_ADDR_EXP 26
11400: PUSH
11401: CALL_OW 44
11405: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11406: LD_ADDR_EXP 32
11410: PUSH
11411: LD_EXP 32
11415: PUSH
11416: LD_EXP 26
11420: ADD
11421: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11422: LD_INT 2
11424: PPUSH
11425: LD_INT 1
11427: PPUSH
11428: LD_INT 6
11430: PPUSH
11431: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11435: LD_ADDR_OWVAR 26
11439: PUSH
11440: LD_STRING Maria Bogdanovic
11442: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11443: LD_ADDR_OWVAR 33
11447: PUSH
11448: LD_STRING SecondCharsGal
11450: ST_TO_ADDR
// hc_face_number := 14 ;
11451: LD_ADDR_OWVAR 34
11455: PUSH
11456: LD_INT 14
11458: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11459: LD_ADDR_OWVAR 29
11463: PUSH
11464: LD_INT 12
11466: PUSH
11467: LD_INT 9
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11474: LD_ADDR_EXP 27
11478: PUSH
11479: CALL_OW 44
11483: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11484: LD_ADDR_EXP 32
11488: PUSH
11489: LD_EXP 32
11493: PUSH
11494: LD_EXP 27
11498: ADD
11499: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11500: LD_INT 1
11502: PPUSH
11503: LD_INT 3
11505: PPUSH
11506: LD_INT 6
11508: PPUSH
11509: CALL_OW 380
// hc_name = Kntor Radomr ;
11513: LD_ADDR_OWVAR 26
11517: PUSH
11518: LD_STRING Kntor Radomr
11520: ST_TO_ADDR
// hc_gallery = sandar ;
11521: LD_ADDR_OWVAR 33
11525: PUSH
11526: LD_STRING sandar
11528: ST_TO_ADDR
// hc_face_number = 12 ;
11529: LD_ADDR_OWVAR 34
11533: PUSH
11534: LD_INT 12
11536: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11537: LD_ADDR_OWVAR 29
11541: PUSH
11542: LD_INT 9
11544: PUSH
11545: LD_INT 9
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: ST_TO_ADDR
// Kantor = CreateHuman ;
11552: LD_ADDR_EXP 28
11556: PUSH
11557: CALL_OW 44
11561: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11562: LD_ADDR_EXP 32
11566: PUSH
11567: LD_EXP 32
11571: PUSH
11572: LD_EXP 28
11576: ADD
11577: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11578: LD_INT 1
11580: PPUSH
11581: LD_INT 3
11583: PPUSH
11584: LD_INT 6
11586: PPUSH
11587: CALL_OW 380
// hc_name = Herczeg Farkas ;
11591: LD_ADDR_OWVAR 26
11595: PUSH
11596: LD_STRING Herczeg Farkas
11598: ST_TO_ADDR
// hc_gallery = sandar ;
11599: LD_ADDR_OWVAR 33
11603: PUSH
11604: LD_STRING sandar
11606: ST_TO_ADDR
// hc_face_number = 28 ;
11607: LD_ADDR_OWVAR 34
11611: PUSH
11612: LD_INT 28
11614: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11615: LD_ADDR_OWVAR 29
11619: PUSH
11620: LD_INT 10
11622: PUSH
11623: LD_INT 9
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: ST_TO_ADDR
// Herczeg = CreateHuman ;
11630: LD_ADDR_EXP 29
11634: PUSH
11635: CALL_OW 44
11639: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11640: LD_ADDR_EXP 32
11644: PUSH
11645: LD_EXP 32
11649: PUSH
11650: LD_EXP 29
11654: ADD
11655: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11656: LD_INT 1
11658: PPUSH
11659: LD_INT 1
11661: PPUSH
11662: LD_INT 6
11664: PPUSH
11665: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11669: LD_ADDR_OWVAR 26
11673: PUSH
11674: LD_STRING Ronn Horntvedt
11676: ST_TO_ADDR
// hc_gallery = sandar ;
11677: LD_ADDR_OWVAR 33
11681: PUSH
11682: LD_STRING sandar
11684: ST_TO_ADDR
// hc_face_number = 29 ;
11685: LD_ADDR_OWVAR 34
11689: PUSH
11690: LD_INT 29
11692: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11693: LD_ADDR_OWVAR 29
11697: PUSH
11698: LD_INT 11
11700: PUSH
11701: LD_INT 11
11703: PUSH
11704: EMPTY
11705: LIST
11706: LIST
11707: ST_TO_ADDR
// Ronn = CreateHuman ;
11708: LD_ADDR_EXP 30
11712: PUSH
11713: CALL_OW 44
11717: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11718: LD_ADDR_EXP 32
11722: PUSH
11723: LD_EXP 32
11727: PUSH
11728: LD_EXP 30
11732: ADD
11733: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11734: LD_INT 2
11736: PPUSH
11737: LD_INT 3
11739: PPUSH
11740: LD_INT 6
11742: PPUSH
11743: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11747: LD_ADDR_OWVAR 26
11751: PUSH
11752: LD_STRING Mia D. Mathiasen
11754: ST_TO_ADDR
// hc_gallery = sandar ;
11755: LD_ADDR_OWVAR 33
11759: PUSH
11760: LD_STRING sandar
11762: ST_TO_ADDR
// hc_face_number = 31 ;
11763: LD_ADDR_OWVAR 34
11767: PUSH
11768: LD_INT 31
11770: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
11771: LD_ADDR_OWVAR 29
11775: PUSH
11776: LD_INT 10
11778: PUSH
11779: LD_INT 10
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: ST_TO_ADDR
// Mia = CreateHuman ;
11786: LD_ADDR_EXP 31
11790: PUSH
11791: CALL_OW 44
11795: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
11796: LD_ADDR_EXP 32
11800: PUSH
11801: LD_EXP 32
11805: PUSH
11806: LD_EXP 31
11810: ADD
11811: ST_TO_ADDR
// for i = 1 to 2 do
11812: LD_ADDR_VAR 0 4
11816: PUSH
11817: DOUBLE
11818: LD_INT 1
11820: DEC
11821: ST_TO_ADDR
11822: LD_INT 2
11824: PUSH
11825: FOR_TO
11826: IFFALSE 11867
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_INT 2
11840: PPUSH
11841: LD_INT 2
11843: PPUSH
11844: LD_INT 14
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: LD_INT 1
11852: PPUSH
11853: LD_INT 32
11855: PPUSH
11856: LD_INT 30
11858: PPUSH
11859: CALL 256 0 7
11863: ADD
11864: ST_TO_ADDR
11865: GO 11825
11867: POP
11868: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
11869: LD_ADDR_VAR 0 3
11873: PUSH
11874: LD_VAR 0 3
11878: PUSH
11879: LD_INT 2
11881: PPUSH
11882: LD_INT 2
11884: PPUSH
11885: LD_INT 14
11887: PPUSH
11888: LD_INT 1
11890: PPUSH
11891: LD_INT 1
11893: PPUSH
11894: LD_INT 26
11896: PPUSH
11897: LD_INT 33
11899: PPUSH
11900: CALL 256 0 7
11904: ADD
11905: ST_TO_ADDR
// tmp := tmp diff 0 ;
11906: LD_ADDR_VAR 0 3
11910: PUSH
11911: LD_VAR 0 3
11915: PUSH
11916: LD_INT 0
11918: DIFF
11919: ST_TO_ADDR
// for i in ar_force do
11920: LD_ADDR_VAR 0 4
11924: PUSH
11925: LD_EXP 32
11929: PUSH
11930: FOR_IN
11931: IFFALSE 12074
// begin if GetClass ( i ) = 3 then
11933: LD_VAR 0 4
11937: PPUSH
11938: CALL_OW 257
11942: PUSH
11943: LD_INT 3
11945: EQUAL
11946: IFFALSE 12028
// begin SetDir ( tmp [ 1 ] , 1 ) ;
11948: LD_VAR 0 3
11952: PUSH
11953: LD_INT 1
11955: ARRAY
11956: PPUSH
11957: LD_INT 1
11959: PPUSH
11960: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
11964: LD_VAR 0 3
11968: PUSH
11969: LD_INT 1
11971: ARRAY
11972: PPUSH
11973: LD_VAR 0 5
11977: PPUSH
11978: LD_VAR 0 6
11982: PPUSH
11983: LD_INT 0
11985: PPUSH
11986: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
11990: LD_VAR 0 4
11994: PPUSH
11995: LD_VAR 0 3
11999: PUSH
12000: LD_INT 1
12002: ARRAY
12003: PPUSH
12004: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12008: LD_ADDR_VAR 0 3
12012: PUSH
12013: LD_VAR 0 3
12017: PPUSH
12018: LD_INT 1
12020: PPUSH
12021: CALL_OW 3
12025: ST_TO_ADDR
// end else
12026: GO 12050
// PlaceUnitXY ( i , x , y , false ) ;
12028: LD_VAR 0 4
12032: PPUSH
12033: LD_VAR 0 5
12037: PPUSH
12038: LD_VAR 0 6
12042: PPUSH
12043: LD_INT 0
12045: PPUSH
12046: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12050: LD_VAR 0 4
12054: PPUSH
12055: LD_INT 86
12057: PPUSH
12058: LD_INT 121
12060: PPUSH
12061: CALL_OW 111
// wait ( 0 0$2 ) ;
12065: LD_INT 70
12067: PPUSH
12068: CALL_OW 67
// end ;
12072: GO 11930
12074: POP
12075: POP
// ar_force := ar_force ^ tmp ;
12076: LD_ADDR_EXP 32
12080: PUSH
12081: LD_EXP 32
12085: PUSH
12086: LD_VAR 0 3
12090: ADD
12091: ST_TO_ADDR
// ar_spawned := true ;
12092: LD_ADDR_EXP 11
12096: PUSH
12097: LD_INT 1
12099: ST_TO_ADDR
// end ; end_of_file
12100: LD_VAR 0 1
12104: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12105: LD_INT 0
12107: PPUSH
12108: PPUSH
12109: PPUSH
12110: PPUSH
12111: PPUSH
12112: PPUSH
12113: PPUSH
// InitHc ;
12114: CALL_OW 19
// uc_side := 3 ;
12118: LD_ADDR_OWVAR 20
12122: PUSH
12123: LD_INT 3
12125: ST_TO_ADDR
// uc_nation := 3 ;
12126: LD_ADDR_OWVAR 21
12130: PUSH
12131: LD_INT 3
12133: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12134: LD_ADDR_VAR 0 5
12138: PUSH
12139: LD_INT 5
12141: PUSH
12142: LD_INT 6
12144: PUSH
12145: LD_INT 7
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: LIST
12152: PUSH
12153: LD_OWVAR 67
12157: ARRAY
12158: ST_TO_ADDR
// ru_force := [ ] ;
12159: LD_ADDR_EXP 33
12163: PUSH
12164: EMPTY
12165: ST_TO_ADDR
// ru_rebuild := [ ] ;
12166: LD_ADDR_EXP 34
12170: PUSH
12171: EMPTY
12172: ST_TO_ADDR
// ru_produce_list := [ ] ;
12173: LD_ADDR_EXP 35
12177: PUSH
12178: EMPTY
12179: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12180: LD_ADDR_VAR 0 6
12184: PUSH
12185: LD_INT 22
12187: PUSH
12188: LD_INT 3
12190: PUSH
12191: EMPTY
12192: LIST
12193: LIST
12194: PUSH
12195: LD_INT 30
12197: PUSH
12198: LD_INT 8
12200: PUSH
12201: EMPTY
12202: LIST
12203: LIST
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: PUSH
12214: LD_INT 1
12216: ARRAY
12217: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12218: LD_ADDR_VAR 0 4
12222: PUSH
12223: LD_INT 43
12225: PUSH
12226: LD_INT 46
12228: PUSH
12229: LD_INT 45
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: LIST
12236: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12237: LD_ADDR_VAR 0 7
12241: PUSH
12242: LD_INT 22
12244: PUSH
12245: LD_INT 3
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: LD_INT 30
12254: PUSH
12255: LD_INT 1
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PPUSH
12266: CALL_OW 69
12270: PUSH
12271: LD_INT 1
12273: ARRAY
12274: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12275: LD_VAR 0 7
12279: PPUSH
12280: CALL_OW 274
12284: PPUSH
12285: LD_INT 1
12287: PPUSH
12288: LD_INT 5000
12290: PPUSH
12291: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12295: LD_VAR 0 7
12299: PPUSH
12300: CALL_OW 274
12304: PPUSH
12305: LD_INT 2
12307: PPUSH
12308: LD_INT 1000
12310: PPUSH
12311: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12315: LD_VAR 0 7
12319: PPUSH
12320: CALL_OW 274
12324: PPUSH
12325: LD_INT 3
12327: PPUSH
12328: LD_INT 30
12330: PPUSH
12331: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12335: LD_ADDR_VAR 0 2
12339: PUSH
12340: LD_INT 22
12342: PUSH
12343: LD_INT 3
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 30
12352: PUSH
12353: LD_INT 33
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PPUSH
12364: CALL_OW 69
12368: PUSH
12369: FOR_IN
12370: IFFALSE 12402
// begin PlaceWeaponTurret ( i , tmp [ rand ( 1 , tmp ) ] ) ;
12372: LD_VAR 0 2
12376: PPUSH
12377: LD_VAR 0 4
12381: PUSH
12382: LD_INT 1
12384: PPUSH
12385: LD_VAR 0 4
12389: PPUSH
12390: CALL_OW 12
12394: ARRAY
12395: PPUSH
12396: CALL_OW 431
// end ;
12400: GO 12369
12402: POP
12403: POP
// for i = 1 to 4 do
12404: LD_ADDR_VAR 0 2
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_INT 4
12416: PUSH
12417: FOR_TO
12418: IFFALSE 12479
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12420: LD_INT 0
12422: PPUSH
12423: LD_INT 9
12425: PPUSH
12426: LD_VAR 0 5
12430: PPUSH
12431: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12435: CALL_OW 44
12439: PPUSH
12440: LD_INT 22
12442: PUSH
12443: LD_INT 3
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 30
12452: PUSH
12453: LD_INT 5
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: EMPTY
12461: LIST
12462: LIST
12463: PPUSH
12464: CALL_OW 69
12468: PUSH
12469: LD_INT 1
12471: ARRAY
12472: PPUSH
12473: CALL_OW 52
// end ;
12477: GO 12417
12479: POP
12480: POP
// for i = 1 to 5 do
12481: LD_ADDR_VAR 0 2
12485: PUSH
12486: DOUBLE
12487: LD_INT 1
12489: DEC
12490: ST_TO_ADDR
12491: LD_INT 5
12493: PUSH
12494: FOR_TO
12495: IFFALSE 12556
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 3
12502: PPUSH
12503: LD_VAR 0 5
12507: PPUSH
12508: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12512: CALL_OW 44
12516: PPUSH
12517: LD_INT 22
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PUSH
12527: LD_INT 30
12529: PUSH
12530: LD_INT 3
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PPUSH
12541: CALL_OW 69
12545: PUSH
12546: LD_INT 1
12548: ARRAY
12549: PPUSH
12550: CALL_OW 52
// end ;
12554: GO 12494
12556: POP
12557: POP
// for i = 1 to 4 do
12558: LD_ADDR_VAR 0 2
12562: PUSH
12563: DOUBLE
12564: LD_INT 1
12566: DEC
12567: ST_TO_ADDR
12568: LD_INT 4
12570: PUSH
12571: FOR_TO
12572: IFFALSE 12633
// begin PrepareHuman ( false , class_engineer , skill ) ;
12574: LD_INT 0
12576: PPUSH
12577: LD_INT 2
12579: PPUSH
12580: LD_VAR 0 5
12584: PPUSH
12585: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12589: CALL_OW 44
12593: PPUSH
12594: LD_INT 22
12596: PUSH
12597: LD_INT 3
12599: PUSH
12600: EMPTY
12601: LIST
12602: LIST
12603: PUSH
12604: LD_INT 30
12606: PUSH
12607: LD_INT 1
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: PUSH
12614: EMPTY
12615: LIST
12616: LIST
12617: PPUSH
12618: CALL_OW 69
12622: PUSH
12623: LD_INT 1
12625: ARRAY
12626: PPUSH
12627: CALL_OW 52
// end ;
12631: GO 12571
12633: POP
12634: POP
// for i = 1 to 3 do
12635: LD_ADDR_VAR 0 2
12639: PUSH
12640: DOUBLE
12641: LD_INT 1
12643: DEC
12644: ST_TO_ADDR
12645: LD_INT 3
12647: PUSH
12648: FOR_TO
12649: IFFALSE 12682
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12651: LD_INT 0
12653: PPUSH
12654: LD_INT 4
12656: PPUSH
12657: LD_VAR 0 5
12661: PPUSH
12662: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12666: CALL_OW 44
12670: PPUSH
12671: LD_VAR 0 6
12675: PPUSH
12676: CALL_OW 52
// end ;
12680: GO 12648
12682: POP
12683: POP
// AddComResearch ( lab , tech_tech2 ) ;
12684: LD_VAR 0 6
12688: PPUSH
12689: LD_INT 49
12691: PPUSH
12692: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12696: LD_VAR 0 6
12700: PPUSH
12701: LD_INT 50
12703: PPUSH
12704: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12708: LD_VAR 0 6
12712: PPUSH
12713: LD_INT 51
12715: PPUSH
12716: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12720: LD_VAR 0 6
12724: PPUSH
12725: LD_INT 52
12727: PPUSH
12728: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12732: LD_VAR 0 6
12736: PPUSH
12737: LD_INT 69
12739: PPUSH
12740: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12744: LD_VAR 0 6
12748: PPUSH
12749: LD_INT 39
12751: PPUSH
12752: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
12756: LD_VAR 0 6
12760: PPUSH
12761: LD_INT 34
12763: PPUSH
12764: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
12768: LD_VAR 0 6
12772: PPUSH
12773: LD_INT 40
12775: PPUSH
12776: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
12780: LD_VAR 0 6
12784: PPUSH
12785: LD_INT 57
12787: PPUSH
12788: CALL_OW 184
// if Difficulty > 1 then
12792: LD_OWVAR 67
12796: PUSH
12797: LD_INT 1
12799: GREATER
12800: IFFALSE 12814
// AddComResearch ( lab , tech_comp2 ) ;
12802: LD_VAR 0 6
12806: PPUSH
12807: LD_INT 58
12809: PPUSH
12810: CALL_OW 184
// end ;
12814: LD_VAR 0 1
12818: RET
// every 7 7$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 do
12819: LD_INT 7
12821: PPUSH
12822: CALL_OW 353
12826: PUSH
12827: LD_INT 3
12829: GREATER
12830: IFFALSE 12865
12832: GO 12834
12834: DISABLE
// begin enable ;
12835: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
12836: LD_ADDR_EXP 35
12840: PUSH
12841: LD_EXP 35
12845: PUSH
12846: LD_INT 24
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: LD_INT 3
12854: PUSH
12855: LD_INT 53
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: ADD
12864: ST_TO_ADDR
// end ;
12865: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
12866: LD_INT 22
12868: PUSH
12869: LD_INT 3
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: LD_INT 21
12878: PUSH
12879: LD_INT 3
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: PPUSH
12890: CALL_OW 69
12894: IFFALSE 13672
12896: GO 12898
12898: DISABLE
12899: LD_INT 0
12901: PPUSH
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
12907: PPUSH
12908: PPUSH
// begin enable ;
12909: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12910: LD_ADDR_VAR 0 3
12914: PUSH
12915: LD_INT 22
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: LD_INT 21
12927: PUSH
12928: LD_INT 3
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 3
12937: PUSH
12938: LD_INT 24
12940: PUSH
12941: LD_INT 1000
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: LIST
12956: PPUSH
12957: CALL_OW 69
12961: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12962: LD_ADDR_VAR 0 4
12966: PUSH
12967: LD_INT 22
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: EMPTY
12974: LIST
12975: LIST
12976: PUSH
12977: LD_INT 25
12979: PUSH
12980: LD_INT 2
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PPUSH
12991: CALL_OW 69
12995: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12996: LD_ADDR_VAR 0 5
13000: PUSH
13001: LD_INT 22
13003: PUSH
13004: LD_INT 3
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PUSH
13011: LD_INT 30
13013: PUSH
13014: LD_INT 1
13016: PUSH
13017: EMPTY
13018: LIST
13019: LIST
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: PPUSH
13025: CALL_OW 69
13029: PUSH
13030: LD_INT 1
13032: ARRAY
13033: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13034: LD_ADDR_VAR 0 8
13038: PUSH
13039: LD_INT 22
13041: PUSH
13042: LD_INT 3
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: PUSH
13049: LD_INT 2
13051: PUSH
13052: LD_INT 30
13054: PUSH
13055: LD_INT 6
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PUSH
13062: LD_INT 30
13064: PUSH
13065: LD_INT 7
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PUSH
13072: LD_INT 30
13074: PUSH
13075: LD_INT 8
13077: PUSH
13078: EMPTY
13079: LIST
13080: LIST
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: PUSH
13088: EMPTY
13089: LIST
13090: LIST
13091: PPUSH
13092: CALL_OW 69
13096: PUSH
13097: LD_INT 1
13099: ARRAY
13100: ST_TO_ADDR
// if not engs then
13101: LD_VAR 0 4
13105: NOT
13106: IFFALSE 13110
// exit ;
13108: GO 13672
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13110: LD_ADDR_VAR 0 6
13114: PUSH
13115: LD_VAR 0 4
13119: PPUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 24
13125: PUSH
13126: LD_INT 600
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: PPUSH
13137: CALL_OW 72
13141: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13142: LD_ADDR_VAR 0 7
13146: PUSH
13147: LD_INT 22
13149: PUSH
13150: LD_INT 3
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: PUSH
13157: LD_INT 25
13159: PUSH
13160: LD_INT 4
13162: PUSH
13163: EMPTY
13164: LIST
13165: LIST
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PPUSH
13171: CALL_OW 69
13175: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13176: LD_VAR 0 3
13180: NOT
13181: PUSH
13182: LD_EXP 34
13186: NOT
13187: AND
13188: IFFALSE 13248
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13190: LD_VAR 0 4
13194: PPUSH
13195: LD_INT 3
13197: PUSH
13198: LD_INT 54
13200: PUSH
13201: EMPTY
13202: LIST
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: PPUSH
13208: CALL_OW 72
13212: IFFALSE 13246
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13214: LD_VAR 0 4
13218: PPUSH
13219: LD_INT 3
13221: PUSH
13222: LD_INT 54
13224: PUSH
13225: EMPTY
13226: LIST
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PPUSH
13232: CALL_OW 72
13236: PPUSH
13237: LD_VAR 0 5
13241: PPUSH
13242: CALL_OW 120
// exit ;
13246: GO 13672
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13248: LD_VAR 0 4
13252: PPUSH
13253: LD_INT 54
13255: PUSH
13256: EMPTY
13257: LIST
13258: PPUSH
13259: CALL_OW 72
13263: IFFALSE 13285
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13265: LD_VAR 0 4
13269: PPUSH
13270: LD_INT 54
13272: PUSH
13273: EMPTY
13274: LIST
13275: PPUSH
13276: CALL_OW 72
13280: PPUSH
13281: CALL_OW 122
// if not tmp then
13285: LD_VAR 0 3
13289: NOT
13290: IFFALSE 13422
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13292: LD_INT 81
13294: PUSH
13295: LD_INT 3
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: PUSH
13302: LD_INT 92
13304: PUSH
13305: LD_INT 147
13307: PUSH
13308: LD_INT 212
13310: PUSH
13311: LD_INT 30
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: LIST
13318: LIST
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PPUSH
13324: CALL_OW 69
13328: NOT
13329: IFFALSE 13422
// begin if not HasTask ( engs [ 1 ] ) then
13331: LD_VAR 0 4
13335: PUSH
13336: LD_INT 1
13338: ARRAY
13339: PPUSH
13340: CALL_OW 314
13344: NOT
13345: IFFALSE 13422
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13347: LD_ADDR_VAR 0 2
13351: PUSH
13352: LD_VAR 0 4
13356: PPUSH
13357: LD_EXP 34
13361: PUSH
13362: LD_INT 1
13364: ARRAY
13365: PPUSH
13366: LD_EXP 34
13370: PUSH
13371: LD_INT 2
13373: ARRAY
13374: PPUSH
13375: LD_EXP 34
13379: PUSH
13380: LD_INT 3
13382: ARRAY
13383: PPUSH
13384: LD_EXP 34
13388: PUSH
13389: LD_INT 4
13391: ARRAY
13392: PPUSH
13393: CALL_OW 145
13397: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13398: LD_VAR 0 2
13402: PPUSH
13403: CALL_OW 266
13407: PUSH
13408: LD_INT 4
13410: EQUAL
13411: IFFALSE 13422
// AddComUpgrade ( i ) ;
13413: LD_VAR 0 2
13417: PPUSH
13418: CALL_OW 206
// end ; end ; end ; for i in engs do
13422: LD_ADDR_VAR 0 2
13426: PUSH
13427: LD_VAR 0 4
13431: PUSH
13432: FOR_IN
13433: IFFALSE 13551
// begin if i in to_heal and sci then
13435: LD_VAR 0 2
13439: PUSH
13440: LD_VAR 0 6
13444: IN
13445: PUSH
13446: LD_VAR 0 7
13450: AND
13451: IFFALSE 13502
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13453: LD_VAR 0 2
13457: PPUSH
13458: LD_INT 149
13460: PPUSH
13461: LD_INT 220
13463: PPUSH
13464: CALL_OW 297
13468: PUSH
13469: LD_INT 5
13471: LESS
13472: IFFALSE 13476
// continue ;
13474: GO 13432
// ComMoveXY ( i , 149 , 220 ) ;
13476: LD_VAR 0 2
13480: PPUSH
13481: LD_INT 149
13483: PPUSH
13484: LD_INT 220
13486: PPUSH
13487: CALL_OW 111
// AddComHold ( i ) ;
13491: LD_VAR 0 2
13495: PPUSH
13496: CALL_OW 200
// end else
13500: GO 13549
// if not HasTask ( i ) or WantsToAttack ( i ) then
13502: LD_VAR 0 2
13506: PPUSH
13507: CALL_OW 314
13511: NOT
13512: PUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL_OW 319
13522: OR
13523: IFFALSE 13549
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13525: LD_VAR 0 2
13529: PPUSH
13530: LD_VAR 0 3
13534: PPUSH
13535: LD_VAR 0 2
13539: PPUSH
13540: CALL_OW 74
13544: PPUSH
13545: CALL_OW 130
// end ;
13549: GO 13432
13551: POP
13552: POP
// if to_heal and sci then
13553: LD_VAR 0 6
13557: PUSH
13558: LD_VAR 0 7
13562: AND
13563: IFFALSE 13624
// begin if UnitFilter ( sci , [ f_inside ] ) then
13565: LD_VAR 0 7
13569: PPUSH
13570: LD_INT 54
13572: PUSH
13573: EMPTY
13574: LIST
13575: PPUSH
13576: CALL_OW 72
13580: IFFALSE 13604
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13582: LD_VAR 0 7
13586: PPUSH
13587: LD_INT 54
13589: PUSH
13590: EMPTY
13591: LIST
13592: PPUSH
13593: CALL_OW 72
13597: PPUSH
13598: CALL_OW 122
13602: GO 13622
// ComHeal ( sci , to_heal [ 1 ] ) ;
13604: LD_VAR 0 7
13608: PPUSH
13609: LD_VAR 0 6
13613: PUSH
13614: LD_INT 1
13616: ARRAY
13617: PPUSH
13618: CALL_OW 128
// end else
13622: GO 13672
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13624: LD_VAR 0 7
13628: PPUSH
13629: LD_INT 56
13631: PUSH
13632: EMPTY
13633: LIST
13634: PPUSH
13635: CALL_OW 72
13639: PUSH
13640: LD_VAR 0 8
13644: AND
13645: IFFALSE 13672
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13647: LD_VAR 0 7
13651: PPUSH
13652: LD_INT 56
13654: PUSH
13655: EMPTY
13656: LIST
13657: PPUSH
13658: CALL_OW 72
13662: PPUSH
13663: LD_VAR 0 8
13667: PPUSH
13668: CALL_OW 120
// end ;
13672: PPOPN 8
13674: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13675: LD_INT 22
13677: PUSH
13678: LD_INT 3
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: LD_INT 30
13687: PUSH
13688: LD_INT 3
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PUSH
13695: EMPTY
13696: LIST
13697: LIST
13698: PPUSH
13699: CALL_OW 69
13703: PUSH
13704: LD_EXP 35
13708: AND
13709: IFFALSE 13835
13711: GO 13713
13713: DISABLE
13714: LD_INT 0
13716: PPUSH
13717: PPUSH
13718: PPUSH
// begin enable ;
13719: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13720: LD_ADDR_VAR 0 3
13724: PUSH
13725: LD_INT 22
13727: PUSH
13728: LD_INT 3
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: PUSH
13735: LD_INT 30
13737: PUSH
13738: LD_INT 3
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PPUSH
13749: CALL_OW 69
13753: PUSH
13754: LD_INT 1
13756: ARRAY
13757: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
13758: LD_VAR 0 3
13762: PPUSH
13763: CALL_OW 313
13767: PUSH
13768: LD_INT 0
13770: EQUAL
13771: IFFALSE 13775
// exit ;
13773: GO 13835
// if BuildingStatus ( fac ) = bs_idle then
13775: LD_VAR 0 3
13779: PPUSH
13780: CALL_OW 461
13784: PUSH
13785: LD_INT 2
13787: EQUAL
13788: IFFALSE 13835
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
13790: LD_VAR 0 3
13794: PPUSH
13795: LD_EXP 35
13799: PUSH
13800: LD_INT 1
13802: ARRAY
13803: PPUSH
13804: LD_EXP 35
13808: PUSH
13809: LD_INT 2
13811: ARRAY
13812: PPUSH
13813: LD_EXP 35
13817: PUSH
13818: LD_INT 3
13820: ARRAY
13821: PPUSH
13822: LD_EXP 35
13826: PUSH
13827: LD_INT 4
13829: ARRAY
13830: PPUSH
13831: CALL_OW 125
// end ;
13835: PPOPN 3
13837: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
13838: LD_INT 0
13840: PPUSH
13841: PPUSH
13842: PPUSH
13843: PPUSH
13844: PPUSH
// uc_side := 3 ;
13845: LD_ADDR_OWVAR 20
13849: PUSH
13850: LD_INT 3
13852: ST_TO_ADDR
// uc_nation := 3 ;
13853: LD_ADDR_OWVAR 21
13857: PUSH
13858: LD_INT 3
13860: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
13861: LD_ADDR_VAR 0 6
13865: PUSH
13866: LD_INT 22
13868: PUSH
13869: LD_INT 3
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: PUSH
13876: LD_INT 30
13878: PUSH
13879: LD_INT 3
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PUSH
13886: EMPTY
13887: LIST
13888: LIST
13889: PPUSH
13890: CALL_OW 69
13894: ST_TO_ADDR
// if fac then
13895: LD_VAR 0 6
13899: IFFALSE 14057
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
13901: LD_ADDR_EXP 35
13905: PUSH
13906: LD_INT 24
13908: PUSH
13909: LD_INT 1
13911: PUSH
13912: LD_INT 3
13914: PUSH
13915: LD_INT 43
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: ST_TO_ADDR
// for i = 1 to Difficulty do
13924: LD_ADDR_VAR 0 3
13928: PUSH
13929: DOUBLE
13930: LD_INT 1
13932: DEC
13933: ST_TO_ADDR
13934: LD_OWVAR 67
13938: PUSH
13939: FOR_TO
13940: IFFALSE 13989
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher , ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ;
13942: LD_ADDR_EXP 35
13946: PUSH
13947: LD_EXP 35
13951: PUSH
13952: LD_INT 24
13954: PUSH
13955: LD_INT 1
13957: PUSH
13958: LD_INT 3
13960: PUSH
13961: LD_INT 45
13963: PUSH
13964: LD_INT 24
13966: PUSH
13967: LD_INT 1
13969: PUSH
13970: LD_INT 3
13972: PUSH
13973: LD_INT 46
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: ADD
13986: ST_TO_ADDR
13987: GO 13939
13989: POP
13990: POP
// repeat wait ( 0 0$1 ) ;
13991: LD_INT 35
13993: PPUSH
13994: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
13998: LD_EXP 35
14002: PUSH
14003: LD_INT 4
14005: LESS
14006: PUSH
14007: LD_VAR 0 6
14011: PUSH
14012: LD_INT 1
14014: ARRAY
14015: PPUSH
14016: CALL_OW 313
14020: PUSH
14021: LD_INT 0
14023: EQUAL
14024: OR
14025: PUSH
14026: LD_VAR 0 6
14030: PUSH
14031: LD_INT 1
14033: ARRAY
14034: PPUSH
14035: CALL_OW 461
14039: PUSH
14040: LD_INT 8
14042: PUSH
14043: LD_INT 6
14045: PUSH
14046: LD_INT 7
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: LIST
14053: IN
14054: OR
14055: IFFALSE 13991
// end ; case wave of 1 :
14057: LD_VAR 0 1
14061: PUSH
14062: LD_INT 1
14064: DOUBLE
14065: EQUAL
14066: IFTRUE 14070
14068: GO 14155
14070: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14071: LD_ADDR_VAR 0 3
14075: PUSH
14076: DOUBLE
14077: LD_INT 1
14079: DEC
14080: ST_TO_ADDR
14081: LD_INT 4
14083: PUSH
14084: LD_INT 5
14086: PUSH
14087: LD_INT 6
14089: PUSH
14090: EMPTY
14091: LIST
14092: LIST
14093: LIST
14094: PUSH
14095: LD_OWVAR 67
14099: ARRAY
14100: PUSH
14101: FOR_TO
14102: IFFALSE 14110
// Sold ;
14104: CALL 14280 0 0
14108: GO 14101
14110: POP
14111: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14112: LD_ADDR_VAR 0 3
14116: PUSH
14117: DOUBLE
14118: LD_INT 1
14120: DEC
14121: ST_TO_ADDR
14122: LD_INT 2
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 3
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: LIST
14135: PUSH
14136: LD_OWVAR 67
14140: ARRAY
14141: PUSH
14142: FOR_TO
14143: IFFALSE 14151
// Tank ;
14145: CALL 14394 0 0
14149: GO 14142
14151: POP
14152: POP
// end ; 2 .. 9 :
14153: GO 14275
14155: LD_INT 2
14157: DOUBLE
14158: GREATEREQUAL
14159: IFFALSE 14167
14161: LD_INT 9
14163: DOUBLE
14164: LESSEQUAL
14165: IFTRUE 14169
14167: GO 14274
14169: POP
// begin for i = 1 to [ 6 , 6 , 8 ] [ Difficulty ] + ( wave div 2 ) do
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: DOUBLE
14176: LD_INT 1
14178: DEC
14179: ST_TO_ADDR
14180: LD_INT 6
14182: PUSH
14183: LD_INT 6
14185: PUSH
14186: LD_INT 8
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: LIST
14193: PUSH
14194: LD_OWVAR 67
14198: ARRAY
14199: PUSH
14200: LD_VAR 0 1
14204: PUSH
14205: LD_INT 2
14207: DIV
14208: PLUS
14209: PUSH
14210: FOR_TO
14211: IFFALSE 14219
// Sold ;
14213: CALL 14280 0 0
14217: GO 14210
14219: POP
14220: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14221: LD_ADDR_VAR 0 3
14225: PUSH
14226: DOUBLE
14227: LD_INT 1
14229: DEC
14230: ST_TO_ADDR
14231: LD_INT 3
14233: PUSH
14234: LD_INT 4
14236: PUSH
14237: LD_INT 4
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: LIST
14244: PUSH
14245: LD_OWVAR 67
14249: ARRAY
14250: PUSH
14251: LD_VAR 0 1
14255: PUSH
14256: LD_INT 2
14258: DIV
14259: PLUS
14260: PUSH
14261: FOR_TO
14262: IFFALSE 14270
// Tank ;
14264: CALL 14394 0 0
14268: GO 14261
14270: POP
14271: POP
// end ; end ;
14272: GO 14275
14274: POP
// end ;
14275: LD_VAR 0 2
14279: RET
// function Sold ( ) ; var un , skill ; begin
14280: LD_INT 0
14282: PPUSH
14283: PPUSH
14284: PPUSH
// InitHc ;
14285: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14289: LD_ADDR_VAR 0 3
14293: PUSH
14294: LD_INT 6
14296: PUSH
14297: LD_INT 7
14299: PUSH
14300: LD_INT 7
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: LIST
14307: PUSH
14308: LD_OWVAR 67
14312: ARRAY
14313: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14314: LD_INT 0
14316: PPUSH
14317: LD_INT 1
14319: PUSH
14320: LD_INT 9
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: PUSH
14327: LD_INT 1
14329: PPUSH
14330: LD_INT 2
14332: PPUSH
14333: CALL_OW 12
14337: ARRAY
14338: PPUSH
14339: LD_VAR 0 3
14343: PPUSH
14344: CALL_OW 380
// un := CreateHuman ;
14348: LD_ADDR_VAR 0 2
14352: PUSH
14353: CALL_OW 44
14357: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14358: LD_VAR 0 2
14362: PPUSH
14363: LD_INT 4
14365: PPUSH
14366: LD_INT 0
14368: PPUSH
14369: CALL_OW 49
// ru_force := ru_force ^ un ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_EXP 33
14382: PUSH
14383: LD_VAR 0 2
14387: ADD
14388: ST_TO_ADDR
// end ;
14389: LD_VAR 0 1
14393: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14394: LD_INT 0
14396: PPUSH
14397: PPUSH
14398: PPUSH
14399: PPUSH
14400: PPUSH
// InitHc ;
14401: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14405: LD_ADDR_VAR 0 5
14409: PUSH
14410: LD_INT 5
14412: PUSH
14413: LD_INT 6
14415: PUSH
14416: LD_INT 7
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: LIST
14423: PUSH
14424: LD_OWVAR 67
14428: ARRAY
14429: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14430: LD_ADDR_VAR 0 3
14434: PUSH
14435: LD_INT 22
14437: PUSH
14438: LD_INT 24
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: LD_INT 1
14447: PPUSH
14448: LD_INT 2
14450: PPUSH
14451: CALL_OW 12
14455: ARRAY
14456: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14457: LD_VAR 0 3
14461: PUSH
14462: LD_INT 22
14464: EQUAL
14465: IFFALSE 14500
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14467: LD_ADDR_VAR 0 4
14471: PUSH
14472: LD_INT 45
14474: PUSH
14475: LD_INT 43
14477: PUSH
14478: LD_INT 44
14480: PUSH
14481: EMPTY
14482: LIST
14483: LIST
14484: LIST
14485: PUSH
14486: LD_INT 1
14488: PPUSH
14489: LD_INT 3
14491: PPUSH
14492: CALL_OW 12
14496: ARRAY
14497: ST_TO_ADDR
14498: GO 14531
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14500: LD_ADDR_VAR 0 4
14504: PUSH
14505: LD_INT 46
14507: PUSH
14508: LD_INT 44
14510: PUSH
14511: LD_INT 45
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: LD_INT 1
14521: PPUSH
14522: LD_INT 3
14524: PPUSH
14525: CALL_OW 12
14529: ARRAY
14530: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_INT 3
14538: PPUSH
14539: LD_INT 3
14541: PPUSH
14542: LD_VAR 0 3
14546: PPUSH
14547: LD_INT 1
14549: PPUSH
14550: LD_INT 3
14552: PUSH
14553: LD_INT 3
14555: PUSH
14556: LD_INT 3
14558: PUSH
14559: LD_INT 1
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: PUSH
14568: LD_INT 1
14570: PPUSH
14571: LD_INT 4
14573: PPUSH
14574: CALL_OW 12
14578: ARRAY
14579: PPUSH
14580: LD_VAR 0 4
14584: PPUSH
14585: LD_INT 99
14587: PPUSH
14588: CALL 256 0 7
14592: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14593: LD_VAR 0 2
14597: PPUSH
14598: CALL_OW 263
14602: PUSH
14603: LD_INT 1
14605: EQUAL
14606: IFFALSE 14637
// begin PrepareHuman ( false , 3 , skill ) ;
14608: LD_INT 0
14610: PPUSH
14611: LD_INT 3
14613: PPUSH
14614: LD_VAR 0 5
14618: PPUSH
14619: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
14623: CALL_OW 44
14627: PPUSH
14628: LD_VAR 0 2
14632: PPUSH
14633: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
14637: LD_VAR 0 2
14641: PPUSH
14642: LD_INT 3
14644: PPUSH
14645: LD_INT 0
14647: PPUSH
14648: CALL_OW 49
// ru_force := ru_force ^ un ;
14652: LD_ADDR_EXP 33
14656: PUSH
14657: LD_EXP 33
14661: PUSH
14662: LD_VAR 0 2
14666: ADD
14667: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
14668: LD_VAR 0 2
14672: PPUSH
14673: LD_INT 126
14675: PPUSH
14676: LD_INT 158
14678: PPUSH
14679: CALL_OW 111
// Wait ( 0 0$3 ) ;
14683: LD_INT 105
14685: PPUSH
14686: CALL_OW 67
// ComStop ( un ) ;
14690: LD_VAR 0 2
14694: PPUSH
14695: CALL_OW 141
// end ;
14699: LD_VAR 0 1
14703: RET
// every 0 0$1 do var i , time , wave ;
14704: GO 14706
14706: DISABLE
14707: LD_INT 0
14709: PPUSH
14710: PPUSH
14711: PPUSH
// begin time := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
14712: LD_ADDR_VAR 0 2
14716: PUSH
14717: LD_INT 25200
14719: PUSH
14720: LD_INT 23100
14722: PUSH
14723: LD_INT 21000
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: LIST
14730: PUSH
14731: LD_OWVAR 67
14735: ARRAY
14736: ST_TO_ADDR
// wait ( time ) ;
14737: LD_VAR 0 2
14741: PPUSH
14742: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
14746: LD_ADDR_VAR 0 2
14750: PUSH
14751: LD_INT 17850
14753: PUSH
14754: LD_INT 16450
14756: PUSH
14757: LD_INT 15750
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: LIST
14764: PUSH
14765: LD_OWVAR 67
14769: ARRAY
14770: ST_TO_ADDR
// wave := 0 ;
14771: LD_ADDR_VAR 0 3
14775: PUSH
14776: LD_INT 0
14778: ST_TO_ADDR
// while true do
14779: LD_INT 1
14781: IFFALSE 14878
// begin wave := wave + 1 ;
14783: LD_ADDR_VAR 0 3
14787: PUSH
14788: LD_VAR 0 3
14792: PUSH
14793: LD_INT 1
14795: PLUS
14796: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
14797: LD_INT 22
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PPUSH
14807: CALL_OW 69
14811: IFFALSE 14840
// repeat wait ( 0 0$1 ) ;
14813: LD_INT 35
14815: PPUSH
14816: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
14820: LD_INT 22
14822: PUSH
14823: LD_INT 2
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 69
14834: PUSH
14835: LD_INT 0
14837: EQUAL
14838: IFFALSE 14813
// if ru_force < 20 then
14840: LD_EXP 33
14844: PUSH
14845: LD_INT 20
14847: LESS
14848: IFFALSE 14859
// PrepareAttack ( wave ) ;
14850: LD_VAR 0 3
14854: PPUSH
14855: CALL 13838 0 1
// ru_can_attack := true ;
14859: LD_ADDR_EXP 8
14863: PUSH
14864: LD_INT 1
14866: ST_TO_ADDR
// wait ( time ) ;
14867: LD_VAR 0 2
14871: PPUSH
14872: CALL_OW 67
// end ;
14876: GO 14779
// end ;
14878: PPOPN 3
14880: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
14881: LD_EXP 8
14885: PUSH
14886: LD_EXP 33
14890: AND
14891: IFFALSE 15633
14893: GO 14895
14895: DISABLE
14896: LD_INT 0
14898: PPUSH
14899: PPUSH
14900: PPUSH
14901: PPUSH
14902: PPUSH
14903: PPUSH
14904: PPUSH
14905: PPUSH
14906: PPUSH
// begin enable ;
14907: ENABLE
// points1 := [ 107 , 123 ] ;
14908: LD_ADDR_VAR 0 4
14912: PUSH
14913: LD_INT 107
14915: PUSH
14916: LD_INT 123
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
14923: LD_ADDR_VAR 0 5
14927: PUSH
14928: LD_INT 55
14930: PUSH
14931: LD_INT 42
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
14938: LD_ADDR_VAR 0 6
14942: PUSH
14943: LD_INT 102
14945: PUSH
14946: LD_INT 140
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: PUSH
14953: LD_INT 105
14955: PUSH
14956: LD_INT 142
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 129
14965: PUSH
14966: LD_INT 131
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: ST_TO_ADDR
// for i in ru_force do
14978: LD_ADDR_VAR 0 1
14982: PUSH
14983: LD_EXP 33
14987: PUSH
14988: FOR_IN
14989: IFFALSE 15631
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
14991: LD_ADDR_VAR 0 3
14995: PUSH
14996: LD_INT 81
14998: PUSH
14999: LD_INT 3
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PPUSH
15006: CALL_OW 69
15010: PPUSH
15011: LD_VAR 0 1
15015: PPUSH
15016: CALL_OW 74
15020: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 10 then
15021: LD_VAR 0 1
15025: PPUSH
15026: LD_VAR 0 3
15030: PPUSH
15031: CALL_OW 296
15035: PUSH
15036: LD_INT 10
15038: LESS
15039: IFFALSE 15184
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15041: LD_VAR 0 1
15045: PPUSH
15046: CALL_OW 247
15050: PUSH
15051: LD_INT 1
15053: EQUAL
15054: PUSH
15055: LD_VAR 0 1
15059: PPUSH
15060: CALL_OW 257
15064: PUSH
15065: LD_INT 1
15067: EQUAL
15068: AND
15069: PUSH
15070: LD_VAR 0 3
15074: PUSH
15075: LD_INT 21
15077: PUSH
15078: LD_INT 2
15080: PUSH
15081: EMPTY
15082: LIST
15083: LIST
15084: PUSH
15085: LD_INT 58
15087: PUSH
15088: EMPTY
15089: LIST
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: PPUSH
15095: CALL_OW 69
15099: IN
15100: AND
15101: IFFALSE 15119
// ComEnterUnit ( i , un ) else
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_VAR 0 3
15112: PPUSH
15113: CALL_OW 120
15117: GO 15182
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15119: LD_VAR 0 3
15123: PUSH
15124: LD_INT 21
15126: PUSH
15127: LD_INT 2
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: PUSH
15134: LD_INT 58
15136: PUSH
15137: EMPTY
15138: LIST
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PPUSH
15144: CALL_OW 69
15148: IN
15149: NOT
15150: IFFALSE 15168
// ComAttackUnit ( i , un ) else
15152: LD_VAR 0 1
15156: PPUSH
15157: LD_VAR 0 3
15161: PPUSH
15162: CALL_OW 115
15166: GO 15182
// ComAttackUnit ( i , JMM ) ;
15168: LD_VAR 0 1
15172: PPUSH
15173: LD_EXP 17
15177: PPUSH
15178: CALL_OW 115
// end else
15182: GO 15629
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
15184: LD_VAR 0 1
15188: PPUSH
15189: LD_VAR 0 4
15193: PUSH
15194: LD_INT 1
15196: ARRAY
15197: PPUSH
15198: LD_VAR 0 4
15202: PUSH
15203: LD_INT 2
15205: ARRAY
15206: PPUSH
15207: CALL_OW 297
15211: PUSH
15212: LD_VAR 0 1
15216: PPUSH
15217: LD_VAR 0 5
15221: PUSH
15222: LD_INT 1
15224: ARRAY
15225: PPUSH
15226: LD_VAR 0 5
15230: PUSH
15231: LD_INT 2
15233: ARRAY
15234: PPUSH
15235: CALL_OW 297
15239: GREATER
15240: PUSH
15241: LD_EXP 9
15245: AND
15246: PUSH
15247: LD_INT 9
15249: PPUSH
15250: LD_INT 22
15252: PUSH
15253: LD_INT 1
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: PPUSH
15260: CALL_OW 70
15264: PUSH
15265: LD_INT 0
15267: EQUAL
15268: OR
15269: IFFALSE 15300
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15271: LD_VAR 0 1
15275: PPUSH
15276: LD_VAR 0 5
15280: PUSH
15281: LD_INT 1
15283: ARRAY
15284: PPUSH
15285: LD_VAR 0 5
15289: PUSH
15290: LD_INT 2
15292: ARRAY
15293: PPUSH
15294: CALL_OW 114
15298: GO 15629
// begin if GetWeapon ( i ) = ru_rocket_launcher then
15300: LD_VAR 0 1
15304: PPUSH
15305: CALL_OW 264
15309: PUSH
15310: LD_INT 45
15312: EQUAL
15313: IFFALSE 15494
// begin dist := 9999 ;
15315: LD_ADDR_VAR 0 8
15319: PUSH
15320: LD_INT 9999
15322: ST_TO_ADDR
// xy := 0 ;
15323: LD_ADDR_VAR 0 9
15327: PUSH
15328: LD_INT 0
15330: ST_TO_ADDR
// for x in pointsr do
15331: LD_ADDR_VAR 0 7
15335: PUSH
15336: LD_VAR 0 6
15340: PUSH
15341: FOR_IN
15342: IFFALSE 15490
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15344: LD_VAR 0 1
15348: PPUSH
15349: LD_VAR 0 7
15353: PUSH
15354: LD_INT 1
15356: ARRAY
15357: PPUSH
15358: LD_VAR 0 7
15362: PUSH
15363: LD_INT 2
15365: ARRAY
15366: PPUSH
15367: CALL_OW 297
15371: PUSH
15372: LD_VAR 0 8
15376: LESS
15377: IFFALSE 15422
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15379: LD_ADDR_VAR 0 8
15383: PUSH
15384: LD_VAR 0 1
15388: PPUSH
15389: LD_VAR 0 7
15393: PUSH
15394: LD_INT 1
15396: ARRAY
15397: PPUSH
15398: LD_VAR 0 7
15402: PUSH
15403: LD_INT 2
15405: ARRAY
15406: PPUSH
15407: CALL_OW 297
15411: ST_TO_ADDR
// xy := x ;
15412: LD_ADDR_VAR 0 9
15416: PUSH
15417: LD_VAR 0 7
15421: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15422: LD_VAR 0 9
15426: PUSH
15427: LD_VAR 0 1
15431: PPUSH
15432: LD_VAR 0 9
15436: PUSH
15437: LD_INT 1
15439: ARRAY
15440: PPUSH
15441: LD_VAR 0 9
15445: PUSH
15446: LD_INT 2
15448: ARRAY
15449: PPUSH
15450: CALL_OW 297
15454: PUSH
15455: LD_INT 9
15457: GREATER
15458: AND
15459: IFFALSE 15488
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15461: LD_VAR 0 1
15465: PPUSH
15466: LD_VAR 0 9
15470: PUSH
15471: LD_INT 1
15473: ARRAY
15474: PPUSH
15475: LD_VAR 0 9
15479: PUSH
15480: LD_INT 2
15482: ARRAY
15483: PPUSH
15484: CALL_OW 114
// end ;
15488: GO 15341
15490: POP
15491: POP
// end else
15492: GO 15629
// begin un := NearestUnitToUnit ( un , all_units diff un ) ;
15494: LD_ADDR_VAR 0 3
15498: PUSH
15499: LD_VAR 0 3
15503: PPUSH
15504: LD_OWVAR 3
15508: PUSH
15509: LD_VAR 0 3
15513: DIFF
15514: PPUSH
15515: CALL_OW 74
15519: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15520: LD_VAR 0 3
15524: PUSH
15525: LD_INT 21
15527: PUSH
15528: LD_INT 2
15530: PUSH
15531: EMPTY
15532: LIST
15533: LIST
15534: PUSH
15535: LD_INT 58
15537: PUSH
15538: EMPTY
15539: LIST
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PPUSH
15545: CALL_OW 69
15549: IN
15550: PUSH
15551: LD_VAR 0 3
15555: PUSH
15556: LD_INT 22
15558: PUSH
15559: LD_INT 3
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 24
15568: PUSH
15569: LD_INT 249
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: PPUSH
15580: CALL_OW 69
15584: IN
15585: OR
15586: IFFALSE 15602
// ComAttackUnit ( i , un ) ;
15588: LD_VAR 0 1
15592: PPUSH
15593: LD_VAR 0 3
15597: PPUSH
15598: CALL_OW 115
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
15602: LD_VAR 0 1
15606: PPUSH
15607: LD_VAR 0 4
15611: PUSH
15612: LD_INT 1
15614: ARRAY
15615: PPUSH
15616: LD_VAR 0 4
15620: PUSH
15621: LD_INT 2
15623: ARRAY
15624: PPUSH
15625: CALL_OW 114
// end ; end ; end ; end ;
15629: GO 14988
15631: POP
15632: POP
// end ;
15633: PPOPN 9
15635: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
15636: LD_INT 22
15638: PUSH
15639: LD_INT 3
15641: PUSH
15642: EMPTY
15643: LIST
15644: LIST
15645: PUSH
15646: LD_INT 32
15648: PUSH
15649: LD_INT 1
15651: PUSH
15652: EMPTY
15653: LIST
15654: LIST
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: PPUSH
15660: CALL_OW 69
15664: IFFALSE 15752
15666: GO 15668
15668: DISABLE
15669: LD_INT 0
15671: PPUSH
15672: PPUSH
// begin enable ;
15673: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
15674: LD_ADDR_VAR 0 2
15678: PUSH
15679: LD_INT 22
15681: PUSH
15682: LD_INT 3
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: PUSH
15689: LD_INT 32
15691: PUSH
15692: LD_INT 1
15694: PUSH
15695: EMPTY
15696: LIST
15697: LIST
15698: PUSH
15699: EMPTY
15700: LIST
15701: LIST
15702: PPUSH
15703: CALL_OW 69
15707: ST_TO_ADDR
// for i in tmp do
15708: LD_ADDR_VAR 0 1
15712: PUSH
15713: LD_VAR 0 2
15717: PUSH
15718: FOR_IN
15719: IFFALSE 15750
// if GetFuel ( i ) < 12 then
15721: LD_VAR 0 1
15725: PPUSH
15726: CALL_OW 261
15730: PUSH
15731: LD_INT 12
15733: LESS
15734: IFFALSE 15748
// SetFuel ( i , 12 ) ;
15736: LD_VAR 0 1
15740: PPUSH
15741: LD_INT 12
15743: PPUSH
15744: CALL_OW 240
15748: GO 15718
15750: POP
15751: POP
// end ;
15752: PPOPN 2
15754: END
