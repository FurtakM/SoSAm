// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 202 0 0
// PrepareNature ;
  16: CALL 377 0 0
// PrepareRussian ;
  20: CALL 13114 0 0
// PrepareAmerican ;
  24: CALL 1110 0 0
// PrepareOvsyenko ;
  28: CALL 1733 0 0
// Action ;
  32: CALL 2673 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: PUSH
  92: LD_INT 105000
  94: PUSH
  95: LD_INT 111300
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: LIST
 102: PUSH
 103: LD_OWVAR 67
 107: ARRAY
 108: ST_TO_ADDR
// ru_can_attack := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// ar_can_arrive := false ;
 125: LD_ADDR_EXP 10
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// ar_spawned := false ;
 133: LD_ADDR_EXP 11
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// player_want_mortar := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// player_want_info := false ;
 149: LD_ADDR_EXP 13
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// player_get_mortar := false ;
 157: LD_ADDR_EXP 14
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// player_get_info := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// player_attacked_ar := false ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// can_end := false ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// blocked := false ;
 189: LD_ADDR_EXP 18
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// end ;
 197: LD_VAR 0 1
 201: RET
// function DebugMode ; begin
 202: LD_INT 0
 204: PPUSH
// if not debug then
 205: LD_EXP 2
 209: NOT
 210: IFFALSE 214
// exit ;
 212: GO 221
// FogOff ( 1 ) ;
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 344
// end ; end_of_file
 221: LD_VAR 0 1
 225: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
// if exist_mode then
 230: LD_VAR 0 2
 234: IFFALSE 259
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_VAR 0 3
 245: PUSH
 246: LD_VAR 0 1
 250: STR
 251: PPUSH
 252: CALL_OW 34
 256: ST_TO_ADDR
 257: GO 274
// unit := NewCharacter ( ident ) ;
 259: LD_ADDR_VAR 0 5
 263: PUSH
 264: LD_VAR 0 1
 268: PPUSH
 269: CALL_OW 25
 273: ST_TO_ADDR
// result := unit ;
 274: LD_ADDR_VAR 0 4
 278: PUSH
 279: LD_VAR 0 5
 283: ST_TO_ADDR
// end ;
 284: LD_VAR 0 4
 288: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 289: LD_INT 0
 291: PPUSH
// uc_side := side ;
 292: LD_ADDR_OWVAR 20
 296: PUSH
 297: LD_VAR 0 1
 301: ST_TO_ADDR
// uc_nation := nation ;
 302: LD_ADDR_OWVAR 21
 306: PUSH
 307: LD_VAR 0 2
 311: ST_TO_ADDR
// vc_chassis := chassis ;
 312: LD_ADDR_OWVAR 37
 316: PUSH
 317: LD_VAR 0 3
 321: ST_TO_ADDR
// vc_engine := engine ;
 322: LD_ADDR_OWVAR 39
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// vc_control := control ;
 332: LD_ADDR_OWVAR 38
 336: PUSH
 337: LD_VAR 0 5
 341: ST_TO_ADDR
// vc_weapon := weapon ;
 342: LD_ADDR_OWVAR 40
 346: PUSH
 347: LD_VAR 0 6
 351: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 352: LD_ADDR_OWVAR 41
 356: PUSH
 357: LD_VAR 0 7
 361: ST_TO_ADDR
// result := CreateVehicle ;
 362: LD_ADDR_VAR 0 8
 366: PUSH
 367: CALL_OW 45
 371: ST_TO_ADDR
// end ;
 372: LD_VAR 0 8
 376: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 377: LD_INT 0
 379: PPUSH
 380: PPUSH
 381: PPUSH
 382: PPUSH
// uc_side = 0 ;
 383: LD_ADDR_OWVAR 20
 387: PUSH
 388: LD_INT 0
 390: ST_TO_ADDR
// uc_nation = 0 ;
 391: LD_ADDR_OWVAR 21
 395: PUSH
 396: LD_INT 0
 398: ST_TO_ADDR
// nat_area := natureArea ;
 399: LD_ADDR_VAR 0 4
 403: PUSH
 404: LD_INT 1
 406: ST_TO_ADDR
// InitHc ;
 407: CALL_OW 19
// for i = 1 to 4 do
 411: LD_ADDR_VAR 0 2
 415: PUSH
 416: DOUBLE
 417: LD_INT 1
 419: DEC
 420: ST_TO_ADDR
 421: LD_INT 4
 423: PUSH
 424: FOR_TO
 425: IFFALSE 480
// begin hc_class = 18 ;
 427: LD_ADDR_OWVAR 28
 431: PUSH
 432: LD_INT 18
 434: ST_TO_ADDR
// hc_gallery =  ;
 435: LD_ADDR_OWVAR 33
 439: PUSH
 440: LD_STRING 
 442: ST_TO_ADDR
// hc_face_number = 1 ;
 443: LD_ADDR_OWVAR 34
 447: PUSH
 448: LD_INT 1
 450: ST_TO_ADDR
// animal := CreateHuman ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: CALL_OW 44
 460: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 461: LD_VAR 0 3
 465: PPUSH
 466: LD_VAR 0 4
 470: PPUSH
 471: LD_INT 0
 473: PPUSH
 474: CALL_OW 49
// end ;
 478: GO 424
 480: POP
 481: POP
// for i = 1 to 4 do
 482: LD_ADDR_VAR 0 2
 486: PUSH
 487: DOUBLE
 488: LD_INT 1
 490: DEC
 491: ST_TO_ADDR
 492: LD_INT 4
 494: PUSH
 495: FOR_TO
 496: IFFALSE 568
// begin hc_class = class_tiger ;
 498: LD_ADDR_OWVAR 28
 502: PUSH
 503: LD_INT 14
 505: ST_TO_ADDR
// hc_gallery =  ;
 506: LD_ADDR_OWVAR 33
 510: PUSH
 511: LD_STRING 
 513: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 514: LD_ADDR_OWVAR 35
 518: PUSH
 519: LD_INT 5
 521: NEG
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL_OW 12
 530: ST_TO_ADDR
// hc_face_number = 3 ;
 531: LD_ADDR_OWVAR 34
 535: PUSH
 536: LD_INT 3
 538: ST_TO_ADDR
// animal := CreateHuman ;
 539: LD_ADDR_VAR 0 3
 543: PUSH
 544: CALL_OW 44
 548: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 549: LD_VAR 0 3
 553: PPUSH
 554: LD_VAR 0 4
 558: PPUSH
 559: LD_INT 0
 561: PPUSH
 562: CALL_OW 49
// end ;
 566: GO 495
 568: POP
 569: POP
// for i = 1 to 8 do
 570: LD_ADDR_VAR 0 2
 574: PUSH
 575: DOUBLE
 576: LD_INT 1
 578: DEC
 579: ST_TO_ADDR
 580: LD_INT 8
 582: PUSH
 583: FOR_TO
 584: IFFALSE 687
// begin hc_class = class_apeman ;
 586: LD_ADDR_OWVAR 28
 590: PUSH
 591: LD_INT 12
 593: ST_TO_ADDR
// hc_gallery =  ;
 594: LD_ADDR_OWVAR 33
 598: PUSH
 599: LD_STRING 
 601: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 602: LD_ADDR_OWVAR 35
 606: PUSH
 607: LD_INT 2
 609: NEG
 610: PPUSH
 611: LD_INT 2
 613: PPUSH
 614: CALL_OW 12
 618: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 619: LD_ADDR_OWVAR 31
 623: PUSH
 624: LD_INT 1
 626: PPUSH
 627: LD_INT 3
 629: PPUSH
 630: CALL_OW 12
 634: PUSH
 635: LD_INT 1
 637: PPUSH
 638: LD_INT 3
 640: PPUSH
 641: CALL_OW 12
 645: PUSH
 646: LD_INT 0
 648: PUSH
 649: LD_INT 0
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: LIST
 657: ST_TO_ADDR
// animal := CreateHuman ;
 658: LD_ADDR_VAR 0 3
 662: PUSH
 663: CALL_OW 44
 667: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 668: LD_VAR 0 3
 672: PPUSH
 673: LD_VAR 0 4
 677: PPUSH
 678: LD_INT 0
 680: PPUSH
 681: CALL_OW 49
// end ;
 685: GO 583
 687: POP
 688: POP
// for i = 1 to 6 do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: DOUBLE
 695: LD_INT 1
 697: DEC
 698: ST_TO_ADDR
 699: LD_INT 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 758
// begin hc_class = 13 ;
 705: LD_ADDR_OWVAR 28
 709: PUSH
 710: LD_INT 13
 712: ST_TO_ADDR
// hc_gallery =  ;
 713: LD_ADDR_OWVAR 33
 717: PUSH
 718: LD_STRING 
 720: ST_TO_ADDR
// hc_face_number = 4 ;
 721: LD_ADDR_OWVAR 34
 725: PUSH
 726: LD_INT 4
 728: ST_TO_ADDR
// animal := CreateHuman ;
 729: LD_ADDR_VAR 0 3
 733: PUSH
 734: CALL_OW 44
 738: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 739: LD_VAR 0 3
 743: PPUSH
 744: LD_VAR 0 4
 748: PPUSH
 749: LD_INT 0
 751: PPUSH
 752: CALL_OW 49
// end ;
 756: GO 702
 758: POP
 759: POP
// vc_chassis := 31 ;
 760: LD_ADDR_OWVAR 37
 764: PUSH
 765: LD_INT 31
 767: ST_TO_ADDR
// vc_control := control_rider ;
 768: LD_ADDR_OWVAR 38
 772: PUSH
 773: LD_INT 4
 775: ST_TO_ADDR
// animal := CreateVehicle ;
 776: LD_ADDR_VAR 0 3
 780: PUSH
 781: CALL_OW 45
 785: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 786: LD_VAR 0 3
 790: PPUSH
 791: LD_INT 21
 793: PPUSH
 794: LD_INT 22
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 48
// end ;
 804: LD_VAR 0 1
 808: RET
// export function GetTerminalCargo ; begin
 809: LD_INT 0
 811: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 812: LD_ADDR_VAR 0 1
 816: PUSH
 817: LD_EXP 3
 821: PPUSH
 822: CALL_OW 274
 826: PPUSH
 827: LD_INT 3
 829: PPUSH
 830: CALL_OW 275
 834: ST_TO_ADDR
// end ;
 835: LD_VAR 0 1
 839: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 840: LD_INT 0
 842: PPUSH
 843: PPUSH
 844: PPUSH
// result := 0 ;
 845: LD_ADDR_VAR 0 2
 849: PUSH
 850: LD_INT 0
 852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 853: LD_ADDR_VAR 0 4
 857: PUSH
 858: LD_INT 22
 860: PUSH
 861: LD_VAR 0 1
 865: PUSH
 866: EMPTY
 867: LIST
 868: LIST
 869: PUSH
 870: LD_INT 2
 872: PUSH
 873: LD_INT 30
 875: PUSH
 876: LD_INT 0
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 30
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PPUSH
 902: CALL_OW 69
 906: ST_TO_ADDR
// if not tmp then
 907: LD_VAR 0 4
 911: NOT
 912: IFFALSE 916
// exit ;
 914: GO 962
// for i in tmp do
 916: LD_ADDR_VAR 0 3
 920: PUSH
 921: LD_VAR 0 4
 925: PUSH
 926: FOR_IN
 927: IFFALSE 960
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 929: LD_ADDR_VAR 0 2
 933: PUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_VAR 0 3
 943: PPUSH
 944: CALL_OW 274
 948: PPUSH
 949: LD_INT 3
 951: PPUSH
 952: CALL_OW 275
 956: PLUS
 957: ST_TO_ADDR
 958: GO 926
 960: POP
 961: POP
// end ;
 962: LD_VAR 0 2
 966: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 967: LD_INT 0
 969: PPUSH
 970: PPUSH
// area = ListEnvironmentArea ( area ) ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_VAR 0 2
 980: PPUSH
 981: CALL_OW 353
 985: ST_TO_ADDR
// if bulldozer > 0 then
 986: LD_VAR 0 1
 990: PUSH
 991: LD_INT 0
 993: GREATER
 994: IFFALSE 1105
// for i = area downto 1 do
 996: LD_ADDR_VAR 0 4
1000: PUSH
1001: DOUBLE
1002: LD_VAR 0 2
1006: INC
1007: ST_TO_ADDR
1008: LD_INT 1
1010: PUSH
1011: FOR_DOWNTO
1012: IFFALSE 1103
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1014: LD_VAR 0 2
1018: PUSH
1019: LD_VAR 0 4
1023: ARRAY
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_VAR 0 4
1038: ARRAY
1039: PUSH
1040: LD_INT 2
1042: ARRAY
1043: PPUSH
1044: CALL_OW 351
1048: IFFALSE 1101
// if not HasTask ( bulldozer ) then
1050: LD_VAR 0 1
1054: PPUSH
1055: CALL_OW 314
1059: NOT
1060: IFFALSE 1101
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1062: LD_VAR 0 1
1066: PPUSH
1067: LD_VAR 0 2
1071: PUSH
1072: LD_VAR 0 4
1076: ARRAY
1077: PUSH
1078: LD_INT 1
1080: ARRAY
1081: PPUSH
1082: LD_VAR 0 2
1086: PUSH
1087: LD_VAR 0 4
1091: ARRAY
1092: PUSH
1093: LD_INT 2
1095: ARRAY
1096: PPUSH
1097: CALL_OW 171
1101: GO 1011
1103: POP
1104: POP
// end ; end_of_file
1105: LD_VAR 0 3
1109: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1110: LD_INT 0
1112: PPUSH
1113: PPUSH
1114: PPUSH
1115: PPUSH
1116: PPUSH
// uc_side := 1 ;
1117: LD_ADDR_OWVAR 20
1121: PUSH
1122: LD_INT 1
1124: ST_TO_ADDR
// uc_nation := 1 ;
1125: LD_ADDR_OWVAR 21
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1133: LD_ADDR_EXP 19
1137: PUSH
1138: LD_STRING JMM
1140: PPUSH
1141: LD_EXP 2
1145: NOT
1146: PPUSH
1147: LD_STRING 08_
1149: PPUSH
1150: CALL 226 0 3
1154: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1155: LD_ADDR_VAR 0 4
1159: PUSH
1160: LD_INT 1
1162: PPUSH
1163: LD_INT 1
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: LD_INT 2
1171: PPUSH
1172: LD_INT 1
1174: PPUSH
1175: LD_INT 5
1177: PPUSH
1178: LD_INT 55
1180: PPUSH
1181: CALL 289 0 7
1185: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1186: LD_VAR 0 4
1190: PPUSH
1191: LD_INT 3
1193: PPUSH
1194: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1198: LD_VAR 0 4
1202: PPUSH
1203: LD_INT 43
1205: PPUSH
1206: LD_INT 3
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1216: LD_EXP 19
1220: PPUSH
1221: LD_VAR 0 4
1225: PPUSH
1226: CALL_OW 52
// tmp := [ ] ;
1230: LD_ADDR_VAR 0 2
1234: PUSH
1235: EMPTY
1236: ST_TO_ADDR
// uc_side := 4 ;
1237: LD_ADDR_OWVAR 20
1241: PUSH
1242: LD_INT 4
1244: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1245: LD_ADDR_OWVAR 33
1249: PUSH
1250: LD_STRING SecondCharsGal
1252: ST_TO_ADDR
// hc_class := 2 ;
1253: LD_ADDR_OWVAR 28
1257: PUSH
1258: LD_INT 2
1260: ST_TO_ADDR
// hc_sex := sex_female ;
1261: LD_ADDR_OWVAR 27
1265: PUSH
1266: LD_INT 2
1268: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1269: LD_ADDR_OWVAR 30
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: LD_INT 1
1279: PUSH
1280: LD_INT 1
1282: PUSH
1283: LD_INT 0
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1292: LD_ADDR_OWVAR 31
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: LD_INT 4
1302: PUSH
1303: LD_INT 2
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1315: LD_ADDR_OWVAR 29
1319: PUSH
1320: LD_INT 10
1322: PUSH
1323: LD_INT 11
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1330: LD_ADDR_OWVAR 26
1334: PUSH
1335: LD_STRING Naoma Goichman
1337: ST_TO_ADDR
// hc_face_number := 43 ;
1338: LD_ADDR_OWVAR 34
1342: PUSH
1343: LD_INT 43
1345: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1346: LD_ADDR_VAR 0 2
1350: PUSH
1351: LD_VAR 0 2
1355: PUSH
1356: CALL_OW 44
1360: ADD
1361: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1362: LD_ADDR_OWVAR 30
1366: PUSH
1367: LD_INT 0
1369: PUSH
1370: LD_INT 2
1372: PUSH
1373: LD_INT 0
1375: PUSH
1376: LD_INT 1
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1385: LD_ADDR_OWVAR 31
1389: PUSH
1390: LD_INT 0
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1408: LD_ADDR_OWVAR 29
1412: PUSH
1413: LD_INT 10
1415: PUSH
1416: LD_INT 10
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1423: LD_ADDR_OWVAR 26
1427: PUSH
1428: LD_STRING Magdalene Glance
1430: ST_TO_ADDR
// hc_face_number := 44 ;
1431: LD_ADDR_OWVAR 34
1435: PUSH
1436: LD_INT 44
1438: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1439: LD_ADDR_VAR 0 2
1443: PUSH
1444: LD_VAR 0 2
1448: PUSH
1449: CALL_OW 44
1453: ADD
1454: ST_TO_ADDR
// hc_sex := sex_male ;
1455: LD_ADDR_OWVAR 27
1459: PUSH
1460: LD_INT 1
1462: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1463: LD_ADDR_OWVAR 30
1467: PUSH
1468: LD_INT 2
1470: PUSH
1471: LD_INT 2
1473: PUSH
1474: LD_INT 0
1476: PUSH
1477: LD_INT 0
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1486: LD_ADDR_OWVAR 31
1490: PUSH
1491: LD_INT 3
1493: PUSH
1494: LD_INT 4
1496: PUSH
1497: LD_INT 1
1499: PUSH
1500: LD_INT 0
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: LIST
1508: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1509: LD_ADDR_OWVAR 29
1513: PUSH
1514: LD_INT 12
1516: PUSH
1517: LD_INT 10
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: ST_TO_ADDR
// hc_name := Steve Holland ;
1524: LD_ADDR_OWVAR 26
1528: PUSH
1529: LD_STRING Steve Holland
1531: ST_TO_ADDR
// hc_face_number := 60 ;
1532: LD_ADDR_OWVAR 34
1536: PUSH
1537: LD_INT 60
1539: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_VAR 0 2
1549: PUSH
1550: CALL_OW 44
1554: ADD
1555: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1556: LD_ADDR_EXP 24
1560: PUSH
1561: LD_VAR 0 2
1565: PUSH
1566: LD_INT 0
1568: DIFF
1569: ST_TO_ADDR
// for un in alpha_engs do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: LD_EXP 24
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1606
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1583: LD_VAR 0 3
1587: PPUSH
1588: LD_INT 52
1590: PPUSH
1591: LD_INT 35
1593: PPUSH
1594: LD_INT 3
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 50
1604: GO 1580
1606: POP
1607: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1608: LD_ADDR_VAR 0 2
1612: PUSH
1613: DOUBLE
1614: LD_INT 1
1616: DEC
1617: ST_TO_ADDR
1618: LD_INT 1
1620: PUSH
1621: LD_STRING 06_crates_1
1623: PPUSH
1624: LD_INT 0
1626: PPUSH
1627: CALL_OW 30
1631: PLUS
1632: PUSH
1633: LD_INT 2
1635: MUL
1636: PUSH
1637: FOR_TO
1638: IFFALSE 1664
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 5
1645: PPUSH
1646: LD_INT 56
1648: PPUSH
1649: LD_INT 40
1651: PPUSH
1652: LD_INT 2
1654: PPUSH
1655: LD_INT 0
1657: PPUSH
1658: CALL_OW 60
1662: GO 1637
1664: POP
1665: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1666: LD_STRING GammaCommander
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 30
1676: PUSH
1677: LD_INT 3
1679: LESS
1680: IFFALSE 1701
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1682: LD_ADDR_EXP 23
1686: PUSH
1687: LD_STRING VanHouten
1689: PPUSH
1690: LD_INT 0
1692: PPUSH
1693: LD_STRING 
1695: PPUSH
1696: CALL 226 0 3
1700: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1701: LD_ADDR_EXP 26
1705: PUSH
1706: LD_STRING Powell
1708: PPUSH
1709: LD_INT 0
1711: PPUSH
1712: LD_STRING 
1714: PPUSH
1715: CALL 226 0 3
1719: ST_TO_ADDR
// InitHc ;
1720: CALL_OW 19
// InitUc ;
1724: CALL_OW 18
// end ;
1728: LD_VAR 0 1
1732: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1733: LD_INT 0
1735: PPUSH
1736: PPUSH
1737: PPUSH
1738: PPUSH
1739: PPUSH
// uc_side := 4 ;
1740: LD_ADDR_OWVAR 20
1744: PUSH
1745: LD_INT 4
1747: ST_TO_ADDR
// uc_nation := 3 ;
1748: LD_ADDR_OWVAR 21
1752: PUSH
1753: LD_INT 3
1755: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1756: LD_ADDR_VAR 0 4
1760: PUSH
1761: LD_STRING 09_ovsyenko_base
1763: PPUSH
1764: LD_INT 0
1766: PUSH
1767: LD_INT 101
1769: PUSH
1770: LD_INT 118
1772: PUSH
1773: LD_INT 2
1775: PUSH
1776: LD_INT 500
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 31
1788: PUSH
1789: LD_INT 109
1791: PUSH
1792: LD_INT 114
1794: PUSH
1795: LD_INT 4
1797: PUSH
1798: LD_INT 500
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: PUSH
1808: LD_INT 31
1810: PUSH
1811: LD_INT 115
1813: PUSH
1814: LD_INT 132
1816: PUSH
1817: LD_INT 5
1819: PUSH
1820: LD_INT 500
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: LD_INT 31
1832: PUSH
1833: LD_INT 98
1835: PUSH
1836: LD_INT 120
1838: PUSH
1839: LD_INT 1
1841: PUSH
1842: LD_INT 500
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 30
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 2
1867: PUSH
1868: LD_VAR 0 4
1872: PUSH
1873: FOR_IN
1874: IFFALSE 2030
// begin bc_type := i [ 1 ] ;
1876: LD_ADDR_OWVAR 42
1880: PUSH
1881: LD_VAR 0 2
1885: PUSH
1886: LD_INT 1
1888: ARRAY
1889: ST_TO_ADDR
// bc_level := 3 ;
1890: LD_ADDR_OWVAR 43
1894: PUSH
1895: LD_INT 3
1897: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1898: LD_ADDR_VAR 0 3
1902: PUSH
1903: LD_VAR 0 2
1907: PUSH
1908: LD_INT 2
1910: ARRAY
1911: PPUSH
1912: LD_VAR 0 2
1916: PUSH
1917: LD_INT 3
1919: ARRAY
1920: PPUSH
1921: LD_VAR 0 2
1925: PUSH
1926: LD_INT 4
1928: ARRAY
1929: PPUSH
1930: CALL_OW 47
1934: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1935: LD_VAR 0 3
1939: PPUSH
1940: CALL_OW 266
1944: PUSH
1945: LD_INT 0
1947: EQUAL
1948: IFFALSE 1982
// begin SetBName ( b , ovsyenko ) ;
1950: LD_VAR 0 3
1954: PPUSH
1955: LD_STRING ovsyenko
1957: PPUSH
1958: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: CALL_OW 274
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: LD_INT 50
1977: PPUSH
1978: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1982: LD_VAR 0 2
1986: PUSH
1987: LD_INT 5
1989: ARRAY
1990: PUSH
1991: LD_INT 250
1993: LESS
1994: IFFALSE 2010
// SetLives ( b , 333 ) else
1996: LD_VAR 0 3
2000: PPUSH
2001: LD_INT 333
2003: PPUSH
2004: CALL_OW 234
2008: GO 2028
// SetLives ( b , i [ 5 ] ) ;
2010: LD_VAR 0 3
2014: PPUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 5
2022: ARRAY
2023: PPUSH
2024: CALL_OW 234
// end ;
2028: GO 1873
2030: POP
2031: POP
// uc_nation := 1 ;
2032: LD_ADDR_OWVAR 21
2036: PUSH
2037: LD_INT 1
2039: ST_TO_ADDR
// tmp := [ ] ;
2040: LD_ADDR_VAR 0 4
2044: PUSH
2045: EMPTY
2046: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2047: LD_ADDR_EXP 20
2051: PUSH
2052: LD_STRING Gary
2054: PPUSH
2055: LD_EXP 2
2059: NOT
2060: PPUSH
2061: LD_STRING 
2063: PPUSH
2064: CALL 226 0 3
2068: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: LD_VAR 0 4
2078: PUSH
2079: LD_EXP 20
2083: ADD
2084: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2085: LD_ADDR_EXP 21
2089: PUSH
2090: LD_STRING Bobby
2092: PPUSH
2093: LD_EXP 2
2097: NOT
2098: PPUSH
2099: LD_STRING 08_
2101: PPUSH
2102: CALL 226 0 3
2106: ST_TO_ADDR
// if not Bobby then
2107: LD_EXP 21
2111: NOT
2112: IFFALSE 2136
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2114: LD_ADDR_EXP 21
2118: PUSH
2119: LD_STRING Bobby
2121: PPUSH
2122: LD_EXP 2
2126: NOT
2127: PPUSH
2128: LD_STRING 03_
2130: PPUSH
2131: CALL 226 0 3
2135: ST_TO_ADDR
// if Bobby then
2136: LD_EXP 21
2140: IFFALSE 2158
// tmp := tmp ^ Bobby ;
2142: LD_ADDR_VAR 0 4
2146: PUSH
2147: LD_VAR 0 4
2151: PUSH
2152: LD_EXP 21
2156: ADD
2157: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2158: LD_ADDR_EXP 22
2162: PUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: LD_EXP 2
2170: NOT
2171: PPUSH
2172: LD_STRING 08_
2174: PPUSH
2175: CALL 226 0 3
2179: ST_TO_ADDR
// if not Cyrus then
2180: LD_EXP 22
2184: NOT
2185: IFFALSE 2209
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2187: LD_ADDR_EXP 22
2191: PUSH
2192: LD_STRING Cyrus
2194: PPUSH
2195: LD_EXP 2
2199: NOT
2200: PPUSH
2201: LD_STRING 03_
2203: PPUSH
2204: CALL 226 0 3
2208: ST_TO_ADDR
// if Cyrus then
2209: LD_EXP 22
2213: IFFALSE 2231
// tmp := tmp ^ Cyrus ;
2215: LD_ADDR_VAR 0 4
2219: PUSH
2220: LD_VAR 0 4
2224: PUSH
2225: LD_EXP 22
2229: ADD
2230: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2231: LD_ADDR_VAR 0 4
2235: PUSH
2236: LD_VAR 0 4
2240: PUSH
2241: LD_STRING 09_prev_squad
2243: PPUSH
2244: CALL_OW 31
2248: ADD
2249: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2250: LD_STRING 09_prev_squad
2252: PPUSH
2253: CALL_OW 40
// tmp := tmp diff 0 ;
2257: LD_ADDR_VAR 0 4
2261: PUSH
2262: LD_VAR 0 4
2266: PUSH
2267: LD_INT 0
2269: DIFF
2270: ST_TO_ADDR
// if debug then
2271: LD_EXP 2
2275: IFFALSE 2326
// begin for i = 1 to 6 do
2277: LD_ADDR_VAR 0 2
2281: PUSH
2282: DOUBLE
2283: LD_INT 1
2285: DEC
2286: ST_TO_ADDR
2287: LD_INT 6
2289: PUSH
2290: FOR_TO
2291: IFFALSE 2324
// begin PrepareHuman ( false , 1 , 6 ) ;
2293: LD_INT 0
2295: PPUSH
2296: LD_INT 1
2298: PPUSH
2299: LD_INT 6
2301: PPUSH
2302: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2306: LD_ADDR_VAR 0 4
2310: PUSH
2311: LD_VAR 0 4
2315: PUSH
2316: CALL_OW 44
2320: ADD
2321: ST_TO_ADDR
// end ;
2322: GO 2290
2324: POP
2325: POP
// end ; for i in tmp do
2326: LD_ADDR_VAR 0 2
2330: PUSH
2331: LD_VAR 0 4
2335: PUSH
2336: FOR_IN
2337: IFFALSE 2396
// begin if GetClass ( i ) in [ 2 , 3 ] then
2339: LD_VAR 0 2
2343: PPUSH
2344: CALL_OW 257
2348: PUSH
2349: LD_INT 2
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: EMPTY
2356: LIST
2357: LIST
2358: IN
2359: IFFALSE 2373
// SetClass ( i , 1 ) ;
2361: LD_VAR 0 2
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2373: LD_VAR 0 2
2377: PPUSH
2378: LD_INT 106
2380: PPUSH
2381: LD_INT 122
2383: PPUSH
2384: LD_INT 5
2386: PPUSH
2387: LD_INT 0
2389: PPUSH
2390: CALL_OW 50
// end ;
2394: GO 2336
2396: POP
2397: POP
// tmp := tmp diff Gary ;
2398: LD_ADDR_VAR 0 4
2402: PUSH
2403: LD_VAR 0 4
2407: PUSH
2408: LD_EXP 20
2412: DIFF
2413: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2414: LD_ADDR_VAR 0 3
2418: PUSH
2419: LD_INT 22
2421: PUSH
2422: LD_INT 4
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: LD_INT 30
2431: PUSH
2432: LD_INT 31
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PPUSH
2443: CALL_OW 69
2447: ST_TO_ADDR
// for i = 1 to b do
2448: LD_ADDR_VAR 0 2
2452: PUSH
2453: DOUBLE
2454: LD_INT 1
2456: DEC
2457: ST_TO_ADDR
2458: LD_VAR 0 3
2462: PUSH
2463: FOR_TO
2464: IFFALSE 2494
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2466: LD_VAR 0 4
2470: PUSH
2471: LD_VAR 0 2
2475: ARRAY
2476: PPUSH
2477: LD_VAR 0 3
2481: PUSH
2482: LD_VAR 0 2
2486: ARRAY
2487: PPUSH
2488: CALL_OW 120
// end ;
2492: GO 2463
2494: POP
2495: POP
// InitHc ;
2496: CALL_OW 19
// InitUc ;
2500: CALL_OW 18
// end ;
2504: LD_VAR 0 1
2508: RET
// export function PowellTransport ; var i , un ; begin
2509: LD_INT 0
2511: PPUSH
2512: PPUSH
2513: PPUSH
// uc_side := 4 ;
2514: LD_ADDR_OWVAR 20
2518: PUSH
2519: LD_INT 4
2521: ST_TO_ADDR
// uc_nation := 1 ;
2522: LD_ADDR_OWVAR 21
2526: PUSH
2527: LD_INT 1
2529: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2530: LD_INT 1
2532: PPUSH
2533: LD_INT 3
2535: PPUSH
2536: LD_INT 6
2538: PPUSH
2539: CALL_OW 380
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2551: LD_ADDR_OWVAR 33
2555: PUSH
2556: LD_STRING SecondCharsGal
2558: ST_TO_ADDR
// hc_face_number := 30 ;
2559: LD_ADDR_OWVAR 34
2563: PUSH
2564: LD_INT 30
2566: ST_TO_ADDR
// powell_trans := CreateHuman ;
2567: LD_ADDR_EXP 25
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// hc_face_number := 31 ;
2577: LD_ADDR_OWVAR 34
2581: PUSH
2582: LD_INT 31
2584: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2585: LD_ADDR_EXP 25
2589: PUSH
2590: LD_EXP 25
2594: PUSH
2595: CALL_OW 44
2599: ADD
2600: ST_TO_ADDR
// for i = 1 to 2 do
2601: LD_ADDR_VAR 0 2
2605: PUSH
2606: DOUBLE
2607: LD_INT 1
2609: DEC
2610: ST_TO_ADDR
2611: LD_INT 2
2613: PUSH
2614: FOR_TO
2615: IFFALSE 2666
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_INT 4
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 1
2633: PPUSH
2634: LD_INT 1
2636: PPUSH
2637: LD_INT 12
2639: PPUSH
2640: LD_INT 66
2642: PPUSH
2643: CALL 289 0 7
2647: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2648: LD_ADDR_EXP 25
2652: PUSH
2653: LD_EXP 25
2657: PUSH
2658: LD_VAR 0 3
2662: ADD
2663: ST_TO_ADDR
// end ;
2664: GO 2614
2666: POP
2667: POP
// end ; end_of_file
2668: LD_VAR 0 1
2672: RET
// export function Action ; var i , veh ; begin
2673: LD_INT 0
2675: PPUSH
2676: PPUSH
2677: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2678: LD_EXP 24
2682: PPUSH
2683: LD_INT 0
2685: PPUSH
2686: LD_INT 50
2688: PPUSH
2689: LD_INT 38
2691: PPUSH
2692: LD_INT 2
2694: PPUSH
2695: CALL_OW 145
// InGameOn ;
2699: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2703: LD_INT 43
2705: PPUSH
2706: LD_INT 9
2708: PPUSH
2709: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2713: LD_EXP 19
2717: PPUSH
2718: LD_INT 54
2720: PPUSH
2721: LD_INT 34
2723: PPUSH
2724: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2728: LD_EXP 19
2732: PPUSH
2733: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_EXP 24
2746: PUSH
2747: LD_INT 1
2749: ARRAY
2750: PPUSH
2751: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2755: LD_INT 35
2757: PPUSH
2758: CALL_OW 67
// until See ( 4 , JMM ) ;
2762: LD_INT 4
2764: PPUSH
2765: LD_EXP 19
2769: PPUSH
2770: CALL_OW 292
2774: IFFALSE 2755
// CenterNowOnUnits ( JMM ) ;
2776: LD_EXP 19
2780: PPUSH
2781: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2785: LD_EXP 19
2789: PPUSH
2790: LD_STRING D2-JMM-1
2792: PPUSH
2793: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2797: LD_EXP 24
2801: PUSH
2802: LD_INT 3
2804: ARRAY
2805: PPUSH
2806: LD_EXP 19
2810: PPUSH
2811: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2815: LD_EXP 24
2819: PUSH
2820: LD_INT 3
2822: ARRAY
2823: PPUSH
2824: LD_STRING D2-Eng1-1
2826: PPUSH
2827: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2831: LD_EXP 19
2835: PPUSH
2836: LD_STRING D2-JMM-2
2838: PPUSH
2839: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2843: LD_EXP 24
2847: PUSH
2848: LD_INT 3
2850: ARRAY
2851: PPUSH
2852: LD_STRING D2-Eng1-2
2854: PPUSH
2855: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2859: LD_EXP 19
2863: PPUSH
2864: LD_STRING D2-JMM-3
2866: PPUSH
2867: CALL_OW 88
// if Houten then
2871: LD_EXP 23
2875: IFFALSE 3073
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2877: LD_ADDR_VAR 0 3
2881: PUSH
2882: LD_INT 4
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: LD_INT 2
2893: PPUSH
2894: LD_INT 1
2896: PPUSH
2897: LD_INT 4
2899: PPUSH
2900: LD_INT 55
2902: PPUSH
2903: CALL 289 0 7
2907: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2908: LD_VAR 0 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2920: LD_VAR 0 3
2924: PPUSH
2925: LD_INT 46
2927: PPUSH
2928: LD_INT 19
2930: PPUSH
2931: LD_INT 0
2933: PPUSH
2934: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2938: LD_EXP 23
2942: PPUSH
2943: LD_VAR 0 3
2947: PPUSH
2948: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2952: LD_EXP 23
2956: PPUSH
2957: LD_INT 49
2959: PPUSH
2960: LD_INT 33
2962: PPUSH
2963: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2967: LD_EXP 23
2971: PPUSH
2972: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2976: LD_EXP 23
2980: PPUSH
2981: LD_EXP 19
2985: PPUSH
2986: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2990: LD_INT 35
2992: PPUSH
2993: CALL_OW 67
// until See ( 1 , Houten ) ;
2997: LD_INT 1
2999: PPUSH
3000: LD_EXP 23
3004: PPUSH
3005: CALL_OW 292
3009: IFFALSE 2990
// ComTurnUnit ( JMM , Houten ) ;
3011: LD_EXP 19
3015: PPUSH
3016: LD_EXP 23
3020: PPUSH
3021: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3025: LD_EXP 19
3029: PPUSH
3030: LD_STRING D1d-JMM-1
3032: PPUSH
3033: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3037: LD_EXP 23
3041: PPUSH
3042: LD_STRING D1-VanH-1
3044: PPUSH
3045: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3049: LD_EXP 19
3053: PPUSH
3054: LD_STRING D1-JMM-1v
3056: PPUSH
3057: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3061: LD_EXP 19
3065: PPUSH
3066: LD_STRING D1-JMM-2v
3068: PPUSH
3069: CALL_OW 88
// end ; InGameOff ;
3073: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3077: LD_STRING M1
3079: PPUSH
3080: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3084: LD_INT 22
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 92
3096: PUSH
3097: LD_EXP 19
3101: PPUSH
3102: CALL_OW 250
3106: PUSH
3107: LD_EXP 19
3111: PPUSH
3112: CALL_OW 251
3116: PUSH
3117: LD_INT 15
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PPUSH
3130: CALL_OW 69
3134: PPUSH
3135: LD_INT 1
3137: PPUSH
3138: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3142: LD_EXP 24
3146: PUSH
3147: LD_EXP 19
3151: ADD
3152: PUSH
3153: LD_EXP 23
3157: ADD
3158: PPUSH
3159: CALL_OW 141
// end ;
3163: LD_VAR 0 1
3167: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3168: LD_INT 1
3170: PPUSH
3171: LD_EXP 20
3175: PPUSH
3176: CALL_OW 292
3180: PUSH
3181: LD_EXP 19
3185: PPUSH
3186: LD_EXP 20
3190: PPUSH
3191: CALL_OW 296
3195: PUSH
3196: LD_INT 6
3198: LESS
3199: AND
3200: IFFALSE 4073
3202: GO 3204
3204: DISABLE
3205: LD_INT 0
3207: PPUSH
3208: PPUSH
3209: PPUSH
3210: PPUSH
3211: PPUSH
// begin InGameOn ;
3212: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3216: LD_INT 22
3218: PUSH
3219: LD_INT 4
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PPUSH
3226: CALL_OW 69
3230: PPUSH
3231: LD_INT 1
3233: PPUSH
3234: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3238: LD_ADDR_VAR 0 4
3242: PUSH
3243: LD_INT 22
3245: PUSH
3246: LD_INT 1
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 2
3255: PUSH
3256: LD_INT 25
3258: PUSH
3259: LD_INT 1
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 25
3268: PUSH
3269: LD_INT 2
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 25
3278: PUSH
3279: LD_INT 3
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: PUSH
3286: LD_INT 25
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: ST_TO_ADDR
// ComHold ( tmp ) ;
3312: LD_VAR 0 4
3316: PPUSH
3317: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3321: LD_EXP 19
3325: PPUSH
3326: LD_STRING D2-JMM-3a
3328: PPUSH
3329: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3333: LD_EXP 20
3337: PPUSH
3338: LD_EXP 19
3342: PPUSH
3343: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3347: LD_EXP 20
3351: PPUSH
3352: LD_STRING D2-Gary-3
3354: PPUSH
3355: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3359: LD_EXP 19
3363: PPUSH
3364: LD_EXP 20
3368: PPUSH
3369: CALL_OW 119
// for i in tmp do
3373: LD_ADDR_VAR 0 5
3377: PUSH
3378: LD_VAR 0 4
3382: PUSH
3383: FOR_IN
3384: IFFALSE 3429
// begin if IsInUnit ( i ) then
3386: LD_VAR 0 5
3390: PPUSH
3391: CALL_OW 310
3395: IFFALSE 3406
// ComExitBuilding ( i ) ;
3397: LD_VAR 0 5
3401: PPUSH
3402: CALL_OW 122
// wait ( 1 ) ;
3406: LD_INT 1
3408: PPUSH
3409: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3413: LD_VAR 0 5
3417: PPUSH
3418: LD_EXP 19
3422: PPUSH
3423: CALL_OW 119
// end ;
3427: GO 3383
3429: POP
3430: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3431: LD_ADDR_VAR 0 4
3435: PUSH
3436: LD_VAR 0 4
3440: PUSH
3441: LD_EXP 19
3445: PUSH
3446: LD_EXP 23
3450: PUSH
3451: LD_EXP 20
3455: PUSH
3456: LD_EXP 22
3460: PUSH
3461: LD_EXP 21
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_EXP 24
3477: ADD
3478: DIFF
3479: ST_TO_ADDR
// if Bobby then
3480: LD_EXP 21
3484: IFFALSE 3498
// Say ( Bobby , D2-Bobby-3 ) ;
3486: LD_EXP 21
3490: PPUSH
3491: LD_STRING D2-Bobby-3
3493: PPUSH
3494: CALL_OW 88
// if Cyrus then
3498: LD_EXP 22
3502: IFFALSE 3516
// Say ( Cyrus , D2-Cyrus-3 ) ;
3504: LD_EXP 22
3508: PPUSH
3509: LD_STRING D2-Cyrus-3
3511: PPUSH
3512: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3516: LD_EXP 19
3520: PPUSH
3521: LD_STRING D2-JMM-4
3523: PPUSH
3524: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3528: LD_EXP 20
3532: PPUSH
3533: LD_STRING D2-Gary-4
3535: PPUSH
3536: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3540: LD_ADDR_VAR 0 1
3544: PUSH
3545: LD_VAR 0 4
3549: PPUSH
3550: LD_INT 26
3552: PUSH
3553: LD_INT 1
3555: PUSH
3556: EMPTY
3557: LIST
3558: LIST
3559: PPUSH
3560: CALL_OW 72
3564: PUSH
3565: LD_INT 1
3567: ARRAY
3568: ST_TO_ADDR
// if Cyrus then
3569: LD_EXP 22
3573: IFFALSE 3589
// Say ( Cyrus , D2-Cyrus-4 ) else
3575: LD_EXP 22
3579: PPUSH
3580: LD_STRING D2-Cyrus-4
3582: PPUSH
3583: CALL_OW 88
3587: GO 3601
// Say ( un1 , D2-Sol1-4 ) ;
3589: LD_VAR 0 1
3593: PPUSH
3594: LD_STRING D2-Sol1-4
3596: PPUSH
3597: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3601: LD_EXP 19
3605: PPUSH
3606: LD_STRING D2-JMM-5
3608: PPUSH
3609: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_EXP 24
3622: PPUSH
3623: LD_INT 91
3625: PUSH
3626: LD_EXP 19
3630: PUSH
3631: LD_INT 10
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 26
3641: PUSH
3642: LD_INT 2
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 72
3657: ST_TO_ADDR
// if un2 then
3658: LD_VAR 0 2
3662: IFFALSE 3716
// begin un2 := un2 [ un2 ] ;
3664: LD_ADDR_VAR 0 2
3668: PUSH
3669: LD_VAR 0 2
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3680: LD_VAR 0 2
3684: PPUSH
3685: LD_STRING D2-FEng1-5
3687: PPUSH
3688: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3692: LD_EXP 19
3696: PPUSH
3697: LD_STRING D2-JMM-6
3699: PPUSH
3700: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3704: LD_VAR 0 2
3708: PPUSH
3709: LD_STRING D2-FEng1-6
3711: PPUSH
3712: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3716: LD_ADDR_VAR 0 3
3720: PUSH
3721: LD_EXP 24
3725: PPUSH
3726: LD_INT 91
3728: PUSH
3729: LD_EXP 19
3733: PUSH
3734: LD_INT 10
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 26
3744: PUSH
3745: LD_INT 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 72
3760: ST_TO_ADDR
// if un3 then
3761: LD_VAR 0 3
3765: IFFALSE 3820
// begin un3 := un3 [ 1 ] ;
3767: LD_ADDR_VAR 0 3
3771: PUSH
3772: LD_VAR 0 3
3776: PUSH
3777: LD_INT 1
3779: ARRAY
3780: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3781: LD_VAR 0 3
3785: PPUSH
3786: LD_INT 114
3788: PPUSH
3789: LD_INT 122
3791: PPUSH
3792: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3796: LD_VAR 0 3
3800: PPUSH
3801: LD_STRING D2-Eng1-6
3803: PPUSH
3804: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3808: LD_EXP 19
3812: PPUSH
3813: LD_STRING D2-JMM-7
3815: PPUSH
3816: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3820: LD_EXP 20
3824: PPUSH
3825: LD_STRING D2-Gary-7
3827: PPUSH
3828: CALL_OW 88
// if un2 then
3832: LD_VAR 0 2
3836: IFFALSE 3850
// Say ( un2 , D2-FEng1-7 ) ;
3838: LD_VAR 0 2
3842: PPUSH
3843: LD_STRING D2-FEng1-7
3845: PPUSH
3846: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3850: LD_VAR 0 1
3854: PPUSH
3855: LD_STRING D2-Sol1-7
3857: PPUSH
3858: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3862: LD_EXP 19
3866: PPUSH
3867: LD_STRING D2-JMM-8
3869: PPUSH
3870: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3874: LD_INT 22
3876: PUSH
3877: LD_INT 1
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 69
3888: PPUSH
3889: CALL_OW 141
// InGameOff ;
3893: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3897: LD_STRING M1a
3899: PPUSH
3900: CALL_OW 337
// jmm_in_ovsyenko := true ;
3904: LD_ADDR_EXP 4
3908: PUSH
3909: LD_INT 1
3911: ST_TO_ADDR
// if debug then
3912: LD_EXP 2
3916: IFFALSE 4022
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
3918: LD_INT 22
3920: PUSH
3921: LD_INT 1
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PUSH
3928: LD_INT 30
3930: PUSH
3931: LD_INT 0
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PPUSH
3942: CALL_OW 69
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PPUSH
3951: CALL_OW 274
3955: PPUSH
3956: LD_INT 2
3958: PPUSH
3959: LD_INT 1000
3961: PPUSH
3962: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 30
3978: PUSH
3979: LD_INT 0
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PPUSH
3990: CALL_OW 69
3994: PUSH
3995: LD_INT 1
3997: ARRAY
3998: PPUSH
3999: CALL_OW 274
4003: PPUSH
4004: LD_INT 1
4006: PPUSH
4007: LD_INT 1000
4009: PPUSH
4010: CALL_OW 277
// ar_can_arrive := true ;
4014: LD_ADDR_EXP 10
4018: PUSH
4019: LD_INT 1
4021: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4022: LD_INT 1050
4024: PPUSH
4025: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4029: LD_ADDR_VAR 0 4
4033: PUSH
4034: LD_INT 25
4036: PUSH
4037: LD_INT 14
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: PPUSH
4044: CALL_OW 69
4048: ST_TO_ADDR
// if not tmp then
4049: LD_VAR 0 4
4053: NOT
4054: IFFALSE 4058
// exit ;
4056: GO 4073
// ComMoveXY ( tmp , 75 , 75 ) ;
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_INT 75
4065: PPUSH
4066: LD_INT 75
4068: PPUSH
4069: CALL_OW 111
// end ;
4073: PPOPN 5
4075: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4076: LD_INT 22
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 30
4088: PUSH
4089: LD_INT 30
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 3
4098: PUSH
4099: LD_INT 57
4101: PUSH
4102: EMPTY
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: IFFALSE 4160
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4126: LD_ADDR_VAR 0 1
4130: PUSH
4131: LD_STRING M2easy
4133: PUSH
4134: LD_STRING M2
4136: PUSH
4137: LD_STRING M2hard
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4145: LD_VAR 0 1
4149: PUSH
4150: LD_OWVAR 67
4154: ARRAY
4155: PPUSH
4156: CALL_OW 337
// end ;
4160: PPOPN 1
4162: END
// every 3 3$00 do
4163: GO 4165
4165: DISABLE
// begin DialogueOn ;
4166: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4170: LD_EXP 26
4174: PPUSH
4175: LD_STRING D3-Pow-1
4177: PPUSH
4178: CALL_OW 94
// if jmm_in_ovsyenko then
4182: LD_EXP 4
4186: IFFALSE 4214
// begin Say ( JMM , D3-JMM-1 ) ;
4188: LD_EXP 19
4192: PPUSH
4193: LD_STRING D3-JMM-1
4195: PPUSH
4196: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4200: LD_EXP 19
4204: PPUSH
4205: LD_STRING D3-JMM-1b
4207: PPUSH
4208: CALL_OW 88
// end else
4212: GO 4226
// Say ( JMM , D3-JMM-1a ) ;
4214: LD_EXP 19
4218: PPUSH
4219: LD_STRING D3-JMM-1a
4221: PPUSH
4222: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4226: LD_EXP 26
4230: PPUSH
4231: LD_STRING D3-Pow-2
4233: PPUSH
4234: CALL_OW 94
// DialogueOff ;
4238: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4242: LD_STRING M3
4244: PPUSH
4245: CALL_OW 337
// powell_want_sib := true ;
4249: LD_ADDR_EXP 5
4253: PUSH
4254: LD_INT 1
4256: ST_TO_ADDR
// end ;
4257: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4258: LD_EXP 6
4262: PUSH
4263: LD_INT 0
4265: EQUAL
4266: IFFALSE 5713
4268: GO 4270
4270: DISABLE
4271: LD_INT 0
4273: PPUSH
4274: PPUSH
4275: PPUSH
4276: PPUSH
4277: PPUSH
4278: PPUSH
4279: PPUSH
4280: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4281: LD_INT 4
4283: PPUSH
4284: LD_INT 1
4286: PPUSH
4287: CALL_OW 343
// PowellTransport ;
4291: CALL 2509 0 0
// for i = 1 to 3 do
4295: LD_ADDR_VAR 0 4
4299: PUSH
4300: DOUBLE
4301: LD_INT 1
4303: DEC
4304: ST_TO_ADDR
4305: LD_INT 3
4307: PUSH
4308: FOR_TO
4309: IFFALSE 4376
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4311: LD_ADDR_VAR 0 1
4315: PUSH
4316: LD_INT 6
4318: PPUSH
4319: LD_VAR 0 4
4323: PPUSH
4324: CALL_OW 287
4328: ST_TO_ADDR
// if not tmp then
4329: LD_VAR 0 1
4333: NOT
4334: IFFALSE 4338
// continue ;
4336: GO 4308
// EraseResourceArea ( terminalArea , i ) ;
4338: LD_INT 6
4340: PPUSH
4341: LD_VAR 0 4
4345: PPUSH
4346: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4350: LD_EXP 3
4354: PPUSH
4355: CALL_OW 274
4359: PPUSH
4360: LD_VAR 0 4
4364: PPUSH
4365: LD_VAR 0 1
4369: PPUSH
4370: CALL_OW 276
// end ;
4374: GO 4308
4376: POP
4377: POP
// x := 43 ;
4378: LD_ADDR_VAR 0 2
4382: PUSH
4383: LD_INT 43
4385: ST_TO_ADDR
// y := 3 ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_INT 3
4393: ST_TO_ADDR
// for i = 3 to 4 do
4394: LD_ADDR_VAR 0 4
4398: PUSH
4399: DOUBLE
4400: LD_INT 3
4402: DEC
4403: ST_TO_ADDR
4404: LD_INT 4
4406: PUSH
4407: FOR_TO
4408: IFFALSE 4599
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4410: LD_EXP 25
4414: PUSH
4415: LD_VAR 0 4
4419: ARRAY
4420: PPUSH
4421: LD_INT 4
4423: PPUSH
4424: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4428: LD_EXP 25
4432: PUSH
4433: LD_VAR 0 4
4437: ARRAY
4438: PPUSH
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_VAR 0 3
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4456: LD_EXP 25
4460: PUSH
4461: LD_VAR 0 4
4465: PUSH
4466: LD_INT 2
4468: MINUS
4469: ARRAY
4470: PPUSH
4471: LD_EXP 25
4475: PUSH
4476: LD_VAR 0 4
4480: ARRAY
4481: PPUSH
4482: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4486: LD_EXP 25
4490: PUSH
4491: LD_VAR 0 4
4495: ARRAY
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 100
4502: PPUSH
4503: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4507: LD_EXP 25
4511: PUSH
4512: LD_VAR 0 4
4516: PUSH
4517: LD_INT 2
4519: MINUS
4520: ARRAY
4521: PPUSH
4522: LD_INT 54
4524: PPUSH
4525: LD_INT 42
4527: PPUSH
4528: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4532: LD_EXP 25
4536: PUSH
4537: LD_VAR 0 4
4541: PUSH
4542: LD_INT 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: LD_EXP 3
4551: PPUSH
4552: CALL_OW 250
4556: PPUSH
4557: LD_EXP 3
4561: PPUSH
4562: CALL_OW 251
4566: PPUSH
4567: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4571: LD_EXP 25
4575: PUSH
4576: LD_VAR 0 4
4580: PUSH
4581: LD_INT 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 200
// Wait ( 0 0$02 ) ;
4590: LD_INT 70
4592: PPUSH
4593: CALL_OW 67
// end ;
4597: GO 4407
4599: POP
4600: POP
// time := 0 0$20 ;
4601: LD_ADDR_VAR 0 8
4605: PUSH
4606: LD_INT 700
4608: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4609: LD_INT 35
4611: PPUSH
4612: CALL_OW 67
// time := time - 0 0$01 ;
4616: LD_ADDR_VAR 0 8
4620: PUSH
4621: LD_VAR 0 8
4625: PUSH
4626: LD_INT 35
4628: MINUS
4629: ST_TO_ADDR
// for i = 3 to 4 do
4630: LD_ADDR_VAR 0 4
4634: PUSH
4635: DOUBLE
4636: LD_INT 3
4638: DEC
4639: ST_TO_ADDR
4640: LD_INT 4
4642: PUSH
4643: FOR_TO
4644: IFFALSE 4779
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4646: LD_EXP 25
4650: PUSH
4651: LD_VAR 0 4
4655: ARRAY
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: GREATER
4668: PUSH
4669: LD_EXP 25
4673: PUSH
4674: LD_VAR 0 4
4678: ARRAY
4679: PPUSH
4680: CALL_OW 314
4684: NOT
4685: AND
4686: IFFALSE 4777
// begin x := rand ( 0 , 5 ) ;
4688: LD_ADDR_VAR 0 2
4692: PUSH
4693: LD_INT 0
4695: PPUSH
4696: LD_INT 5
4698: PPUSH
4699: CALL_OW 12
4703: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4704: LD_EXP 25
4708: PUSH
4709: LD_VAR 0 4
4713: ARRAY
4714: PPUSH
4715: LD_EXP 25
4719: PUSH
4720: LD_VAR 0 4
4724: ARRAY
4725: PPUSH
4726: CALL_OW 250
4730: PPUSH
4731: LD_VAR 0 2
4735: PPUSH
4736: LD_INT 3
4738: PPUSH
4739: CALL_OW 272
4743: PPUSH
4744: LD_EXP 25
4748: PUSH
4749: LD_VAR 0 4
4753: ARRAY
4754: PPUSH
4755: CALL_OW 251
4759: PPUSH
4760: LD_VAR 0 2
4764: PPUSH
4765: LD_INT 3
4767: PPUSH
4768: CALL_OW 273
4772: PPUSH
4773: CALL_OW 171
// end ;
4777: GO 4643
4779: POP
4780: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4781: LD_EXP 25
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_INT 54
4792: PPUSH
4793: LD_INT 42
4795: PPUSH
4796: CALL_OW 297
4800: PUSH
4801: LD_INT 4
4803: LESS
4804: PUSH
4805: LD_VAR 0 8
4809: PUSH
4810: LD_INT 0
4812: EQUAL
4813: OR
4814: IFFALSE 4609
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4816: LD_EXP 25
4820: PUSH
4821: LD_INT 3
4823: ARRAY
4824: PPUSH
4825: LD_INT 1
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4835: LD_EXP 25
4839: PUSH
4840: LD_INT 4
4842: ARRAY
4843: PPUSH
4844: LD_INT 1
4846: PPUSH
4847: LD_INT 0
4849: PPUSH
4850: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4854: LD_EXP 3
4858: PPUSH
4859: CALL_OW 274
4863: PPUSH
4864: LD_INT 1
4866: PPUSH
4867: LD_INT 200
4869: PPUSH
4870: CALL_OW 276
// DialogueOn ;
4874: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4878: LD_INT 53
4880: PPUSH
4881: LD_INT 35
4883: PPUSH
4884: CALL_OW 86
// un := powell_trans [ 1 ] ;
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_EXP 25
4897: PUSH
4898: LD_INT 1
4900: ARRAY
4901: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4902: LD_VAR 0 5
4906: PPUSH
4907: LD_STRING D4-Mech1-1
4909: PPUSH
4910: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4914: LD_EXP 19
4918: PPUSH
4919: LD_STRING D4-JMM-1
4921: PPUSH
4922: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4926: LD_VAR 0 5
4930: PPUSH
4931: LD_STRING D4-Mech1-2
4933: PPUSH
4934: CALL_OW 88
// powell_happy := false ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_INT 0
4945: ST_TO_ADDR
// take_cargo := false ;
4946: LD_ADDR_VAR 0 7
4950: PUSH
4951: LD_INT 0
4953: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4954: CALL 809 0 0
4958: PUSH
4959: LD_INT 60
4961: GREATEREQUAL
4962: IFFALSE 5010
// begin Say ( JMM , D5-JMM-1 ) ;
4964: LD_EXP 19
4968: PPUSH
4969: LD_STRING D5-JMM-1
4971: PPUSH
4972: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4976: LD_VAR 0 5
4980: PPUSH
4981: LD_STRING D6-Mech1-1
4983: PPUSH
4984: CALL_OW 88
// powell_happy := true ;
4988: LD_ADDR_VAR 0 6
4992: PUSH
4993: LD_INT 1
4995: ST_TO_ADDR
// take_cargo := true ;
4996: LD_ADDR_VAR 0 7
5000: PUSH
5001: LD_INT 1
5003: ST_TO_ADDR
// DialogueOff ;
5004: CALL_OW 7
// end else
5008: GO 5244
// if GetTerminalCargo > 0 then
5010: CALL 809 0 0
5014: PUSH
5015: LD_INT 0
5017: GREATER
5018: IFFALSE 5216
// begin case Query ( QWait ) of 1 :
5020: LD_STRING QWait
5022: PPUSH
5023: CALL_OW 97
5027: PUSH
5028: LD_INT 1
5030: DOUBLE
5031: EQUAL
5032: IFTRUE 5036
5034: GO 5127
5036: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5037: LD_EXP 19
5041: PPUSH
5042: LD_STRING D5b-JMM-1
5044: PPUSH
5045: CALL_OW 88
// DialogueOff ;
5049: CALL_OW 7
// wait ( 5 5$00 ) ;
5053: LD_INT 10500
5055: PPUSH
5056: CALL_OW 67
// if GetTerminalCargo < 60 then
5060: CALL 809 0 0
5064: PUSH
5065: LD_INT 60
5067: LESS
5068: IFFALSE 5109
// begin DialogueOn ;
5070: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5074: LD_EXP 3
5078: PPUSH
5079: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5083: LD_VAR 0 5
5087: PPUSH
5088: LD_STRING D6-Mech1-1a
5090: PPUSH
5091: CALL_OW 88
// DialogueOff ;
5095: CALL_OW 7
// powell_happy := false ;
5099: LD_ADDR_VAR 0 6
5103: PUSH
5104: LD_INT 0
5106: ST_TO_ADDR
// end else
5107: GO 5125
// begin powell_happy := true ;
5109: LD_ADDR_VAR 0 6
5113: PUSH
5114: LD_INT 1
5116: ST_TO_ADDR
// take_cargo := true ;
5117: LD_ADDR_VAR 0 7
5121: PUSH
5122: LD_INT 1
5124: ST_TO_ADDR
// end ; end ; 2 :
5125: GO 5214
5127: LD_INT 2
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5135
5133: GO 5174
5135: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5136: LD_EXP 19
5140: PPUSH
5141: LD_STRING D5b-JMM-1
5143: PPUSH
5144: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5148: LD_VAR 0 5
5152: PPUSH
5153: LD_STRING D6-Mech1-1a
5155: PPUSH
5156: CALL_OW 88
// DialogueOff ;
5160: CALL_OW 7
// take_cargo := true ;
5164: LD_ADDR_VAR 0 7
5168: PUSH
5169: LD_INT 1
5171: ST_TO_ADDR
// end ; 3 :
5172: GO 5214
5174: LD_INT 3
5176: DOUBLE
5177: EQUAL
5178: IFTRUE 5182
5180: GO 5213
5182: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5183: LD_EXP 19
5187: PPUSH
5188: LD_STRING D5c-JMM-1
5190: PPUSH
5191: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D6-Mech1-1b
5202: PPUSH
5203: CALL_OW 88
// DialogueOff ;
5207: CALL_OW 7
// end ; end ;
5211: GO 5214
5213: POP
// end else
5214: GO 5244
// begin Say ( JMM , D5c-JMM-1 ) ;
5216: LD_EXP 19
5220: PPUSH
5221: LD_STRING D5c-JMM-1
5223: PPUSH
5224: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5228: LD_VAR 0 5
5232: PPUSH
5233: LD_STRING D6-Mech1-1b
5235: PPUSH
5236: CALL_OW 88
// DialogueOff ;
5240: CALL_OW 7
// end ; if take_cargo then
5244: LD_VAR 0 7
5248: IFFALSE 5327
// begin x := GetTerminalCargo ;
5250: LD_ADDR_VAR 0 2
5254: PUSH
5255: CALL 809 0 0
5259: ST_TO_ADDR
// if x > 60 then
5260: LD_VAR 0 2
5264: PUSH
5265: LD_INT 60
5267: GREATER
5268: IFFALSE 5278
// x := 60 ;
5270: LD_ADDR_VAR 0 2
5274: PUSH
5275: LD_INT 60
5277: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5278: LD_EXP 3
5282: PPUSH
5283: CALL_OW 274
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 809 0 0
5295: PUSH
5296: LD_VAR 0 2
5300: MINUS
5301: PPUSH
5302: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5306: LD_EXP 25
5310: PUSH
5311: LD_INT 3
5313: ARRAY
5314: PPUSH
5315: LD_INT 3
5317: PPUSH
5318: LD_VAR 0 2
5322: PPUSH
5323: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5327: LD_EXP 25
5331: PPUSH
5332: LD_INT 43
5334: PPUSH
5335: LD_INT 3
5337: PPUSH
5338: CALL_OW 171
// x := 0 0$20 ;
5342: LD_ADDR_VAR 0 2
5346: PUSH
5347: LD_INT 700
5349: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// x := x - 0 0$01 ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_VAR 0 2
5366: PUSH
5367: LD_INT 35
5369: MINUS
5370: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5371: LD_VAR 0 2
5375: PUSH
5376: LD_INT 0
5378: EQUAL
5379: PUSH
5380: LD_EXP 25
5384: PUSH
5385: LD_INT 3
5387: ARRAY
5388: PPUSH
5389: LD_INT 43
5391: PPUSH
5392: LD_INT 3
5394: PPUSH
5395: CALL_OW 297
5399: PUSH
5400: LD_INT 4
5402: LESS
5403: PUSH
5404: LD_EXP 25
5408: PUSH
5409: LD_INT 3
5411: ARRAY
5412: PPUSH
5413: LD_INT 43
5415: PPUSH
5416: LD_INT 3
5418: PPUSH
5419: CALL_OW 297
5423: PUSH
5424: LD_INT 4
5426: LESS
5427: AND
5428: OR
5429: IFFALSE 5350
// for i in powell_trans do
5431: LD_ADDR_VAR 0 4
5435: PUSH
5436: LD_EXP 25
5440: PUSH
5441: FOR_IN
5442: IFFALSE 5455
// RemoveUnit ( i ) ;
5444: LD_VAR 0 4
5448: PPUSH
5449: CALL_OW 64
5453: GO 5441
5455: POP
5456: POP
// if not powell_happy then
5457: LD_VAR 0 6
5461: NOT
5462: IFFALSE 5473
// powell_happy := - 1 ;
5464: LD_ADDR_VAR 0 6
5468: PUSH
5469: LD_INT 1
5471: NEG
5472: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5473: LD_STRING EarlySiberite
5475: PPUSH
5476: LD_VAR 0 6
5480: PPUSH
5481: CALL_OW 101
// if powell_happy then
5485: LD_VAR 0 6
5489: IFFALSE 5500
// ChangeMissionObjectives ( M3a ) else
5491: LD_STRING M3a
5493: PPUSH
5494: CALL_OW 337
5498: GO 5507
// ChangeMissionObjectives ( M3b ) ;
5500: LD_STRING M3b
5502: PPUSH
5503: CALL_OW 337
// ru_can_attack_terminal := true ;
5507: LD_ADDR_EXP 9
5511: PUSH
5512: LD_INT 1
5514: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5515: LD_INT 25200
5517: PPUSH
5518: CALL_OW 67
// time := 2 2$00 ;
5522: LD_ADDR_VAR 0 8
5526: PUSH
5527: LD_INT 4200
5529: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5530: LD_INT 35
5532: PPUSH
5533: CALL_OW 67
// time := time - 0 0$1 ;
5537: LD_ADDR_VAR 0 8
5541: PUSH
5542: LD_VAR 0 8
5546: PUSH
5547: LD_INT 35
5549: MINUS
5550: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5551: LD_EXP 8
5555: NOT
5556: PUSH
5557: LD_EXP 36
5561: PUSH
5562: LD_INT 0
5564: EQUAL
5565: OR
5566: PUSH
5567: LD_VAR 0 8
5571: PUSH
5572: LD_INT 0
5574: EQUAL
5575: OR
5576: IFFALSE 5530
// if ru_force then
5578: LD_EXP 36
5582: IFFALSE 5681
// for i in ru_force do
5584: LD_ADDR_VAR 0 4
5588: PUSH
5589: LD_EXP 36
5593: PUSH
5594: FOR_IN
5595: IFFALSE 5679
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5597: LD_INT 1
5599: PPUSH
5600: LD_VAR 0 4
5604: PPUSH
5605: CALL_OW 292
5609: NOT
5610: PUSH
5611: LD_VAR 0 4
5615: PPUSH
5616: LD_INT 81
5618: PUSH
5619: LD_INT 3
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: PPUSH
5631: LD_VAR 0 4
5635: PPUSH
5636: CALL_OW 74
5640: PPUSH
5641: CALL_OW 296
5645: PUSH
5646: LD_INT 10
5648: GREATER
5649: AND
5650: IFFALSE 5677
// begin RemoveUnit ( i ) ;
5652: LD_VAR 0 4
5656: PPUSH
5657: CALL_OW 64
// ru_force := ru_force diff i ;
5661: LD_ADDR_EXP 36
5665: PUSH
5666: LD_EXP 36
5670: PUSH
5671: LD_VAR 0 4
5675: DIFF
5676: ST_TO_ADDR
// end ;
5677: GO 5594
5679: POP
5680: POP
// repeat wait ( 0 0$03 ) ;
5681: LD_INT 105
5683: PPUSH
5684: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5688: LD_EXP 8
5692: NOT
5693: PUSH
5694: LD_EXP 36
5698: PUSH
5699: LD_INT 3
5701: LESS
5702: OR
5703: IFFALSE 5681
// ar_can_arrive := true ;
5705: LD_ADDR_EXP 10
5709: PUSH
5710: LD_INT 1
5712: ST_TO_ADDR
// end ;
5713: PPOPN 8
5715: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5716: LD_INT 1
5718: PPUSH
5719: LD_INT 20
5721: PPUSH
5722: CALL_OW 325
5726: IFFALSE 5867
5728: GO 5730
5730: DISABLE
5731: LD_INT 0
5733: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: LD_INT 22
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: LD_INT 1
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 25
5761: PUSH
5762: LD_INT 4
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 69
5778: PUSH
5779: LD_EXP 19
5783: PUSH
5784: LD_EXP 22
5788: PUSH
5789: LD_EXP 21
5793: PUSH
5794: LD_EXP 23
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: DIFF
5805: ST_TO_ADDR
// if not un then
5806: LD_VAR 0 1
5810: NOT
5811: IFFALSE 5815
// exit ;
5813: GO 5867
// DialogueOn ;
5815: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5819: LD_VAR 0 1
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_STRING D13-Sci1-1
5830: PPUSH
5831: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5835: LD_EXP 19
5839: PPUSH
5840: LD_STRING D13-JMM-1
5842: PPUSH
5843: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5847: LD_VAR 0 1
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PPUSH
5856: LD_STRING D13-Sci1-2
5858: PPUSH
5859: CALL_OW 88
// DialogueOff ;
5863: CALL_OW 7
// end ;
5867: PPOPN 1
5869: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5870: LD_INT 1
5872: PPUSH
5873: CALL 840 0 1
5877: PUSH
5878: LD_INT 77
5880: GREATER
5881: PUSH
5882: LD_EXP 8
5886: NOT
5887: AND
5888: PUSH
5889: LD_INT 22
5891: PUSH
5892: LD_INT 1
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 25
5901: PUSH
5902: LD_INT 4
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: LD_INT 26
5911: PUSH
5912: LD_INT 1
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: PPUSH
5924: CALL_OW 69
5928: PUSH
5929: LD_EXP 19
5933: PUSH
5934: LD_EXP 21
5938: PUSH
5939: LD_EXP 22
5943: PUSH
5944: LD_EXP 20
5948: PUSH
5949: LD_EXP 23
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: DIFF
5961: AND
5962: IFFALSE 6140
5964: GO 5966
5966: DISABLE
5967: LD_INT 0
5969: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5970: LD_ADDR_VAR 0 1
5974: PUSH
5975: LD_INT 22
5977: PUSH
5978: LD_INT 1
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 25
5987: PUSH
5988: LD_INT 4
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: PUSH
6015: LD_EXP 19
6019: PUSH
6020: LD_EXP 21
6024: PUSH
6025: LD_EXP 22
6029: PUSH
6030: LD_EXP 20
6034: PUSH
6035: LD_EXP 23
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: DIFF
6047: ST_TO_ADDR
// DialogueOn ;
6048: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6052: LD_VAR 0 1
6056: PUSH
6057: LD_INT 1
6059: ARRAY
6060: PPUSH
6061: LD_STRING D7-Sci1-1
6063: PPUSH
6064: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6068: LD_EXP 19
6072: PPUSH
6073: LD_STRING D7-JMM-1
6075: PPUSH
6076: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6080: LD_VAR 0 1
6084: PUSH
6085: LD_INT 1
6087: ARRAY
6088: PPUSH
6089: LD_STRING D7-Sci1-2
6091: PPUSH
6092: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6096: LD_EXP 19
6100: PPUSH
6101: LD_STRING D7-JMM-2
6103: PPUSH
6104: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6108: LD_VAR 0 1
6112: PUSH
6113: LD_INT 1
6115: ARRAY
6116: PPUSH
6117: LD_STRING D7-Sci1-3
6119: PPUSH
6120: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6124: LD_EXP 19
6128: PPUSH
6129: LD_STRING D7-JMM-3
6131: PPUSH
6132: CALL_OW 88
// DialogueOff ;
6136: CALL_OW 7
// end ;
6140: PPOPN 1
6142: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates ;
6143: LD_EXP 10
6147: IFFALSE 9644
6149: GO 6151
6151: DISABLE
6152: LD_INT 0
6154: PPUSH
6155: PPUSH
6156: PPUSH
6157: PPUSH
6158: PPUSH
6159: PPUSH
6160: PPUSH
6161: PPUSH
6162: PPUSH
// begin PrepareArabian ;
6163: CALL 12220 0 0
// blocked := false ;
6167: LD_ADDR_EXP 18
6171: PUSH
6172: LD_INT 0
6174: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6175: LD_INT 35
6177: PPUSH
6178: CALL_OW 67
// until ar_spawned ;
6182: LD_EXP 11
6186: IFFALSE 6175
// have_crates := true ;
6188: LD_ADDR_VAR 0 9
6192: PUSH
6193: LD_INT 1
6195: ST_TO_ADDR
// player_want_info := 2 ;
6196: LD_ADDR_EXP 13
6200: PUSH
6201: LD_INT 2
6203: ST_TO_ADDR
// DialogueOn ;
6204: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6208: LD_EXP 27
6212: PPUSH
6213: LD_STRING D8-Ar1-1
6215: PPUSH
6216: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6220: LD_EXP 19
6224: PPUSH
6225: LD_STRING D8-JMM-1
6227: PPUSH
6228: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6232: LD_EXP 27
6236: PPUSH
6237: LD_STRING D8-Ar1-2
6239: PPUSH
6240: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6244: LD_EXP 19
6248: PPUSH
6249: LD_STRING D8-JMM-2
6251: PPUSH
6252: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6256: LD_EXP 27
6260: PPUSH
6261: LD_STRING D8-Ar1-3
6263: PPUSH
6264: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6268: LD_EXP 19
6272: PPUSH
6273: LD_STRING D8-JMM-3
6275: PPUSH
6276: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6280: LD_EXP 27
6284: PPUSH
6285: LD_STRING D8-Ar1-4
6287: PPUSH
6288: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6292: LD_EXP 19
6296: PPUSH
6297: LD_STRING D8-JMM-4
6299: PPUSH
6300: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6304: LD_EXP 27
6308: PPUSH
6309: LD_STRING D8-Ar1-5
6311: PPUSH
6312: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6316: LD_EXP 19
6320: PPUSH
6321: LD_STRING D8-JMM-5
6323: PPUSH
6324: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6328: LD_EXP 27
6332: PPUSH
6333: LD_STRING D8-Ar1-6
6335: PPUSH
6336: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6340: LD_EXP 28
6344: PPUSH
6345: LD_STRING D8-Ar2-6
6347: PPUSH
6348: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6352: LD_EXP 19
6356: PPUSH
6357: LD_STRING D8-JMM-6
6359: PPUSH
6360: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6364: LD_EXP 28
6368: PPUSH
6369: LD_STRING D8-Ar2-7
6371: PPUSH
6372: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6376: LD_STRING QBarracks
6378: PPUSH
6379: CALL_OW 97
6383: PUSH
6384: LD_INT 1
6386: DOUBLE
6387: EQUAL
6388: IFTRUE 6392
6390: GO 6427
6392: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6393: LD_EXP 19
6397: PPUSH
6398: LD_STRING D8a-JMM-1
6400: PPUSH
6401: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6405: LD_EXP 27
6409: PPUSH
6410: LD_STRING D8a-Ar1-1
6412: PPUSH
6413: CALL_OW 94
// player_want_mortar := true ;
6417: LD_ADDR_EXP 12
6421: PUSH
6422: LD_INT 1
6424: ST_TO_ADDR
// end ; 2 :
6425: GO 6585
6427: LD_INT 2
6429: DOUBLE
6430: EQUAL
6431: IFTRUE 6435
6433: GO 6549
6435: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6436: LD_EXP 19
6440: PPUSH
6441: LD_STRING D8b-JMM-1
6443: PPUSH
6444: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6448: LD_EXP 27
6452: PPUSH
6453: LD_STRING D8b-Ar1-1
6455: PPUSH
6456: CALL_OW 94
// case Query ( QInfo ) of 1 :
6460: LD_STRING QInfo
6462: PPUSH
6463: CALL_OW 97
6467: PUSH
6468: LD_INT 1
6470: DOUBLE
6471: EQUAL
6472: IFTRUE 6476
6474: GO 6511
6476: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6477: LD_EXP 19
6481: PPUSH
6482: LD_STRING D8b1-JMM-1
6484: PPUSH
6485: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6489: LD_EXP 27
6493: PPUSH
6494: LD_STRING D8b1-Ar1-1
6496: PPUSH
6497: CALL_OW 94
// player_want_info := 2 ;
6501: LD_ADDR_EXP 13
6505: PUSH
6506: LD_INT 2
6508: ST_TO_ADDR
// end ; 2 :
6509: GO 6547
6511: LD_INT 2
6513: DOUBLE
6514: EQUAL
6515: IFTRUE 6519
6517: GO 6546
6519: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6520: LD_EXP 19
6524: PPUSH
6525: LD_STRING D8b2-JMM-1
6527: PPUSH
6528: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6532: LD_EXP 27
6536: PPUSH
6537: LD_STRING D8b2-Ar1-1
6539: PPUSH
6540: CALL_OW 94
// end ; end ;
6544: GO 6547
6546: POP
// end ; 3 :
6547: GO 6585
6549: LD_INT 3
6551: DOUBLE
6552: EQUAL
6553: IFTRUE 6557
6555: GO 6584
6557: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6558: LD_EXP 19
6562: PPUSH
6563: LD_STRING D8c-JMM-1
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6570: LD_EXP 27
6574: PPUSH
6575: LD_STRING D8c-Ar1-1
6577: PPUSH
6578: CALL_OW 94
// end ; end ;
6582: GO 6585
6584: POP
// DialogueOff ;
6585: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6589: LD_ADDR_VAR 0 4
6593: PUSH
6594: LD_INT 9
6596: PPUSH
6597: LD_INT 2
6599: PUSH
6600: LD_INT 30
6602: PUSH
6603: LD_INT 0
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 30
6612: PUSH
6613: LD_INT 1
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: PPUSH
6625: CALL_OW 70
6629: ST_TO_ADDR
// if dep then
6630: LD_VAR 0 4
6634: IFFALSE 6650
// dep := dep [ 1 ] ;
6636: LD_ADDR_VAR 0 4
6640: PUSH
6641: LD_VAR 0 4
6645: PUSH
6646: LD_INT 1
6648: ARRAY
6649: ST_TO_ADDR
// if not dep then
6650: LD_VAR 0 4
6654: NOT
6655: IFFALSE 6693
// begin case Query ( QInfoNothing ) of 1 :
6657: LD_STRING QInfoNothing
6659: PPUSH
6660: CALL_OW 97
6664: PUSH
6665: LD_INT 1
6667: DOUBLE
6668: EQUAL
6669: IFTRUE 6673
6671: GO 6676
6673: POP
// ; end ;
6674: GO 6677
6676: POP
// player_want_info := false ;
6677: LD_ADDR_EXP 13
6681: PUSH
6682: LD_INT 0
6684: ST_TO_ADDR
// player_want_mortar := false ;
6685: LD_ADDR_EXP 12
6689: PUSH
6690: LD_INT 0
6692: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6693: LD_ADDR_VAR 0 3
6697: PUSH
6698: LD_INT 22
6700: PUSH
6701: LD_INT 2
6703: PUSH
6704: EMPTY
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 21
6710: PUSH
6711: LD_INT 2
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PPUSH
6722: CALL_OW 69
6726: ST_TO_ADDR
// time := 1 1$55 ;
6727: LD_ADDR_VAR 0 5
6731: PUSH
6732: LD_INT 4025
6734: ST_TO_ADDR
// no_oil_gain := false ;
6735: LD_ADDR_VAR 0 6
6739: PUSH
6740: LD_INT 0
6742: ST_TO_ADDR
// first_warn := false ;
6743: LD_ADDR_VAR 0 7
6747: PUSH
6748: LD_INT 0
6750: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6751: LD_EXP 12
6755: PUSH
6756: LD_EXP 13
6760: OR
6761: IFFALSE 6866
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6763: LD_EXP 34
6767: PPUSH
6768: LD_INT 25
6770: PUSH
6771: LD_INT 1
6773: PUSH
6774: EMPTY
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PPUSH
6783: LD_VAR 0 4
6787: PPUSH
6788: CALL_OW 250
6792: PPUSH
6793: LD_VAR 0 4
6797: PPUSH
6798: CALL_OW 251
6802: PPUSH
6803: LD_VAR 0 4
6807: PPUSH
6808: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6812: LD_EXP 34
6816: PPUSH
6817: LD_INT 25
6819: PUSH
6820: LD_INT 1
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL_OW 72
6831: PPUSH
6832: LD_INT 86
6834: PPUSH
6835: LD_INT 121
6837: PPUSH
6838: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6842: LD_EXP 34
6846: PPUSH
6847: LD_INT 25
6849: PUSH
6850: LD_INT 1
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PPUSH
6857: CALL_OW 72
6861: PPUSH
6862: CALL_OW 200
// end ; if player_attacked_ar then
6866: LD_EXP 16
6870: IFFALSE 6874
// exit ;
6872: GO 9644
// if player_want_mortar then
6874: LD_EXP 12
6878: IFFALSE 8306
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6880: LD_EXP 28
6884: PPUSH
6885: LD_VAR 0 4
6889: PPUSH
6890: CALL_OW 250
6894: PUSH
6895: LD_INT 1
6897: PLUS
6898: PPUSH
6899: LD_VAR 0 4
6903: PPUSH
6904: CALL_OW 251
6908: PUSH
6909: LD_INT 1
6911: PLUS
6912: PPUSH
6913: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6917: LD_INT 35
6919: PPUSH
6920: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6924: LD_EXP 28
6928: PPUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL_OW 296
6938: PUSH
6939: LD_INT 4
6941: LESS
6942: IFFALSE 6917
// for i = 1 to 6 do
6944: LD_ADDR_VAR 0 1
6948: PUSH
6949: DOUBLE
6950: LD_INT 1
6952: DEC
6953: ST_TO_ADDR
6954: LD_INT 6
6956: PUSH
6957: FOR_TO
6958: IFFALSE 7162
// begin if player_attacked_ar then
6960: LD_EXP 16
6964: IFFALSE 6970
// exit ;
6966: POP
6967: POP
6968: GO 9644
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6970: LD_VAR 0 4
6974: PPUSH
6975: CALL_OW 274
6979: PPUSH
6980: LD_INT 2
6982: PPUSH
6983: CALL_OW 275
6987: PUSH
6988: LD_INT 10
6990: LESS
6991: PUSH
6992: LD_VAR 0 7
6996: NOT
6997: AND
6998: IFFALSE 7061
// begin first_warn := true ;
7000: LD_ADDR_VAR 0 7
7004: PUSH
7005: LD_INT 1
7007: ST_TO_ADDR
// DialogueOn ;
7008: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7012: LD_EXP 29
7016: PPUSH
7017: LD_STRING D9a-FAr1-1
7019: PPUSH
7020: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7024: LD_EXP 19
7028: PPUSH
7029: LD_STRING D9a-JMM-1
7031: PPUSH
7032: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7036: LD_EXP 27
7040: PPUSH
7041: LD_STRING D9a2-Ar1-1
7043: PPUSH
7044: CALL_OW 88
// DialogueOff ;
7048: CALL_OW 7
// wait ( time ) ;
7052: LD_VAR 0 5
7056: PPUSH
7057: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7061: LD_VAR 0 4
7065: PPUSH
7066: CALL_OW 274
7070: PPUSH
7071: LD_INT 2
7073: PPUSH
7074: CALL_OW 275
7078: PUSH
7079: LD_INT 10
7081: LESS
7082: IFFALSE 7108
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7084: LD_EXP 27
7088: PPUSH
7089: LD_STRING D9a3-Ar1-1
7091: PPUSH
7092: CALL_OW 88
// no_oil_gain := true ;
7096: LD_ADDR_VAR 0 6
7100: PUSH
7101: LD_INT 1
7103: ST_TO_ADDR
// break ;
7104: GO 7162
// end else
7106: GO 7160
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7108: LD_EXP 28
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: LD_INT 2
7120: PPUSH
7121: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7125: LD_EXP 28
7129: PPUSH
7130: LD_VAR 0 3
7134: PUSH
7135: LD_VAR 0 1
7139: PUSH
7140: LD_INT 3
7142: MOD
7143: PUSH
7144: LD_INT 1
7146: PLUS
7147: ARRAY
7148: PPUSH
7149: CALL_OW 210
// wait ( 0 0$10 ) ;
7153: LD_INT 350
7155: PPUSH
7156: CALL_OW 67
// end ; end ;
7160: GO 6957
7162: POP
7163: POP
// if not no_oil_gain then
7164: LD_VAR 0 6
7168: NOT
7169: IFFALSE 8306
// begin repeat wait ( 0 0$01 ) ;
7171: LD_INT 35
7173: PPUSH
7174: CALL_OW 67
// if player_attacked_ar then
7178: LD_EXP 16
7182: IFFALSE 7186
// exit ;
7184: GO 9644
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7186: LD_VAR 0 3
7190: PUSH
7191: LD_INT 1
7193: ARRAY
7194: PPUSH
7195: CALL_OW 261
7199: PUSH
7200: LD_INT 80
7202: GREATER
7203: PUSH
7204: LD_VAR 0 3
7208: PUSH
7209: LD_INT 2
7211: ARRAY
7212: PPUSH
7213: CALL_OW 261
7217: PUSH
7218: LD_INT 80
7220: GREATER
7221: AND
7222: PUSH
7223: LD_VAR 0 3
7227: PUSH
7228: LD_INT 3
7230: ARRAY
7231: PPUSH
7232: CALL_OW 261
7236: PUSH
7237: LD_INT 80
7239: GREATER
7240: AND
7241: IFFALSE 7171
// ComMoveXY ( Gali , 105 , 127 ) ;
7243: LD_EXP 28
7247: PPUSH
7248: LD_INT 105
7250: PPUSH
7251: LD_INT 127
7253: PPUSH
7254: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7258: LD_EXP 28
7262: PPUSH
7263: LD_INT 2
7265: PPUSH
7266: CALL_OW 173
// AddComHold ( Gali ) ;
7270: LD_EXP 28
7274: PPUSH
7275: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7279: LD_INT 35
7281: PPUSH
7282: CALL_OW 67
// if player_attacked_ar then
7286: LD_EXP 16
7290: IFFALSE 7294
// exit ;
7292: GO 9644
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7294: LD_EXP 28
7298: PPUSH
7299: LD_INT 105
7301: PPUSH
7302: LD_INT 127
7304: PPUSH
7305: CALL_OW 297
7309: PUSH
7310: LD_INT 4
7312: LESS
7313: IFFALSE 7279
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7315: LD_VAR 0 4
7319: PPUSH
7320: CALL_OW 274
7324: PPUSH
7325: LD_INT 1
7327: PPUSH
7328: CALL_OW 275
7332: PUSH
7333: LD_INT 50
7335: LESS
7336: IFFALSE 7638
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7338: LD_VAR 0 4
7342: PPUSH
7343: CALL_OW 274
7347: PPUSH
7348: LD_INT 1
7350: PPUSH
7351: CALL_OW 275
7355: PUSH
7356: LD_INT 0
7358: DOUBLE
7359: GREATEREQUAL
7360: IFFALSE 7368
7362: LD_INT 24
7364: DOUBLE
7365: LESSEQUAL
7366: IFTRUE 7370
7368: GO 7385
7370: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7371: LD_EXP 28
7375: PPUSH
7376: LD_STRING D9b-Ar2-1
7378: PPUSH
7379: CALL_OW 88
7383: GO 7415
7385: LD_INT 25
7387: DOUBLE
7388: GREATEREQUAL
7389: IFFALSE 7397
7391: LD_INT 49
7393: DOUBLE
7394: LESSEQUAL
7395: IFTRUE 7399
7397: GO 7414
7399: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7400: LD_EXP 28
7404: PPUSH
7405: LD_STRING D9b-Ar2-1a
7407: PPUSH
7408: CALL_OW 88
7412: GO 7415
7414: POP
// Say ( JMM , D9b-JMM-1 ) ;
7415: LD_EXP 19
7419: PPUSH
7420: LD_STRING D9b-JMM-1
7422: PPUSH
7423: CALL_OW 88
// x := 0 0$0 ;
7427: LD_ADDR_VAR 0 2
7431: PUSH
7432: LD_INT 0
7434: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7435: LD_INT 35
7437: PPUSH
7438: CALL_OW 67
// x := x + 0 0$1 ;
7442: LD_ADDR_VAR 0 2
7446: PUSH
7447: LD_VAR 0 2
7451: PUSH
7452: LD_INT 35
7454: PLUS
7455: ST_TO_ADDR
// if player_attacked_ar then
7456: LD_EXP 16
7460: IFFALSE 7464
// exit ;
7462: GO 9644
// until x >= time ;
7464: LD_VAR 0 2
7468: PUSH
7469: LD_VAR 0 5
7473: GREATEREQUAL
7474: IFFALSE 7435
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7476: LD_VAR 0 4
7480: PPUSH
7481: CALL_OW 274
7485: PPUSH
7486: LD_INT 1
7488: PPUSH
7489: CALL_OW 275
7493: PUSH
7494: LD_INT 50
7496: LESS
7497: IFFALSE 7638
// begin have_crates := false ;
7499: LD_ADDR_VAR 0 9
7503: PUSH
7504: LD_INT 0
7506: ST_TO_ADDR
// DialogueOn ;
7507: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7511: LD_EXP 27
7515: PPUSH
7516: LD_STRING D9c-Ar1-1
7518: PPUSH
7519: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7523: LD_EXP 19
7527: PPUSH
7528: LD_STRING D9c-JMM-1
7530: PPUSH
7531: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7535: LD_EXP 27
7539: PPUSH
7540: LD_STRING D9c-Ar1-2
7542: PPUSH
7543: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7547: LD_EXP 29
7551: PPUSH
7552: LD_STRING D9c-FAr1-2
7554: PPUSH
7555: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7559: LD_EXP 27
7563: PPUSH
7564: LD_STRING D9c-Ar1-3
7566: PPUSH
7567: CALL_OW 88
// case Query ( QInfo ) of 1 :
7571: LD_STRING QInfo
7573: PPUSH
7574: CALL_OW 97
7578: PUSH
7579: LD_INT 1
7581: DOUBLE
7582: EQUAL
7583: IFTRUE 7587
7585: GO 7610
7587: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7588: LD_EXP 19
7592: PPUSH
7593: LD_STRING D8b1-JMM-1
7595: PPUSH
7596: CALL_OW 88
// player_want_info := 2 ;
7600: LD_ADDR_EXP 13
7604: PUSH
7605: LD_INT 2
7607: ST_TO_ADDR
// end ; 2 :
7608: GO 7634
7610: LD_INT 2
7612: DOUBLE
7613: EQUAL
7614: IFTRUE 7618
7616: GO 7633
7618: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7619: LD_EXP 27
7623: PPUSH
7624: LD_STRING D8b2-Ar1-1
7626: PPUSH
7627: CALL_OW 88
// end ; end ;
7631: GO 7634
7633: POP
// DialogueOff ;
7634: CALL_OW 7
// end ; end ; if have_crates then
7638: LD_VAR 0 9
7642: IFFALSE 8306
// begin RemoveEnvironmentArea ( mortarArea ) ;
7644: LD_INT 2
7646: PPUSH
7647: CALL_OW 355
// wait ( 1 ) ;
7651: LD_INT 1
7653: PPUSH
7654: CALL_OW 67
// InGameOn ;
7658: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7662: LD_EXP 28
7666: PPUSH
7667: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7671: LD_EXP 28
7675: PPUSH
7676: LD_INT 1
7678: PPUSH
7679: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7683: LD_EXP 28
7687: PPUSH
7688: LD_INT 4
7690: PPUSH
7691: LD_INT 107
7693: PPUSH
7694: LD_INT 131
7696: PPUSH
7697: LD_INT 0
7699: PPUSH
7700: CALL_OW 145
// repeat wait ( 1 ) ;
7704: LD_INT 1
7706: PPUSH
7707: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7711: LD_INT 30
7713: PUSH
7714: LD_INT 4
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PUSH
7721: LD_INT 23
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PPUSH
7735: CALL_OW 69
7739: IFFALSE 7704
// SetSide ( Gali , 2 ) ;
7741: LD_EXP 28
7745: PPUSH
7746: LD_INT 2
7748: PPUSH
7749: CALL_OW 235
// InGameOff ;
7753: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7757: LD_ADDR_VAR 0 8
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 4
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 23
7774: PUSH
7775: LD_INT 2
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: PPUSH
7786: CALL_OW 69
7790: PUSH
7791: LD_INT 1
7793: ARRAY
7794: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7795: LD_INT 35
7797: PPUSH
7798: CALL_OW 67
// if player_attacked_ar then
7802: LD_EXP 16
7806: IFFALSE 7810
// exit ;
7808: GO 9644
// until BuildingStatus ( b ) <> bs_build ;
7810: LD_VAR 0 8
7814: PPUSH
7815: CALL_OW 461
7819: PUSH
7820: LD_INT 1
7822: NONEQUAL
7823: IFFALSE 7795
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7825: LD_VAR 0 8
7829: PPUSH
7830: CALL_OW 302
7834: PUSH
7835: LD_VAR 0 4
7839: PPUSH
7840: CALL_OW 274
7844: PPUSH
7845: LD_INT 1
7847: PPUSH
7848: CALL_OW 275
7852: PUSH
7853: LD_INT 25
7855: GREATEREQUAL
7856: AND
7857: IFFALSE 7956
// begin ComUpgrade ( b ) ;
7859: LD_VAR 0 8
7863: PPUSH
7864: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7868: LD_EXP 28
7872: PPUSH
7873: LD_STRING h
7875: PUSH
7876: LD_VAR 0 8
7880: PPUSH
7881: CALL_OW 250
7885: PUSH
7886: LD_VAR 0 8
7890: PPUSH
7891: CALL_OW 251
7895: PUSH
7896: LD_VAR 0 8
7900: PUSH
7901: LD_INT 0
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: LIST
7918: PUSH
7919: EMPTY
7920: LIST
7921: PPUSH
7922: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7926: LD_INT 35
7928: PPUSH
7929: CALL_OW 67
// if player_attacked_ar then
7933: LD_EXP 16
7937: IFFALSE 7941
// exit ;
7939: GO 9644
// until BuildingStatus ( b ) <> bs_build ;
7941: LD_VAR 0 8
7945: PPUSH
7946: CALL_OW 461
7950: PUSH
7951: LD_INT 1
7953: NONEQUAL
7954: IFFALSE 7926
// end ; if b then
7956: LD_VAR 0 8
7960: IFFALSE 7971
// CenterNowOnUnits ( b ) ;
7962: LD_VAR 0 8
7966: PPUSH
7967: CALL_OW 87
// DialogueOn ;
7971: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7975: LD_EXP 28
7979: PPUSH
7980: LD_STRING D9d-Ar2-1
7982: PPUSH
7983: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7987: LD_EXP 27
7991: PPUSH
7992: LD_STRING D9d-Ar1-1
7994: PPUSH
7995: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7999: LD_EXP 19
8003: PPUSH
8004: LD_STRING D9d-JMM-1
8006: PPUSH
8007: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8011: LD_EXP 27
8015: PPUSH
8016: LD_STRING D9d-Ar1-2
8018: PPUSH
8019: CALL_OW 88
// DialogueOff ;
8023: CALL_OW 7
// i := [ ] ;
8027: LD_ADDR_VAR 0 1
8031: PUSH
8032: EMPTY
8033: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8034: LD_VAR 0 4
8038: PPUSH
8039: CALL_OW 274
8043: PPUSH
8044: LD_INT 3
8046: PPUSH
8047: CALL_OW 275
8051: PUSH
8052: LD_INT 20
8054: GREATEREQUAL
8055: IFFALSE 8074
// i := i ^ [ 1 ] ;
8057: LD_ADDR_VAR 0 1
8061: PUSH
8062: LD_VAR 0 1
8066: PUSH
8067: LD_INT 1
8069: PUSH
8070: EMPTY
8071: LIST
8072: ADD
8073: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8074: LD_VAR 0 4
8078: PPUSH
8079: CALL_OW 274
8083: PPUSH
8084: LD_INT 1
8086: PPUSH
8087: CALL_OW 275
8091: PUSH
8092: LD_INT 50
8094: GREATEREQUAL
8095: IFFALSE 8114
// i := i ^ [ 2 ] ;
8097: LD_ADDR_VAR 0 1
8101: PUSH
8102: LD_VAR 0 1
8106: PUSH
8107: LD_INT 2
8109: PUSH
8110: EMPTY
8111: LIST
8112: ADD
8113: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8114: LD_VAR 0 4
8118: PPUSH
8119: CALL_OW 274
8123: PPUSH
8124: LD_INT 2
8126: PPUSH
8127: CALL_OW 275
8131: PUSH
8132: LD_INT 80
8134: GREATEREQUAL
8135: IFFALSE 8154
// i := i ^ [ 3 ] ;
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: LD_VAR 0 1
8146: PUSH
8147: LD_INT 3
8149: PUSH
8150: EMPTY
8151: LIST
8152: ADD
8153: ST_TO_ADDR
// i := i diff 0 ;
8154: LD_ADDR_VAR 0 1
8158: PUSH
8159: LD_VAR 0 1
8163: PUSH
8164: LD_INT 0
8166: DIFF
8167: ST_TO_ADDR
// if i then
8168: LD_VAR 0 1
8172: IFFALSE 8278
// begin i := i ^ [ 4 ] ;
8174: LD_ADDR_VAR 0 1
8178: PUSH
8179: LD_VAR 0 1
8183: PUSH
8184: LD_INT 4
8186: PUSH
8187: EMPTY
8188: LIST
8189: ADD
8190: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8191: LD_STRING QInfo2
8193: PPUSH
8194: CALL_OW 97
8198: PUSH
8199: LD_INT 1
8201: DOUBLE
8202: EQUAL
8203: IFTRUE 8207
8205: GO 8218
8207: POP
// player_want_info := 3 ; 2 :
8208: LD_ADDR_EXP 13
8212: PUSH
8213: LD_INT 3
8215: ST_TO_ADDR
8216: GO 8276
8218: LD_INT 2
8220: DOUBLE
8221: EQUAL
8222: IFTRUE 8226
8224: GO 8237
8226: POP
// player_want_info := 1 ; 3 :
8227: LD_ADDR_EXP 13
8231: PUSH
8232: LD_INT 1
8234: ST_TO_ADDR
8235: GO 8276
8237: LD_INT 3
8239: DOUBLE
8240: EQUAL
8241: IFTRUE 8245
8243: GO 8256
8245: POP
// player_want_info := 2 ; 4 :
8246: LD_ADDR_EXP 13
8250: PUSH
8251: LD_INT 2
8253: ST_TO_ADDR
8254: GO 8276
8256: LD_INT 4
8258: DOUBLE
8259: EQUAL
8260: IFTRUE 8264
8262: GO 8275
8264: POP
// player_want_info := 0 ; end ;
8265: LD_ADDR_EXP 13
8269: PUSH
8270: LD_INT 0
8272: ST_TO_ADDR
8273: GO 8276
8275: POP
// end else
8276: GO 8306
// case Query ( QInfoNothing ) of 1 :
8278: LD_STRING QInfoNothing
8280: PPUSH
8281: CALL_OW 97
8285: PUSH
8286: LD_INT 1
8288: DOUBLE
8289: EQUAL
8290: IFTRUE 8294
8292: GO 8305
8294: POP
// player_want_info := 0 ; end ;
8295: LD_ADDR_EXP 13
8299: PUSH
8300: LD_INT 0
8302: ST_TO_ADDR
8303: GO 8306
8305: POP
// end ; end ; end ; if player_want_info then
8306: LD_EXP 13
8310: IFFALSE 9464
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8312: LD_ADDR_VAR 0 3
8316: PUSH
8317: LD_VAR 0 3
8321: PPUSH
8322: LD_INT 34
8324: PUSH
8325: LD_INT 32
8327: PUSH
8328: EMPTY
8329: LIST
8330: LIST
8331: PPUSH
8332: CALL_OW 72
8336: ST_TO_ADDR
// if player_want_mortar then
8337: LD_EXP 12
8341: IFFALSE 8696
// begin case player_want_info of 1 :
8343: LD_EXP 13
8347: PUSH
8348: LD_INT 1
8350: DOUBLE
8351: EQUAL
8352: IFTRUE 8356
8354: GO 8367
8356: POP
// x := 5 ; 2 :
8357: LD_ADDR_VAR 0 2
8361: PUSH
8362: LD_INT 5
8364: ST_TO_ADDR
8365: GO 8406
8367: LD_INT 2
8369: DOUBLE
8370: EQUAL
8371: IFTRUE 8375
8373: GO 8386
8375: POP
// x := 8 ; 3 :
8376: LD_ADDR_VAR 0 2
8380: PUSH
8381: LD_INT 8
8383: ST_TO_ADDR
8384: GO 8406
8386: LD_INT 3
8388: DOUBLE
8389: EQUAL
8390: IFTRUE 8394
8392: GO 8405
8394: POP
// x := 2 ; end ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ST_TO_ADDR
8403: GO 8406
8405: POP
// repeat wait ( 0 0$1 ) ;
8406: LD_INT 35
8408: PPUSH
8409: CALL_OW 67
// until not HasTask ( Gali ) ;
8413: LD_EXP 28
8417: PPUSH
8418: CALL_OW 314
8422: NOT
8423: IFFALSE 8406
// time := 0 0$00 ;
8425: LD_ADDR_VAR 0 5
8429: PUSH
8430: LD_INT 0
8432: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8433: LD_INT 35
8435: PPUSH
8436: CALL_OW 67
// time := time + 0 0$1 ;
8440: LD_ADDR_VAR 0 5
8444: PUSH
8445: LD_VAR 0 5
8449: PUSH
8450: LD_INT 35
8452: PLUS
8453: ST_TO_ADDR
// if debug then
8454: LD_EXP 2
8458: IFFALSE 8477
// debug_strings := [ time: & time ] ;
8460: LD_ADDR_OWVAR 48
8464: PUSH
8465: LD_STRING time:
8467: PUSH
8468: LD_VAR 0 5
8472: STR
8473: PUSH
8474: EMPTY
8475: LIST
8476: ST_TO_ADDR
// if time > 8 8$00 then
8477: LD_VAR 0 5
8481: PUSH
8482: LD_INT 16800
8484: GREATER
8485: IFFALSE 8497
// begin blocked := true ;
8487: LD_ADDR_EXP 18
8491: PUSH
8492: LD_INT 1
8494: ST_TO_ADDR
// exit ;
8495: GO 9644
// end ; if not Carry ( Gali ) then
8497: LD_EXP 28
8501: PPUSH
8502: CALL_OW 281
8506: NOT
8507: IFFALSE 8530
// ComTransport ( Gali , dep , player_want_info ) else
8509: LD_EXP 28
8513: PPUSH
8514: LD_VAR 0 4
8518: PPUSH
8519: LD_EXP 13
8523: PPUSH
8524: CALL_OW 151
8528: GO 8648
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8530: LD_EXP 28
8534: PPUSH
8535: LD_VAR 0 3
8539: PUSH
8540: LD_INT 1
8542: ARRAY
8543: PPUSH
8544: CALL_OW 296
8548: PUSH
8549: LD_INT 4
8551: LESS
8552: PUSH
8553: LD_EXP 28
8557: PPUSH
8558: LD_EXP 13
8562: PPUSH
8563: CALL_OW 289
8567: AND
8568: IFFALSE 8630
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8570: LD_VAR 0 3
8574: PUSH
8575: LD_INT 1
8577: ARRAY
8578: PPUSH
8579: LD_EXP 13
8583: PPUSH
8584: LD_VAR 0 3
8588: PUSH
8589: LD_INT 1
8591: ARRAY
8592: PPUSH
8593: LD_EXP 13
8597: PPUSH
8598: CALL_OW 289
8602: PUSH
8603: LD_INT 10
8605: PLUS
8606: PPUSH
8607: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8611: LD_EXP 28
8615: PPUSH
8616: LD_EXP 13
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 290
// end else
8628: GO 8648
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8630: LD_EXP 28
8634: PPUSH
8635: LD_VAR 0 3
8639: PUSH
8640: LD_INT 1
8642: ARRAY
8643: PPUSH
8644: CALL_OW 112
// end ; if player_attacked_ar then
8648: LD_EXP 16
8652: IFFALSE 8656
// exit ;
8654: GO 9644
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
8656: LD_VAR 0 3
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_EXP 13
8669: PPUSH
8670: CALL_OW 289
8674: PUSH
8675: LD_VAR 0 2
8679: PUSH
8680: LD_INT 10
8682: MUL
8683: GREATEREQUAL
8684: IFFALSE 8433
// no_oil_gain := false ;
8686: LD_ADDR_VAR 0 6
8690: PUSH
8691: LD_INT 0
8693: ST_TO_ADDR
// end else
8694: GO 9285
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8696: LD_ADDR_VAR 0 3
8700: PUSH
8701: LD_INT 22
8703: PUSH
8704: LD_INT 2
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: LD_INT 21
8713: PUSH
8714: LD_INT 2
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: PPUSH
8725: CALL_OW 69
8729: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8730: LD_EXP 28
8734: PPUSH
8735: LD_VAR 0 4
8739: PPUSH
8740: CALL_OW 250
8744: PUSH
8745: LD_INT 1
8747: PLUS
8748: PPUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 251
8758: PUSH
8759: LD_INT 1
8761: PLUS
8762: PPUSH
8763: CALL_OW 111
// time := 0 0$00 ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 0
8774: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8775: LD_INT 35
8777: PPUSH
8778: CALL_OW 67
// time := time + 0 0$1 ;
8782: LD_ADDR_VAR 0 5
8786: PUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 35
8794: PLUS
8795: ST_TO_ADDR
// if time > 1 1$45 then
8796: LD_VAR 0 5
8800: PUSH
8801: LD_INT 3675
8803: GREATER
8804: IFFALSE 8808
// break ;
8806: GO 8828
// until GetDistUnits ( Gali , dep ) < 4 ;
8808: LD_EXP 28
8812: PPUSH
8813: LD_VAR 0 4
8817: PPUSH
8818: CALL_OW 296
8822: PUSH
8823: LD_INT 4
8825: LESS
8826: IFFALSE 8775
// for i = 1 to 6 do
8828: LD_ADDR_VAR 0 1
8832: PUSH
8833: DOUBLE
8834: LD_INT 1
8836: DEC
8837: ST_TO_ADDR
8838: LD_INT 6
8840: PUSH
8841: FOR_TO
8842: IFFALSE 9046
// begin if player_attacked_ar then
8844: LD_EXP 16
8848: IFFALSE 8854
// exit ;
8850: POP
8851: POP
8852: GO 9644
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8854: LD_VAR 0 4
8858: PPUSH
8859: CALL_OW 274
8863: PPUSH
8864: LD_INT 2
8866: PPUSH
8867: CALL_OW 275
8871: PUSH
8872: LD_INT 10
8874: LESS
8875: PUSH
8876: LD_VAR 0 7
8880: NOT
8881: AND
8882: IFFALSE 8945
// begin first_warn := true ;
8884: LD_ADDR_VAR 0 7
8888: PUSH
8889: LD_INT 1
8891: ST_TO_ADDR
// DialogueOn ;
8892: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8896: LD_EXP 29
8900: PPUSH
8901: LD_STRING D9a-FAr1-1
8903: PPUSH
8904: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8908: LD_EXP 19
8912: PPUSH
8913: LD_STRING D9a-JMM-1
8915: PPUSH
8916: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8920: LD_EXP 27
8924: PPUSH
8925: LD_STRING D9a2-Ar1-1
8927: PPUSH
8928: CALL_OW 88
// DialogueOff ;
8932: CALL_OW 7
// wait ( time ) ;
8936: LD_VAR 0 5
8940: PPUSH
8941: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8945: LD_VAR 0 4
8949: PPUSH
8950: CALL_OW 274
8954: PPUSH
8955: LD_INT 2
8957: PPUSH
8958: CALL_OW 275
8962: PUSH
8963: LD_INT 10
8965: LESS
8966: IFFALSE 8992
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8968: LD_EXP 27
8972: PPUSH
8973: LD_STRING D9a3-Ar1-1
8975: PPUSH
8976: CALL_OW 88
// no_oil_gain := true ;
8980: LD_ADDR_VAR 0 6
8984: PUSH
8985: LD_INT 1
8987: ST_TO_ADDR
// break ;
8988: GO 9046
// end else
8990: GO 9044
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8992: LD_EXP 28
8996: PPUSH
8997: LD_VAR 0 4
9001: PPUSH
9002: LD_INT 2
9004: PPUSH
9005: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9009: LD_EXP 28
9013: PPUSH
9014: LD_VAR 0 3
9018: PUSH
9019: LD_VAR 0 1
9023: PUSH
9024: LD_INT 3
9026: MOD
9027: PUSH
9028: LD_INT 1
9030: PLUS
9031: ARRAY
9032: PPUSH
9033: CALL_OW 210
// wait ( 0 0$10 ) ;
9037: LD_INT 350
9039: PPUSH
9040: CALL_OW 67
// end ; end ;
9044: GO 8841
9046: POP
9047: POP
// time := 0 0$00 ;
9048: LD_ADDR_VAR 0 5
9052: PUSH
9053: LD_INT 0
9055: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9056: LD_INT 35
9058: PPUSH
9059: CALL_OW 67
// if not HasTask ( Gali ) then
9063: LD_EXP 28
9067: PPUSH
9068: CALL_OW 314
9072: NOT
9073: IFFALSE 9089
// time := time + 0 0$1 ;
9075: LD_ADDR_VAR 0 5
9079: PUSH
9080: LD_VAR 0 5
9084: PUSH
9085: LD_INT 35
9087: PLUS
9088: ST_TO_ADDR
// if time > 1 1$25 then
9089: LD_VAR 0 5
9093: PUSH
9094: LD_INT 2975
9096: GREATER
9097: IFFALSE 9121
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9099: LD_EXP 27
9103: PPUSH
9104: LD_STRING D9a3-Ar1-1
9106: PPUSH
9107: CALL_OW 88
// no_oil_gain := true ;
9111: LD_ADDR_VAR 0 6
9115: PUSH
9116: LD_INT 1
9118: ST_TO_ADDR
// break ;
9119: GO 9285
// end ; if player_attacked_ar then
9121: LD_EXP 16
9125: IFFALSE 9129
// exit ;
9127: GO 9644
// for i in tmp do
9129: LD_ADDR_VAR 0 1
9133: PUSH
9134: LD_VAR 0 3
9138: PUSH
9139: FOR_IN
9140: IFFALSE 9171
// if GetFuel ( i ) < 100 then
9142: LD_VAR 0 1
9146: PPUSH
9147: CALL_OW 261
9151: PUSH
9152: LD_INT 100
9154: LESS
9155: IFFALSE 9169
// begin x := i ;
9157: LD_ADDR_VAR 0 2
9161: PUSH
9162: LD_VAR 0 1
9166: ST_TO_ADDR
// break ;
9167: GO 9171
// end ;
9169: GO 9139
9171: POP
9172: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9173: LD_EXP 28
9177: PPUSH
9178: CALL_OW 314
9182: NOT
9183: PUSH
9184: LD_EXP 28
9188: PPUSH
9189: CALL_OW 281
9193: NOT
9194: AND
9195: IFFALSE 9228
// begin ComTransport ( Gali , dep , mat_oil ) ;
9197: LD_EXP 28
9201: PPUSH
9202: LD_VAR 0 4
9206: PPUSH
9207: LD_INT 2
9209: PPUSH
9210: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9214: LD_EXP 28
9218: PPUSH
9219: LD_VAR 0 2
9223: PPUSH
9224: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9228: LD_VAR 0 3
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PPUSH
9237: CALL_OW 261
9241: PUSH
9242: LD_INT 80
9244: GREATER
9245: PUSH
9246: LD_VAR 0 3
9250: PUSH
9251: LD_INT 2
9253: ARRAY
9254: PPUSH
9255: CALL_OW 261
9259: PUSH
9260: LD_INT 80
9262: GREATER
9263: AND
9264: PUSH
9265: LD_VAR 0 3
9269: PUSH
9270: LD_INT 3
9272: ARRAY
9273: PPUSH
9274: CALL_OW 261
9278: PUSH
9279: LD_INT 80
9281: GREATER
9282: AND
9283: IFFALSE 9056
// end ; ComHold ( Gali ) ;
9285: LD_EXP 28
9289: PPUSH
9290: CALL_OW 140
// if not no_oil_gain then
9294: LD_VAR 0 6
9298: NOT
9299: IFFALSE 9464
// begin DialogueOn ;
9301: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9305: LD_EXP 27
9309: PPUSH
9310: CALL_OW 87
// if player_want_mortar then
9314: LD_EXP 12
9318: IFFALSE 9344
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9320: LD_EXP 27
9324: PPUSH
9325: LD_STRING D9e-Ar1-1
9327: PPUSH
9328: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9332: LD_EXP 19
9336: PPUSH
9337: LD_STRING D10a-JMM-1
9339: PPUSH
9340: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9344: LD_EXP 27
9348: PPUSH
9349: LD_STRING D10a-Ar1-1
9351: PPUSH
9352: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9356: LD_EXP 28
9360: PPUSH
9361: LD_STRING D10a-Ar2-1
9363: PPUSH
9364: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9368: LD_EXP 29
9372: PPUSH
9373: LD_STRING D10a-FAr1-1
9375: PPUSH
9376: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9380: LD_EXP 28
9384: PPUSH
9385: LD_STRING D10a-Ar2-2
9387: PPUSH
9388: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9392: LD_EXP 29
9396: PPUSH
9397: LD_STRING D10a-FAr1-2
9399: PPUSH
9400: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9404: LD_EXP 27
9408: PPUSH
9409: LD_STRING D10a-Ar1-2
9411: PPUSH
9412: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9416: LD_EXP 19
9420: PPUSH
9421: LD_STRING D10a-JMM-2
9423: PPUSH
9424: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9428: LD_EXP 27
9432: PPUSH
9433: LD_STRING D10a-Ar1-3
9435: PPUSH
9436: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9440: LD_EXP 19
9444: PPUSH
9445: LD_STRING D10a-JMM-3
9447: PPUSH
9448: CALL_OW 88
// player_get_info := true ;
9452: LD_ADDR_EXP 15
9456: PUSH
9457: LD_INT 1
9459: ST_TO_ADDR
// DialogueOff ;
9460: CALL_OW 7
// end ; end ; if player_attacked_ar then
9464: LD_EXP 16
9468: IFFALSE 9472
// exit ;
9470: GO 9644
// if player_want_mortar or player_want_info then
9472: LD_EXP 12
9476: PUSH
9477: LD_EXP 13
9481: OR
9482: IFFALSE 9496
// Say ( Vervecken , D9f-Ar1-1 ) ;
9484: LD_EXP 27
9488: PPUSH
9489: LD_STRING D9f-Ar1-1
9491: PPUSH
9492: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9496: LD_INT 22
9498: PUSH
9499: LD_INT 2
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: PPUSH
9506: CALL_OW 69
9510: PPUSH
9511: LD_INT 51
9513: PPUSH
9514: LD_INT 99
9516: PPUSH
9517: CALL_OW 111
// wait ( 0 0$1 ) ;
9521: LD_INT 35
9523: PPUSH
9524: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9528: LD_INT 22
9530: PUSH
9531: LD_INT 2
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: PUSH
9538: LD_INT 92
9540: PUSH
9541: LD_INT 51
9543: PUSH
9544: LD_INT 99
9546: PUSH
9547: LD_INT 2
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: LIST
9554: LIST
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: PPUSH
9560: CALL_OW 69
9564: IFFALSE 9624
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9566: LD_ADDR_VAR 0 1
9570: PUSH
9571: LD_INT 22
9573: PUSH
9574: LD_INT 2
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 92
9583: PUSH
9584: LD_INT 51
9586: PUSH
9587: LD_INT 99
9589: PUSH
9590: LD_INT 2
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: LIST
9597: LIST
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 69
9607: PUSH
9608: FOR_IN
9609: IFFALSE 9622
// RemoveUnit ( i ) ;
9611: LD_VAR 0 1
9615: PPUSH
9616: CALL_OW 64
9620: GO 9608
9622: POP
9623: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9624: LD_INT 22
9626: PUSH
9627: LD_INT 2
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PPUSH
9634: CALL_OW 69
9638: PUSH
9639: LD_INT 0
9641: EQUAL
9642: IFFALSE 9496
// end ;
9644: PPOPN 9
9646: END
// every 0 0$01 trigger blocked do var i ;
9647: LD_EXP 18
9651: IFFALSE 9819
9653: GO 9655
9655: DISABLE
9656: LD_INT 0
9658: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9659: LD_EXP 27
9663: PPUSH
9664: LD_STRING D9f-Ar1-1
9666: PPUSH
9667: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9671: LD_INT 22
9673: PUSH
9674: LD_INT 2
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: PPUSH
9681: CALL_OW 69
9685: PPUSH
9686: LD_INT 51
9688: PPUSH
9689: LD_INT 99
9691: PPUSH
9692: CALL_OW 111
// wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9703: LD_INT 22
9705: PUSH
9706: LD_INT 2
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PUSH
9713: LD_INT 92
9715: PUSH
9716: LD_INT 51
9718: PUSH
9719: LD_INT 99
9721: PUSH
9722: LD_INT 2
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: PUSH
9731: EMPTY
9732: LIST
9733: LIST
9734: PPUSH
9735: CALL_OW 69
9739: IFFALSE 9799
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9741: LD_ADDR_VAR 0 1
9745: PUSH
9746: LD_INT 22
9748: PUSH
9749: LD_INT 2
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PUSH
9756: LD_INT 92
9758: PUSH
9759: LD_INT 51
9761: PUSH
9762: LD_INT 99
9764: PUSH
9765: LD_INT 2
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: LIST
9772: LIST
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PPUSH
9778: CALL_OW 69
9782: PUSH
9783: FOR_IN
9784: IFFALSE 9797
// RemoveUnit ( i ) ;
9786: LD_VAR 0 1
9790: PPUSH
9791: CALL_OW 64
9795: GO 9783
9797: POP
9798: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9799: LD_INT 22
9801: PUSH
9802: LD_INT 2
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PPUSH
9809: CALL_OW 69
9813: PUSH
9814: LD_INT 0
9816: EQUAL
9817: IFFALSE 9671
// end ;
9819: PPOPN 1
9821: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9822: LD_EXP 16
9826: IFFALSE 10179
9828: GO 9830
9830: DISABLE
9831: LD_INT 0
9833: PPUSH
9834: PPUSH
9835: PPUSH
9836: PPUSH
// begin ru_can_attack := true ;
9837: LD_ADDR_EXP 8
9841: PUSH
9842: LD_INT 1
9844: ST_TO_ADDR
// mine_launched := false ;
9845: LD_ADDR_VAR 0 3
9849: PUSH
9850: LD_INT 0
9852: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9853: LD_INT 22
9855: PUSH
9856: LD_INT 2
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: PPUSH
9863: CALL_OW 69
9867: PPUSH
9868: LD_INT 51
9870: PPUSH
9871: LD_INT 99
9873: PPUSH
9874: CALL_OW 111
// if IsOk ( Vervecken ) then
9878: LD_EXP 27
9882: PPUSH
9883: CALL_OW 302
9887: IFFALSE 9901
// Say ( Vervecken , D11a-Ar1-1 ) ;
9889: LD_EXP 27
9893: PPUSH
9894: LD_STRING D11a-Ar1-1
9896: PPUSH
9897: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9901: LD_ADDR_VAR 0 2
9905: PUSH
9906: LD_EXP 34
9910: PPUSH
9911: LD_INT 25
9913: PUSH
9914: LD_INT 1
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: PPUSH
9921: CALL_OW 72
9925: ST_TO_ADDR
// for i in tmp do
9926: LD_ADDR_VAR 0 1
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: FOR_IN
9937: IFFALSE 10000
// if MineOfUnit ( i ) then
9939: LD_VAR 0 1
9943: PPUSH
9944: CALL_OW 459
9948: IFFALSE 9998
// begin x := MineOfUnit ( i ) ;
9950: LD_ADDR_VAR 0 4
9954: PUSH
9955: LD_VAR 0 1
9959: PPUSH
9960: CALL_OW 459
9964: ST_TO_ADDR
// mine_launched := true ;
9965: LD_ADDR_VAR 0 3
9969: PUSH
9970: LD_INT 1
9972: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9973: LD_VAR 0 4
9977: PUSH
9978: LD_INT 1
9980: ARRAY
9981: PPUSH
9982: LD_VAR 0 4
9986: PUSH
9987: LD_INT 2
9989: ARRAY
9990: PPUSH
9991: LD_INT 2
9993: PPUSH
9994: CALL_OW 456
// end ;
9998: GO 9936
10000: POP
10001: POP
// if mine_launched and IsOk ( Vervecken ) then
10002: LD_VAR 0 3
10006: PUSH
10007: LD_EXP 27
10011: PPUSH
10012: CALL_OW 302
10016: AND
10017: IFFALSE 10031
// Say ( Vervecken , D11b-Ar1-1 ) ;
10019: LD_EXP 27
10023: PPUSH
10024: LD_STRING D11b-Ar1-1
10026: PPUSH
10027: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10031: LD_INT 22
10033: PUSH
10034: LD_INT 2
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PPUSH
10041: CALL_OW 69
10045: PPUSH
10046: LD_INT 51
10048: PPUSH
10049: LD_INT 99
10051: PPUSH
10052: CALL_OW 111
// wait ( 0 0$1 ) ;
10056: LD_INT 35
10058: PPUSH
10059: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 92
10075: PUSH
10076: LD_INT 51
10078: PUSH
10079: LD_INT 99
10081: PUSH
10082: LD_INT 2
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: PUSH
10091: EMPTY
10092: LIST
10093: LIST
10094: PPUSH
10095: CALL_OW 69
10099: IFFALSE 10159
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10101: LD_ADDR_VAR 0 1
10105: PUSH
10106: LD_INT 22
10108: PUSH
10109: LD_INT 2
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: PUSH
10116: LD_INT 92
10118: PUSH
10119: LD_INT 51
10121: PUSH
10122: LD_INT 99
10124: PUSH
10125: LD_INT 2
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: PPUSH
10138: CALL_OW 69
10142: PUSH
10143: FOR_IN
10144: IFFALSE 10157
// RemoveUnit ( i ) ;
10146: LD_VAR 0 1
10150: PPUSH
10151: CALL_OW 64
10155: GO 10143
10157: POP
10158: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10159: LD_INT 22
10161: PUSH
10162: LD_INT 2
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: PPUSH
10169: CALL_OW 69
10173: PUSH
10174: LD_INT 0
10176: EQUAL
10177: IFFALSE 10031
// end ;
10179: PPOPN 4
10181: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10182: LD_EXP 10
10186: IFFALSE 10365
10188: GO 10190
10190: DISABLE
10191: LD_INT 0
10193: PPUSH
// begin Wait ( 10 10$00 ) ;
10194: LD_INT 21000
10196: PPUSH
10197: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10201: LD_INT 22
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PPUSH
10211: CALL_OW 69
10215: IFFALSE 10365
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10217: LD_INT 22
10219: PUSH
10220: LD_INT 2
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PPUSH
10227: CALL_OW 69
10231: PPUSH
10232: LD_INT 51
10234: PPUSH
10235: LD_INT 99
10237: PPUSH
10238: CALL_OW 114
// wait ( 0 0$1 ) ;
10242: LD_INT 35
10244: PPUSH
10245: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10249: LD_INT 22
10251: PUSH
10252: LD_INT 2
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PUSH
10259: LD_INT 92
10261: PUSH
10262: LD_INT 51
10264: PUSH
10265: LD_INT 99
10267: PUSH
10268: LD_INT 2
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: PPUSH
10281: CALL_OW 69
10285: IFFALSE 10345
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10287: LD_ADDR_VAR 0 1
10291: PUSH
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: LD_INT 92
10304: PUSH
10305: LD_INT 51
10307: PUSH
10308: LD_INT 99
10310: PUSH
10311: LD_INT 2
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: CALL_OW 69
10328: PUSH
10329: FOR_IN
10330: IFFALSE 10343
// RemoveUnit ( i ) ;
10332: LD_VAR 0 1
10336: PPUSH
10337: CALL_OW 64
10341: GO 10329
10343: POP
10344: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10345: LD_INT 22
10347: PUSH
10348: LD_INT 2
10350: PUSH
10351: EMPTY
10352: LIST
10353: LIST
10354: PPUSH
10355: CALL_OW 69
10359: PUSH
10360: LD_INT 0
10362: EQUAL
10363: IFFALSE 10217
// end ; end ;
10365: PPOPN 1
10367: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
10368: LD_EXP 4
10372: IFFALSE 11300
10374: GO 10376
10376: DISABLE
10377: LD_INT 0
10379: PPUSH
10380: PPUSH
10381: PPUSH
// begin Wait ( game_time ) ;
10382: LD_EXP 7
10386: PPUSH
10387: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10391: LD_INT 35
10393: PPUSH
10394: CALL_OW 67
// until ( not ru_can_attack ) ;
10398: LD_EXP 8
10402: NOT
10403: IFFALSE 10391
// Wait ( 0 0$35 ) ;
10405: LD_INT 1225
10407: PPUSH
10408: CALL_OW 67
// DialogueOn ;
10412: CALL_OW 6
// InGameOn ;
10416: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10420: LD_EXP 26
10424: PPUSH
10425: LD_STRING D12-Pow-1
10427: PPUSH
10428: CALL_OW 94
// InGameOff ;
10432: CALL_OW 9
// DialogueOff ;
10436: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10440: LD_STRING M4
10442: PPUSH
10443: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10447: LD_INT 5
10449: PPUSH
10450: LD_INT 1
10452: PPUSH
10453: CALL_OW 424
// can_end := true ;
10457: LD_ADDR_EXP 17
10461: PUSH
10462: LD_INT 1
10464: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10465: LD_INT 35
10467: PPUSH
10468: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10472: CALL 809 0 0
10476: PUSH
10477: LD_INT 20
10479: GREATEREQUAL
10480: PUSH
10481: LD_INT 22
10483: PUSH
10484: LD_INT 1
10486: PUSH
10487: EMPTY
10488: LIST
10489: LIST
10490: PUSH
10491: LD_INT 21
10493: PUSH
10494: LD_INT 1
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: PPUSH
10505: CALL_OW 69
10509: PUSH
10510: LD_INT 5
10512: PPUSH
10513: LD_INT 22
10515: PUSH
10516: LD_INT 1
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: PUSH
10523: LD_INT 21
10525: PUSH
10526: LD_INT 1
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PPUSH
10537: CALL_OW 70
10541: PUSH
10542: LD_INT 22
10544: PUSH
10545: LD_INT 1
10547: PUSH
10548: EMPTY
10549: LIST
10550: LIST
10551: PUSH
10552: LD_INT 55
10554: PUSH
10555: EMPTY
10556: LIST
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 69
10566: PLUS
10567: LESSEQUAL
10568: AND
10569: IFFALSE 10465
// if not player_get_info then
10571: LD_EXP 15
10575: NOT
10576: IFFALSE 10587
// player_get_info := - 1 ;
10578: LD_ADDR_EXP 15
10582: PUSH
10583: LD_INT 1
10585: NEG
10586: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10587: LD_STRING Information
10589: PPUSH
10590: LD_EXP 15
10594: PPUSH
10595: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10599: LD_ADDR_VAR 0 2
10603: PUSH
10604: LD_INT 22
10606: PUSH
10607: LD_INT 1
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: LD_INT 25
10619: PUSH
10620: LD_INT 2
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PUSH
10627: LD_INT 25
10629: PUSH
10630: LD_INT 16
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PUSH
10637: LD_INT 34
10639: PUSH
10640: LD_INT 12
10642: PUSH
10643: EMPTY
10644: LIST
10645: LIST
10646: PUSH
10647: EMPTY
10648: LIST
10649: LIST
10650: LIST
10651: LIST
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PPUSH
10657: CALL_OW 69
10661: ST_TO_ADDR
// sib := GetTerminalCargo ;
10662: LD_ADDR_VAR 0 3
10666: PUSH
10667: CALL 809 0 0
10671: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10672: LD_ADDR_VAR 0 3
10676: PUSH
10677: LD_VAR 0 3
10681: PUSH
10682: LD_INT 6
10684: PPUSH
10685: LD_INT 3
10687: PPUSH
10688: CALL_OW 287
10692: PLUS
10693: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10694: LD_ADDR_VAR 0 3
10698: PUSH
10699: LD_VAR 0 3
10703: PUSH
10704: LD_VAR 0 2
10708: PPUSH
10709: LD_INT 3
10711: PPUSH
10712: CALL_OW 289
10716: PLUS
10717: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10718: LD_VAR 0 3
10722: PUSH
10723: LD_INT 2
10725: PUSH
10726: LD_OWVAR 67
10730: PLUS
10731: PUSH
10732: LD_INT 50
10734: MUL
10735: LESS
10736: IFFALSE 10761
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10738: LD_STRING MuchSiberite
10740: PPUSH
10741: LD_INT 2
10743: NEG
10744: PUSH
10745: LD_OWVAR 67
10749: MUL
10750: PUSH
10751: LD_INT 1
10753: PLUS
10754: PPUSH
10755: CALL_OW 101
10759: GO 10771
// AddMedal ( MuchSiberite , 1 ) ;
10761: LD_STRING MuchSiberite
10763: PPUSH
10764: LD_INT 1
10766: PPUSH
10767: CALL_OW 101
// GiveMedals ( MAIN ) ;
10771: LD_STRING MAIN
10773: PPUSH
10774: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10778: LD_INT 22
10780: PUSH
10781: LD_INT 1
10783: PUSH
10784: EMPTY
10785: LIST
10786: LIST
10787: PUSH
10788: LD_INT 2
10790: PUSH
10791: LD_INT 25
10793: PUSH
10794: LD_INT 1
10796: PUSH
10797: EMPTY
10798: LIST
10799: LIST
10800: PUSH
10801: LD_INT 25
10803: PUSH
10804: LD_INT 2
10806: PUSH
10807: EMPTY
10808: LIST
10809: LIST
10810: PUSH
10811: LD_INT 25
10813: PUSH
10814: LD_INT 3
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PUSH
10821: LD_INT 25
10823: PUSH
10824: LD_INT 4
10826: PUSH
10827: EMPTY
10828: LIST
10829: LIST
10830: PUSH
10831: LD_INT 25
10833: PUSH
10834: LD_INT 8
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: PUSH
10841: EMPTY
10842: LIST
10843: LIST
10844: LIST
10845: LIST
10846: LIST
10847: LIST
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: PPUSH
10853: CALL_OW 69
10857: PPUSH
10858: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10862: LD_ADDR_VAR 0 2
10866: PUSH
10867: LD_INT 22
10869: PUSH
10870: LD_INT 1
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: PUSH
10877: LD_INT 25
10879: PUSH
10880: LD_INT 8
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PPUSH
10891: CALL_OW 69
10895: ST_TO_ADDR
// if tmp then
10896: LD_VAR 0 2
10900: IFFALSE 10931
// for i in tmp do
10902: LD_ADDR_VAR 0 1
10906: PUSH
10907: LD_VAR 0 2
10911: PUSH
10912: FOR_IN
10913: IFFALSE 10929
// SetClass ( i , 1 ) ;
10915: LD_VAR 0 1
10919: PPUSH
10920: LD_INT 1
10922: PPUSH
10923: CALL_OW 336
10927: GO 10912
10929: POP
10930: POP
// SaveVariable ( sib , 09_sibRes ) ;
10931: LD_VAR 0 3
10935: PPUSH
10936: LD_STRING 09_sibRes
10938: PPUSH
10939: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10943: LD_EXP 15
10947: PPUSH
10948: LD_STRING 09_arInfo
10950: PPUSH
10951: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10955: LD_EXP 19
10959: PPUSH
10960: LD_EXP 1
10964: PUSH
10965: LD_STRING JMM
10967: STR
10968: PPUSH
10969: CALL_OW 38
// if IsLive ( Gary ) then
10973: LD_EXP 20
10977: PPUSH
10978: CALL_OW 300
10982: IFFALSE 11002
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10984: LD_EXP 20
10988: PPUSH
10989: LD_EXP 1
10993: PUSH
10994: LD_STRING Gary
10996: STR
10997: PPUSH
10998: CALL_OW 38
// if IsLive ( Bobby ) then
11002: LD_EXP 21
11006: PPUSH
11007: CALL_OW 300
11011: IFFALSE 11031
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11013: LD_EXP 21
11017: PPUSH
11018: LD_EXP 1
11022: PUSH
11023: LD_STRING Bobby
11025: STR
11026: PPUSH
11027: CALL_OW 38
// if IsLive ( Cyrus ) then
11031: LD_EXP 22
11035: PPUSH
11036: CALL_OW 300
11040: IFFALSE 11060
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11042: LD_EXP 22
11046: PPUSH
11047: LD_EXP 1
11051: PUSH
11052: LD_STRING Cyrus
11054: STR
11055: PPUSH
11056: CALL_OW 38
// if IsLive ( Houten ) then
11060: LD_EXP 23
11064: PPUSH
11065: CALL_OW 300
11069: IFFALSE 11089
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11071: LD_EXP 23
11075: PPUSH
11076: LD_EXP 1
11080: PUSH
11081: LD_STRING Houten
11083: STR
11084: PPUSH
11085: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11089: LD_ADDR_VAR 0 2
11093: PUSH
11094: LD_INT 22
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: LD_INT 2
11106: PUSH
11107: LD_INT 25
11109: PUSH
11110: LD_INT 1
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 25
11119: PUSH
11120: LD_INT 2
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: PUSH
11127: LD_INT 25
11129: PUSH
11130: LD_INT 3
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 25
11139: PUSH
11140: LD_INT 4
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PPUSH
11158: CALL_OW 69
11162: PUSH
11163: LD_EXP 19
11167: PUSH
11168: LD_EXP 22
11172: PUSH
11173: LD_EXP 21
11177: PUSH
11178: LD_EXP 23
11182: PUSH
11183: LD_EXP 20
11187: PUSH
11188: EMPTY
11189: LIST
11190: LIST
11191: LIST
11192: LIST
11193: LIST
11194: DIFF
11195: ST_TO_ADDR
// if tmp then
11196: LD_VAR 0 2
11200: IFFALSE 11220
// SaveCharacters ( tmp , mission_prefix & others ) ;
11202: LD_VAR 0 2
11206: PPUSH
11207: LD_EXP 1
11211: PUSH
11212: LD_STRING others
11214: STR
11215: PPUSH
11216: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11220: LD_ADDR_VAR 0 2
11224: PUSH
11225: LD_INT 22
11227: PUSH
11228: LD_INT 1
11230: PUSH
11231: EMPTY
11232: LIST
11233: LIST
11234: PUSH
11235: LD_INT 2
11237: PUSH
11238: LD_INT 25
11240: PUSH
11241: LD_INT 12
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: PUSH
11248: LD_INT 25
11250: PUSH
11251: LD_INT 16
11253: PUSH
11254: EMPTY
11255: LIST
11256: LIST
11257: PUSH
11258: EMPTY
11259: LIST
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: ST_TO_ADDR
// if tmp then
11272: LD_VAR 0 2
11276: IFFALSE 11296
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11278: LD_VAR 0 2
11282: PPUSH
11283: LD_EXP 1
11287: PUSH
11288: LD_STRING apes
11290: STR
11291: PPUSH
11292: CALL_OW 38
// YouWin ;
11296: CALL_OW 103
// end ; end_of_file
11300: PPOPN 3
11302: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11303: LD_VAR 0 1
11307: PPUSH
11308: CALL_OW 266
11312: PUSH
11313: LD_INT 0
11315: EQUAL
11316: PUSH
11317: LD_EXP 3
11321: NOT
11322: AND
11323: IFFALSE 11347
// begin terminal := b ;
11325: LD_ADDR_EXP 3
11329: PUSH
11330: LD_VAR 0 1
11334: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11335: LD_EXP 3
11339: PPUSH
11340: LD_STRING terminal
11342: PPUSH
11343: CALL_OW 500
// end ; end ;
11347: PPOPN 2
11349: END
// on BuildingComplete ( b ) do var i ;
11350: LD_INT 0
11352: PPUSH
// begin if GetSide ( b ) = 3 then
11353: LD_VAR 0 1
11357: PPUSH
11358: CALL_OW 255
11362: PUSH
11363: LD_INT 3
11365: EQUAL
11366: IFFALSE 11406
// for i = 1 to 4 do
11368: LD_ADDR_VAR 0 2
11372: PUSH
11373: DOUBLE
11374: LD_INT 1
11376: DEC
11377: ST_TO_ADDR
11378: LD_INT 4
11380: PUSH
11381: FOR_TO
11382: IFFALSE 11404
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11384: LD_ADDR_EXP 37
11388: PUSH
11389: LD_EXP 37
11393: PPUSH
11394: LD_INT 1
11396: PPUSH
11397: CALL_OW 3
11401: ST_TO_ADDR
11402: GO 11381
11404: POP
11405: POP
// end ;
11406: PPOPN 2
11408: END
// on VehicleConstructed ( veh , fac ) do var i ;
11409: LD_INT 0
11411: PPUSH
// begin if GetSide ( veh ) = 3 then
11412: LD_VAR 0 1
11416: PPUSH
11417: CALL_OW 255
11421: PUSH
11422: LD_INT 3
11424: EQUAL
11425: IFFALSE 11550
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11427: LD_VAR 0 1
11431: PPUSH
11432: CALL_OW 264
11436: PUSH
11437: LD_INT 53
11439: PUSH
11440: LD_INT 52
11442: PUSH
11443: LD_INT 51
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: LIST
11450: IN
11451: NOT
11452: IFFALSE 11470
// ru_force := ru_force ^ veh ;
11454: LD_ADDR_EXP 36
11458: PUSH
11459: LD_EXP 36
11463: PUSH
11464: LD_VAR 0 1
11468: ADD
11469: ST_TO_ADDR
// for i = 1 to 4 do
11470: LD_ADDR_VAR 0 3
11474: PUSH
11475: DOUBLE
11476: LD_INT 1
11478: DEC
11479: ST_TO_ADDR
11480: LD_INT 4
11482: PUSH
11483: FOR_TO
11484: IFFALSE 11506
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11486: LD_ADDR_EXP 38
11490: PUSH
11491: LD_EXP 38
11495: PPUSH
11496: LD_INT 1
11498: PPUSH
11499: CALL_OW 3
11503: ST_TO_ADDR
11504: GO 11483
11506: POP
11507: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11508: LD_VAR 0 1
11512: PPUSH
11513: CALL_OW 264
11517: PUSH
11518: LD_INT 53
11520: EQUAL
11521: IFFALSE 11550
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11523: LD_VAR 0 1
11527: PPUSH
11528: LD_INT 7
11530: PPUSH
11531: CALL 967 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11535: LD_VAR 0 1
11539: PPUSH
11540: LD_INT 170
11542: PPUSH
11543: LD_INT 235
11545: PPUSH
11546: CALL_OW 171
// end ; end ; end ;
11550: PPOPN 3
11552: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_INT 1
11560: EQUAL
11561: PUSH
11562: LD_VAR 0 2
11566: PUSH
11567: LD_INT 2
11569: EQUAL
11570: AND
11571: PUSH
11572: LD_VAR 0 1
11576: PUSH
11577: LD_INT 2
11579: EQUAL
11580: PUSH
11581: LD_VAR 0 2
11585: PUSH
11586: LD_INT 1
11588: EQUAL
11589: AND
11590: OR
11591: IFFALSE 11601
// player_attacked_ar := true ;
11593: LD_ADDR_EXP 16
11597: PUSH
11598: LD_INT 1
11600: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_INT 1
11608: EQUAL
11609: PUSH
11610: LD_VAR 0 2
11614: PUSH
11615: LD_INT 4
11617: EQUAL
11618: AND
11619: PUSH
11620: LD_VAR 0 1
11624: PUSH
11625: LD_INT 4
11627: EQUAL
11628: PUSH
11629: LD_VAR 0 2
11633: PUSH
11634: LD_INT 1
11636: EQUAL
11637: AND
11638: OR
11639: IFFALSE 11648
// YouLost ( Traitor ) ;
11641: LD_STRING Traitor
11643: PPUSH
11644: CALL_OW 104
// end ;
11648: PPOPN 2
11650: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11651: LD_VAR 0 1
11655: PUSH
11656: LD_EXP 19
11660: EQUAL
11661: IFFALSE 11670
// YouLost ( JMM ) ;
11663: LD_STRING JMM
11665: PPUSH
11666: CALL_OW 104
// if un = terminal then
11670: LD_VAR 0 1
11674: PUSH
11675: LD_EXP 3
11679: EQUAL
11680: IFFALSE 11689
// YouLost ( Terminal ) ;
11682: LD_STRING Terminal
11684: PPUSH
11685: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11689: LD_VAR 0 1
11693: PUSH
11694: LD_INT 22
11696: PUSH
11697: LD_INT 3
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PUSH
11704: LD_INT 21
11706: PUSH
11707: LD_INT 3
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: EMPTY
11715: LIST
11716: LIST
11717: PPUSH
11718: CALL_OW 69
11722: IN
11723: IFFALSE 11869
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11725: LD_VAR 0 1
11729: PPUSH
11730: CALL_OW 266
11734: PUSH
11735: LD_INT 33
11737: PUSH
11738: LD_INT 26
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: IN
11745: IFFALSE 11804
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11747: LD_ADDR_EXP 37
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_VAR 0 1
11761: PPUSH
11762: CALL_OW 266
11766: PUSH
11767: LD_VAR 0 1
11771: PPUSH
11772: CALL_OW 250
11776: PUSH
11777: LD_VAR 0 1
11781: PPUSH
11782: CALL_OW 251
11786: PUSH
11787: LD_VAR 0 1
11791: PPUSH
11792: CALL_OW 254
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: ADD
11803: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11804: LD_VAR 0 1
11808: PPUSH
11809: CALL_OW 266
11813: PUSH
11814: LD_INT 5
11816: EQUAL
11817: IFFALSE 11869
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11819: LD_ADDR_EXP 37
11823: PUSH
11824: LD_EXP 37
11828: PUSH
11829: LD_INT 4
11831: PUSH
11832: LD_VAR 0 1
11836: PPUSH
11837: CALL_OW 250
11841: PUSH
11842: LD_VAR 0 1
11846: PPUSH
11847: CALL_OW 251
11851: PUSH
11852: LD_VAR 0 1
11856: PPUSH
11857: CALL_OW 254
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: ADD
11868: ST_TO_ADDR
// end ; if un in ru_force then
11869: LD_VAR 0 1
11873: PUSH
11874: LD_EXP 36
11878: IN
11879: IFFALSE 11915
// begin ru_force := ru_force diff un ;
11881: LD_ADDR_EXP 36
11885: PUSH
11886: LD_EXP 36
11890: PUSH
11891: LD_VAR 0 1
11895: DIFF
11896: ST_TO_ADDR
// if ru_force = 0 then
11897: LD_EXP 36
11901: PUSH
11902: LD_INT 0
11904: EQUAL
11905: IFFALSE 11915
// ru_can_attack := false ;
11907: LD_ADDR_EXP 8
11911: PUSH
11912: LD_INT 0
11914: ST_TO_ADDR
// end ; end ; end_of_file
11915: PPOPN 1
11917: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11918: LD_EXP 5
11922: PUSH
11923: LD_EXP 6
11927: AND
11928: IFFALSE 12013
11930: GO 11932
11932: DISABLE
11933: LD_INT 0
11935: PPUSH
// begin enable ;
11936: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11937: LD_ADDR_VAR 0 1
11941: PUSH
11942: LD_INT 60
11944: PUSH
11945: CALL 809 0 0
11949: MINUS
11950: ST_TO_ADDR
// if sib < 0 then
11951: LD_VAR 0 1
11955: PUSH
11956: LD_INT 0
11958: LESS
11959: IFFALSE 11969
// sib := 0 ;
11961: LD_ADDR_VAR 0 1
11965: PUSH
11966: LD_INT 0
11968: ST_TO_ADDR
// if not debug then
11969: LD_EXP 2
11973: NOT
11974: IFFALSE 11999
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11976: LD_ADDR_OWVAR 47
11980: PUSH
11981: LD_STRING #Am09-1
11983: PUSH
11984: LD_VAR 0 1
11988: PUSH
11989: LD_EXP 6
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11999: LD_ADDR_EXP 6
12003: PUSH
12004: LD_EXP 6
12008: PUSH
12009: LD_INT 35
12011: MINUS
12012: ST_TO_ADDR
// end ;
12013: PPOPN 1
12015: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12016: LD_EXP 6
12020: PUSH
12021: LD_INT 0
12023: EQUAL
12024: IFFALSE 12036
12026: GO 12028
12028: DISABLE
// display_strings := [ ] ;
12029: LD_ADDR_OWVAR 47
12033: PUSH
12034: EMPTY
12035: ST_TO_ADDR
12036: END
// every 1 1$35 do var i , tmp ;
12037: GO 12039
12039: DISABLE
12040: LD_INT 0
12042: PPUSH
12043: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12044: LD_ADDR_VAR 0 2
12048: PUSH
12049: LD_INT 1155
12051: PUSH
12052: LD_INT 1225
12054: PUSH
12055: LD_INT 1435
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_OWVAR 67
12067: ARRAY
12068: ST_TO_ADDR
// i := 0 ;
12069: LD_ADDR_VAR 0 1
12073: PUSH
12074: LD_INT 0
12076: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12077: LD_INT 1
12079: PPUSH
12080: LD_INT 5
12082: PPUSH
12083: CALL_OW 12
12087: PPUSH
12088: LD_INT 75
12090: PPUSH
12091: LD_INT 75
12093: PPUSH
12094: LD_INT 20
12096: PPUSH
12097: LD_INT 1
12099: PPUSH
12100: CALL_OW 56
// wait ( tmp ) ;
12104: LD_VAR 0 2
12108: PPUSH
12109: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12113: LD_ADDR_VAR 0 2
12117: PUSH
12118: LD_VAR 0 2
12122: PUSH
12123: LD_INT 105
12125: PPUSH
12126: LD_INT 315
12128: PPUSH
12129: CALL_OW 12
12133: PLUS
12134: ST_TO_ADDR
// i := i + 1 ;
12135: LD_ADDR_VAR 0 1
12139: PUSH
12140: LD_VAR 0 1
12144: PUSH
12145: LD_INT 1
12147: PLUS
12148: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12149: LD_VAR 0 1
12153: PUSH
12154: LD_INT 3
12156: MOD
12157: PUSH
12158: LD_INT 0
12160: EQUAL
12161: PUSH
12162: LD_EXP 4
12166: AND
12167: IFFALSE 12205
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12169: LD_INT 2
12171: PPUSH
12172: LD_INT 5
12174: PPUSH
12175: CALL_OW 12
12179: PPUSH
12180: LD_INT 8
12182: PPUSH
12183: LD_INT 1
12185: PPUSH
12186: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12190: LD_INT 665
12192: PPUSH
12193: LD_INT 735
12195: PPUSH
12196: CALL_OW 12
12200: PPUSH
12201: CALL_OW 67
// end ; until tick > game_time ;
12205: LD_OWVAR 1
12209: PUSH
12210: LD_EXP 7
12214: GREATER
12215: IFFALSE 12077
// end ; end_of_file
12217: PPOPN 2
12219: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12220: LD_INT 0
12222: PPUSH
12223: PPUSH
12224: PPUSH
12225: PPUSH
12226: PPUSH
12227: PPUSH
// x := 76 ;
12228: LD_ADDR_VAR 0 5
12232: PUSH
12233: LD_INT 76
12235: ST_TO_ADDR
// y := 147 ;
12236: LD_ADDR_VAR 0 6
12240: PUSH
12241: LD_INT 147
12243: ST_TO_ADDR
// uc_side := 2 ;
12244: LD_ADDR_OWVAR 20
12248: PUSH
12249: LD_INT 2
12251: ST_TO_ADDR
// uc_nation := 2 ;
12252: LD_ADDR_OWVAR 21
12256: PUSH
12257: LD_INT 2
12259: ST_TO_ADDR
// InitHc ;
12260: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12264: LD_INT 1
12266: PPUSH
12267: LD_INT 1
12269: PPUSH
12270: LD_INT 6
12272: PPUSH
12273: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12277: LD_ADDR_OWVAR 26
12281: PUSH
12282: LD_STRING Nicolas Vervecken
12284: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12285: LD_ADDR_OWVAR 33
12289: PUSH
12290: LD_STRING SecondCharsGal
12292: ST_TO_ADDR
// hc_face_number := 3 ;
12293: LD_ADDR_OWVAR 34
12297: PUSH
12298: LD_INT 3
12300: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12301: LD_ADDR_OWVAR 29
12305: PUSH
12306: LD_INT 11
12308: PUSH
12309: LD_INT 10
12311: PUSH
12312: EMPTY
12313: LIST
12314: LIST
12315: ST_TO_ADDR
// Vervecken := CreateHuman ;
12316: LD_ADDR_EXP 27
12320: PUSH
12321: CALL_OW 44
12325: ST_TO_ADDR
// ar_force := Vervecken ;
12326: LD_ADDR_EXP 34
12330: PUSH
12331: LD_EXP 27
12335: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12336: LD_INT 1
12338: PPUSH
12339: LD_INT 2
12341: PPUSH
12342: LD_INT 6
12344: PPUSH
12345: CALL_OW 380
// hc_name := Louis Gali ;
12349: LD_ADDR_OWVAR 26
12353: PUSH
12354: LD_STRING Louis Gali
12356: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12357: LD_ADDR_OWVAR 33
12361: PUSH
12362: LD_STRING SecondCharsGal
12364: ST_TO_ADDR
// hc_face_number := 2 ;
12365: LD_ADDR_OWVAR 34
12369: PUSH
12370: LD_INT 2
12372: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12373: LD_ADDR_OWVAR 29
12377: PUSH
12378: LD_INT 10
12380: PUSH
12381: LD_INT 11
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: ST_TO_ADDR
// Gali := CreateHuman ;
12388: LD_ADDR_EXP 28
12392: PUSH
12393: CALL_OW 44
12397: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12398: LD_ADDR_EXP 34
12402: PUSH
12403: LD_EXP 34
12407: PUSH
12408: LD_EXP 28
12412: ADD
12413: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12414: LD_INT 2
12416: PPUSH
12417: LD_INT 1
12419: PPUSH
12420: LD_INT 6
12422: PPUSH
12423: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12427: LD_ADDR_OWVAR 26
12431: PUSH
12432: LD_STRING Maria Bogdanovic
12434: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12435: LD_ADDR_OWVAR 33
12439: PUSH
12440: LD_STRING SecondCharsGal
12442: ST_TO_ADDR
// hc_face_number := 14 ;
12443: LD_ADDR_OWVAR 34
12447: PUSH
12448: LD_INT 14
12450: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12451: LD_ADDR_OWVAR 29
12455: PUSH
12456: LD_INT 12
12458: PUSH
12459: LD_INT 9
12461: PUSH
12462: EMPTY
12463: LIST
12464: LIST
12465: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12466: LD_ADDR_EXP 29
12470: PUSH
12471: CALL_OW 44
12475: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12476: LD_ADDR_EXP 34
12480: PUSH
12481: LD_EXP 34
12485: PUSH
12486: LD_EXP 29
12490: ADD
12491: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12492: LD_INT 1
12494: PPUSH
12495: LD_INT 3
12497: PPUSH
12498: LD_INT 6
12500: PPUSH
12501: CALL_OW 380
// hc_name = Kntor Radomr ;
12505: LD_ADDR_OWVAR 26
12509: PUSH
12510: LD_STRING Kntor Radomr
12512: ST_TO_ADDR
// hc_gallery = sandar ;
12513: LD_ADDR_OWVAR 33
12517: PUSH
12518: LD_STRING sandar
12520: ST_TO_ADDR
// hc_face_number = 12 ;
12521: LD_ADDR_OWVAR 34
12525: PUSH
12526: LD_INT 12
12528: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12529: LD_ADDR_OWVAR 29
12533: PUSH
12534: LD_INT 9
12536: PUSH
12537: LD_INT 9
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: ST_TO_ADDR
// Kantor = CreateHuman ;
12544: LD_ADDR_EXP 30
12548: PUSH
12549: CALL_OW 44
12553: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12554: LD_ADDR_EXP 34
12558: PUSH
12559: LD_EXP 34
12563: PUSH
12564: LD_EXP 30
12568: ADD
12569: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12570: LD_INT 1
12572: PPUSH
12573: LD_INT 3
12575: PPUSH
12576: LD_INT 6
12578: PPUSH
12579: CALL_OW 380
// hc_name = Herczeg Farkas ;
12583: LD_ADDR_OWVAR 26
12587: PUSH
12588: LD_STRING Herczeg Farkas
12590: ST_TO_ADDR
// hc_gallery = sandar ;
12591: LD_ADDR_OWVAR 33
12595: PUSH
12596: LD_STRING sandar
12598: ST_TO_ADDR
// hc_face_number = 28 ;
12599: LD_ADDR_OWVAR 34
12603: PUSH
12604: LD_INT 28
12606: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12607: LD_ADDR_OWVAR 29
12611: PUSH
12612: LD_INT 10
12614: PUSH
12615: LD_INT 9
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: ST_TO_ADDR
// Herczeg = CreateHuman ;
12622: LD_ADDR_EXP 31
12626: PUSH
12627: CALL_OW 44
12631: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12632: LD_ADDR_EXP 34
12636: PUSH
12637: LD_EXP 34
12641: PUSH
12642: LD_EXP 31
12646: ADD
12647: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12648: LD_INT 1
12650: PPUSH
12651: LD_INT 1
12653: PPUSH
12654: LD_INT 6
12656: PPUSH
12657: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12661: LD_ADDR_OWVAR 26
12665: PUSH
12666: LD_STRING Ronn Horntvedt
12668: ST_TO_ADDR
// hc_gallery = sandar ;
12669: LD_ADDR_OWVAR 33
12673: PUSH
12674: LD_STRING sandar
12676: ST_TO_ADDR
// hc_face_number = 29 ;
12677: LD_ADDR_OWVAR 34
12681: PUSH
12682: LD_INT 29
12684: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12685: LD_ADDR_OWVAR 29
12689: PUSH
12690: LD_INT 11
12692: PUSH
12693: LD_INT 11
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: ST_TO_ADDR
// Ronn = CreateHuman ;
12700: LD_ADDR_EXP 32
12704: PUSH
12705: CALL_OW 44
12709: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12710: LD_ADDR_EXP 34
12714: PUSH
12715: LD_EXP 34
12719: PUSH
12720: LD_EXP 32
12724: ADD
12725: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12726: LD_INT 2
12728: PPUSH
12729: LD_INT 3
12731: PPUSH
12732: LD_INT 6
12734: PPUSH
12735: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12739: LD_ADDR_OWVAR 26
12743: PUSH
12744: LD_STRING Mia D. Mathiasen
12746: ST_TO_ADDR
// hc_gallery = sandar ;
12747: LD_ADDR_OWVAR 33
12751: PUSH
12752: LD_STRING sandar
12754: ST_TO_ADDR
// hc_face_number = 31 ;
12755: LD_ADDR_OWVAR 34
12759: PUSH
12760: LD_INT 31
12762: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12763: LD_ADDR_OWVAR 29
12767: PUSH
12768: LD_INT 10
12770: PUSH
12771: LD_INT 10
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: ST_TO_ADDR
// Mia = CreateHuman ;
12778: LD_ADDR_EXP 33
12782: PUSH
12783: CALL_OW 44
12787: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12788: LD_ADDR_EXP 34
12792: PUSH
12793: LD_EXP 34
12797: PUSH
12798: LD_EXP 33
12802: ADD
12803: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12804: LD_ADDR_VAR 0 3
12808: PUSH
12809: LD_VAR 0 3
12813: PUSH
12814: LD_INT 2
12816: PPUSH
12817: LD_INT 2
12819: PPUSH
12820: LD_INT 14
12822: PPUSH
12823: LD_INT 1
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: LD_INT 32
12831: PPUSH
12832: LD_INT 30
12834: PPUSH
12835: CALL 289 0 7
12839: ADD
12840: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
12841: LD_ADDR_VAR 0 3
12845: PUSH
12846: LD_VAR 0 3
12850: PUSH
12851: LD_INT 2
12853: PPUSH
12854: LD_INT 2
12856: PPUSH
12857: LD_INT 14
12859: PPUSH
12860: LD_INT 1
12862: PPUSH
12863: LD_INT 1
12865: PPUSH
12866: LD_INT 27
12868: PPUSH
12869: LD_INT 30
12871: PPUSH
12872: CALL 289 0 7
12876: ADD
12877: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
12878: LD_ADDR_VAR 0 3
12882: PUSH
12883: LD_VAR 0 3
12887: PUSH
12888: LD_INT 2
12890: PPUSH
12891: LD_INT 2
12893: PPUSH
12894: LD_INT 14
12896: PPUSH
12897: LD_INT 1
12899: PPUSH
12900: LD_INT 1
12902: PPUSH
12903: LD_INT 25
12905: PPUSH
12906: LD_INT 33
12908: PPUSH
12909: CALL 289 0 7
12913: ADD
12914: ST_TO_ADDR
// tmp := tmp diff 0 ;
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_VAR 0 3
12924: PUSH
12925: LD_INT 0
12927: DIFF
12928: ST_TO_ADDR
// for i in ar_force do
12929: LD_ADDR_VAR 0 4
12933: PUSH
12934: LD_EXP 34
12938: PUSH
12939: FOR_IN
12940: IFFALSE 13083
// begin if GetClass ( i ) = 3 then
12942: LD_VAR 0 4
12946: PPUSH
12947: CALL_OW 257
12951: PUSH
12952: LD_INT 3
12954: EQUAL
12955: IFFALSE 13037
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12957: LD_VAR 0 3
12961: PUSH
12962: LD_INT 1
12964: ARRAY
12965: PPUSH
12966: LD_INT 1
12968: PPUSH
12969: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12973: LD_VAR 0 3
12977: PUSH
12978: LD_INT 1
12980: ARRAY
12981: PPUSH
12982: LD_VAR 0 5
12986: PPUSH
12987: LD_VAR 0 6
12991: PPUSH
12992: LD_INT 0
12994: PPUSH
12995: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12999: LD_VAR 0 4
13003: PPUSH
13004: LD_VAR 0 3
13008: PUSH
13009: LD_INT 1
13011: ARRAY
13012: PPUSH
13013: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13017: LD_ADDR_VAR 0 3
13021: PUSH
13022: LD_VAR 0 3
13026: PPUSH
13027: LD_INT 1
13029: PPUSH
13030: CALL_OW 3
13034: ST_TO_ADDR
// end else
13035: GO 13059
// PlaceUnitXY ( i , x , y , false ) ;
13037: LD_VAR 0 4
13041: PPUSH
13042: LD_VAR 0 5
13046: PPUSH
13047: LD_VAR 0 6
13051: PPUSH
13052: LD_INT 0
13054: PPUSH
13055: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13059: LD_VAR 0 4
13063: PPUSH
13064: LD_INT 86
13066: PPUSH
13067: LD_INT 121
13069: PPUSH
13070: CALL_OW 111
// wait ( 0 0$2 ) ;
13074: LD_INT 70
13076: PPUSH
13077: CALL_OW 67
// end ;
13081: GO 12939
13083: POP
13084: POP
// ar_force := ar_force ^ tmp ;
13085: LD_ADDR_EXP 34
13089: PUSH
13090: LD_EXP 34
13094: PUSH
13095: LD_VAR 0 3
13099: ADD
13100: ST_TO_ADDR
// ar_spawned := true ;
13101: LD_ADDR_EXP 11
13105: PUSH
13106: LD_INT 1
13108: ST_TO_ADDR
// end ; end_of_file
13109: LD_VAR 0 1
13113: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13114: LD_INT 0
13116: PPUSH
13117: PPUSH
13118: PPUSH
13119: PPUSH
13120: PPUSH
13121: PPUSH
13122: PPUSH
// InitHc ;
13123: CALL_OW 19
// uc_side := 3 ;
13127: LD_ADDR_OWVAR 20
13131: PUSH
13132: LD_INT 3
13134: ST_TO_ADDR
// uc_nation := 3 ;
13135: LD_ADDR_OWVAR 21
13139: PUSH
13140: LD_INT 3
13142: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13143: LD_ADDR_VAR 0 5
13147: PUSH
13148: LD_INT 5
13150: PUSH
13151: LD_INT 6
13153: PUSH
13154: LD_INT 7
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: LIST
13161: PUSH
13162: LD_OWVAR 67
13166: ARRAY
13167: ST_TO_ADDR
// ru_force := [ ] ;
13168: LD_ADDR_EXP 36
13172: PUSH
13173: EMPTY
13174: ST_TO_ADDR
// ru_rebuild := [ ] ;
13175: LD_ADDR_EXP 37
13179: PUSH
13180: EMPTY
13181: ST_TO_ADDR
// ru_produce_list := [ ] ;
13182: LD_ADDR_EXP 38
13186: PUSH
13187: EMPTY
13188: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13189: LD_ADDR_VAR 0 6
13193: PUSH
13194: LD_INT 22
13196: PUSH
13197: LD_INT 3
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: PUSH
13204: LD_INT 30
13206: PUSH
13207: LD_INT 8
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PPUSH
13218: CALL_OW 69
13222: PUSH
13223: LD_INT 1
13225: ARRAY
13226: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13227: LD_ADDR_VAR 0 4
13231: PUSH
13232: LD_INT 43
13234: PUSH
13235: LD_INT 46
13237: PUSH
13238: LD_INT 45
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: LIST
13245: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13246: LD_ADDR_VAR 0 7
13250: PUSH
13251: LD_INT 22
13253: PUSH
13254: LD_INT 3
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: PUSH
13261: LD_INT 30
13263: PUSH
13264: LD_INT 1
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: PPUSH
13275: CALL_OW 69
13279: PUSH
13280: LD_INT 1
13282: ARRAY
13283: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13284: LD_VAR 0 7
13288: PPUSH
13289: CALL_OW 274
13293: PPUSH
13294: LD_INT 1
13296: PPUSH
13297: LD_INT 5000
13299: PPUSH
13300: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13304: LD_VAR 0 7
13308: PPUSH
13309: CALL_OW 274
13313: PPUSH
13314: LD_INT 2
13316: PPUSH
13317: LD_INT 1000
13319: PPUSH
13320: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13324: LD_VAR 0 7
13328: PPUSH
13329: CALL_OW 274
13333: PPUSH
13334: LD_INT 3
13336: PPUSH
13337: LD_INT 30
13339: PPUSH
13340: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13344: LD_ADDR_VAR 0 2
13348: PUSH
13349: LD_INT 22
13351: PUSH
13352: LD_INT 3
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: PUSH
13359: LD_INT 30
13361: PUSH
13362: LD_INT 33
13364: PUSH
13365: EMPTY
13366: LIST
13367: LIST
13368: PUSH
13369: EMPTY
13370: LIST
13371: LIST
13372: PPUSH
13373: CALL_OW 69
13377: PUSH
13378: FOR_IN
13379: IFFALSE 13411
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13381: LD_VAR 0 2
13385: PPUSH
13386: LD_VAR 0 4
13390: PUSH
13391: LD_VAR 0 2
13395: PUSH
13396: LD_INT 3
13398: MOD
13399: PUSH
13400: LD_INT 1
13402: PLUS
13403: ARRAY
13404: PPUSH
13405: CALL_OW 431
// end ;
13409: GO 13378
13411: POP
13412: POP
// for i = 1 to 4 do
13413: LD_ADDR_VAR 0 2
13417: PUSH
13418: DOUBLE
13419: LD_INT 1
13421: DEC
13422: ST_TO_ADDR
13423: LD_INT 4
13425: PUSH
13426: FOR_TO
13427: IFFALSE 13488
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13429: LD_INT 0
13431: PPUSH
13432: LD_INT 9
13434: PPUSH
13435: LD_VAR 0 5
13439: PPUSH
13440: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13444: CALL_OW 44
13448: PPUSH
13449: LD_INT 22
13451: PUSH
13452: LD_INT 3
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PUSH
13459: LD_INT 30
13461: PUSH
13462: LD_INT 5
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: PPUSH
13473: CALL_OW 69
13477: PUSH
13478: LD_INT 1
13480: ARRAY
13481: PPUSH
13482: CALL_OW 52
// end ;
13486: GO 13426
13488: POP
13489: POP
// for i = 1 to 5 do
13490: LD_ADDR_VAR 0 2
13494: PUSH
13495: DOUBLE
13496: LD_INT 1
13498: DEC
13499: ST_TO_ADDR
13500: LD_INT 5
13502: PUSH
13503: FOR_TO
13504: IFFALSE 13565
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13506: LD_INT 0
13508: PPUSH
13509: LD_INT 3
13511: PPUSH
13512: LD_VAR 0 5
13516: PPUSH
13517: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13521: CALL_OW 44
13525: PPUSH
13526: LD_INT 22
13528: PUSH
13529: LD_INT 3
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 30
13538: PUSH
13539: LD_INT 3
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PPUSH
13550: CALL_OW 69
13554: PUSH
13555: LD_INT 1
13557: ARRAY
13558: PPUSH
13559: CALL_OW 52
// end ;
13563: GO 13503
13565: POP
13566: POP
// for i = 1 to 4 do
13567: LD_ADDR_VAR 0 2
13571: PUSH
13572: DOUBLE
13573: LD_INT 1
13575: DEC
13576: ST_TO_ADDR
13577: LD_INT 4
13579: PUSH
13580: FOR_TO
13581: IFFALSE 13642
// begin PrepareHuman ( false , class_engineer , skill ) ;
13583: LD_INT 0
13585: PPUSH
13586: LD_INT 2
13588: PPUSH
13589: LD_VAR 0 5
13593: PPUSH
13594: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13598: CALL_OW 44
13602: PPUSH
13603: LD_INT 22
13605: PUSH
13606: LD_INT 3
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PUSH
13613: LD_INT 30
13615: PUSH
13616: LD_INT 1
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PPUSH
13627: CALL_OW 69
13631: PUSH
13632: LD_INT 1
13634: ARRAY
13635: PPUSH
13636: CALL_OW 52
// end ;
13640: GO 13580
13642: POP
13643: POP
// for i = 1 to 3 do
13644: LD_ADDR_VAR 0 2
13648: PUSH
13649: DOUBLE
13650: LD_INT 1
13652: DEC
13653: ST_TO_ADDR
13654: LD_INT 3
13656: PUSH
13657: FOR_TO
13658: IFFALSE 13691
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13660: LD_INT 0
13662: PPUSH
13663: LD_INT 4
13665: PPUSH
13666: LD_VAR 0 5
13670: PPUSH
13671: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13675: CALL_OW 44
13679: PPUSH
13680: LD_VAR 0 6
13684: PPUSH
13685: CALL_OW 52
// end ;
13689: GO 13657
13691: POP
13692: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13693: LD_ADDR_EXP 35
13697: PUSH
13698: LD_STRING Yakotich
13700: PPUSH
13701: LD_EXP 2
13705: NOT
13706: PPUSH
13707: LD_STRING 
13709: PPUSH
13710: CALL 226 0 3
13714: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13715: LD_EXP 35
13719: PPUSH
13720: LD_INT 74
13722: PPUSH
13723: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13727: LD_VAR 0 6
13731: PPUSH
13732: LD_INT 49
13734: PPUSH
13735: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13739: LD_VAR 0 6
13743: PPUSH
13744: LD_INT 50
13746: PPUSH
13747: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13751: LD_VAR 0 6
13755: PPUSH
13756: LD_INT 51
13758: PPUSH
13759: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13763: LD_VAR 0 6
13767: PPUSH
13768: LD_INT 52
13770: PPUSH
13771: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13775: LD_VAR 0 6
13779: PPUSH
13780: LD_INT 69
13782: PPUSH
13783: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13787: LD_VAR 0 6
13791: PPUSH
13792: LD_INT 39
13794: PPUSH
13795: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13799: LD_VAR 0 6
13803: PPUSH
13804: LD_INT 34
13806: PPUSH
13807: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13811: LD_VAR 0 6
13815: PPUSH
13816: LD_INT 40
13818: PPUSH
13819: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13823: LD_VAR 0 6
13827: PPUSH
13828: LD_INT 57
13830: PPUSH
13831: CALL_OW 184
// if Difficulty > 1 then
13835: LD_OWVAR 67
13839: PUSH
13840: LD_INT 1
13842: GREATER
13843: IFFALSE 13857
// AddComResearch ( lab , tech_comp2 ) ;
13845: LD_VAR 0 6
13849: PPUSH
13850: LD_INT 58
13852: PPUSH
13853: CALL_OW 184
// end ;
13857: LD_VAR 0 1
13861: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13862: LD_INT 7
13864: PPUSH
13865: CALL_OW 353
13869: PUSH
13870: LD_INT 3
13872: GREATER
13873: PUSH
13874: LD_INT 22
13876: PUSH
13877: LD_INT 3
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 34
13886: PUSH
13887: LD_INT 53
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: EMPTY
13895: LIST
13896: LIST
13897: PPUSH
13898: CALL_OW 69
13902: NOT
13903: AND
13904: IFFALSE 13939
13906: GO 13908
13908: DISABLE
// begin enable ;
13909: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13910: LD_ADDR_EXP 38
13914: PUSH
13915: LD_EXP 38
13919: PUSH
13920: LD_INT 24
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: LD_INT 3
13928: PUSH
13929: LD_INT 53
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: ADD
13938: ST_TO_ADDR
// end ;
13939: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13940: LD_INT 22
13942: PUSH
13943: LD_INT 3
13945: PUSH
13946: EMPTY
13947: LIST
13948: LIST
13949: PUSH
13950: LD_INT 21
13952: PUSH
13953: LD_INT 3
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PPUSH
13964: CALL_OW 69
13968: IFFALSE 14746
13970: GO 13972
13972: DISABLE
13973: LD_INT 0
13975: PPUSH
13976: PPUSH
13977: PPUSH
13978: PPUSH
13979: PPUSH
13980: PPUSH
13981: PPUSH
13982: PPUSH
// begin enable ;
13983: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13984: LD_ADDR_VAR 0 3
13988: PUSH
13989: LD_INT 22
13991: PUSH
13992: LD_INT 3
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 21
14001: PUSH
14002: LD_INT 3
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: LD_INT 3
14011: PUSH
14012: LD_INT 24
14014: PUSH
14015: LD_INT 1000
14017: PUSH
14018: EMPTY
14019: LIST
14020: LIST
14021: PUSH
14022: EMPTY
14023: LIST
14024: LIST
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: PPUSH
14031: CALL_OW 69
14035: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14036: LD_ADDR_VAR 0 4
14040: PUSH
14041: LD_INT 22
14043: PUSH
14044: LD_INT 3
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: LD_INT 25
14053: PUSH
14054: LD_INT 2
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: PPUSH
14065: CALL_OW 69
14069: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14070: LD_ADDR_VAR 0 5
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 30
14087: PUSH
14088: LD_INT 1
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: PUSH
14104: LD_INT 1
14106: ARRAY
14107: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14108: LD_ADDR_VAR 0 8
14112: PUSH
14113: LD_INT 22
14115: PUSH
14116: LD_INT 3
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: PUSH
14123: LD_INT 2
14125: PUSH
14126: LD_INT 30
14128: PUSH
14129: LD_INT 6
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 30
14138: PUSH
14139: LD_INT 7
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: LD_INT 30
14148: PUSH
14149: LD_INT 8
14151: PUSH
14152: EMPTY
14153: LIST
14154: LIST
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: PPUSH
14166: CALL_OW 69
14170: PUSH
14171: LD_INT 1
14173: ARRAY
14174: ST_TO_ADDR
// if not engs then
14175: LD_VAR 0 4
14179: NOT
14180: IFFALSE 14184
// exit ;
14182: GO 14746
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 4
14193: PPUSH
14194: LD_INT 3
14196: PUSH
14197: LD_INT 24
14199: PUSH
14200: LD_INT 600
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: PPUSH
14211: CALL_OW 72
14215: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14216: LD_ADDR_VAR 0 7
14220: PUSH
14221: LD_INT 22
14223: PUSH
14224: LD_INT 3
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: PUSH
14231: LD_INT 25
14233: PUSH
14234: LD_INT 4
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PPUSH
14245: CALL_OW 69
14249: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14250: LD_VAR 0 3
14254: NOT
14255: PUSH
14256: LD_EXP 37
14260: NOT
14261: AND
14262: IFFALSE 14322
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14264: LD_VAR 0 4
14268: PPUSH
14269: LD_INT 3
14271: PUSH
14272: LD_INT 54
14274: PUSH
14275: EMPTY
14276: LIST
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PPUSH
14282: CALL_OW 72
14286: IFFALSE 14320
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14288: LD_VAR 0 4
14292: PPUSH
14293: LD_INT 3
14295: PUSH
14296: LD_INT 54
14298: PUSH
14299: EMPTY
14300: LIST
14301: PUSH
14302: EMPTY
14303: LIST
14304: LIST
14305: PPUSH
14306: CALL_OW 72
14310: PPUSH
14311: LD_VAR 0 5
14315: PPUSH
14316: CALL_OW 120
// exit ;
14320: GO 14746
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14322: LD_VAR 0 4
14326: PPUSH
14327: LD_INT 54
14329: PUSH
14330: EMPTY
14331: LIST
14332: PPUSH
14333: CALL_OW 72
14337: IFFALSE 14359
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14339: LD_VAR 0 4
14343: PPUSH
14344: LD_INT 54
14346: PUSH
14347: EMPTY
14348: LIST
14349: PPUSH
14350: CALL_OW 72
14354: PPUSH
14355: CALL_OW 122
// if not tmp then
14359: LD_VAR 0 3
14363: NOT
14364: IFFALSE 14496
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14366: LD_INT 81
14368: PUSH
14369: LD_INT 3
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PUSH
14376: LD_INT 92
14378: PUSH
14379: LD_INT 147
14381: PUSH
14382: LD_INT 212
14384: PUSH
14385: LD_INT 30
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: PPUSH
14398: CALL_OW 69
14402: NOT
14403: IFFALSE 14496
// begin if not HasTask ( engs [ 1 ] ) then
14405: LD_VAR 0 4
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: PPUSH
14414: CALL_OW 314
14418: NOT
14419: IFFALSE 14496
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14421: LD_ADDR_VAR 0 2
14425: PUSH
14426: LD_VAR 0 4
14430: PPUSH
14431: LD_EXP 37
14435: PUSH
14436: LD_INT 1
14438: ARRAY
14439: PPUSH
14440: LD_EXP 37
14444: PUSH
14445: LD_INT 2
14447: ARRAY
14448: PPUSH
14449: LD_EXP 37
14453: PUSH
14454: LD_INT 3
14456: ARRAY
14457: PPUSH
14458: LD_EXP 37
14462: PUSH
14463: LD_INT 4
14465: ARRAY
14466: PPUSH
14467: CALL_OW 145
14471: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14472: LD_VAR 0 2
14476: PPUSH
14477: CALL_OW 266
14481: PUSH
14482: LD_INT 4
14484: EQUAL
14485: IFFALSE 14496
// AddComUpgrade ( i ) ;
14487: LD_VAR 0 2
14491: PPUSH
14492: CALL_OW 206
// end ; end ; end ; for i in engs do
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_VAR 0 4
14505: PUSH
14506: FOR_IN
14507: IFFALSE 14625
// begin if i in to_heal and sci then
14509: LD_VAR 0 2
14513: PUSH
14514: LD_VAR 0 6
14518: IN
14519: PUSH
14520: LD_VAR 0 7
14524: AND
14525: IFFALSE 14576
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14527: LD_VAR 0 2
14531: PPUSH
14532: LD_INT 149
14534: PPUSH
14535: LD_INT 220
14537: PPUSH
14538: CALL_OW 297
14542: PUSH
14543: LD_INT 5
14545: LESS
14546: IFFALSE 14550
// continue ;
14548: GO 14506
// ComMoveXY ( i , 149 , 220 ) ;
14550: LD_VAR 0 2
14554: PPUSH
14555: LD_INT 149
14557: PPUSH
14558: LD_INT 220
14560: PPUSH
14561: CALL_OW 111
// AddComHold ( i ) ;
14565: LD_VAR 0 2
14569: PPUSH
14570: CALL_OW 200
// end else
14574: GO 14623
// if not HasTask ( i ) or WantsToAttack ( i ) then
14576: LD_VAR 0 2
14580: PPUSH
14581: CALL_OW 314
14585: NOT
14586: PUSH
14587: LD_VAR 0 2
14591: PPUSH
14592: CALL_OW 319
14596: OR
14597: IFFALSE 14623
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14599: LD_VAR 0 2
14603: PPUSH
14604: LD_VAR 0 3
14608: PPUSH
14609: LD_VAR 0 2
14613: PPUSH
14614: CALL_OW 74
14618: PPUSH
14619: CALL_OW 130
// end ;
14623: GO 14506
14625: POP
14626: POP
// if to_heal and sci then
14627: LD_VAR 0 6
14631: PUSH
14632: LD_VAR 0 7
14636: AND
14637: IFFALSE 14698
// begin if UnitFilter ( sci , [ f_inside ] ) then
14639: LD_VAR 0 7
14643: PPUSH
14644: LD_INT 54
14646: PUSH
14647: EMPTY
14648: LIST
14649: PPUSH
14650: CALL_OW 72
14654: IFFALSE 14678
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14656: LD_VAR 0 7
14660: PPUSH
14661: LD_INT 54
14663: PUSH
14664: EMPTY
14665: LIST
14666: PPUSH
14667: CALL_OW 72
14671: PPUSH
14672: CALL_OW 122
14676: GO 14696
// ComHeal ( sci , to_heal [ 1 ] ) ;
14678: LD_VAR 0 7
14682: PPUSH
14683: LD_VAR 0 6
14687: PUSH
14688: LD_INT 1
14690: ARRAY
14691: PPUSH
14692: CALL_OW 128
// end else
14696: GO 14746
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14698: LD_VAR 0 7
14702: PPUSH
14703: LD_INT 56
14705: PUSH
14706: EMPTY
14707: LIST
14708: PPUSH
14709: CALL_OW 72
14713: PUSH
14714: LD_VAR 0 8
14718: AND
14719: IFFALSE 14746
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14721: LD_VAR 0 7
14725: PPUSH
14726: LD_INT 56
14728: PUSH
14729: EMPTY
14730: LIST
14731: PPUSH
14732: CALL_OW 72
14736: PPUSH
14737: LD_VAR 0 8
14741: PPUSH
14742: CALL_OW 120
// end ;
14746: PPOPN 8
14748: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14749: LD_INT 22
14751: PUSH
14752: LD_INT 3
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 30
14761: PUSH
14762: LD_INT 3
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: PPUSH
14773: CALL_OW 69
14777: PUSH
14778: LD_EXP 38
14782: AND
14783: IFFALSE 14909
14785: GO 14787
14787: DISABLE
14788: LD_INT 0
14790: PPUSH
14791: PPUSH
14792: PPUSH
// begin enable ;
14793: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14794: LD_ADDR_VAR 0 3
14798: PUSH
14799: LD_INT 22
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: LD_INT 30
14811: PUSH
14812: LD_INT 3
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PPUSH
14823: CALL_OW 69
14827: PUSH
14828: LD_INT 1
14830: ARRAY
14831: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14832: LD_VAR 0 3
14836: PPUSH
14837: CALL_OW 313
14841: PUSH
14842: LD_INT 0
14844: EQUAL
14845: IFFALSE 14849
// exit ;
14847: GO 14909
// if BuildingStatus ( fac ) = bs_idle then
14849: LD_VAR 0 3
14853: PPUSH
14854: CALL_OW 461
14858: PUSH
14859: LD_INT 2
14861: EQUAL
14862: IFFALSE 14909
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14864: LD_VAR 0 3
14868: PPUSH
14869: LD_EXP 38
14873: PUSH
14874: LD_INT 1
14876: ARRAY
14877: PPUSH
14878: LD_EXP 38
14882: PUSH
14883: LD_INT 2
14885: ARRAY
14886: PPUSH
14887: LD_EXP 38
14891: PUSH
14892: LD_INT 3
14894: ARRAY
14895: PPUSH
14896: LD_EXP 38
14900: PUSH
14901: LD_INT 4
14903: ARRAY
14904: PPUSH
14905: CALL_OW 125
// end ;
14909: PPOPN 3
14911: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14912: LD_INT 0
14914: PPUSH
14915: PPUSH
14916: PPUSH
14917: PPUSH
14918: PPUSH
// uc_side := 3 ;
14919: LD_ADDR_OWVAR 20
14923: PUSH
14924: LD_INT 3
14926: ST_TO_ADDR
// uc_nation := 3 ;
14927: LD_ADDR_OWVAR 21
14931: PUSH
14932: LD_INT 3
14934: ST_TO_ADDR
// ru_can_attack := false ;
14935: LD_ADDR_EXP 8
14939: PUSH
14940: LD_INT 0
14942: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14943: LD_ADDR_VAR 0 6
14947: PUSH
14948: LD_INT 22
14950: PUSH
14951: LD_INT 3
14953: PUSH
14954: EMPTY
14955: LIST
14956: LIST
14957: PUSH
14958: LD_INT 30
14960: PUSH
14961: LD_INT 3
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: PPUSH
14972: CALL_OW 69
14976: ST_TO_ADDR
// if fac then
14977: LD_VAR 0 6
14981: IFFALSE 15133
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14983: LD_ADDR_EXP 38
14987: PUSH
14988: LD_INT 24
14990: PUSH
14991: LD_INT 1
14993: PUSH
14994: LD_INT 3
14996: PUSH
14997: LD_INT 43
14999: PUSH
15000: EMPTY
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: ST_TO_ADDR
// if wave > 1 then
15006: LD_VAR 0 1
15010: PUSH
15011: LD_INT 1
15013: GREATER
15014: IFFALSE 15067
// for i = 1 to Difficulty do
15016: LD_ADDR_VAR 0 3
15020: PUSH
15021: DOUBLE
15022: LD_INT 1
15024: DEC
15025: ST_TO_ADDR
15026: LD_OWVAR 67
15030: PUSH
15031: FOR_TO
15032: IFFALSE 15065
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15034: LD_ADDR_EXP 38
15038: PUSH
15039: LD_EXP 38
15043: PUSH
15044: LD_INT 24
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: LD_INT 3
15052: PUSH
15053: LD_INT 45
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: LIST
15060: LIST
15061: ADD
15062: ST_TO_ADDR
15063: GO 15031
15065: POP
15066: POP
// repeat wait ( 0 0$1 ) ;
15067: LD_INT 35
15069: PPUSH
15070: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15074: LD_EXP 38
15078: PUSH
15079: LD_INT 4
15081: LESS
15082: PUSH
15083: LD_VAR 0 6
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: PPUSH
15092: CALL_OW 313
15096: PUSH
15097: LD_INT 0
15099: EQUAL
15100: OR
15101: PUSH
15102: LD_VAR 0 6
15106: PUSH
15107: LD_INT 1
15109: ARRAY
15110: PPUSH
15111: CALL_OW 461
15115: PUSH
15116: LD_INT 8
15118: PUSH
15119: LD_INT 6
15121: PUSH
15122: LD_INT 7
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: LIST
15129: IN
15130: OR
15131: IFFALSE 15067
// end ; case wave of 1 :
15133: LD_VAR 0 1
15137: PUSH
15138: LD_INT 1
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15231
15146: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: DOUBLE
15153: LD_INT 1
15155: DEC
15156: ST_TO_ADDR
15157: LD_INT 3
15159: PUSH
15160: LD_INT 4
15162: PUSH
15163: LD_INT 5
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: LIST
15170: PUSH
15171: LD_OWVAR 67
15175: ARRAY
15176: PUSH
15177: FOR_TO
15178: IFFALSE 15186
// Sold ;
15180: CALL 15457 0 0
15184: GO 15177
15186: POP
15187: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15188: LD_ADDR_VAR 0 3
15192: PUSH
15193: DOUBLE
15194: LD_INT 1
15196: DEC
15197: ST_TO_ADDR
15198: LD_INT 2
15200: PUSH
15201: LD_INT 3
15203: PUSH
15204: LD_INT 3
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: LIST
15211: PUSH
15212: LD_OWVAR 67
15216: ARRAY
15217: PUSH
15218: FOR_TO
15219: IFFALSE 15227
// Tank ;
15221: CALL 15587 0 0
15225: GO 15218
15227: POP
15228: POP
// end ; 2 .. 9 :
15229: GO 15444
15231: LD_INT 2
15233: DOUBLE
15234: GREATEREQUAL
15235: IFFALSE 15243
15237: LD_INT 9
15239: DOUBLE
15240: LESSEQUAL
15241: IFTRUE 15245
15243: GO 15350
15245: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15246: LD_ADDR_VAR 0 3
15250: PUSH
15251: DOUBLE
15252: LD_INT 1
15254: DEC
15255: ST_TO_ADDR
15256: LD_INT 3
15258: PUSH
15259: LD_INT 4
15261: PUSH
15262: LD_INT 5
15264: PUSH
15265: EMPTY
15266: LIST
15267: LIST
15268: LIST
15269: PUSH
15270: LD_OWVAR 67
15274: ARRAY
15275: PUSH
15276: LD_VAR 0 1
15280: PUSH
15281: LD_INT 2
15283: DIV
15284: PLUS
15285: PUSH
15286: FOR_TO
15287: IFFALSE 15295
// Sold ;
15289: CALL 15457 0 0
15293: GO 15286
15295: POP
15296: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15297: LD_ADDR_VAR 0 3
15301: PUSH
15302: DOUBLE
15303: LD_INT 1
15305: DEC
15306: ST_TO_ADDR
15307: LD_INT 2
15309: PUSH
15310: LD_INT 3
15312: PUSH
15313: LD_INT 3
15315: PUSH
15316: EMPTY
15317: LIST
15318: LIST
15319: LIST
15320: PUSH
15321: LD_OWVAR 67
15325: ARRAY
15326: PUSH
15327: LD_VAR 0 1
15331: PUSH
15332: LD_INT 2
15334: DIV
15335: PLUS
15336: PUSH
15337: FOR_TO
15338: IFFALSE 15346
// Tank ;
15340: CALL 15587 0 0
15344: GO 15337
15346: POP
15347: POP
// end ; 10 :
15348: GO 15444
15350: LD_INT 10
15352: DOUBLE
15353: EQUAL
15354: IFTRUE 15358
15356: GO 15443
15358: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15359: LD_ADDR_VAR 0 3
15363: PUSH
15364: DOUBLE
15365: LD_INT 1
15367: DEC
15368: ST_TO_ADDR
15369: LD_INT 10
15371: PUSH
15372: LD_INT 12
15374: PUSH
15375: LD_INT 14
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: LIST
15382: PUSH
15383: LD_OWVAR 67
15387: ARRAY
15388: PUSH
15389: FOR_TO
15390: IFFALSE 15398
// Sold ;
15392: CALL 15457 0 0
15396: GO 15389
15398: POP
15399: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15400: LD_ADDR_VAR 0 3
15404: PUSH
15405: DOUBLE
15406: LD_INT 1
15408: DEC
15409: ST_TO_ADDR
15410: LD_INT 11
15412: PUSH
15413: LD_INT 13
15415: PUSH
15416: LD_INT 15
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: LIST
15423: PUSH
15424: LD_OWVAR 67
15428: ARRAY
15429: PUSH
15430: FOR_TO
15431: IFFALSE 15439
// Tank ;
15433: CALL 15587 0 0
15437: GO 15430
15439: POP
15440: POP
// end ; end ;
15441: GO 15444
15443: POP
// ru_can_attack := true ;
15444: LD_ADDR_EXP 8
15448: PUSH
15449: LD_INT 1
15451: ST_TO_ADDR
// end ;
15452: LD_VAR 0 2
15456: RET
// function Sold ( ) ; var un , skill ; begin
15457: LD_INT 0
15459: PPUSH
15460: PPUSH
15461: PPUSH
// uc_side := 3 ;
15462: LD_ADDR_OWVAR 20
15466: PUSH
15467: LD_INT 3
15469: ST_TO_ADDR
// uc_nation := 3 ;
15470: LD_ADDR_OWVAR 21
15474: PUSH
15475: LD_INT 3
15477: ST_TO_ADDR
// InitHc ;
15478: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15482: LD_ADDR_VAR 0 3
15486: PUSH
15487: LD_INT 6
15489: PUSH
15490: LD_INT 7
15492: PUSH
15493: LD_INT 7
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: LIST
15500: PUSH
15501: LD_OWVAR 67
15505: ARRAY
15506: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15507: LD_INT 0
15509: PPUSH
15510: LD_INT 1
15512: PUSH
15513: LD_INT 9
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 1
15522: PPUSH
15523: LD_INT 2
15525: PPUSH
15526: CALL_OW 12
15530: ARRAY
15531: PPUSH
15532: LD_VAR 0 3
15536: PPUSH
15537: CALL_OW 380
// un := CreateHuman ;
15541: LD_ADDR_VAR 0 2
15545: PUSH
15546: CALL_OW 44
15550: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15551: LD_VAR 0 2
15555: PPUSH
15556: LD_INT 4
15558: PPUSH
15559: LD_INT 0
15561: PPUSH
15562: CALL_OW 49
// ru_force := ru_force ^ un ;
15566: LD_ADDR_EXP 36
15570: PUSH
15571: LD_EXP 36
15575: PUSH
15576: LD_VAR 0 2
15580: ADD
15581: ST_TO_ADDR
// end ;
15582: LD_VAR 0 1
15586: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15587: LD_INT 0
15589: PPUSH
15590: PPUSH
15591: PPUSH
15592: PPUSH
15593: PPUSH
// uc_side := 3 ;
15594: LD_ADDR_OWVAR 20
15598: PUSH
15599: LD_INT 3
15601: ST_TO_ADDR
// uc_nation := 3 ;
15602: LD_ADDR_OWVAR 21
15606: PUSH
15607: LD_INT 3
15609: ST_TO_ADDR
// InitHc ;
15610: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15614: LD_ADDR_VAR 0 5
15618: PUSH
15619: LD_INT 5
15621: PUSH
15622: LD_INT 6
15624: PUSH
15625: LD_INT 7
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: LIST
15632: PUSH
15633: LD_OWVAR 67
15637: ARRAY
15638: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15639: LD_ADDR_VAR 0 3
15643: PUSH
15644: LD_INT 22
15646: PUSH
15647: LD_INT 24
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: LD_INT 1
15656: PPUSH
15657: LD_INT 2
15659: PPUSH
15660: CALL_OW 12
15664: ARRAY
15665: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15666: LD_VAR 0 3
15670: PUSH
15671: LD_INT 22
15673: EQUAL
15674: IFFALSE 15709
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15676: LD_ADDR_VAR 0 4
15680: PUSH
15681: LD_INT 45
15683: PUSH
15684: LD_INT 43
15686: PUSH
15687: LD_INT 44
15689: PUSH
15690: EMPTY
15691: LIST
15692: LIST
15693: LIST
15694: PUSH
15695: LD_INT 1
15697: PPUSH
15698: LD_INT 3
15700: PPUSH
15701: CALL_OW 12
15705: ARRAY
15706: ST_TO_ADDR
15707: GO 15740
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15709: LD_ADDR_VAR 0 4
15713: PUSH
15714: LD_INT 46
15716: PUSH
15717: LD_INT 44
15719: PUSH
15720: LD_INT 45
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: LIST
15727: PUSH
15728: LD_INT 1
15730: PPUSH
15731: LD_INT 3
15733: PPUSH
15734: CALL_OW 12
15738: ARRAY
15739: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15740: LD_ADDR_VAR 0 2
15744: PUSH
15745: LD_INT 3
15747: PPUSH
15748: LD_INT 3
15750: PPUSH
15751: LD_VAR 0 3
15755: PPUSH
15756: LD_INT 1
15758: PPUSH
15759: LD_INT 3
15761: PUSH
15762: LD_INT 3
15764: PUSH
15765: LD_INT 3
15767: PUSH
15768: LD_INT 1
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: PUSH
15777: LD_INT 1
15779: PPUSH
15780: LD_INT 4
15782: PPUSH
15783: CALL_OW 12
15787: ARRAY
15788: PPUSH
15789: LD_VAR 0 4
15793: PPUSH
15794: LD_INT 99
15796: PPUSH
15797: CALL 289 0 7
15801: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15802: LD_VAR 0 2
15806: PPUSH
15807: CALL_OW 263
15811: PUSH
15812: LD_INT 1
15814: EQUAL
15815: IFFALSE 15846
// begin PrepareHuman ( false , 3 , skill ) ;
15817: LD_INT 0
15819: PPUSH
15820: LD_INT 3
15822: PPUSH
15823: LD_VAR 0 5
15827: PPUSH
15828: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15832: CALL_OW 44
15836: PPUSH
15837: LD_VAR 0 2
15841: PPUSH
15842: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15846: LD_VAR 0 2
15850: PPUSH
15851: LD_INT 3
15853: PPUSH
15854: LD_INT 0
15856: PPUSH
15857: CALL_OW 49
// ru_force := ru_force ^ un ;
15861: LD_ADDR_EXP 36
15865: PUSH
15866: LD_EXP 36
15870: PUSH
15871: LD_VAR 0 2
15875: ADD
15876: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15877: LD_VAR 0 2
15881: PPUSH
15882: LD_INT 126
15884: PPUSH
15885: LD_INT 158
15887: PPUSH
15888: CALL_OW 111
// Wait ( 0 0$3 ) ;
15892: LD_INT 105
15894: PPUSH
15895: CALL_OW 67
// ComStop ( un ) ;
15899: LD_VAR 0 2
15903: PPUSH
15904: CALL_OW 141
// end ;
15908: LD_VAR 0 1
15912: RET
// every 0 0$1 do var i , time , wave ;
15913: GO 15915
15915: DISABLE
15916: LD_INT 0
15918: PPUSH
15919: PPUSH
15920: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15921: LD_ADDR_VAR 0 2
15925: PUSH
15926: LD_INT 25200
15928: PUSH
15929: LD_INT 24150
15931: PUSH
15932: LD_INT 23100
15934: PUSH
15935: EMPTY
15936: LIST
15937: LIST
15938: LIST
15939: PUSH
15940: LD_OWVAR 67
15944: ARRAY
15945: ST_TO_ADDR
// wait ( time ) ;
15946: LD_VAR 0 2
15950: PPUSH
15951: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
15955: LD_ADDR_VAR 0 2
15959: PUSH
15960: LD_INT 15750
15962: PUSH
15963: LD_INT 15400
15965: PUSH
15966: LD_INT 15050
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: LIST
15973: PUSH
15974: LD_OWVAR 67
15978: ARRAY
15979: ST_TO_ADDR
// wave := 0 ;
15980: LD_ADDR_VAR 0 3
15984: PUSH
15985: LD_INT 0
15987: ST_TO_ADDR
// while true do
15988: LD_INT 1
15990: IFFALSE 16094
// begin wave := wave + 1 ;
15992: LD_ADDR_VAR 0 3
15996: PUSH
15997: LD_VAR 0 3
16001: PUSH
16002: LD_INT 1
16004: PLUS
16005: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16006: LD_INT 22
16008: PUSH
16009: LD_INT 2
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PPUSH
16016: CALL_OW 69
16020: IFFALSE 16056
// begin repeat wait ( 0 0$1 ) ;
16022: LD_INT 35
16024: PPUSH
16025: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16029: LD_INT 22
16031: PUSH
16032: LD_INT 2
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: PPUSH
16039: CALL_OW 69
16043: PUSH
16044: LD_INT 0
16046: EQUAL
16047: IFFALSE 16022
// wait ( 1 1$30 ) ;
16049: LD_INT 3150
16051: PPUSH
16052: CALL_OW 67
// end ; if ru_force < 20 then
16056: LD_EXP 36
16060: PUSH
16061: LD_INT 20
16063: LESS
16064: IFFALSE 16075
// PrepareAttack ( wave ) ;
16066: LD_VAR 0 3
16070: PPUSH
16071: CALL 14912 0 1
// ru_can_attack := true ;
16075: LD_ADDR_EXP 8
16079: PUSH
16080: LD_INT 1
16082: ST_TO_ADDR
// wait ( time ) ;
16083: LD_VAR 0 2
16087: PPUSH
16088: CALL_OW 67
// end ;
16092: GO 15988
// end ;
16094: PPOPN 3
16096: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16097: LD_EXP 8
16101: PUSH
16102: LD_EXP 36
16106: AND
16107: IFFALSE 16941
16109: GO 16111
16111: DISABLE
16112: LD_INT 0
16114: PPUSH
16115: PPUSH
16116: PPUSH
16117: PPUSH
16118: PPUSH
16119: PPUSH
16120: PPUSH
16121: PPUSH
16122: PPUSH
// begin enable ;
16123: ENABLE
// points1 := [ 107 , 123 ] ;
16124: LD_ADDR_VAR 0 4
16128: PUSH
16129: LD_INT 107
16131: PUSH
16132: LD_INT 123
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16139: LD_ADDR_VAR 0 5
16143: PUSH
16144: LD_INT 55
16146: PUSH
16147: LD_INT 42
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16154: LD_ADDR_VAR 0 6
16158: PUSH
16159: LD_INT 102
16161: PUSH
16162: LD_INT 140
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: LD_INT 105
16171: PUSH
16172: LD_INT 142
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: PUSH
16179: LD_INT 129
16181: PUSH
16182: LD_INT 131
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: LIST
16193: ST_TO_ADDR
// for i in ru_force do
16194: LD_ADDR_VAR 0 1
16198: PUSH
16199: LD_EXP 36
16203: PUSH
16204: FOR_IN
16205: IFFALSE 16939
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16207: LD_ADDR_VAR 0 3
16211: PUSH
16212: LD_INT 81
16214: PUSH
16215: LD_INT 3
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: PPUSH
16222: CALL_OW 69
16226: PPUSH
16227: LD_VAR 0 1
16231: PPUSH
16232: CALL_OW 74
16236: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16237: LD_VAR 0 1
16241: PPUSH
16242: LD_VAR 0 3
16246: PPUSH
16247: CALL_OW 296
16251: PUSH
16252: LD_INT 12
16254: LESS
16255: IFFALSE 16400
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16257: LD_VAR 0 1
16261: PPUSH
16262: CALL_OW 247
16266: PUSH
16267: LD_INT 1
16269: EQUAL
16270: PUSH
16271: LD_VAR 0 1
16275: PPUSH
16276: CALL_OW 257
16280: PUSH
16281: LD_INT 1
16283: EQUAL
16284: AND
16285: PUSH
16286: LD_VAR 0 3
16290: PUSH
16291: LD_INT 21
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PUSH
16301: LD_INT 58
16303: PUSH
16304: EMPTY
16305: LIST
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PPUSH
16311: CALL_OW 69
16315: IN
16316: AND
16317: IFFALSE 16335
// ComEnterUnit ( i , un ) else
16319: LD_VAR 0 1
16323: PPUSH
16324: LD_VAR 0 3
16328: PPUSH
16329: CALL_OW 120
16333: GO 16398
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16335: LD_VAR 0 3
16339: PUSH
16340: LD_INT 21
16342: PUSH
16343: LD_INT 2
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: PUSH
16350: LD_INT 58
16352: PUSH
16353: EMPTY
16354: LIST
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: PPUSH
16360: CALL_OW 69
16364: IN
16365: NOT
16366: IFFALSE 16384
// ComAttackUnit ( i , un ) else
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_VAR 0 3
16377: PPUSH
16378: CALL_OW 115
16382: GO 16398
// ComAttackUnit ( i , JMM ) ;
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_EXP 19
16393: PPUSH
16394: CALL_OW 115
// end else
16398: GO 16937
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_VAR 0 4
16409: PUSH
16410: LD_INT 1
16412: ARRAY
16413: PPUSH
16414: LD_VAR 0 4
16418: PUSH
16419: LD_INT 2
16421: ARRAY
16422: PPUSH
16423: CALL_OW 297
16427: PUSH
16428: LD_VAR 0 1
16432: PPUSH
16433: LD_VAR 0 5
16437: PUSH
16438: LD_INT 1
16440: ARRAY
16441: PPUSH
16442: LD_VAR 0 5
16446: PUSH
16447: LD_INT 2
16449: ARRAY
16450: PPUSH
16451: CALL_OW 297
16455: GREATER
16456: PUSH
16457: LD_EXP 9
16461: AND
16462: PUSH
16463: LD_INT 9
16465: PPUSH
16466: LD_INT 81
16468: PUSH
16469: LD_INT 3
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PPUSH
16476: CALL_OW 70
16480: PUSH
16481: LD_INT 0
16483: EQUAL
16484: OR
16485: IFFALSE 16523
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16487: LD_VAR 0 1
16491: PPUSH
16492: LD_INT 81
16494: PUSH
16495: LD_INT 3
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PPUSH
16502: CALL_OW 69
16506: PPUSH
16507: LD_VAR 0 1
16511: PPUSH
16512: CALL_OW 74
16516: PPUSH
16517: CALL_OW 115
16521: GO 16937
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16523: LD_VAR 0 1
16527: PPUSH
16528: CALL_OW 264
16532: PUSH
16533: LD_INT 45
16535: EQUAL
16536: PUSH
16537: LD_EXP 36
16541: PPUSH
16542: LD_INT 3
16544: PUSH
16545: LD_INT 34
16547: PUSH
16548: LD_INT 45
16550: PUSH
16551: EMPTY
16552: LIST
16553: LIST
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PPUSH
16559: CALL_OW 72
16563: PUSH
16564: LD_INT 6
16566: GREATER
16567: AND
16568: IFFALSE 16749
// begin dist := 9999 ;
16570: LD_ADDR_VAR 0 8
16574: PUSH
16575: LD_INT 9999
16577: ST_TO_ADDR
// xy := 0 ;
16578: LD_ADDR_VAR 0 9
16582: PUSH
16583: LD_INT 0
16585: ST_TO_ADDR
// for x in pointsr do
16586: LD_ADDR_VAR 0 7
16590: PUSH
16591: LD_VAR 0 6
16595: PUSH
16596: FOR_IN
16597: IFFALSE 16745
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16599: LD_VAR 0 1
16603: PPUSH
16604: LD_VAR 0 7
16608: PUSH
16609: LD_INT 1
16611: ARRAY
16612: PPUSH
16613: LD_VAR 0 7
16617: PUSH
16618: LD_INT 2
16620: ARRAY
16621: PPUSH
16622: CALL_OW 297
16626: PUSH
16627: LD_VAR 0 8
16631: LESS
16632: IFFALSE 16677
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16634: LD_ADDR_VAR 0 8
16638: PUSH
16639: LD_VAR 0 1
16643: PPUSH
16644: LD_VAR 0 7
16648: PUSH
16649: LD_INT 1
16651: ARRAY
16652: PPUSH
16653: LD_VAR 0 7
16657: PUSH
16658: LD_INT 2
16660: ARRAY
16661: PPUSH
16662: CALL_OW 297
16666: ST_TO_ADDR
// xy := x ;
16667: LD_ADDR_VAR 0 9
16671: PUSH
16672: LD_VAR 0 7
16676: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16677: LD_VAR 0 9
16681: PUSH
16682: LD_VAR 0 1
16686: PPUSH
16687: LD_VAR 0 9
16691: PUSH
16692: LD_INT 1
16694: ARRAY
16695: PPUSH
16696: LD_VAR 0 9
16700: PUSH
16701: LD_INT 2
16703: ARRAY
16704: PPUSH
16705: CALL_OW 297
16709: PUSH
16710: LD_INT 9
16712: GREATER
16713: AND
16714: IFFALSE 16743
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16716: LD_VAR 0 1
16720: PPUSH
16721: LD_VAR 0 9
16725: PUSH
16726: LD_INT 1
16728: ARRAY
16729: PPUSH
16730: LD_VAR 0 9
16734: PUSH
16735: LD_INT 2
16737: ARRAY
16738: PPUSH
16739: CALL_OW 114
// end ;
16743: GO 16596
16745: POP
16746: POP
// end else
16747: GO 16937
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16749: LD_ADDR_VAR 0 3
16753: PUSH
16754: LD_OWVAR 3
16758: PUSH
16759: LD_VAR 0 1
16763: DIFF
16764: PPUSH
16765: LD_VAR 0 1
16769: PPUSH
16770: CALL_OW 74
16774: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16775: LD_VAR 0 1
16779: PPUSH
16780: CALL_OW 320
16784: NOT
16785: PUSH
16786: LD_VAR 0 3
16790: PUSH
16791: LD_INT 21
16793: PUSH
16794: LD_INT 2
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: LD_INT 33
16803: PUSH
16804: LD_INT 1
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PUSH
16811: LD_INT 58
16813: PUSH
16814: EMPTY
16815: LIST
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: LIST
16821: PPUSH
16822: CALL_OW 69
16826: IN
16827: PUSH
16828: LD_VAR 0 3
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_INT 3
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 2
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: LD_INT 3
16855: PUSH
16856: LD_INT 24
16858: PUSH
16859: LD_INT 249
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: LIST
16874: PPUSH
16875: CALL_OW 69
16879: IN
16880: OR
16881: AND
16882: IFFALSE 16900
// ComAttackUnit ( i , un ) else
16884: LD_VAR 0 1
16888: PPUSH
16889: LD_VAR 0 3
16893: PPUSH
16894: CALL_OW 115
16898: GO 16937
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16900: LD_VAR 0 1
16904: PPUSH
16905: LD_INT 9
16907: PPUSH
16908: LD_INT 81
16910: PUSH
16911: LD_INT 3
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PPUSH
16918: CALL_OW 70
16922: PPUSH
16923: LD_VAR 0 1
16927: PPUSH
16928: CALL_OW 74
16932: PPUSH
16933: CALL_OW 115
// end ; end ; end ; end ;
16937: GO 16204
16939: POP
16940: POP
// end ;
16941: PPOPN 9
16943: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16944: LD_INT 22
16946: PUSH
16947: LD_INT 3
16949: PUSH
16950: EMPTY
16951: LIST
16952: LIST
16953: PUSH
16954: LD_INT 32
16956: PUSH
16957: LD_INT 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PPUSH
16968: CALL_OW 69
16972: IFFALSE 17060
16974: GO 16976
16976: DISABLE
16977: LD_INT 0
16979: PPUSH
16980: PPUSH
// begin enable ;
16981: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16982: LD_ADDR_VAR 0 2
16986: PUSH
16987: LD_INT 22
16989: PUSH
16990: LD_INT 3
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: PUSH
16997: LD_INT 32
16999: PUSH
17000: LD_INT 1
17002: PUSH
17003: EMPTY
17004: LIST
17005: LIST
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: PPUSH
17011: CALL_OW 69
17015: ST_TO_ADDR
// for i in tmp do
17016: LD_ADDR_VAR 0 1
17020: PUSH
17021: LD_VAR 0 2
17025: PUSH
17026: FOR_IN
17027: IFFALSE 17058
// if GetFuel ( i ) < 12 then
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL_OW 261
17038: PUSH
17039: LD_INT 12
17041: LESS
17042: IFFALSE 17056
// SetFuel ( i , 12 ) ;
17044: LD_VAR 0 1
17048: PPUSH
17049: LD_INT 12
17051: PPUSH
17052: CALL_OW 240
17056: GO 17026
17058: POP
17059: POP
// end ;
17060: PPOPN 2
17062: END
// every 0 0$1 trigger can_end do
17063: LD_EXP 17
17067: IFFALSE 17086
17069: GO 17071
17071: DISABLE
// begin Wait ( 1 1$35 ) ;
17072: LD_INT 3325
17074: PPUSH
17075: CALL_OW 67
// PrepareAttack ( 10 ) ;
17079: LD_INT 10
17081: PPUSH
17082: CALL 14912 0 1
// end ;
17086: END
