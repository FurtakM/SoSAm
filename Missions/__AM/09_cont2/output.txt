// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 202 0 0
// PrepareNature ;
  16: CALL 377 0 0
// PrepareRussian ;
  20: CALL 13130 0 0
// PrepareAmerican ;
  24: CALL 1110 0 0
// PrepareOvsyenko ;
  28: CALL 1733 0 0
// Action ;
  32: CALL 2673 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: PUSH
  92: LD_INT 105000
  94: PUSH
  95: LD_INT 111300
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: LIST
 102: PUSH
 103: LD_OWVAR 67
 107: ARRAY
 108: ST_TO_ADDR
// ru_can_attack := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// ar_can_arrive := false ;
 125: LD_ADDR_EXP 10
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// ar_spawned := false ;
 133: LD_ADDR_EXP 11
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// player_want_mortar := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// player_want_info := false ;
 149: LD_ADDR_EXP 13
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// player_get_mortar := false ;
 157: LD_ADDR_EXP 14
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// player_get_info := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// player_attacked_ar := false ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// can_end := false ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// blocked := false ;
 189: LD_ADDR_EXP 18
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// end ;
 197: LD_VAR 0 1
 201: RET
// function DebugMode ; begin
 202: LD_INT 0
 204: PPUSH
// if not debug then
 205: LD_EXP 2
 209: NOT
 210: IFFALSE 214
// exit ;
 212: GO 221
// FogOff ( 1 ) ;
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 344
// end ; end_of_file
 221: LD_VAR 0 1
 225: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
// if exist_mode then
 230: LD_VAR 0 2
 234: IFFALSE 259
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_VAR 0 3
 245: PUSH
 246: LD_VAR 0 1
 250: STR
 251: PPUSH
 252: CALL_OW 34
 256: ST_TO_ADDR
 257: GO 274
// unit := NewCharacter ( ident ) ;
 259: LD_ADDR_VAR 0 5
 263: PUSH
 264: LD_VAR 0 1
 268: PPUSH
 269: CALL_OW 25
 273: ST_TO_ADDR
// result := unit ;
 274: LD_ADDR_VAR 0 4
 278: PUSH
 279: LD_VAR 0 5
 283: ST_TO_ADDR
// end ;
 284: LD_VAR 0 4
 288: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 289: LD_INT 0
 291: PPUSH
// uc_side := side ;
 292: LD_ADDR_OWVAR 20
 296: PUSH
 297: LD_VAR 0 1
 301: ST_TO_ADDR
// uc_nation := nation ;
 302: LD_ADDR_OWVAR 21
 306: PUSH
 307: LD_VAR 0 2
 311: ST_TO_ADDR
// vc_chassis := chassis ;
 312: LD_ADDR_OWVAR 37
 316: PUSH
 317: LD_VAR 0 3
 321: ST_TO_ADDR
// vc_engine := engine ;
 322: LD_ADDR_OWVAR 39
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// vc_control := control ;
 332: LD_ADDR_OWVAR 38
 336: PUSH
 337: LD_VAR 0 5
 341: ST_TO_ADDR
// vc_weapon := weapon ;
 342: LD_ADDR_OWVAR 40
 346: PUSH
 347: LD_VAR 0 6
 351: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 352: LD_ADDR_OWVAR 41
 356: PUSH
 357: LD_VAR 0 7
 361: ST_TO_ADDR
// result := CreateVehicle ;
 362: LD_ADDR_VAR 0 8
 366: PUSH
 367: CALL_OW 45
 371: ST_TO_ADDR
// end ;
 372: LD_VAR 0 8
 376: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 377: LD_INT 0
 379: PPUSH
 380: PPUSH
 381: PPUSH
 382: PPUSH
// uc_side = 0 ;
 383: LD_ADDR_OWVAR 20
 387: PUSH
 388: LD_INT 0
 390: ST_TO_ADDR
// uc_nation = 0 ;
 391: LD_ADDR_OWVAR 21
 395: PUSH
 396: LD_INT 0
 398: ST_TO_ADDR
// nat_area := natureArea ;
 399: LD_ADDR_VAR 0 4
 403: PUSH
 404: LD_INT 1
 406: ST_TO_ADDR
// InitHc ;
 407: CALL_OW 19
// for i = 1 to 4 do
 411: LD_ADDR_VAR 0 2
 415: PUSH
 416: DOUBLE
 417: LD_INT 1
 419: DEC
 420: ST_TO_ADDR
 421: LD_INT 4
 423: PUSH
 424: FOR_TO
 425: IFFALSE 480
// begin hc_class = 18 ;
 427: LD_ADDR_OWVAR 28
 431: PUSH
 432: LD_INT 18
 434: ST_TO_ADDR
// hc_gallery =  ;
 435: LD_ADDR_OWVAR 33
 439: PUSH
 440: LD_STRING 
 442: ST_TO_ADDR
// hc_face_number = 1 ;
 443: LD_ADDR_OWVAR 34
 447: PUSH
 448: LD_INT 1
 450: ST_TO_ADDR
// animal := CreateHuman ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: CALL_OW 44
 460: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 461: LD_VAR 0 3
 465: PPUSH
 466: LD_VAR 0 4
 470: PPUSH
 471: LD_INT 0
 473: PPUSH
 474: CALL_OW 49
// end ;
 478: GO 424
 480: POP
 481: POP
// for i = 1 to 4 do
 482: LD_ADDR_VAR 0 2
 486: PUSH
 487: DOUBLE
 488: LD_INT 1
 490: DEC
 491: ST_TO_ADDR
 492: LD_INT 4
 494: PUSH
 495: FOR_TO
 496: IFFALSE 568
// begin hc_class = class_tiger ;
 498: LD_ADDR_OWVAR 28
 502: PUSH
 503: LD_INT 14
 505: ST_TO_ADDR
// hc_gallery =  ;
 506: LD_ADDR_OWVAR 33
 510: PUSH
 511: LD_STRING 
 513: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 514: LD_ADDR_OWVAR 35
 518: PUSH
 519: LD_INT 5
 521: NEG
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL_OW 12
 530: ST_TO_ADDR
// hc_face_number = 3 ;
 531: LD_ADDR_OWVAR 34
 535: PUSH
 536: LD_INT 3
 538: ST_TO_ADDR
// animal := CreateHuman ;
 539: LD_ADDR_VAR 0 3
 543: PUSH
 544: CALL_OW 44
 548: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 549: LD_VAR 0 3
 553: PPUSH
 554: LD_VAR 0 4
 558: PPUSH
 559: LD_INT 0
 561: PPUSH
 562: CALL_OW 49
// end ;
 566: GO 495
 568: POP
 569: POP
// for i = 1 to 8 do
 570: LD_ADDR_VAR 0 2
 574: PUSH
 575: DOUBLE
 576: LD_INT 1
 578: DEC
 579: ST_TO_ADDR
 580: LD_INT 8
 582: PUSH
 583: FOR_TO
 584: IFFALSE 687
// begin hc_class = class_apeman ;
 586: LD_ADDR_OWVAR 28
 590: PUSH
 591: LD_INT 12
 593: ST_TO_ADDR
// hc_gallery =  ;
 594: LD_ADDR_OWVAR 33
 598: PUSH
 599: LD_STRING 
 601: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 602: LD_ADDR_OWVAR 35
 606: PUSH
 607: LD_INT 2
 609: NEG
 610: PPUSH
 611: LD_INT 2
 613: PPUSH
 614: CALL_OW 12
 618: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 619: LD_ADDR_OWVAR 31
 623: PUSH
 624: LD_INT 1
 626: PPUSH
 627: LD_INT 3
 629: PPUSH
 630: CALL_OW 12
 634: PUSH
 635: LD_INT 1
 637: PPUSH
 638: LD_INT 3
 640: PPUSH
 641: CALL_OW 12
 645: PUSH
 646: LD_INT 0
 648: PUSH
 649: LD_INT 0
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: LIST
 657: ST_TO_ADDR
// animal := CreateHuman ;
 658: LD_ADDR_VAR 0 3
 662: PUSH
 663: CALL_OW 44
 667: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 668: LD_VAR 0 3
 672: PPUSH
 673: LD_VAR 0 4
 677: PPUSH
 678: LD_INT 0
 680: PPUSH
 681: CALL_OW 49
// end ;
 685: GO 583
 687: POP
 688: POP
// for i = 1 to 6 do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: DOUBLE
 695: LD_INT 1
 697: DEC
 698: ST_TO_ADDR
 699: LD_INT 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 758
// begin hc_class = 13 ;
 705: LD_ADDR_OWVAR 28
 709: PUSH
 710: LD_INT 13
 712: ST_TO_ADDR
// hc_gallery =  ;
 713: LD_ADDR_OWVAR 33
 717: PUSH
 718: LD_STRING 
 720: ST_TO_ADDR
// hc_face_number = 4 ;
 721: LD_ADDR_OWVAR 34
 725: PUSH
 726: LD_INT 4
 728: ST_TO_ADDR
// animal := CreateHuman ;
 729: LD_ADDR_VAR 0 3
 733: PUSH
 734: CALL_OW 44
 738: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 739: LD_VAR 0 3
 743: PPUSH
 744: LD_VAR 0 4
 748: PPUSH
 749: LD_INT 0
 751: PPUSH
 752: CALL_OW 49
// end ;
 756: GO 702
 758: POP
 759: POP
// vc_chassis := 31 ;
 760: LD_ADDR_OWVAR 37
 764: PUSH
 765: LD_INT 31
 767: ST_TO_ADDR
// vc_control := control_rider ;
 768: LD_ADDR_OWVAR 38
 772: PUSH
 773: LD_INT 4
 775: ST_TO_ADDR
// animal := CreateVehicle ;
 776: LD_ADDR_VAR 0 3
 780: PUSH
 781: CALL_OW 45
 785: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 786: LD_VAR 0 3
 790: PPUSH
 791: LD_INT 21
 793: PPUSH
 794: LD_INT 22
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 48
// end ;
 804: LD_VAR 0 1
 808: RET
// export function GetTerminalCargo ; begin
 809: LD_INT 0
 811: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 812: LD_ADDR_VAR 0 1
 816: PUSH
 817: LD_EXP 3
 821: PPUSH
 822: CALL_OW 274
 826: PPUSH
 827: LD_INT 3
 829: PPUSH
 830: CALL_OW 275
 834: ST_TO_ADDR
// end ;
 835: LD_VAR 0 1
 839: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 840: LD_INT 0
 842: PPUSH
 843: PPUSH
 844: PPUSH
// result := 0 ;
 845: LD_ADDR_VAR 0 2
 849: PUSH
 850: LD_INT 0
 852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 853: LD_ADDR_VAR 0 4
 857: PUSH
 858: LD_INT 22
 860: PUSH
 861: LD_VAR 0 1
 865: PUSH
 866: EMPTY
 867: LIST
 868: LIST
 869: PUSH
 870: LD_INT 2
 872: PUSH
 873: LD_INT 30
 875: PUSH
 876: LD_INT 0
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 30
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PPUSH
 902: CALL_OW 69
 906: ST_TO_ADDR
// if not tmp then
 907: LD_VAR 0 4
 911: NOT
 912: IFFALSE 916
// exit ;
 914: GO 962
// for i in tmp do
 916: LD_ADDR_VAR 0 3
 920: PUSH
 921: LD_VAR 0 4
 925: PUSH
 926: FOR_IN
 927: IFFALSE 960
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 929: LD_ADDR_VAR 0 2
 933: PUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_VAR 0 3
 943: PPUSH
 944: CALL_OW 274
 948: PPUSH
 949: LD_INT 3
 951: PPUSH
 952: CALL_OW 275
 956: PLUS
 957: ST_TO_ADDR
 958: GO 926
 960: POP
 961: POP
// end ;
 962: LD_VAR 0 2
 966: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 967: LD_INT 0
 969: PPUSH
 970: PPUSH
// area = ListEnvironmentArea ( area ) ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_VAR 0 2
 980: PPUSH
 981: CALL_OW 353
 985: ST_TO_ADDR
// if bulldozer > 0 then
 986: LD_VAR 0 1
 990: PUSH
 991: LD_INT 0
 993: GREATER
 994: IFFALSE 1105
// for i = area downto 1 do
 996: LD_ADDR_VAR 0 4
1000: PUSH
1001: DOUBLE
1002: LD_VAR 0 2
1006: INC
1007: ST_TO_ADDR
1008: LD_INT 1
1010: PUSH
1011: FOR_DOWNTO
1012: IFFALSE 1103
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1014: LD_VAR 0 2
1018: PUSH
1019: LD_VAR 0 4
1023: ARRAY
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_VAR 0 4
1038: ARRAY
1039: PUSH
1040: LD_INT 2
1042: ARRAY
1043: PPUSH
1044: CALL_OW 351
1048: IFFALSE 1101
// if not HasTask ( bulldozer ) then
1050: LD_VAR 0 1
1054: PPUSH
1055: CALL_OW 314
1059: NOT
1060: IFFALSE 1101
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1062: LD_VAR 0 1
1066: PPUSH
1067: LD_VAR 0 2
1071: PUSH
1072: LD_VAR 0 4
1076: ARRAY
1077: PUSH
1078: LD_INT 1
1080: ARRAY
1081: PPUSH
1082: LD_VAR 0 2
1086: PUSH
1087: LD_VAR 0 4
1091: ARRAY
1092: PUSH
1093: LD_INT 2
1095: ARRAY
1096: PPUSH
1097: CALL_OW 171
1101: GO 1011
1103: POP
1104: POP
// end ; end_of_file
1105: LD_VAR 0 3
1109: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1110: LD_INT 0
1112: PPUSH
1113: PPUSH
1114: PPUSH
1115: PPUSH
1116: PPUSH
// uc_side := 1 ;
1117: LD_ADDR_OWVAR 20
1121: PUSH
1122: LD_INT 1
1124: ST_TO_ADDR
// uc_nation := 1 ;
1125: LD_ADDR_OWVAR 21
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1133: LD_ADDR_EXP 19
1137: PUSH
1138: LD_STRING JMM
1140: PPUSH
1141: LD_EXP 2
1145: NOT
1146: PPUSH
1147: LD_STRING 08_
1149: PPUSH
1150: CALL 226 0 3
1154: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1155: LD_ADDR_VAR 0 4
1159: PUSH
1160: LD_INT 1
1162: PPUSH
1163: LD_INT 1
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: LD_INT 2
1171: PPUSH
1172: LD_INT 1
1174: PPUSH
1175: LD_INT 5
1177: PPUSH
1178: LD_INT 55
1180: PPUSH
1181: CALL 289 0 7
1185: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1186: LD_VAR 0 4
1190: PPUSH
1191: LD_INT 3
1193: PPUSH
1194: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1198: LD_VAR 0 4
1202: PPUSH
1203: LD_INT 43
1205: PPUSH
1206: LD_INT 3
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1216: LD_EXP 19
1220: PPUSH
1221: LD_VAR 0 4
1225: PPUSH
1226: CALL_OW 52
// tmp := [ ] ;
1230: LD_ADDR_VAR 0 2
1234: PUSH
1235: EMPTY
1236: ST_TO_ADDR
// uc_side := 4 ;
1237: LD_ADDR_OWVAR 20
1241: PUSH
1242: LD_INT 4
1244: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1245: LD_ADDR_OWVAR 33
1249: PUSH
1250: LD_STRING SecondCharsGal
1252: ST_TO_ADDR
// hc_class := 2 ;
1253: LD_ADDR_OWVAR 28
1257: PUSH
1258: LD_INT 2
1260: ST_TO_ADDR
// hc_sex := sex_female ;
1261: LD_ADDR_OWVAR 27
1265: PUSH
1266: LD_INT 2
1268: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1269: LD_ADDR_OWVAR 30
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: LD_INT 1
1279: PUSH
1280: LD_INT 1
1282: PUSH
1283: LD_INT 0
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1292: LD_ADDR_OWVAR 31
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: LD_INT 4
1302: PUSH
1303: LD_INT 2
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1315: LD_ADDR_OWVAR 29
1319: PUSH
1320: LD_INT 10
1322: PUSH
1323: LD_INT 11
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1330: LD_ADDR_OWVAR 26
1334: PUSH
1335: LD_STRING Naoma Goichman
1337: ST_TO_ADDR
// hc_face_number := 43 ;
1338: LD_ADDR_OWVAR 34
1342: PUSH
1343: LD_INT 43
1345: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1346: LD_ADDR_VAR 0 2
1350: PUSH
1351: LD_VAR 0 2
1355: PUSH
1356: CALL_OW 44
1360: ADD
1361: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1362: LD_ADDR_OWVAR 30
1366: PUSH
1367: LD_INT 0
1369: PUSH
1370: LD_INT 2
1372: PUSH
1373: LD_INT 0
1375: PUSH
1376: LD_INT 1
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1385: LD_ADDR_OWVAR 31
1389: PUSH
1390: LD_INT 0
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1408: LD_ADDR_OWVAR 29
1412: PUSH
1413: LD_INT 10
1415: PUSH
1416: LD_INT 10
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1423: LD_ADDR_OWVAR 26
1427: PUSH
1428: LD_STRING Magdalene Glance
1430: ST_TO_ADDR
// hc_face_number := 44 ;
1431: LD_ADDR_OWVAR 34
1435: PUSH
1436: LD_INT 44
1438: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1439: LD_ADDR_VAR 0 2
1443: PUSH
1444: LD_VAR 0 2
1448: PUSH
1449: CALL_OW 44
1453: ADD
1454: ST_TO_ADDR
// hc_sex := sex_male ;
1455: LD_ADDR_OWVAR 27
1459: PUSH
1460: LD_INT 1
1462: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1463: LD_ADDR_OWVAR 30
1467: PUSH
1468: LD_INT 2
1470: PUSH
1471: LD_INT 2
1473: PUSH
1474: LD_INT 0
1476: PUSH
1477: LD_INT 0
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1486: LD_ADDR_OWVAR 31
1490: PUSH
1491: LD_INT 3
1493: PUSH
1494: LD_INT 4
1496: PUSH
1497: LD_INT 1
1499: PUSH
1500: LD_INT 0
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: LIST
1508: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1509: LD_ADDR_OWVAR 29
1513: PUSH
1514: LD_INT 12
1516: PUSH
1517: LD_INT 10
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: ST_TO_ADDR
// hc_name := Steve Holland ;
1524: LD_ADDR_OWVAR 26
1528: PUSH
1529: LD_STRING Steve Holland
1531: ST_TO_ADDR
// hc_face_number := 60 ;
1532: LD_ADDR_OWVAR 34
1536: PUSH
1537: LD_INT 60
1539: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_VAR 0 2
1549: PUSH
1550: CALL_OW 44
1554: ADD
1555: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1556: LD_ADDR_EXP 24
1560: PUSH
1561: LD_VAR 0 2
1565: PUSH
1566: LD_INT 0
1568: DIFF
1569: ST_TO_ADDR
// for un in alpha_engs do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: LD_EXP 24
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1606
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1583: LD_VAR 0 3
1587: PPUSH
1588: LD_INT 52
1590: PPUSH
1591: LD_INT 35
1593: PPUSH
1594: LD_INT 3
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 50
1604: GO 1580
1606: POP
1607: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1608: LD_ADDR_VAR 0 2
1612: PUSH
1613: DOUBLE
1614: LD_INT 1
1616: DEC
1617: ST_TO_ADDR
1618: LD_INT 1
1620: PUSH
1621: LD_STRING 06_crates_1
1623: PPUSH
1624: LD_INT 0
1626: PPUSH
1627: CALL_OW 30
1631: PLUS
1632: PUSH
1633: LD_INT 2
1635: MUL
1636: PUSH
1637: FOR_TO
1638: IFFALSE 1664
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 5
1645: PPUSH
1646: LD_INT 56
1648: PPUSH
1649: LD_INT 40
1651: PPUSH
1652: LD_INT 2
1654: PPUSH
1655: LD_INT 0
1657: PPUSH
1658: CALL_OW 60
1662: GO 1637
1664: POP
1665: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1666: LD_STRING GammaCommander
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 30
1676: PUSH
1677: LD_INT 3
1679: LESS
1680: IFFALSE 1701
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1682: LD_ADDR_EXP 23
1686: PUSH
1687: LD_STRING VanHouten
1689: PPUSH
1690: LD_INT 0
1692: PPUSH
1693: LD_STRING 
1695: PPUSH
1696: CALL 226 0 3
1700: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1701: LD_ADDR_EXP 26
1705: PUSH
1706: LD_STRING Powell
1708: PPUSH
1709: LD_INT 0
1711: PPUSH
1712: LD_STRING 
1714: PPUSH
1715: CALL 226 0 3
1719: ST_TO_ADDR
// InitHc ;
1720: CALL_OW 19
// InitUc ;
1724: CALL_OW 18
// end ;
1728: LD_VAR 0 1
1732: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1733: LD_INT 0
1735: PPUSH
1736: PPUSH
1737: PPUSH
1738: PPUSH
1739: PPUSH
// uc_side := 4 ;
1740: LD_ADDR_OWVAR 20
1744: PUSH
1745: LD_INT 4
1747: ST_TO_ADDR
// uc_nation := 3 ;
1748: LD_ADDR_OWVAR 21
1752: PUSH
1753: LD_INT 3
1755: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1756: LD_ADDR_VAR 0 4
1760: PUSH
1761: LD_STRING 09_ovsyenko_base
1763: PPUSH
1764: LD_INT 0
1766: PUSH
1767: LD_INT 101
1769: PUSH
1770: LD_INT 118
1772: PUSH
1773: LD_INT 2
1775: PUSH
1776: LD_INT 500
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 31
1788: PUSH
1789: LD_INT 109
1791: PUSH
1792: LD_INT 114
1794: PUSH
1795: LD_INT 4
1797: PUSH
1798: LD_INT 500
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: PUSH
1808: LD_INT 31
1810: PUSH
1811: LD_INT 115
1813: PUSH
1814: LD_INT 132
1816: PUSH
1817: LD_INT 5
1819: PUSH
1820: LD_INT 500
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: LD_INT 31
1832: PUSH
1833: LD_INT 98
1835: PUSH
1836: LD_INT 120
1838: PUSH
1839: LD_INT 1
1841: PUSH
1842: LD_INT 500
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 30
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 2
1867: PUSH
1868: LD_VAR 0 4
1872: PUSH
1873: FOR_IN
1874: IFFALSE 2030
// begin bc_type := i [ 1 ] ;
1876: LD_ADDR_OWVAR 42
1880: PUSH
1881: LD_VAR 0 2
1885: PUSH
1886: LD_INT 1
1888: ARRAY
1889: ST_TO_ADDR
// bc_level := 3 ;
1890: LD_ADDR_OWVAR 43
1894: PUSH
1895: LD_INT 3
1897: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1898: LD_ADDR_VAR 0 3
1902: PUSH
1903: LD_VAR 0 2
1907: PUSH
1908: LD_INT 2
1910: ARRAY
1911: PPUSH
1912: LD_VAR 0 2
1916: PUSH
1917: LD_INT 3
1919: ARRAY
1920: PPUSH
1921: LD_VAR 0 2
1925: PUSH
1926: LD_INT 4
1928: ARRAY
1929: PPUSH
1930: CALL_OW 47
1934: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1935: LD_VAR 0 3
1939: PPUSH
1940: CALL_OW 266
1944: PUSH
1945: LD_INT 0
1947: EQUAL
1948: IFFALSE 1982
// begin SetBName ( b , ovsyenko ) ;
1950: LD_VAR 0 3
1954: PPUSH
1955: LD_STRING ovsyenko
1957: PPUSH
1958: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: CALL_OW 274
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: LD_INT 50
1977: PPUSH
1978: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1982: LD_VAR 0 2
1986: PUSH
1987: LD_INT 5
1989: ARRAY
1990: PUSH
1991: LD_INT 250
1993: LESS
1994: IFFALSE 2010
// SetLives ( b , 333 ) else
1996: LD_VAR 0 3
2000: PPUSH
2001: LD_INT 333
2003: PPUSH
2004: CALL_OW 234
2008: GO 2028
// SetLives ( b , i [ 5 ] ) ;
2010: LD_VAR 0 3
2014: PPUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 5
2022: ARRAY
2023: PPUSH
2024: CALL_OW 234
// end ;
2028: GO 1873
2030: POP
2031: POP
// uc_nation := 1 ;
2032: LD_ADDR_OWVAR 21
2036: PUSH
2037: LD_INT 1
2039: ST_TO_ADDR
// tmp := [ ] ;
2040: LD_ADDR_VAR 0 4
2044: PUSH
2045: EMPTY
2046: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2047: LD_ADDR_EXP 20
2051: PUSH
2052: LD_STRING Gary
2054: PPUSH
2055: LD_EXP 2
2059: NOT
2060: PPUSH
2061: LD_STRING 
2063: PPUSH
2064: CALL 226 0 3
2068: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: LD_VAR 0 4
2078: PUSH
2079: LD_EXP 20
2083: ADD
2084: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2085: LD_ADDR_EXP 21
2089: PUSH
2090: LD_STRING Bobby
2092: PPUSH
2093: LD_EXP 2
2097: NOT
2098: PPUSH
2099: LD_STRING 08_
2101: PPUSH
2102: CALL 226 0 3
2106: ST_TO_ADDR
// if not Bobby then
2107: LD_EXP 21
2111: NOT
2112: IFFALSE 2136
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2114: LD_ADDR_EXP 21
2118: PUSH
2119: LD_STRING Bobby
2121: PPUSH
2122: LD_EXP 2
2126: NOT
2127: PPUSH
2128: LD_STRING 03_
2130: PPUSH
2131: CALL 226 0 3
2135: ST_TO_ADDR
// if Bobby then
2136: LD_EXP 21
2140: IFFALSE 2158
// tmp := tmp ^ Bobby ;
2142: LD_ADDR_VAR 0 4
2146: PUSH
2147: LD_VAR 0 4
2151: PUSH
2152: LD_EXP 21
2156: ADD
2157: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2158: LD_ADDR_EXP 22
2162: PUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: LD_EXP 2
2170: NOT
2171: PPUSH
2172: LD_STRING 08_
2174: PPUSH
2175: CALL 226 0 3
2179: ST_TO_ADDR
// if not Cyrus then
2180: LD_EXP 22
2184: NOT
2185: IFFALSE 2209
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2187: LD_ADDR_EXP 22
2191: PUSH
2192: LD_STRING Cyrus
2194: PPUSH
2195: LD_EXP 2
2199: NOT
2200: PPUSH
2201: LD_STRING 03_
2203: PPUSH
2204: CALL 226 0 3
2208: ST_TO_ADDR
// if Cyrus then
2209: LD_EXP 22
2213: IFFALSE 2231
// tmp := tmp ^ Cyrus ;
2215: LD_ADDR_VAR 0 4
2219: PUSH
2220: LD_VAR 0 4
2224: PUSH
2225: LD_EXP 22
2229: ADD
2230: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2231: LD_ADDR_VAR 0 4
2235: PUSH
2236: LD_VAR 0 4
2240: PUSH
2241: LD_STRING 09_prev_squad
2243: PPUSH
2244: CALL_OW 31
2248: ADD
2249: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2250: LD_STRING 09_prev_squad
2252: PPUSH
2253: CALL_OW 40
// tmp := tmp diff 0 ;
2257: LD_ADDR_VAR 0 4
2261: PUSH
2262: LD_VAR 0 4
2266: PUSH
2267: LD_INT 0
2269: DIFF
2270: ST_TO_ADDR
// if debug then
2271: LD_EXP 2
2275: IFFALSE 2326
// begin for i = 1 to 6 do
2277: LD_ADDR_VAR 0 2
2281: PUSH
2282: DOUBLE
2283: LD_INT 1
2285: DEC
2286: ST_TO_ADDR
2287: LD_INT 6
2289: PUSH
2290: FOR_TO
2291: IFFALSE 2324
// begin PrepareHuman ( false , 1 , 6 ) ;
2293: LD_INT 0
2295: PPUSH
2296: LD_INT 1
2298: PPUSH
2299: LD_INT 6
2301: PPUSH
2302: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2306: LD_ADDR_VAR 0 4
2310: PUSH
2311: LD_VAR 0 4
2315: PUSH
2316: CALL_OW 44
2320: ADD
2321: ST_TO_ADDR
// end ;
2322: GO 2290
2324: POP
2325: POP
// end ; for i in tmp do
2326: LD_ADDR_VAR 0 2
2330: PUSH
2331: LD_VAR 0 4
2335: PUSH
2336: FOR_IN
2337: IFFALSE 2396
// begin if GetClass ( i ) in [ 2 , 3 ] then
2339: LD_VAR 0 2
2343: PPUSH
2344: CALL_OW 257
2348: PUSH
2349: LD_INT 2
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: EMPTY
2356: LIST
2357: LIST
2358: IN
2359: IFFALSE 2373
// SetClass ( i , 1 ) ;
2361: LD_VAR 0 2
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2373: LD_VAR 0 2
2377: PPUSH
2378: LD_INT 106
2380: PPUSH
2381: LD_INT 122
2383: PPUSH
2384: LD_INT 5
2386: PPUSH
2387: LD_INT 0
2389: PPUSH
2390: CALL_OW 50
// end ;
2394: GO 2336
2396: POP
2397: POP
// tmp := tmp diff Gary ;
2398: LD_ADDR_VAR 0 4
2402: PUSH
2403: LD_VAR 0 4
2407: PUSH
2408: LD_EXP 20
2412: DIFF
2413: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2414: LD_ADDR_VAR 0 3
2418: PUSH
2419: LD_INT 22
2421: PUSH
2422: LD_INT 4
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: LD_INT 30
2431: PUSH
2432: LD_INT 31
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PPUSH
2443: CALL_OW 69
2447: ST_TO_ADDR
// for i = 1 to b do
2448: LD_ADDR_VAR 0 2
2452: PUSH
2453: DOUBLE
2454: LD_INT 1
2456: DEC
2457: ST_TO_ADDR
2458: LD_VAR 0 3
2462: PUSH
2463: FOR_TO
2464: IFFALSE 2494
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2466: LD_VAR 0 4
2470: PUSH
2471: LD_VAR 0 2
2475: ARRAY
2476: PPUSH
2477: LD_VAR 0 3
2481: PUSH
2482: LD_VAR 0 2
2486: ARRAY
2487: PPUSH
2488: CALL_OW 120
// end ;
2492: GO 2463
2494: POP
2495: POP
// InitHc ;
2496: CALL_OW 19
// InitUc ;
2500: CALL_OW 18
// end ;
2504: LD_VAR 0 1
2508: RET
// export function PowellTransport ; var i , un ; begin
2509: LD_INT 0
2511: PPUSH
2512: PPUSH
2513: PPUSH
// uc_side := 4 ;
2514: LD_ADDR_OWVAR 20
2518: PUSH
2519: LD_INT 4
2521: ST_TO_ADDR
// uc_nation := 1 ;
2522: LD_ADDR_OWVAR 21
2526: PUSH
2527: LD_INT 1
2529: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2530: LD_INT 1
2532: PPUSH
2533: LD_INT 3
2535: PPUSH
2536: LD_INT 6
2538: PPUSH
2539: CALL_OW 380
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2551: LD_ADDR_OWVAR 33
2555: PUSH
2556: LD_STRING SecondCharsGal
2558: ST_TO_ADDR
// hc_face_number := 30 ;
2559: LD_ADDR_OWVAR 34
2563: PUSH
2564: LD_INT 30
2566: ST_TO_ADDR
// powell_trans := CreateHuman ;
2567: LD_ADDR_EXP 25
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// hc_face_number := 31 ;
2577: LD_ADDR_OWVAR 34
2581: PUSH
2582: LD_INT 31
2584: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2585: LD_ADDR_EXP 25
2589: PUSH
2590: LD_EXP 25
2594: PUSH
2595: CALL_OW 44
2599: ADD
2600: ST_TO_ADDR
// for i = 1 to 2 do
2601: LD_ADDR_VAR 0 2
2605: PUSH
2606: DOUBLE
2607: LD_INT 1
2609: DEC
2610: ST_TO_ADDR
2611: LD_INT 2
2613: PUSH
2614: FOR_TO
2615: IFFALSE 2666
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_INT 4
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 1
2633: PPUSH
2634: LD_INT 1
2636: PPUSH
2637: LD_INT 12
2639: PPUSH
2640: LD_INT 66
2642: PPUSH
2643: CALL 289 0 7
2647: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2648: LD_ADDR_EXP 25
2652: PUSH
2653: LD_EXP 25
2657: PUSH
2658: LD_VAR 0 3
2662: ADD
2663: ST_TO_ADDR
// end ;
2664: GO 2614
2666: POP
2667: POP
// end ; end_of_file
2668: LD_VAR 0 1
2672: RET
// export function Action ; var i , veh ; begin
2673: LD_INT 0
2675: PPUSH
2676: PPUSH
2677: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2678: LD_EXP 24
2682: PPUSH
2683: LD_INT 0
2685: PPUSH
2686: LD_INT 50
2688: PPUSH
2689: LD_INT 38
2691: PPUSH
2692: LD_INT 2
2694: PPUSH
2695: CALL_OW 145
// InGameOn ;
2699: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2703: LD_INT 43
2705: PPUSH
2706: LD_INT 9
2708: PPUSH
2709: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2713: LD_EXP 19
2717: PPUSH
2718: LD_INT 54
2720: PPUSH
2721: LD_INT 34
2723: PPUSH
2724: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2728: LD_EXP 19
2732: PPUSH
2733: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_EXP 24
2746: PUSH
2747: LD_INT 1
2749: ARRAY
2750: PPUSH
2751: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2755: LD_INT 35
2757: PPUSH
2758: CALL_OW 67
// until See ( 4 , JMM ) ;
2762: LD_INT 4
2764: PPUSH
2765: LD_EXP 19
2769: PPUSH
2770: CALL_OW 292
2774: IFFALSE 2755
// CenterNowOnUnits ( JMM ) ;
2776: LD_EXP 19
2780: PPUSH
2781: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2785: LD_EXP 19
2789: PPUSH
2790: LD_STRING D2-JMM-1
2792: PPUSH
2793: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2797: LD_EXP 24
2801: PUSH
2802: LD_INT 3
2804: ARRAY
2805: PPUSH
2806: LD_EXP 19
2810: PPUSH
2811: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2815: LD_EXP 24
2819: PUSH
2820: LD_INT 3
2822: ARRAY
2823: PPUSH
2824: LD_STRING D2-Eng1-1
2826: PPUSH
2827: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2831: LD_EXP 19
2835: PPUSH
2836: LD_STRING D2-JMM-2
2838: PPUSH
2839: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2843: LD_EXP 24
2847: PUSH
2848: LD_INT 3
2850: ARRAY
2851: PPUSH
2852: LD_STRING D2-Eng1-2
2854: PPUSH
2855: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2859: LD_EXP 19
2863: PPUSH
2864: LD_STRING D2-JMM-3
2866: PPUSH
2867: CALL_OW 88
// if Houten then
2871: LD_EXP 23
2875: IFFALSE 3073
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2877: LD_ADDR_VAR 0 3
2881: PUSH
2882: LD_INT 4
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: LD_INT 2
2893: PPUSH
2894: LD_INT 1
2896: PPUSH
2897: LD_INT 4
2899: PPUSH
2900: LD_INT 55
2902: PPUSH
2903: CALL 289 0 7
2907: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2908: LD_VAR 0 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2920: LD_VAR 0 3
2924: PPUSH
2925: LD_INT 46
2927: PPUSH
2928: LD_INT 19
2930: PPUSH
2931: LD_INT 0
2933: PPUSH
2934: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2938: LD_EXP 23
2942: PPUSH
2943: LD_VAR 0 3
2947: PPUSH
2948: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2952: LD_EXP 23
2956: PPUSH
2957: LD_INT 49
2959: PPUSH
2960: LD_INT 33
2962: PPUSH
2963: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2967: LD_EXP 23
2971: PPUSH
2972: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2976: LD_EXP 23
2980: PPUSH
2981: LD_EXP 19
2985: PPUSH
2986: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2990: LD_INT 35
2992: PPUSH
2993: CALL_OW 67
// until See ( 1 , Houten ) ;
2997: LD_INT 1
2999: PPUSH
3000: LD_EXP 23
3004: PPUSH
3005: CALL_OW 292
3009: IFFALSE 2990
// ComTurnUnit ( JMM , Houten ) ;
3011: LD_EXP 19
3015: PPUSH
3016: LD_EXP 23
3020: PPUSH
3021: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3025: LD_EXP 19
3029: PPUSH
3030: LD_STRING D1d-JMM-1
3032: PPUSH
3033: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3037: LD_EXP 23
3041: PPUSH
3042: LD_STRING D1-VanH-1
3044: PPUSH
3045: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3049: LD_EXP 19
3053: PPUSH
3054: LD_STRING D1-JMM-1v
3056: PPUSH
3057: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3061: LD_EXP 19
3065: PPUSH
3066: LD_STRING D1-JMM-2v
3068: PPUSH
3069: CALL_OW 88
// end ; InGameOff ;
3073: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3077: LD_STRING M1
3079: PPUSH
3080: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3084: LD_INT 22
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 92
3096: PUSH
3097: LD_EXP 19
3101: PPUSH
3102: CALL_OW 250
3106: PUSH
3107: LD_EXP 19
3111: PPUSH
3112: CALL_OW 251
3116: PUSH
3117: LD_INT 15
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PPUSH
3130: CALL_OW 69
3134: PPUSH
3135: LD_INT 1
3137: PPUSH
3138: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3142: LD_EXP 24
3146: PUSH
3147: LD_EXP 19
3151: ADD
3152: PUSH
3153: LD_EXP 23
3157: ADD
3158: PPUSH
3159: CALL_OW 141
// end ;
3163: LD_VAR 0 1
3167: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3168: LD_INT 1
3170: PPUSH
3171: LD_EXP 20
3175: PPUSH
3176: CALL_OW 292
3180: PUSH
3181: LD_EXP 19
3185: PPUSH
3186: LD_EXP 20
3190: PPUSH
3191: CALL_OW 296
3195: PUSH
3196: LD_INT 6
3198: LESS
3199: AND
3200: IFFALSE 4073
3202: GO 3204
3204: DISABLE
3205: LD_INT 0
3207: PPUSH
3208: PPUSH
3209: PPUSH
3210: PPUSH
3211: PPUSH
// begin InGameOn ;
3212: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3216: LD_INT 22
3218: PUSH
3219: LD_INT 4
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PPUSH
3226: CALL_OW 69
3230: PPUSH
3231: LD_INT 1
3233: PPUSH
3234: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3238: LD_ADDR_VAR 0 4
3242: PUSH
3243: LD_INT 22
3245: PUSH
3246: LD_INT 1
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 2
3255: PUSH
3256: LD_INT 25
3258: PUSH
3259: LD_INT 1
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 25
3268: PUSH
3269: LD_INT 2
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 25
3278: PUSH
3279: LD_INT 3
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: PUSH
3286: LD_INT 25
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: ST_TO_ADDR
// ComHold ( tmp ) ;
3312: LD_VAR 0 4
3316: PPUSH
3317: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3321: LD_EXP 19
3325: PPUSH
3326: LD_STRING D2-JMM-3a
3328: PPUSH
3329: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3333: LD_EXP 20
3337: PPUSH
3338: LD_EXP 19
3342: PPUSH
3343: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3347: LD_EXP 20
3351: PPUSH
3352: LD_STRING D2-Gary-3
3354: PPUSH
3355: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3359: LD_EXP 19
3363: PPUSH
3364: LD_EXP 20
3368: PPUSH
3369: CALL_OW 119
// for i in tmp do
3373: LD_ADDR_VAR 0 5
3377: PUSH
3378: LD_VAR 0 4
3382: PUSH
3383: FOR_IN
3384: IFFALSE 3429
// begin if IsInUnit ( i ) then
3386: LD_VAR 0 5
3390: PPUSH
3391: CALL_OW 310
3395: IFFALSE 3406
// ComExitBuilding ( i ) ;
3397: LD_VAR 0 5
3401: PPUSH
3402: CALL_OW 122
// wait ( 1 ) ;
3406: LD_INT 1
3408: PPUSH
3409: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3413: LD_VAR 0 5
3417: PPUSH
3418: LD_EXP 19
3422: PPUSH
3423: CALL_OW 119
// end ;
3427: GO 3383
3429: POP
3430: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3431: LD_ADDR_VAR 0 4
3435: PUSH
3436: LD_VAR 0 4
3440: PUSH
3441: LD_EXP 19
3445: PUSH
3446: LD_EXP 23
3450: PUSH
3451: LD_EXP 20
3455: PUSH
3456: LD_EXP 22
3460: PUSH
3461: LD_EXP 21
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_EXP 24
3477: ADD
3478: DIFF
3479: ST_TO_ADDR
// if Bobby then
3480: LD_EXP 21
3484: IFFALSE 3498
// Say ( Bobby , D2-Bobby-3 ) ;
3486: LD_EXP 21
3490: PPUSH
3491: LD_STRING D2-Bobby-3
3493: PPUSH
3494: CALL_OW 88
// if Cyrus then
3498: LD_EXP 22
3502: IFFALSE 3516
// Say ( Cyrus , D2-Cyrus-3 ) ;
3504: LD_EXP 22
3508: PPUSH
3509: LD_STRING D2-Cyrus-3
3511: PPUSH
3512: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3516: LD_EXP 19
3520: PPUSH
3521: LD_STRING D2-JMM-4
3523: PPUSH
3524: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3528: LD_EXP 20
3532: PPUSH
3533: LD_STRING D2-Gary-4
3535: PPUSH
3536: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3540: LD_ADDR_VAR 0 1
3544: PUSH
3545: LD_VAR 0 4
3549: PPUSH
3550: LD_INT 26
3552: PUSH
3553: LD_INT 1
3555: PUSH
3556: EMPTY
3557: LIST
3558: LIST
3559: PPUSH
3560: CALL_OW 72
3564: PUSH
3565: LD_INT 1
3567: ARRAY
3568: ST_TO_ADDR
// if Cyrus then
3569: LD_EXP 22
3573: IFFALSE 3589
// Say ( Cyrus , D2-Cyrus-4 ) else
3575: LD_EXP 22
3579: PPUSH
3580: LD_STRING D2-Cyrus-4
3582: PPUSH
3583: CALL_OW 88
3587: GO 3601
// Say ( un1 , D2-Sol1-4 ) ;
3589: LD_VAR 0 1
3593: PPUSH
3594: LD_STRING D2-Sol1-4
3596: PPUSH
3597: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3601: LD_EXP 19
3605: PPUSH
3606: LD_STRING D2-JMM-5
3608: PPUSH
3609: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_EXP 24
3622: PPUSH
3623: LD_INT 91
3625: PUSH
3626: LD_EXP 19
3630: PUSH
3631: LD_INT 10
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 26
3641: PUSH
3642: LD_INT 2
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 72
3657: ST_TO_ADDR
// if un2 then
3658: LD_VAR 0 2
3662: IFFALSE 3716
// begin un2 := un2 [ un2 ] ;
3664: LD_ADDR_VAR 0 2
3668: PUSH
3669: LD_VAR 0 2
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3680: LD_VAR 0 2
3684: PPUSH
3685: LD_STRING D2-FEng1-5
3687: PPUSH
3688: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3692: LD_EXP 19
3696: PPUSH
3697: LD_STRING D2-JMM-6
3699: PPUSH
3700: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3704: LD_VAR 0 2
3708: PPUSH
3709: LD_STRING D2-FEng1-6
3711: PPUSH
3712: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3716: LD_ADDR_VAR 0 3
3720: PUSH
3721: LD_EXP 24
3725: PPUSH
3726: LD_INT 91
3728: PUSH
3729: LD_EXP 19
3733: PUSH
3734: LD_INT 10
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 26
3744: PUSH
3745: LD_INT 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 72
3760: ST_TO_ADDR
// if un3 then
3761: LD_VAR 0 3
3765: IFFALSE 3820
// begin un3 := un3 [ 1 ] ;
3767: LD_ADDR_VAR 0 3
3771: PUSH
3772: LD_VAR 0 3
3776: PUSH
3777: LD_INT 1
3779: ARRAY
3780: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3781: LD_VAR 0 3
3785: PPUSH
3786: LD_INT 114
3788: PPUSH
3789: LD_INT 122
3791: PPUSH
3792: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3796: LD_VAR 0 3
3800: PPUSH
3801: LD_STRING D2-Eng1-6
3803: PPUSH
3804: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3808: LD_EXP 19
3812: PPUSH
3813: LD_STRING D2-JMM-7
3815: PPUSH
3816: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3820: LD_EXP 20
3824: PPUSH
3825: LD_STRING D2-Gary-7
3827: PPUSH
3828: CALL_OW 88
// if un2 then
3832: LD_VAR 0 2
3836: IFFALSE 3850
// Say ( un2 , D2-FEng1-7 ) ;
3838: LD_VAR 0 2
3842: PPUSH
3843: LD_STRING D2-FEng1-7
3845: PPUSH
3846: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3850: LD_VAR 0 1
3854: PPUSH
3855: LD_STRING D2-Sol1-7
3857: PPUSH
3858: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3862: LD_EXP 19
3866: PPUSH
3867: LD_STRING D2-JMM-8
3869: PPUSH
3870: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3874: LD_INT 22
3876: PUSH
3877: LD_INT 1
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 69
3888: PPUSH
3889: CALL_OW 141
// InGameOff ;
3893: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3897: LD_STRING M1a
3899: PPUSH
3900: CALL_OW 337
// jmm_in_ovsyenko := true ;
3904: LD_ADDR_EXP 4
3908: PUSH
3909: LD_INT 1
3911: ST_TO_ADDR
// if debug then
3912: LD_EXP 2
3916: IFFALSE 4022
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
3918: LD_INT 22
3920: PUSH
3921: LD_INT 1
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PUSH
3928: LD_INT 30
3930: PUSH
3931: LD_INT 0
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PPUSH
3942: CALL_OW 69
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PPUSH
3951: CALL_OW 274
3955: PPUSH
3956: LD_INT 2
3958: PPUSH
3959: LD_INT 1000
3961: PPUSH
3962: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 30
3978: PUSH
3979: LD_INT 0
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PPUSH
3990: CALL_OW 69
3994: PUSH
3995: LD_INT 1
3997: ARRAY
3998: PPUSH
3999: CALL_OW 274
4003: PPUSH
4004: LD_INT 1
4006: PPUSH
4007: LD_INT 1000
4009: PPUSH
4010: CALL_OW 277
// ar_can_arrive := true ;
4014: LD_ADDR_EXP 10
4018: PUSH
4019: LD_INT 1
4021: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4022: LD_INT 1050
4024: PPUSH
4025: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4029: LD_ADDR_VAR 0 4
4033: PUSH
4034: LD_INT 25
4036: PUSH
4037: LD_INT 14
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: PPUSH
4044: CALL_OW 69
4048: ST_TO_ADDR
// if not tmp then
4049: LD_VAR 0 4
4053: NOT
4054: IFFALSE 4058
// exit ;
4056: GO 4073
// ComMoveXY ( tmp , 75 , 75 ) ;
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_INT 75
4065: PPUSH
4066: LD_INT 75
4068: PPUSH
4069: CALL_OW 111
// end ;
4073: PPOPN 5
4075: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4076: LD_INT 22
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 30
4088: PUSH
4089: LD_INT 30
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 3
4098: PUSH
4099: LD_INT 57
4101: PUSH
4102: EMPTY
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: IFFALSE 4160
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4126: LD_ADDR_VAR 0 1
4130: PUSH
4131: LD_STRING M2easy
4133: PUSH
4134: LD_STRING M2
4136: PUSH
4137: LD_STRING M2hard
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4145: LD_VAR 0 1
4149: PUSH
4150: LD_OWVAR 67
4154: ARRAY
4155: PPUSH
4156: CALL_OW 337
// end ;
4160: PPOPN 1
4162: END
// every 3 3$00 do
4163: GO 4165
4165: DISABLE
// begin DialogueOn ;
4166: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4170: LD_EXP 26
4174: PPUSH
4175: LD_STRING D3-Pow-1
4177: PPUSH
4178: CALL_OW 94
// if jmm_in_ovsyenko then
4182: LD_EXP 4
4186: IFFALSE 4214
// begin Say ( JMM , D3-JMM-1 ) ;
4188: LD_EXP 19
4192: PPUSH
4193: LD_STRING D3-JMM-1
4195: PPUSH
4196: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4200: LD_EXP 19
4204: PPUSH
4205: LD_STRING D3-JMM-1b
4207: PPUSH
4208: CALL_OW 88
// end else
4212: GO 4226
// Say ( JMM , D3-JMM-1a ) ;
4214: LD_EXP 19
4218: PPUSH
4219: LD_STRING D3-JMM-1a
4221: PPUSH
4222: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4226: LD_EXP 26
4230: PPUSH
4231: LD_STRING D3-Pow-2
4233: PPUSH
4234: CALL_OW 94
// DialogueOff ;
4238: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4242: LD_STRING M3
4244: PPUSH
4245: CALL_OW 337
// powell_want_sib := true ;
4249: LD_ADDR_EXP 5
4253: PUSH
4254: LD_INT 1
4256: ST_TO_ADDR
// end ;
4257: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4258: LD_EXP 6
4262: PUSH
4263: LD_INT 0
4265: EQUAL
4266: IFFALSE 5713
4268: GO 4270
4270: DISABLE
4271: LD_INT 0
4273: PPUSH
4274: PPUSH
4275: PPUSH
4276: PPUSH
4277: PPUSH
4278: PPUSH
4279: PPUSH
4280: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4281: LD_INT 4
4283: PPUSH
4284: LD_INT 1
4286: PPUSH
4287: CALL_OW 343
// PowellTransport ;
4291: CALL 2509 0 0
// for i = 1 to 3 do
4295: LD_ADDR_VAR 0 4
4299: PUSH
4300: DOUBLE
4301: LD_INT 1
4303: DEC
4304: ST_TO_ADDR
4305: LD_INT 3
4307: PUSH
4308: FOR_TO
4309: IFFALSE 4376
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4311: LD_ADDR_VAR 0 1
4315: PUSH
4316: LD_INT 6
4318: PPUSH
4319: LD_VAR 0 4
4323: PPUSH
4324: CALL_OW 287
4328: ST_TO_ADDR
// if not tmp then
4329: LD_VAR 0 1
4333: NOT
4334: IFFALSE 4338
// continue ;
4336: GO 4308
// EraseResourceArea ( terminalArea , i ) ;
4338: LD_INT 6
4340: PPUSH
4341: LD_VAR 0 4
4345: PPUSH
4346: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4350: LD_EXP 3
4354: PPUSH
4355: CALL_OW 274
4359: PPUSH
4360: LD_VAR 0 4
4364: PPUSH
4365: LD_VAR 0 1
4369: PPUSH
4370: CALL_OW 276
// end ;
4374: GO 4308
4376: POP
4377: POP
// x := 43 ;
4378: LD_ADDR_VAR 0 2
4382: PUSH
4383: LD_INT 43
4385: ST_TO_ADDR
// y := 3 ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_INT 3
4393: ST_TO_ADDR
// for i = 3 to 4 do
4394: LD_ADDR_VAR 0 4
4398: PUSH
4399: DOUBLE
4400: LD_INT 3
4402: DEC
4403: ST_TO_ADDR
4404: LD_INT 4
4406: PUSH
4407: FOR_TO
4408: IFFALSE 4599
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4410: LD_EXP 25
4414: PUSH
4415: LD_VAR 0 4
4419: ARRAY
4420: PPUSH
4421: LD_INT 4
4423: PPUSH
4424: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4428: LD_EXP 25
4432: PUSH
4433: LD_VAR 0 4
4437: ARRAY
4438: PPUSH
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_VAR 0 3
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4456: LD_EXP 25
4460: PUSH
4461: LD_VAR 0 4
4465: PUSH
4466: LD_INT 2
4468: MINUS
4469: ARRAY
4470: PPUSH
4471: LD_EXP 25
4475: PUSH
4476: LD_VAR 0 4
4480: ARRAY
4481: PPUSH
4482: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4486: LD_EXP 25
4490: PUSH
4491: LD_VAR 0 4
4495: ARRAY
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 100
4502: PPUSH
4503: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4507: LD_EXP 25
4511: PUSH
4512: LD_VAR 0 4
4516: PUSH
4517: LD_INT 2
4519: MINUS
4520: ARRAY
4521: PPUSH
4522: LD_INT 54
4524: PPUSH
4525: LD_INT 42
4527: PPUSH
4528: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4532: LD_EXP 25
4536: PUSH
4537: LD_VAR 0 4
4541: PUSH
4542: LD_INT 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: LD_EXP 3
4551: PPUSH
4552: CALL_OW 250
4556: PPUSH
4557: LD_EXP 3
4561: PPUSH
4562: CALL_OW 251
4566: PPUSH
4567: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4571: LD_EXP 25
4575: PUSH
4576: LD_VAR 0 4
4580: PUSH
4581: LD_INT 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 200
// Wait ( 0 0$02 ) ;
4590: LD_INT 70
4592: PPUSH
4593: CALL_OW 67
// end ;
4597: GO 4407
4599: POP
4600: POP
// time := 0 0$20 ;
4601: LD_ADDR_VAR 0 8
4605: PUSH
4606: LD_INT 700
4608: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4609: LD_INT 35
4611: PPUSH
4612: CALL_OW 67
// time := time - 0 0$01 ;
4616: LD_ADDR_VAR 0 8
4620: PUSH
4621: LD_VAR 0 8
4625: PUSH
4626: LD_INT 35
4628: MINUS
4629: ST_TO_ADDR
// for i = 3 to 4 do
4630: LD_ADDR_VAR 0 4
4634: PUSH
4635: DOUBLE
4636: LD_INT 3
4638: DEC
4639: ST_TO_ADDR
4640: LD_INT 4
4642: PUSH
4643: FOR_TO
4644: IFFALSE 4779
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4646: LD_EXP 25
4650: PUSH
4651: LD_VAR 0 4
4655: ARRAY
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: GREATER
4668: PUSH
4669: LD_EXP 25
4673: PUSH
4674: LD_VAR 0 4
4678: ARRAY
4679: PPUSH
4680: CALL_OW 314
4684: NOT
4685: AND
4686: IFFALSE 4777
// begin x := rand ( 0 , 5 ) ;
4688: LD_ADDR_VAR 0 2
4692: PUSH
4693: LD_INT 0
4695: PPUSH
4696: LD_INT 5
4698: PPUSH
4699: CALL_OW 12
4703: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4704: LD_EXP 25
4708: PUSH
4709: LD_VAR 0 4
4713: ARRAY
4714: PPUSH
4715: LD_EXP 25
4719: PUSH
4720: LD_VAR 0 4
4724: ARRAY
4725: PPUSH
4726: CALL_OW 250
4730: PPUSH
4731: LD_VAR 0 2
4735: PPUSH
4736: LD_INT 3
4738: PPUSH
4739: CALL_OW 272
4743: PPUSH
4744: LD_EXP 25
4748: PUSH
4749: LD_VAR 0 4
4753: ARRAY
4754: PPUSH
4755: CALL_OW 251
4759: PPUSH
4760: LD_VAR 0 2
4764: PPUSH
4765: LD_INT 3
4767: PPUSH
4768: CALL_OW 273
4772: PPUSH
4773: CALL_OW 171
// end ;
4777: GO 4643
4779: POP
4780: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4781: LD_EXP 25
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_INT 54
4792: PPUSH
4793: LD_INT 42
4795: PPUSH
4796: CALL_OW 297
4800: PUSH
4801: LD_INT 4
4803: LESS
4804: PUSH
4805: LD_VAR 0 8
4809: PUSH
4810: LD_INT 0
4812: EQUAL
4813: OR
4814: IFFALSE 4609
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4816: LD_EXP 25
4820: PUSH
4821: LD_INT 3
4823: ARRAY
4824: PPUSH
4825: LD_INT 1
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4835: LD_EXP 25
4839: PUSH
4840: LD_INT 4
4842: ARRAY
4843: PPUSH
4844: LD_INT 1
4846: PPUSH
4847: LD_INT 0
4849: PPUSH
4850: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4854: LD_EXP 3
4858: PPUSH
4859: CALL_OW 274
4863: PPUSH
4864: LD_INT 1
4866: PPUSH
4867: LD_INT 200
4869: PPUSH
4870: CALL_OW 276
// DialogueOn ;
4874: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4878: LD_INT 53
4880: PPUSH
4881: LD_INT 35
4883: PPUSH
4884: CALL_OW 86
// un := powell_trans [ 1 ] ;
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_EXP 25
4897: PUSH
4898: LD_INT 1
4900: ARRAY
4901: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4902: LD_VAR 0 5
4906: PPUSH
4907: LD_STRING D4-Mech1-1
4909: PPUSH
4910: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4914: LD_EXP 19
4918: PPUSH
4919: LD_STRING D4-JMM-1
4921: PPUSH
4922: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4926: LD_VAR 0 5
4930: PPUSH
4931: LD_STRING D4-Mech1-2
4933: PPUSH
4934: CALL_OW 88
// powell_happy := false ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_INT 0
4945: ST_TO_ADDR
// take_cargo := false ;
4946: LD_ADDR_VAR 0 7
4950: PUSH
4951: LD_INT 0
4953: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4954: CALL 809 0 0
4958: PUSH
4959: LD_INT 60
4961: GREATEREQUAL
4962: IFFALSE 5010
// begin Say ( JMM , D5-JMM-1 ) ;
4964: LD_EXP 19
4968: PPUSH
4969: LD_STRING D5-JMM-1
4971: PPUSH
4972: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4976: LD_VAR 0 5
4980: PPUSH
4981: LD_STRING D6-Mech1-1
4983: PPUSH
4984: CALL_OW 88
// powell_happy := true ;
4988: LD_ADDR_VAR 0 6
4992: PUSH
4993: LD_INT 1
4995: ST_TO_ADDR
// take_cargo := true ;
4996: LD_ADDR_VAR 0 7
5000: PUSH
5001: LD_INT 1
5003: ST_TO_ADDR
// DialogueOff ;
5004: CALL_OW 7
// end else
5008: GO 5244
// if GetTerminalCargo > 0 then
5010: CALL 809 0 0
5014: PUSH
5015: LD_INT 0
5017: GREATER
5018: IFFALSE 5216
// begin case Query ( QWait ) of 1 :
5020: LD_STRING QWait
5022: PPUSH
5023: CALL_OW 97
5027: PUSH
5028: LD_INT 1
5030: DOUBLE
5031: EQUAL
5032: IFTRUE 5036
5034: GO 5127
5036: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5037: LD_EXP 19
5041: PPUSH
5042: LD_STRING D5a-JMM-1
5044: PPUSH
5045: CALL_OW 88
// DialogueOff ;
5049: CALL_OW 7
// wait ( 5 5$00 ) ;
5053: LD_INT 10500
5055: PPUSH
5056: CALL_OW 67
// if GetTerminalCargo < 60 then
5060: CALL 809 0 0
5064: PUSH
5065: LD_INT 60
5067: LESS
5068: IFFALSE 5109
// begin DialogueOn ;
5070: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5074: LD_EXP 3
5078: PPUSH
5079: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5083: LD_VAR 0 5
5087: PPUSH
5088: LD_STRING D6-Mech1-1a
5090: PPUSH
5091: CALL_OW 88
// DialogueOff ;
5095: CALL_OW 7
// powell_happy := false ;
5099: LD_ADDR_VAR 0 6
5103: PUSH
5104: LD_INT 0
5106: ST_TO_ADDR
// end else
5107: GO 5125
// begin powell_happy := true ;
5109: LD_ADDR_VAR 0 6
5113: PUSH
5114: LD_INT 1
5116: ST_TO_ADDR
// take_cargo := true ;
5117: LD_ADDR_VAR 0 7
5121: PUSH
5122: LD_INT 1
5124: ST_TO_ADDR
// end ; end ; 2 :
5125: GO 5214
5127: LD_INT 2
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5135
5133: GO 5174
5135: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5136: LD_EXP 19
5140: PPUSH
5141: LD_STRING D5b-JMM-1
5143: PPUSH
5144: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5148: LD_VAR 0 5
5152: PPUSH
5153: LD_STRING D6-Mech1-1a
5155: PPUSH
5156: CALL_OW 88
// DialogueOff ;
5160: CALL_OW 7
// take_cargo := true ;
5164: LD_ADDR_VAR 0 7
5168: PUSH
5169: LD_INT 1
5171: ST_TO_ADDR
// end ; 3 :
5172: GO 5214
5174: LD_INT 3
5176: DOUBLE
5177: EQUAL
5178: IFTRUE 5182
5180: GO 5213
5182: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5183: LD_EXP 19
5187: PPUSH
5188: LD_STRING D5c-JMM-1
5190: PPUSH
5191: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D6-Mech1-1b
5202: PPUSH
5203: CALL_OW 88
// DialogueOff ;
5207: CALL_OW 7
// end ; end ;
5211: GO 5214
5213: POP
// end else
5214: GO 5244
// begin Say ( JMM , D5c-JMM-1 ) ;
5216: LD_EXP 19
5220: PPUSH
5221: LD_STRING D5c-JMM-1
5223: PPUSH
5224: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5228: LD_VAR 0 5
5232: PPUSH
5233: LD_STRING D6-Mech1-1b
5235: PPUSH
5236: CALL_OW 88
// DialogueOff ;
5240: CALL_OW 7
// end ; if take_cargo then
5244: LD_VAR 0 7
5248: IFFALSE 5327
// begin x := GetTerminalCargo ;
5250: LD_ADDR_VAR 0 2
5254: PUSH
5255: CALL 809 0 0
5259: ST_TO_ADDR
// if x > 60 then
5260: LD_VAR 0 2
5264: PUSH
5265: LD_INT 60
5267: GREATER
5268: IFFALSE 5278
// x := 60 ;
5270: LD_ADDR_VAR 0 2
5274: PUSH
5275: LD_INT 60
5277: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5278: LD_EXP 3
5282: PPUSH
5283: CALL_OW 274
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 809 0 0
5295: PUSH
5296: LD_VAR 0 2
5300: MINUS
5301: PPUSH
5302: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5306: LD_EXP 25
5310: PUSH
5311: LD_INT 3
5313: ARRAY
5314: PPUSH
5315: LD_INT 3
5317: PPUSH
5318: LD_VAR 0 2
5322: PPUSH
5323: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5327: LD_EXP 25
5331: PPUSH
5332: LD_INT 43
5334: PPUSH
5335: LD_INT 3
5337: PPUSH
5338: CALL_OW 171
// x := 0 0$20 ;
5342: LD_ADDR_VAR 0 2
5346: PUSH
5347: LD_INT 700
5349: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// x := x - 0 0$01 ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_VAR 0 2
5366: PUSH
5367: LD_INT 35
5369: MINUS
5370: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5371: LD_VAR 0 2
5375: PUSH
5376: LD_INT 0
5378: EQUAL
5379: PUSH
5380: LD_EXP 25
5384: PUSH
5385: LD_INT 3
5387: ARRAY
5388: PPUSH
5389: LD_INT 43
5391: PPUSH
5392: LD_INT 3
5394: PPUSH
5395: CALL_OW 297
5399: PUSH
5400: LD_INT 4
5402: LESS
5403: PUSH
5404: LD_EXP 25
5408: PUSH
5409: LD_INT 3
5411: ARRAY
5412: PPUSH
5413: LD_INT 43
5415: PPUSH
5416: LD_INT 3
5418: PPUSH
5419: CALL_OW 297
5423: PUSH
5424: LD_INT 4
5426: LESS
5427: AND
5428: OR
5429: IFFALSE 5350
// for i in powell_trans do
5431: LD_ADDR_VAR 0 4
5435: PUSH
5436: LD_EXP 25
5440: PUSH
5441: FOR_IN
5442: IFFALSE 5455
// RemoveUnit ( i ) ;
5444: LD_VAR 0 4
5448: PPUSH
5449: CALL_OW 64
5453: GO 5441
5455: POP
5456: POP
// if not powell_happy then
5457: LD_VAR 0 6
5461: NOT
5462: IFFALSE 5473
// powell_happy := - 1 ;
5464: LD_ADDR_VAR 0 6
5468: PUSH
5469: LD_INT 1
5471: NEG
5472: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5473: LD_STRING EarlySiberite
5475: PPUSH
5476: LD_VAR 0 6
5480: PPUSH
5481: CALL_OW 101
// if powell_happy then
5485: LD_VAR 0 6
5489: IFFALSE 5500
// ChangeMissionObjectives ( M3a ) else
5491: LD_STRING M3a
5493: PPUSH
5494: CALL_OW 337
5498: GO 5507
// ChangeMissionObjectives ( M3b ) ;
5500: LD_STRING M3b
5502: PPUSH
5503: CALL_OW 337
// ru_can_attack_terminal := true ;
5507: LD_ADDR_EXP 9
5511: PUSH
5512: LD_INT 1
5514: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5515: LD_INT 25200
5517: PPUSH
5518: CALL_OW 67
// time := 2 2$00 ;
5522: LD_ADDR_VAR 0 8
5526: PUSH
5527: LD_INT 4200
5529: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5530: LD_INT 35
5532: PPUSH
5533: CALL_OW 67
// time := time - 0 0$1 ;
5537: LD_ADDR_VAR 0 8
5541: PUSH
5542: LD_VAR 0 8
5546: PUSH
5547: LD_INT 35
5549: MINUS
5550: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5551: LD_EXP 8
5555: NOT
5556: PUSH
5557: LD_EXP 36
5561: PUSH
5562: LD_INT 0
5564: EQUAL
5565: OR
5566: PUSH
5567: LD_VAR 0 8
5571: PUSH
5572: LD_INT 0
5574: EQUAL
5575: OR
5576: IFFALSE 5530
// if ru_force then
5578: LD_EXP 36
5582: IFFALSE 5681
// for i in ru_force do
5584: LD_ADDR_VAR 0 4
5588: PUSH
5589: LD_EXP 36
5593: PUSH
5594: FOR_IN
5595: IFFALSE 5679
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5597: LD_INT 1
5599: PPUSH
5600: LD_VAR 0 4
5604: PPUSH
5605: CALL_OW 292
5609: NOT
5610: PUSH
5611: LD_VAR 0 4
5615: PPUSH
5616: LD_INT 81
5618: PUSH
5619: LD_INT 3
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: PPUSH
5631: LD_VAR 0 4
5635: PPUSH
5636: CALL_OW 74
5640: PPUSH
5641: CALL_OW 296
5645: PUSH
5646: LD_INT 10
5648: GREATER
5649: AND
5650: IFFALSE 5677
// begin RemoveUnit ( i ) ;
5652: LD_VAR 0 4
5656: PPUSH
5657: CALL_OW 64
// ru_force := ru_force diff i ;
5661: LD_ADDR_EXP 36
5665: PUSH
5666: LD_EXP 36
5670: PUSH
5671: LD_VAR 0 4
5675: DIFF
5676: ST_TO_ADDR
// end ;
5677: GO 5594
5679: POP
5680: POP
// repeat wait ( 0 0$03 ) ;
5681: LD_INT 105
5683: PPUSH
5684: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5688: LD_EXP 8
5692: NOT
5693: PUSH
5694: LD_EXP 36
5698: PUSH
5699: LD_INT 3
5701: LESS
5702: OR
5703: IFFALSE 5681
// ar_can_arrive := true ;
5705: LD_ADDR_EXP 10
5709: PUSH
5710: LD_INT 1
5712: ST_TO_ADDR
// end ;
5713: PPOPN 8
5715: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5716: LD_INT 1
5718: PPUSH
5719: LD_INT 20
5721: PPUSH
5722: CALL_OW 325
5726: IFFALSE 5867
5728: GO 5730
5730: DISABLE
5731: LD_INT 0
5733: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: LD_INT 22
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: LD_INT 1
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 25
5761: PUSH
5762: LD_INT 4
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 69
5778: PUSH
5779: LD_EXP 19
5783: PUSH
5784: LD_EXP 22
5788: PUSH
5789: LD_EXP 21
5793: PUSH
5794: LD_EXP 23
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: DIFF
5805: ST_TO_ADDR
// if not un then
5806: LD_VAR 0 1
5810: NOT
5811: IFFALSE 5815
// exit ;
5813: GO 5867
// DialogueOn ;
5815: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5819: LD_VAR 0 1
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_STRING D13-Sci1-1
5830: PPUSH
5831: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5835: LD_EXP 19
5839: PPUSH
5840: LD_STRING D13-JMM-1
5842: PPUSH
5843: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5847: LD_VAR 0 1
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PPUSH
5856: LD_STRING D13-Sci1-2
5858: PPUSH
5859: CALL_OW 88
// DialogueOff ;
5863: CALL_OW 7
// end ;
5867: PPOPN 1
5869: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5870: LD_INT 1
5872: PPUSH
5873: CALL 840 0 1
5877: PUSH
5878: LD_INT 77
5880: GREATER
5881: PUSH
5882: LD_EXP 8
5886: NOT
5887: AND
5888: PUSH
5889: LD_INT 22
5891: PUSH
5892: LD_INT 1
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 25
5901: PUSH
5902: LD_INT 4
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: LD_INT 26
5911: PUSH
5912: LD_INT 1
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: PPUSH
5924: CALL_OW 69
5928: PUSH
5929: LD_EXP 19
5933: PUSH
5934: LD_EXP 21
5938: PUSH
5939: LD_EXP 22
5943: PUSH
5944: LD_EXP 20
5948: PUSH
5949: LD_EXP 23
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: DIFF
5961: AND
5962: IFFALSE 6140
5964: GO 5966
5966: DISABLE
5967: LD_INT 0
5969: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5970: LD_ADDR_VAR 0 1
5974: PUSH
5975: LD_INT 22
5977: PUSH
5978: LD_INT 1
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 25
5987: PUSH
5988: LD_INT 4
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: PUSH
6015: LD_EXP 19
6019: PUSH
6020: LD_EXP 21
6024: PUSH
6025: LD_EXP 22
6029: PUSH
6030: LD_EXP 20
6034: PUSH
6035: LD_EXP 23
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: DIFF
6047: ST_TO_ADDR
// DialogueOn ;
6048: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6052: LD_VAR 0 1
6056: PUSH
6057: LD_INT 1
6059: ARRAY
6060: PPUSH
6061: LD_STRING D7-Sci1-1
6063: PPUSH
6064: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6068: LD_EXP 19
6072: PPUSH
6073: LD_STRING D7-JMM-1
6075: PPUSH
6076: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6080: LD_VAR 0 1
6084: PUSH
6085: LD_INT 1
6087: ARRAY
6088: PPUSH
6089: LD_STRING D7-Sci1-2
6091: PPUSH
6092: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6096: LD_EXP 19
6100: PPUSH
6101: LD_STRING D7-JMM-2
6103: PPUSH
6104: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6108: LD_VAR 0 1
6112: PUSH
6113: LD_INT 1
6115: ARRAY
6116: PPUSH
6117: LD_STRING D7-Sci1-3
6119: PPUSH
6120: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6124: LD_EXP 19
6128: PPUSH
6129: LD_STRING D7-JMM-3
6131: PPUSH
6132: CALL_OW 88
// DialogueOff ;
6136: CALL_OW 7
// end ;
6140: PPOPN 1
6142: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates ;
6143: LD_EXP 10
6147: IFFALSE 9660
6149: GO 6151
6151: DISABLE
6152: LD_INT 0
6154: PPUSH
6155: PPUSH
6156: PPUSH
6157: PPUSH
6158: PPUSH
6159: PPUSH
6160: PPUSH
6161: PPUSH
6162: PPUSH
// begin PrepareArabian ;
6163: CALL 12236 0 0
// blocked := false ;
6167: LD_ADDR_EXP 18
6171: PUSH
6172: LD_INT 0
6174: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6175: LD_INT 35
6177: PPUSH
6178: CALL_OW 67
// until ar_spawned ;
6182: LD_EXP 11
6186: IFFALSE 6175
// have_crates := true ;
6188: LD_ADDR_VAR 0 9
6192: PUSH
6193: LD_INT 1
6195: ST_TO_ADDR
// player_want_info := 2 ;
6196: LD_ADDR_EXP 13
6200: PUSH
6201: LD_INT 2
6203: ST_TO_ADDR
// DialogueOn ;
6204: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6208: LD_EXP 27
6212: PPUSH
6213: LD_STRING D8-Ar1-1
6215: PPUSH
6216: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6220: LD_EXP 19
6224: PPUSH
6225: LD_STRING D8-JMM-1
6227: PPUSH
6228: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6232: LD_EXP 27
6236: PPUSH
6237: LD_STRING D8-Ar1-2
6239: PPUSH
6240: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6244: LD_EXP 19
6248: PPUSH
6249: LD_STRING D8-JMM-2
6251: PPUSH
6252: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6256: LD_EXP 27
6260: PPUSH
6261: LD_STRING D8-Ar1-3
6263: PPUSH
6264: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6268: LD_EXP 19
6272: PPUSH
6273: LD_STRING D8-JMM-3
6275: PPUSH
6276: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6280: LD_EXP 27
6284: PPUSH
6285: LD_STRING D8-Ar1-4
6287: PPUSH
6288: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6292: LD_EXP 19
6296: PPUSH
6297: LD_STRING D8-JMM-4
6299: PPUSH
6300: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6304: LD_EXP 27
6308: PPUSH
6309: LD_STRING D8-Ar1-5
6311: PPUSH
6312: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6316: LD_EXP 19
6320: PPUSH
6321: LD_STRING D8-JMM-5
6323: PPUSH
6324: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6328: LD_EXP 27
6332: PPUSH
6333: LD_STRING D8-Ar1-6
6335: PPUSH
6336: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6340: LD_EXP 28
6344: PPUSH
6345: LD_STRING D8-Ar2-6
6347: PPUSH
6348: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6352: LD_EXP 19
6356: PPUSH
6357: LD_STRING D8-JMM-6
6359: PPUSH
6360: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6364: LD_EXP 28
6368: PPUSH
6369: LD_STRING D8-Ar2-7
6371: PPUSH
6372: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6376: LD_STRING QBarracks
6378: PPUSH
6379: CALL_OW 97
6383: PUSH
6384: LD_INT 1
6386: DOUBLE
6387: EQUAL
6388: IFTRUE 6392
6390: GO 6427
6392: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6393: LD_EXP 19
6397: PPUSH
6398: LD_STRING D8a-JMM-1
6400: PPUSH
6401: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6405: LD_EXP 27
6409: PPUSH
6410: LD_STRING D8a-Ar1-1
6412: PPUSH
6413: CALL_OW 94
// player_want_mortar := true ;
6417: LD_ADDR_EXP 12
6421: PUSH
6422: LD_INT 1
6424: ST_TO_ADDR
// end ; 2 :
6425: GO 6601
6427: LD_INT 2
6429: DOUBLE
6430: EQUAL
6431: IFTRUE 6435
6433: GO 6557
6435: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6436: LD_EXP 19
6440: PPUSH
6441: LD_STRING D8b-JMM-1
6443: PPUSH
6444: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6448: LD_EXP 27
6452: PPUSH
6453: LD_STRING D8b-Ar1-1
6455: PPUSH
6456: CALL_OW 94
// case Query ( QInfo ) of 1 :
6460: LD_STRING QInfo
6462: PPUSH
6463: CALL_OW 97
6467: PUSH
6468: LD_INT 1
6470: DOUBLE
6471: EQUAL
6472: IFTRUE 6476
6474: GO 6511
6476: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6477: LD_EXP 19
6481: PPUSH
6482: LD_STRING D8b1-JMM-1
6484: PPUSH
6485: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6489: LD_EXP 27
6493: PPUSH
6494: LD_STRING D8b1-Ar1-1
6496: PPUSH
6497: CALL_OW 94
// player_want_info := 2 ;
6501: LD_ADDR_EXP 13
6505: PUSH
6506: LD_INT 2
6508: ST_TO_ADDR
// end ; 2 :
6509: GO 6555
6511: LD_INT 2
6513: DOUBLE
6514: EQUAL
6515: IFTRUE 6519
6517: GO 6554
6519: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6520: LD_EXP 19
6524: PPUSH
6525: LD_STRING D8b2-JMM-1
6527: PPUSH
6528: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6532: LD_EXP 27
6536: PPUSH
6537: LD_STRING D8b2-Ar1-1
6539: PPUSH
6540: CALL_OW 94
// player_want_info := 0 ;
6544: LD_ADDR_EXP 13
6548: PUSH
6549: LD_INT 0
6551: ST_TO_ADDR
// end ; end ;
6552: GO 6555
6554: POP
// end ; 3 :
6555: GO 6601
6557: LD_INT 3
6559: DOUBLE
6560: EQUAL
6561: IFTRUE 6565
6563: GO 6600
6565: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6566: LD_EXP 19
6570: PPUSH
6571: LD_STRING D8c-JMM-1
6573: PPUSH
6574: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6578: LD_EXP 27
6582: PPUSH
6583: LD_STRING D8c-Ar1-1
6585: PPUSH
6586: CALL_OW 94
// player_want_info := 0 ;
6590: LD_ADDR_EXP 13
6594: PUSH
6595: LD_INT 0
6597: ST_TO_ADDR
// end ; end ;
6598: GO 6601
6600: POP
// DialogueOff ;
6601: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6605: LD_ADDR_VAR 0 4
6609: PUSH
6610: LD_INT 9
6612: PPUSH
6613: LD_INT 2
6615: PUSH
6616: LD_INT 30
6618: PUSH
6619: LD_INT 0
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: LD_INT 30
6628: PUSH
6629: LD_INT 1
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: PPUSH
6641: CALL_OW 70
6645: ST_TO_ADDR
// if dep then
6646: LD_VAR 0 4
6650: IFFALSE 6666
// dep := dep [ 1 ] ;
6652: LD_ADDR_VAR 0 4
6656: PUSH
6657: LD_VAR 0 4
6661: PUSH
6662: LD_INT 1
6664: ARRAY
6665: ST_TO_ADDR
// if not dep then
6666: LD_VAR 0 4
6670: NOT
6671: IFFALSE 6709
// begin case Query ( QInfoNothing ) of 1 :
6673: LD_STRING QInfoNothing
6675: PPUSH
6676: CALL_OW 97
6680: PUSH
6681: LD_INT 1
6683: DOUBLE
6684: EQUAL
6685: IFTRUE 6689
6687: GO 6692
6689: POP
// ; end ;
6690: GO 6693
6692: POP
// player_want_info := false ;
6693: LD_ADDR_EXP 13
6697: PUSH
6698: LD_INT 0
6700: ST_TO_ADDR
// player_want_mortar := false ;
6701: LD_ADDR_EXP 12
6705: PUSH
6706: LD_INT 0
6708: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6709: LD_ADDR_VAR 0 3
6713: PUSH
6714: LD_INT 22
6716: PUSH
6717: LD_INT 2
6719: PUSH
6720: EMPTY
6721: LIST
6722: LIST
6723: PUSH
6724: LD_INT 21
6726: PUSH
6727: LD_INT 2
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: CALL_OW 69
6742: ST_TO_ADDR
// time := 1 1$55 ;
6743: LD_ADDR_VAR 0 5
6747: PUSH
6748: LD_INT 4025
6750: ST_TO_ADDR
// no_oil_gain := false ;
6751: LD_ADDR_VAR 0 6
6755: PUSH
6756: LD_INT 0
6758: ST_TO_ADDR
// first_warn := false ;
6759: LD_ADDR_VAR 0 7
6763: PUSH
6764: LD_INT 0
6766: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6767: LD_EXP 12
6771: PUSH
6772: LD_EXP 13
6776: OR
6777: IFFALSE 6882
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6779: LD_EXP 34
6783: PPUSH
6784: LD_INT 25
6786: PUSH
6787: LD_INT 1
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PPUSH
6794: CALL_OW 72
6798: PPUSH
6799: LD_VAR 0 4
6803: PPUSH
6804: CALL_OW 250
6808: PPUSH
6809: LD_VAR 0 4
6813: PPUSH
6814: CALL_OW 251
6818: PPUSH
6819: LD_VAR 0 4
6823: PPUSH
6824: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6828: LD_EXP 34
6832: PPUSH
6833: LD_INT 25
6835: PUSH
6836: LD_INT 1
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 72
6847: PPUSH
6848: LD_INT 86
6850: PPUSH
6851: LD_INT 121
6853: PPUSH
6854: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6858: LD_EXP 34
6862: PPUSH
6863: LD_INT 25
6865: PUSH
6866: LD_INT 1
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PPUSH
6873: CALL_OW 72
6877: PPUSH
6878: CALL_OW 200
// end ; if player_attacked_ar then
6882: LD_EXP 16
6886: IFFALSE 6890
// exit ;
6888: GO 9660
// if player_want_mortar then
6890: LD_EXP 12
6894: IFFALSE 8322
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6896: LD_EXP 28
6900: PPUSH
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL_OW 250
6910: PUSH
6911: LD_INT 1
6913: PLUS
6914: PPUSH
6915: LD_VAR 0 4
6919: PPUSH
6920: CALL_OW 251
6924: PUSH
6925: LD_INT 1
6927: PLUS
6928: PPUSH
6929: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6933: LD_INT 35
6935: PPUSH
6936: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6940: LD_EXP 28
6944: PPUSH
6945: LD_VAR 0 4
6949: PPUSH
6950: CALL_OW 296
6954: PUSH
6955: LD_INT 4
6957: LESS
6958: IFFALSE 6933
// for i = 1 to 6 do
6960: LD_ADDR_VAR 0 1
6964: PUSH
6965: DOUBLE
6966: LD_INT 1
6968: DEC
6969: ST_TO_ADDR
6970: LD_INT 6
6972: PUSH
6973: FOR_TO
6974: IFFALSE 7178
// begin if player_attacked_ar then
6976: LD_EXP 16
6980: IFFALSE 6986
// exit ;
6982: POP
6983: POP
6984: GO 9660
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6986: LD_VAR 0 4
6990: PPUSH
6991: CALL_OW 274
6995: PPUSH
6996: LD_INT 2
6998: PPUSH
6999: CALL_OW 275
7003: PUSH
7004: LD_INT 10
7006: LESS
7007: PUSH
7008: LD_VAR 0 7
7012: NOT
7013: AND
7014: IFFALSE 7077
// begin first_warn := true ;
7016: LD_ADDR_VAR 0 7
7020: PUSH
7021: LD_INT 1
7023: ST_TO_ADDR
// DialogueOn ;
7024: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7028: LD_EXP 29
7032: PPUSH
7033: LD_STRING D9a-FAr1-1
7035: PPUSH
7036: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7040: LD_EXP 19
7044: PPUSH
7045: LD_STRING D9a-JMM-1
7047: PPUSH
7048: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7052: LD_EXP 27
7056: PPUSH
7057: LD_STRING D9a2-Ar1-1
7059: PPUSH
7060: CALL_OW 88
// DialogueOff ;
7064: CALL_OW 7
// wait ( time ) ;
7068: LD_VAR 0 5
7072: PPUSH
7073: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7077: LD_VAR 0 4
7081: PPUSH
7082: CALL_OW 274
7086: PPUSH
7087: LD_INT 2
7089: PPUSH
7090: CALL_OW 275
7094: PUSH
7095: LD_INT 10
7097: LESS
7098: IFFALSE 7124
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7100: LD_EXP 27
7104: PPUSH
7105: LD_STRING D9a3-Ar1-1
7107: PPUSH
7108: CALL_OW 88
// no_oil_gain := true ;
7112: LD_ADDR_VAR 0 6
7116: PUSH
7117: LD_INT 1
7119: ST_TO_ADDR
// break ;
7120: GO 7178
// end else
7122: GO 7176
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7124: LD_EXP 28
7128: PPUSH
7129: LD_VAR 0 4
7133: PPUSH
7134: LD_INT 2
7136: PPUSH
7137: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7141: LD_EXP 28
7145: PPUSH
7146: LD_VAR 0 3
7150: PUSH
7151: LD_VAR 0 1
7155: PUSH
7156: LD_INT 3
7158: MOD
7159: PUSH
7160: LD_INT 1
7162: PLUS
7163: ARRAY
7164: PPUSH
7165: CALL_OW 210
// wait ( 0 0$10 ) ;
7169: LD_INT 350
7171: PPUSH
7172: CALL_OW 67
// end ; end ;
7176: GO 6973
7178: POP
7179: POP
// if not no_oil_gain then
7180: LD_VAR 0 6
7184: NOT
7185: IFFALSE 8322
// begin repeat wait ( 0 0$01 ) ;
7187: LD_INT 35
7189: PPUSH
7190: CALL_OW 67
// if player_attacked_ar then
7194: LD_EXP 16
7198: IFFALSE 7202
// exit ;
7200: GO 9660
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7202: LD_VAR 0 3
7206: PUSH
7207: LD_INT 1
7209: ARRAY
7210: PPUSH
7211: CALL_OW 261
7215: PUSH
7216: LD_INT 80
7218: GREATER
7219: PUSH
7220: LD_VAR 0 3
7224: PUSH
7225: LD_INT 2
7227: ARRAY
7228: PPUSH
7229: CALL_OW 261
7233: PUSH
7234: LD_INT 80
7236: GREATER
7237: AND
7238: PUSH
7239: LD_VAR 0 3
7243: PUSH
7244: LD_INT 3
7246: ARRAY
7247: PPUSH
7248: CALL_OW 261
7252: PUSH
7253: LD_INT 80
7255: GREATER
7256: AND
7257: IFFALSE 7187
// ComMoveXY ( Gali , 105 , 127 ) ;
7259: LD_EXP 28
7263: PPUSH
7264: LD_INT 105
7266: PPUSH
7267: LD_INT 127
7269: PPUSH
7270: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7274: LD_EXP 28
7278: PPUSH
7279: LD_INT 2
7281: PPUSH
7282: CALL_OW 173
// AddComHold ( Gali ) ;
7286: LD_EXP 28
7290: PPUSH
7291: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7295: LD_INT 35
7297: PPUSH
7298: CALL_OW 67
// if player_attacked_ar then
7302: LD_EXP 16
7306: IFFALSE 7310
// exit ;
7308: GO 9660
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7310: LD_EXP 28
7314: PPUSH
7315: LD_INT 105
7317: PPUSH
7318: LD_INT 127
7320: PPUSH
7321: CALL_OW 297
7325: PUSH
7326: LD_INT 4
7328: LESS
7329: IFFALSE 7295
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7331: LD_VAR 0 4
7335: PPUSH
7336: CALL_OW 274
7340: PPUSH
7341: LD_INT 1
7343: PPUSH
7344: CALL_OW 275
7348: PUSH
7349: LD_INT 50
7351: LESS
7352: IFFALSE 7654
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7354: LD_VAR 0 4
7358: PPUSH
7359: CALL_OW 274
7363: PPUSH
7364: LD_INT 1
7366: PPUSH
7367: CALL_OW 275
7371: PUSH
7372: LD_INT 0
7374: DOUBLE
7375: GREATEREQUAL
7376: IFFALSE 7384
7378: LD_INT 24
7380: DOUBLE
7381: LESSEQUAL
7382: IFTRUE 7386
7384: GO 7401
7386: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7387: LD_EXP 28
7391: PPUSH
7392: LD_STRING D9b-Ar2-1
7394: PPUSH
7395: CALL_OW 88
7399: GO 7431
7401: LD_INT 25
7403: DOUBLE
7404: GREATEREQUAL
7405: IFFALSE 7413
7407: LD_INT 49
7409: DOUBLE
7410: LESSEQUAL
7411: IFTRUE 7415
7413: GO 7430
7415: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7416: LD_EXP 28
7420: PPUSH
7421: LD_STRING D9b-Ar2-1a
7423: PPUSH
7424: CALL_OW 88
7428: GO 7431
7430: POP
// Say ( JMM , D9b-JMM-1 ) ;
7431: LD_EXP 19
7435: PPUSH
7436: LD_STRING D9b-JMM-1
7438: PPUSH
7439: CALL_OW 88
// x := 0 0$0 ;
7443: LD_ADDR_VAR 0 2
7447: PUSH
7448: LD_INT 0
7450: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7451: LD_INT 35
7453: PPUSH
7454: CALL_OW 67
// x := x + 0 0$1 ;
7458: LD_ADDR_VAR 0 2
7462: PUSH
7463: LD_VAR 0 2
7467: PUSH
7468: LD_INT 35
7470: PLUS
7471: ST_TO_ADDR
// if player_attacked_ar then
7472: LD_EXP 16
7476: IFFALSE 7480
// exit ;
7478: GO 9660
// until x >= time ;
7480: LD_VAR 0 2
7484: PUSH
7485: LD_VAR 0 5
7489: GREATEREQUAL
7490: IFFALSE 7451
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7492: LD_VAR 0 4
7496: PPUSH
7497: CALL_OW 274
7501: PPUSH
7502: LD_INT 1
7504: PPUSH
7505: CALL_OW 275
7509: PUSH
7510: LD_INT 50
7512: LESS
7513: IFFALSE 7654
// begin have_crates := false ;
7515: LD_ADDR_VAR 0 9
7519: PUSH
7520: LD_INT 0
7522: ST_TO_ADDR
// DialogueOn ;
7523: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7527: LD_EXP 27
7531: PPUSH
7532: LD_STRING D9c-Ar1-1
7534: PPUSH
7535: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7539: LD_EXP 19
7543: PPUSH
7544: LD_STRING D9c-JMM-1
7546: PPUSH
7547: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7551: LD_EXP 27
7555: PPUSH
7556: LD_STRING D9c-Ar1-2
7558: PPUSH
7559: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7563: LD_EXP 29
7567: PPUSH
7568: LD_STRING D9c-FAr1-2
7570: PPUSH
7571: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7575: LD_EXP 27
7579: PPUSH
7580: LD_STRING D9c-Ar1-3
7582: PPUSH
7583: CALL_OW 88
// case Query ( QInfo ) of 1 :
7587: LD_STRING QInfo
7589: PPUSH
7590: CALL_OW 97
7594: PUSH
7595: LD_INT 1
7597: DOUBLE
7598: EQUAL
7599: IFTRUE 7603
7601: GO 7626
7603: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7604: LD_EXP 19
7608: PPUSH
7609: LD_STRING D8b1-JMM-1
7611: PPUSH
7612: CALL_OW 88
// player_want_info := 2 ;
7616: LD_ADDR_EXP 13
7620: PUSH
7621: LD_INT 2
7623: ST_TO_ADDR
// end ; 2 :
7624: GO 7650
7626: LD_INT 2
7628: DOUBLE
7629: EQUAL
7630: IFTRUE 7634
7632: GO 7649
7634: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7635: LD_EXP 27
7639: PPUSH
7640: LD_STRING D8b2-Ar1-1
7642: PPUSH
7643: CALL_OW 88
// end ; end ;
7647: GO 7650
7649: POP
// DialogueOff ;
7650: CALL_OW 7
// end ; end ; if have_crates then
7654: LD_VAR 0 9
7658: IFFALSE 8322
// begin RemoveEnvironmentArea ( mortarArea ) ;
7660: LD_INT 2
7662: PPUSH
7663: CALL_OW 355
// wait ( 1 ) ;
7667: LD_INT 1
7669: PPUSH
7670: CALL_OW 67
// InGameOn ;
7674: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7678: LD_EXP 28
7682: PPUSH
7683: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7687: LD_EXP 28
7691: PPUSH
7692: LD_INT 1
7694: PPUSH
7695: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7699: LD_EXP 28
7703: PPUSH
7704: LD_INT 4
7706: PPUSH
7707: LD_INT 107
7709: PPUSH
7710: LD_INT 131
7712: PPUSH
7713: LD_INT 0
7715: PPUSH
7716: CALL_OW 145
// repeat wait ( 1 ) ;
7720: LD_INT 1
7722: PPUSH
7723: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7727: LD_INT 30
7729: PUSH
7730: LD_INT 4
7732: PUSH
7733: EMPTY
7734: LIST
7735: LIST
7736: PUSH
7737: LD_INT 23
7739: PUSH
7740: LD_INT 2
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: PPUSH
7751: CALL_OW 69
7755: IFFALSE 7720
// SetSide ( Gali , 2 ) ;
7757: LD_EXP 28
7761: PPUSH
7762: LD_INT 2
7764: PPUSH
7765: CALL_OW 235
// InGameOff ;
7769: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7773: LD_ADDR_VAR 0 8
7777: PUSH
7778: LD_INT 30
7780: PUSH
7781: LD_INT 4
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 23
7790: PUSH
7791: LD_INT 2
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PPUSH
7802: CALL_OW 69
7806: PUSH
7807: LD_INT 1
7809: ARRAY
7810: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7811: LD_INT 35
7813: PPUSH
7814: CALL_OW 67
// if player_attacked_ar then
7818: LD_EXP 16
7822: IFFALSE 7826
// exit ;
7824: GO 9660
// until BuildingStatus ( b ) <> bs_build ;
7826: LD_VAR 0 8
7830: PPUSH
7831: CALL_OW 461
7835: PUSH
7836: LD_INT 1
7838: NONEQUAL
7839: IFFALSE 7811
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7841: LD_VAR 0 8
7845: PPUSH
7846: CALL_OW 302
7850: PUSH
7851: LD_VAR 0 4
7855: PPUSH
7856: CALL_OW 274
7860: PPUSH
7861: LD_INT 1
7863: PPUSH
7864: CALL_OW 275
7868: PUSH
7869: LD_INT 25
7871: GREATEREQUAL
7872: AND
7873: IFFALSE 7972
// begin ComUpgrade ( b ) ;
7875: LD_VAR 0 8
7879: PPUSH
7880: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7884: LD_EXP 28
7888: PPUSH
7889: LD_STRING h
7891: PUSH
7892: LD_VAR 0 8
7896: PPUSH
7897: CALL_OW 250
7901: PUSH
7902: LD_VAR 0 8
7906: PPUSH
7907: CALL_OW 251
7911: PUSH
7912: LD_VAR 0 8
7916: PUSH
7917: LD_INT 0
7919: PUSH
7920: LD_INT 0
7922: PUSH
7923: LD_INT 0
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: LIST
7930: LIST
7931: LIST
7932: LIST
7933: LIST
7934: PUSH
7935: EMPTY
7936: LIST
7937: PPUSH
7938: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7942: LD_INT 35
7944: PPUSH
7945: CALL_OW 67
// if player_attacked_ar then
7949: LD_EXP 16
7953: IFFALSE 7957
// exit ;
7955: GO 9660
// until BuildingStatus ( b ) <> bs_build ;
7957: LD_VAR 0 8
7961: PPUSH
7962: CALL_OW 461
7966: PUSH
7967: LD_INT 1
7969: NONEQUAL
7970: IFFALSE 7942
// end ; if b then
7972: LD_VAR 0 8
7976: IFFALSE 7987
// CenterNowOnUnits ( b ) ;
7978: LD_VAR 0 8
7982: PPUSH
7983: CALL_OW 87
// DialogueOn ;
7987: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7991: LD_EXP 28
7995: PPUSH
7996: LD_STRING D9d-Ar2-1
7998: PPUSH
7999: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8003: LD_EXP 27
8007: PPUSH
8008: LD_STRING D9d-Ar1-1
8010: PPUSH
8011: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8015: LD_EXP 19
8019: PPUSH
8020: LD_STRING D9d-JMM-1
8022: PPUSH
8023: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8027: LD_EXP 27
8031: PPUSH
8032: LD_STRING D9d-Ar1-2
8034: PPUSH
8035: CALL_OW 88
// DialogueOff ;
8039: CALL_OW 7
// i := [ ] ;
8043: LD_ADDR_VAR 0 1
8047: PUSH
8048: EMPTY
8049: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8050: LD_VAR 0 4
8054: PPUSH
8055: CALL_OW 274
8059: PPUSH
8060: LD_INT 3
8062: PPUSH
8063: CALL_OW 275
8067: PUSH
8068: LD_INT 20
8070: GREATEREQUAL
8071: IFFALSE 8090
// i := i ^ [ 1 ] ;
8073: LD_ADDR_VAR 0 1
8077: PUSH
8078: LD_VAR 0 1
8082: PUSH
8083: LD_INT 1
8085: PUSH
8086: EMPTY
8087: LIST
8088: ADD
8089: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8090: LD_VAR 0 4
8094: PPUSH
8095: CALL_OW 274
8099: PPUSH
8100: LD_INT 1
8102: PPUSH
8103: CALL_OW 275
8107: PUSH
8108: LD_INT 50
8110: GREATEREQUAL
8111: IFFALSE 8130
// i := i ^ [ 2 ] ;
8113: LD_ADDR_VAR 0 1
8117: PUSH
8118: LD_VAR 0 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: EMPTY
8127: LIST
8128: ADD
8129: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8130: LD_VAR 0 4
8134: PPUSH
8135: CALL_OW 274
8139: PPUSH
8140: LD_INT 2
8142: PPUSH
8143: CALL_OW 275
8147: PUSH
8148: LD_INT 80
8150: GREATEREQUAL
8151: IFFALSE 8170
// i := i ^ [ 3 ] ;
8153: LD_ADDR_VAR 0 1
8157: PUSH
8158: LD_VAR 0 1
8162: PUSH
8163: LD_INT 3
8165: PUSH
8166: EMPTY
8167: LIST
8168: ADD
8169: ST_TO_ADDR
// i := i diff 0 ;
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 1
8179: PUSH
8180: LD_INT 0
8182: DIFF
8183: ST_TO_ADDR
// if i then
8184: LD_VAR 0 1
8188: IFFALSE 8294
// begin i := i ^ [ 4 ] ;
8190: LD_ADDR_VAR 0 1
8194: PUSH
8195: LD_VAR 0 1
8199: PUSH
8200: LD_INT 4
8202: PUSH
8203: EMPTY
8204: LIST
8205: ADD
8206: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8207: LD_STRING QInfo2
8209: PPUSH
8210: CALL_OW 97
8214: PUSH
8215: LD_INT 1
8217: DOUBLE
8218: EQUAL
8219: IFTRUE 8223
8221: GO 8234
8223: POP
// player_want_info := 3 ; 2 :
8224: LD_ADDR_EXP 13
8228: PUSH
8229: LD_INT 3
8231: ST_TO_ADDR
8232: GO 8292
8234: LD_INT 2
8236: DOUBLE
8237: EQUAL
8238: IFTRUE 8242
8240: GO 8253
8242: POP
// player_want_info := 1 ; 3 :
8243: LD_ADDR_EXP 13
8247: PUSH
8248: LD_INT 1
8250: ST_TO_ADDR
8251: GO 8292
8253: LD_INT 3
8255: DOUBLE
8256: EQUAL
8257: IFTRUE 8261
8259: GO 8272
8261: POP
// player_want_info := 2 ; 4 :
8262: LD_ADDR_EXP 13
8266: PUSH
8267: LD_INT 2
8269: ST_TO_ADDR
8270: GO 8292
8272: LD_INT 4
8274: DOUBLE
8275: EQUAL
8276: IFTRUE 8280
8278: GO 8291
8280: POP
// player_want_info := 0 ; end ;
8281: LD_ADDR_EXP 13
8285: PUSH
8286: LD_INT 0
8288: ST_TO_ADDR
8289: GO 8292
8291: POP
// end else
8292: GO 8322
// case Query ( QInfoNothing ) of 1 :
8294: LD_STRING QInfoNothing
8296: PPUSH
8297: CALL_OW 97
8301: PUSH
8302: LD_INT 1
8304: DOUBLE
8305: EQUAL
8306: IFTRUE 8310
8308: GO 8321
8310: POP
// player_want_info := 0 ; end ;
8311: LD_ADDR_EXP 13
8315: PUSH
8316: LD_INT 0
8318: ST_TO_ADDR
8319: GO 8322
8321: POP
// end ; end ; end ; if player_want_info then
8322: LD_EXP 13
8326: IFFALSE 9480
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8328: LD_ADDR_VAR 0 3
8332: PUSH
8333: LD_VAR 0 3
8337: PPUSH
8338: LD_INT 34
8340: PUSH
8341: LD_INT 32
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: PPUSH
8348: CALL_OW 72
8352: ST_TO_ADDR
// if player_want_mortar then
8353: LD_EXP 12
8357: IFFALSE 8712
// begin case player_want_info of 1 :
8359: LD_EXP 13
8363: PUSH
8364: LD_INT 1
8366: DOUBLE
8367: EQUAL
8368: IFTRUE 8372
8370: GO 8383
8372: POP
// x := 5 ; 2 :
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 5
8380: ST_TO_ADDR
8381: GO 8422
8383: LD_INT 2
8385: DOUBLE
8386: EQUAL
8387: IFTRUE 8391
8389: GO 8402
8391: POP
// x := 8 ; 3 :
8392: LD_ADDR_VAR 0 2
8396: PUSH
8397: LD_INT 8
8399: ST_TO_ADDR
8400: GO 8422
8402: LD_INT 3
8404: DOUBLE
8405: EQUAL
8406: IFTRUE 8410
8408: GO 8421
8410: POP
// x := 2 ; end ;
8411: LD_ADDR_VAR 0 2
8415: PUSH
8416: LD_INT 2
8418: ST_TO_ADDR
8419: GO 8422
8421: POP
// repeat wait ( 0 0$1 ) ;
8422: LD_INT 35
8424: PPUSH
8425: CALL_OW 67
// until not HasTask ( Gali ) ;
8429: LD_EXP 28
8433: PPUSH
8434: CALL_OW 314
8438: NOT
8439: IFFALSE 8422
// time := 0 0$00 ;
8441: LD_ADDR_VAR 0 5
8445: PUSH
8446: LD_INT 0
8448: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8449: LD_INT 35
8451: PPUSH
8452: CALL_OW 67
// time := time + 0 0$1 ;
8456: LD_ADDR_VAR 0 5
8460: PUSH
8461: LD_VAR 0 5
8465: PUSH
8466: LD_INT 35
8468: PLUS
8469: ST_TO_ADDR
// if debug then
8470: LD_EXP 2
8474: IFFALSE 8493
// debug_strings := [ time: & time ] ;
8476: LD_ADDR_OWVAR 48
8480: PUSH
8481: LD_STRING time:
8483: PUSH
8484: LD_VAR 0 5
8488: STR
8489: PUSH
8490: EMPTY
8491: LIST
8492: ST_TO_ADDR
// if time > 8 8$00 then
8493: LD_VAR 0 5
8497: PUSH
8498: LD_INT 16800
8500: GREATER
8501: IFFALSE 8513
// begin blocked := true ;
8503: LD_ADDR_EXP 18
8507: PUSH
8508: LD_INT 1
8510: ST_TO_ADDR
// exit ;
8511: GO 9660
// end ; if not Carry ( Gali ) then
8513: LD_EXP 28
8517: PPUSH
8518: CALL_OW 281
8522: NOT
8523: IFFALSE 8546
// ComTransport ( Gali , dep , player_want_info ) else
8525: LD_EXP 28
8529: PPUSH
8530: LD_VAR 0 4
8534: PPUSH
8535: LD_EXP 13
8539: PPUSH
8540: CALL_OW 151
8544: GO 8664
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8546: LD_EXP 28
8550: PPUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 1
8558: ARRAY
8559: PPUSH
8560: CALL_OW 296
8564: PUSH
8565: LD_INT 4
8567: LESS
8568: PUSH
8569: LD_EXP 28
8573: PPUSH
8574: LD_EXP 13
8578: PPUSH
8579: CALL_OW 289
8583: AND
8584: IFFALSE 8646
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8586: LD_VAR 0 3
8590: PUSH
8591: LD_INT 1
8593: ARRAY
8594: PPUSH
8595: LD_EXP 13
8599: PPUSH
8600: LD_VAR 0 3
8604: PUSH
8605: LD_INT 1
8607: ARRAY
8608: PPUSH
8609: LD_EXP 13
8613: PPUSH
8614: CALL_OW 289
8618: PUSH
8619: LD_INT 10
8621: PLUS
8622: PPUSH
8623: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8627: LD_EXP 28
8631: PPUSH
8632: LD_EXP 13
8636: PPUSH
8637: LD_INT 0
8639: PPUSH
8640: CALL_OW 290
// end else
8644: GO 8664
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8646: LD_EXP 28
8650: PPUSH
8651: LD_VAR 0 3
8655: PUSH
8656: LD_INT 1
8658: ARRAY
8659: PPUSH
8660: CALL_OW 112
// end ; if player_attacked_ar then
8664: LD_EXP 16
8668: IFFALSE 8672
// exit ;
8670: GO 9660
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: ARRAY
8680: PPUSH
8681: LD_EXP 13
8685: PPUSH
8686: CALL_OW 289
8690: PUSH
8691: LD_VAR 0 2
8695: PUSH
8696: LD_INT 10
8698: MUL
8699: GREATEREQUAL
8700: IFFALSE 8449
// no_oil_gain := false ;
8702: LD_ADDR_VAR 0 6
8706: PUSH
8707: LD_INT 0
8709: ST_TO_ADDR
// end else
8710: GO 9301
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8712: LD_ADDR_VAR 0 3
8716: PUSH
8717: LD_INT 22
8719: PUSH
8720: LD_INT 2
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PUSH
8727: LD_INT 21
8729: PUSH
8730: LD_INT 2
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: PPUSH
8741: CALL_OW 69
8745: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8746: LD_EXP 28
8750: PPUSH
8751: LD_VAR 0 4
8755: PPUSH
8756: CALL_OW 250
8760: PUSH
8761: LD_INT 1
8763: PLUS
8764: PPUSH
8765: LD_VAR 0 4
8769: PPUSH
8770: CALL_OW 251
8774: PUSH
8775: LD_INT 1
8777: PLUS
8778: PPUSH
8779: CALL_OW 111
// time := 0 0$00 ;
8783: LD_ADDR_VAR 0 5
8787: PUSH
8788: LD_INT 0
8790: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8791: LD_INT 35
8793: PPUSH
8794: CALL_OW 67
// time := time + 0 0$1 ;
8798: LD_ADDR_VAR 0 5
8802: PUSH
8803: LD_VAR 0 5
8807: PUSH
8808: LD_INT 35
8810: PLUS
8811: ST_TO_ADDR
// if time > 1 1$45 then
8812: LD_VAR 0 5
8816: PUSH
8817: LD_INT 3675
8819: GREATER
8820: IFFALSE 8824
// break ;
8822: GO 8844
// until GetDistUnits ( Gali , dep ) < 4 ;
8824: LD_EXP 28
8828: PPUSH
8829: LD_VAR 0 4
8833: PPUSH
8834: CALL_OW 296
8838: PUSH
8839: LD_INT 4
8841: LESS
8842: IFFALSE 8791
// for i = 1 to 6 do
8844: LD_ADDR_VAR 0 1
8848: PUSH
8849: DOUBLE
8850: LD_INT 1
8852: DEC
8853: ST_TO_ADDR
8854: LD_INT 6
8856: PUSH
8857: FOR_TO
8858: IFFALSE 9062
// begin if player_attacked_ar then
8860: LD_EXP 16
8864: IFFALSE 8870
// exit ;
8866: POP
8867: POP
8868: GO 9660
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8870: LD_VAR 0 4
8874: PPUSH
8875: CALL_OW 274
8879: PPUSH
8880: LD_INT 2
8882: PPUSH
8883: CALL_OW 275
8887: PUSH
8888: LD_INT 10
8890: LESS
8891: PUSH
8892: LD_VAR 0 7
8896: NOT
8897: AND
8898: IFFALSE 8961
// begin first_warn := true ;
8900: LD_ADDR_VAR 0 7
8904: PUSH
8905: LD_INT 1
8907: ST_TO_ADDR
// DialogueOn ;
8908: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8912: LD_EXP 29
8916: PPUSH
8917: LD_STRING D9a-FAr1-1
8919: PPUSH
8920: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8924: LD_EXP 19
8928: PPUSH
8929: LD_STRING D9a-JMM-1
8931: PPUSH
8932: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8936: LD_EXP 27
8940: PPUSH
8941: LD_STRING D9a2-Ar1-1
8943: PPUSH
8944: CALL_OW 88
// DialogueOff ;
8948: CALL_OW 7
// wait ( time ) ;
8952: LD_VAR 0 5
8956: PPUSH
8957: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8961: LD_VAR 0 4
8965: PPUSH
8966: CALL_OW 274
8970: PPUSH
8971: LD_INT 2
8973: PPUSH
8974: CALL_OW 275
8978: PUSH
8979: LD_INT 10
8981: LESS
8982: IFFALSE 9008
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8984: LD_EXP 27
8988: PPUSH
8989: LD_STRING D9a3-Ar1-1
8991: PPUSH
8992: CALL_OW 88
// no_oil_gain := true ;
8996: LD_ADDR_VAR 0 6
9000: PUSH
9001: LD_INT 1
9003: ST_TO_ADDR
// break ;
9004: GO 9062
// end else
9006: GO 9060
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9008: LD_EXP 28
9012: PPUSH
9013: LD_VAR 0 4
9017: PPUSH
9018: LD_INT 2
9020: PPUSH
9021: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9025: LD_EXP 28
9029: PPUSH
9030: LD_VAR 0 3
9034: PUSH
9035: LD_VAR 0 1
9039: PUSH
9040: LD_INT 3
9042: MOD
9043: PUSH
9044: LD_INT 1
9046: PLUS
9047: ARRAY
9048: PPUSH
9049: CALL_OW 210
// wait ( 0 0$10 ) ;
9053: LD_INT 350
9055: PPUSH
9056: CALL_OW 67
// end ; end ;
9060: GO 8857
9062: POP
9063: POP
// time := 0 0$00 ;
9064: LD_ADDR_VAR 0 5
9068: PUSH
9069: LD_INT 0
9071: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9072: LD_INT 35
9074: PPUSH
9075: CALL_OW 67
// if not HasTask ( Gali ) then
9079: LD_EXP 28
9083: PPUSH
9084: CALL_OW 314
9088: NOT
9089: IFFALSE 9105
// time := time + 0 0$1 ;
9091: LD_ADDR_VAR 0 5
9095: PUSH
9096: LD_VAR 0 5
9100: PUSH
9101: LD_INT 35
9103: PLUS
9104: ST_TO_ADDR
// if time > 1 1$25 then
9105: LD_VAR 0 5
9109: PUSH
9110: LD_INT 2975
9112: GREATER
9113: IFFALSE 9137
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9115: LD_EXP 27
9119: PPUSH
9120: LD_STRING D9a3-Ar1-1
9122: PPUSH
9123: CALL_OW 88
// no_oil_gain := true ;
9127: LD_ADDR_VAR 0 6
9131: PUSH
9132: LD_INT 1
9134: ST_TO_ADDR
// break ;
9135: GO 9301
// end ; if player_attacked_ar then
9137: LD_EXP 16
9141: IFFALSE 9145
// exit ;
9143: GO 9660
// for i in tmp do
9145: LD_ADDR_VAR 0 1
9149: PUSH
9150: LD_VAR 0 3
9154: PUSH
9155: FOR_IN
9156: IFFALSE 9187
// if GetFuel ( i ) < 100 then
9158: LD_VAR 0 1
9162: PPUSH
9163: CALL_OW 261
9167: PUSH
9168: LD_INT 100
9170: LESS
9171: IFFALSE 9185
// begin x := i ;
9173: LD_ADDR_VAR 0 2
9177: PUSH
9178: LD_VAR 0 1
9182: ST_TO_ADDR
// break ;
9183: GO 9187
// end ;
9185: GO 9155
9187: POP
9188: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9189: LD_EXP 28
9193: PPUSH
9194: CALL_OW 314
9198: NOT
9199: PUSH
9200: LD_EXP 28
9204: PPUSH
9205: CALL_OW 281
9209: NOT
9210: AND
9211: IFFALSE 9244
// begin ComTransport ( Gali , dep , mat_oil ) ;
9213: LD_EXP 28
9217: PPUSH
9218: LD_VAR 0 4
9222: PPUSH
9223: LD_INT 2
9225: PPUSH
9226: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9230: LD_EXP 28
9234: PPUSH
9235: LD_VAR 0 2
9239: PPUSH
9240: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9244: LD_VAR 0 3
9248: PUSH
9249: LD_INT 1
9251: ARRAY
9252: PPUSH
9253: CALL_OW 261
9257: PUSH
9258: LD_INT 80
9260: GREATER
9261: PUSH
9262: LD_VAR 0 3
9266: PUSH
9267: LD_INT 2
9269: ARRAY
9270: PPUSH
9271: CALL_OW 261
9275: PUSH
9276: LD_INT 80
9278: GREATER
9279: AND
9280: PUSH
9281: LD_VAR 0 3
9285: PUSH
9286: LD_INT 3
9288: ARRAY
9289: PPUSH
9290: CALL_OW 261
9294: PUSH
9295: LD_INT 80
9297: GREATER
9298: AND
9299: IFFALSE 9072
// end ; ComHold ( Gali ) ;
9301: LD_EXP 28
9305: PPUSH
9306: CALL_OW 140
// if not no_oil_gain then
9310: LD_VAR 0 6
9314: NOT
9315: IFFALSE 9480
// begin DialogueOn ;
9317: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9321: LD_EXP 27
9325: PPUSH
9326: CALL_OW 87
// if player_want_mortar then
9330: LD_EXP 12
9334: IFFALSE 9360
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9336: LD_EXP 27
9340: PPUSH
9341: LD_STRING D9e-Ar1-1
9343: PPUSH
9344: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9348: LD_EXP 19
9352: PPUSH
9353: LD_STRING D10a-JMM-1
9355: PPUSH
9356: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9360: LD_EXP 27
9364: PPUSH
9365: LD_STRING D10a-Ar1-1
9367: PPUSH
9368: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9372: LD_EXP 28
9376: PPUSH
9377: LD_STRING D10a-Ar2-1
9379: PPUSH
9380: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9384: LD_EXP 29
9388: PPUSH
9389: LD_STRING D10a-FAr1-1
9391: PPUSH
9392: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9396: LD_EXP 28
9400: PPUSH
9401: LD_STRING D10a-Ar2-2
9403: PPUSH
9404: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9408: LD_EXP 29
9412: PPUSH
9413: LD_STRING D10a-FAr1-2
9415: PPUSH
9416: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9420: LD_EXP 27
9424: PPUSH
9425: LD_STRING D10a-Ar1-2
9427: PPUSH
9428: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9432: LD_EXP 19
9436: PPUSH
9437: LD_STRING D10a-JMM-2
9439: PPUSH
9440: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9444: LD_EXP 27
9448: PPUSH
9449: LD_STRING D10a-Ar1-3
9451: PPUSH
9452: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9456: LD_EXP 19
9460: PPUSH
9461: LD_STRING D10a-JMM-3
9463: PPUSH
9464: CALL_OW 88
// player_get_info := true ;
9468: LD_ADDR_EXP 15
9472: PUSH
9473: LD_INT 1
9475: ST_TO_ADDR
// DialogueOff ;
9476: CALL_OW 7
// end ; end ; if player_attacked_ar then
9480: LD_EXP 16
9484: IFFALSE 9488
// exit ;
9486: GO 9660
// if player_want_mortar or player_want_info then
9488: LD_EXP 12
9492: PUSH
9493: LD_EXP 13
9497: OR
9498: IFFALSE 9512
// Say ( Vervecken , D9f-Ar1-1 ) ;
9500: LD_EXP 27
9504: PPUSH
9505: LD_STRING D9f-Ar1-1
9507: PPUSH
9508: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9512: LD_INT 22
9514: PUSH
9515: LD_INT 2
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PPUSH
9522: CALL_OW 69
9526: PPUSH
9527: LD_INT 51
9529: PPUSH
9530: LD_INT 99
9532: PPUSH
9533: CALL_OW 111
// wait ( 0 0$1 ) ;
9537: LD_INT 35
9539: PPUSH
9540: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9544: LD_INT 22
9546: PUSH
9547: LD_INT 2
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: PUSH
9554: LD_INT 92
9556: PUSH
9557: LD_INT 51
9559: PUSH
9560: LD_INT 99
9562: PUSH
9563: LD_INT 2
9565: PUSH
9566: EMPTY
9567: LIST
9568: LIST
9569: LIST
9570: LIST
9571: PUSH
9572: EMPTY
9573: LIST
9574: LIST
9575: PPUSH
9576: CALL_OW 69
9580: IFFALSE 9640
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9582: LD_ADDR_VAR 0 1
9586: PUSH
9587: LD_INT 22
9589: PUSH
9590: LD_INT 2
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 92
9599: PUSH
9600: LD_INT 51
9602: PUSH
9603: LD_INT 99
9605: PUSH
9606: LD_INT 2
9608: PUSH
9609: EMPTY
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: PPUSH
9619: CALL_OW 69
9623: PUSH
9624: FOR_IN
9625: IFFALSE 9638
// RemoveUnit ( i ) ;
9627: LD_VAR 0 1
9631: PPUSH
9632: CALL_OW 64
9636: GO 9624
9638: POP
9639: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9640: LD_INT 22
9642: PUSH
9643: LD_INT 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PPUSH
9650: CALL_OW 69
9654: PUSH
9655: LD_INT 0
9657: EQUAL
9658: IFFALSE 9512
// end ;
9660: PPOPN 9
9662: END
// every 0 0$01 trigger blocked do var i ;
9663: LD_EXP 18
9667: IFFALSE 9835
9669: GO 9671
9671: DISABLE
9672: LD_INT 0
9674: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9675: LD_EXP 27
9679: PPUSH
9680: LD_STRING D9f-Ar1-1
9682: PPUSH
9683: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9687: LD_INT 22
9689: PUSH
9690: LD_INT 2
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: PPUSH
9697: CALL_OW 69
9701: PPUSH
9702: LD_INT 51
9704: PPUSH
9705: LD_INT 99
9707: PPUSH
9708: CALL_OW 111
// wait ( 0 0$1 ) ;
9712: LD_INT 35
9714: PPUSH
9715: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9719: LD_INT 22
9721: PUSH
9722: LD_INT 2
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 92
9731: PUSH
9732: LD_INT 51
9734: PUSH
9735: LD_INT 99
9737: PUSH
9738: LD_INT 2
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: PPUSH
9751: CALL_OW 69
9755: IFFALSE 9815
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9757: LD_ADDR_VAR 0 1
9761: PUSH
9762: LD_INT 22
9764: PUSH
9765: LD_INT 2
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 92
9774: PUSH
9775: LD_INT 51
9777: PUSH
9778: LD_INT 99
9780: PUSH
9781: LD_INT 2
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: LIST
9793: PPUSH
9794: CALL_OW 69
9798: PUSH
9799: FOR_IN
9800: IFFALSE 9813
// RemoveUnit ( i ) ;
9802: LD_VAR 0 1
9806: PPUSH
9807: CALL_OW 64
9811: GO 9799
9813: POP
9814: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9815: LD_INT 22
9817: PUSH
9818: LD_INT 2
9820: PUSH
9821: EMPTY
9822: LIST
9823: LIST
9824: PPUSH
9825: CALL_OW 69
9829: PUSH
9830: LD_INT 0
9832: EQUAL
9833: IFFALSE 9687
// end ;
9835: PPOPN 1
9837: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9838: LD_EXP 16
9842: IFFALSE 10195
9844: GO 9846
9846: DISABLE
9847: LD_INT 0
9849: PPUSH
9850: PPUSH
9851: PPUSH
9852: PPUSH
// begin ru_can_attack := true ;
9853: LD_ADDR_EXP 8
9857: PUSH
9858: LD_INT 1
9860: ST_TO_ADDR
// mine_launched := false ;
9861: LD_ADDR_VAR 0 3
9865: PUSH
9866: LD_INT 0
9868: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9869: LD_INT 22
9871: PUSH
9872: LD_INT 2
9874: PUSH
9875: EMPTY
9876: LIST
9877: LIST
9878: PPUSH
9879: CALL_OW 69
9883: PPUSH
9884: LD_INT 51
9886: PPUSH
9887: LD_INT 99
9889: PPUSH
9890: CALL_OW 111
// if IsOk ( Vervecken ) then
9894: LD_EXP 27
9898: PPUSH
9899: CALL_OW 302
9903: IFFALSE 9917
// Say ( Vervecken , D11a-Ar1-1 ) ;
9905: LD_EXP 27
9909: PPUSH
9910: LD_STRING D11a-Ar1-1
9912: PPUSH
9913: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9917: LD_ADDR_VAR 0 2
9921: PUSH
9922: LD_EXP 34
9926: PPUSH
9927: LD_INT 25
9929: PUSH
9930: LD_INT 1
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: PPUSH
9937: CALL_OW 72
9941: ST_TO_ADDR
// for i in tmp do
9942: LD_ADDR_VAR 0 1
9946: PUSH
9947: LD_VAR 0 2
9951: PUSH
9952: FOR_IN
9953: IFFALSE 10016
// if MineOfUnit ( i ) then
9955: LD_VAR 0 1
9959: PPUSH
9960: CALL_OW 459
9964: IFFALSE 10014
// begin x := MineOfUnit ( i ) ;
9966: LD_ADDR_VAR 0 4
9970: PUSH
9971: LD_VAR 0 1
9975: PPUSH
9976: CALL_OW 459
9980: ST_TO_ADDR
// mine_launched := true ;
9981: LD_ADDR_VAR 0 3
9985: PUSH
9986: LD_INT 1
9988: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9989: LD_VAR 0 4
9993: PUSH
9994: LD_INT 1
9996: ARRAY
9997: PPUSH
9998: LD_VAR 0 4
10002: PUSH
10003: LD_INT 2
10005: ARRAY
10006: PPUSH
10007: LD_INT 2
10009: PPUSH
10010: CALL_OW 456
// end ;
10014: GO 9952
10016: POP
10017: POP
// if mine_launched and IsOk ( Vervecken ) then
10018: LD_VAR 0 3
10022: PUSH
10023: LD_EXP 27
10027: PPUSH
10028: CALL_OW 302
10032: AND
10033: IFFALSE 10047
// Say ( Vervecken , D11b-Ar1-1 ) ;
10035: LD_EXP 27
10039: PPUSH
10040: LD_STRING D11b-Ar1-1
10042: PPUSH
10043: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10047: LD_INT 22
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PPUSH
10057: CALL_OW 69
10061: PPUSH
10062: LD_INT 51
10064: PPUSH
10065: LD_INT 99
10067: PPUSH
10068: CALL_OW 111
// wait ( 0 0$1 ) ;
10072: LD_INT 35
10074: PPUSH
10075: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10079: LD_INT 22
10081: PUSH
10082: LD_INT 2
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: PUSH
10089: LD_INT 92
10091: PUSH
10092: LD_INT 51
10094: PUSH
10095: LD_INT 99
10097: PUSH
10098: LD_INT 2
10100: PUSH
10101: EMPTY
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: PPUSH
10111: CALL_OW 69
10115: IFFALSE 10175
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10117: LD_ADDR_VAR 0 1
10121: PUSH
10122: LD_INT 22
10124: PUSH
10125: LD_INT 2
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: PUSH
10132: LD_INT 92
10134: PUSH
10135: LD_INT 51
10137: PUSH
10138: LD_INT 99
10140: PUSH
10141: LD_INT 2
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PPUSH
10154: CALL_OW 69
10158: PUSH
10159: FOR_IN
10160: IFFALSE 10173
// RemoveUnit ( i ) ;
10162: LD_VAR 0 1
10166: PPUSH
10167: CALL_OW 64
10171: GO 10159
10173: POP
10174: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10175: LD_INT 22
10177: PUSH
10178: LD_INT 2
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: PPUSH
10185: CALL_OW 69
10189: PUSH
10190: LD_INT 0
10192: EQUAL
10193: IFFALSE 10047
// end ;
10195: PPOPN 4
10197: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10198: LD_EXP 10
10202: IFFALSE 10381
10204: GO 10206
10206: DISABLE
10207: LD_INT 0
10209: PPUSH
// begin Wait ( 10 10$00 ) ;
10210: LD_INT 21000
10212: PPUSH
10213: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10217: LD_INT 22
10219: PUSH
10220: LD_INT 2
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PPUSH
10227: CALL_OW 69
10231: IFFALSE 10381
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10233: LD_INT 22
10235: PUSH
10236: LD_INT 2
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: PPUSH
10243: CALL_OW 69
10247: PPUSH
10248: LD_INT 51
10250: PPUSH
10251: LD_INT 99
10253: PPUSH
10254: CALL_OW 114
// wait ( 0 0$1 ) ;
10258: LD_INT 35
10260: PPUSH
10261: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10265: LD_INT 22
10267: PUSH
10268: LD_INT 2
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 92
10277: PUSH
10278: LD_INT 51
10280: PUSH
10281: LD_INT 99
10283: PUSH
10284: LD_INT 2
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: PPUSH
10297: CALL_OW 69
10301: IFFALSE 10361
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10303: LD_ADDR_VAR 0 1
10307: PUSH
10308: LD_INT 22
10310: PUSH
10311: LD_INT 2
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 92
10320: PUSH
10321: LD_INT 51
10323: PUSH
10324: LD_INT 99
10326: PUSH
10327: LD_INT 2
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: PPUSH
10340: CALL_OW 69
10344: PUSH
10345: FOR_IN
10346: IFFALSE 10359
// RemoveUnit ( i ) ;
10348: LD_VAR 0 1
10352: PPUSH
10353: CALL_OW 64
10357: GO 10345
10359: POP
10360: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10361: LD_INT 22
10363: PUSH
10364: LD_INT 2
10366: PUSH
10367: EMPTY
10368: LIST
10369: LIST
10370: PPUSH
10371: CALL_OW 69
10375: PUSH
10376: LD_INT 0
10378: EQUAL
10379: IFFALSE 10233
// end ; end ;
10381: PPOPN 1
10383: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
10384: LD_EXP 4
10388: IFFALSE 11316
10390: GO 10392
10392: DISABLE
10393: LD_INT 0
10395: PPUSH
10396: PPUSH
10397: PPUSH
// begin Wait ( game_time ) ;
10398: LD_EXP 7
10402: PPUSH
10403: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10407: LD_INT 35
10409: PPUSH
10410: CALL_OW 67
// until ( not ru_can_attack ) ;
10414: LD_EXP 8
10418: NOT
10419: IFFALSE 10407
// Wait ( 0 0$35 ) ;
10421: LD_INT 1225
10423: PPUSH
10424: CALL_OW 67
// DialogueOn ;
10428: CALL_OW 6
// InGameOn ;
10432: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10436: LD_EXP 26
10440: PPUSH
10441: LD_STRING D12-Pow-1
10443: PPUSH
10444: CALL_OW 94
// InGameOff ;
10448: CALL_OW 9
// DialogueOff ;
10452: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10456: LD_STRING M4
10458: PPUSH
10459: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10463: LD_INT 5
10465: PPUSH
10466: LD_INT 1
10468: PPUSH
10469: CALL_OW 424
// can_end := true ;
10473: LD_ADDR_EXP 17
10477: PUSH
10478: LD_INT 1
10480: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10481: LD_INT 35
10483: PPUSH
10484: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10488: CALL 809 0 0
10492: PUSH
10493: LD_INT 20
10495: GREATEREQUAL
10496: PUSH
10497: LD_INT 22
10499: PUSH
10500: LD_INT 1
10502: PUSH
10503: EMPTY
10504: LIST
10505: LIST
10506: PUSH
10507: LD_INT 21
10509: PUSH
10510: LD_INT 1
10512: PUSH
10513: EMPTY
10514: LIST
10515: LIST
10516: PUSH
10517: EMPTY
10518: LIST
10519: LIST
10520: PPUSH
10521: CALL_OW 69
10525: PUSH
10526: LD_INT 5
10528: PPUSH
10529: LD_INT 22
10531: PUSH
10532: LD_INT 1
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: PUSH
10539: LD_INT 21
10541: PUSH
10542: LD_INT 1
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: PPUSH
10553: CALL_OW 70
10557: PUSH
10558: LD_INT 22
10560: PUSH
10561: LD_INT 1
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 55
10570: PUSH
10571: EMPTY
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PPUSH
10578: CALL_OW 69
10582: PLUS
10583: LESSEQUAL
10584: AND
10585: IFFALSE 10481
// if not player_get_info then
10587: LD_EXP 15
10591: NOT
10592: IFFALSE 10603
// player_get_info := - 1 ;
10594: LD_ADDR_EXP 15
10598: PUSH
10599: LD_INT 1
10601: NEG
10602: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10603: LD_STRING Information
10605: PPUSH
10606: LD_EXP 15
10610: PPUSH
10611: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10615: LD_ADDR_VAR 0 2
10619: PUSH
10620: LD_INT 22
10622: PUSH
10623: LD_INT 1
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: PUSH
10630: LD_INT 2
10632: PUSH
10633: LD_INT 25
10635: PUSH
10636: LD_INT 2
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 25
10645: PUSH
10646: LD_INT 16
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 34
10655: PUSH
10656: LD_INT 12
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PPUSH
10673: CALL_OW 69
10677: ST_TO_ADDR
// sib := GetTerminalCargo ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL 809 0 0
10687: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10688: LD_ADDR_VAR 0 3
10692: PUSH
10693: LD_VAR 0 3
10697: PUSH
10698: LD_INT 6
10700: PPUSH
10701: LD_INT 3
10703: PPUSH
10704: CALL_OW 287
10708: PLUS
10709: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10710: LD_ADDR_VAR 0 3
10714: PUSH
10715: LD_VAR 0 3
10719: PUSH
10720: LD_VAR 0 2
10724: PPUSH
10725: LD_INT 3
10727: PPUSH
10728: CALL_OW 289
10732: PLUS
10733: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10734: LD_VAR 0 3
10738: PUSH
10739: LD_INT 2
10741: PUSH
10742: LD_OWVAR 67
10746: PLUS
10747: PUSH
10748: LD_INT 50
10750: MUL
10751: LESS
10752: IFFALSE 10777
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10754: LD_STRING MuchSiberite
10756: PPUSH
10757: LD_INT 2
10759: NEG
10760: PUSH
10761: LD_OWVAR 67
10765: MUL
10766: PUSH
10767: LD_INT 1
10769: PLUS
10770: PPUSH
10771: CALL_OW 101
10775: GO 10787
// AddMedal ( MuchSiberite , 1 ) ;
10777: LD_STRING MuchSiberite
10779: PPUSH
10780: LD_INT 1
10782: PPUSH
10783: CALL_OW 101
// GiveMedals ( MAIN ) ;
10787: LD_STRING MAIN
10789: PPUSH
10790: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10794: LD_INT 22
10796: PUSH
10797: LD_INT 1
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 2
10806: PUSH
10807: LD_INT 25
10809: PUSH
10810: LD_INT 1
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: LD_INT 25
10819: PUSH
10820: LD_INT 2
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: LD_INT 25
10829: PUSH
10830: LD_INT 3
10832: PUSH
10833: EMPTY
10834: LIST
10835: LIST
10836: PUSH
10837: LD_INT 25
10839: PUSH
10840: LD_INT 4
10842: PUSH
10843: EMPTY
10844: LIST
10845: LIST
10846: PUSH
10847: LD_INT 25
10849: PUSH
10850: LD_INT 8
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: EMPTY
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PPUSH
10869: CALL_OW 69
10873: PPUSH
10874: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10878: LD_ADDR_VAR 0 2
10882: PUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 1
10888: PUSH
10889: EMPTY
10890: LIST
10891: LIST
10892: PUSH
10893: LD_INT 25
10895: PUSH
10896: LD_INT 8
10898: PUSH
10899: EMPTY
10900: LIST
10901: LIST
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: PPUSH
10907: CALL_OW 69
10911: ST_TO_ADDR
// if tmp then
10912: LD_VAR 0 2
10916: IFFALSE 10947
// for i in tmp do
10918: LD_ADDR_VAR 0 1
10922: PUSH
10923: LD_VAR 0 2
10927: PUSH
10928: FOR_IN
10929: IFFALSE 10945
// SetClass ( i , 1 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_INT 1
10938: PPUSH
10939: CALL_OW 336
10943: GO 10928
10945: POP
10946: POP
// SaveVariable ( sib , 09_sibRes ) ;
10947: LD_VAR 0 3
10951: PPUSH
10952: LD_STRING 09_sibRes
10954: PPUSH
10955: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10959: LD_EXP 15
10963: PPUSH
10964: LD_STRING 09_arInfo
10966: PPUSH
10967: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10971: LD_EXP 19
10975: PPUSH
10976: LD_EXP 1
10980: PUSH
10981: LD_STRING JMM
10983: STR
10984: PPUSH
10985: CALL_OW 38
// if IsLive ( Gary ) then
10989: LD_EXP 20
10993: PPUSH
10994: CALL_OW 300
10998: IFFALSE 11018
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11000: LD_EXP 20
11004: PPUSH
11005: LD_EXP 1
11009: PUSH
11010: LD_STRING Gary
11012: STR
11013: PPUSH
11014: CALL_OW 38
// if IsLive ( Bobby ) then
11018: LD_EXP 21
11022: PPUSH
11023: CALL_OW 300
11027: IFFALSE 11047
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11029: LD_EXP 21
11033: PPUSH
11034: LD_EXP 1
11038: PUSH
11039: LD_STRING Bobby
11041: STR
11042: PPUSH
11043: CALL_OW 38
// if IsLive ( Cyrus ) then
11047: LD_EXP 22
11051: PPUSH
11052: CALL_OW 300
11056: IFFALSE 11076
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11058: LD_EXP 22
11062: PPUSH
11063: LD_EXP 1
11067: PUSH
11068: LD_STRING Cyrus
11070: STR
11071: PPUSH
11072: CALL_OW 38
// if IsLive ( Houten ) then
11076: LD_EXP 23
11080: PPUSH
11081: CALL_OW 300
11085: IFFALSE 11105
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11087: LD_EXP 23
11091: PPUSH
11092: LD_EXP 1
11096: PUSH
11097: LD_STRING Houten
11099: STR
11100: PPUSH
11101: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11105: LD_ADDR_VAR 0 2
11109: PUSH
11110: LD_INT 22
11112: PUSH
11113: LD_INT 1
11115: PUSH
11116: EMPTY
11117: LIST
11118: LIST
11119: PUSH
11120: LD_INT 2
11122: PUSH
11123: LD_INT 25
11125: PUSH
11126: LD_INT 1
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: LD_INT 25
11135: PUSH
11136: LD_INT 2
11138: PUSH
11139: EMPTY
11140: LIST
11141: LIST
11142: PUSH
11143: LD_INT 25
11145: PUSH
11146: LD_INT 3
11148: PUSH
11149: EMPTY
11150: LIST
11151: LIST
11152: PUSH
11153: LD_INT 25
11155: PUSH
11156: LD_INT 4
11158: PUSH
11159: EMPTY
11160: LIST
11161: LIST
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: PPUSH
11174: CALL_OW 69
11178: PUSH
11179: LD_EXP 19
11183: PUSH
11184: LD_EXP 22
11188: PUSH
11189: LD_EXP 21
11193: PUSH
11194: LD_EXP 23
11198: PUSH
11199: LD_EXP 20
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: LIST
11208: LIST
11209: LIST
11210: DIFF
11211: ST_TO_ADDR
// if tmp then
11212: LD_VAR 0 2
11216: IFFALSE 11236
// SaveCharacters ( tmp , mission_prefix & others ) ;
11218: LD_VAR 0 2
11222: PPUSH
11223: LD_EXP 1
11227: PUSH
11228: LD_STRING others
11230: STR
11231: PPUSH
11232: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11236: LD_ADDR_VAR 0 2
11240: PUSH
11241: LD_INT 22
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PUSH
11251: LD_INT 2
11253: PUSH
11254: LD_INT 25
11256: PUSH
11257: LD_INT 12
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: PUSH
11264: LD_INT 25
11266: PUSH
11267: LD_INT 16
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: LIST
11278: PUSH
11279: EMPTY
11280: LIST
11281: LIST
11282: PPUSH
11283: CALL_OW 69
11287: ST_TO_ADDR
// if tmp then
11288: LD_VAR 0 2
11292: IFFALSE 11312
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11294: LD_VAR 0 2
11298: PPUSH
11299: LD_EXP 1
11303: PUSH
11304: LD_STRING apes
11306: STR
11307: PPUSH
11308: CALL_OW 38
// YouWin ;
11312: CALL_OW 103
// end ; end_of_file
11316: PPOPN 3
11318: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11319: LD_VAR 0 1
11323: PPUSH
11324: CALL_OW 266
11328: PUSH
11329: LD_INT 0
11331: EQUAL
11332: PUSH
11333: LD_EXP 3
11337: NOT
11338: AND
11339: IFFALSE 11363
// begin terminal := b ;
11341: LD_ADDR_EXP 3
11345: PUSH
11346: LD_VAR 0 1
11350: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11351: LD_EXP 3
11355: PPUSH
11356: LD_STRING terminal
11358: PPUSH
11359: CALL_OW 500
// end ; end ;
11363: PPOPN 2
11365: END
// on BuildingComplete ( b ) do var i ;
11366: LD_INT 0
11368: PPUSH
// begin if GetSide ( b ) = 3 then
11369: LD_VAR 0 1
11373: PPUSH
11374: CALL_OW 255
11378: PUSH
11379: LD_INT 3
11381: EQUAL
11382: IFFALSE 11422
// for i = 1 to 4 do
11384: LD_ADDR_VAR 0 2
11388: PUSH
11389: DOUBLE
11390: LD_INT 1
11392: DEC
11393: ST_TO_ADDR
11394: LD_INT 4
11396: PUSH
11397: FOR_TO
11398: IFFALSE 11420
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11400: LD_ADDR_EXP 37
11404: PUSH
11405: LD_EXP 37
11409: PPUSH
11410: LD_INT 1
11412: PPUSH
11413: CALL_OW 3
11417: ST_TO_ADDR
11418: GO 11397
11420: POP
11421: POP
// end ;
11422: PPOPN 2
11424: END
// on VehicleConstructed ( veh , fac ) do var i ;
11425: LD_INT 0
11427: PPUSH
// begin if GetSide ( veh ) = 3 then
11428: LD_VAR 0 1
11432: PPUSH
11433: CALL_OW 255
11437: PUSH
11438: LD_INT 3
11440: EQUAL
11441: IFFALSE 11566
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 264
11452: PUSH
11453: LD_INT 53
11455: PUSH
11456: LD_INT 52
11458: PUSH
11459: LD_INT 51
11461: PUSH
11462: EMPTY
11463: LIST
11464: LIST
11465: LIST
11466: IN
11467: NOT
11468: IFFALSE 11486
// ru_force := ru_force ^ veh ;
11470: LD_ADDR_EXP 36
11474: PUSH
11475: LD_EXP 36
11479: PUSH
11480: LD_VAR 0 1
11484: ADD
11485: ST_TO_ADDR
// for i = 1 to 4 do
11486: LD_ADDR_VAR 0 3
11490: PUSH
11491: DOUBLE
11492: LD_INT 1
11494: DEC
11495: ST_TO_ADDR
11496: LD_INT 4
11498: PUSH
11499: FOR_TO
11500: IFFALSE 11522
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11502: LD_ADDR_EXP 38
11506: PUSH
11507: LD_EXP 38
11511: PPUSH
11512: LD_INT 1
11514: PPUSH
11515: CALL_OW 3
11519: ST_TO_ADDR
11520: GO 11499
11522: POP
11523: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11524: LD_VAR 0 1
11528: PPUSH
11529: CALL_OW 264
11533: PUSH
11534: LD_INT 53
11536: EQUAL
11537: IFFALSE 11566
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11539: LD_VAR 0 1
11543: PPUSH
11544: LD_INT 7
11546: PPUSH
11547: CALL 967 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11551: LD_VAR 0 1
11555: PPUSH
11556: LD_INT 170
11558: PPUSH
11559: LD_INT 235
11561: PPUSH
11562: CALL_OW 171
// end ; end ; end ;
11566: PPOPN 3
11568: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11569: LD_VAR 0 1
11573: PUSH
11574: LD_INT 1
11576: EQUAL
11577: PUSH
11578: LD_VAR 0 2
11582: PUSH
11583: LD_INT 2
11585: EQUAL
11586: AND
11587: PUSH
11588: LD_VAR 0 1
11592: PUSH
11593: LD_INT 2
11595: EQUAL
11596: PUSH
11597: LD_VAR 0 2
11601: PUSH
11602: LD_INT 1
11604: EQUAL
11605: AND
11606: OR
11607: IFFALSE 11617
// player_attacked_ar := true ;
11609: LD_ADDR_EXP 16
11613: PUSH
11614: LD_INT 1
11616: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11617: LD_VAR 0 1
11621: PUSH
11622: LD_INT 1
11624: EQUAL
11625: PUSH
11626: LD_VAR 0 2
11630: PUSH
11631: LD_INT 4
11633: EQUAL
11634: AND
11635: PUSH
11636: LD_VAR 0 1
11640: PUSH
11641: LD_INT 4
11643: EQUAL
11644: PUSH
11645: LD_VAR 0 2
11649: PUSH
11650: LD_INT 1
11652: EQUAL
11653: AND
11654: OR
11655: IFFALSE 11664
// YouLost ( Traitor ) ;
11657: LD_STRING Traitor
11659: PPUSH
11660: CALL_OW 104
// end ;
11664: PPOPN 2
11666: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11667: LD_VAR 0 1
11671: PUSH
11672: LD_EXP 19
11676: EQUAL
11677: IFFALSE 11686
// YouLost ( JMM ) ;
11679: LD_STRING JMM
11681: PPUSH
11682: CALL_OW 104
// if un = terminal then
11686: LD_VAR 0 1
11690: PUSH
11691: LD_EXP 3
11695: EQUAL
11696: IFFALSE 11705
// YouLost ( Terminal ) ;
11698: LD_STRING Terminal
11700: PPUSH
11701: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11705: LD_VAR 0 1
11709: PUSH
11710: LD_INT 22
11712: PUSH
11713: LD_INT 3
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: LD_INT 21
11722: PUSH
11723: LD_INT 3
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PPUSH
11734: CALL_OW 69
11738: IN
11739: IFFALSE 11885
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11741: LD_VAR 0 1
11745: PPUSH
11746: CALL_OW 266
11750: PUSH
11751: LD_INT 33
11753: PUSH
11754: LD_INT 26
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: IN
11761: IFFALSE 11820
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11763: LD_ADDR_EXP 37
11767: PUSH
11768: LD_EXP 37
11772: PUSH
11773: LD_VAR 0 1
11777: PPUSH
11778: CALL_OW 266
11782: PUSH
11783: LD_VAR 0 1
11787: PPUSH
11788: CALL_OW 250
11792: PUSH
11793: LD_VAR 0 1
11797: PPUSH
11798: CALL_OW 251
11802: PUSH
11803: LD_VAR 0 1
11807: PPUSH
11808: CALL_OW 254
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: ADD
11819: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11820: LD_VAR 0 1
11824: PPUSH
11825: CALL_OW 266
11829: PUSH
11830: LD_INT 5
11832: EQUAL
11833: IFFALSE 11885
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11835: LD_ADDR_EXP 37
11839: PUSH
11840: LD_EXP 37
11844: PUSH
11845: LD_INT 4
11847: PUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: CALL_OW 250
11857: PUSH
11858: LD_VAR 0 1
11862: PPUSH
11863: CALL_OW 251
11867: PUSH
11868: LD_VAR 0 1
11872: PPUSH
11873: CALL_OW 254
11877: PUSH
11878: EMPTY
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: ADD
11884: ST_TO_ADDR
// end ; if un in ru_force then
11885: LD_VAR 0 1
11889: PUSH
11890: LD_EXP 36
11894: IN
11895: IFFALSE 11931
// begin ru_force := ru_force diff un ;
11897: LD_ADDR_EXP 36
11901: PUSH
11902: LD_EXP 36
11906: PUSH
11907: LD_VAR 0 1
11911: DIFF
11912: ST_TO_ADDR
// if ru_force = 0 then
11913: LD_EXP 36
11917: PUSH
11918: LD_INT 0
11920: EQUAL
11921: IFFALSE 11931
// ru_can_attack := false ;
11923: LD_ADDR_EXP 8
11927: PUSH
11928: LD_INT 0
11930: ST_TO_ADDR
// end ; end ; end_of_file
11931: PPOPN 1
11933: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11934: LD_EXP 5
11938: PUSH
11939: LD_EXP 6
11943: AND
11944: IFFALSE 12029
11946: GO 11948
11948: DISABLE
11949: LD_INT 0
11951: PPUSH
// begin enable ;
11952: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11953: LD_ADDR_VAR 0 1
11957: PUSH
11958: LD_INT 60
11960: PUSH
11961: CALL 809 0 0
11965: MINUS
11966: ST_TO_ADDR
// if sib < 0 then
11967: LD_VAR 0 1
11971: PUSH
11972: LD_INT 0
11974: LESS
11975: IFFALSE 11985
// sib := 0 ;
11977: LD_ADDR_VAR 0 1
11981: PUSH
11982: LD_INT 0
11984: ST_TO_ADDR
// if not debug then
11985: LD_EXP 2
11989: NOT
11990: IFFALSE 12015
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11992: LD_ADDR_OWVAR 47
11996: PUSH
11997: LD_STRING #Am09-1
11999: PUSH
12000: LD_VAR 0 1
12004: PUSH
12005: LD_EXP 6
12009: PUSH
12010: EMPTY
12011: LIST
12012: LIST
12013: LIST
12014: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12015: LD_ADDR_EXP 6
12019: PUSH
12020: LD_EXP 6
12024: PUSH
12025: LD_INT 35
12027: MINUS
12028: ST_TO_ADDR
// end ;
12029: PPOPN 1
12031: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12032: LD_EXP 6
12036: PUSH
12037: LD_INT 0
12039: EQUAL
12040: IFFALSE 12052
12042: GO 12044
12044: DISABLE
// display_strings := [ ] ;
12045: LD_ADDR_OWVAR 47
12049: PUSH
12050: EMPTY
12051: ST_TO_ADDR
12052: END
// every 1 1$35 do var i , tmp ;
12053: GO 12055
12055: DISABLE
12056: LD_INT 0
12058: PPUSH
12059: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12060: LD_ADDR_VAR 0 2
12064: PUSH
12065: LD_INT 1155
12067: PUSH
12068: LD_INT 1225
12070: PUSH
12071: LD_INT 1435
12073: PUSH
12074: EMPTY
12075: LIST
12076: LIST
12077: LIST
12078: PUSH
12079: LD_OWVAR 67
12083: ARRAY
12084: ST_TO_ADDR
// i := 0 ;
12085: LD_ADDR_VAR 0 1
12089: PUSH
12090: LD_INT 0
12092: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12093: LD_INT 1
12095: PPUSH
12096: LD_INT 5
12098: PPUSH
12099: CALL_OW 12
12103: PPUSH
12104: LD_INT 75
12106: PPUSH
12107: LD_INT 75
12109: PPUSH
12110: LD_INT 20
12112: PPUSH
12113: LD_INT 1
12115: PPUSH
12116: CALL_OW 56
// wait ( tmp ) ;
12120: LD_VAR 0 2
12124: PPUSH
12125: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12129: LD_ADDR_VAR 0 2
12133: PUSH
12134: LD_VAR 0 2
12138: PUSH
12139: LD_INT 105
12141: PPUSH
12142: LD_INT 315
12144: PPUSH
12145: CALL_OW 12
12149: PLUS
12150: ST_TO_ADDR
// i := i + 1 ;
12151: LD_ADDR_VAR 0 1
12155: PUSH
12156: LD_VAR 0 1
12160: PUSH
12161: LD_INT 1
12163: PLUS
12164: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12165: LD_VAR 0 1
12169: PUSH
12170: LD_INT 3
12172: MOD
12173: PUSH
12174: LD_INT 0
12176: EQUAL
12177: PUSH
12178: LD_EXP 4
12182: AND
12183: IFFALSE 12221
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12185: LD_INT 2
12187: PPUSH
12188: LD_INT 5
12190: PPUSH
12191: CALL_OW 12
12195: PPUSH
12196: LD_INT 8
12198: PPUSH
12199: LD_INT 1
12201: PPUSH
12202: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12206: LD_INT 665
12208: PPUSH
12209: LD_INT 735
12211: PPUSH
12212: CALL_OW 12
12216: PPUSH
12217: CALL_OW 67
// end ; until tick > game_time ;
12221: LD_OWVAR 1
12225: PUSH
12226: LD_EXP 7
12230: GREATER
12231: IFFALSE 12093
// end ; end_of_file
12233: PPOPN 2
12235: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12236: LD_INT 0
12238: PPUSH
12239: PPUSH
12240: PPUSH
12241: PPUSH
12242: PPUSH
12243: PPUSH
// x := 76 ;
12244: LD_ADDR_VAR 0 5
12248: PUSH
12249: LD_INT 76
12251: ST_TO_ADDR
// y := 147 ;
12252: LD_ADDR_VAR 0 6
12256: PUSH
12257: LD_INT 147
12259: ST_TO_ADDR
// uc_side := 2 ;
12260: LD_ADDR_OWVAR 20
12264: PUSH
12265: LD_INT 2
12267: ST_TO_ADDR
// uc_nation := 2 ;
12268: LD_ADDR_OWVAR 21
12272: PUSH
12273: LD_INT 2
12275: ST_TO_ADDR
// InitHc ;
12276: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12280: LD_INT 1
12282: PPUSH
12283: LD_INT 1
12285: PPUSH
12286: LD_INT 6
12288: PPUSH
12289: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12293: LD_ADDR_OWVAR 26
12297: PUSH
12298: LD_STRING Nicolas Vervecken
12300: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12301: LD_ADDR_OWVAR 33
12305: PUSH
12306: LD_STRING SecondCharsGal
12308: ST_TO_ADDR
// hc_face_number := 3 ;
12309: LD_ADDR_OWVAR 34
12313: PUSH
12314: LD_INT 3
12316: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12317: LD_ADDR_OWVAR 29
12321: PUSH
12322: LD_INT 11
12324: PUSH
12325: LD_INT 10
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: ST_TO_ADDR
// Vervecken := CreateHuman ;
12332: LD_ADDR_EXP 27
12336: PUSH
12337: CALL_OW 44
12341: ST_TO_ADDR
// ar_force := Vervecken ;
12342: LD_ADDR_EXP 34
12346: PUSH
12347: LD_EXP 27
12351: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12352: LD_INT 1
12354: PPUSH
12355: LD_INT 2
12357: PPUSH
12358: LD_INT 6
12360: PPUSH
12361: CALL_OW 380
// hc_name := Louis Gali ;
12365: LD_ADDR_OWVAR 26
12369: PUSH
12370: LD_STRING Louis Gali
12372: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12373: LD_ADDR_OWVAR 33
12377: PUSH
12378: LD_STRING SecondCharsGal
12380: ST_TO_ADDR
// hc_face_number := 2 ;
12381: LD_ADDR_OWVAR 34
12385: PUSH
12386: LD_INT 2
12388: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12389: LD_ADDR_OWVAR 29
12393: PUSH
12394: LD_INT 10
12396: PUSH
12397: LD_INT 11
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: ST_TO_ADDR
// Gali := CreateHuman ;
12404: LD_ADDR_EXP 28
12408: PUSH
12409: CALL_OW 44
12413: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12414: LD_ADDR_EXP 34
12418: PUSH
12419: LD_EXP 34
12423: PUSH
12424: LD_EXP 28
12428: ADD
12429: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12430: LD_INT 2
12432: PPUSH
12433: LD_INT 1
12435: PPUSH
12436: LD_INT 6
12438: PPUSH
12439: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12443: LD_ADDR_OWVAR 26
12447: PUSH
12448: LD_STRING Maria Bogdanovic
12450: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12451: LD_ADDR_OWVAR 33
12455: PUSH
12456: LD_STRING SecondCharsGal
12458: ST_TO_ADDR
// hc_face_number := 14 ;
12459: LD_ADDR_OWVAR 34
12463: PUSH
12464: LD_INT 14
12466: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12467: LD_ADDR_OWVAR 29
12471: PUSH
12472: LD_INT 12
12474: PUSH
12475: LD_INT 9
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12482: LD_ADDR_EXP 29
12486: PUSH
12487: CALL_OW 44
12491: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12492: LD_ADDR_EXP 34
12496: PUSH
12497: LD_EXP 34
12501: PUSH
12502: LD_EXP 29
12506: ADD
12507: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12508: LD_INT 1
12510: PPUSH
12511: LD_INT 3
12513: PPUSH
12514: LD_INT 6
12516: PPUSH
12517: CALL_OW 380
// hc_name = Kntor Radomr ;
12521: LD_ADDR_OWVAR 26
12525: PUSH
12526: LD_STRING Kntor Radomr
12528: ST_TO_ADDR
// hc_gallery = sandar ;
12529: LD_ADDR_OWVAR 33
12533: PUSH
12534: LD_STRING sandar
12536: ST_TO_ADDR
// hc_face_number = 12 ;
12537: LD_ADDR_OWVAR 34
12541: PUSH
12542: LD_INT 12
12544: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12545: LD_ADDR_OWVAR 29
12549: PUSH
12550: LD_INT 9
12552: PUSH
12553: LD_INT 9
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: ST_TO_ADDR
// Kantor = CreateHuman ;
12560: LD_ADDR_EXP 30
12564: PUSH
12565: CALL_OW 44
12569: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12570: LD_ADDR_EXP 34
12574: PUSH
12575: LD_EXP 34
12579: PUSH
12580: LD_EXP 30
12584: ADD
12585: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12586: LD_INT 1
12588: PPUSH
12589: LD_INT 3
12591: PPUSH
12592: LD_INT 6
12594: PPUSH
12595: CALL_OW 380
// hc_name = Herczeg Farkas ;
12599: LD_ADDR_OWVAR 26
12603: PUSH
12604: LD_STRING Herczeg Farkas
12606: ST_TO_ADDR
// hc_gallery = sandar ;
12607: LD_ADDR_OWVAR 33
12611: PUSH
12612: LD_STRING sandar
12614: ST_TO_ADDR
// hc_face_number = 28 ;
12615: LD_ADDR_OWVAR 34
12619: PUSH
12620: LD_INT 28
12622: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12623: LD_ADDR_OWVAR 29
12627: PUSH
12628: LD_INT 10
12630: PUSH
12631: LD_INT 9
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: ST_TO_ADDR
// Herczeg = CreateHuman ;
12638: LD_ADDR_EXP 31
12642: PUSH
12643: CALL_OW 44
12647: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12648: LD_ADDR_EXP 34
12652: PUSH
12653: LD_EXP 34
12657: PUSH
12658: LD_EXP 31
12662: ADD
12663: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12664: LD_INT 1
12666: PPUSH
12667: LD_INT 1
12669: PPUSH
12670: LD_INT 6
12672: PPUSH
12673: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12677: LD_ADDR_OWVAR 26
12681: PUSH
12682: LD_STRING Ronn Horntvedt
12684: ST_TO_ADDR
// hc_gallery = sandar ;
12685: LD_ADDR_OWVAR 33
12689: PUSH
12690: LD_STRING sandar
12692: ST_TO_ADDR
// hc_face_number = 29 ;
12693: LD_ADDR_OWVAR 34
12697: PUSH
12698: LD_INT 29
12700: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12701: LD_ADDR_OWVAR 29
12705: PUSH
12706: LD_INT 11
12708: PUSH
12709: LD_INT 11
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: ST_TO_ADDR
// Ronn = CreateHuman ;
12716: LD_ADDR_EXP 32
12720: PUSH
12721: CALL_OW 44
12725: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12726: LD_ADDR_EXP 34
12730: PUSH
12731: LD_EXP 34
12735: PUSH
12736: LD_EXP 32
12740: ADD
12741: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12742: LD_INT 2
12744: PPUSH
12745: LD_INT 3
12747: PPUSH
12748: LD_INT 6
12750: PPUSH
12751: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12755: LD_ADDR_OWVAR 26
12759: PUSH
12760: LD_STRING Mia D. Mathiasen
12762: ST_TO_ADDR
// hc_gallery = sandar ;
12763: LD_ADDR_OWVAR 33
12767: PUSH
12768: LD_STRING sandar
12770: ST_TO_ADDR
// hc_face_number = 31 ;
12771: LD_ADDR_OWVAR 34
12775: PUSH
12776: LD_INT 31
12778: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12779: LD_ADDR_OWVAR 29
12783: PUSH
12784: LD_INT 10
12786: PUSH
12787: LD_INT 10
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: ST_TO_ADDR
// Mia = CreateHuman ;
12794: LD_ADDR_EXP 33
12798: PUSH
12799: CALL_OW 44
12803: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12804: LD_ADDR_EXP 34
12808: PUSH
12809: LD_EXP 34
12813: PUSH
12814: LD_EXP 33
12818: ADD
12819: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12820: LD_ADDR_VAR 0 3
12824: PUSH
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 2
12832: PPUSH
12833: LD_INT 2
12835: PPUSH
12836: LD_INT 14
12838: PPUSH
12839: LD_INT 1
12841: PPUSH
12842: LD_INT 1
12844: PPUSH
12845: LD_INT 32
12847: PPUSH
12848: LD_INT 30
12850: PPUSH
12851: CALL 289 0 7
12855: ADD
12856: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
12857: LD_ADDR_VAR 0 3
12861: PUSH
12862: LD_VAR 0 3
12866: PUSH
12867: LD_INT 2
12869: PPUSH
12870: LD_INT 2
12872: PPUSH
12873: LD_INT 14
12875: PPUSH
12876: LD_INT 1
12878: PPUSH
12879: LD_INT 1
12881: PPUSH
12882: LD_INT 27
12884: PPUSH
12885: LD_INT 30
12887: PPUSH
12888: CALL 289 0 7
12892: ADD
12893: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
12894: LD_ADDR_VAR 0 3
12898: PUSH
12899: LD_VAR 0 3
12903: PUSH
12904: LD_INT 2
12906: PPUSH
12907: LD_INT 2
12909: PPUSH
12910: LD_INT 14
12912: PPUSH
12913: LD_INT 1
12915: PPUSH
12916: LD_INT 1
12918: PPUSH
12919: LD_INT 25
12921: PPUSH
12922: LD_INT 33
12924: PPUSH
12925: CALL 289 0 7
12929: ADD
12930: ST_TO_ADDR
// tmp := tmp diff 0 ;
12931: LD_ADDR_VAR 0 3
12935: PUSH
12936: LD_VAR 0 3
12940: PUSH
12941: LD_INT 0
12943: DIFF
12944: ST_TO_ADDR
// for i in ar_force do
12945: LD_ADDR_VAR 0 4
12949: PUSH
12950: LD_EXP 34
12954: PUSH
12955: FOR_IN
12956: IFFALSE 13099
// begin if GetClass ( i ) = 3 then
12958: LD_VAR 0 4
12962: PPUSH
12963: CALL_OW 257
12967: PUSH
12968: LD_INT 3
12970: EQUAL
12971: IFFALSE 13053
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12973: LD_VAR 0 3
12977: PUSH
12978: LD_INT 1
12980: ARRAY
12981: PPUSH
12982: LD_INT 1
12984: PPUSH
12985: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12989: LD_VAR 0 3
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: PPUSH
12998: LD_VAR 0 5
13002: PPUSH
13003: LD_VAR 0 6
13007: PPUSH
13008: LD_INT 0
13010: PPUSH
13011: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13015: LD_VAR 0 4
13019: PPUSH
13020: LD_VAR 0 3
13024: PUSH
13025: LD_INT 1
13027: ARRAY
13028: PPUSH
13029: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13033: LD_ADDR_VAR 0 3
13037: PUSH
13038: LD_VAR 0 3
13042: PPUSH
13043: LD_INT 1
13045: PPUSH
13046: CALL_OW 3
13050: ST_TO_ADDR
// end else
13051: GO 13075
// PlaceUnitXY ( i , x , y , false ) ;
13053: LD_VAR 0 4
13057: PPUSH
13058: LD_VAR 0 5
13062: PPUSH
13063: LD_VAR 0 6
13067: PPUSH
13068: LD_INT 0
13070: PPUSH
13071: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13075: LD_VAR 0 4
13079: PPUSH
13080: LD_INT 86
13082: PPUSH
13083: LD_INT 121
13085: PPUSH
13086: CALL_OW 111
// wait ( 0 0$2 ) ;
13090: LD_INT 70
13092: PPUSH
13093: CALL_OW 67
// end ;
13097: GO 12955
13099: POP
13100: POP
// ar_force := ar_force ^ tmp ;
13101: LD_ADDR_EXP 34
13105: PUSH
13106: LD_EXP 34
13110: PUSH
13111: LD_VAR 0 3
13115: ADD
13116: ST_TO_ADDR
// ar_spawned := true ;
13117: LD_ADDR_EXP 11
13121: PUSH
13122: LD_INT 1
13124: ST_TO_ADDR
// end ; end_of_file
13125: LD_VAR 0 1
13129: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13130: LD_INT 0
13132: PPUSH
13133: PPUSH
13134: PPUSH
13135: PPUSH
13136: PPUSH
13137: PPUSH
13138: PPUSH
// InitHc ;
13139: CALL_OW 19
// uc_side := 3 ;
13143: LD_ADDR_OWVAR 20
13147: PUSH
13148: LD_INT 3
13150: ST_TO_ADDR
// uc_nation := 3 ;
13151: LD_ADDR_OWVAR 21
13155: PUSH
13156: LD_INT 3
13158: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13159: LD_ADDR_VAR 0 5
13163: PUSH
13164: LD_INT 5
13166: PUSH
13167: LD_INT 6
13169: PUSH
13170: LD_INT 7
13172: PUSH
13173: EMPTY
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: LD_OWVAR 67
13182: ARRAY
13183: ST_TO_ADDR
// ru_force := [ ] ;
13184: LD_ADDR_EXP 36
13188: PUSH
13189: EMPTY
13190: ST_TO_ADDR
// ru_rebuild := [ ] ;
13191: LD_ADDR_EXP 37
13195: PUSH
13196: EMPTY
13197: ST_TO_ADDR
// ru_produce_list := [ ] ;
13198: LD_ADDR_EXP 38
13202: PUSH
13203: EMPTY
13204: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13205: LD_ADDR_VAR 0 6
13209: PUSH
13210: LD_INT 22
13212: PUSH
13213: LD_INT 3
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: LD_INT 30
13222: PUSH
13223: LD_INT 8
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: PUSH
13230: EMPTY
13231: LIST
13232: LIST
13233: PPUSH
13234: CALL_OW 69
13238: PUSH
13239: LD_INT 1
13241: ARRAY
13242: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13243: LD_ADDR_VAR 0 4
13247: PUSH
13248: LD_INT 43
13250: PUSH
13251: LD_INT 46
13253: PUSH
13254: LD_INT 45
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13262: LD_ADDR_VAR 0 7
13266: PUSH
13267: LD_INT 22
13269: PUSH
13270: LD_INT 3
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: PUSH
13277: LD_INT 30
13279: PUSH
13280: LD_INT 1
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: PUSH
13287: EMPTY
13288: LIST
13289: LIST
13290: PPUSH
13291: CALL_OW 69
13295: PUSH
13296: LD_INT 1
13298: ARRAY
13299: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13300: LD_VAR 0 7
13304: PPUSH
13305: CALL_OW 274
13309: PPUSH
13310: LD_INT 1
13312: PPUSH
13313: LD_INT 5000
13315: PPUSH
13316: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13320: LD_VAR 0 7
13324: PPUSH
13325: CALL_OW 274
13329: PPUSH
13330: LD_INT 2
13332: PPUSH
13333: LD_INT 1000
13335: PPUSH
13336: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13340: LD_VAR 0 7
13344: PPUSH
13345: CALL_OW 274
13349: PPUSH
13350: LD_INT 3
13352: PPUSH
13353: LD_INT 30
13355: PPUSH
13356: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13360: LD_ADDR_VAR 0 2
13364: PUSH
13365: LD_INT 22
13367: PUSH
13368: LD_INT 3
13370: PUSH
13371: EMPTY
13372: LIST
13373: LIST
13374: PUSH
13375: LD_INT 30
13377: PUSH
13378: LD_INT 33
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: PPUSH
13389: CALL_OW 69
13393: PUSH
13394: FOR_IN
13395: IFFALSE 13427
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13397: LD_VAR 0 2
13401: PPUSH
13402: LD_VAR 0 4
13406: PUSH
13407: LD_VAR 0 2
13411: PUSH
13412: LD_INT 3
13414: MOD
13415: PUSH
13416: LD_INT 1
13418: PLUS
13419: ARRAY
13420: PPUSH
13421: CALL_OW 431
// end ;
13425: GO 13394
13427: POP
13428: POP
// for i = 1 to 4 do
13429: LD_ADDR_VAR 0 2
13433: PUSH
13434: DOUBLE
13435: LD_INT 1
13437: DEC
13438: ST_TO_ADDR
13439: LD_INT 4
13441: PUSH
13442: FOR_TO
13443: IFFALSE 13504
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13445: LD_INT 0
13447: PPUSH
13448: LD_INT 9
13450: PPUSH
13451: LD_VAR 0 5
13455: PPUSH
13456: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13460: CALL_OW 44
13464: PPUSH
13465: LD_INT 22
13467: PUSH
13468: LD_INT 3
13470: PUSH
13471: EMPTY
13472: LIST
13473: LIST
13474: PUSH
13475: LD_INT 30
13477: PUSH
13478: LD_INT 5
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PPUSH
13489: CALL_OW 69
13493: PUSH
13494: LD_INT 1
13496: ARRAY
13497: PPUSH
13498: CALL_OW 52
// end ;
13502: GO 13442
13504: POP
13505: POP
// for i = 1 to 5 do
13506: LD_ADDR_VAR 0 2
13510: PUSH
13511: DOUBLE
13512: LD_INT 1
13514: DEC
13515: ST_TO_ADDR
13516: LD_INT 5
13518: PUSH
13519: FOR_TO
13520: IFFALSE 13581
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13522: LD_INT 0
13524: PPUSH
13525: LD_INT 3
13527: PPUSH
13528: LD_VAR 0 5
13532: PPUSH
13533: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13537: CALL_OW 44
13541: PPUSH
13542: LD_INT 22
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: LD_INT 30
13554: PUSH
13555: LD_INT 3
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PPUSH
13566: CALL_OW 69
13570: PUSH
13571: LD_INT 1
13573: ARRAY
13574: PPUSH
13575: CALL_OW 52
// end ;
13579: GO 13519
13581: POP
13582: POP
// for i = 1 to 4 do
13583: LD_ADDR_VAR 0 2
13587: PUSH
13588: DOUBLE
13589: LD_INT 1
13591: DEC
13592: ST_TO_ADDR
13593: LD_INT 4
13595: PUSH
13596: FOR_TO
13597: IFFALSE 13658
// begin PrepareHuman ( false , class_engineer , skill ) ;
13599: LD_INT 0
13601: PPUSH
13602: LD_INT 2
13604: PPUSH
13605: LD_VAR 0 5
13609: PPUSH
13610: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13614: CALL_OW 44
13618: PPUSH
13619: LD_INT 22
13621: PUSH
13622: LD_INT 3
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: PUSH
13629: LD_INT 30
13631: PUSH
13632: LD_INT 1
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: PPUSH
13643: CALL_OW 69
13647: PUSH
13648: LD_INT 1
13650: ARRAY
13651: PPUSH
13652: CALL_OW 52
// end ;
13656: GO 13596
13658: POP
13659: POP
// for i = 1 to 3 do
13660: LD_ADDR_VAR 0 2
13664: PUSH
13665: DOUBLE
13666: LD_INT 1
13668: DEC
13669: ST_TO_ADDR
13670: LD_INT 3
13672: PUSH
13673: FOR_TO
13674: IFFALSE 13707
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13676: LD_INT 0
13678: PPUSH
13679: LD_INT 4
13681: PPUSH
13682: LD_VAR 0 5
13686: PPUSH
13687: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13691: CALL_OW 44
13695: PPUSH
13696: LD_VAR 0 6
13700: PPUSH
13701: CALL_OW 52
// end ;
13705: GO 13673
13707: POP
13708: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13709: LD_ADDR_EXP 35
13713: PUSH
13714: LD_STRING Yakotich
13716: PPUSH
13717: LD_EXP 2
13721: NOT
13722: PPUSH
13723: LD_STRING 
13725: PPUSH
13726: CALL 226 0 3
13730: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13731: LD_EXP 35
13735: PPUSH
13736: LD_INT 74
13738: PPUSH
13739: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13743: LD_VAR 0 6
13747: PPUSH
13748: LD_INT 49
13750: PPUSH
13751: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13755: LD_VAR 0 6
13759: PPUSH
13760: LD_INT 50
13762: PPUSH
13763: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13767: LD_VAR 0 6
13771: PPUSH
13772: LD_INT 51
13774: PPUSH
13775: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13779: LD_VAR 0 6
13783: PPUSH
13784: LD_INT 52
13786: PPUSH
13787: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13791: LD_VAR 0 6
13795: PPUSH
13796: LD_INT 69
13798: PPUSH
13799: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13803: LD_VAR 0 6
13807: PPUSH
13808: LD_INT 39
13810: PPUSH
13811: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13815: LD_VAR 0 6
13819: PPUSH
13820: LD_INT 34
13822: PPUSH
13823: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13827: LD_VAR 0 6
13831: PPUSH
13832: LD_INT 40
13834: PPUSH
13835: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13839: LD_VAR 0 6
13843: PPUSH
13844: LD_INT 57
13846: PPUSH
13847: CALL_OW 184
// if Difficulty > 1 then
13851: LD_OWVAR 67
13855: PUSH
13856: LD_INT 1
13858: GREATER
13859: IFFALSE 13873
// AddComResearch ( lab , tech_comp2 ) ;
13861: LD_VAR 0 6
13865: PPUSH
13866: LD_INT 58
13868: PPUSH
13869: CALL_OW 184
// end ;
13873: LD_VAR 0 1
13877: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13878: LD_INT 7
13880: PPUSH
13881: CALL_OW 353
13885: PUSH
13886: LD_INT 3
13888: GREATER
13889: PUSH
13890: LD_INT 22
13892: PUSH
13893: LD_INT 3
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: LD_INT 34
13902: PUSH
13903: LD_INT 53
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PPUSH
13914: CALL_OW 69
13918: NOT
13919: AND
13920: IFFALSE 13955
13922: GO 13924
13924: DISABLE
// begin enable ;
13925: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13926: LD_ADDR_EXP 38
13930: PUSH
13931: LD_EXP 38
13935: PUSH
13936: LD_INT 24
13938: PUSH
13939: LD_INT 1
13941: PUSH
13942: LD_INT 3
13944: PUSH
13945: LD_INT 53
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: ADD
13954: ST_TO_ADDR
// end ;
13955: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 3
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: IFFALSE 14762
13986: GO 13988
13988: DISABLE
13989: LD_INT 0
13991: PPUSH
13992: PPUSH
13993: PPUSH
13994: PPUSH
13995: PPUSH
13996: PPUSH
13997: PPUSH
13998: PPUSH
// begin enable ;
13999: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14000: LD_ADDR_VAR 0 3
14004: PUSH
14005: LD_INT 22
14007: PUSH
14008: LD_INT 3
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PUSH
14015: LD_INT 21
14017: PUSH
14018: LD_INT 3
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: PUSH
14025: LD_INT 3
14027: PUSH
14028: LD_INT 24
14030: PUSH
14031: LD_INT 1000
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: LD_INT 22
14059: PUSH
14060: LD_INT 3
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: PUSH
14067: LD_INT 25
14069: PUSH
14070: LD_INT 2
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: PPUSH
14081: CALL_OW 69
14085: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14086: LD_ADDR_VAR 0 5
14090: PUSH
14091: LD_INT 22
14093: PUSH
14094: LD_INT 3
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: PUSH
14101: LD_INT 30
14103: PUSH
14104: LD_INT 1
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: PUSH
14111: EMPTY
14112: LIST
14113: LIST
14114: PPUSH
14115: CALL_OW 69
14119: PUSH
14120: LD_INT 1
14122: ARRAY
14123: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14124: LD_ADDR_VAR 0 8
14128: PUSH
14129: LD_INT 22
14131: PUSH
14132: LD_INT 3
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PUSH
14139: LD_INT 2
14141: PUSH
14142: LD_INT 30
14144: PUSH
14145: LD_INT 6
14147: PUSH
14148: EMPTY
14149: LIST
14150: LIST
14151: PUSH
14152: LD_INT 30
14154: PUSH
14155: LD_INT 7
14157: PUSH
14158: EMPTY
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 30
14164: PUSH
14165: LD_INT 8
14167: PUSH
14168: EMPTY
14169: LIST
14170: LIST
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: PPUSH
14182: CALL_OW 69
14186: PUSH
14187: LD_INT 1
14189: ARRAY
14190: ST_TO_ADDR
// if not engs then
14191: LD_VAR 0 4
14195: NOT
14196: IFFALSE 14200
// exit ;
14198: GO 14762
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 4
14209: PPUSH
14210: LD_INT 3
14212: PUSH
14213: LD_INT 24
14215: PUSH
14216: LD_INT 600
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 72
14231: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14232: LD_ADDR_VAR 0 7
14236: PUSH
14237: LD_INT 22
14239: PUSH
14240: LD_INT 3
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 25
14249: PUSH
14250: LD_INT 4
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PPUSH
14261: CALL_OW 69
14265: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14266: LD_VAR 0 3
14270: NOT
14271: PUSH
14272: LD_EXP 37
14276: NOT
14277: AND
14278: IFFALSE 14338
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14280: LD_VAR 0 4
14284: PPUSH
14285: LD_INT 3
14287: PUSH
14288: LD_INT 54
14290: PUSH
14291: EMPTY
14292: LIST
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: PPUSH
14298: CALL_OW 72
14302: IFFALSE 14336
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14304: LD_VAR 0 4
14308: PPUSH
14309: LD_INT 3
14311: PUSH
14312: LD_INT 54
14314: PUSH
14315: EMPTY
14316: LIST
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: PPUSH
14322: CALL_OW 72
14326: PPUSH
14327: LD_VAR 0 5
14331: PPUSH
14332: CALL_OW 120
// exit ;
14336: GO 14762
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14338: LD_VAR 0 4
14342: PPUSH
14343: LD_INT 54
14345: PUSH
14346: EMPTY
14347: LIST
14348: PPUSH
14349: CALL_OW 72
14353: IFFALSE 14375
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14355: LD_VAR 0 4
14359: PPUSH
14360: LD_INT 54
14362: PUSH
14363: EMPTY
14364: LIST
14365: PPUSH
14366: CALL_OW 72
14370: PPUSH
14371: CALL_OW 122
// if not tmp then
14375: LD_VAR 0 3
14379: NOT
14380: IFFALSE 14512
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14382: LD_INT 81
14384: PUSH
14385: LD_INT 3
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PUSH
14392: LD_INT 92
14394: PUSH
14395: LD_INT 147
14397: PUSH
14398: LD_INT 212
14400: PUSH
14401: LD_INT 30
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PPUSH
14414: CALL_OW 69
14418: NOT
14419: IFFALSE 14512
// begin if not HasTask ( engs [ 1 ] ) then
14421: LD_VAR 0 4
14425: PUSH
14426: LD_INT 1
14428: ARRAY
14429: PPUSH
14430: CALL_OW 314
14434: NOT
14435: IFFALSE 14512
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14437: LD_ADDR_VAR 0 2
14441: PUSH
14442: LD_VAR 0 4
14446: PPUSH
14447: LD_EXP 37
14451: PUSH
14452: LD_INT 1
14454: ARRAY
14455: PPUSH
14456: LD_EXP 37
14460: PUSH
14461: LD_INT 2
14463: ARRAY
14464: PPUSH
14465: LD_EXP 37
14469: PUSH
14470: LD_INT 3
14472: ARRAY
14473: PPUSH
14474: LD_EXP 37
14478: PUSH
14479: LD_INT 4
14481: ARRAY
14482: PPUSH
14483: CALL_OW 145
14487: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14488: LD_VAR 0 2
14492: PPUSH
14493: CALL_OW 266
14497: PUSH
14498: LD_INT 4
14500: EQUAL
14501: IFFALSE 14512
// AddComUpgrade ( i ) ;
14503: LD_VAR 0 2
14507: PPUSH
14508: CALL_OW 206
// end ; end ; end ; for i in engs do
14512: LD_ADDR_VAR 0 2
14516: PUSH
14517: LD_VAR 0 4
14521: PUSH
14522: FOR_IN
14523: IFFALSE 14641
// begin if i in to_heal and sci then
14525: LD_VAR 0 2
14529: PUSH
14530: LD_VAR 0 6
14534: IN
14535: PUSH
14536: LD_VAR 0 7
14540: AND
14541: IFFALSE 14592
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14543: LD_VAR 0 2
14547: PPUSH
14548: LD_INT 149
14550: PPUSH
14551: LD_INT 220
14553: PPUSH
14554: CALL_OW 297
14558: PUSH
14559: LD_INT 5
14561: LESS
14562: IFFALSE 14566
// continue ;
14564: GO 14522
// ComMoveXY ( i , 149 , 220 ) ;
14566: LD_VAR 0 2
14570: PPUSH
14571: LD_INT 149
14573: PPUSH
14574: LD_INT 220
14576: PPUSH
14577: CALL_OW 111
// AddComHold ( i ) ;
14581: LD_VAR 0 2
14585: PPUSH
14586: CALL_OW 200
// end else
14590: GO 14639
// if not HasTask ( i ) or WantsToAttack ( i ) then
14592: LD_VAR 0 2
14596: PPUSH
14597: CALL_OW 314
14601: NOT
14602: PUSH
14603: LD_VAR 0 2
14607: PPUSH
14608: CALL_OW 319
14612: OR
14613: IFFALSE 14639
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14615: LD_VAR 0 2
14619: PPUSH
14620: LD_VAR 0 3
14624: PPUSH
14625: LD_VAR 0 2
14629: PPUSH
14630: CALL_OW 74
14634: PPUSH
14635: CALL_OW 130
// end ;
14639: GO 14522
14641: POP
14642: POP
// if to_heal and sci then
14643: LD_VAR 0 6
14647: PUSH
14648: LD_VAR 0 7
14652: AND
14653: IFFALSE 14714
// begin if UnitFilter ( sci , [ f_inside ] ) then
14655: LD_VAR 0 7
14659: PPUSH
14660: LD_INT 54
14662: PUSH
14663: EMPTY
14664: LIST
14665: PPUSH
14666: CALL_OW 72
14670: IFFALSE 14694
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14672: LD_VAR 0 7
14676: PPUSH
14677: LD_INT 54
14679: PUSH
14680: EMPTY
14681: LIST
14682: PPUSH
14683: CALL_OW 72
14687: PPUSH
14688: CALL_OW 122
14692: GO 14712
// ComHeal ( sci , to_heal [ 1 ] ) ;
14694: LD_VAR 0 7
14698: PPUSH
14699: LD_VAR 0 6
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: CALL_OW 128
// end else
14712: GO 14762
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14714: LD_VAR 0 7
14718: PPUSH
14719: LD_INT 56
14721: PUSH
14722: EMPTY
14723: LIST
14724: PPUSH
14725: CALL_OW 72
14729: PUSH
14730: LD_VAR 0 8
14734: AND
14735: IFFALSE 14762
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14737: LD_VAR 0 7
14741: PPUSH
14742: LD_INT 56
14744: PUSH
14745: EMPTY
14746: LIST
14747: PPUSH
14748: CALL_OW 72
14752: PPUSH
14753: LD_VAR 0 8
14757: PPUSH
14758: CALL_OW 120
// end ;
14762: PPOPN 8
14764: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14765: LD_INT 22
14767: PUSH
14768: LD_INT 3
14770: PUSH
14771: EMPTY
14772: LIST
14773: LIST
14774: PUSH
14775: LD_INT 30
14777: PUSH
14778: LD_INT 3
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PPUSH
14789: CALL_OW 69
14793: PUSH
14794: LD_EXP 38
14798: AND
14799: IFFALSE 14925
14801: GO 14803
14803: DISABLE
14804: LD_INT 0
14806: PPUSH
14807: PPUSH
14808: PPUSH
// begin enable ;
14809: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14810: LD_ADDR_VAR 0 3
14814: PUSH
14815: LD_INT 22
14817: PUSH
14818: LD_INT 3
14820: PUSH
14821: EMPTY
14822: LIST
14823: LIST
14824: PUSH
14825: LD_INT 30
14827: PUSH
14828: LD_INT 3
14830: PUSH
14831: EMPTY
14832: LIST
14833: LIST
14834: PUSH
14835: EMPTY
14836: LIST
14837: LIST
14838: PPUSH
14839: CALL_OW 69
14843: PUSH
14844: LD_INT 1
14846: ARRAY
14847: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14848: LD_VAR 0 3
14852: PPUSH
14853: CALL_OW 313
14857: PUSH
14858: LD_INT 0
14860: EQUAL
14861: IFFALSE 14865
// exit ;
14863: GO 14925
// if BuildingStatus ( fac ) = bs_idle then
14865: LD_VAR 0 3
14869: PPUSH
14870: CALL_OW 461
14874: PUSH
14875: LD_INT 2
14877: EQUAL
14878: IFFALSE 14925
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14880: LD_VAR 0 3
14884: PPUSH
14885: LD_EXP 38
14889: PUSH
14890: LD_INT 1
14892: ARRAY
14893: PPUSH
14894: LD_EXP 38
14898: PUSH
14899: LD_INT 2
14901: ARRAY
14902: PPUSH
14903: LD_EXP 38
14907: PUSH
14908: LD_INT 3
14910: ARRAY
14911: PPUSH
14912: LD_EXP 38
14916: PUSH
14917: LD_INT 4
14919: ARRAY
14920: PPUSH
14921: CALL_OW 125
// end ;
14925: PPOPN 3
14927: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14928: LD_INT 0
14930: PPUSH
14931: PPUSH
14932: PPUSH
14933: PPUSH
14934: PPUSH
// uc_side := 3 ;
14935: LD_ADDR_OWVAR 20
14939: PUSH
14940: LD_INT 3
14942: ST_TO_ADDR
// uc_nation := 3 ;
14943: LD_ADDR_OWVAR 21
14947: PUSH
14948: LD_INT 3
14950: ST_TO_ADDR
// ru_can_attack := false ;
14951: LD_ADDR_EXP 8
14955: PUSH
14956: LD_INT 0
14958: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14959: LD_ADDR_VAR 0 6
14963: PUSH
14964: LD_INT 22
14966: PUSH
14967: LD_INT 3
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PUSH
14974: LD_INT 30
14976: PUSH
14977: LD_INT 3
14979: PUSH
14980: EMPTY
14981: LIST
14982: LIST
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PPUSH
14988: CALL_OW 69
14992: ST_TO_ADDR
// if fac then
14993: LD_VAR 0 6
14997: IFFALSE 15149
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14999: LD_ADDR_EXP 38
15003: PUSH
15004: LD_INT 24
15006: PUSH
15007: LD_INT 1
15009: PUSH
15010: LD_INT 3
15012: PUSH
15013: LD_INT 43
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: ST_TO_ADDR
// if wave > 1 then
15022: LD_VAR 0 1
15026: PUSH
15027: LD_INT 1
15029: GREATER
15030: IFFALSE 15083
// for i = 1 to Difficulty do
15032: LD_ADDR_VAR 0 3
15036: PUSH
15037: DOUBLE
15038: LD_INT 1
15040: DEC
15041: ST_TO_ADDR
15042: LD_OWVAR 67
15046: PUSH
15047: FOR_TO
15048: IFFALSE 15081
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15050: LD_ADDR_EXP 38
15054: PUSH
15055: LD_EXP 38
15059: PUSH
15060: LD_INT 24
15062: PUSH
15063: LD_INT 1
15065: PUSH
15066: LD_INT 3
15068: PUSH
15069: LD_INT 45
15071: PUSH
15072: EMPTY
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: ADD
15078: ST_TO_ADDR
15079: GO 15047
15081: POP
15082: POP
// repeat wait ( 0 0$1 ) ;
15083: LD_INT 35
15085: PPUSH
15086: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15090: LD_EXP 38
15094: PUSH
15095: LD_INT 4
15097: LESS
15098: PUSH
15099: LD_VAR 0 6
15103: PUSH
15104: LD_INT 1
15106: ARRAY
15107: PPUSH
15108: CALL_OW 313
15112: PUSH
15113: LD_INT 0
15115: EQUAL
15116: OR
15117: PUSH
15118: LD_VAR 0 6
15122: PUSH
15123: LD_INT 1
15125: ARRAY
15126: PPUSH
15127: CALL_OW 461
15131: PUSH
15132: LD_INT 8
15134: PUSH
15135: LD_INT 6
15137: PUSH
15138: LD_INT 7
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: LIST
15145: IN
15146: OR
15147: IFFALSE 15083
// end ; case wave of 1 :
15149: LD_VAR 0 1
15153: PUSH
15154: LD_INT 1
15156: DOUBLE
15157: EQUAL
15158: IFTRUE 15162
15160: GO 15247
15162: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
15163: LD_ADDR_VAR 0 3
15167: PUSH
15168: DOUBLE
15169: LD_INT 1
15171: DEC
15172: ST_TO_ADDR
15173: LD_INT 3
15175: PUSH
15176: LD_INT 4
15178: PUSH
15179: LD_INT 5
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: LIST
15186: PUSH
15187: LD_OWVAR 67
15191: ARRAY
15192: PUSH
15193: FOR_TO
15194: IFFALSE 15202
// Sold ;
15196: CALL 15473 0 0
15200: GO 15193
15202: POP
15203: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15204: LD_ADDR_VAR 0 3
15208: PUSH
15209: DOUBLE
15210: LD_INT 1
15212: DEC
15213: ST_TO_ADDR
15214: LD_INT 2
15216: PUSH
15217: LD_INT 3
15219: PUSH
15220: LD_INT 3
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: LIST
15227: PUSH
15228: LD_OWVAR 67
15232: ARRAY
15233: PUSH
15234: FOR_TO
15235: IFFALSE 15243
// Tank ;
15237: CALL 15603 0 0
15241: GO 15234
15243: POP
15244: POP
// end ; 2 .. 9 :
15245: GO 15460
15247: LD_INT 2
15249: DOUBLE
15250: GREATEREQUAL
15251: IFFALSE 15259
15253: LD_INT 9
15255: DOUBLE
15256: LESSEQUAL
15257: IFTRUE 15261
15259: GO 15366
15261: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: DOUBLE
15268: LD_INT 1
15270: DEC
15271: ST_TO_ADDR
15272: LD_INT 3
15274: PUSH
15275: LD_INT 4
15277: PUSH
15278: LD_INT 5
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: LIST
15285: PUSH
15286: LD_OWVAR 67
15290: ARRAY
15291: PUSH
15292: LD_VAR 0 1
15296: PUSH
15297: LD_INT 2
15299: DIV
15300: PLUS
15301: PUSH
15302: FOR_TO
15303: IFFALSE 15311
// Sold ;
15305: CALL 15473 0 0
15309: GO 15302
15311: POP
15312: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15313: LD_ADDR_VAR 0 3
15317: PUSH
15318: DOUBLE
15319: LD_INT 1
15321: DEC
15322: ST_TO_ADDR
15323: LD_INT 2
15325: PUSH
15326: LD_INT 3
15328: PUSH
15329: LD_INT 3
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: LIST
15336: PUSH
15337: LD_OWVAR 67
15341: ARRAY
15342: PUSH
15343: LD_VAR 0 1
15347: PUSH
15348: LD_INT 2
15350: DIV
15351: PLUS
15352: PUSH
15353: FOR_TO
15354: IFFALSE 15362
// Tank ;
15356: CALL 15603 0 0
15360: GO 15353
15362: POP
15363: POP
// end ; 10 :
15364: GO 15460
15366: LD_INT 10
15368: DOUBLE
15369: EQUAL
15370: IFTRUE 15374
15372: GO 15459
15374: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15375: LD_ADDR_VAR 0 3
15379: PUSH
15380: DOUBLE
15381: LD_INT 1
15383: DEC
15384: ST_TO_ADDR
15385: LD_INT 10
15387: PUSH
15388: LD_INT 12
15390: PUSH
15391: LD_INT 14
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: LIST
15398: PUSH
15399: LD_OWVAR 67
15403: ARRAY
15404: PUSH
15405: FOR_TO
15406: IFFALSE 15414
// Sold ;
15408: CALL 15473 0 0
15412: GO 15405
15414: POP
15415: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15416: LD_ADDR_VAR 0 3
15420: PUSH
15421: DOUBLE
15422: LD_INT 1
15424: DEC
15425: ST_TO_ADDR
15426: LD_INT 11
15428: PUSH
15429: LD_INT 13
15431: PUSH
15432: LD_INT 15
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: LIST
15439: PUSH
15440: LD_OWVAR 67
15444: ARRAY
15445: PUSH
15446: FOR_TO
15447: IFFALSE 15455
// Tank ;
15449: CALL 15603 0 0
15453: GO 15446
15455: POP
15456: POP
// end ; end ;
15457: GO 15460
15459: POP
// ru_can_attack := true ;
15460: LD_ADDR_EXP 8
15464: PUSH
15465: LD_INT 1
15467: ST_TO_ADDR
// end ;
15468: LD_VAR 0 2
15472: RET
// function Sold ( ) ; var un , skill ; begin
15473: LD_INT 0
15475: PPUSH
15476: PPUSH
15477: PPUSH
// uc_side := 3 ;
15478: LD_ADDR_OWVAR 20
15482: PUSH
15483: LD_INT 3
15485: ST_TO_ADDR
// uc_nation := 3 ;
15486: LD_ADDR_OWVAR 21
15490: PUSH
15491: LD_INT 3
15493: ST_TO_ADDR
// InitHc ;
15494: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15498: LD_ADDR_VAR 0 3
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: LD_INT 7
15508: PUSH
15509: LD_INT 7
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: LIST
15516: PUSH
15517: LD_OWVAR 67
15521: ARRAY
15522: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15523: LD_INT 0
15525: PPUSH
15526: LD_INT 1
15528: PUSH
15529: LD_INT 9
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PUSH
15536: LD_INT 1
15538: PPUSH
15539: LD_INT 2
15541: PPUSH
15542: CALL_OW 12
15546: ARRAY
15547: PPUSH
15548: LD_VAR 0 3
15552: PPUSH
15553: CALL_OW 380
// un := CreateHuman ;
15557: LD_ADDR_VAR 0 2
15561: PUSH
15562: CALL_OW 44
15566: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15567: LD_VAR 0 2
15571: PPUSH
15572: LD_INT 4
15574: PPUSH
15575: LD_INT 0
15577: PPUSH
15578: CALL_OW 49
// ru_force := ru_force ^ un ;
15582: LD_ADDR_EXP 36
15586: PUSH
15587: LD_EXP 36
15591: PUSH
15592: LD_VAR 0 2
15596: ADD
15597: ST_TO_ADDR
// end ;
15598: LD_VAR 0 1
15602: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15603: LD_INT 0
15605: PPUSH
15606: PPUSH
15607: PPUSH
15608: PPUSH
15609: PPUSH
// uc_side := 3 ;
15610: LD_ADDR_OWVAR 20
15614: PUSH
15615: LD_INT 3
15617: ST_TO_ADDR
// uc_nation := 3 ;
15618: LD_ADDR_OWVAR 21
15622: PUSH
15623: LD_INT 3
15625: ST_TO_ADDR
// InitHc ;
15626: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15630: LD_ADDR_VAR 0 5
15634: PUSH
15635: LD_INT 5
15637: PUSH
15638: LD_INT 6
15640: PUSH
15641: LD_INT 7
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: LIST
15648: PUSH
15649: LD_OWVAR 67
15653: ARRAY
15654: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15655: LD_ADDR_VAR 0 3
15659: PUSH
15660: LD_INT 22
15662: PUSH
15663: LD_INT 24
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PUSH
15670: LD_INT 1
15672: PPUSH
15673: LD_INT 2
15675: PPUSH
15676: CALL_OW 12
15680: ARRAY
15681: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15682: LD_VAR 0 3
15686: PUSH
15687: LD_INT 22
15689: EQUAL
15690: IFFALSE 15725
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15692: LD_ADDR_VAR 0 4
15696: PUSH
15697: LD_INT 45
15699: PUSH
15700: LD_INT 43
15702: PUSH
15703: LD_INT 44
15705: PUSH
15706: EMPTY
15707: LIST
15708: LIST
15709: LIST
15710: PUSH
15711: LD_INT 1
15713: PPUSH
15714: LD_INT 3
15716: PPUSH
15717: CALL_OW 12
15721: ARRAY
15722: ST_TO_ADDR
15723: GO 15756
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15725: LD_ADDR_VAR 0 4
15729: PUSH
15730: LD_INT 46
15732: PUSH
15733: LD_INT 44
15735: PUSH
15736: LD_INT 45
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: LIST
15743: PUSH
15744: LD_INT 1
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: CALL_OW 12
15754: ARRAY
15755: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15756: LD_ADDR_VAR 0 2
15760: PUSH
15761: LD_INT 3
15763: PPUSH
15764: LD_INT 3
15766: PPUSH
15767: LD_VAR 0 3
15771: PPUSH
15772: LD_INT 1
15774: PPUSH
15775: LD_INT 3
15777: PUSH
15778: LD_INT 3
15780: PUSH
15781: LD_INT 3
15783: PUSH
15784: LD_INT 1
15786: PUSH
15787: EMPTY
15788: LIST
15789: LIST
15790: LIST
15791: LIST
15792: PUSH
15793: LD_INT 1
15795: PPUSH
15796: LD_INT 4
15798: PPUSH
15799: CALL_OW 12
15803: ARRAY
15804: PPUSH
15805: LD_VAR 0 4
15809: PPUSH
15810: LD_INT 99
15812: PPUSH
15813: CALL 289 0 7
15817: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15818: LD_VAR 0 2
15822: PPUSH
15823: CALL_OW 263
15827: PUSH
15828: LD_INT 1
15830: EQUAL
15831: IFFALSE 15862
// begin PrepareHuman ( false , 3 , skill ) ;
15833: LD_INT 0
15835: PPUSH
15836: LD_INT 3
15838: PPUSH
15839: LD_VAR 0 5
15843: PPUSH
15844: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15848: CALL_OW 44
15852: PPUSH
15853: LD_VAR 0 2
15857: PPUSH
15858: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15862: LD_VAR 0 2
15866: PPUSH
15867: LD_INT 3
15869: PPUSH
15870: LD_INT 0
15872: PPUSH
15873: CALL_OW 49
// ru_force := ru_force ^ un ;
15877: LD_ADDR_EXP 36
15881: PUSH
15882: LD_EXP 36
15886: PUSH
15887: LD_VAR 0 2
15891: ADD
15892: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15893: LD_VAR 0 2
15897: PPUSH
15898: LD_INT 126
15900: PPUSH
15901: LD_INT 158
15903: PPUSH
15904: CALL_OW 111
// Wait ( 0 0$3 ) ;
15908: LD_INT 105
15910: PPUSH
15911: CALL_OW 67
// ComStop ( un ) ;
15915: LD_VAR 0 2
15919: PPUSH
15920: CALL_OW 141
// end ;
15924: LD_VAR 0 1
15928: RET
// every 0 0$1 do var i , time , wave ;
15929: GO 15931
15931: DISABLE
15932: LD_INT 0
15934: PPUSH
15935: PPUSH
15936: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15937: LD_ADDR_VAR 0 2
15941: PUSH
15942: LD_INT 25200
15944: PUSH
15945: LD_INT 24150
15947: PUSH
15948: LD_INT 23100
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: LIST
15955: PUSH
15956: LD_OWVAR 67
15960: ARRAY
15961: ST_TO_ADDR
// wait ( time ) ;
15962: LD_VAR 0 2
15966: PPUSH
15967: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
15971: LD_ADDR_VAR 0 2
15975: PUSH
15976: LD_INT 15750
15978: PUSH
15979: LD_INT 15400
15981: PUSH
15982: LD_INT 15050
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: LIST
15989: PUSH
15990: LD_OWVAR 67
15994: ARRAY
15995: ST_TO_ADDR
// wave := 0 ;
15996: LD_ADDR_VAR 0 3
16000: PUSH
16001: LD_INT 0
16003: ST_TO_ADDR
// while true do
16004: LD_INT 1
16006: IFFALSE 16110
// begin wave := wave + 1 ;
16008: LD_ADDR_VAR 0 3
16012: PUSH
16013: LD_VAR 0 3
16017: PUSH
16018: LD_INT 1
16020: PLUS
16021: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16022: LD_INT 22
16024: PUSH
16025: LD_INT 2
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PPUSH
16032: CALL_OW 69
16036: IFFALSE 16072
// begin repeat wait ( 0 0$1 ) ;
16038: LD_INT 35
16040: PPUSH
16041: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16045: LD_INT 22
16047: PUSH
16048: LD_INT 2
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: PPUSH
16055: CALL_OW 69
16059: PUSH
16060: LD_INT 0
16062: EQUAL
16063: IFFALSE 16038
// wait ( 1 1$30 ) ;
16065: LD_INT 3150
16067: PPUSH
16068: CALL_OW 67
// end ; if ru_force < 20 then
16072: LD_EXP 36
16076: PUSH
16077: LD_INT 20
16079: LESS
16080: IFFALSE 16091
// PrepareAttack ( wave ) ;
16082: LD_VAR 0 3
16086: PPUSH
16087: CALL 14928 0 1
// ru_can_attack := true ;
16091: LD_ADDR_EXP 8
16095: PUSH
16096: LD_INT 1
16098: ST_TO_ADDR
// wait ( time ) ;
16099: LD_VAR 0 2
16103: PPUSH
16104: CALL_OW 67
// end ;
16108: GO 16004
// end ;
16110: PPOPN 3
16112: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16113: LD_EXP 8
16117: PUSH
16118: LD_EXP 36
16122: AND
16123: IFFALSE 16957
16125: GO 16127
16127: DISABLE
16128: LD_INT 0
16130: PPUSH
16131: PPUSH
16132: PPUSH
16133: PPUSH
16134: PPUSH
16135: PPUSH
16136: PPUSH
16137: PPUSH
16138: PPUSH
// begin enable ;
16139: ENABLE
// points1 := [ 107 , 123 ] ;
16140: LD_ADDR_VAR 0 4
16144: PUSH
16145: LD_INT 107
16147: PUSH
16148: LD_INT 123
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16155: LD_ADDR_VAR 0 5
16159: PUSH
16160: LD_INT 55
16162: PUSH
16163: LD_INT 42
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16170: LD_ADDR_VAR 0 6
16174: PUSH
16175: LD_INT 102
16177: PUSH
16178: LD_INT 140
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: PUSH
16185: LD_INT 105
16187: PUSH
16188: LD_INT 142
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PUSH
16195: LD_INT 129
16197: PUSH
16198: LD_INT 131
16200: PUSH
16201: EMPTY
16202: LIST
16203: LIST
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: LIST
16209: ST_TO_ADDR
// for i in ru_force do
16210: LD_ADDR_VAR 0 1
16214: PUSH
16215: LD_EXP 36
16219: PUSH
16220: FOR_IN
16221: IFFALSE 16955
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16223: LD_ADDR_VAR 0 3
16227: PUSH
16228: LD_INT 81
16230: PUSH
16231: LD_INT 3
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PPUSH
16238: CALL_OW 69
16242: PPUSH
16243: LD_VAR 0 1
16247: PPUSH
16248: CALL_OW 74
16252: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16253: LD_VAR 0 1
16257: PPUSH
16258: LD_VAR 0 3
16262: PPUSH
16263: CALL_OW 296
16267: PUSH
16268: LD_INT 12
16270: LESS
16271: IFFALSE 16416
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16273: LD_VAR 0 1
16277: PPUSH
16278: CALL_OW 247
16282: PUSH
16283: LD_INT 1
16285: EQUAL
16286: PUSH
16287: LD_VAR 0 1
16291: PPUSH
16292: CALL_OW 257
16296: PUSH
16297: LD_INT 1
16299: EQUAL
16300: AND
16301: PUSH
16302: LD_VAR 0 3
16306: PUSH
16307: LD_INT 21
16309: PUSH
16310: LD_INT 2
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PUSH
16317: LD_INT 58
16319: PUSH
16320: EMPTY
16321: LIST
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PPUSH
16327: CALL_OW 69
16331: IN
16332: AND
16333: IFFALSE 16351
// ComEnterUnit ( i , un ) else
16335: LD_VAR 0 1
16339: PPUSH
16340: LD_VAR 0 3
16344: PPUSH
16345: CALL_OW 120
16349: GO 16414
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16351: LD_VAR 0 3
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 2
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 58
16368: PUSH
16369: EMPTY
16370: LIST
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PPUSH
16376: CALL_OW 69
16380: IN
16381: NOT
16382: IFFALSE 16400
// ComAttackUnit ( i , un ) else
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_VAR 0 3
16393: PPUSH
16394: CALL_OW 115
16398: GO 16414
// ComAttackUnit ( i , JMM ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_EXP 19
16409: PPUSH
16410: CALL_OW 115
// end else
16414: GO 16953
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16416: LD_VAR 0 1
16420: PPUSH
16421: LD_VAR 0 4
16425: PUSH
16426: LD_INT 1
16428: ARRAY
16429: PPUSH
16430: LD_VAR 0 4
16434: PUSH
16435: LD_INT 2
16437: ARRAY
16438: PPUSH
16439: CALL_OW 297
16443: PUSH
16444: LD_VAR 0 1
16448: PPUSH
16449: LD_VAR 0 5
16453: PUSH
16454: LD_INT 1
16456: ARRAY
16457: PPUSH
16458: LD_VAR 0 5
16462: PUSH
16463: LD_INT 2
16465: ARRAY
16466: PPUSH
16467: CALL_OW 297
16471: GREATER
16472: PUSH
16473: LD_EXP 9
16477: AND
16478: PUSH
16479: LD_INT 9
16481: PPUSH
16482: LD_INT 81
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PPUSH
16492: CALL_OW 70
16496: PUSH
16497: LD_INT 0
16499: EQUAL
16500: OR
16501: IFFALSE 16539
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16503: LD_VAR 0 1
16507: PPUSH
16508: LD_INT 81
16510: PUSH
16511: LD_INT 3
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PPUSH
16518: CALL_OW 69
16522: PPUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: CALL_OW 74
16532: PPUSH
16533: CALL_OW 115
16537: GO 16953
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16539: LD_VAR 0 1
16543: PPUSH
16544: CALL_OW 264
16548: PUSH
16549: LD_INT 45
16551: EQUAL
16552: PUSH
16553: LD_EXP 36
16557: PPUSH
16558: LD_INT 3
16560: PUSH
16561: LD_INT 34
16563: PUSH
16564: LD_INT 45
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 72
16579: PUSH
16580: LD_INT 6
16582: GREATER
16583: AND
16584: IFFALSE 16765
// begin dist := 9999 ;
16586: LD_ADDR_VAR 0 8
16590: PUSH
16591: LD_INT 9999
16593: ST_TO_ADDR
// xy := 0 ;
16594: LD_ADDR_VAR 0 9
16598: PUSH
16599: LD_INT 0
16601: ST_TO_ADDR
// for x in pointsr do
16602: LD_ADDR_VAR 0 7
16606: PUSH
16607: LD_VAR 0 6
16611: PUSH
16612: FOR_IN
16613: IFFALSE 16761
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16615: LD_VAR 0 1
16619: PPUSH
16620: LD_VAR 0 7
16624: PUSH
16625: LD_INT 1
16627: ARRAY
16628: PPUSH
16629: LD_VAR 0 7
16633: PUSH
16634: LD_INT 2
16636: ARRAY
16637: PPUSH
16638: CALL_OW 297
16642: PUSH
16643: LD_VAR 0 8
16647: LESS
16648: IFFALSE 16693
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16650: LD_ADDR_VAR 0 8
16654: PUSH
16655: LD_VAR 0 1
16659: PPUSH
16660: LD_VAR 0 7
16664: PUSH
16665: LD_INT 1
16667: ARRAY
16668: PPUSH
16669: LD_VAR 0 7
16673: PUSH
16674: LD_INT 2
16676: ARRAY
16677: PPUSH
16678: CALL_OW 297
16682: ST_TO_ADDR
// xy := x ;
16683: LD_ADDR_VAR 0 9
16687: PUSH
16688: LD_VAR 0 7
16692: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16693: LD_VAR 0 9
16697: PUSH
16698: LD_VAR 0 1
16702: PPUSH
16703: LD_VAR 0 9
16707: PUSH
16708: LD_INT 1
16710: ARRAY
16711: PPUSH
16712: LD_VAR 0 9
16716: PUSH
16717: LD_INT 2
16719: ARRAY
16720: PPUSH
16721: CALL_OW 297
16725: PUSH
16726: LD_INT 9
16728: GREATER
16729: AND
16730: IFFALSE 16759
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_VAR 0 9
16741: PUSH
16742: LD_INT 1
16744: ARRAY
16745: PPUSH
16746: LD_VAR 0 9
16750: PUSH
16751: LD_INT 2
16753: ARRAY
16754: PPUSH
16755: CALL_OW 114
// end ;
16759: GO 16612
16761: POP
16762: POP
// end else
16763: GO 16953
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16765: LD_ADDR_VAR 0 3
16769: PUSH
16770: LD_OWVAR 3
16774: PUSH
16775: LD_VAR 0 1
16779: DIFF
16780: PPUSH
16781: LD_VAR 0 1
16785: PPUSH
16786: CALL_OW 74
16790: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16791: LD_VAR 0 1
16795: PPUSH
16796: CALL_OW 320
16800: NOT
16801: PUSH
16802: LD_VAR 0 3
16806: PUSH
16807: LD_INT 21
16809: PUSH
16810: LD_INT 2
16812: PUSH
16813: EMPTY
16814: LIST
16815: LIST
16816: PUSH
16817: LD_INT 33
16819: PUSH
16820: LD_INT 1
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: PUSH
16827: LD_INT 58
16829: PUSH
16830: EMPTY
16831: LIST
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: LIST
16837: PPUSH
16838: CALL_OW 69
16842: IN
16843: PUSH
16844: LD_VAR 0 3
16848: PUSH
16849: LD_INT 22
16851: PUSH
16852: LD_INT 3
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: PUSH
16859: LD_INT 21
16861: PUSH
16862: LD_INT 2
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: PUSH
16869: LD_INT 3
16871: PUSH
16872: LD_INT 24
16874: PUSH
16875: LD_INT 249
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: LIST
16890: PPUSH
16891: CALL_OW 69
16895: IN
16896: OR
16897: AND
16898: IFFALSE 16916
// ComAttackUnit ( i , un ) else
16900: LD_VAR 0 1
16904: PPUSH
16905: LD_VAR 0 3
16909: PPUSH
16910: CALL_OW 115
16914: GO 16953
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16916: LD_VAR 0 1
16920: PPUSH
16921: LD_INT 9
16923: PPUSH
16924: LD_INT 81
16926: PUSH
16927: LD_INT 3
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: PPUSH
16934: CALL_OW 70
16938: PPUSH
16939: LD_VAR 0 1
16943: PPUSH
16944: CALL_OW 74
16948: PPUSH
16949: CALL_OW 115
// end ; end ; end ; end ;
16953: GO 16220
16955: POP
16956: POP
// end ;
16957: PPOPN 9
16959: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16960: LD_INT 22
16962: PUSH
16963: LD_INT 3
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: PUSH
16970: LD_INT 32
16972: PUSH
16973: LD_INT 1
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PPUSH
16984: CALL_OW 69
16988: IFFALSE 17076
16990: GO 16992
16992: DISABLE
16993: LD_INT 0
16995: PPUSH
16996: PPUSH
// begin enable ;
16997: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16998: LD_ADDR_VAR 0 2
17002: PUSH
17003: LD_INT 22
17005: PUSH
17006: LD_INT 3
17008: PUSH
17009: EMPTY
17010: LIST
17011: LIST
17012: PUSH
17013: LD_INT 32
17015: PUSH
17016: LD_INT 1
17018: PUSH
17019: EMPTY
17020: LIST
17021: LIST
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PPUSH
17027: CALL_OW 69
17031: ST_TO_ADDR
// for i in tmp do
17032: LD_ADDR_VAR 0 1
17036: PUSH
17037: LD_VAR 0 2
17041: PUSH
17042: FOR_IN
17043: IFFALSE 17074
// if GetFuel ( i ) < 12 then
17045: LD_VAR 0 1
17049: PPUSH
17050: CALL_OW 261
17054: PUSH
17055: LD_INT 12
17057: LESS
17058: IFFALSE 17072
// SetFuel ( i , 12 ) ;
17060: LD_VAR 0 1
17064: PPUSH
17065: LD_INT 12
17067: PPUSH
17068: CALL_OW 240
17072: GO 17042
17074: POP
17075: POP
// end ;
17076: PPOPN 2
17078: END
// every 0 0$1 trigger can_end do
17079: LD_EXP 17
17083: IFFALSE 17106
17085: GO 17087
17087: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17088: LD_INT 3325
17090: PPUSH
17091: CALL_OW 67
// PrepareAttack ( 10 ) ;
17095: LD_INT 10
17097: PPUSH
17098: CALL 14928 0 1
// until false ;
17102: LD_INT 0
17104: IFFALSE 17088
// end ;
17106: END
