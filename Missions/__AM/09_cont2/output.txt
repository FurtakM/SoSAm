// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 202 0 0
// PrepareNature ;
  16: CALL 377 0 0
// PrepareRussian ;
  20: CALL 13240 0 0
// PrepareAmerican ;
  24: CALL 1110 0 0
// PrepareOvsyenko ;
  28: CALL 1733 0 0
// Action ;
  32: CALL 2673 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: PUSH
  92: LD_INT 105000
  94: PUSH
  95: LD_INT 111300
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: LIST
 102: PUSH
 103: LD_OWVAR 67
 107: ARRAY
 108: ST_TO_ADDR
// ru_can_attack := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// ar_can_arrive := false ;
 125: LD_ADDR_EXP 10
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// ar_spawned := false ;
 133: LD_ADDR_EXP 11
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// player_want_mortar := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// player_want_info := false ;
 149: LD_ADDR_EXP 13
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// player_get_mortar := false ;
 157: LD_ADDR_EXP 14
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// player_get_info := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// player_attacked_ar := false ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// can_end := false ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// blocked := false ;
 189: LD_ADDR_EXP 18
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// end ;
 197: LD_VAR 0 1
 201: RET
// function DebugMode ; begin
 202: LD_INT 0
 204: PPUSH
// if not debug then
 205: LD_EXP 2
 209: NOT
 210: IFFALSE 214
// exit ;
 212: GO 221
// FogOff ( 1 ) ;
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 344
// end ; end_of_file
 221: LD_VAR 0 1
 225: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
// if exist_mode then
 230: LD_VAR 0 2
 234: IFFALSE 259
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_VAR 0 3
 245: PUSH
 246: LD_VAR 0 1
 250: STR
 251: PPUSH
 252: CALL_OW 34
 256: ST_TO_ADDR
 257: GO 274
// unit := NewCharacter ( ident ) ;
 259: LD_ADDR_VAR 0 5
 263: PUSH
 264: LD_VAR 0 1
 268: PPUSH
 269: CALL_OW 25
 273: ST_TO_ADDR
// result := unit ;
 274: LD_ADDR_VAR 0 4
 278: PUSH
 279: LD_VAR 0 5
 283: ST_TO_ADDR
// end ;
 284: LD_VAR 0 4
 288: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 289: LD_INT 0
 291: PPUSH
// uc_side := side ;
 292: LD_ADDR_OWVAR 20
 296: PUSH
 297: LD_VAR 0 1
 301: ST_TO_ADDR
// uc_nation := nation ;
 302: LD_ADDR_OWVAR 21
 306: PUSH
 307: LD_VAR 0 2
 311: ST_TO_ADDR
// vc_chassis := chassis ;
 312: LD_ADDR_OWVAR 37
 316: PUSH
 317: LD_VAR 0 3
 321: ST_TO_ADDR
// vc_engine := engine ;
 322: LD_ADDR_OWVAR 39
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// vc_control := control ;
 332: LD_ADDR_OWVAR 38
 336: PUSH
 337: LD_VAR 0 5
 341: ST_TO_ADDR
// vc_weapon := weapon ;
 342: LD_ADDR_OWVAR 40
 346: PUSH
 347: LD_VAR 0 6
 351: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 352: LD_ADDR_OWVAR 41
 356: PUSH
 357: LD_VAR 0 7
 361: ST_TO_ADDR
// result := CreateVehicle ;
 362: LD_ADDR_VAR 0 8
 366: PUSH
 367: CALL_OW 45
 371: ST_TO_ADDR
// end ;
 372: LD_VAR 0 8
 376: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 377: LD_INT 0
 379: PPUSH
 380: PPUSH
 381: PPUSH
 382: PPUSH
// uc_side = 0 ;
 383: LD_ADDR_OWVAR 20
 387: PUSH
 388: LD_INT 0
 390: ST_TO_ADDR
// uc_nation = 0 ;
 391: LD_ADDR_OWVAR 21
 395: PUSH
 396: LD_INT 0
 398: ST_TO_ADDR
// nat_area := natureArea ;
 399: LD_ADDR_VAR 0 4
 403: PUSH
 404: LD_INT 1
 406: ST_TO_ADDR
// InitHc ;
 407: CALL_OW 19
// for i = 1 to 4 do
 411: LD_ADDR_VAR 0 2
 415: PUSH
 416: DOUBLE
 417: LD_INT 1
 419: DEC
 420: ST_TO_ADDR
 421: LD_INT 4
 423: PUSH
 424: FOR_TO
 425: IFFALSE 480
// begin hc_class = 18 ;
 427: LD_ADDR_OWVAR 28
 431: PUSH
 432: LD_INT 18
 434: ST_TO_ADDR
// hc_gallery =  ;
 435: LD_ADDR_OWVAR 33
 439: PUSH
 440: LD_STRING 
 442: ST_TO_ADDR
// hc_face_number = 1 ;
 443: LD_ADDR_OWVAR 34
 447: PUSH
 448: LD_INT 1
 450: ST_TO_ADDR
// animal := CreateHuman ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: CALL_OW 44
 460: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 461: LD_VAR 0 3
 465: PPUSH
 466: LD_VAR 0 4
 470: PPUSH
 471: LD_INT 0
 473: PPUSH
 474: CALL_OW 49
// end ;
 478: GO 424
 480: POP
 481: POP
// for i = 1 to 4 do
 482: LD_ADDR_VAR 0 2
 486: PUSH
 487: DOUBLE
 488: LD_INT 1
 490: DEC
 491: ST_TO_ADDR
 492: LD_INT 4
 494: PUSH
 495: FOR_TO
 496: IFFALSE 568
// begin hc_class = class_tiger ;
 498: LD_ADDR_OWVAR 28
 502: PUSH
 503: LD_INT 14
 505: ST_TO_ADDR
// hc_gallery =  ;
 506: LD_ADDR_OWVAR 33
 510: PUSH
 511: LD_STRING 
 513: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 514: LD_ADDR_OWVAR 35
 518: PUSH
 519: LD_INT 5
 521: NEG
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL_OW 12
 530: ST_TO_ADDR
// hc_face_number = 3 ;
 531: LD_ADDR_OWVAR 34
 535: PUSH
 536: LD_INT 3
 538: ST_TO_ADDR
// animal := CreateHuman ;
 539: LD_ADDR_VAR 0 3
 543: PUSH
 544: CALL_OW 44
 548: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 549: LD_VAR 0 3
 553: PPUSH
 554: LD_VAR 0 4
 558: PPUSH
 559: LD_INT 0
 561: PPUSH
 562: CALL_OW 49
// end ;
 566: GO 495
 568: POP
 569: POP
// for i = 1 to 8 do
 570: LD_ADDR_VAR 0 2
 574: PUSH
 575: DOUBLE
 576: LD_INT 1
 578: DEC
 579: ST_TO_ADDR
 580: LD_INT 8
 582: PUSH
 583: FOR_TO
 584: IFFALSE 687
// begin hc_class = class_apeman ;
 586: LD_ADDR_OWVAR 28
 590: PUSH
 591: LD_INT 12
 593: ST_TO_ADDR
// hc_gallery =  ;
 594: LD_ADDR_OWVAR 33
 598: PUSH
 599: LD_STRING 
 601: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 602: LD_ADDR_OWVAR 35
 606: PUSH
 607: LD_INT 2
 609: NEG
 610: PPUSH
 611: LD_INT 2
 613: PPUSH
 614: CALL_OW 12
 618: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 619: LD_ADDR_OWVAR 31
 623: PUSH
 624: LD_INT 1
 626: PPUSH
 627: LD_INT 3
 629: PPUSH
 630: CALL_OW 12
 634: PUSH
 635: LD_INT 1
 637: PPUSH
 638: LD_INT 3
 640: PPUSH
 641: CALL_OW 12
 645: PUSH
 646: LD_INT 0
 648: PUSH
 649: LD_INT 0
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: LIST
 657: ST_TO_ADDR
// animal := CreateHuman ;
 658: LD_ADDR_VAR 0 3
 662: PUSH
 663: CALL_OW 44
 667: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 668: LD_VAR 0 3
 672: PPUSH
 673: LD_VAR 0 4
 677: PPUSH
 678: LD_INT 0
 680: PPUSH
 681: CALL_OW 49
// end ;
 685: GO 583
 687: POP
 688: POP
// for i = 1 to 6 do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: DOUBLE
 695: LD_INT 1
 697: DEC
 698: ST_TO_ADDR
 699: LD_INT 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 758
// begin hc_class = 13 ;
 705: LD_ADDR_OWVAR 28
 709: PUSH
 710: LD_INT 13
 712: ST_TO_ADDR
// hc_gallery =  ;
 713: LD_ADDR_OWVAR 33
 717: PUSH
 718: LD_STRING 
 720: ST_TO_ADDR
// hc_face_number = 4 ;
 721: LD_ADDR_OWVAR 34
 725: PUSH
 726: LD_INT 4
 728: ST_TO_ADDR
// animal := CreateHuman ;
 729: LD_ADDR_VAR 0 3
 733: PUSH
 734: CALL_OW 44
 738: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 739: LD_VAR 0 3
 743: PPUSH
 744: LD_VAR 0 4
 748: PPUSH
 749: LD_INT 0
 751: PPUSH
 752: CALL_OW 49
// end ;
 756: GO 702
 758: POP
 759: POP
// vc_chassis := 31 ;
 760: LD_ADDR_OWVAR 37
 764: PUSH
 765: LD_INT 31
 767: ST_TO_ADDR
// vc_control := control_rider ;
 768: LD_ADDR_OWVAR 38
 772: PUSH
 773: LD_INT 4
 775: ST_TO_ADDR
// animal := CreateVehicle ;
 776: LD_ADDR_VAR 0 3
 780: PUSH
 781: CALL_OW 45
 785: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 786: LD_VAR 0 3
 790: PPUSH
 791: LD_INT 21
 793: PPUSH
 794: LD_INT 22
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 48
// end ;
 804: LD_VAR 0 1
 808: RET
// export function GetTerminalCargo ; begin
 809: LD_INT 0
 811: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 812: LD_ADDR_VAR 0 1
 816: PUSH
 817: LD_EXP 3
 821: PPUSH
 822: CALL_OW 274
 826: PPUSH
 827: LD_INT 3
 829: PPUSH
 830: CALL_OW 275
 834: ST_TO_ADDR
// end ;
 835: LD_VAR 0 1
 839: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 840: LD_INT 0
 842: PPUSH
 843: PPUSH
 844: PPUSH
// result := 0 ;
 845: LD_ADDR_VAR 0 2
 849: PUSH
 850: LD_INT 0
 852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 853: LD_ADDR_VAR 0 4
 857: PUSH
 858: LD_INT 22
 860: PUSH
 861: LD_VAR 0 1
 865: PUSH
 866: EMPTY
 867: LIST
 868: LIST
 869: PUSH
 870: LD_INT 2
 872: PUSH
 873: LD_INT 30
 875: PUSH
 876: LD_INT 0
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 30
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PPUSH
 902: CALL_OW 69
 906: ST_TO_ADDR
// if not tmp then
 907: LD_VAR 0 4
 911: NOT
 912: IFFALSE 916
// exit ;
 914: GO 962
// for i in tmp do
 916: LD_ADDR_VAR 0 3
 920: PUSH
 921: LD_VAR 0 4
 925: PUSH
 926: FOR_IN
 927: IFFALSE 960
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 929: LD_ADDR_VAR 0 2
 933: PUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_VAR 0 3
 943: PPUSH
 944: CALL_OW 274
 948: PPUSH
 949: LD_INT 3
 951: PPUSH
 952: CALL_OW 275
 956: PLUS
 957: ST_TO_ADDR
 958: GO 926
 960: POP
 961: POP
// end ;
 962: LD_VAR 0 2
 966: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 967: LD_INT 0
 969: PPUSH
 970: PPUSH
// area = ListEnvironmentArea ( area ) ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_VAR 0 2
 980: PPUSH
 981: CALL_OW 353
 985: ST_TO_ADDR
// if bulldozer > 0 then
 986: LD_VAR 0 1
 990: PUSH
 991: LD_INT 0
 993: GREATER
 994: IFFALSE 1105
// for i = area downto 1 do
 996: LD_ADDR_VAR 0 4
1000: PUSH
1001: DOUBLE
1002: LD_VAR 0 2
1006: INC
1007: ST_TO_ADDR
1008: LD_INT 1
1010: PUSH
1011: FOR_DOWNTO
1012: IFFALSE 1103
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1014: LD_VAR 0 2
1018: PUSH
1019: LD_VAR 0 4
1023: ARRAY
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_VAR 0 4
1038: ARRAY
1039: PUSH
1040: LD_INT 2
1042: ARRAY
1043: PPUSH
1044: CALL_OW 351
1048: IFFALSE 1101
// if not HasTask ( bulldozer ) then
1050: LD_VAR 0 1
1054: PPUSH
1055: CALL_OW 314
1059: NOT
1060: IFFALSE 1101
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1062: LD_VAR 0 1
1066: PPUSH
1067: LD_VAR 0 2
1071: PUSH
1072: LD_VAR 0 4
1076: ARRAY
1077: PUSH
1078: LD_INT 1
1080: ARRAY
1081: PPUSH
1082: LD_VAR 0 2
1086: PUSH
1087: LD_VAR 0 4
1091: ARRAY
1092: PUSH
1093: LD_INT 2
1095: ARRAY
1096: PPUSH
1097: CALL_OW 171
1101: GO 1011
1103: POP
1104: POP
// end ; end_of_file
1105: LD_VAR 0 3
1109: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1110: LD_INT 0
1112: PPUSH
1113: PPUSH
1114: PPUSH
1115: PPUSH
1116: PPUSH
// uc_side := 1 ;
1117: LD_ADDR_OWVAR 20
1121: PUSH
1122: LD_INT 1
1124: ST_TO_ADDR
// uc_nation := 1 ;
1125: LD_ADDR_OWVAR 21
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1133: LD_ADDR_EXP 19
1137: PUSH
1138: LD_STRING JMM
1140: PPUSH
1141: LD_EXP 2
1145: NOT
1146: PPUSH
1147: LD_STRING 08_
1149: PPUSH
1150: CALL 226 0 3
1154: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1155: LD_ADDR_VAR 0 4
1159: PUSH
1160: LD_INT 1
1162: PPUSH
1163: LD_INT 1
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: LD_INT 2
1171: PPUSH
1172: LD_INT 1
1174: PPUSH
1175: LD_INT 5
1177: PPUSH
1178: LD_INT 55
1180: PPUSH
1181: CALL 289 0 7
1185: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1186: LD_VAR 0 4
1190: PPUSH
1191: LD_INT 3
1193: PPUSH
1194: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1198: LD_VAR 0 4
1202: PPUSH
1203: LD_INT 43
1205: PPUSH
1206: LD_INT 3
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1216: LD_EXP 19
1220: PPUSH
1221: LD_VAR 0 4
1225: PPUSH
1226: CALL_OW 52
// tmp := [ ] ;
1230: LD_ADDR_VAR 0 2
1234: PUSH
1235: EMPTY
1236: ST_TO_ADDR
// uc_side := 4 ;
1237: LD_ADDR_OWVAR 20
1241: PUSH
1242: LD_INT 4
1244: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1245: LD_ADDR_OWVAR 33
1249: PUSH
1250: LD_STRING SecondCharsGal
1252: ST_TO_ADDR
// hc_class := 2 ;
1253: LD_ADDR_OWVAR 28
1257: PUSH
1258: LD_INT 2
1260: ST_TO_ADDR
// hc_sex := sex_female ;
1261: LD_ADDR_OWVAR 27
1265: PUSH
1266: LD_INT 2
1268: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1269: LD_ADDR_OWVAR 30
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: LD_INT 1
1279: PUSH
1280: LD_INT 1
1282: PUSH
1283: LD_INT 0
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1292: LD_ADDR_OWVAR 31
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: LD_INT 4
1302: PUSH
1303: LD_INT 2
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1315: LD_ADDR_OWVAR 29
1319: PUSH
1320: LD_INT 10
1322: PUSH
1323: LD_INT 11
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1330: LD_ADDR_OWVAR 26
1334: PUSH
1335: LD_STRING Naoma Goichman
1337: ST_TO_ADDR
// hc_face_number := 43 ;
1338: LD_ADDR_OWVAR 34
1342: PUSH
1343: LD_INT 43
1345: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1346: LD_ADDR_VAR 0 2
1350: PUSH
1351: LD_VAR 0 2
1355: PUSH
1356: CALL_OW 44
1360: ADD
1361: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1362: LD_ADDR_OWVAR 30
1366: PUSH
1367: LD_INT 0
1369: PUSH
1370: LD_INT 2
1372: PUSH
1373: LD_INT 0
1375: PUSH
1376: LD_INT 1
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1385: LD_ADDR_OWVAR 31
1389: PUSH
1390: LD_INT 0
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1408: LD_ADDR_OWVAR 29
1412: PUSH
1413: LD_INT 10
1415: PUSH
1416: LD_INT 10
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1423: LD_ADDR_OWVAR 26
1427: PUSH
1428: LD_STRING Magdalene Glance
1430: ST_TO_ADDR
// hc_face_number := 44 ;
1431: LD_ADDR_OWVAR 34
1435: PUSH
1436: LD_INT 44
1438: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1439: LD_ADDR_VAR 0 2
1443: PUSH
1444: LD_VAR 0 2
1448: PUSH
1449: CALL_OW 44
1453: ADD
1454: ST_TO_ADDR
// hc_sex := sex_male ;
1455: LD_ADDR_OWVAR 27
1459: PUSH
1460: LD_INT 1
1462: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1463: LD_ADDR_OWVAR 30
1467: PUSH
1468: LD_INT 2
1470: PUSH
1471: LD_INT 2
1473: PUSH
1474: LD_INT 0
1476: PUSH
1477: LD_INT 0
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1486: LD_ADDR_OWVAR 31
1490: PUSH
1491: LD_INT 3
1493: PUSH
1494: LD_INT 4
1496: PUSH
1497: LD_INT 1
1499: PUSH
1500: LD_INT 0
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: LIST
1508: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1509: LD_ADDR_OWVAR 29
1513: PUSH
1514: LD_INT 12
1516: PUSH
1517: LD_INT 10
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: ST_TO_ADDR
// hc_name := Steve Holland ;
1524: LD_ADDR_OWVAR 26
1528: PUSH
1529: LD_STRING Steve Holland
1531: ST_TO_ADDR
// hc_face_number := 60 ;
1532: LD_ADDR_OWVAR 34
1536: PUSH
1537: LD_INT 60
1539: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_VAR 0 2
1549: PUSH
1550: CALL_OW 44
1554: ADD
1555: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1556: LD_ADDR_EXP 24
1560: PUSH
1561: LD_VAR 0 2
1565: PUSH
1566: LD_INT 0
1568: DIFF
1569: ST_TO_ADDR
// for un in alpha_engs do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: LD_EXP 24
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1606
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1583: LD_VAR 0 3
1587: PPUSH
1588: LD_INT 52
1590: PPUSH
1591: LD_INT 35
1593: PPUSH
1594: LD_INT 3
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 50
1604: GO 1580
1606: POP
1607: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1608: LD_ADDR_VAR 0 2
1612: PUSH
1613: DOUBLE
1614: LD_INT 1
1616: DEC
1617: ST_TO_ADDR
1618: LD_INT 1
1620: PUSH
1621: LD_STRING 06_crates_1
1623: PPUSH
1624: LD_INT 0
1626: PPUSH
1627: CALL_OW 30
1631: PLUS
1632: PUSH
1633: LD_INT 2
1635: MUL
1636: PUSH
1637: FOR_TO
1638: IFFALSE 1664
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 5
1645: PPUSH
1646: LD_INT 56
1648: PPUSH
1649: LD_INT 40
1651: PPUSH
1652: LD_INT 2
1654: PPUSH
1655: LD_INT 0
1657: PPUSH
1658: CALL_OW 60
1662: GO 1637
1664: POP
1665: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1666: LD_STRING GammaCommander
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 30
1676: PUSH
1677: LD_INT 3
1679: LESS
1680: IFFALSE 1701
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1682: LD_ADDR_EXP 23
1686: PUSH
1687: LD_STRING VanHouten
1689: PPUSH
1690: LD_INT 0
1692: PPUSH
1693: LD_STRING 
1695: PPUSH
1696: CALL 226 0 3
1700: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1701: LD_ADDR_EXP 26
1705: PUSH
1706: LD_STRING Powell
1708: PPUSH
1709: LD_INT 0
1711: PPUSH
1712: LD_STRING 
1714: PPUSH
1715: CALL 226 0 3
1719: ST_TO_ADDR
// InitHc ;
1720: CALL_OW 19
// InitUc ;
1724: CALL_OW 18
// end ;
1728: LD_VAR 0 1
1732: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1733: LD_INT 0
1735: PPUSH
1736: PPUSH
1737: PPUSH
1738: PPUSH
1739: PPUSH
// uc_side := 4 ;
1740: LD_ADDR_OWVAR 20
1744: PUSH
1745: LD_INT 4
1747: ST_TO_ADDR
// uc_nation := 3 ;
1748: LD_ADDR_OWVAR 21
1752: PUSH
1753: LD_INT 3
1755: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1756: LD_ADDR_VAR 0 4
1760: PUSH
1761: LD_STRING 09_ovsyenko_base
1763: PPUSH
1764: LD_INT 0
1766: PUSH
1767: LD_INT 101
1769: PUSH
1770: LD_INT 118
1772: PUSH
1773: LD_INT 2
1775: PUSH
1776: LD_INT 500
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 31
1788: PUSH
1789: LD_INT 109
1791: PUSH
1792: LD_INT 114
1794: PUSH
1795: LD_INT 4
1797: PUSH
1798: LD_INT 500
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: PUSH
1808: LD_INT 31
1810: PUSH
1811: LD_INT 115
1813: PUSH
1814: LD_INT 132
1816: PUSH
1817: LD_INT 5
1819: PUSH
1820: LD_INT 500
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: LD_INT 31
1832: PUSH
1833: LD_INT 98
1835: PUSH
1836: LD_INT 120
1838: PUSH
1839: LD_INT 1
1841: PUSH
1842: LD_INT 500
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 30
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 2
1867: PUSH
1868: LD_VAR 0 4
1872: PUSH
1873: FOR_IN
1874: IFFALSE 2030
// begin bc_type := i [ 1 ] ;
1876: LD_ADDR_OWVAR 42
1880: PUSH
1881: LD_VAR 0 2
1885: PUSH
1886: LD_INT 1
1888: ARRAY
1889: ST_TO_ADDR
// bc_level := 3 ;
1890: LD_ADDR_OWVAR 43
1894: PUSH
1895: LD_INT 3
1897: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1898: LD_ADDR_VAR 0 3
1902: PUSH
1903: LD_VAR 0 2
1907: PUSH
1908: LD_INT 2
1910: ARRAY
1911: PPUSH
1912: LD_VAR 0 2
1916: PUSH
1917: LD_INT 3
1919: ARRAY
1920: PPUSH
1921: LD_VAR 0 2
1925: PUSH
1926: LD_INT 4
1928: ARRAY
1929: PPUSH
1930: CALL_OW 47
1934: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1935: LD_VAR 0 3
1939: PPUSH
1940: CALL_OW 266
1944: PUSH
1945: LD_INT 0
1947: EQUAL
1948: IFFALSE 1982
// begin SetBName ( b , ovsyenko ) ;
1950: LD_VAR 0 3
1954: PPUSH
1955: LD_STRING ovsyenko
1957: PPUSH
1958: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: CALL_OW 274
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: LD_INT 50
1977: PPUSH
1978: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1982: LD_VAR 0 2
1986: PUSH
1987: LD_INT 5
1989: ARRAY
1990: PUSH
1991: LD_INT 250
1993: LESS
1994: IFFALSE 2010
// SetLives ( b , 333 ) else
1996: LD_VAR 0 3
2000: PPUSH
2001: LD_INT 333
2003: PPUSH
2004: CALL_OW 234
2008: GO 2028
// SetLives ( b , i [ 5 ] ) ;
2010: LD_VAR 0 3
2014: PPUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 5
2022: ARRAY
2023: PPUSH
2024: CALL_OW 234
// end ;
2028: GO 1873
2030: POP
2031: POP
// uc_nation := 1 ;
2032: LD_ADDR_OWVAR 21
2036: PUSH
2037: LD_INT 1
2039: ST_TO_ADDR
// tmp := [ ] ;
2040: LD_ADDR_VAR 0 4
2044: PUSH
2045: EMPTY
2046: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2047: LD_ADDR_EXP 20
2051: PUSH
2052: LD_STRING Gary
2054: PPUSH
2055: LD_EXP 2
2059: NOT
2060: PPUSH
2061: LD_STRING 
2063: PPUSH
2064: CALL 226 0 3
2068: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: LD_VAR 0 4
2078: PUSH
2079: LD_EXP 20
2083: ADD
2084: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2085: LD_ADDR_EXP 21
2089: PUSH
2090: LD_STRING Bobby
2092: PPUSH
2093: LD_EXP 2
2097: NOT
2098: PPUSH
2099: LD_STRING 08_
2101: PPUSH
2102: CALL 226 0 3
2106: ST_TO_ADDR
// if not Bobby then
2107: LD_EXP 21
2111: NOT
2112: IFFALSE 2136
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2114: LD_ADDR_EXP 21
2118: PUSH
2119: LD_STRING Bobby
2121: PPUSH
2122: LD_EXP 2
2126: NOT
2127: PPUSH
2128: LD_STRING 03_
2130: PPUSH
2131: CALL 226 0 3
2135: ST_TO_ADDR
// if Bobby then
2136: LD_EXP 21
2140: IFFALSE 2158
// tmp := tmp ^ Bobby ;
2142: LD_ADDR_VAR 0 4
2146: PUSH
2147: LD_VAR 0 4
2151: PUSH
2152: LD_EXP 21
2156: ADD
2157: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2158: LD_ADDR_EXP 22
2162: PUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: LD_EXP 2
2170: NOT
2171: PPUSH
2172: LD_STRING 08_
2174: PPUSH
2175: CALL 226 0 3
2179: ST_TO_ADDR
// if not Cyrus then
2180: LD_EXP 22
2184: NOT
2185: IFFALSE 2209
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2187: LD_ADDR_EXP 22
2191: PUSH
2192: LD_STRING Cyrus
2194: PPUSH
2195: LD_EXP 2
2199: NOT
2200: PPUSH
2201: LD_STRING 03_
2203: PPUSH
2204: CALL 226 0 3
2208: ST_TO_ADDR
// if Cyrus then
2209: LD_EXP 22
2213: IFFALSE 2231
// tmp := tmp ^ Cyrus ;
2215: LD_ADDR_VAR 0 4
2219: PUSH
2220: LD_VAR 0 4
2224: PUSH
2225: LD_EXP 22
2229: ADD
2230: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2231: LD_ADDR_VAR 0 4
2235: PUSH
2236: LD_VAR 0 4
2240: PUSH
2241: LD_STRING 09_prev_squad
2243: PPUSH
2244: CALL_OW 31
2248: ADD
2249: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2250: LD_STRING 09_prev_squad
2252: PPUSH
2253: CALL_OW 40
// tmp := tmp diff 0 ;
2257: LD_ADDR_VAR 0 4
2261: PUSH
2262: LD_VAR 0 4
2266: PUSH
2267: LD_INT 0
2269: DIFF
2270: ST_TO_ADDR
// if debug then
2271: LD_EXP 2
2275: IFFALSE 2326
// begin for i = 1 to 6 do
2277: LD_ADDR_VAR 0 2
2281: PUSH
2282: DOUBLE
2283: LD_INT 1
2285: DEC
2286: ST_TO_ADDR
2287: LD_INT 6
2289: PUSH
2290: FOR_TO
2291: IFFALSE 2324
// begin PrepareHuman ( false , 1 , 6 ) ;
2293: LD_INT 0
2295: PPUSH
2296: LD_INT 1
2298: PPUSH
2299: LD_INT 6
2301: PPUSH
2302: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2306: LD_ADDR_VAR 0 4
2310: PUSH
2311: LD_VAR 0 4
2315: PUSH
2316: CALL_OW 44
2320: ADD
2321: ST_TO_ADDR
// end ;
2322: GO 2290
2324: POP
2325: POP
// end ; for i in tmp do
2326: LD_ADDR_VAR 0 2
2330: PUSH
2331: LD_VAR 0 4
2335: PUSH
2336: FOR_IN
2337: IFFALSE 2396
// begin if GetClass ( i ) in [ 2 , 3 ] then
2339: LD_VAR 0 2
2343: PPUSH
2344: CALL_OW 257
2348: PUSH
2349: LD_INT 2
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: EMPTY
2356: LIST
2357: LIST
2358: IN
2359: IFFALSE 2373
// SetClass ( i , 1 ) ;
2361: LD_VAR 0 2
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2373: LD_VAR 0 2
2377: PPUSH
2378: LD_INT 106
2380: PPUSH
2381: LD_INT 122
2383: PPUSH
2384: LD_INT 5
2386: PPUSH
2387: LD_INT 0
2389: PPUSH
2390: CALL_OW 50
// end ;
2394: GO 2336
2396: POP
2397: POP
// tmp := tmp diff Gary ;
2398: LD_ADDR_VAR 0 4
2402: PUSH
2403: LD_VAR 0 4
2407: PUSH
2408: LD_EXP 20
2412: DIFF
2413: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2414: LD_ADDR_VAR 0 3
2418: PUSH
2419: LD_INT 22
2421: PUSH
2422: LD_INT 4
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: LD_INT 30
2431: PUSH
2432: LD_INT 31
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PPUSH
2443: CALL_OW 69
2447: ST_TO_ADDR
// for i = 1 to b do
2448: LD_ADDR_VAR 0 2
2452: PUSH
2453: DOUBLE
2454: LD_INT 1
2456: DEC
2457: ST_TO_ADDR
2458: LD_VAR 0 3
2462: PUSH
2463: FOR_TO
2464: IFFALSE 2494
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2466: LD_VAR 0 4
2470: PUSH
2471: LD_VAR 0 2
2475: ARRAY
2476: PPUSH
2477: LD_VAR 0 3
2481: PUSH
2482: LD_VAR 0 2
2486: ARRAY
2487: PPUSH
2488: CALL_OW 120
// end ;
2492: GO 2463
2494: POP
2495: POP
// InitHc ;
2496: CALL_OW 19
// InitUc ;
2500: CALL_OW 18
// end ;
2504: LD_VAR 0 1
2508: RET
// export function PowellTransport ; var i , un ; begin
2509: LD_INT 0
2511: PPUSH
2512: PPUSH
2513: PPUSH
// uc_side := 4 ;
2514: LD_ADDR_OWVAR 20
2518: PUSH
2519: LD_INT 4
2521: ST_TO_ADDR
// uc_nation := 1 ;
2522: LD_ADDR_OWVAR 21
2526: PUSH
2527: LD_INT 1
2529: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2530: LD_INT 1
2532: PPUSH
2533: LD_INT 3
2535: PPUSH
2536: LD_INT 6
2538: PPUSH
2539: CALL_OW 380
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2551: LD_ADDR_OWVAR 33
2555: PUSH
2556: LD_STRING SecondCharsGal
2558: ST_TO_ADDR
// hc_face_number := 30 ;
2559: LD_ADDR_OWVAR 34
2563: PUSH
2564: LD_INT 30
2566: ST_TO_ADDR
// powell_trans := CreateHuman ;
2567: LD_ADDR_EXP 25
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// hc_face_number := 31 ;
2577: LD_ADDR_OWVAR 34
2581: PUSH
2582: LD_INT 31
2584: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2585: LD_ADDR_EXP 25
2589: PUSH
2590: LD_EXP 25
2594: PUSH
2595: CALL_OW 44
2599: ADD
2600: ST_TO_ADDR
// for i = 1 to 2 do
2601: LD_ADDR_VAR 0 2
2605: PUSH
2606: DOUBLE
2607: LD_INT 1
2609: DEC
2610: ST_TO_ADDR
2611: LD_INT 2
2613: PUSH
2614: FOR_TO
2615: IFFALSE 2666
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_INT 4
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 1
2633: PPUSH
2634: LD_INT 1
2636: PPUSH
2637: LD_INT 12
2639: PPUSH
2640: LD_INT 66
2642: PPUSH
2643: CALL 289 0 7
2647: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2648: LD_ADDR_EXP 25
2652: PUSH
2653: LD_EXP 25
2657: PUSH
2658: LD_VAR 0 3
2662: ADD
2663: ST_TO_ADDR
// end ;
2664: GO 2614
2666: POP
2667: POP
// end ; end_of_file
2668: LD_VAR 0 1
2672: RET
// export function Action ; var i , veh ; begin
2673: LD_INT 0
2675: PPUSH
2676: PPUSH
2677: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2678: LD_EXP 24
2682: PPUSH
2683: LD_INT 0
2685: PPUSH
2686: LD_INT 50
2688: PPUSH
2689: LD_INT 38
2691: PPUSH
2692: LD_INT 2
2694: PPUSH
2695: CALL_OW 145
// InGameOn ;
2699: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2703: LD_INT 43
2705: PPUSH
2706: LD_INT 9
2708: PPUSH
2709: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2713: LD_EXP 19
2717: PPUSH
2718: LD_INT 54
2720: PPUSH
2721: LD_INT 34
2723: PPUSH
2724: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2728: LD_EXP 19
2732: PPUSH
2733: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_EXP 24
2746: PUSH
2747: LD_INT 1
2749: ARRAY
2750: PPUSH
2751: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2755: LD_INT 35
2757: PPUSH
2758: CALL_OW 67
// until See ( 4 , JMM ) ;
2762: LD_INT 4
2764: PPUSH
2765: LD_EXP 19
2769: PPUSH
2770: CALL_OW 292
2774: IFFALSE 2755
// CenterNowOnUnits ( JMM ) ;
2776: LD_EXP 19
2780: PPUSH
2781: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2785: LD_EXP 19
2789: PPUSH
2790: LD_STRING D2-JMM-1
2792: PPUSH
2793: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2797: LD_EXP 24
2801: PUSH
2802: LD_INT 3
2804: ARRAY
2805: PPUSH
2806: LD_EXP 19
2810: PPUSH
2811: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2815: LD_EXP 24
2819: PUSH
2820: LD_INT 3
2822: ARRAY
2823: PPUSH
2824: LD_STRING D2-Eng1-1
2826: PPUSH
2827: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2831: LD_EXP 19
2835: PPUSH
2836: LD_STRING D2-JMM-2
2838: PPUSH
2839: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2843: LD_EXP 24
2847: PUSH
2848: LD_INT 3
2850: ARRAY
2851: PPUSH
2852: LD_STRING D2-Eng1-2
2854: PPUSH
2855: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2859: LD_EXP 19
2863: PPUSH
2864: LD_STRING D2-JMM-3
2866: PPUSH
2867: CALL_OW 88
// if Houten then
2871: LD_EXP 23
2875: IFFALSE 3073
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2877: LD_ADDR_VAR 0 3
2881: PUSH
2882: LD_INT 4
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: LD_INT 2
2893: PPUSH
2894: LD_INT 1
2896: PPUSH
2897: LD_INT 4
2899: PPUSH
2900: LD_INT 55
2902: PPUSH
2903: CALL 289 0 7
2907: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2908: LD_VAR 0 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2920: LD_VAR 0 3
2924: PPUSH
2925: LD_INT 46
2927: PPUSH
2928: LD_INT 19
2930: PPUSH
2931: LD_INT 0
2933: PPUSH
2934: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2938: LD_EXP 23
2942: PPUSH
2943: LD_VAR 0 3
2947: PPUSH
2948: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2952: LD_EXP 23
2956: PPUSH
2957: LD_INT 49
2959: PPUSH
2960: LD_INT 33
2962: PPUSH
2963: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2967: LD_EXP 23
2971: PPUSH
2972: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2976: LD_EXP 23
2980: PPUSH
2981: LD_EXP 19
2985: PPUSH
2986: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2990: LD_INT 35
2992: PPUSH
2993: CALL_OW 67
// until See ( 1 , Houten ) ;
2997: LD_INT 1
2999: PPUSH
3000: LD_EXP 23
3004: PPUSH
3005: CALL_OW 292
3009: IFFALSE 2990
// ComTurnUnit ( JMM , Houten ) ;
3011: LD_EXP 19
3015: PPUSH
3016: LD_EXP 23
3020: PPUSH
3021: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3025: LD_EXP 19
3029: PPUSH
3030: LD_STRING D1d-JMM-1
3032: PPUSH
3033: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3037: LD_EXP 23
3041: PPUSH
3042: LD_STRING D1-VanH-1
3044: PPUSH
3045: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3049: LD_EXP 19
3053: PPUSH
3054: LD_STRING D1-JMM-1v
3056: PPUSH
3057: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3061: LD_EXP 19
3065: PPUSH
3066: LD_STRING D1-JMM-2v
3068: PPUSH
3069: CALL_OW 88
// end ; InGameOff ;
3073: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3077: LD_STRING M1
3079: PPUSH
3080: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3084: LD_INT 22
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 92
3096: PUSH
3097: LD_EXP 19
3101: PPUSH
3102: CALL_OW 250
3106: PUSH
3107: LD_EXP 19
3111: PPUSH
3112: CALL_OW 251
3116: PUSH
3117: LD_INT 15
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PPUSH
3130: CALL_OW 69
3134: PPUSH
3135: LD_INT 1
3137: PPUSH
3138: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3142: LD_EXP 24
3146: PUSH
3147: LD_EXP 19
3151: ADD
3152: PUSH
3153: LD_EXP 23
3157: ADD
3158: PPUSH
3159: CALL_OW 141
// end ;
3163: LD_VAR 0 1
3167: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3168: LD_INT 1
3170: PPUSH
3171: LD_EXP 20
3175: PPUSH
3176: CALL_OW 292
3180: PUSH
3181: LD_EXP 19
3185: PPUSH
3186: LD_EXP 20
3190: PPUSH
3191: CALL_OW 296
3195: PUSH
3196: LD_INT 6
3198: LESS
3199: AND
3200: IFFALSE 4073
3202: GO 3204
3204: DISABLE
3205: LD_INT 0
3207: PPUSH
3208: PPUSH
3209: PPUSH
3210: PPUSH
3211: PPUSH
// begin InGameOn ;
3212: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3216: LD_INT 22
3218: PUSH
3219: LD_INT 4
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PPUSH
3226: CALL_OW 69
3230: PPUSH
3231: LD_INT 1
3233: PPUSH
3234: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3238: LD_ADDR_VAR 0 4
3242: PUSH
3243: LD_INT 22
3245: PUSH
3246: LD_INT 1
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 2
3255: PUSH
3256: LD_INT 25
3258: PUSH
3259: LD_INT 1
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 25
3268: PUSH
3269: LD_INT 2
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 25
3278: PUSH
3279: LD_INT 3
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: PUSH
3286: LD_INT 25
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: ST_TO_ADDR
// ComHold ( tmp ) ;
3312: LD_VAR 0 4
3316: PPUSH
3317: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3321: LD_EXP 19
3325: PPUSH
3326: LD_STRING D2-JMM-3a
3328: PPUSH
3329: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3333: LD_EXP 20
3337: PPUSH
3338: LD_EXP 19
3342: PPUSH
3343: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3347: LD_EXP 20
3351: PPUSH
3352: LD_STRING D2-Gary-3
3354: PPUSH
3355: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3359: LD_EXP 19
3363: PPUSH
3364: LD_EXP 20
3368: PPUSH
3369: CALL_OW 119
// for i in tmp do
3373: LD_ADDR_VAR 0 5
3377: PUSH
3378: LD_VAR 0 4
3382: PUSH
3383: FOR_IN
3384: IFFALSE 3429
// begin if IsInUnit ( i ) then
3386: LD_VAR 0 5
3390: PPUSH
3391: CALL_OW 310
3395: IFFALSE 3406
// ComExitBuilding ( i ) ;
3397: LD_VAR 0 5
3401: PPUSH
3402: CALL_OW 122
// wait ( 1 ) ;
3406: LD_INT 1
3408: PPUSH
3409: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3413: LD_VAR 0 5
3417: PPUSH
3418: LD_EXP 19
3422: PPUSH
3423: CALL_OW 119
// end ;
3427: GO 3383
3429: POP
3430: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3431: LD_ADDR_VAR 0 4
3435: PUSH
3436: LD_VAR 0 4
3440: PUSH
3441: LD_EXP 19
3445: PUSH
3446: LD_EXP 23
3450: PUSH
3451: LD_EXP 20
3455: PUSH
3456: LD_EXP 22
3460: PUSH
3461: LD_EXP 21
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_EXP 24
3477: ADD
3478: DIFF
3479: ST_TO_ADDR
// if Bobby then
3480: LD_EXP 21
3484: IFFALSE 3498
// Say ( Bobby , D2-Bobby-3 ) ;
3486: LD_EXP 21
3490: PPUSH
3491: LD_STRING D2-Bobby-3
3493: PPUSH
3494: CALL_OW 88
// if Cyrus then
3498: LD_EXP 22
3502: IFFALSE 3516
// Say ( Cyrus , D2-Cyrus-3 ) ;
3504: LD_EXP 22
3508: PPUSH
3509: LD_STRING D2-Cyrus-3
3511: PPUSH
3512: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3516: LD_EXP 19
3520: PPUSH
3521: LD_STRING D2-JMM-4
3523: PPUSH
3524: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3528: LD_EXP 20
3532: PPUSH
3533: LD_STRING D2-Gary-4
3535: PPUSH
3536: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3540: LD_ADDR_VAR 0 1
3544: PUSH
3545: LD_VAR 0 4
3549: PPUSH
3550: LD_INT 26
3552: PUSH
3553: LD_INT 1
3555: PUSH
3556: EMPTY
3557: LIST
3558: LIST
3559: PPUSH
3560: CALL_OW 72
3564: PUSH
3565: LD_INT 1
3567: ARRAY
3568: ST_TO_ADDR
// if Cyrus then
3569: LD_EXP 22
3573: IFFALSE 3589
// Say ( Cyrus , D2-Cyrus-4 ) else
3575: LD_EXP 22
3579: PPUSH
3580: LD_STRING D2-Cyrus-4
3582: PPUSH
3583: CALL_OW 88
3587: GO 3601
// Say ( un1 , D2-Sol1-4 ) ;
3589: LD_VAR 0 1
3593: PPUSH
3594: LD_STRING D2-Sol1-4
3596: PPUSH
3597: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3601: LD_EXP 19
3605: PPUSH
3606: LD_STRING D2-JMM-5
3608: PPUSH
3609: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_EXP 24
3622: PPUSH
3623: LD_INT 91
3625: PUSH
3626: LD_EXP 19
3630: PUSH
3631: LD_INT 10
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 26
3641: PUSH
3642: LD_INT 2
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 72
3657: ST_TO_ADDR
// if un2 then
3658: LD_VAR 0 2
3662: IFFALSE 3716
// begin un2 := un2 [ un2 ] ;
3664: LD_ADDR_VAR 0 2
3668: PUSH
3669: LD_VAR 0 2
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3680: LD_VAR 0 2
3684: PPUSH
3685: LD_STRING D2-FEng1-5
3687: PPUSH
3688: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3692: LD_EXP 19
3696: PPUSH
3697: LD_STRING D2-JMM-6
3699: PPUSH
3700: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3704: LD_VAR 0 2
3708: PPUSH
3709: LD_STRING D2-FEng1-6
3711: PPUSH
3712: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3716: LD_ADDR_VAR 0 3
3720: PUSH
3721: LD_EXP 24
3725: PPUSH
3726: LD_INT 91
3728: PUSH
3729: LD_EXP 19
3733: PUSH
3734: LD_INT 10
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 26
3744: PUSH
3745: LD_INT 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 72
3760: ST_TO_ADDR
// if un3 then
3761: LD_VAR 0 3
3765: IFFALSE 3820
// begin un3 := un3 [ 1 ] ;
3767: LD_ADDR_VAR 0 3
3771: PUSH
3772: LD_VAR 0 3
3776: PUSH
3777: LD_INT 1
3779: ARRAY
3780: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3781: LD_VAR 0 3
3785: PPUSH
3786: LD_INT 114
3788: PPUSH
3789: LD_INT 122
3791: PPUSH
3792: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3796: LD_VAR 0 3
3800: PPUSH
3801: LD_STRING D2-Eng1-6
3803: PPUSH
3804: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3808: LD_EXP 19
3812: PPUSH
3813: LD_STRING D2-JMM-7
3815: PPUSH
3816: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3820: LD_EXP 20
3824: PPUSH
3825: LD_STRING D2-Gary-7
3827: PPUSH
3828: CALL_OW 88
// if un2 then
3832: LD_VAR 0 2
3836: IFFALSE 3850
// Say ( un2 , D2-FEng1-7 ) ;
3838: LD_VAR 0 2
3842: PPUSH
3843: LD_STRING D2-FEng1-7
3845: PPUSH
3846: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3850: LD_VAR 0 1
3854: PPUSH
3855: LD_STRING D2-Sol1-7
3857: PPUSH
3858: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3862: LD_EXP 19
3866: PPUSH
3867: LD_STRING D2-JMM-8
3869: PPUSH
3870: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3874: LD_INT 22
3876: PUSH
3877: LD_INT 1
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 69
3888: PPUSH
3889: CALL_OW 141
// InGameOff ;
3893: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3897: LD_STRING M1a
3899: PPUSH
3900: CALL_OW 337
// jmm_in_ovsyenko := true ;
3904: LD_ADDR_EXP 4
3908: PUSH
3909: LD_INT 1
3911: ST_TO_ADDR
// if debug then
3912: LD_EXP 2
3916: IFFALSE 4022
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
3918: LD_INT 22
3920: PUSH
3921: LD_INT 1
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PUSH
3928: LD_INT 30
3930: PUSH
3931: LD_INT 0
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PPUSH
3942: CALL_OW 69
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PPUSH
3951: CALL_OW 274
3955: PPUSH
3956: LD_INT 2
3958: PPUSH
3959: LD_INT 1000
3961: PPUSH
3962: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 30
3978: PUSH
3979: LD_INT 0
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PPUSH
3990: CALL_OW 69
3994: PUSH
3995: LD_INT 1
3997: ARRAY
3998: PPUSH
3999: CALL_OW 274
4003: PPUSH
4004: LD_INT 1
4006: PPUSH
4007: LD_INT 1000
4009: PPUSH
4010: CALL_OW 277
// ar_can_arrive := true ;
4014: LD_ADDR_EXP 10
4018: PUSH
4019: LD_INT 1
4021: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4022: LD_INT 1050
4024: PPUSH
4025: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4029: LD_ADDR_VAR 0 4
4033: PUSH
4034: LD_INT 25
4036: PUSH
4037: LD_INT 14
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: PPUSH
4044: CALL_OW 69
4048: ST_TO_ADDR
// if not tmp then
4049: LD_VAR 0 4
4053: NOT
4054: IFFALSE 4058
// exit ;
4056: GO 4073
// ComMoveXY ( tmp , 75 , 75 ) ;
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_INT 75
4065: PPUSH
4066: LD_INT 75
4068: PPUSH
4069: CALL_OW 111
// end ;
4073: PPOPN 5
4075: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4076: LD_INT 22
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 30
4088: PUSH
4089: LD_INT 30
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 3
4098: PUSH
4099: LD_INT 57
4101: PUSH
4102: EMPTY
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: IFFALSE 4160
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4126: LD_ADDR_VAR 0 1
4130: PUSH
4131: LD_STRING M2easy
4133: PUSH
4134: LD_STRING M2
4136: PUSH
4137: LD_STRING M2hard
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4145: LD_VAR 0 1
4149: PUSH
4150: LD_OWVAR 67
4154: ARRAY
4155: PPUSH
4156: CALL_OW 337
// end ;
4160: PPOPN 1
4162: END
// every 3 3$00 do
4163: GO 4165
4165: DISABLE
// begin DialogueOn ;
4166: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4170: LD_EXP 26
4174: PPUSH
4175: LD_STRING D3-Pow-1
4177: PPUSH
4178: CALL_OW 94
// if jmm_in_ovsyenko then
4182: LD_EXP 4
4186: IFFALSE 4214
// begin Say ( JMM , D3-JMM-1 ) ;
4188: LD_EXP 19
4192: PPUSH
4193: LD_STRING D3-JMM-1
4195: PPUSH
4196: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4200: LD_EXP 19
4204: PPUSH
4205: LD_STRING D3-JMM-1b
4207: PPUSH
4208: CALL_OW 88
// end else
4212: GO 4226
// Say ( JMM , D3-JMM-1a ) ;
4214: LD_EXP 19
4218: PPUSH
4219: LD_STRING D3-JMM-1a
4221: PPUSH
4222: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4226: LD_EXP 26
4230: PPUSH
4231: LD_STRING D3-Pow-2
4233: PPUSH
4234: CALL_OW 94
// DialogueOff ;
4238: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4242: LD_STRING M3
4244: PPUSH
4245: CALL_OW 337
// powell_want_sib := true ;
4249: LD_ADDR_EXP 5
4253: PUSH
4254: LD_INT 1
4256: ST_TO_ADDR
// end ;
4257: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4258: LD_EXP 6
4262: PUSH
4263: LD_INT 0
4265: EQUAL
4266: IFFALSE 5713
4268: GO 4270
4270: DISABLE
4271: LD_INT 0
4273: PPUSH
4274: PPUSH
4275: PPUSH
4276: PPUSH
4277: PPUSH
4278: PPUSH
4279: PPUSH
4280: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4281: LD_INT 4
4283: PPUSH
4284: LD_INT 1
4286: PPUSH
4287: CALL_OW 343
// PowellTransport ;
4291: CALL 2509 0 0
// for i = 1 to 3 do
4295: LD_ADDR_VAR 0 4
4299: PUSH
4300: DOUBLE
4301: LD_INT 1
4303: DEC
4304: ST_TO_ADDR
4305: LD_INT 3
4307: PUSH
4308: FOR_TO
4309: IFFALSE 4376
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4311: LD_ADDR_VAR 0 1
4315: PUSH
4316: LD_INT 6
4318: PPUSH
4319: LD_VAR 0 4
4323: PPUSH
4324: CALL_OW 287
4328: ST_TO_ADDR
// if not tmp then
4329: LD_VAR 0 1
4333: NOT
4334: IFFALSE 4338
// continue ;
4336: GO 4308
// EraseResourceArea ( terminalArea , i ) ;
4338: LD_INT 6
4340: PPUSH
4341: LD_VAR 0 4
4345: PPUSH
4346: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4350: LD_EXP 3
4354: PPUSH
4355: CALL_OW 274
4359: PPUSH
4360: LD_VAR 0 4
4364: PPUSH
4365: LD_VAR 0 1
4369: PPUSH
4370: CALL_OW 276
// end ;
4374: GO 4308
4376: POP
4377: POP
// x := 43 ;
4378: LD_ADDR_VAR 0 2
4382: PUSH
4383: LD_INT 43
4385: ST_TO_ADDR
// y := 3 ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_INT 3
4393: ST_TO_ADDR
// for i = 3 to 4 do
4394: LD_ADDR_VAR 0 4
4398: PUSH
4399: DOUBLE
4400: LD_INT 3
4402: DEC
4403: ST_TO_ADDR
4404: LD_INT 4
4406: PUSH
4407: FOR_TO
4408: IFFALSE 4599
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4410: LD_EXP 25
4414: PUSH
4415: LD_VAR 0 4
4419: ARRAY
4420: PPUSH
4421: LD_INT 4
4423: PPUSH
4424: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4428: LD_EXP 25
4432: PUSH
4433: LD_VAR 0 4
4437: ARRAY
4438: PPUSH
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_VAR 0 3
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4456: LD_EXP 25
4460: PUSH
4461: LD_VAR 0 4
4465: PUSH
4466: LD_INT 2
4468: MINUS
4469: ARRAY
4470: PPUSH
4471: LD_EXP 25
4475: PUSH
4476: LD_VAR 0 4
4480: ARRAY
4481: PPUSH
4482: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4486: LD_EXP 25
4490: PUSH
4491: LD_VAR 0 4
4495: ARRAY
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 100
4502: PPUSH
4503: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4507: LD_EXP 25
4511: PUSH
4512: LD_VAR 0 4
4516: PUSH
4517: LD_INT 2
4519: MINUS
4520: ARRAY
4521: PPUSH
4522: LD_INT 54
4524: PPUSH
4525: LD_INT 42
4527: PPUSH
4528: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4532: LD_EXP 25
4536: PUSH
4537: LD_VAR 0 4
4541: PUSH
4542: LD_INT 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: LD_EXP 3
4551: PPUSH
4552: CALL_OW 250
4556: PPUSH
4557: LD_EXP 3
4561: PPUSH
4562: CALL_OW 251
4566: PPUSH
4567: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4571: LD_EXP 25
4575: PUSH
4576: LD_VAR 0 4
4580: PUSH
4581: LD_INT 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 200
// Wait ( 0 0$02 ) ;
4590: LD_INT 70
4592: PPUSH
4593: CALL_OW 67
// end ;
4597: GO 4407
4599: POP
4600: POP
// time := 0 0$20 ;
4601: LD_ADDR_VAR 0 8
4605: PUSH
4606: LD_INT 700
4608: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4609: LD_INT 35
4611: PPUSH
4612: CALL_OW 67
// time := time - 0 0$01 ;
4616: LD_ADDR_VAR 0 8
4620: PUSH
4621: LD_VAR 0 8
4625: PUSH
4626: LD_INT 35
4628: MINUS
4629: ST_TO_ADDR
// for i = 3 to 4 do
4630: LD_ADDR_VAR 0 4
4634: PUSH
4635: DOUBLE
4636: LD_INT 3
4638: DEC
4639: ST_TO_ADDR
4640: LD_INT 4
4642: PUSH
4643: FOR_TO
4644: IFFALSE 4779
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4646: LD_EXP 25
4650: PUSH
4651: LD_VAR 0 4
4655: ARRAY
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: GREATER
4668: PUSH
4669: LD_EXP 25
4673: PUSH
4674: LD_VAR 0 4
4678: ARRAY
4679: PPUSH
4680: CALL_OW 314
4684: NOT
4685: AND
4686: IFFALSE 4777
// begin x := rand ( 0 , 5 ) ;
4688: LD_ADDR_VAR 0 2
4692: PUSH
4693: LD_INT 0
4695: PPUSH
4696: LD_INT 5
4698: PPUSH
4699: CALL_OW 12
4703: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4704: LD_EXP 25
4708: PUSH
4709: LD_VAR 0 4
4713: ARRAY
4714: PPUSH
4715: LD_EXP 25
4719: PUSH
4720: LD_VAR 0 4
4724: ARRAY
4725: PPUSH
4726: CALL_OW 250
4730: PPUSH
4731: LD_VAR 0 2
4735: PPUSH
4736: LD_INT 3
4738: PPUSH
4739: CALL_OW 272
4743: PPUSH
4744: LD_EXP 25
4748: PUSH
4749: LD_VAR 0 4
4753: ARRAY
4754: PPUSH
4755: CALL_OW 251
4759: PPUSH
4760: LD_VAR 0 2
4764: PPUSH
4765: LD_INT 3
4767: PPUSH
4768: CALL_OW 273
4772: PPUSH
4773: CALL_OW 171
// end ;
4777: GO 4643
4779: POP
4780: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4781: LD_EXP 25
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_INT 54
4792: PPUSH
4793: LD_INT 42
4795: PPUSH
4796: CALL_OW 297
4800: PUSH
4801: LD_INT 4
4803: LESS
4804: PUSH
4805: LD_VAR 0 8
4809: PUSH
4810: LD_INT 0
4812: EQUAL
4813: OR
4814: IFFALSE 4609
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4816: LD_EXP 25
4820: PUSH
4821: LD_INT 3
4823: ARRAY
4824: PPUSH
4825: LD_INT 1
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4835: LD_EXP 25
4839: PUSH
4840: LD_INT 4
4842: ARRAY
4843: PPUSH
4844: LD_INT 1
4846: PPUSH
4847: LD_INT 0
4849: PPUSH
4850: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4854: LD_EXP 3
4858: PPUSH
4859: CALL_OW 274
4863: PPUSH
4864: LD_INT 1
4866: PPUSH
4867: LD_INT 200
4869: PPUSH
4870: CALL_OW 276
// DialogueOn ;
4874: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4878: LD_INT 53
4880: PPUSH
4881: LD_INT 35
4883: PPUSH
4884: CALL_OW 86
// un := powell_trans [ 1 ] ;
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_EXP 25
4897: PUSH
4898: LD_INT 1
4900: ARRAY
4901: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4902: LD_VAR 0 5
4906: PPUSH
4907: LD_STRING D4-Mech1-1
4909: PPUSH
4910: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4914: LD_EXP 19
4918: PPUSH
4919: LD_STRING D4-JMM-1
4921: PPUSH
4922: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4926: LD_VAR 0 5
4930: PPUSH
4931: LD_STRING D4-Mech1-2
4933: PPUSH
4934: CALL_OW 88
// powell_happy := false ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_INT 0
4945: ST_TO_ADDR
// take_cargo := false ;
4946: LD_ADDR_VAR 0 7
4950: PUSH
4951: LD_INT 0
4953: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4954: CALL 809 0 0
4958: PUSH
4959: LD_INT 60
4961: GREATEREQUAL
4962: IFFALSE 5010
// begin Say ( JMM , D5-JMM-1 ) ;
4964: LD_EXP 19
4968: PPUSH
4969: LD_STRING D5-JMM-1
4971: PPUSH
4972: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4976: LD_VAR 0 5
4980: PPUSH
4981: LD_STRING D6-Mech1-1
4983: PPUSH
4984: CALL_OW 88
// powell_happy := true ;
4988: LD_ADDR_VAR 0 6
4992: PUSH
4993: LD_INT 1
4995: ST_TO_ADDR
// take_cargo := true ;
4996: LD_ADDR_VAR 0 7
5000: PUSH
5001: LD_INT 1
5003: ST_TO_ADDR
// DialogueOff ;
5004: CALL_OW 7
// end else
5008: GO 5244
// if GetTerminalCargo > 0 then
5010: CALL 809 0 0
5014: PUSH
5015: LD_INT 0
5017: GREATER
5018: IFFALSE 5216
// begin case Query ( QWait ) of 1 :
5020: LD_STRING QWait
5022: PPUSH
5023: CALL_OW 97
5027: PUSH
5028: LD_INT 1
5030: DOUBLE
5031: EQUAL
5032: IFTRUE 5036
5034: GO 5127
5036: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5037: LD_EXP 19
5041: PPUSH
5042: LD_STRING D5a-JMM-1
5044: PPUSH
5045: CALL_OW 88
// DialogueOff ;
5049: CALL_OW 7
// wait ( 5 5$00 ) ;
5053: LD_INT 10500
5055: PPUSH
5056: CALL_OW 67
// if GetTerminalCargo < 60 then
5060: CALL 809 0 0
5064: PUSH
5065: LD_INT 60
5067: LESS
5068: IFFALSE 5109
// begin DialogueOn ;
5070: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5074: LD_EXP 3
5078: PPUSH
5079: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5083: LD_VAR 0 5
5087: PPUSH
5088: LD_STRING D6-Mech1-1a
5090: PPUSH
5091: CALL_OW 88
// DialogueOff ;
5095: CALL_OW 7
// powell_happy := false ;
5099: LD_ADDR_VAR 0 6
5103: PUSH
5104: LD_INT 0
5106: ST_TO_ADDR
// end else
5107: GO 5125
// begin powell_happy := true ;
5109: LD_ADDR_VAR 0 6
5113: PUSH
5114: LD_INT 1
5116: ST_TO_ADDR
// take_cargo := true ;
5117: LD_ADDR_VAR 0 7
5121: PUSH
5122: LD_INT 1
5124: ST_TO_ADDR
// end ; end ; 2 :
5125: GO 5214
5127: LD_INT 2
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5135
5133: GO 5174
5135: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5136: LD_EXP 19
5140: PPUSH
5141: LD_STRING D5b-JMM-1
5143: PPUSH
5144: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5148: LD_VAR 0 5
5152: PPUSH
5153: LD_STRING D6-Mech1-1a
5155: PPUSH
5156: CALL_OW 88
// DialogueOff ;
5160: CALL_OW 7
// take_cargo := true ;
5164: LD_ADDR_VAR 0 7
5168: PUSH
5169: LD_INT 1
5171: ST_TO_ADDR
// end ; 3 :
5172: GO 5214
5174: LD_INT 3
5176: DOUBLE
5177: EQUAL
5178: IFTRUE 5182
5180: GO 5213
5182: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5183: LD_EXP 19
5187: PPUSH
5188: LD_STRING D5c-JMM-1
5190: PPUSH
5191: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D6-Mech1-1b
5202: PPUSH
5203: CALL_OW 88
// DialogueOff ;
5207: CALL_OW 7
// end ; end ;
5211: GO 5214
5213: POP
// end else
5214: GO 5244
// begin Say ( JMM , D5c-JMM-1 ) ;
5216: LD_EXP 19
5220: PPUSH
5221: LD_STRING D5c-JMM-1
5223: PPUSH
5224: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5228: LD_VAR 0 5
5232: PPUSH
5233: LD_STRING D6-Mech1-1b
5235: PPUSH
5236: CALL_OW 88
// DialogueOff ;
5240: CALL_OW 7
// end ; if take_cargo then
5244: LD_VAR 0 7
5248: IFFALSE 5327
// begin x := GetTerminalCargo ;
5250: LD_ADDR_VAR 0 2
5254: PUSH
5255: CALL 809 0 0
5259: ST_TO_ADDR
// if x > 60 then
5260: LD_VAR 0 2
5264: PUSH
5265: LD_INT 60
5267: GREATER
5268: IFFALSE 5278
// x := 60 ;
5270: LD_ADDR_VAR 0 2
5274: PUSH
5275: LD_INT 60
5277: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5278: LD_EXP 3
5282: PPUSH
5283: CALL_OW 274
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 809 0 0
5295: PUSH
5296: LD_VAR 0 2
5300: MINUS
5301: PPUSH
5302: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5306: LD_EXP 25
5310: PUSH
5311: LD_INT 3
5313: ARRAY
5314: PPUSH
5315: LD_INT 3
5317: PPUSH
5318: LD_VAR 0 2
5322: PPUSH
5323: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5327: LD_EXP 25
5331: PPUSH
5332: LD_INT 43
5334: PPUSH
5335: LD_INT 3
5337: PPUSH
5338: CALL_OW 171
// x := 0 0$20 ;
5342: LD_ADDR_VAR 0 2
5346: PUSH
5347: LD_INT 700
5349: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// x := x - 0 0$01 ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_VAR 0 2
5366: PUSH
5367: LD_INT 35
5369: MINUS
5370: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5371: LD_VAR 0 2
5375: PUSH
5376: LD_INT 0
5378: EQUAL
5379: PUSH
5380: LD_EXP 25
5384: PUSH
5385: LD_INT 3
5387: ARRAY
5388: PPUSH
5389: LD_INT 43
5391: PPUSH
5392: LD_INT 3
5394: PPUSH
5395: CALL_OW 297
5399: PUSH
5400: LD_INT 4
5402: LESS
5403: PUSH
5404: LD_EXP 25
5408: PUSH
5409: LD_INT 3
5411: ARRAY
5412: PPUSH
5413: LD_INT 43
5415: PPUSH
5416: LD_INT 3
5418: PPUSH
5419: CALL_OW 297
5423: PUSH
5424: LD_INT 4
5426: LESS
5427: AND
5428: OR
5429: IFFALSE 5350
// for i in powell_trans do
5431: LD_ADDR_VAR 0 4
5435: PUSH
5436: LD_EXP 25
5440: PUSH
5441: FOR_IN
5442: IFFALSE 5455
// RemoveUnit ( i ) ;
5444: LD_VAR 0 4
5448: PPUSH
5449: CALL_OW 64
5453: GO 5441
5455: POP
5456: POP
// if not powell_happy then
5457: LD_VAR 0 6
5461: NOT
5462: IFFALSE 5473
// powell_happy := - 1 ;
5464: LD_ADDR_VAR 0 6
5468: PUSH
5469: LD_INT 1
5471: NEG
5472: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5473: LD_STRING EarlySiberite
5475: PPUSH
5476: LD_VAR 0 6
5480: PPUSH
5481: CALL_OW 101
// if powell_happy then
5485: LD_VAR 0 6
5489: IFFALSE 5500
// ChangeMissionObjectives ( M3a ) else
5491: LD_STRING M3a
5493: PPUSH
5494: CALL_OW 337
5498: GO 5507
// ChangeMissionObjectives ( M3b ) ;
5500: LD_STRING M3b
5502: PPUSH
5503: CALL_OW 337
// ru_can_attack_terminal := true ;
5507: LD_ADDR_EXP 9
5511: PUSH
5512: LD_INT 1
5514: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5515: LD_INT 25200
5517: PPUSH
5518: CALL_OW 67
// time := 2 2$00 ;
5522: LD_ADDR_VAR 0 8
5526: PUSH
5527: LD_INT 4200
5529: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5530: LD_INT 35
5532: PPUSH
5533: CALL_OW 67
// time := time - 0 0$1 ;
5537: LD_ADDR_VAR 0 8
5541: PUSH
5542: LD_VAR 0 8
5546: PUSH
5547: LD_INT 35
5549: MINUS
5550: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5551: LD_EXP 8
5555: NOT
5556: PUSH
5557: LD_EXP 36
5561: PUSH
5562: LD_INT 0
5564: EQUAL
5565: OR
5566: PUSH
5567: LD_VAR 0 8
5571: PUSH
5572: LD_INT 0
5574: EQUAL
5575: OR
5576: IFFALSE 5530
// if ru_force then
5578: LD_EXP 36
5582: IFFALSE 5681
// for i in ru_force do
5584: LD_ADDR_VAR 0 4
5588: PUSH
5589: LD_EXP 36
5593: PUSH
5594: FOR_IN
5595: IFFALSE 5679
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5597: LD_INT 1
5599: PPUSH
5600: LD_VAR 0 4
5604: PPUSH
5605: CALL_OW 292
5609: NOT
5610: PUSH
5611: LD_VAR 0 4
5615: PPUSH
5616: LD_INT 81
5618: PUSH
5619: LD_INT 3
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: PPUSH
5631: LD_VAR 0 4
5635: PPUSH
5636: CALL_OW 74
5640: PPUSH
5641: CALL_OW 296
5645: PUSH
5646: LD_INT 10
5648: GREATER
5649: AND
5650: IFFALSE 5677
// begin RemoveUnit ( i ) ;
5652: LD_VAR 0 4
5656: PPUSH
5657: CALL_OW 64
// ru_force := ru_force diff i ;
5661: LD_ADDR_EXP 36
5665: PUSH
5666: LD_EXP 36
5670: PUSH
5671: LD_VAR 0 4
5675: DIFF
5676: ST_TO_ADDR
// end ;
5677: GO 5594
5679: POP
5680: POP
// repeat wait ( 0 0$03 ) ;
5681: LD_INT 105
5683: PPUSH
5684: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5688: LD_EXP 8
5692: NOT
5693: PUSH
5694: LD_EXP 36
5698: PUSH
5699: LD_INT 3
5701: LESS
5702: OR
5703: IFFALSE 5681
// ar_can_arrive := true ;
5705: LD_ADDR_EXP 10
5709: PUSH
5710: LD_INT 1
5712: ST_TO_ADDR
// end ;
5713: PPOPN 8
5715: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5716: LD_INT 1
5718: PPUSH
5719: LD_INT 20
5721: PPUSH
5722: CALL_OW 325
5726: IFFALSE 5867
5728: GO 5730
5730: DISABLE
5731: LD_INT 0
5733: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: LD_INT 22
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: LD_INT 1
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 25
5761: PUSH
5762: LD_INT 4
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 69
5778: PUSH
5779: LD_EXP 19
5783: PUSH
5784: LD_EXP 22
5788: PUSH
5789: LD_EXP 21
5793: PUSH
5794: LD_EXP 23
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: DIFF
5805: ST_TO_ADDR
// if not un then
5806: LD_VAR 0 1
5810: NOT
5811: IFFALSE 5815
// exit ;
5813: GO 5867
// DialogueOn ;
5815: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5819: LD_VAR 0 1
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_STRING D13-Sci1-1
5830: PPUSH
5831: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5835: LD_EXP 19
5839: PPUSH
5840: LD_STRING D13-JMM-1
5842: PPUSH
5843: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5847: LD_VAR 0 1
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PPUSH
5856: LD_STRING D13-Sci1-2
5858: PPUSH
5859: CALL_OW 88
// DialogueOff ;
5863: CALL_OW 7
// end ;
5867: PPOPN 1
5869: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5870: LD_INT 1
5872: PPUSH
5873: CALL 840 0 1
5877: PUSH
5878: LD_INT 77
5880: GREATER
5881: PUSH
5882: LD_EXP 8
5886: NOT
5887: AND
5888: PUSH
5889: LD_INT 22
5891: PUSH
5892: LD_INT 1
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 25
5901: PUSH
5902: LD_INT 4
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: LD_INT 26
5911: PUSH
5912: LD_INT 1
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: PPUSH
5924: CALL_OW 69
5928: PUSH
5929: LD_EXP 19
5933: PUSH
5934: LD_EXP 21
5938: PUSH
5939: LD_EXP 22
5943: PUSH
5944: LD_EXP 20
5948: PUSH
5949: LD_EXP 23
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: DIFF
5961: AND
5962: IFFALSE 6140
5964: GO 5966
5966: DISABLE
5967: LD_INT 0
5969: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5970: LD_ADDR_VAR 0 1
5974: PUSH
5975: LD_INT 22
5977: PUSH
5978: LD_INT 1
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 25
5987: PUSH
5988: LD_INT 4
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: PUSH
6015: LD_EXP 19
6019: PUSH
6020: LD_EXP 21
6024: PUSH
6025: LD_EXP 22
6029: PUSH
6030: LD_EXP 20
6034: PUSH
6035: LD_EXP 23
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: DIFF
6047: ST_TO_ADDR
// DialogueOn ;
6048: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6052: LD_VAR 0 1
6056: PUSH
6057: LD_INT 1
6059: ARRAY
6060: PPUSH
6061: LD_STRING D7-Sci1-1
6063: PPUSH
6064: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6068: LD_EXP 19
6072: PPUSH
6073: LD_STRING D7-JMM-1
6075: PPUSH
6076: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6080: LD_VAR 0 1
6084: PUSH
6085: LD_INT 1
6087: ARRAY
6088: PPUSH
6089: LD_STRING D7-Sci1-2
6091: PPUSH
6092: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6096: LD_EXP 19
6100: PPUSH
6101: LD_STRING D7-JMM-2
6103: PPUSH
6104: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6108: LD_VAR 0 1
6112: PUSH
6113: LD_INT 1
6115: ARRAY
6116: PPUSH
6117: LD_STRING D7-Sci1-3
6119: PPUSH
6120: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6124: LD_EXP 19
6128: PPUSH
6129: LD_STRING D7-JMM-3
6131: PPUSH
6132: CALL_OW 88
// DialogueOff ;
6136: CALL_OW 7
// end ;
6140: PPOPN 1
6142: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6143: LD_EXP 10
6147: IFFALSE 9770
6149: GO 6151
6151: DISABLE
6152: LD_INT 0
6154: PPUSH
6155: PPUSH
6156: PPUSH
6157: PPUSH
6158: PPUSH
6159: PPUSH
6160: PPUSH
6161: PPUSH
6162: PPUSH
6163: PPUSH
// begin PrepareArabian ;
6164: CALL 12346 0 0
// blocked := false ;
6168: LD_ADDR_EXP 18
6172: PUSH
6173: LD_INT 0
6175: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6176: LD_INT 35
6178: PPUSH
6179: CALL_OW 67
// until ar_spawned ;
6183: LD_EXP 11
6187: IFFALSE 6176
// have_crates := true ;
6189: LD_ADDR_VAR 0 9
6193: PUSH
6194: LD_INT 1
6196: ST_TO_ADDR
// player_want_info := 2 ;
6197: LD_ADDR_EXP 13
6201: PUSH
6202: LD_INT 2
6204: ST_TO_ADDR
// DialogueOn ;
6205: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6209: LD_EXP 27
6213: PPUSH
6214: LD_STRING D8-Ar1-1
6216: PPUSH
6217: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6221: LD_EXP 19
6225: PPUSH
6226: LD_STRING D8-JMM-1
6228: PPUSH
6229: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6233: LD_EXP 27
6237: PPUSH
6238: LD_STRING D8-Ar1-2
6240: PPUSH
6241: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6245: LD_EXP 19
6249: PPUSH
6250: LD_STRING D8-JMM-2
6252: PPUSH
6253: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6257: LD_EXP 27
6261: PPUSH
6262: LD_STRING D8-Ar1-3
6264: PPUSH
6265: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6269: LD_EXP 19
6273: PPUSH
6274: LD_STRING D8-JMM-3
6276: PPUSH
6277: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6281: LD_EXP 27
6285: PPUSH
6286: LD_STRING D8-Ar1-4
6288: PPUSH
6289: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6293: LD_EXP 19
6297: PPUSH
6298: LD_STRING D8-JMM-4
6300: PPUSH
6301: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6305: LD_EXP 27
6309: PPUSH
6310: LD_STRING D8-Ar1-5
6312: PPUSH
6313: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6317: LD_EXP 19
6321: PPUSH
6322: LD_STRING D8-JMM-5
6324: PPUSH
6325: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6329: LD_EXP 27
6333: PPUSH
6334: LD_STRING D8-Ar1-6
6336: PPUSH
6337: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6341: LD_EXP 28
6345: PPUSH
6346: LD_STRING D8-Ar2-6
6348: PPUSH
6349: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6353: LD_EXP 19
6357: PPUSH
6358: LD_STRING D8-JMM-6
6360: PPUSH
6361: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6365: LD_EXP 28
6369: PPUSH
6370: LD_STRING D8-Ar2-7
6372: PPUSH
6373: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6377: LD_STRING QBarracks
6379: PPUSH
6380: CALL_OW 97
6384: PUSH
6385: LD_INT 1
6387: DOUBLE
6388: EQUAL
6389: IFTRUE 6393
6391: GO 6428
6393: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6394: LD_EXP 19
6398: PPUSH
6399: LD_STRING D8a-JMM-1
6401: PPUSH
6402: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6406: LD_EXP 27
6410: PPUSH
6411: LD_STRING D8a-Ar1-1
6413: PPUSH
6414: CALL_OW 94
// player_want_mortar := true ;
6418: LD_ADDR_EXP 12
6422: PUSH
6423: LD_INT 1
6425: ST_TO_ADDR
// end ; 2 :
6426: GO 6602
6428: LD_INT 2
6430: DOUBLE
6431: EQUAL
6432: IFTRUE 6436
6434: GO 6558
6436: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6437: LD_EXP 19
6441: PPUSH
6442: LD_STRING D8b-JMM-1
6444: PPUSH
6445: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6449: LD_EXP 27
6453: PPUSH
6454: LD_STRING D8b-Ar1-1
6456: PPUSH
6457: CALL_OW 94
// case Query ( QInfo ) of 1 :
6461: LD_STRING QInfo
6463: PPUSH
6464: CALL_OW 97
6468: PUSH
6469: LD_INT 1
6471: DOUBLE
6472: EQUAL
6473: IFTRUE 6477
6475: GO 6512
6477: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6478: LD_EXP 19
6482: PPUSH
6483: LD_STRING D8b1-JMM-1
6485: PPUSH
6486: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6490: LD_EXP 27
6494: PPUSH
6495: LD_STRING D8b1-Ar1-1
6497: PPUSH
6498: CALL_OW 94
// player_want_info := 2 ;
6502: LD_ADDR_EXP 13
6506: PUSH
6507: LD_INT 2
6509: ST_TO_ADDR
// end ; 2 :
6510: GO 6556
6512: LD_INT 2
6514: DOUBLE
6515: EQUAL
6516: IFTRUE 6520
6518: GO 6555
6520: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6521: LD_EXP 19
6525: PPUSH
6526: LD_STRING D8b2-JMM-1
6528: PPUSH
6529: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6533: LD_EXP 27
6537: PPUSH
6538: LD_STRING D8b2-Ar1-1
6540: PPUSH
6541: CALL_OW 94
// player_want_info := 0 ;
6545: LD_ADDR_EXP 13
6549: PUSH
6550: LD_INT 0
6552: ST_TO_ADDR
// end ; end ;
6553: GO 6556
6555: POP
// end ; 3 :
6556: GO 6602
6558: LD_INT 3
6560: DOUBLE
6561: EQUAL
6562: IFTRUE 6566
6564: GO 6601
6566: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6567: LD_EXP 19
6571: PPUSH
6572: LD_STRING D8c-JMM-1
6574: PPUSH
6575: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6579: LD_EXP 27
6583: PPUSH
6584: LD_STRING D8c-Ar1-1
6586: PPUSH
6587: CALL_OW 94
// player_want_info := 0 ;
6591: LD_ADDR_EXP 13
6595: PUSH
6596: LD_INT 0
6598: ST_TO_ADDR
// end ; end ;
6599: GO 6602
6601: POP
// DialogueOff ;
6602: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6606: LD_ADDR_VAR 0 4
6610: PUSH
6611: LD_INT 9
6613: PPUSH
6614: LD_INT 2
6616: PUSH
6617: LD_INT 30
6619: PUSH
6620: LD_INT 0
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: LD_INT 30
6629: PUSH
6630: LD_INT 1
6632: PUSH
6633: EMPTY
6634: LIST
6635: LIST
6636: PUSH
6637: EMPTY
6638: LIST
6639: LIST
6640: LIST
6641: PPUSH
6642: CALL_OW 70
6646: ST_TO_ADDR
// if dep then
6647: LD_VAR 0 4
6651: IFFALSE 6667
// dep := dep [ 1 ] ;
6653: LD_ADDR_VAR 0 4
6657: PUSH
6658: LD_VAR 0 4
6662: PUSH
6663: LD_INT 1
6665: ARRAY
6666: ST_TO_ADDR
// if not dep then
6667: LD_VAR 0 4
6671: NOT
6672: IFFALSE 6710
// begin case Query ( QInfoNothing ) of 1 :
6674: LD_STRING QInfoNothing
6676: PPUSH
6677: CALL_OW 97
6681: PUSH
6682: LD_INT 1
6684: DOUBLE
6685: EQUAL
6686: IFTRUE 6690
6688: GO 6693
6690: POP
// ; end ;
6691: GO 6694
6693: POP
// player_want_info := false ;
6694: LD_ADDR_EXP 13
6698: PUSH
6699: LD_INT 0
6701: ST_TO_ADDR
// player_want_mortar := false ;
6702: LD_ADDR_EXP 12
6706: PUSH
6707: LD_INT 0
6709: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_INT 22
6717: PUSH
6718: LD_INT 2
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: PUSH
6725: LD_INT 21
6727: PUSH
6728: LD_INT 2
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PPUSH
6739: CALL_OW 69
6743: ST_TO_ADDR
// time := 1 1$55 ;
6744: LD_ADDR_VAR 0 5
6748: PUSH
6749: LD_INT 4025
6751: ST_TO_ADDR
// no_oil_gain := false ;
6752: LD_ADDR_VAR 0 6
6756: PUSH
6757: LD_INT 0
6759: ST_TO_ADDR
// first_warn := false ;
6760: LD_ADDR_VAR 0 7
6764: PUSH
6765: LD_INT 0
6767: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6768: LD_EXP 12
6772: PUSH
6773: LD_EXP 13
6777: OR
6778: IFFALSE 6883
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6780: LD_EXP 34
6784: PPUSH
6785: LD_INT 25
6787: PUSH
6788: LD_INT 1
6790: PUSH
6791: EMPTY
6792: LIST
6793: LIST
6794: PPUSH
6795: CALL_OW 72
6799: PPUSH
6800: LD_VAR 0 4
6804: PPUSH
6805: CALL_OW 250
6809: PPUSH
6810: LD_VAR 0 4
6814: PPUSH
6815: CALL_OW 251
6819: PPUSH
6820: LD_VAR 0 4
6824: PPUSH
6825: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6829: LD_EXP 34
6833: PPUSH
6834: LD_INT 25
6836: PUSH
6837: LD_INT 1
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL_OW 72
6848: PPUSH
6849: LD_INT 86
6851: PPUSH
6852: LD_INT 121
6854: PPUSH
6855: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6859: LD_EXP 34
6863: PPUSH
6864: LD_INT 25
6866: PUSH
6867: LD_INT 1
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PPUSH
6874: CALL_OW 72
6878: PPUSH
6879: CALL_OW 200
// end ; if player_attacked_ar then
6883: LD_EXP 16
6887: IFFALSE 6891
// exit ;
6889: GO 9770
// if player_want_mortar then
6891: LD_EXP 12
6895: IFFALSE 8432
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6897: LD_EXP 28
6901: PPUSH
6902: LD_VAR 0 4
6906: PPUSH
6907: CALL_OW 250
6911: PUSH
6912: LD_INT 1
6914: PLUS
6915: PPUSH
6916: LD_VAR 0 4
6920: PPUSH
6921: CALL_OW 251
6925: PUSH
6926: LD_INT 1
6928: PLUS
6929: PPUSH
6930: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6934: LD_INT 35
6936: PPUSH
6937: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6941: LD_EXP 28
6945: PPUSH
6946: LD_VAR 0 4
6950: PPUSH
6951: CALL_OW 296
6955: PUSH
6956: LD_INT 4
6958: LESS
6959: IFFALSE 6934
// for i = 1 to 6 do
6961: LD_ADDR_VAR 0 1
6965: PUSH
6966: DOUBLE
6967: LD_INT 1
6969: DEC
6970: ST_TO_ADDR
6971: LD_INT 6
6973: PUSH
6974: FOR_TO
6975: IFFALSE 7179
// begin if player_attacked_ar then
6977: LD_EXP 16
6981: IFFALSE 6987
// exit ;
6983: POP
6984: POP
6985: GO 9770
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6987: LD_VAR 0 4
6991: PPUSH
6992: CALL_OW 274
6996: PPUSH
6997: LD_INT 2
6999: PPUSH
7000: CALL_OW 275
7004: PUSH
7005: LD_INT 10
7007: LESS
7008: PUSH
7009: LD_VAR 0 7
7013: NOT
7014: AND
7015: IFFALSE 7078
// begin first_warn := true ;
7017: LD_ADDR_VAR 0 7
7021: PUSH
7022: LD_INT 1
7024: ST_TO_ADDR
// DialogueOn ;
7025: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7029: LD_EXP 29
7033: PPUSH
7034: LD_STRING D9a-FAr1-1
7036: PPUSH
7037: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7041: LD_EXP 19
7045: PPUSH
7046: LD_STRING D9a-JMM-1
7048: PPUSH
7049: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7053: LD_EXP 27
7057: PPUSH
7058: LD_STRING D9a2-Ar1-1
7060: PPUSH
7061: CALL_OW 88
// DialogueOff ;
7065: CALL_OW 7
// wait ( time ) ;
7069: LD_VAR 0 5
7073: PPUSH
7074: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7078: LD_VAR 0 4
7082: PPUSH
7083: CALL_OW 274
7087: PPUSH
7088: LD_INT 2
7090: PPUSH
7091: CALL_OW 275
7095: PUSH
7096: LD_INT 10
7098: LESS
7099: IFFALSE 7125
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7101: LD_EXP 27
7105: PPUSH
7106: LD_STRING D9a3-Ar1-1
7108: PPUSH
7109: CALL_OW 88
// no_oil_gain := true ;
7113: LD_ADDR_VAR 0 6
7117: PUSH
7118: LD_INT 1
7120: ST_TO_ADDR
// break ;
7121: GO 7179
// end else
7123: GO 7177
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7125: LD_EXP 28
7129: PPUSH
7130: LD_VAR 0 4
7134: PPUSH
7135: LD_INT 2
7137: PPUSH
7138: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7142: LD_EXP 28
7146: PPUSH
7147: LD_VAR 0 3
7151: PUSH
7152: LD_VAR 0 1
7156: PUSH
7157: LD_INT 3
7159: MOD
7160: PUSH
7161: LD_INT 1
7163: PLUS
7164: ARRAY
7165: PPUSH
7166: CALL_OW 210
// wait ( 0 0$10 ) ;
7170: LD_INT 350
7172: PPUSH
7173: CALL_OW 67
// end ; end ;
7177: GO 6974
7179: POP
7180: POP
// if not no_oil_gain then
7181: LD_VAR 0 6
7185: NOT
7186: IFFALSE 8432
// begin repeat wait ( 0 0$01 ) ;
7188: LD_INT 35
7190: PPUSH
7191: CALL_OW 67
// if player_attacked_ar then
7195: LD_EXP 16
7199: IFFALSE 7203
// exit ;
7201: GO 9770
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7203: LD_VAR 0 3
7207: PUSH
7208: LD_INT 1
7210: ARRAY
7211: PPUSH
7212: CALL_OW 261
7216: PUSH
7217: LD_INT 80
7219: GREATER
7220: PUSH
7221: LD_VAR 0 3
7225: PUSH
7226: LD_INT 2
7228: ARRAY
7229: PPUSH
7230: CALL_OW 261
7234: PUSH
7235: LD_INT 80
7237: GREATER
7238: AND
7239: PUSH
7240: LD_VAR 0 3
7244: PUSH
7245: LD_INT 3
7247: ARRAY
7248: PPUSH
7249: CALL_OW 261
7253: PUSH
7254: LD_INT 80
7256: GREATER
7257: AND
7258: IFFALSE 7188
// ComMoveXY ( Gali , 105 , 127 ) ;
7260: LD_EXP 28
7264: PPUSH
7265: LD_INT 105
7267: PPUSH
7268: LD_INT 127
7270: PPUSH
7271: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7275: LD_EXP 28
7279: PPUSH
7280: LD_INT 2
7282: PPUSH
7283: CALL_OW 173
// AddComHold ( Gali ) ;
7287: LD_EXP 28
7291: PPUSH
7292: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7296: LD_INT 35
7298: PPUSH
7299: CALL_OW 67
// if player_attacked_ar then
7303: LD_EXP 16
7307: IFFALSE 7311
// exit ;
7309: GO 9770
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7311: LD_EXP 28
7315: PPUSH
7316: LD_INT 105
7318: PPUSH
7319: LD_INT 127
7321: PPUSH
7322: CALL_OW 297
7326: PUSH
7327: LD_INT 4
7329: LESS
7330: IFFALSE 7296
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7332: LD_VAR 0 4
7336: PPUSH
7337: CALL_OW 274
7341: PPUSH
7342: LD_INT 1
7344: PPUSH
7345: CALL_OW 275
7349: PUSH
7350: LD_INT 50
7352: LESS
7353: IFFALSE 7655
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7355: LD_VAR 0 4
7359: PPUSH
7360: CALL_OW 274
7364: PPUSH
7365: LD_INT 1
7367: PPUSH
7368: CALL_OW 275
7372: PUSH
7373: LD_INT 0
7375: DOUBLE
7376: GREATEREQUAL
7377: IFFALSE 7385
7379: LD_INT 24
7381: DOUBLE
7382: LESSEQUAL
7383: IFTRUE 7387
7385: GO 7402
7387: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7388: LD_EXP 28
7392: PPUSH
7393: LD_STRING D9b-Ar2-1
7395: PPUSH
7396: CALL_OW 88
7400: GO 7432
7402: LD_INT 25
7404: DOUBLE
7405: GREATEREQUAL
7406: IFFALSE 7414
7408: LD_INT 49
7410: DOUBLE
7411: LESSEQUAL
7412: IFTRUE 7416
7414: GO 7431
7416: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7417: LD_EXP 28
7421: PPUSH
7422: LD_STRING D9b-Ar2-1a
7424: PPUSH
7425: CALL_OW 88
7429: GO 7432
7431: POP
// Say ( JMM , D9b-JMM-1 ) ;
7432: LD_EXP 19
7436: PPUSH
7437: LD_STRING D9b-JMM-1
7439: PPUSH
7440: CALL_OW 88
// x := 0 0$0 ;
7444: LD_ADDR_VAR 0 2
7448: PUSH
7449: LD_INT 0
7451: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7452: LD_INT 35
7454: PPUSH
7455: CALL_OW 67
// x := x + 0 0$1 ;
7459: LD_ADDR_VAR 0 2
7463: PUSH
7464: LD_VAR 0 2
7468: PUSH
7469: LD_INT 35
7471: PLUS
7472: ST_TO_ADDR
// if player_attacked_ar then
7473: LD_EXP 16
7477: IFFALSE 7481
// exit ;
7479: GO 9770
// until x >= time ;
7481: LD_VAR 0 2
7485: PUSH
7486: LD_VAR 0 5
7490: GREATEREQUAL
7491: IFFALSE 7452
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7493: LD_VAR 0 4
7497: PPUSH
7498: CALL_OW 274
7502: PPUSH
7503: LD_INT 1
7505: PPUSH
7506: CALL_OW 275
7510: PUSH
7511: LD_INT 50
7513: LESS
7514: IFFALSE 7655
// begin have_crates := false ;
7516: LD_ADDR_VAR 0 9
7520: PUSH
7521: LD_INT 0
7523: ST_TO_ADDR
// DialogueOn ;
7524: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7528: LD_EXP 27
7532: PPUSH
7533: LD_STRING D9c-Ar1-1
7535: PPUSH
7536: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7540: LD_EXP 19
7544: PPUSH
7545: LD_STRING D9c-JMM-1
7547: PPUSH
7548: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7552: LD_EXP 27
7556: PPUSH
7557: LD_STRING D9c-Ar1-2
7559: PPUSH
7560: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7564: LD_EXP 29
7568: PPUSH
7569: LD_STRING D9c-FAr1-2
7571: PPUSH
7572: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7576: LD_EXP 27
7580: PPUSH
7581: LD_STRING D9c-Ar1-3
7583: PPUSH
7584: CALL_OW 88
// case Query ( QInfo ) of 1 :
7588: LD_STRING QInfo
7590: PPUSH
7591: CALL_OW 97
7595: PUSH
7596: LD_INT 1
7598: DOUBLE
7599: EQUAL
7600: IFTRUE 7604
7602: GO 7627
7604: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7605: LD_EXP 19
7609: PPUSH
7610: LD_STRING D8b1-JMM-1
7612: PPUSH
7613: CALL_OW 88
// player_want_info := 2 ;
7617: LD_ADDR_EXP 13
7621: PUSH
7622: LD_INT 2
7624: ST_TO_ADDR
// end ; 2 :
7625: GO 7651
7627: LD_INT 2
7629: DOUBLE
7630: EQUAL
7631: IFTRUE 7635
7633: GO 7650
7635: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7636: LD_EXP 27
7640: PPUSH
7641: LD_STRING D8b2-Ar1-1
7643: PPUSH
7644: CALL_OW 88
// end ; end ;
7648: GO 7651
7650: POP
// DialogueOff ;
7651: CALL_OW 7
// end ; end ; if have_crates then
7655: LD_VAR 0 9
7659: IFFALSE 8432
// begin RemoveEnvironmentArea ( mortarArea ) ;
7661: LD_INT 2
7663: PPUSH
7664: CALL_OW 355
// wait ( 1 ) ;
7668: LD_INT 1
7670: PPUSH
7671: CALL_OW 67
// InGameOn ;
7675: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7679: LD_EXP 28
7683: PPUSH
7684: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7688: LD_EXP 28
7692: PPUSH
7693: LD_INT 1
7695: PPUSH
7696: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
7700: LD_ADDR_VAR 0 10
7704: PUSH
7705: LD_INT 22
7707: PUSH
7708: LD_INT 1
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 3
7717: PUSH
7718: LD_INT 23
7720: PUSH
7721: LD_INT 2
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: LD_INT 21
7734: PUSH
7735: LD_INT 1
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PUSH
7742: LD_INT 92
7744: PUSH
7745: LD_INT 107
7747: PUSH
7748: LD_INT 131
7750: PUSH
7751: LD_INT 6
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 69
7770: ST_TO_ADDR
// if filter then
7771: LD_VAR 0 10
7775: IFFALSE 7809
// for i in filter do
7777: LD_ADDR_VAR 0 1
7781: PUSH
7782: LD_VAR 0 10
7786: PUSH
7787: FOR_IN
7788: IFFALSE 7807
// ComMoveXY ( i , 107 , 121 ) ;
7790: LD_VAR 0 1
7794: PPUSH
7795: LD_INT 107
7797: PPUSH
7798: LD_INT 121
7800: PPUSH
7801: CALL_OW 111
7805: GO 7787
7807: POP
7808: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7809: LD_EXP 28
7813: PPUSH
7814: LD_INT 4
7816: PPUSH
7817: LD_INT 107
7819: PPUSH
7820: LD_INT 131
7822: PPUSH
7823: LD_INT 0
7825: PPUSH
7826: CALL_OW 145
// wait ( 0 0$1 ) ;
7830: LD_INT 35
7832: PPUSH
7833: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7837: LD_INT 30
7839: PUSH
7840: LD_INT 4
7842: PUSH
7843: EMPTY
7844: LIST
7845: LIST
7846: PUSH
7847: LD_INT 23
7849: PUSH
7850: LD_INT 2
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 69
7865: IFFALSE 7700
// SetSide ( Gali , 2 ) ;
7867: LD_EXP 28
7871: PPUSH
7872: LD_INT 2
7874: PPUSH
7875: CALL_OW 235
// InGameOff ;
7879: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7883: LD_ADDR_VAR 0 8
7887: PUSH
7888: LD_INT 30
7890: PUSH
7891: LD_INT 4
7893: PUSH
7894: EMPTY
7895: LIST
7896: LIST
7897: PUSH
7898: LD_INT 23
7900: PUSH
7901: LD_INT 2
7903: PUSH
7904: EMPTY
7905: LIST
7906: LIST
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7921: LD_INT 35
7923: PPUSH
7924: CALL_OW 67
// if player_attacked_ar then
7928: LD_EXP 16
7932: IFFALSE 7936
// exit ;
7934: GO 9770
// until BuildingStatus ( b ) <> bs_build ;
7936: LD_VAR 0 8
7940: PPUSH
7941: CALL_OW 461
7945: PUSH
7946: LD_INT 1
7948: NONEQUAL
7949: IFFALSE 7921
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7951: LD_VAR 0 8
7955: PPUSH
7956: CALL_OW 302
7960: PUSH
7961: LD_VAR 0 4
7965: PPUSH
7966: CALL_OW 274
7970: PPUSH
7971: LD_INT 1
7973: PPUSH
7974: CALL_OW 275
7978: PUSH
7979: LD_INT 25
7981: GREATEREQUAL
7982: AND
7983: IFFALSE 8082
// begin ComUpgrade ( b ) ;
7985: LD_VAR 0 8
7989: PPUSH
7990: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7994: LD_EXP 28
7998: PPUSH
7999: LD_STRING h
8001: PUSH
8002: LD_VAR 0 8
8006: PPUSH
8007: CALL_OW 250
8011: PUSH
8012: LD_VAR 0 8
8016: PPUSH
8017: CALL_OW 251
8021: PUSH
8022: LD_VAR 0 8
8026: PUSH
8027: LD_INT 0
8029: PUSH
8030: LD_INT 0
8032: PUSH
8033: LD_INT 0
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: EMPTY
8046: LIST
8047: PPUSH
8048: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8052: LD_INT 35
8054: PPUSH
8055: CALL_OW 67
// if player_attacked_ar then
8059: LD_EXP 16
8063: IFFALSE 8067
// exit ;
8065: GO 9770
// until BuildingStatus ( b ) <> bs_build ;
8067: LD_VAR 0 8
8071: PPUSH
8072: CALL_OW 461
8076: PUSH
8077: LD_INT 1
8079: NONEQUAL
8080: IFFALSE 8052
// end ; if b then
8082: LD_VAR 0 8
8086: IFFALSE 8097
// CenterNowOnUnits ( b ) ;
8088: LD_VAR 0 8
8092: PPUSH
8093: CALL_OW 87
// DialogueOn ;
8097: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8101: LD_EXP 28
8105: PPUSH
8106: LD_STRING D9d-Ar2-1
8108: PPUSH
8109: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8113: LD_EXP 27
8117: PPUSH
8118: LD_STRING D9d-Ar1-1
8120: PPUSH
8121: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8125: LD_EXP 19
8129: PPUSH
8130: LD_STRING D9d-JMM-1
8132: PPUSH
8133: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8137: LD_EXP 27
8141: PPUSH
8142: LD_STRING D9d-Ar1-2
8144: PPUSH
8145: CALL_OW 88
// DialogueOff ;
8149: CALL_OW 7
// i := [ ] ;
8153: LD_ADDR_VAR 0 1
8157: PUSH
8158: EMPTY
8159: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8160: LD_VAR 0 4
8164: PPUSH
8165: CALL_OW 274
8169: PPUSH
8170: LD_INT 3
8172: PPUSH
8173: CALL_OW 275
8177: PUSH
8178: LD_INT 20
8180: GREATEREQUAL
8181: IFFALSE 8200
// i := i ^ [ 1 ] ;
8183: LD_ADDR_VAR 0 1
8187: PUSH
8188: LD_VAR 0 1
8192: PUSH
8193: LD_INT 1
8195: PUSH
8196: EMPTY
8197: LIST
8198: ADD
8199: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8200: LD_VAR 0 4
8204: PPUSH
8205: CALL_OW 274
8209: PPUSH
8210: LD_INT 1
8212: PPUSH
8213: CALL_OW 275
8217: PUSH
8218: LD_INT 50
8220: GREATEREQUAL
8221: IFFALSE 8240
// i := i ^ [ 2 ] ;
8223: LD_ADDR_VAR 0 1
8227: PUSH
8228: LD_VAR 0 1
8232: PUSH
8233: LD_INT 2
8235: PUSH
8236: EMPTY
8237: LIST
8238: ADD
8239: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8240: LD_VAR 0 4
8244: PPUSH
8245: CALL_OW 274
8249: PPUSH
8250: LD_INT 2
8252: PPUSH
8253: CALL_OW 275
8257: PUSH
8258: LD_INT 80
8260: GREATEREQUAL
8261: IFFALSE 8280
// i := i ^ [ 3 ] ;
8263: LD_ADDR_VAR 0 1
8267: PUSH
8268: LD_VAR 0 1
8272: PUSH
8273: LD_INT 3
8275: PUSH
8276: EMPTY
8277: LIST
8278: ADD
8279: ST_TO_ADDR
// i := i diff 0 ;
8280: LD_ADDR_VAR 0 1
8284: PUSH
8285: LD_VAR 0 1
8289: PUSH
8290: LD_INT 0
8292: DIFF
8293: ST_TO_ADDR
// if i then
8294: LD_VAR 0 1
8298: IFFALSE 8404
// begin i := i ^ [ 4 ] ;
8300: LD_ADDR_VAR 0 1
8304: PUSH
8305: LD_VAR 0 1
8309: PUSH
8310: LD_INT 4
8312: PUSH
8313: EMPTY
8314: LIST
8315: ADD
8316: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8317: LD_STRING QInfo2
8319: PPUSH
8320: CALL_OW 97
8324: PUSH
8325: LD_INT 1
8327: DOUBLE
8328: EQUAL
8329: IFTRUE 8333
8331: GO 8344
8333: POP
// player_want_info := 3 ; 2 :
8334: LD_ADDR_EXP 13
8338: PUSH
8339: LD_INT 3
8341: ST_TO_ADDR
8342: GO 8402
8344: LD_INT 2
8346: DOUBLE
8347: EQUAL
8348: IFTRUE 8352
8350: GO 8363
8352: POP
// player_want_info := 1 ; 3 :
8353: LD_ADDR_EXP 13
8357: PUSH
8358: LD_INT 1
8360: ST_TO_ADDR
8361: GO 8402
8363: LD_INT 3
8365: DOUBLE
8366: EQUAL
8367: IFTRUE 8371
8369: GO 8382
8371: POP
// player_want_info := 2 ; 4 :
8372: LD_ADDR_EXP 13
8376: PUSH
8377: LD_INT 2
8379: ST_TO_ADDR
8380: GO 8402
8382: LD_INT 4
8384: DOUBLE
8385: EQUAL
8386: IFTRUE 8390
8388: GO 8401
8390: POP
// player_want_info := 0 ; end ;
8391: LD_ADDR_EXP 13
8395: PUSH
8396: LD_INT 0
8398: ST_TO_ADDR
8399: GO 8402
8401: POP
// end else
8402: GO 8432
// case Query ( QInfoNothing ) of 1 :
8404: LD_STRING QInfoNothing
8406: PPUSH
8407: CALL_OW 97
8411: PUSH
8412: LD_INT 1
8414: DOUBLE
8415: EQUAL
8416: IFTRUE 8420
8418: GO 8431
8420: POP
// player_want_info := 0 ; end ;
8421: LD_ADDR_EXP 13
8425: PUSH
8426: LD_INT 0
8428: ST_TO_ADDR
8429: GO 8432
8431: POP
// end ; end ; end ; if player_want_info then
8432: LD_EXP 13
8436: IFFALSE 9590
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8438: LD_ADDR_VAR 0 3
8442: PUSH
8443: LD_VAR 0 3
8447: PPUSH
8448: LD_INT 34
8450: PUSH
8451: LD_INT 32
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: PPUSH
8458: CALL_OW 72
8462: ST_TO_ADDR
// if player_want_mortar then
8463: LD_EXP 12
8467: IFFALSE 8822
// begin case player_want_info of 1 :
8469: LD_EXP 13
8473: PUSH
8474: LD_INT 1
8476: DOUBLE
8477: EQUAL
8478: IFTRUE 8482
8480: GO 8493
8482: POP
// x := 5 ; 2 :
8483: LD_ADDR_VAR 0 2
8487: PUSH
8488: LD_INT 5
8490: ST_TO_ADDR
8491: GO 8532
8493: LD_INT 2
8495: DOUBLE
8496: EQUAL
8497: IFTRUE 8501
8499: GO 8512
8501: POP
// x := 8 ; 3 :
8502: LD_ADDR_VAR 0 2
8506: PUSH
8507: LD_INT 8
8509: ST_TO_ADDR
8510: GO 8532
8512: LD_INT 3
8514: DOUBLE
8515: EQUAL
8516: IFTRUE 8520
8518: GO 8531
8520: POP
// x := 2 ; end ;
8521: LD_ADDR_VAR 0 2
8525: PUSH
8526: LD_INT 2
8528: ST_TO_ADDR
8529: GO 8532
8531: POP
// repeat wait ( 0 0$1 ) ;
8532: LD_INT 35
8534: PPUSH
8535: CALL_OW 67
// until not HasTask ( Gali ) ;
8539: LD_EXP 28
8543: PPUSH
8544: CALL_OW 314
8548: NOT
8549: IFFALSE 8532
// time := 0 0$00 ;
8551: LD_ADDR_VAR 0 5
8555: PUSH
8556: LD_INT 0
8558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8559: LD_INT 35
8561: PPUSH
8562: CALL_OW 67
// time := time + 0 0$1 ;
8566: LD_ADDR_VAR 0 5
8570: PUSH
8571: LD_VAR 0 5
8575: PUSH
8576: LD_INT 35
8578: PLUS
8579: ST_TO_ADDR
// if debug then
8580: LD_EXP 2
8584: IFFALSE 8603
// debug_strings := [ time: & time ] ;
8586: LD_ADDR_OWVAR 48
8590: PUSH
8591: LD_STRING time:
8593: PUSH
8594: LD_VAR 0 5
8598: STR
8599: PUSH
8600: EMPTY
8601: LIST
8602: ST_TO_ADDR
// if time > 8 8$00 then
8603: LD_VAR 0 5
8607: PUSH
8608: LD_INT 16800
8610: GREATER
8611: IFFALSE 8623
// begin blocked := true ;
8613: LD_ADDR_EXP 18
8617: PUSH
8618: LD_INT 1
8620: ST_TO_ADDR
// exit ;
8621: GO 9770
// end ; if not Carry ( Gali ) then
8623: LD_EXP 28
8627: PPUSH
8628: CALL_OW 281
8632: NOT
8633: IFFALSE 8656
// ComTransport ( Gali , dep , player_want_info ) else
8635: LD_EXP 28
8639: PPUSH
8640: LD_VAR 0 4
8644: PPUSH
8645: LD_EXP 13
8649: PPUSH
8650: CALL_OW 151
8654: GO 8774
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8656: LD_EXP 28
8660: PPUSH
8661: LD_VAR 0 3
8665: PUSH
8666: LD_INT 1
8668: ARRAY
8669: PPUSH
8670: CALL_OW 296
8674: PUSH
8675: LD_INT 4
8677: LESS
8678: PUSH
8679: LD_EXP 28
8683: PPUSH
8684: LD_EXP 13
8688: PPUSH
8689: CALL_OW 289
8693: AND
8694: IFFALSE 8756
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8696: LD_VAR 0 3
8700: PUSH
8701: LD_INT 1
8703: ARRAY
8704: PPUSH
8705: LD_EXP 13
8709: PPUSH
8710: LD_VAR 0 3
8714: PUSH
8715: LD_INT 1
8717: ARRAY
8718: PPUSH
8719: LD_EXP 13
8723: PPUSH
8724: CALL_OW 289
8728: PUSH
8729: LD_INT 10
8731: PLUS
8732: PPUSH
8733: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8737: LD_EXP 28
8741: PPUSH
8742: LD_EXP 13
8746: PPUSH
8747: LD_INT 0
8749: PPUSH
8750: CALL_OW 290
// end else
8754: GO 8774
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8756: LD_EXP 28
8760: PPUSH
8761: LD_VAR 0 3
8765: PUSH
8766: LD_INT 1
8768: ARRAY
8769: PPUSH
8770: CALL_OW 112
// end ; if player_attacked_ar then
8774: LD_EXP 16
8778: IFFALSE 8782
// exit ;
8780: GO 9770
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
8782: LD_VAR 0 3
8786: PUSH
8787: LD_INT 1
8789: ARRAY
8790: PPUSH
8791: LD_EXP 13
8795: PPUSH
8796: CALL_OW 289
8800: PUSH
8801: LD_VAR 0 2
8805: PUSH
8806: LD_INT 10
8808: MUL
8809: GREATEREQUAL
8810: IFFALSE 8559
// no_oil_gain := false ;
8812: LD_ADDR_VAR 0 6
8816: PUSH
8817: LD_INT 0
8819: ST_TO_ADDR
// end else
8820: GO 9411
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8822: LD_ADDR_VAR 0 3
8826: PUSH
8827: LD_INT 22
8829: PUSH
8830: LD_INT 2
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: PUSH
8837: LD_INT 21
8839: PUSH
8840: LD_INT 2
8842: PUSH
8843: EMPTY
8844: LIST
8845: LIST
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PPUSH
8851: CALL_OW 69
8855: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8856: LD_EXP 28
8860: PPUSH
8861: LD_VAR 0 4
8865: PPUSH
8866: CALL_OW 250
8870: PUSH
8871: LD_INT 1
8873: PLUS
8874: PPUSH
8875: LD_VAR 0 4
8879: PPUSH
8880: CALL_OW 251
8884: PUSH
8885: LD_INT 1
8887: PLUS
8888: PPUSH
8889: CALL_OW 111
// time := 0 0$00 ;
8893: LD_ADDR_VAR 0 5
8897: PUSH
8898: LD_INT 0
8900: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8901: LD_INT 35
8903: PPUSH
8904: CALL_OW 67
// time := time + 0 0$1 ;
8908: LD_ADDR_VAR 0 5
8912: PUSH
8913: LD_VAR 0 5
8917: PUSH
8918: LD_INT 35
8920: PLUS
8921: ST_TO_ADDR
// if time > 1 1$45 then
8922: LD_VAR 0 5
8926: PUSH
8927: LD_INT 3675
8929: GREATER
8930: IFFALSE 8934
// break ;
8932: GO 8954
// until GetDistUnits ( Gali , dep ) < 4 ;
8934: LD_EXP 28
8938: PPUSH
8939: LD_VAR 0 4
8943: PPUSH
8944: CALL_OW 296
8948: PUSH
8949: LD_INT 4
8951: LESS
8952: IFFALSE 8901
// for i = 1 to 6 do
8954: LD_ADDR_VAR 0 1
8958: PUSH
8959: DOUBLE
8960: LD_INT 1
8962: DEC
8963: ST_TO_ADDR
8964: LD_INT 6
8966: PUSH
8967: FOR_TO
8968: IFFALSE 9172
// begin if player_attacked_ar then
8970: LD_EXP 16
8974: IFFALSE 8980
// exit ;
8976: POP
8977: POP
8978: GO 9770
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8980: LD_VAR 0 4
8984: PPUSH
8985: CALL_OW 274
8989: PPUSH
8990: LD_INT 2
8992: PPUSH
8993: CALL_OW 275
8997: PUSH
8998: LD_INT 10
9000: LESS
9001: PUSH
9002: LD_VAR 0 7
9006: NOT
9007: AND
9008: IFFALSE 9071
// begin first_warn := true ;
9010: LD_ADDR_VAR 0 7
9014: PUSH
9015: LD_INT 1
9017: ST_TO_ADDR
// DialogueOn ;
9018: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9022: LD_EXP 29
9026: PPUSH
9027: LD_STRING D9a-FAr1-1
9029: PPUSH
9030: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9034: LD_EXP 19
9038: PPUSH
9039: LD_STRING D9a-JMM-1
9041: PPUSH
9042: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9046: LD_EXP 27
9050: PPUSH
9051: LD_STRING D9a2-Ar1-1
9053: PPUSH
9054: CALL_OW 88
// DialogueOff ;
9058: CALL_OW 7
// wait ( time ) ;
9062: LD_VAR 0 5
9066: PPUSH
9067: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9071: LD_VAR 0 4
9075: PPUSH
9076: CALL_OW 274
9080: PPUSH
9081: LD_INT 2
9083: PPUSH
9084: CALL_OW 275
9088: PUSH
9089: LD_INT 10
9091: LESS
9092: IFFALSE 9118
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9094: LD_EXP 27
9098: PPUSH
9099: LD_STRING D9a3-Ar1-1
9101: PPUSH
9102: CALL_OW 88
// no_oil_gain := true ;
9106: LD_ADDR_VAR 0 6
9110: PUSH
9111: LD_INT 1
9113: ST_TO_ADDR
// break ;
9114: GO 9172
// end else
9116: GO 9170
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9118: LD_EXP 28
9122: PPUSH
9123: LD_VAR 0 4
9127: PPUSH
9128: LD_INT 2
9130: PPUSH
9131: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9135: LD_EXP 28
9139: PPUSH
9140: LD_VAR 0 3
9144: PUSH
9145: LD_VAR 0 1
9149: PUSH
9150: LD_INT 3
9152: MOD
9153: PUSH
9154: LD_INT 1
9156: PLUS
9157: ARRAY
9158: PPUSH
9159: CALL_OW 210
// wait ( 0 0$10 ) ;
9163: LD_INT 350
9165: PPUSH
9166: CALL_OW 67
// end ; end ;
9170: GO 8967
9172: POP
9173: POP
// time := 0 0$00 ;
9174: LD_ADDR_VAR 0 5
9178: PUSH
9179: LD_INT 0
9181: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9182: LD_INT 35
9184: PPUSH
9185: CALL_OW 67
// if not HasTask ( Gali ) then
9189: LD_EXP 28
9193: PPUSH
9194: CALL_OW 314
9198: NOT
9199: IFFALSE 9215
// time := time + 0 0$1 ;
9201: LD_ADDR_VAR 0 5
9205: PUSH
9206: LD_VAR 0 5
9210: PUSH
9211: LD_INT 35
9213: PLUS
9214: ST_TO_ADDR
// if time > 1 1$25 then
9215: LD_VAR 0 5
9219: PUSH
9220: LD_INT 2975
9222: GREATER
9223: IFFALSE 9247
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9225: LD_EXP 27
9229: PPUSH
9230: LD_STRING D9a3-Ar1-1
9232: PPUSH
9233: CALL_OW 88
// no_oil_gain := true ;
9237: LD_ADDR_VAR 0 6
9241: PUSH
9242: LD_INT 1
9244: ST_TO_ADDR
// break ;
9245: GO 9411
// end ; if player_attacked_ar then
9247: LD_EXP 16
9251: IFFALSE 9255
// exit ;
9253: GO 9770
// for i in tmp do
9255: LD_ADDR_VAR 0 1
9259: PUSH
9260: LD_VAR 0 3
9264: PUSH
9265: FOR_IN
9266: IFFALSE 9297
// if GetFuel ( i ) < 100 then
9268: LD_VAR 0 1
9272: PPUSH
9273: CALL_OW 261
9277: PUSH
9278: LD_INT 100
9280: LESS
9281: IFFALSE 9295
// begin x := i ;
9283: LD_ADDR_VAR 0 2
9287: PUSH
9288: LD_VAR 0 1
9292: ST_TO_ADDR
// break ;
9293: GO 9297
// end ;
9295: GO 9265
9297: POP
9298: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9299: LD_EXP 28
9303: PPUSH
9304: CALL_OW 314
9308: NOT
9309: PUSH
9310: LD_EXP 28
9314: PPUSH
9315: CALL_OW 281
9319: NOT
9320: AND
9321: IFFALSE 9354
// begin ComTransport ( Gali , dep , mat_oil ) ;
9323: LD_EXP 28
9327: PPUSH
9328: LD_VAR 0 4
9332: PPUSH
9333: LD_INT 2
9335: PPUSH
9336: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9340: LD_EXP 28
9344: PPUSH
9345: LD_VAR 0 2
9349: PPUSH
9350: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9354: LD_VAR 0 3
9358: PUSH
9359: LD_INT 1
9361: ARRAY
9362: PPUSH
9363: CALL_OW 261
9367: PUSH
9368: LD_INT 80
9370: GREATER
9371: PUSH
9372: LD_VAR 0 3
9376: PUSH
9377: LD_INT 2
9379: ARRAY
9380: PPUSH
9381: CALL_OW 261
9385: PUSH
9386: LD_INT 80
9388: GREATER
9389: AND
9390: PUSH
9391: LD_VAR 0 3
9395: PUSH
9396: LD_INT 3
9398: ARRAY
9399: PPUSH
9400: CALL_OW 261
9404: PUSH
9405: LD_INT 80
9407: GREATER
9408: AND
9409: IFFALSE 9182
// end ; ComHold ( Gali ) ;
9411: LD_EXP 28
9415: PPUSH
9416: CALL_OW 140
// if not no_oil_gain then
9420: LD_VAR 0 6
9424: NOT
9425: IFFALSE 9590
// begin DialogueOn ;
9427: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9431: LD_EXP 27
9435: PPUSH
9436: CALL_OW 87
// if player_want_mortar then
9440: LD_EXP 12
9444: IFFALSE 9470
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9446: LD_EXP 27
9450: PPUSH
9451: LD_STRING D9e-Ar1-1
9453: PPUSH
9454: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9458: LD_EXP 19
9462: PPUSH
9463: LD_STRING D10a-JMM-1
9465: PPUSH
9466: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9470: LD_EXP 27
9474: PPUSH
9475: LD_STRING D10a-Ar1-1
9477: PPUSH
9478: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9482: LD_EXP 28
9486: PPUSH
9487: LD_STRING D10a-Ar2-1
9489: PPUSH
9490: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9494: LD_EXP 29
9498: PPUSH
9499: LD_STRING D10a-FAr1-1
9501: PPUSH
9502: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9506: LD_EXP 28
9510: PPUSH
9511: LD_STRING D10a-Ar2-2
9513: PPUSH
9514: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9518: LD_EXP 29
9522: PPUSH
9523: LD_STRING D10a-FAr1-2
9525: PPUSH
9526: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9530: LD_EXP 27
9534: PPUSH
9535: LD_STRING D10a-Ar1-2
9537: PPUSH
9538: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9542: LD_EXP 19
9546: PPUSH
9547: LD_STRING D10a-JMM-2
9549: PPUSH
9550: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9554: LD_EXP 27
9558: PPUSH
9559: LD_STRING D10a-Ar1-3
9561: PPUSH
9562: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9566: LD_EXP 19
9570: PPUSH
9571: LD_STRING D10a-JMM-3
9573: PPUSH
9574: CALL_OW 88
// player_get_info := true ;
9578: LD_ADDR_EXP 15
9582: PUSH
9583: LD_INT 1
9585: ST_TO_ADDR
// DialogueOff ;
9586: CALL_OW 7
// end ; end ; if player_attacked_ar then
9590: LD_EXP 16
9594: IFFALSE 9598
// exit ;
9596: GO 9770
// if player_want_mortar or player_want_info then
9598: LD_EXP 12
9602: PUSH
9603: LD_EXP 13
9607: OR
9608: IFFALSE 9622
// Say ( Vervecken , D9f-Ar1-1 ) ;
9610: LD_EXP 27
9614: PPUSH
9615: LD_STRING D9f-Ar1-1
9617: PPUSH
9618: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9622: LD_INT 22
9624: PUSH
9625: LD_INT 2
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: PPUSH
9632: CALL_OW 69
9636: PPUSH
9637: LD_INT 51
9639: PPUSH
9640: LD_INT 99
9642: PPUSH
9643: CALL_OW 111
// wait ( 0 0$1 ) ;
9647: LD_INT 35
9649: PPUSH
9650: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9654: LD_INT 22
9656: PUSH
9657: LD_INT 2
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 92
9666: PUSH
9667: LD_INT 51
9669: PUSH
9670: LD_INT 99
9672: PUSH
9673: LD_INT 2
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PPUSH
9686: CALL_OW 69
9690: IFFALSE 9750
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9692: LD_ADDR_VAR 0 1
9696: PUSH
9697: LD_INT 22
9699: PUSH
9700: LD_INT 2
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 92
9709: PUSH
9710: LD_INT 51
9712: PUSH
9713: LD_INT 99
9715: PUSH
9716: LD_INT 2
9718: PUSH
9719: EMPTY
9720: LIST
9721: LIST
9722: LIST
9723: LIST
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: PPUSH
9729: CALL_OW 69
9733: PUSH
9734: FOR_IN
9735: IFFALSE 9748
// RemoveUnit ( i ) ;
9737: LD_VAR 0 1
9741: PPUSH
9742: CALL_OW 64
9746: GO 9734
9748: POP
9749: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9750: LD_INT 22
9752: PUSH
9753: LD_INT 2
9755: PUSH
9756: EMPTY
9757: LIST
9758: LIST
9759: PPUSH
9760: CALL_OW 69
9764: PUSH
9765: LD_INT 0
9767: EQUAL
9768: IFFALSE 9622
// end ;
9770: PPOPN 10
9772: END
// every 0 0$01 trigger blocked do var i ;
9773: LD_EXP 18
9777: IFFALSE 9945
9779: GO 9781
9781: DISABLE
9782: LD_INT 0
9784: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9785: LD_EXP 27
9789: PPUSH
9790: LD_STRING D9f-Ar1-1
9792: PPUSH
9793: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9797: LD_INT 22
9799: PUSH
9800: LD_INT 2
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PPUSH
9807: CALL_OW 69
9811: PPUSH
9812: LD_INT 51
9814: PPUSH
9815: LD_INT 99
9817: PPUSH
9818: CALL_OW 111
// wait ( 0 0$1 ) ;
9822: LD_INT 35
9824: PPUSH
9825: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9829: LD_INT 22
9831: PUSH
9832: LD_INT 2
9834: PUSH
9835: EMPTY
9836: LIST
9837: LIST
9838: PUSH
9839: LD_INT 92
9841: PUSH
9842: LD_INT 51
9844: PUSH
9845: LD_INT 99
9847: PUSH
9848: LD_INT 2
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: LIST
9855: LIST
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: PPUSH
9861: CALL_OW 69
9865: IFFALSE 9925
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9867: LD_ADDR_VAR 0 1
9871: PUSH
9872: LD_INT 22
9874: PUSH
9875: LD_INT 2
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: PUSH
9882: LD_INT 92
9884: PUSH
9885: LD_INT 51
9887: PUSH
9888: LD_INT 99
9890: PUSH
9891: LD_INT 2
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PPUSH
9904: CALL_OW 69
9908: PUSH
9909: FOR_IN
9910: IFFALSE 9923
// RemoveUnit ( i ) ;
9912: LD_VAR 0 1
9916: PPUSH
9917: CALL_OW 64
9921: GO 9909
9923: POP
9924: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9925: LD_INT 22
9927: PUSH
9928: LD_INT 2
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 69
9939: PUSH
9940: LD_INT 0
9942: EQUAL
9943: IFFALSE 9797
// end ;
9945: PPOPN 1
9947: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9948: LD_EXP 16
9952: IFFALSE 10305
9954: GO 9956
9956: DISABLE
9957: LD_INT 0
9959: PPUSH
9960: PPUSH
9961: PPUSH
9962: PPUSH
// begin ru_can_attack := true ;
9963: LD_ADDR_EXP 8
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// mine_launched := false ;
9971: LD_ADDR_VAR 0 3
9975: PUSH
9976: LD_INT 0
9978: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9979: LD_INT 22
9981: PUSH
9982: LD_INT 2
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: PPUSH
9989: CALL_OW 69
9993: PPUSH
9994: LD_INT 51
9996: PPUSH
9997: LD_INT 99
9999: PPUSH
10000: CALL_OW 111
// if IsOk ( Vervecken ) then
10004: LD_EXP 27
10008: PPUSH
10009: CALL_OW 302
10013: IFFALSE 10027
// Say ( Vervecken , D11a-Ar1-1 ) ;
10015: LD_EXP 27
10019: PPUSH
10020: LD_STRING D11a-Ar1-1
10022: PPUSH
10023: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10027: LD_ADDR_VAR 0 2
10031: PUSH
10032: LD_EXP 34
10036: PPUSH
10037: LD_INT 25
10039: PUSH
10040: LD_INT 1
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PPUSH
10047: CALL_OW 72
10051: ST_TO_ADDR
// for i in tmp do
10052: LD_ADDR_VAR 0 1
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: FOR_IN
10063: IFFALSE 10126
// if MineOfUnit ( i ) then
10065: LD_VAR 0 1
10069: PPUSH
10070: CALL_OW 459
10074: IFFALSE 10124
// begin x := MineOfUnit ( i ) ;
10076: LD_ADDR_VAR 0 4
10080: PUSH
10081: LD_VAR 0 1
10085: PPUSH
10086: CALL_OW 459
10090: ST_TO_ADDR
// mine_launched := true ;
10091: LD_ADDR_VAR 0 3
10095: PUSH
10096: LD_INT 1
10098: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10099: LD_VAR 0 4
10103: PUSH
10104: LD_INT 1
10106: ARRAY
10107: PPUSH
10108: LD_VAR 0 4
10112: PUSH
10113: LD_INT 2
10115: ARRAY
10116: PPUSH
10117: LD_INT 2
10119: PPUSH
10120: CALL_OW 456
// end ;
10124: GO 10062
10126: POP
10127: POP
// if mine_launched and IsOk ( Vervecken ) then
10128: LD_VAR 0 3
10132: PUSH
10133: LD_EXP 27
10137: PPUSH
10138: CALL_OW 302
10142: AND
10143: IFFALSE 10157
// Say ( Vervecken , D11b-Ar1-1 ) ;
10145: LD_EXP 27
10149: PPUSH
10150: LD_STRING D11b-Ar1-1
10152: PPUSH
10153: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10157: LD_INT 22
10159: PUSH
10160: LD_INT 2
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 69
10171: PPUSH
10172: LD_INT 51
10174: PPUSH
10175: LD_INT 99
10177: PPUSH
10178: CALL_OW 111
// wait ( 0 0$1 ) ;
10182: LD_INT 35
10184: PPUSH
10185: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10189: LD_INT 22
10191: PUSH
10192: LD_INT 2
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PUSH
10199: LD_INT 92
10201: PUSH
10202: LD_INT 51
10204: PUSH
10205: LD_INT 99
10207: PUSH
10208: LD_INT 2
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PPUSH
10221: CALL_OW 69
10225: IFFALSE 10285
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10227: LD_ADDR_VAR 0 1
10231: PUSH
10232: LD_INT 22
10234: PUSH
10235: LD_INT 2
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PUSH
10242: LD_INT 92
10244: PUSH
10245: LD_INT 51
10247: PUSH
10248: LD_INT 99
10250: PUSH
10251: LD_INT 2
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: LIST
10258: LIST
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PPUSH
10264: CALL_OW 69
10268: PUSH
10269: FOR_IN
10270: IFFALSE 10283
// RemoveUnit ( i ) ;
10272: LD_VAR 0 1
10276: PPUSH
10277: CALL_OW 64
10281: GO 10269
10283: POP
10284: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10285: LD_INT 22
10287: PUSH
10288: LD_INT 2
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: PUSH
10300: LD_INT 0
10302: EQUAL
10303: IFFALSE 10157
// end ;
10305: PPOPN 4
10307: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10308: LD_EXP 10
10312: IFFALSE 10491
10314: GO 10316
10316: DISABLE
10317: LD_INT 0
10319: PPUSH
// begin Wait ( 10 10$00 ) ;
10320: LD_INT 21000
10322: PPUSH
10323: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10327: LD_INT 22
10329: PUSH
10330: LD_INT 2
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PPUSH
10337: CALL_OW 69
10341: IFFALSE 10491
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10343: LD_INT 22
10345: PUSH
10346: LD_INT 2
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: PPUSH
10353: CALL_OW 69
10357: PPUSH
10358: LD_INT 51
10360: PPUSH
10361: LD_INT 99
10363: PPUSH
10364: CALL_OW 114
// wait ( 0 0$1 ) ;
10368: LD_INT 35
10370: PPUSH
10371: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10375: LD_INT 22
10377: PUSH
10378: LD_INT 2
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PUSH
10385: LD_INT 92
10387: PUSH
10388: LD_INT 51
10390: PUSH
10391: LD_INT 99
10393: PUSH
10394: LD_INT 2
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: PPUSH
10407: CALL_OW 69
10411: IFFALSE 10471
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10413: LD_ADDR_VAR 0 1
10417: PUSH
10418: LD_INT 22
10420: PUSH
10421: LD_INT 2
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PUSH
10428: LD_INT 92
10430: PUSH
10431: LD_INT 51
10433: PUSH
10434: LD_INT 99
10436: PUSH
10437: LD_INT 2
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: LIST
10444: LIST
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PPUSH
10450: CALL_OW 69
10454: PUSH
10455: FOR_IN
10456: IFFALSE 10469
// RemoveUnit ( i ) ;
10458: LD_VAR 0 1
10462: PPUSH
10463: CALL_OW 64
10467: GO 10455
10469: POP
10470: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10471: LD_INT 22
10473: PUSH
10474: LD_INT 2
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PPUSH
10481: CALL_OW 69
10485: PUSH
10486: LD_INT 0
10488: EQUAL
10489: IFFALSE 10343
// end ; end ;
10491: PPOPN 1
10493: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
10494: LD_EXP 4
10498: IFFALSE 11426
10500: GO 10502
10502: DISABLE
10503: LD_INT 0
10505: PPUSH
10506: PPUSH
10507: PPUSH
// begin Wait ( game_time ) ;
10508: LD_EXP 7
10512: PPUSH
10513: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10517: LD_INT 35
10519: PPUSH
10520: CALL_OW 67
// until ( not ru_can_attack ) ;
10524: LD_EXP 8
10528: NOT
10529: IFFALSE 10517
// Wait ( 0 0$35 ) ;
10531: LD_INT 1225
10533: PPUSH
10534: CALL_OW 67
// DialogueOn ;
10538: CALL_OW 6
// InGameOn ;
10542: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10546: LD_EXP 26
10550: PPUSH
10551: LD_STRING D12-Pow-1
10553: PPUSH
10554: CALL_OW 94
// InGameOff ;
10558: CALL_OW 9
// DialogueOff ;
10562: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10566: LD_STRING M4
10568: PPUSH
10569: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10573: LD_INT 5
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: CALL_OW 424
// can_end := true ;
10583: LD_ADDR_EXP 17
10587: PUSH
10588: LD_INT 1
10590: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10591: LD_INT 35
10593: PPUSH
10594: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10598: CALL 809 0 0
10602: PUSH
10603: LD_INT 20
10605: GREATEREQUAL
10606: PUSH
10607: LD_INT 22
10609: PUSH
10610: LD_INT 1
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PUSH
10617: LD_INT 21
10619: PUSH
10620: LD_INT 1
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 69
10635: PUSH
10636: LD_INT 5
10638: PPUSH
10639: LD_INT 22
10641: PUSH
10642: LD_INT 1
10644: PUSH
10645: EMPTY
10646: LIST
10647: LIST
10648: PUSH
10649: LD_INT 21
10651: PUSH
10652: LD_INT 1
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 70
10667: PUSH
10668: LD_INT 22
10670: PUSH
10671: LD_INT 1
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PUSH
10678: LD_INT 55
10680: PUSH
10681: EMPTY
10682: LIST
10683: PUSH
10684: EMPTY
10685: LIST
10686: LIST
10687: PPUSH
10688: CALL_OW 69
10692: PLUS
10693: LESSEQUAL
10694: AND
10695: IFFALSE 10591
// if not player_get_info then
10697: LD_EXP 15
10701: NOT
10702: IFFALSE 10713
// player_get_info := - 1 ;
10704: LD_ADDR_EXP 15
10708: PUSH
10709: LD_INT 1
10711: NEG
10712: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10713: LD_STRING Information
10715: PPUSH
10716: LD_EXP 15
10720: PPUSH
10721: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10725: LD_ADDR_VAR 0 2
10729: PUSH
10730: LD_INT 22
10732: PUSH
10733: LD_INT 1
10735: PUSH
10736: EMPTY
10737: LIST
10738: LIST
10739: PUSH
10740: LD_INT 2
10742: PUSH
10743: LD_INT 25
10745: PUSH
10746: LD_INT 2
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PUSH
10753: LD_INT 25
10755: PUSH
10756: LD_INT 16
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PUSH
10763: LD_INT 34
10765: PUSH
10766: LD_INT 12
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PUSH
10773: EMPTY
10774: LIST
10775: LIST
10776: LIST
10777: LIST
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: PPUSH
10783: CALL_OW 69
10787: ST_TO_ADDR
// sib := GetTerminalCargo ;
10788: LD_ADDR_VAR 0 3
10792: PUSH
10793: CALL 809 0 0
10797: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10798: LD_ADDR_VAR 0 3
10802: PUSH
10803: LD_VAR 0 3
10807: PUSH
10808: LD_INT 6
10810: PPUSH
10811: LD_INT 3
10813: PPUSH
10814: CALL_OW 287
10818: PLUS
10819: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10820: LD_ADDR_VAR 0 3
10824: PUSH
10825: LD_VAR 0 3
10829: PUSH
10830: LD_VAR 0 2
10834: PPUSH
10835: LD_INT 3
10837: PPUSH
10838: CALL_OW 289
10842: PLUS
10843: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10844: LD_VAR 0 3
10848: PUSH
10849: LD_INT 2
10851: PUSH
10852: LD_OWVAR 67
10856: PLUS
10857: PUSH
10858: LD_INT 50
10860: MUL
10861: LESS
10862: IFFALSE 10887
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10864: LD_STRING MuchSiberite
10866: PPUSH
10867: LD_INT 2
10869: NEG
10870: PUSH
10871: LD_OWVAR 67
10875: MUL
10876: PUSH
10877: LD_INT 1
10879: PLUS
10880: PPUSH
10881: CALL_OW 101
10885: GO 10897
// AddMedal ( MuchSiberite , 1 ) ;
10887: LD_STRING MuchSiberite
10889: PPUSH
10890: LD_INT 1
10892: PPUSH
10893: CALL_OW 101
// GiveMedals ( MAIN ) ;
10897: LD_STRING MAIN
10899: PPUSH
10900: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10904: LD_INT 22
10906: PUSH
10907: LD_INT 1
10909: PUSH
10910: EMPTY
10911: LIST
10912: LIST
10913: PUSH
10914: LD_INT 2
10916: PUSH
10917: LD_INT 25
10919: PUSH
10920: LD_INT 1
10922: PUSH
10923: EMPTY
10924: LIST
10925: LIST
10926: PUSH
10927: LD_INT 25
10929: PUSH
10930: LD_INT 2
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 25
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PUSH
10947: LD_INT 25
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: PUSH
10957: LD_INT 25
10959: PUSH
10960: LD_INT 8
10962: PUSH
10963: EMPTY
10964: LIST
10965: LIST
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: LIST
10971: LIST
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 69
10983: PPUSH
10984: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10988: LD_ADDR_VAR 0 2
10992: PUSH
10993: LD_INT 22
10995: PUSH
10996: LD_INT 1
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: PUSH
11003: LD_INT 25
11005: PUSH
11006: LD_INT 8
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: PPUSH
11017: CALL_OW 69
11021: ST_TO_ADDR
// if tmp then
11022: LD_VAR 0 2
11026: IFFALSE 11057
// for i in tmp do
11028: LD_ADDR_VAR 0 1
11032: PUSH
11033: LD_VAR 0 2
11037: PUSH
11038: FOR_IN
11039: IFFALSE 11055
// SetClass ( i , 1 ) ;
11041: LD_VAR 0 1
11045: PPUSH
11046: LD_INT 1
11048: PPUSH
11049: CALL_OW 336
11053: GO 11038
11055: POP
11056: POP
// SaveVariable ( sib , 09_sibRes ) ;
11057: LD_VAR 0 3
11061: PPUSH
11062: LD_STRING 09_sibRes
11064: PPUSH
11065: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11069: LD_EXP 15
11073: PPUSH
11074: LD_STRING 09_arInfo
11076: PPUSH
11077: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11081: LD_EXP 19
11085: PPUSH
11086: LD_EXP 1
11090: PUSH
11091: LD_STRING JMM
11093: STR
11094: PPUSH
11095: CALL_OW 38
// if IsLive ( Gary ) then
11099: LD_EXP 20
11103: PPUSH
11104: CALL_OW 300
11108: IFFALSE 11128
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11110: LD_EXP 20
11114: PPUSH
11115: LD_EXP 1
11119: PUSH
11120: LD_STRING Gary
11122: STR
11123: PPUSH
11124: CALL_OW 38
// if IsLive ( Bobby ) then
11128: LD_EXP 21
11132: PPUSH
11133: CALL_OW 300
11137: IFFALSE 11157
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11139: LD_EXP 21
11143: PPUSH
11144: LD_EXP 1
11148: PUSH
11149: LD_STRING Bobby
11151: STR
11152: PPUSH
11153: CALL_OW 38
// if IsLive ( Cyrus ) then
11157: LD_EXP 22
11161: PPUSH
11162: CALL_OW 300
11166: IFFALSE 11186
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11168: LD_EXP 22
11172: PPUSH
11173: LD_EXP 1
11177: PUSH
11178: LD_STRING Cyrus
11180: STR
11181: PPUSH
11182: CALL_OW 38
// if IsLive ( Houten ) then
11186: LD_EXP 23
11190: PPUSH
11191: CALL_OW 300
11195: IFFALSE 11215
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11197: LD_EXP 23
11201: PPUSH
11202: LD_EXP 1
11206: PUSH
11207: LD_STRING Houten
11209: STR
11210: PPUSH
11211: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11215: LD_ADDR_VAR 0 2
11219: PUSH
11220: LD_INT 22
11222: PUSH
11223: LD_INT 1
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 2
11232: PUSH
11233: LD_INT 25
11235: PUSH
11236: LD_INT 1
11238: PUSH
11239: EMPTY
11240: LIST
11241: LIST
11242: PUSH
11243: LD_INT 25
11245: PUSH
11246: LD_INT 2
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: LD_INT 25
11255: PUSH
11256: LD_INT 3
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: LD_INT 25
11265: PUSH
11266: LD_INT 4
11268: PUSH
11269: EMPTY
11270: LIST
11271: LIST
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: PPUSH
11284: CALL_OW 69
11288: PUSH
11289: LD_EXP 19
11293: PUSH
11294: LD_EXP 22
11298: PUSH
11299: LD_EXP 21
11303: PUSH
11304: LD_EXP 23
11308: PUSH
11309: LD_EXP 20
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: DIFF
11321: ST_TO_ADDR
// if tmp then
11322: LD_VAR 0 2
11326: IFFALSE 11346
// SaveCharacters ( tmp , mission_prefix & others ) ;
11328: LD_VAR 0 2
11332: PPUSH
11333: LD_EXP 1
11337: PUSH
11338: LD_STRING others
11340: STR
11341: PPUSH
11342: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11346: LD_ADDR_VAR 0 2
11350: PUSH
11351: LD_INT 22
11353: PUSH
11354: LD_INT 1
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: PUSH
11361: LD_INT 2
11363: PUSH
11364: LD_INT 25
11366: PUSH
11367: LD_INT 12
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: PUSH
11374: LD_INT 25
11376: PUSH
11377: LD_INT 16
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: LIST
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: CALL_OW 69
11397: ST_TO_ADDR
// if tmp then
11398: LD_VAR 0 2
11402: IFFALSE 11422
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11404: LD_VAR 0 2
11408: PPUSH
11409: LD_EXP 1
11413: PUSH
11414: LD_STRING apes
11416: STR
11417: PPUSH
11418: CALL_OW 38
// YouWin ;
11422: CALL_OW 103
// end ; end_of_file
11426: PPOPN 3
11428: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 266
11438: PUSH
11439: LD_INT 0
11441: EQUAL
11442: PUSH
11443: LD_EXP 3
11447: NOT
11448: AND
11449: IFFALSE 11473
// begin terminal := b ;
11451: LD_ADDR_EXP 3
11455: PUSH
11456: LD_VAR 0 1
11460: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11461: LD_EXP 3
11465: PPUSH
11466: LD_STRING terminal
11468: PPUSH
11469: CALL_OW 500
// end ; end ;
11473: PPOPN 2
11475: END
// on BuildingComplete ( b ) do var i ;
11476: LD_INT 0
11478: PPUSH
// begin if GetSide ( b ) = 3 then
11479: LD_VAR 0 1
11483: PPUSH
11484: CALL_OW 255
11488: PUSH
11489: LD_INT 3
11491: EQUAL
11492: IFFALSE 11532
// for i = 1 to 4 do
11494: LD_ADDR_VAR 0 2
11498: PUSH
11499: DOUBLE
11500: LD_INT 1
11502: DEC
11503: ST_TO_ADDR
11504: LD_INT 4
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11530
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11510: LD_ADDR_EXP 37
11514: PUSH
11515: LD_EXP 37
11519: PPUSH
11520: LD_INT 1
11522: PPUSH
11523: CALL_OW 3
11527: ST_TO_ADDR
11528: GO 11507
11530: POP
11531: POP
// end ;
11532: PPOPN 2
11534: END
// on VehicleConstructed ( veh , fac ) do var i ;
11535: LD_INT 0
11537: PPUSH
// begin if GetSide ( veh ) = 3 then
11538: LD_VAR 0 1
11542: PPUSH
11543: CALL_OW 255
11547: PUSH
11548: LD_INT 3
11550: EQUAL
11551: IFFALSE 11676
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11553: LD_VAR 0 1
11557: PPUSH
11558: CALL_OW 264
11562: PUSH
11563: LD_INT 53
11565: PUSH
11566: LD_INT 52
11568: PUSH
11569: LD_INT 51
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: IN
11577: NOT
11578: IFFALSE 11596
// ru_force := ru_force ^ veh ;
11580: LD_ADDR_EXP 36
11584: PUSH
11585: LD_EXP 36
11589: PUSH
11590: LD_VAR 0 1
11594: ADD
11595: ST_TO_ADDR
// for i = 1 to 4 do
11596: LD_ADDR_VAR 0 3
11600: PUSH
11601: DOUBLE
11602: LD_INT 1
11604: DEC
11605: ST_TO_ADDR
11606: LD_INT 4
11608: PUSH
11609: FOR_TO
11610: IFFALSE 11632
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11612: LD_ADDR_EXP 38
11616: PUSH
11617: LD_EXP 38
11621: PPUSH
11622: LD_INT 1
11624: PPUSH
11625: CALL_OW 3
11629: ST_TO_ADDR
11630: GO 11609
11632: POP
11633: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11634: LD_VAR 0 1
11638: PPUSH
11639: CALL_OW 264
11643: PUSH
11644: LD_INT 53
11646: EQUAL
11647: IFFALSE 11676
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11649: LD_VAR 0 1
11653: PPUSH
11654: LD_INT 7
11656: PPUSH
11657: CALL 967 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11661: LD_VAR 0 1
11665: PPUSH
11666: LD_INT 170
11668: PPUSH
11669: LD_INT 235
11671: PPUSH
11672: CALL_OW 171
// end ; end ; end ;
11676: PPOPN 3
11678: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11679: LD_VAR 0 1
11683: PUSH
11684: LD_INT 1
11686: EQUAL
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: LD_INT 2
11695: EQUAL
11696: AND
11697: PUSH
11698: LD_VAR 0 1
11702: PUSH
11703: LD_INT 2
11705: EQUAL
11706: PUSH
11707: LD_VAR 0 2
11711: PUSH
11712: LD_INT 1
11714: EQUAL
11715: AND
11716: OR
11717: IFFALSE 11727
// player_attacked_ar := true ;
11719: LD_ADDR_EXP 16
11723: PUSH
11724: LD_INT 1
11726: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11727: LD_VAR 0 1
11731: PUSH
11732: LD_INT 1
11734: EQUAL
11735: PUSH
11736: LD_VAR 0 2
11740: PUSH
11741: LD_INT 4
11743: EQUAL
11744: AND
11745: PUSH
11746: LD_VAR 0 1
11750: PUSH
11751: LD_INT 4
11753: EQUAL
11754: PUSH
11755: LD_VAR 0 2
11759: PUSH
11760: LD_INT 1
11762: EQUAL
11763: AND
11764: OR
11765: IFFALSE 11774
// YouLost ( Traitor ) ;
11767: LD_STRING Traitor
11769: PPUSH
11770: CALL_OW 104
// end ;
11774: PPOPN 2
11776: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11777: LD_VAR 0 1
11781: PUSH
11782: LD_EXP 19
11786: EQUAL
11787: IFFALSE 11796
// YouLost ( JMM ) ;
11789: LD_STRING JMM
11791: PPUSH
11792: CALL_OW 104
// if un = terminal then
11796: LD_VAR 0 1
11800: PUSH
11801: LD_EXP 3
11805: EQUAL
11806: IFFALSE 11815
// YouLost ( Terminal ) ;
11808: LD_STRING Terminal
11810: PPUSH
11811: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11815: LD_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 3
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 21
11832: PUSH
11833: LD_INT 3
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PPUSH
11844: CALL_OW 69
11848: IN
11849: IFFALSE 11995
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11851: LD_VAR 0 1
11855: PPUSH
11856: CALL_OW 266
11860: PUSH
11861: LD_INT 33
11863: PUSH
11864: LD_INT 26
11866: PUSH
11867: EMPTY
11868: LIST
11869: LIST
11870: IN
11871: IFFALSE 11930
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11873: LD_ADDR_EXP 37
11877: PUSH
11878: LD_EXP 37
11882: PUSH
11883: LD_VAR 0 1
11887: PPUSH
11888: CALL_OW 266
11892: PUSH
11893: LD_VAR 0 1
11897: PPUSH
11898: CALL_OW 250
11902: PUSH
11903: LD_VAR 0 1
11907: PPUSH
11908: CALL_OW 251
11912: PUSH
11913: LD_VAR 0 1
11917: PPUSH
11918: CALL_OW 254
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: LIST
11928: ADD
11929: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11930: LD_VAR 0 1
11934: PPUSH
11935: CALL_OW 266
11939: PUSH
11940: LD_INT 5
11942: EQUAL
11943: IFFALSE 11995
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11945: LD_ADDR_EXP 37
11949: PUSH
11950: LD_EXP 37
11954: PUSH
11955: LD_INT 4
11957: PUSH
11958: LD_VAR 0 1
11962: PPUSH
11963: CALL_OW 250
11967: PUSH
11968: LD_VAR 0 1
11972: PPUSH
11973: CALL_OW 251
11977: PUSH
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 254
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: ADD
11994: ST_TO_ADDR
// end ; if un in ru_force then
11995: LD_VAR 0 1
11999: PUSH
12000: LD_EXP 36
12004: IN
12005: IFFALSE 12041
// begin ru_force := ru_force diff un ;
12007: LD_ADDR_EXP 36
12011: PUSH
12012: LD_EXP 36
12016: PUSH
12017: LD_VAR 0 1
12021: DIFF
12022: ST_TO_ADDR
// if ru_force = 0 then
12023: LD_EXP 36
12027: PUSH
12028: LD_INT 0
12030: EQUAL
12031: IFFALSE 12041
// ru_can_attack := false ;
12033: LD_ADDR_EXP 8
12037: PUSH
12038: LD_INT 0
12040: ST_TO_ADDR
// end ; end ; end_of_file
12041: PPOPN 1
12043: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12044: LD_EXP 5
12048: PUSH
12049: LD_EXP 6
12053: AND
12054: IFFALSE 12139
12056: GO 12058
12058: DISABLE
12059: LD_INT 0
12061: PPUSH
// begin enable ;
12062: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12063: LD_ADDR_VAR 0 1
12067: PUSH
12068: LD_INT 60
12070: PUSH
12071: CALL 809 0 0
12075: MINUS
12076: ST_TO_ADDR
// if sib < 0 then
12077: LD_VAR 0 1
12081: PUSH
12082: LD_INT 0
12084: LESS
12085: IFFALSE 12095
// sib := 0 ;
12087: LD_ADDR_VAR 0 1
12091: PUSH
12092: LD_INT 0
12094: ST_TO_ADDR
// if not debug then
12095: LD_EXP 2
12099: NOT
12100: IFFALSE 12125
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12102: LD_ADDR_OWVAR 47
12106: PUSH
12107: LD_STRING #Am09-1
12109: PUSH
12110: LD_VAR 0 1
12114: PUSH
12115: LD_EXP 6
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: LIST
12124: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12125: LD_ADDR_EXP 6
12129: PUSH
12130: LD_EXP 6
12134: PUSH
12135: LD_INT 35
12137: MINUS
12138: ST_TO_ADDR
// end ;
12139: PPOPN 1
12141: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12142: LD_EXP 6
12146: PUSH
12147: LD_INT 0
12149: EQUAL
12150: IFFALSE 12162
12152: GO 12154
12154: DISABLE
// display_strings := [ ] ;
12155: LD_ADDR_OWVAR 47
12159: PUSH
12160: EMPTY
12161: ST_TO_ADDR
12162: END
// every 1 1$35 do var i , tmp ;
12163: GO 12165
12165: DISABLE
12166: LD_INT 0
12168: PPUSH
12169: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: LD_INT 1155
12177: PUSH
12178: LD_INT 1225
12180: PUSH
12181: LD_INT 1435
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: LIST
12188: PUSH
12189: LD_OWVAR 67
12193: ARRAY
12194: ST_TO_ADDR
// i := 0 ;
12195: LD_ADDR_VAR 0 1
12199: PUSH
12200: LD_INT 0
12202: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12203: LD_INT 1
12205: PPUSH
12206: LD_INT 5
12208: PPUSH
12209: CALL_OW 12
12213: PPUSH
12214: LD_INT 75
12216: PPUSH
12217: LD_INT 75
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 1
12225: PPUSH
12226: CALL_OW 56
// wait ( tmp ) ;
12230: LD_VAR 0 2
12234: PPUSH
12235: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12239: LD_ADDR_VAR 0 2
12243: PUSH
12244: LD_VAR 0 2
12248: PUSH
12249: LD_INT 105
12251: PPUSH
12252: LD_INT 315
12254: PPUSH
12255: CALL_OW 12
12259: PLUS
12260: ST_TO_ADDR
// i := i + 1 ;
12261: LD_ADDR_VAR 0 1
12265: PUSH
12266: LD_VAR 0 1
12270: PUSH
12271: LD_INT 1
12273: PLUS
12274: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12275: LD_VAR 0 1
12279: PUSH
12280: LD_INT 3
12282: MOD
12283: PUSH
12284: LD_INT 0
12286: EQUAL
12287: PUSH
12288: LD_EXP 4
12292: AND
12293: IFFALSE 12331
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12295: LD_INT 2
12297: PPUSH
12298: LD_INT 5
12300: PPUSH
12301: CALL_OW 12
12305: PPUSH
12306: LD_INT 8
12308: PPUSH
12309: LD_INT 1
12311: PPUSH
12312: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12316: LD_INT 665
12318: PPUSH
12319: LD_INT 735
12321: PPUSH
12322: CALL_OW 12
12326: PPUSH
12327: CALL_OW 67
// end ; until tick > game_time ;
12331: LD_OWVAR 1
12335: PUSH
12336: LD_EXP 7
12340: GREATER
12341: IFFALSE 12203
// end ; end_of_file
12343: PPOPN 2
12345: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12346: LD_INT 0
12348: PPUSH
12349: PPUSH
12350: PPUSH
12351: PPUSH
12352: PPUSH
12353: PPUSH
// x := 76 ;
12354: LD_ADDR_VAR 0 5
12358: PUSH
12359: LD_INT 76
12361: ST_TO_ADDR
// y := 147 ;
12362: LD_ADDR_VAR 0 6
12366: PUSH
12367: LD_INT 147
12369: ST_TO_ADDR
// uc_side := 2 ;
12370: LD_ADDR_OWVAR 20
12374: PUSH
12375: LD_INT 2
12377: ST_TO_ADDR
// uc_nation := 2 ;
12378: LD_ADDR_OWVAR 21
12382: PUSH
12383: LD_INT 2
12385: ST_TO_ADDR
// InitHc ;
12386: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12390: LD_INT 1
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: LD_INT 6
12398: PPUSH
12399: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12403: LD_ADDR_OWVAR 26
12407: PUSH
12408: LD_STRING Nicolas Vervecken
12410: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12411: LD_ADDR_OWVAR 33
12415: PUSH
12416: LD_STRING SecondCharsGal
12418: ST_TO_ADDR
// hc_face_number := 3 ;
12419: LD_ADDR_OWVAR 34
12423: PUSH
12424: LD_INT 3
12426: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12427: LD_ADDR_OWVAR 29
12431: PUSH
12432: LD_INT 11
12434: PUSH
12435: LD_INT 10
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: ST_TO_ADDR
// Vervecken := CreateHuman ;
12442: LD_ADDR_EXP 27
12446: PUSH
12447: CALL_OW 44
12451: ST_TO_ADDR
// ar_force := Vervecken ;
12452: LD_ADDR_EXP 34
12456: PUSH
12457: LD_EXP 27
12461: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12462: LD_INT 1
12464: PPUSH
12465: LD_INT 2
12467: PPUSH
12468: LD_INT 6
12470: PPUSH
12471: CALL_OW 380
// hc_name := Louis Gali ;
12475: LD_ADDR_OWVAR 26
12479: PUSH
12480: LD_STRING Louis Gali
12482: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12483: LD_ADDR_OWVAR 33
12487: PUSH
12488: LD_STRING SecondCharsGal
12490: ST_TO_ADDR
// hc_face_number := 2 ;
12491: LD_ADDR_OWVAR 34
12495: PUSH
12496: LD_INT 2
12498: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12499: LD_ADDR_OWVAR 29
12503: PUSH
12504: LD_INT 10
12506: PUSH
12507: LD_INT 11
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: ST_TO_ADDR
// Gali := CreateHuman ;
12514: LD_ADDR_EXP 28
12518: PUSH
12519: CALL_OW 44
12523: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12524: LD_ADDR_EXP 34
12528: PUSH
12529: LD_EXP 34
12533: PUSH
12534: LD_EXP 28
12538: ADD
12539: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12540: LD_INT 2
12542: PPUSH
12543: LD_INT 1
12545: PPUSH
12546: LD_INT 6
12548: PPUSH
12549: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12553: LD_ADDR_OWVAR 26
12557: PUSH
12558: LD_STRING Maria Bogdanovic
12560: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12561: LD_ADDR_OWVAR 33
12565: PUSH
12566: LD_STRING SecondCharsGal
12568: ST_TO_ADDR
// hc_face_number := 14 ;
12569: LD_ADDR_OWVAR 34
12573: PUSH
12574: LD_INT 14
12576: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12577: LD_ADDR_OWVAR 29
12581: PUSH
12582: LD_INT 12
12584: PUSH
12585: LD_INT 9
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12592: LD_ADDR_EXP 29
12596: PUSH
12597: CALL_OW 44
12601: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12602: LD_ADDR_EXP 34
12606: PUSH
12607: LD_EXP 34
12611: PUSH
12612: LD_EXP 29
12616: ADD
12617: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12618: LD_INT 1
12620: PPUSH
12621: LD_INT 3
12623: PPUSH
12624: LD_INT 6
12626: PPUSH
12627: CALL_OW 380
// hc_name = Kntor Radomr ;
12631: LD_ADDR_OWVAR 26
12635: PUSH
12636: LD_STRING Kntor Radomr
12638: ST_TO_ADDR
// hc_gallery = sandar ;
12639: LD_ADDR_OWVAR 33
12643: PUSH
12644: LD_STRING sandar
12646: ST_TO_ADDR
// hc_face_number = 12 ;
12647: LD_ADDR_OWVAR 34
12651: PUSH
12652: LD_INT 12
12654: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12655: LD_ADDR_OWVAR 29
12659: PUSH
12660: LD_INT 9
12662: PUSH
12663: LD_INT 9
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: ST_TO_ADDR
// Kantor = CreateHuman ;
12670: LD_ADDR_EXP 30
12674: PUSH
12675: CALL_OW 44
12679: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12680: LD_ADDR_EXP 34
12684: PUSH
12685: LD_EXP 34
12689: PUSH
12690: LD_EXP 30
12694: ADD
12695: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12696: LD_INT 1
12698: PPUSH
12699: LD_INT 3
12701: PPUSH
12702: LD_INT 6
12704: PPUSH
12705: CALL_OW 380
// hc_name = Herczeg Farkas ;
12709: LD_ADDR_OWVAR 26
12713: PUSH
12714: LD_STRING Herczeg Farkas
12716: ST_TO_ADDR
// hc_gallery = sandar ;
12717: LD_ADDR_OWVAR 33
12721: PUSH
12722: LD_STRING sandar
12724: ST_TO_ADDR
// hc_face_number = 28 ;
12725: LD_ADDR_OWVAR 34
12729: PUSH
12730: LD_INT 28
12732: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12733: LD_ADDR_OWVAR 29
12737: PUSH
12738: LD_INT 10
12740: PUSH
12741: LD_INT 9
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: ST_TO_ADDR
// Herczeg = CreateHuman ;
12748: LD_ADDR_EXP 31
12752: PUSH
12753: CALL_OW 44
12757: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12758: LD_ADDR_EXP 34
12762: PUSH
12763: LD_EXP 34
12767: PUSH
12768: LD_EXP 31
12772: ADD
12773: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12774: LD_INT 1
12776: PPUSH
12777: LD_INT 1
12779: PPUSH
12780: LD_INT 6
12782: PPUSH
12783: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12787: LD_ADDR_OWVAR 26
12791: PUSH
12792: LD_STRING Ronn Horntvedt
12794: ST_TO_ADDR
// hc_gallery = sandar ;
12795: LD_ADDR_OWVAR 33
12799: PUSH
12800: LD_STRING sandar
12802: ST_TO_ADDR
// hc_face_number = 29 ;
12803: LD_ADDR_OWVAR 34
12807: PUSH
12808: LD_INT 29
12810: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12811: LD_ADDR_OWVAR 29
12815: PUSH
12816: LD_INT 11
12818: PUSH
12819: LD_INT 11
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: ST_TO_ADDR
// Ronn = CreateHuman ;
12826: LD_ADDR_EXP 32
12830: PUSH
12831: CALL_OW 44
12835: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12836: LD_ADDR_EXP 34
12840: PUSH
12841: LD_EXP 34
12845: PUSH
12846: LD_EXP 32
12850: ADD
12851: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12852: LD_INT 2
12854: PPUSH
12855: LD_INT 3
12857: PPUSH
12858: LD_INT 6
12860: PPUSH
12861: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12865: LD_ADDR_OWVAR 26
12869: PUSH
12870: LD_STRING Mia D. Mathiasen
12872: ST_TO_ADDR
// hc_gallery = sandar ;
12873: LD_ADDR_OWVAR 33
12877: PUSH
12878: LD_STRING sandar
12880: ST_TO_ADDR
// hc_face_number = 31 ;
12881: LD_ADDR_OWVAR 34
12885: PUSH
12886: LD_INT 31
12888: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12889: LD_ADDR_OWVAR 29
12893: PUSH
12894: LD_INT 10
12896: PUSH
12897: LD_INT 10
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: ST_TO_ADDR
// Mia = CreateHuman ;
12904: LD_ADDR_EXP 33
12908: PUSH
12909: CALL_OW 44
12913: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12914: LD_ADDR_EXP 34
12918: PUSH
12919: LD_EXP 34
12923: PUSH
12924: LD_EXP 33
12928: ADD
12929: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: LD_VAR 0 3
12939: PUSH
12940: LD_INT 2
12942: PPUSH
12943: LD_INT 2
12945: PPUSH
12946: LD_INT 14
12948: PPUSH
12949: LD_INT 1
12951: PPUSH
12952: LD_INT 1
12954: PPUSH
12955: LD_INT 32
12957: PPUSH
12958: LD_INT 30
12960: PPUSH
12961: CALL 289 0 7
12965: ADD
12966: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
12967: LD_ADDR_VAR 0 3
12971: PUSH
12972: LD_VAR 0 3
12976: PUSH
12977: LD_INT 2
12979: PPUSH
12980: LD_INT 2
12982: PPUSH
12983: LD_INT 14
12985: PPUSH
12986: LD_INT 1
12988: PPUSH
12989: LD_INT 1
12991: PPUSH
12992: LD_INT 27
12994: PPUSH
12995: LD_INT 30
12997: PPUSH
12998: CALL 289 0 7
13002: ADD
13003: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13004: LD_ADDR_VAR 0 3
13008: PUSH
13009: LD_VAR 0 3
13013: PUSH
13014: LD_INT 2
13016: PPUSH
13017: LD_INT 2
13019: PPUSH
13020: LD_INT 14
13022: PPUSH
13023: LD_INT 1
13025: PPUSH
13026: LD_INT 1
13028: PPUSH
13029: LD_INT 25
13031: PPUSH
13032: LD_INT 33
13034: PPUSH
13035: CALL 289 0 7
13039: ADD
13040: ST_TO_ADDR
// tmp := tmp diff 0 ;
13041: LD_ADDR_VAR 0 3
13045: PUSH
13046: LD_VAR 0 3
13050: PUSH
13051: LD_INT 0
13053: DIFF
13054: ST_TO_ADDR
// for i in ar_force do
13055: LD_ADDR_VAR 0 4
13059: PUSH
13060: LD_EXP 34
13064: PUSH
13065: FOR_IN
13066: IFFALSE 13209
// begin if GetClass ( i ) = 3 then
13068: LD_VAR 0 4
13072: PPUSH
13073: CALL_OW 257
13077: PUSH
13078: LD_INT 3
13080: EQUAL
13081: IFFALSE 13163
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13083: LD_VAR 0 3
13087: PUSH
13088: LD_INT 1
13090: ARRAY
13091: PPUSH
13092: LD_INT 1
13094: PPUSH
13095: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13099: LD_VAR 0 3
13103: PUSH
13104: LD_INT 1
13106: ARRAY
13107: PPUSH
13108: LD_VAR 0 5
13112: PPUSH
13113: LD_VAR 0 6
13117: PPUSH
13118: LD_INT 0
13120: PPUSH
13121: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13125: LD_VAR 0 4
13129: PPUSH
13130: LD_VAR 0 3
13134: PUSH
13135: LD_INT 1
13137: ARRAY
13138: PPUSH
13139: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13143: LD_ADDR_VAR 0 3
13147: PUSH
13148: LD_VAR 0 3
13152: PPUSH
13153: LD_INT 1
13155: PPUSH
13156: CALL_OW 3
13160: ST_TO_ADDR
// end else
13161: GO 13185
// PlaceUnitXY ( i , x , y , false ) ;
13163: LD_VAR 0 4
13167: PPUSH
13168: LD_VAR 0 5
13172: PPUSH
13173: LD_VAR 0 6
13177: PPUSH
13178: LD_INT 0
13180: PPUSH
13181: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13185: LD_VAR 0 4
13189: PPUSH
13190: LD_INT 86
13192: PPUSH
13193: LD_INT 121
13195: PPUSH
13196: CALL_OW 111
// wait ( 0 0$2 ) ;
13200: LD_INT 70
13202: PPUSH
13203: CALL_OW 67
// end ;
13207: GO 13065
13209: POP
13210: POP
// ar_force := ar_force ^ tmp ;
13211: LD_ADDR_EXP 34
13215: PUSH
13216: LD_EXP 34
13220: PUSH
13221: LD_VAR 0 3
13225: ADD
13226: ST_TO_ADDR
// ar_spawned := true ;
13227: LD_ADDR_EXP 11
13231: PUSH
13232: LD_INT 1
13234: ST_TO_ADDR
// end ; end_of_file
13235: LD_VAR 0 1
13239: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13240: LD_INT 0
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
// InitHc ;
13249: CALL_OW 19
// uc_side := 3 ;
13253: LD_ADDR_OWVAR 20
13257: PUSH
13258: LD_INT 3
13260: ST_TO_ADDR
// uc_nation := 3 ;
13261: LD_ADDR_OWVAR 21
13265: PUSH
13266: LD_INT 3
13268: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13269: LD_ADDR_VAR 0 5
13273: PUSH
13274: LD_INT 5
13276: PUSH
13277: LD_INT 6
13279: PUSH
13280: LD_INT 7
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: LIST
13287: PUSH
13288: LD_OWVAR 67
13292: ARRAY
13293: ST_TO_ADDR
// ru_force := [ ] ;
13294: LD_ADDR_EXP 36
13298: PUSH
13299: EMPTY
13300: ST_TO_ADDR
// ru_rebuild := [ ] ;
13301: LD_ADDR_EXP 37
13305: PUSH
13306: EMPTY
13307: ST_TO_ADDR
// ru_produce_list := [ ] ;
13308: LD_ADDR_EXP 38
13312: PUSH
13313: EMPTY
13314: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13315: LD_ADDR_VAR 0 6
13319: PUSH
13320: LD_INT 22
13322: PUSH
13323: LD_INT 3
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PUSH
13330: LD_INT 30
13332: PUSH
13333: LD_INT 8
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PPUSH
13344: CALL_OW 69
13348: PUSH
13349: LD_INT 1
13351: ARRAY
13352: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13353: LD_ADDR_VAR 0 4
13357: PUSH
13358: LD_INT 43
13360: PUSH
13361: LD_INT 46
13363: PUSH
13364: LD_INT 45
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13372: LD_ADDR_VAR 0 7
13376: PUSH
13377: LD_INT 22
13379: PUSH
13380: LD_INT 3
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PUSH
13387: LD_INT 30
13389: PUSH
13390: LD_INT 1
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PPUSH
13401: CALL_OW 69
13405: PUSH
13406: LD_INT 1
13408: ARRAY
13409: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13410: LD_VAR 0 7
13414: PPUSH
13415: CALL_OW 274
13419: PPUSH
13420: LD_INT 1
13422: PPUSH
13423: LD_INT 5000
13425: PPUSH
13426: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13430: LD_VAR 0 7
13434: PPUSH
13435: CALL_OW 274
13439: PPUSH
13440: LD_INT 2
13442: PPUSH
13443: LD_INT 1000
13445: PPUSH
13446: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13450: LD_VAR 0 7
13454: PPUSH
13455: CALL_OW 274
13459: PPUSH
13460: LD_INT 3
13462: PPUSH
13463: LD_INT 30
13465: PPUSH
13466: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13470: LD_ADDR_VAR 0 2
13474: PUSH
13475: LD_INT 22
13477: PUSH
13478: LD_INT 3
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: PUSH
13485: LD_INT 30
13487: PUSH
13488: LD_INT 33
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PPUSH
13499: CALL_OW 69
13503: PUSH
13504: FOR_IN
13505: IFFALSE 13537
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13507: LD_VAR 0 2
13511: PPUSH
13512: LD_VAR 0 4
13516: PUSH
13517: LD_VAR 0 2
13521: PUSH
13522: LD_INT 3
13524: MOD
13525: PUSH
13526: LD_INT 1
13528: PLUS
13529: ARRAY
13530: PPUSH
13531: CALL_OW 431
// end ;
13535: GO 13504
13537: POP
13538: POP
// for i = 1 to 4 do
13539: LD_ADDR_VAR 0 2
13543: PUSH
13544: DOUBLE
13545: LD_INT 1
13547: DEC
13548: ST_TO_ADDR
13549: LD_INT 4
13551: PUSH
13552: FOR_TO
13553: IFFALSE 13614
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13555: LD_INT 0
13557: PPUSH
13558: LD_INT 9
13560: PPUSH
13561: LD_VAR 0 5
13565: PPUSH
13566: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13570: CALL_OW 44
13574: PPUSH
13575: LD_INT 22
13577: PUSH
13578: LD_INT 3
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: PUSH
13585: LD_INT 30
13587: PUSH
13588: LD_INT 5
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PUSH
13595: EMPTY
13596: LIST
13597: LIST
13598: PPUSH
13599: CALL_OW 69
13603: PUSH
13604: LD_INT 1
13606: ARRAY
13607: PPUSH
13608: CALL_OW 52
// end ;
13612: GO 13552
13614: POP
13615: POP
// for i = 1 to 5 do
13616: LD_ADDR_VAR 0 2
13620: PUSH
13621: DOUBLE
13622: LD_INT 1
13624: DEC
13625: ST_TO_ADDR
13626: LD_INT 5
13628: PUSH
13629: FOR_TO
13630: IFFALSE 13691
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13632: LD_INT 0
13634: PPUSH
13635: LD_INT 3
13637: PPUSH
13638: LD_VAR 0 5
13642: PPUSH
13643: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13647: CALL_OW 44
13651: PPUSH
13652: LD_INT 22
13654: PUSH
13655: LD_INT 3
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: LD_INT 30
13664: PUSH
13665: LD_INT 3
13667: PUSH
13668: EMPTY
13669: LIST
13670: LIST
13671: PUSH
13672: EMPTY
13673: LIST
13674: LIST
13675: PPUSH
13676: CALL_OW 69
13680: PUSH
13681: LD_INT 1
13683: ARRAY
13684: PPUSH
13685: CALL_OW 52
// end ;
13689: GO 13629
13691: POP
13692: POP
// for i = 1 to 4 do
13693: LD_ADDR_VAR 0 2
13697: PUSH
13698: DOUBLE
13699: LD_INT 1
13701: DEC
13702: ST_TO_ADDR
13703: LD_INT 4
13705: PUSH
13706: FOR_TO
13707: IFFALSE 13768
// begin PrepareHuman ( false , class_engineer , skill ) ;
13709: LD_INT 0
13711: PPUSH
13712: LD_INT 2
13714: PPUSH
13715: LD_VAR 0 5
13719: PPUSH
13720: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13724: CALL_OW 44
13728: PPUSH
13729: LD_INT 22
13731: PUSH
13732: LD_INT 3
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: LD_INT 30
13741: PUSH
13742: LD_INT 1
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: PPUSH
13753: CALL_OW 69
13757: PUSH
13758: LD_INT 1
13760: ARRAY
13761: PPUSH
13762: CALL_OW 52
// end ;
13766: GO 13706
13768: POP
13769: POP
// for i = 1 to 3 do
13770: LD_ADDR_VAR 0 2
13774: PUSH
13775: DOUBLE
13776: LD_INT 1
13778: DEC
13779: ST_TO_ADDR
13780: LD_INT 3
13782: PUSH
13783: FOR_TO
13784: IFFALSE 13817
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13786: LD_INT 0
13788: PPUSH
13789: LD_INT 4
13791: PPUSH
13792: LD_VAR 0 5
13796: PPUSH
13797: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13801: CALL_OW 44
13805: PPUSH
13806: LD_VAR 0 6
13810: PPUSH
13811: CALL_OW 52
// end ;
13815: GO 13783
13817: POP
13818: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13819: LD_ADDR_EXP 35
13823: PUSH
13824: LD_STRING Yakotich
13826: PPUSH
13827: LD_EXP 2
13831: NOT
13832: PPUSH
13833: LD_STRING 
13835: PPUSH
13836: CALL 226 0 3
13840: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13841: LD_EXP 35
13845: PPUSH
13846: LD_INT 74
13848: PPUSH
13849: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13853: LD_VAR 0 6
13857: PPUSH
13858: LD_INT 49
13860: PPUSH
13861: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13865: LD_VAR 0 6
13869: PPUSH
13870: LD_INT 50
13872: PPUSH
13873: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13877: LD_VAR 0 6
13881: PPUSH
13882: LD_INT 51
13884: PPUSH
13885: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13889: LD_VAR 0 6
13893: PPUSH
13894: LD_INT 52
13896: PPUSH
13897: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13901: LD_VAR 0 6
13905: PPUSH
13906: LD_INT 69
13908: PPUSH
13909: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13913: LD_VAR 0 6
13917: PPUSH
13918: LD_INT 39
13920: PPUSH
13921: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13925: LD_VAR 0 6
13929: PPUSH
13930: LD_INT 34
13932: PPUSH
13933: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13937: LD_VAR 0 6
13941: PPUSH
13942: LD_INT 40
13944: PPUSH
13945: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13949: LD_VAR 0 6
13953: PPUSH
13954: LD_INT 57
13956: PPUSH
13957: CALL_OW 184
// if Difficulty > 1 then
13961: LD_OWVAR 67
13965: PUSH
13966: LD_INT 1
13968: GREATER
13969: IFFALSE 13983
// AddComResearch ( lab , tech_comp2 ) ;
13971: LD_VAR 0 6
13975: PPUSH
13976: LD_INT 58
13978: PPUSH
13979: CALL_OW 184
// end ;
13983: LD_VAR 0 1
13987: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13988: LD_INT 7
13990: PPUSH
13991: CALL_OW 353
13995: PUSH
13996: LD_INT 3
13998: GREATER
13999: PUSH
14000: LD_INT 22
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 34
14012: PUSH
14013: LD_INT 53
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PPUSH
14024: CALL_OW 69
14028: NOT
14029: AND
14030: IFFALSE 14065
14032: GO 14034
14034: DISABLE
// begin enable ;
14035: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14036: LD_ADDR_EXP 38
14040: PUSH
14041: LD_EXP 38
14045: PUSH
14046: LD_INT 24
14048: PUSH
14049: LD_INT 1
14051: PUSH
14052: LD_INT 3
14054: PUSH
14055: LD_INT 53
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: LIST
14062: LIST
14063: ADD
14064: ST_TO_ADDR
// end ;
14065: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14066: LD_INT 22
14068: PUSH
14069: LD_INT 3
14071: PUSH
14072: EMPTY
14073: LIST
14074: LIST
14075: PUSH
14076: LD_INT 21
14078: PUSH
14079: LD_INT 3
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: PPUSH
14090: CALL_OW 69
14094: IFFALSE 14872
14096: GO 14098
14098: DISABLE
14099: LD_INT 0
14101: PPUSH
14102: PPUSH
14103: PPUSH
14104: PPUSH
14105: PPUSH
14106: PPUSH
14107: PPUSH
14108: PPUSH
// begin enable ;
14109: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14110: LD_ADDR_VAR 0 3
14114: PUSH
14115: LD_INT 22
14117: PUSH
14118: LD_INT 3
14120: PUSH
14121: EMPTY
14122: LIST
14123: LIST
14124: PUSH
14125: LD_INT 21
14127: PUSH
14128: LD_INT 3
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: PUSH
14135: LD_INT 3
14137: PUSH
14138: LD_INT 24
14140: PUSH
14141: LD_INT 1000
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: EMPTY
14149: LIST
14150: LIST
14151: PUSH
14152: EMPTY
14153: LIST
14154: LIST
14155: LIST
14156: PPUSH
14157: CALL_OW 69
14161: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14162: LD_ADDR_VAR 0 4
14166: PUSH
14167: LD_INT 22
14169: PUSH
14170: LD_INT 3
14172: PUSH
14173: EMPTY
14174: LIST
14175: LIST
14176: PUSH
14177: LD_INT 25
14179: PUSH
14180: LD_INT 2
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: PPUSH
14191: CALL_OW 69
14195: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14196: LD_ADDR_VAR 0 5
14200: PUSH
14201: LD_INT 22
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: PUSH
14211: LD_INT 30
14213: PUSH
14214: LD_INT 1
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: PPUSH
14225: CALL_OW 69
14229: PUSH
14230: LD_INT 1
14232: ARRAY
14233: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14234: LD_ADDR_VAR 0 8
14238: PUSH
14239: LD_INT 22
14241: PUSH
14242: LD_INT 3
14244: PUSH
14245: EMPTY
14246: LIST
14247: LIST
14248: PUSH
14249: LD_INT 2
14251: PUSH
14252: LD_INT 30
14254: PUSH
14255: LD_INT 6
14257: PUSH
14258: EMPTY
14259: LIST
14260: LIST
14261: PUSH
14262: LD_INT 30
14264: PUSH
14265: LD_INT 7
14267: PUSH
14268: EMPTY
14269: LIST
14270: LIST
14271: PUSH
14272: LD_INT 30
14274: PUSH
14275: LD_INT 8
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PUSH
14282: EMPTY
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: PUSH
14297: LD_INT 1
14299: ARRAY
14300: ST_TO_ADDR
// if not engs then
14301: LD_VAR 0 4
14305: NOT
14306: IFFALSE 14310
// exit ;
14308: GO 14872
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14310: LD_ADDR_VAR 0 6
14314: PUSH
14315: LD_VAR 0 4
14319: PPUSH
14320: LD_INT 3
14322: PUSH
14323: LD_INT 24
14325: PUSH
14326: LD_INT 600
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: EMPTY
14334: LIST
14335: LIST
14336: PPUSH
14337: CALL_OW 72
14341: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14342: LD_ADDR_VAR 0 7
14346: PUSH
14347: LD_INT 22
14349: PUSH
14350: LD_INT 3
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: PUSH
14357: LD_INT 25
14359: PUSH
14360: LD_INT 4
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: PPUSH
14371: CALL_OW 69
14375: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14376: LD_VAR 0 3
14380: NOT
14381: PUSH
14382: LD_EXP 37
14386: NOT
14387: AND
14388: IFFALSE 14448
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14390: LD_VAR 0 4
14394: PPUSH
14395: LD_INT 3
14397: PUSH
14398: LD_INT 54
14400: PUSH
14401: EMPTY
14402: LIST
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: PPUSH
14408: CALL_OW 72
14412: IFFALSE 14446
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14414: LD_VAR 0 4
14418: PPUSH
14419: LD_INT 3
14421: PUSH
14422: LD_INT 54
14424: PUSH
14425: EMPTY
14426: LIST
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PPUSH
14432: CALL_OW 72
14436: PPUSH
14437: LD_VAR 0 5
14441: PPUSH
14442: CALL_OW 120
// exit ;
14446: GO 14872
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14448: LD_VAR 0 4
14452: PPUSH
14453: LD_INT 54
14455: PUSH
14456: EMPTY
14457: LIST
14458: PPUSH
14459: CALL_OW 72
14463: IFFALSE 14485
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14465: LD_VAR 0 4
14469: PPUSH
14470: LD_INT 54
14472: PUSH
14473: EMPTY
14474: LIST
14475: PPUSH
14476: CALL_OW 72
14480: PPUSH
14481: CALL_OW 122
// if not tmp then
14485: LD_VAR 0 3
14489: NOT
14490: IFFALSE 14622
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14492: LD_INT 81
14494: PUSH
14495: LD_INT 3
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PUSH
14502: LD_INT 92
14504: PUSH
14505: LD_INT 147
14507: PUSH
14508: LD_INT 212
14510: PUSH
14511: LD_INT 30
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: PPUSH
14524: CALL_OW 69
14528: NOT
14529: IFFALSE 14622
// begin if not HasTask ( engs [ 1 ] ) then
14531: LD_VAR 0 4
14535: PUSH
14536: LD_INT 1
14538: ARRAY
14539: PPUSH
14540: CALL_OW 314
14544: NOT
14545: IFFALSE 14622
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14547: LD_ADDR_VAR 0 2
14551: PUSH
14552: LD_VAR 0 4
14556: PPUSH
14557: LD_EXP 37
14561: PUSH
14562: LD_INT 1
14564: ARRAY
14565: PPUSH
14566: LD_EXP 37
14570: PUSH
14571: LD_INT 2
14573: ARRAY
14574: PPUSH
14575: LD_EXP 37
14579: PUSH
14580: LD_INT 3
14582: ARRAY
14583: PPUSH
14584: LD_EXP 37
14588: PUSH
14589: LD_INT 4
14591: ARRAY
14592: PPUSH
14593: CALL_OW 145
14597: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14598: LD_VAR 0 2
14602: PPUSH
14603: CALL_OW 266
14607: PUSH
14608: LD_INT 4
14610: EQUAL
14611: IFFALSE 14622
// AddComUpgrade ( i ) ;
14613: LD_VAR 0 2
14617: PPUSH
14618: CALL_OW 206
// end ; end ; end ; for i in engs do
14622: LD_ADDR_VAR 0 2
14626: PUSH
14627: LD_VAR 0 4
14631: PUSH
14632: FOR_IN
14633: IFFALSE 14751
// begin if i in to_heal and sci then
14635: LD_VAR 0 2
14639: PUSH
14640: LD_VAR 0 6
14644: IN
14645: PUSH
14646: LD_VAR 0 7
14650: AND
14651: IFFALSE 14702
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14653: LD_VAR 0 2
14657: PPUSH
14658: LD_INT 149
14660: PPUSH
14661: LD_INT 220
14663: PPUSH
14664: CALL_OW 297
14668: PUSH
14669: LD_INT 5
14671: LESS
14672: IFFALSE 14676
// continue ;
14674: GO 14632
// ComMoveXY ( i , 149 , 220 ) ;
14676: LD_VAR 0 2
14680: PPUSH
14681: LD_INT 149
14683: PPUSH
14684: LD_INT 220
14686: PPUSH
14687: CALL_OW 111
// AddComHold ( i ) ;
14691: LD_VAR 0 2
14695: PPUSH
14696: CALL_OW 200
// end else
14700: GO 14749
// if not HasTask ( i ) or WantsToAttack ( i ) then
14702: LD_VAR 0 2
14706: PPUSH
14707: CALL_OW 314
14711: NOT
14712: PUSH
14713: LD_VAR 0 2
14717: PPUSH
14718: CALL_OW 319
14722: OR
14723: IFFALSE 14749
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14725: LD_VAR 0 2
14729: PPUSH
14730: LD_VAR 0 3
14734: PPUSH
14735: LD_VAR 0 2
14739: PPUSH
14740: CALL_OW 74
14744: PPUSH
14745: CALL_OW 130
// end ;
14749: GO 14632
14751: POP
14752: POP
// if to_heal and sci then
14753: LD_VAR 0 6
14757: PUSH
14758: LD_VAR 0 7
14762: AND
14763: IFFALSE 14824
// begin if UnitFilter ( sci , [ f_inside ] ) then
14765: LD_VAR 0 7
14769: PPUSH
14770: LD_INT 54
14772: PUSH
14773: EMPTY
14774: LIST
14775: PPUSH
14776: CALL_OW 72
14780: IFFALSE 14804
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14782: LD_VAR 0 7
14786: PPUSH
14787: LD_INT 54
14789: PUSH
14790: EMPTY
14791: LIST
14792: PPUSH
14793: CALL_OW 72
14797: PPUSH
14798: CALL_OW 122
14802: GO 14822
// ComHeal ( sci , to_heal [ 1 ] ) ;
14804: LD_VAR 0 7
14808: PPUSH
14809: LD_VAR 0 6
14813: PUSH
14814: LD_INT 1
14816: ARRAY
14817: PPUSH
14818: CALL_OW 128
// end else
14822: GO 14872
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14824: LD_VAR 0 7
14828: PPUSH
14829: LD_INT 56
14831: PUSH
14832: EMPTY
14833: LIST
14834: PPUSH
14835: CALL_OW 72
14839: PUSH
14840: LD_VAR 0 8
14844: AND
14845: IFFALSE 14872
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14847: LD_VAR 0 7
14851: PPUSH
14852: LD_INT 56
14854: PUSH
14855: EMPTY
14856: LIST
14857: PPUSH
14858: CALL_OW 72
14862: PPUSH
14863: LD_VAR 0 8
14867: PPUSH
14868: CALL_OW 120
// end ;
14872: PPOPN 8
14874: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14875: LD_INT 22
14877: PUSH
14878: LD_INT 3
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 30
14887: PUSH
14888: LD_INT 3
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: PPUSH
14899: CALL_OW 69
14903: PUSH
14904: LD_EXP 38
14908: AND
14909: IFFALSE 15035
14911: GO 14913
14913: DISABLE
14914: LD_INT 0
14916: PPUSH
14917: PPUSH
14918: PPUSH
// begin enable ;
14919: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14920: LD_ADDR_VAR 0 3
14924: PUSH
14925: LD_INT 22
14927: PUSH
14928: LD_INT 3
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: PUSH
14935: LD_INT 30
14937: PUSH
14938: LD_INT 3
14940: PUSH
14941: EMPTY
14942: LIST
14943: LIST
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PPUSH
14949: CALL_OW 69
14953: PUSH
14954: LD_INT 1
14956: ARRAY
14957: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14958: LD_VAR 0 3
14962: PPUSH
14963: CALL_OW 313
14967: PUSH
14968: LD_INT 0
14970: EQUAL
14971: IFFALSE 14975
// exit ;
14973: GO 15035
// if BuildingStatus ( fac ) = bs_idle then
14975: LD_VAR 0 3
14979: PPUSH
14980: CALL_OW 461
14984: PUSH
14985: LD_INT 2
14987: EQUAL
14988: IFFALSE 15035
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14990: LD_VAR 0 3
14994: PPUSH
14995: LD_EXP 38
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PPUSH
15004: LD_EXP 38
15008: PUSH
15009: LD_INT 2
15011: ARRAY
15012: PPUSH
15013: LD_EXP 38
15017: PUSH
15018: LD_INT 3
15020: ARRAY
15021: PPUSH
15022: LD_EXP 38
15026: PUSH
15027: LD_INT 4
15029: ARRAY
15030: PPUSH
15031: CALL_OW 125
// end ;
15035: PPOPN 3
15037: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15038: LD_INT 0
15040: PPUSH
15041: PPUSH
15042: PPUSH
15043: PPUSH
15044: PPUSH
// uc_side := 3 ;
15045: LD_ADDR_OWVAR 20
15049: PUSH
15050: LD_INT 3
15052: ST_TO_ADDR
// uc_nation := 3 ;
15053: LD_ADDR_OWVAR 21
15057: PUSH
15058: LD_INT 3
15060: ST_TO_ADDR
// ru_can_attack := false ;
15061: LD_ADDR_EXP 8
15065: PUSH
15066: LD_INT 0
15068: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15069: LD_ADDR_VAR 0 6
15073: PUSH
15074: LD_INT 22
15076: PUSH
15077: LD_INT 3
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: PUSH
15084: LD_INT 30
15086: PUSH
15087: LD_INT 3
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PPUSH
15098: CALL_OW 69
15102: ST_TO_ADDR
// if fac then
15103: LD_VAR 0 6
15107: IFFALSE 15259
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15109: LD_ADDR_EXP 38
15113: PUSH
15114: LD_INT 24
15116: PUSH
15117: LD_INT 1
15119: PUSH
15120: LD_INT 3
15122: PUSH
15123: LD_INT 43
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: LIST
15130: LIST
15131: ST_TO_ADDR
// if wave > 1 then
15132: LD_VAR 0 1
15136: PUSH
15137: LD_INT 1
15139: GREATER
15140: IFFALSE 15193
// for i = 1 to Difficulty do
15142: LD_ADDR_VAR 0 3
15146: PUSH
15147: DOUBLE
15148: LD_INT 1
15150: DEC
15151: ST_TO_ADDR
15152: LD_OWVAR 67
15156: PUSH
15157: FOR_TO
15158: IFFALSE 15191
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15160: LD_ADDR_EXP 38
15164: PUSH
15165: LD_EXP 38
15169: PUSH
15170: LD_INT 24
15172: PUSH
15173: LD_INT 1
15175: PUSH
15176: LD_INT 3
15178: PUSH
15179: LD_INT 45
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: LIST
15186: LIST
15187: ADD
15188: ST_TO_ADDR
15189: GO 15157
15191: POP
15192: POP
// repeat wait ( 0 0$1 ) ;
15193: LD_INT 35
15195: PPUSH
15196: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15200: LD_EXP 38
15204: PUSH
15205: LD_INT 4
15207: LESS
15208: PUSH
15209: LD_VAR 0 6
15213: PUSH
15214: LD_INT 1
15216: ARRAY
15217: PPUSH
15218: CALL_OW 313
15222: PUSH
15223: LD_INT 0
15225: EQUAL
15226: OR
15227: PUSH
15228: LD_VAR 0 6
15232: PUSH
15233: LD_INT 1
15235: ARRAY
15236: PPUSH
15237: CALL_OW 461
15241: PUSH
15242: LD_INT 8
15244: PUSH
15245: LD_INT 6
15247: PUSH
15248: LD_INT 7
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: IN
15256: OR
15257: IFFALSE 15193
// end ; case wave of 1 :
15259: LD_VAR 0 1
15263: PUSH
15264: LD_INT 1
15266: DOUBLE
15267: EQUAL
15268: IFTRUE 15272
15270: GO 15357
15272: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
15273: LD_ADDR_VAR 0 3
15277: PUSH
15278: DOUBLE
15279: LD_INT 1
15281: DEC
15282: ST_TO_ADDR
15283: LD_INT 3
15285: PUSH
15286: LD_INT 4
15288: PUSH
15289: LD_INT 5
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: LIST
15296: PUSH
15297: LD_OWVAR 67
15301: ARRAY
15302: PUSH
15303: FOR_TO
15304: IFFALSE 15312
// Sold ;
15306: CALL 15583 0 0
15310: GO 15303
15312: POP
15313: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15314: LD_ADDR_VAR 0 3
15318: PUSH
15319: DOUBLE
15320: LD_INT 1
15322: DEC
15323: ST_TO_ADDR
15324: LD_INT 2
15326: PUSH
15327: LD_INT 3
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: LIST
15337: PUSH
15338: LD_OWVAR 67
15342: ARRAY
15343: PUSH
15344: FOR_TO
15345: IFFALSE 15353
// Tank ;
15347: CALL 15713 0 0
15351: GO 15344
15353: POP
15354: POP
// end ; 2 .. 9 :
15355: GO 15570
15357: LD_INT 2
15359: DOUBLE
15360: GREATEREQUAL
15361: IFFALSE 15369
15363: LD_INT 9
15365: DOUBLE
15366: LESSEQUAL
15367: IFTRUE 15371
15369: GO 15476
15371: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15372: LD_ADDR_VAR 0 3
15376: PUSH
15377: DOUBLE
15378: LD_INT 1
15380: DEC
15381: ST_TO_ADDR
15382: LD_INT 3
15384: PUSH
15385: LD_INT 4
15387: PUSH
15388: LD_INT 5
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: LIST
15395: PUSH
15396: LD_OWVAR 67
15400: ARRAY
15401: PUSH
15402: LD_VAR 0 1
15406: PUSH
15407: LD_INT 2
15409: DIV
15410: PLUS
15411: PUSH
15412: FOR_TO
15413: IFFALSE 15421
// Sold ;
15415: CALL 15583 0 0
15419: GO 15412
15421: POP
15422: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15423: LD_ADDR_VAR 0 3
15427: PUSH
15428: DOUBLE
15429: LD_INT 1
15431: DEC
15432: ST_TO_ADDR
15433: LD_INT 2
15435: PUSH
15436: LD_INT 3
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: LIST
15446: PUSH
15447: LD_OWVAR 67
15451: ARRAY
15452: PUSH
15453: LD_VAR 0 1
15457: PUSH
15458: LD_INT 2
15460: DIV
15461: PLUS
15462: PUSH
15463: FOR_TO
15464: IFFALSE 15472
// Tank ;
15466: CALL 15713 0 0
15470: GO 15463
15472: POP
15473: POP
// end ; 10 :
15474: GO 15570
15476: LD_INT 10
15478: DOUBLE
15479: EQUAL
15480: IFTRUE 15484
15482: GO 15569
15484: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15485: LD_ADDR_VAR 0 3
15489: PUSH
15490: DOUBLE
15491: LD_INT 1
15493: DEC
15494: ST_TO_ADDR
15495: LD_INT 10
15497: PUSH
15498: LD_INT 12
15500: PUSH
15501: LD_INT 14
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: LIST
15508: PUSH
15509: LD_OWVAR 67
15513: ARRAY
15514: PUSH
15515: FOR_TO
15516: IFFALSE 15524
// Sold ;
15518: CALL 15583 0 0
15522: GO 15515
15524: POP
15525: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15526: LD_ADDR_VAR 0 3
15530: PUSH
15531: DOUBLE
15532: LD_INT 1
15534: DEC
15535: ST_TO_ADDR
15536: LD_INT 11
15538: PUSH
15539: LD_INT 13
15541: PUSH
15542: LD_INT 15
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: LIST
15549: PUSH
15550: LD_OWVAR 67
15554: ARRAY
15555: PUSH
15556: FOR_TO
15557: IFFALSE 15565
// Tank ;
15559: CALL 15713 0 0
15563: GO 15556
15565: POP
15566: POP
// end ; end ;
15567: GO 15570
15569: POP
// ru_can_attack := true ;
15570: LD_ADDR_EXP 8
15574: PUSH
15575: LD_INT 1
15577: ST_TO_ADDR
// end ;
15578: LD_VAR 0 2
15582: RET
// function Sold ( ) ; var un , skill ; begin
15583: LD_INT 0
15585: PPUSH
15586: PPUSH
15587: PPUSH
// uc_side := 3 ;
15588: LD_ADDR_OWVAR 20
15592: PUSH
15593: LD_INT 3
15595: ST_TO_ADDR
// uc_nation := 3 ;
15596: LD_ADDR_OWVAR 21
15600: PUSH
15601: LD_INT 3
15603: ST_TO_ADDR
// InitHc ;
15604: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15608: LD_ADDR_VAR 0 3
15612: PUSH
15613: LD_INT 6
15615: PUSH
15616: LD_INT 7
15618: PUSH
15619: LD_INT 7
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: LIST
15626: PUSH
15627: LD_OWVAR 67
15631: ARRAY
15632: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15633: LD_INT 0
15635: PPUSH
15636: LD_INT 1
15638: PUSH
15639: LD_INT 9
15641: PUSH
15642: EMPTY
15643: LIST
15644: LIST
15645: PUSH
15646: LD_INT 1
15648: PPUSH
15649: LD_INT 2
15651: PPUSH
15652: CALL_OW 12
15656: ARRAY
15657: PPUSH
15658: LD_VAR 0 3
15662: PPUSH
15663: CALL_OW 380
// un := CreateHuman ;
15667: LD_ADDR_VAR 0 2
15671: PUSH
15672: CALL_OW 44
15676: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15677: LD_VAR 0 2
15681: PPUSH
15682: LD_INT 4
15684: PPUSH
15685: LD_INT 0
15687: PPUSH
15688: CALL_OW 49
// ru_force := ru_force ^ un ;
15692: LD_ADDR_EXP 36
15696: PUSH
15697: LD_EXP 36
15701: PUSH
15702: LD_VAR 0 2
15706: ADD
15707: ST_TO_ADDR
// end ;
15708: LD_VAR 0 1
15712: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15713: LD_INT 0
15715: PPUSH
15716: PPUSH
15717: PPUSH
15718: PPUSH
15719: PPUSH
// uc_side := 3 ;
15720: LD_ADDR_OWVAR 20
15724: PUSH
15725: LD_INT 3
15727: ST_TO_ADDR
// uc_nation := 3 ;
15728: LD_ADDR_OWVAR 21
15732: PUSH
15733: LD_INT 3
15735: ST_TO_ADDR
// InitHc ;
15736: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15740: LD_ADDR_VAR 0 5
15744: PUSH
15745: LD_INT 5
15747: PUSH
15748: LD_INT 6
15750: PUSH
15751: LD_INT 7
15753: PUSH
15754: EMPTY
15755: LIST
15756: LIST
15757: LIST
15758: PUSH
15759: LD_OWVAR 67
15763: ARRAY
15764: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15765: LD_ADDR_VAR 0 3
15769: PUSH
15770: LD_INT 22
15772: PUSH
15773: LD_INT 24
15775: PUSH
15776: EMPTY
15777: LIST
15778: LIST
15779: PUSH
15780: LD_INT 1
15782: PPUSH
15783: LD_INT 2
15785: PPUSH
15786: CALL_OW 12
15790: ARRAY
15791: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15792: LD_VAR 0 3
15796: PUSH
15797: LD_INT 22
15799: EQUAL
15800: IFFALSE 15835
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15802: LD_ADDR_VAR 0 4
15806: PUSH
15807: LD_INT 45
15809: PUSH
15810: LD_INT 43
15812: PUSH
15813: LD_INT 44
15815: PUSH
15816: EMPTY
15817: LIST
15818: LIST
15819: LIST
15820: PUSH
15821: LD_INT 1
15823: PPUSH
15824: LD_INT 3
15826: PPUSH
15827: CALL_OW 12
15831: ARRAY
15832: ST_TO_ADDR
15833: GO 15866
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15835: LD_ADDR_VAR 0 4
15839: PUSH
15840: LD_INT 46
15842: PUSH
15843: LD_INT 44
15845: PUSH
15846: LD_INT 45
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: LIST
15853: PUSH
15854: LD_INT 1
15856: PPUSH
15857: LD_INT 3
15859: PPUSH
15860: CALL_OW 12
15864: ARRAY
15865: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15866: LD_ADDR_VAR 0 2
15870: PUSH
15871: LD_INT 3
15873: PPUSH
15874: LD_INT 3
15876: PPUSH
15877: LD_VAR 0 3
15881: PPUSH
15882: LD_INT 1
15884: PPUSH
15885: LD_INT 3
15887: PUSH
15888: LD_INT 3
15890: PUSH
15891: LD_INT 3
15893: PUSH
15894: LD_INT 1
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: LIST
15901: LIST
15902: PUSH
15903: LD_INT 1
15905: PPUSH
15906: LD_INT 4
15908: PPUSH
15909: CALL_OW 12
15913: ARRAY
15914: PPUSH
15915: LD_VAR 0 4
15919: PPUSH
15920: LD_INT 99
15922: PPUSH
15923: CALL 289 0 7
15927: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15928: LD_VAR 0 2
15932: PPUSH
15933: CALL_OW 263
15937: PUSH
15938: LD_INT 1
15940: EQUAL
15941: IFFALSE 15972
// begin PrepareHuman ( false , 3 , skill ) ;
15943: LD_INT 0
15945: PPUSH
15946: LD_INT 3
15948: PPUSH
15949: LD_VAR 0 5
15953: PPUSH
15954: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15958: CALL_OW 44
15962: PPUSH
15963: LD_VAR 0 2
15967: PPUSH
15968: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15972: LD_VAR 0 2
15976: PPUSH
15977: LD_INT 3
15979: PPUSH
15980: LD_INT 0
15982: PPUSH
15983: CALL_OW 49
// ru_force := ru_force ^ un ;
15987: LD_ADDR_EXP 36
15991: PUSH
15992: LD_EXP 36
15996: PUSH
15997: LD_VAR 0 2
16001: ADD
16002: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16003: LD_VAR 0 2
16007: PPUSH
16008: LD_INT 126
16010: PPUSH
16011: LD_INT 158
16013: PPUSH
16014: CALL_OW 111
// Wait ( 0 0$3 ) ;
16018: LD_INT 105
16020: PPUSH
16021: CALL_OW 67
// ComStop ( un ) ;
16025: LD_VAR 0 2
16029: PPUSH
16030: CALL_OW 141
// end ;
16034: LD_VAR 0 1
16038: RET
// every 0 0$1 do var i , time , wave ;
16039: GO 16041
16041: DISABLE
16042: LD_INT 0
16044: PPUSH
16045: PPUSH
16046: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16047: LD_ADDR_VAR 0 2
16051: PUSH
16052: LD_INT 25200
16054: PUSH
16055: LD_INT 24150
16057: PUSH
16058: LD_INT 23100
16060: PUSH
16061: EMPTY
16062: LIST
16063: LIST
16064: LIST
16065: PUSH
16066: LD_OWVAR 67
16070: ARRAY
16071: ST_TO_ADDR
// wait ( time ) ;
16072: LD_VAR 0 2
16076: PPUSH
16077: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16081: LD_ADDR_VAR 0 2
16085: PUSH
16086: LD_INT 15750
16088: PUSH
16089: LD_INT 15400
16091: PUSH
16092: LD_INT 15050
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: LIST
16099: PUSH
16100: LD_OWVAR 67
16104: ARRAY
16105: ST_TO_ADDR
// wave := 0 ;
16106: LD_ADDR_VAR 0 3
16110: PUSH
16111: LD_INT 0
16113: ST_TO_ADDR
// while true do
16114: LD_INT 1
16116: IFFALSE 16220
// begin wave := wave + 1 ;
16118: LD_ADDR_VAR 0 3
16122: PUSH
16123: LD_VAR 0 3
16127: PUSH
16128: LD_INT 1
16130: PLUS
16131: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16132: LD_INT 22
16134: PUSH
16135: LD_INT 2
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PPUSH
16142: CALL_OW 69
16146: IFFALSE 16182
// begin repeat wait ( 0 0$1 ) ;
16148: LD_INT 35
16150: PPUSH
16151: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16155: LD_INT 22
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PPUSH
16165: CALL_OW 69
16169: PUSH
16170: LD_INT 0
16172: EQUAL
16173: IFFALSE 16148
// wait ( 1 1$30 ) ;
16175: LD_INT 3150
16177: PPUSH
16178: CALL_OW 67
// end ; if ru_force < 20 then
16182: LD_EXP 36
16186: PUSH
16187: LD_INT 20
16189: LESS
16190: IFFALSE 16201
// PrepareAttack ( wave ) ;
16192: LD_VAR 0 3
16196: PPUSH
16197: CALL 15038 0 1
// ru_can_attack := true ;
16201: LD_ADDR_EXP 8
16205: PUSH
16206: LD_INT 1
16208: ST_TO_ADDR
// wait ( time ) ;
16209: LD_VAR 0 2
16213: PPUSH
16214: CALL_OW 67
// end ;
16218: GO 16114
// end ;
16220: PPOPN 3
16222: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16223: LD_EXP 8
16227: PUSH
16228: LD_EXP 36
16232: AND
16233: IFFALSE 17067
16235: GO 16237
16237: DISABLE
16238: LD_INT 0
16240: PPUSH
16241: PPUSH
16242: PPUSH
16243: PPUSH
16244: PPUSH
16245: PPUSH
16246: PPUSH
16247: PPUSH
16248: PPUSH
// begin enable ;
16249: ENABLE
// points1 := [ 107 , 123 ] ;
16250: LD_ADDR_VAR 0 4
16254: PUSH
16255: LD_INT 107
16257: PUSH
16258: LD_INT 123
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16265: LD_ADDR_VAR 0 5
16269: PUSH
16270: LD_INT 55
16272: PUSH
16273: LD_INT 42
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16280: LD_ADDR_VAR 0 6
16284: PUSH
16285: LD_INT 102
16287: PUSH
16288: LD_INT 140
16290: PUSH
16291: EMPTY
16292: LIST
16293: LIST
16294: PUSH
16295: LD_INT 105
16297: PUSH
16298: LD_INT 142
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PUSH
16305: LD_INT 129
16307: PUSH
16308: LD_INT 131
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: PUSH
16315: EMPTY
16316: LIST
16317: LIST
16318: LIST
16319: ST_TO_ADDR
// for i in ru_force do
16320: LD_ADDR_VAR 0 1
16324: PUSH
16325: LD_EXP 36
16329: PUSH
16330: FOR_IN
16331: IFFALSE 17065
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16333: LD_ADDR_VAR 0 3
16337: PUSH
16338: LD_INT 81
16340: PUSH
16341: LD_INT 3
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: PPUSH
16348: CALL_OW 69
16352: PPUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 74
16362: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16363: LD_VAR 0 1
16367: PPUSH
16368: LD_VAR 0 3
16372: PPUSH
16373: CALL_OW 296
16377: PUSH
16378: LD_INT 12
16380: LESS
16381: IFFALSE 16526
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16383: LD_VAR 0 1
16387: PPUSH
16388: CALL_OW 247
16392: PUSH
16393: LD_INT 1
16395: EQUAL
16396: PUSH
16397: LD_VAR 0 1
16401: PPUSH
16402: CALL_OW 257
16406: PUSH
16407: LD_INT 1
16409: EQUAL
16410: AND
16411: PUSH
16412: LD_VAR 0 3
16416: PUSH
16417: LD_INT 21
16419: PUSH
16420: LD_INT 2
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: PUSH
16427: LD_INT 58
16429: PUSH
16430: EMPTY
16431: LIST
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PPUSH
16437: CALL_OW 69
16441: IN
16442: AND
16443: IFFALSE 16461
// ComEnterUnit ( i , un ) else
16445: LD_VAR 0 1
16449: PPUSH
16450: LD_VAR 0 3
16454: PPUSH
16455: CALL_OW 120
16459: GO 16524
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16461: LD_VAR 0 3
16465: PUSH
16466: LD_INT 21
16468: PUSH
16469: LD_INT 2
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: LD_INT 58
16478: PUSH
16479: EMPTY
16480: LIST
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PPUSH
16486: CALL_OW 69
16490: IN
16491: NOT
16492: IFFALSE 16510
// ComAttackUnit ( i , un ) else
16494: LD_VAR 0 1
16498: PPUSH
16499: LD_VAR 0 3
16503: PPUSH
16504: CALL_OW 115
16508: GO 16524
// ComAttackUnit ( i , JMM ) ;
16510: LD_VAR 0 1
16514: PPUSH
16515: LD_EXP 19
16519: PPUSH
16520: CALL_OW 115
// end else
16524: GO 17063
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16526: LD_VAR 0 1
16530: PPUSH
16531: LD_VAR 0 4
16535: PUSH
16536: LD_INT 1
16538: ARRAY
16539: PPUSH
16540: LD_VAR 0 4
16544: PUSH
16545: LD_INT 2
16547: ARRAY
16548: PPUSH
16549: CALL_OW 297
16553: PUSH
16554: LD_VAR 0 1
16558: PPUSH
16559: LD_VAR 0 5
16563: PUSH
16564: LD_INT 1
16566: ARRAY
16567: PPUSH
16568: LD_VAR 0 5
16572: PUSH
16573: LD_INT 2
16575: ARRAY
16576: PPUSH
16577: CALL_OW 297
16581: GREATER
16582: PUSH
16583: LD_EXP 9
16587: AND
16588: PUSH
16589: LD_INT 9
16591: PPUSH
16592: LD_INT 81
16594: PUSH
16595: LD_INT 3
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PPUSH
16602: CALL_OW 70
16606: PUSH
16607: LD_INT 0
16609: EQUAL
16610: OR
16611: IFFALSE 16649
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16613: LD_VAR 0 1
16617: PPUSH
16618: LD_INT 81
16620: PUSH
16621: LD_INT 3
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: PPUSH
16628: CALL_OW 69
16632: PPUSH
16633: LD_VAR 0 1
16637: PPUSH
16638: CALL_OW 74
16642: PPUSH
16643: CALL_OW 115
16647: GO 17063
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16649: LD_VAR 0 1
16653: PPUSH
16654: CALL_OW 264
16658: PUSH
16659: LD_INT 45
16661: EQUAL
16662: PUSH
16663: LD_EXP 36
16667: PPUSH
16668: LD_INT 3
16670: PUSH
16671: LD_INT 34
16673: PUSH
16674: LD_INT 45
16676: PUSH
16677: EMPTY
16678: LIST
16679: LIST
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PPUSH
16685: CALL_OW 72
16689: PUSH
16690: LD_INT 6
16692: GREATER
16693: AND
16694: IFFALSE 16875
// begin dist := 9999 ;
16696: LD_ADDR_VAR 0 8
16700: PUSH
16701: LD_INT 9999
16703: ST_TO_ADDR
// xy := 0 ;
16704: LD_ADDR_VAR 0 9
16708: PUSH
16709: LD_INT 0
16711: ST_TO_ADDR
// for x in pointsr do
16712: LD_ADDR_VAR 0 7
16716: PUSH
16717: LD_VAR 0 6
16721: PUSH
16722: FOR_IN
16723: IFFALSE 16871
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16725: LD_VAR 0 1
16729: PPUSH
16730: LD_VAR 0 7
16734: PUSH
16735: LD_INT 1
16737: ARRAY
16738: PPUSH
16739: LD_VAR 0 7
16743: PUSH
16744: LD_INT 2
16746: ARRAY
16747: PPUSH
16748: CALL_OW 297
16752: PUSH
16753: LD_VAR 0 8
16757: LESS
16758: IFFALSE 16803
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16760: LD_ADDR_VAR 0 8
16764: PUSH
16765: LD_VAR 0 1
16769: PPUSH
16770: LD_VAR 0 7
16774: PUSH
16775: LD_INT 1
16777: ARRAY
16778: PPUSH
16779: LD_VAR 0 7
16783: PUSH
16784: LD_INT 2
16786: ARRAY
16787: PPUSH
16788: CALL_OW 297
16792: ST_TO_ADDR
// xy := x ;
16793: LD_ADDR_VAR 0 9
16797: PUSH
16798: LD_VAR 0 7
16802: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16803: LD_VAR 0 9
16807: PUSH
16808: LD_VAR 0 1
16812: PPUSH
16813: LD_VAR 0 9
16817: PUSH
16818: LD_INT 1
16820: ARRAY
16821: PPUSH
16822: LD_VAR 0 9
16826: PUSH
16827: LD_INT 2
16829: ARRAY
16830: PPUSH
16831: CALL_OW 297
16835: PUSH
16836: LD_INT 9
16838: GREATER
16839: AND
16840: IFFALSE 16869
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16842: LD_VAR 0 1
16846: PPUSH
16847: LD_VAR 0 9
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: PPUSH
16856: LD_VAR 0 9
16860: PUSH
16861: LD_INT 2
16863: ARRAY
16864: PPUSH
16865: CALL_OW 114
// end ;
16869: GO 16722
16871: POP
16872: POP
// end else
16873: GO 17063
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16875: LD_ADDR_VAR 0 3
16879: PUSH
16880: LD_OWVAR 3
16884: PUSH
16885: LD_VAR 0 1
16889: DIFF
16890: PPUSH
16891: LD_VAR 0 1
16895: PPUSH
16896: CALL_OW 74
16900: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16901: LD_VAR 0 1
16905: PPUSH
16906: CALL_OW 320
16910: NOT
16911: PUSH
16912: LD_VAR 0 3
16916: PUSH
16917: LD_INT 21
16919: PUSH
16920: LD_INT 2
16922: PUSH
16923: EMPTY
16924: LIST
16925: LIST
16926: PUSH
16927: LD_INT 33
16929: PUSH
16930: LD_INT 1
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: PUSH
16937: LD_INT 58
16939: PUSH
16940: EMPTY
16941: LIST
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: LIST
16947: PPUSH
16948: CALL_OW 69
16952: IN
16953: PUSH
16954: LD_VAR 0 3
16958: PUSH
16959: LD_INT 22
16961: PUSH
16962: LD_INT 3
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: PUSH
16969: LD_INT 21
16971: PUSH
16972: LD_INT 2
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: LD_INT 3
16981: PUSH
16982: LD_INT 24
16984: PUSH
16985: LD_INT 249
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL_OW 69
17005: IN
17006: OR
17007: AND
17008: IFFALSE 17026
// ComAttackUnit ( i , un ) else
17010: LD_VAR 0 1
17014: PPUSH
17015: LD_VAR 0 3
17019: PPUSH
17020: CALL_OW 115
17024: GO 17063
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17026: LD_VAR 0 1
17030: PPUSH
17031: LD_INT 9
17033: PPUSH
17034: LD_INT 81
17036: PUSH
17037: LD_INT 3
17039: PUSH
17040: EMPTY
17041: LIST
17042: LIST
17043: PPUSH
17044: CALL_OW 70
17048: PPUSH
17049: LD_VAR 0 1
17053: PPUSH
17054: CALL_OW 74
17058: PPUSH
17059: CALL_OW 115
// end ; end ; end ; end ;
17063: GO 16330
17065: POP
17066: POP
// end ;
17067: PPOPN 9
17069: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17070: LD_INT 22
17072: PUSH
17073: LD_INT 3
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: LD_INT 32
17082: PUSH
17083: LD_INT 1
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PUSH
17090: EMPTY
17091: LIST
17092: LIST
17093: PPUSH
17094: CALL_OW 69
17098: IFFALSE 17186
17100: GO 17102
17102: DISABLE
17103: LD_INT 0
17105: PPUSH
17106: PPUSH
// begin enable ;
17107: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17108: LD_ADDR_VAR 0 2
17112: PUSH
17113: LD_INT 22
17115: PUSH
17116: LD_INT 3
17118: PUSH
17119: EMPTY
17120: LIST
17121: LIST
17122: PUSH
17123: LD_INT 32
17125: PUSH
17126: LD_INT 1
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: PPUSH
17137: CALL_OW 69
17141: ST_TO_ADDR
// for i in tmp do
17142: LD_ADDR_VAR 0 1
17146: PUSH
17147: LD_VAR 0 2
17151: PUSH
17152: FOR_IN
17153: IFFALSE 17184
// if GetFuel ( i ) < 12 then
17155: LD_VAR 0 1
17159: PPUSH
17160: CALL_OW 261
17164: PUSH
17165: LD_INT 12
17167: LESS
17168: IFFALSE 17182
// SetFuel ( i , 12 ) ;
17170: LD_VAR 0 1
17174: PPUSH
17175: LD_INT 12
17177: PPUSH
17178: CALL_OW 240
17182: GO 17152
17184: POP
17185: POP
// end ;
17186: PPOPN 2
17188: END
// every 0 0$1 trigger can_end do
17189: LD_EXP 17
17193: IFFALSE 17216
17195: GO 17197
17197: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17198: LD_INT 3325
17200: PPUSH
17201: CALL_OW 67
// PrepareAttack ( 10 ) ;
17205: LD_INT 10
17207: PPUSH
17208: CALL 15038 0 1
// until false ;
17212: LD_INT 0
17214: IFFALSE 17198
// end ;
17216: END
