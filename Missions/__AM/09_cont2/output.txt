// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12586 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1745 0 0
// Action ;
  32: CALL 2620 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1713
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// for i = 1 to 4 do
1676: LD_ADDR_VAR 0 5
1680: PUSH
1681: DOUBLE
1682: LD_INT 1
1684: DEC
1685: ST_TO_ADDR
1686: LD_INT 4
1688: PUSH
1689: FOR_TO
1690: IFFALSE 1711
// AddExperience ( Houten , i , 10000 ) ;
1692: LD_EXP 22
1696: PPUSH
1697: LD_VAR 0 5
1701: PPUSH
1702: LD_INT 10000
1704: PPUSH
1705: CALL_OW 492
1709: GO 1689
1711: POP
1712: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1713: LD_ADDR_EXP 25
1717: PUSH
1718: LD_STRING Powell
1720: PPUSH
1721: LD_INT 0
1723: PPUSH
1724: LD_STRING 
1726: PPUSH
1727: CALL 201 0 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// InitUc ;
1736: CALL_OW 18
// end ;
1740: LD_VAR 0 1
1744: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1745: LD_INT 0
1747: PPUSH
1748: PPUSH
1749: PPUSH
1750: PPUSH
1751: PPUSH
// uc_side := 4 ;
1752: LD_ADDR_OWVAR 20
1756: PUSH
1757: LD_INT 4
1759: ST_TO_ADDR
// uc_nation := 3 ;
1760: LD_ADDR_OWVAR 21
1764: PUSH
1765: LD_INT 3
1767: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_STRING 09_ovsyenko_base
1775: PPUSH
1776: LD_INT 0
1778: PUSH
1779: LD_INT 101
1781: PUSH
1782: LD_INT 118
1784: PUSH
1785: LD_INT 2
1787: PUSH
1788: LD_INT 500
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 31
1800: PUSH
1801: LD_INT 109
1803: PUSH
1804: LD_INT 114
1806: PUSH
1807: LD_INT 4
1809: PUSH
1810: LD_INT 500
1812: PUSH
1813: EMPTY
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_INT 31
1822: PUSH
1823: LD_INT 115
1825: PUSH
1826: LD_INT 132
1828: PUSH
1829: LD_INT 5
1831: PUSH
1832: LD_INT 500
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 31
1844: PUSH
1845: LD_INT 98
1847: PUSH
1848: LD_INT 120
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 500
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: PPUSH
1870: CALL_OW 30
1874: ST_TO_ADDR
// for i in tmp do
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: LD_VAR 0 4
1884: PUSH
1885: FOR_IN
1886: IFFALSE 2042
// begin bc_type := i [ 1 ] ;
1888: LD_ADDR_OWVAR 42
1892: PUSH
1893: LD_VAR 0 2
1897: PUSH
1898: LD_INT 1
1900: ARRAY
1901: ST_TO_ADDR
// bc_level := 3 ;
1902: LD_ADDR_OWVAR 43
1906: PUSH
1907: LD_INT 3
1909: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1910: LD_ADDR_VAR 0 3
1914: PUSH
1915: LD_VAR 0 2
1919: PUSH
1920: LD_INT 2
1922: ARRAY
1923: PPUSH
1924: LD_VAR 0 2
1928: PUSH
1929: LD_INT 3
1931: ARRAY
1932: PPUSH
1933: LD_VAR 0 2
1937: PUSH
1938: LD_INT 4
1940: ARRAY
1941: PPUSH
1942: CALL_OW 47
1946: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1947: LD_VAR 0 3
1951: PPUSH
1952: CALL_OW 266
1956: PUSH
1957: LD_INT 0
1959: EQUAL
1960: IFFALSE 1994
// begin SetBName ( b , ovsyenko ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: LD_STRING ovsyenko
1969: PPUSH
1970: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1974: LD_VAR 0 3
1978: PPUSH
1979: CALL_OW 274
1983: PPUSH
1984: LD_INT 1
1986: PPUSH
1987: LD_INT 50
1989: PPUSH
1990: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1994: LD_VAR 0 2
1998: PUSH
1999: LD_INT 5
2001: ARRAY
2002: PUSH
2003: LD_INT 250
2005: LESS
2006: IFFALSE 2022
// SetLives ( b , 333 ) else
2008: LD_VAR 0 3
2012: PPUSH
2013: LD_INT 333
2015: PPUSH
2016: CALL_OW 234
2020: GO 2040
// SetLives ( b , i [ 5 ] ) ;
2022: LD_VAR 0 3
2026: PPUSH
2027: LD_VAR 0 2
2031: PUSH
2032: LD_INT 5
2034: ARRAY
2035: PPUSH
2036: CALL_OW 234
// end ;
2040: GO 1885
2042: POP
2043: POP
// uc_nation := 1 ;
2044: LD_ADDR_OWVAR 21
2048: PUSH
2049: LD_INT 1
2051: ST_TO_ADDR
// tmp := [ ] ;
2052: LD_ADDR_VAR 0 4
2056: PUSH
2057: EMPTY
2058: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2059: LD_ADDR_EXP 19
2063: PUSH
2064: LD_STRING Gary
2066: PPUSH
2067: LD_EXP 2
2071: NOT
2072: PPUSH
2073: LD_STRING 
2075: PPUSH
2076: CALL 201 0 3
2080: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 4
2090: PUSH
2091: LD_EXP 19
2095: ADD
2096: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2097: LD_ADDR_EXP 20
2101: PUSH
2102: LD_STRING Bobby
2104: PPUSH
2105: LD_EXP 2
2109: NOT
2110: PPUSH
2111: LD_STRING 03_
2113: PPUSH
2114: CALL 201 0 3
2118: ST_TO_ADDR
// if Bobby then
2119: LD_EXP 20
2123: IFFALSE 2141
// tmp := tmp ^ Bobby ;
2125: LD_ADDR_VAR 0 4
2129: PUSH
2130: LD_VAR 0 4
2134: PUSH
2135: LD_EXP 20
2139: ADD
2140: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2141: LD_ADDR_EXP 21
2145: PUSH
2146: LD_STRING Cyrus
2148: PPUSH
2149: LD_EXP 2
2153: NOT
2154: PPUSH
2155: LD_STRING 03_
2157: PPUSH
2158: CALL 201 0 3
2162: ST_TO_ADDR
// if Cyrus then
2163: LD_EXP 21
2167: IFFALSE 2185
// tmp := tmp ^ Cyrus ;
2169: LD_ADDR_VAR 0 4
2173: PUSH
2174: LD_VAR 0 4
2178: PUSH
2179: LD_EXP 21
2183: ADD
2184: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2185: LD_ADDR_VAR 0 4
2189: PUSH
2190: LD_VAR 0 4
2194: PUSH
2195: LD_STRING 09_prev_squad
2197: PPUSH
2198: CALL_OW 31
2202: ADD
2203: ST_TO_ADDR
// tmp := tmp diff 0 ;
2204: LD_ADDR_VAR 0 4
2208: PUSH
2209: LD_VAR 0 4
2213: PUSH
2214: LD_INT 0
2216: DIFF
2217: ST_TO_ADDR
// if debug then
2218: LD_EXP 2
2222: IFFALSE 2273
// begin for i = 1 to 6 do
2224: LD_ADDR_VAR 0 2
2228: PUSH
2229: DOUBLE
2230: LD_INT 1
2232: DEC
2233: ST_TO_ADDR
2234: LD_INT 6
2236: PUSH
2237: FOR_TO
2238: IFFALSE 2271
// begin PrepareHuman ( false , 1 , 6 ) ;
2240: LD_INT 0
2242: PPUSH
2243: LD_INT 1
2245: PPUSH
2246: LD_INT 6
2248: PPUSH
2249: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2253: LD_ADDR_VAR 0 4
2257: PUSH
2258: LD_VAR 0 4
2262: PUSH
2263: CALL_OW 44
2267: ADD
2268: ST_TO_ADDR
// end ;
2269: GO 2237
2271: POP
2272: POP
// end ; for i in tmp do
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_VAR 0 4
2282: PUSH
2283: FOR_IN
2284: IFFALSE 2343
// begin if GetClass ( i ) in [ 2 , 3 ] then
2286: LD_VAR 0 2
2290: PPUSH
2291: CALL_OW 257
2295: PUSH
2296: LD_INT 2
2298: PUSH
2299: LD_INT 3
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: IN
2306: IFFALSE 2320
// SetClass ( i , 1 ) ;
2308: LD_VAR 0 2
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: LD_INT 106
2327: PPUSH
2328: LD_INT 122
2330: PPUSH
2331: LD_INT 5
2333: PPUSH
2334: LD_INT 0
2336: PPUSH
2337: CALL_OW 50
// end ;
2341: GO 2283
2343: POP
2344: POP
// tmp := tmp diff Gary ;
2345: LD_ADDR_VAR 0 4
2349: PUSH
2350: LD_VAR 0 4
2354: PUSH
2355: LD_EXP 19
2359: DIFF
2360: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2361: LD_ADDR_VAR 0 3
2365: PUSH
2366: LD_INT 22
2368: PUSH
2369: LD_INT 4
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: LD_INT 30
2378: PUSH
2379: LD_INT 31
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: PPUSH
2390: CALL_OW 69
2394: ST_TO_ADDR
// for i = 1 to b do
2395: LD_ADDR_VAR 0 2
2399: PUSH
2400: DOUBLE
2401: LD_INT 1
2403: DEC
2404: ST_TO_ADDR
2405: LD_VAR 0 3
2409: PUSH
2410: FOR_TO
2411: IFFALSE 2441
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2413: LD_VAR 0 4
2417: PUSH
2418: LD_VAR 0 2
2422: ARRAY
2423: PPUSH
2424: LD_VAR 0 3
2428: PUSH
2429: LD_VAR 0 2
2433: ARRAY
2434: PPUSH
2435: CALL_OW 120
// end ;
2439: GO 2410
2441: POP
2442: POP
// InitHc ;
2443: CALL_OW 19
// InitUc ;
2447: CALL_OW 18
// end ;
2451: LD_VAR 0 1
2455: RET
// export function PowellTransport ; var i , un ; begin
2456: LD_INT 0
2458: PPUSH
2459: PPUSH
2460: PPUSH
// uc_side := 4 ;
2461: LD_ADDR_OWVAR 20
2465: PUSH
2466: LD_INT 4
2468: ST_TO_ADDR
// uc_nation := 1 ;
2469: LD_ADDR_OWVAR 21
2473: PUSH
2474: LD_INT 1
2476: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2477: LD_INT 1
2479: PPUSH
2480: LD_INT 3
2482: PPUSH
2483: LD_INT 6
2485: PPUSH
2486: CALL_OW 380
// hc_name :=  ;
2490: LD_ADDR_OWVAR 26
2494: PUSH
2495: LD_STRING 
2497: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2498: LD_ADDR_OWVAR 33
2502: PUSH
2503: LD_STRING SecondCharsGal
2505: ST_TO_ADDR
// hc_face_number := 30 ;
2506: LD_ADDR_OWVAR 34
2510: PUSH
2511: LD_INT 30
2513: ST_TO_ADDR
// powell_trans := CreateHuman ;
2514: LD_ADDR_EXP 24
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// hc_face_number := 31 ;
2524: LD_ADDR_OWVAR 34
2528: PUSH
2529: LD_INT 31
2531: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2532: LD_ADDR_EXP 24
2536: PUSH
2537: LD_EXP 24
2541: PUSH
2542: CALL_OW 44
2546: ADD
2547: ST_TO_ADDR
// for i = 1 to 2 do
2548: LD_ADDR_VAR 0 2
2552: PUSH
2553: DOUBLE
2554: LD_INT 1
2556: DEC
2557: ST_TO_ADDR
2558: LD_INT 2
2560: PUSH
2561: FOR_TO
2562: IFFALSE 2613
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2564: LD_ADDR_VAR 0 3
2568: PUSH
2569: LD_INT 4
2571: PPUSH
2572: LD_INT 1
2574: PPUSH
2575: LD_INT 3
2577: PPUSH
2578: LD_INT 1
2580: PPUSH
2581: LD_INT 1
2583: PPUSH
2584: LD_INT 12
2586: PPUSH
2587: LD_INT 66
2589: PPUSH
2590: CALL 264 0 7
2594: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2595: LD_ADDR_EXP 24
2599: PUSH
2600: LD_EXP 24
2604: PUSH
2605: LD_VAR 0 3
2609: ADD
2610: ST_TO_ADDR
// end ;
2611: GO 2561
2613: POP
2614: POP
// end ; end_of_file
2615: LD_VAR 0 1
2619: RET
// export function Action ; var i , veh ; begin
2620: LD_INT 0
2622: PPUSH
2623: PPUSH
2624: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2625: LD_EXP 23
2629: PPUSH
2630: LD_INT 0
2632: PPUSH
2633: LD_INT 50
2635: PPUSH
2636: LD_INT 38
2638: PPUSH
2639: LD_INT 2
2641: PPUSH
2642: CALL_OW 145
// InGameOn ;
2646: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 9
2655: PPUSH
2656: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2660: LD_EXP 18
2664: PPUSH
2665: LD_INT 54
2667: PPUSH
2668: LD_INT 34
2670: PPUSH
2671: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2675: LD_EXP 18
2679: PPUSH
2680: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2684: LD_EXP 18
2688: PPUSH
2689: LD_EXP 23
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2702: LD_INT 35
2704: PPUSH
2705: CALL_OW 67
// until See ( 4 , JMM ) ;
2709: LD_INT 4
2711: PPUSH
2712: LD_EXP 18
2716: PPUSH
2717: CALL_OW 292
2721: IFFALSE 2702
// CenterNowOnUnits ( JMM ) ;
2723: LD_EXP 18
2727: PPUSH
2728: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2732: LD_EXP 18
2736: PPUSH
2737: LD_STRING D2-JMM-1
2739: PPUSH
2740: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2744: LD_EXP 23
2748: PUSH
2749: LD_INT 3
2751: ARRAY
2752: PPUSH
2753: LD_EXP 18
2757: PPUSH
2758: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2762: LD_EXP 23
2766: PUSH
2767: LD_INT 3
2769: ARRAY
2770: PPUSH
2771: LD_STRING D2-Eng1-1
2773: PPUSH
2774: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2778: LD_EXP 18
2782: PPUSH
2783: LD_STRING D2-JMM-2
2785: PPUSH
2786: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2790: LD_EXP 23
2794: PUSH
2795: LD_INT 3
2797: ARRAY
2798: PPUSH
2799: LD_STRING D2-Eng1-2
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2806: LD_EXP 18
2810: PPUSH
2811: LD_STRING D2-JMM-3
2813: PPUSH
2814: CALL_OW 88
// if Houten then
2818: LD_EXP 22
2822: IFFALSE 3020
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2824: LD_ADDR_VAR 0 3
2828: PUSH
2829: LD_INT 4
2831: PPUSH
2832: LD_INT 1
2834: PPUSH
2835: LD_INT 3
2837: PPUSH
2838: LD_INT 2
2840: PPUSH
2841: LD_INT 1
2843: PPUSH
2844: LD_INT 4
2846: PPUSH
2847: LD_INT 55
2849: PPUSH
2850: CALL 264 0 7
2854: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2855: LD_VAR 0 3
2859: PPUSH
2860: LD_INT 3
2862: PPUSH
2863: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 46
2874: PPUSH
2875: LD_INT 19
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2885: LD_EXP 22
2889: PPUSH
2890: LD_VAR 0 3
2894: PPUSH
2895: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2899: LD_EXP 22
2903: PPUSH
2904: LD_INT 49
2906: PPUSH
2907: LD_INT 33
2909: PPUSH
2910: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2914: LD_EXP 22
2918: PPUSH
2919: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2923: LD_EXP 22
2927: PPUSH
2928: LD_EXP 18
2932: PPUSH
2933: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2937: LD_INT 35
2939: PPUSH
2940: CALL_OW 67
// until See ( 1 , Houten ) ;
2944: LD_INT 1
2946: PPUSH
2947: LD_EXP 22
2951: PPUSH
2952: CALL_OW 292
2956: IFFALSE 2937
// ComTurnUnit ( JMM , Houten ) ;
2958: LD_EXP 18
2962: PPUSH
2963: LD_EXP 22
2967: PPUSH
2968: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2972: LD_EXP 18
2976: PPUSH
2977: LD_STRING D1d-JMM-1
2979: PPUSH
2980: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2984: LD_EXP 22
2988: PPUSH
2989: LD_STRING D1-VanH-1
2991: PPUSH
2992: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2996: LD_EXP 18
3000: PPUSH
3001: LD_STRING D1-JMM-1v
3003: PPUSH
3004: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3008: LD_EXP 18
3012: PPUSH
3013: LD_STRING D1-JMM-2v
3015: PPUSH
3016: CALL_OW 88
// end ; InGameOff ;
3020: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3024: LD_STRING M1
3026: PPUSH
3027: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3031: LD_INT 22
3033: PUSH
3034: LD_INT 4
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: PUSH
3041: LD_INT 92
3043: PUSH
3044: LD_EXP 18
3048: PPUSH
3049: CALL_OW 250
3053: PUSH
3054: LD_EXP 18
3058: PPUSH
3059: CALL_OW 251
3063: PUSH
3064: LD_INT 15
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PPUSH
3077: CALL_OW 69
3081: PPUSH
3082: LD_INT 1
3084: PPUSH
3085: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3089: LD_EXP 23
3093: PUSH
3094: LD_EXP 18
3098: ADD
3099: PUSH
3100: LD_EXP 22
3104: ADD
3105: PPUSH
3106: CALL_OW 141
// end ;
3110: LD_VAR 0 1
3114: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3115: LD_INT 1
3117: PPUSH
3118: LD_EXP 19
3122: PPUSH
3123: CALL_OW 292
3127: PUSH
3128: LD_EXP 18
3132: PPUSH
3133: LD_EXP 19
3137: PPUSH
3138: CALL_OW 296
3142: PUSH
3143: LD_INT 6
3145: LESS
3146: AND
3147: IFFALSE 3910
3149: GO 3151
3151: DISABLE
3152: LD_INT 0
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
// begin InGameOn ;
3159: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3163: LD_INT 22
3165: PUSH
3166: LD_INT 4
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PPUSH
3173: CALL_OW 69
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3185: LD_ADDR_VAR 0 4
3189: PUSH
3190: LD_INT 22
3192: PUSH
3193: LD_INT 1
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 2
3202: PUSH
3203: LD_INT 25
3205: PUSH
3206: LD_INT 1
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 2
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PUSH
3223: LD_INT 25
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: PUSH
3233: LD_INT 25
3235: PUSH
3236: LD_INT 4
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: PPUSH
3254: CALL_OW 69
3258: ST_TO_ADDR
// ComHold ( tmp ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3268: LD_EXP 18
3272: PPUSH
3273: LD_STRING D2-JMM-3a
3275: PPUSH
3276: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3280: LD_EXP 19
3284: PPUSH
3285: LD_EXP 18
3289: PPUSH
3290: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_STRING D2-Gary-3
3301: PPUSH
3302: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3306: LD_EXP 18
3310: PPUSH
3311: LD_EXP 19
3315: PPUSH
3316: CALL_OW 119
// for i in tmp do
3320: LD_ADDR_VAR 0 5
3324: PUSH
3325: LD_VAR 0 4
3329: PUSH
3330: FOR_IN
3331: IFFALSE 3376
// begin if IsInUnit ( i ) then
3333: LD_VAR 0 5
3337: PPUSH
3338: CALL_OW 310
3342: IFFALSE 3353
// ComExitBuilding ( i ) ;
3344: LD_VAR 0 5
3348: PPUSH
3349: CALL_OW 122
// wait ( 1 ) ;
3353: LD_INT 1
3355: PPUSH
3356: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3360: LD_VAR 0 5
3364: PPUSH
3365: LD_EXP 18
3369: PPUSH
3370: CALL_OW 119
// end ;
3374: GO 3330
3376: POP
3377: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3378: LD_ADDR_VAR 0 4
3382: PUSH
3383: LD_VAR 0 4
3387: PUSH
3388: LD_EXP 18
3392: PUSH
3393: LD_EXP 22
3397: PUSH
3398: LD_EXP 19
3402: PUSH
3403: LD_EXP 21
3407: PUSH
3408: LD_EXP 20
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_EXP 23
3424: ADD
3425: DIFF
3426: ST_TO_ADDR
// if Bobby then
3427: LD_EXP 20
3431: IFFALSE 3445
// Say ( Bobby , D2-Bobby-3 ) ;
3433: LD_EXP 20
3437: PPUSH
3438: LD_STRING D2-Bobby-3
3440: PPUSH
3441: CALL_OW 88
// if Cyrus then
3445: LD_EXP 21
3449: IFFALSE 3463
// Say ( Cyrus , D2-Cyrus-3 ) ;
3451: LD_EXP 21
3455: PPUSH
3456: LD_STRING D2-Cyrus-3
3458: PPUSH
3459: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3463: LD_EXP 18
3467: PPUSH
3468: LD_STRING D2-JMM-4
3470: PPUSH
3471: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3475: LD_EXP 19
3479: PPUSH
3480: LD_STRING D2-Gary-4
3482: PPUSH
3483: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: LD_VAR 0 4
3496: PPUSH
3497: LD_INT 26
3499: PUSH
3500: LD_INT 1
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 72
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: ST_TO_ADDR
// if Cyrus then
3516: LD_EXP 21
3520: IFFALSE 3536
// Say ( Cyrus , D2-Cyrus-4 ) else
3522: LD_EXP 21
3526: PPUSH
3527: LD_STRING D2-Cyrus-4
3529: PPUSH
3530: CALL_OW 88
3534: GO 3548
// Say ( un1 , D2-Sol1-4 ) ;
3536: LD_VAR 0 1
3540: PPUSH
3541: LD_STRING D2-Sol1-4
3543: PPUSH
3544: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3548: LD_EXP 18
3552: PPUSH
3553: LD_STRING D2-JMM-5
3555: PPUSH
3556: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_EXP 23
3569: PPUSH
3570: LD_INT 91
3572: PUSH
3573: LD_EXP 18
3577: PUSH
3578: LD_INT 10
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 26
3588: PUSH
3589: LD_INT 2
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 72
3604: ST_TO_ADDR
// if un2 then
3605: LD_VAR 0 2
3609: IFFALSE 3663
// begin un2 := un2 [ un2 ] ;
3611: LD_ADDR_VAR 0 2
3615: PUSH
3616: LD_VAR 0 2
3620: PUSH
3621: LD_VAR 0 2
3625: ARRAY
3626: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_STRING D2-FEng1-5
3634: PPUSH
3635: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3639: LD_EXP 18
3643: PPUSH
3644: LD_STRING D2-JMM-6
3646: PPUSH
3647: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3651: LD_VAR 0 2
3655: PPUSH
3656: LD_STRING D2-FEng1-6
3658: PPUSH
3659: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_EXP 23
3672: PPUSH
3673: LD_INT 91
3675: PUSH
3676: LD_EXP 18
3680: PUSH
3681: LD_INT 10
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 26
3691: PUSH
3692: LD_INT 1
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PPUSH
3703: CALL_OW 72
3707: ST_TO_ADDR
// if un3 then
3708: LD_VAR 0 3
3712: IFFALSE 3767
// begin un3 := un3 [ 1 ] ;
3714: LD_ADDR_VAR 0 3
3718: PUSH
3719: LD_VAR 0 3
3723: PUSH
3724: LD_INT 1
3726: ARRAY
3727: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3728: LD_VAR 0 3
3732: PPUSH
3733: LD_INT 114
3735: PPUSH
3736: LD_INT 122
3738: PPUSH
3739: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3743: LD_VAR 0 3
3747: PPUSH
3748: LD_STRING D2-Eng1-6
3750: PPUSH
3751: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3755: LD_EXP 18
3759: PPUSH
3760: LD_STRING D2-JMM-7
3762: PPUSH
3763: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3767: LD_EXP 19
3771: PPUSH
3772: LD_STRING D2-Gary-7
3774: PPUSH
3775: CALL_OW 88
// if un2 then
3779: LD_VAR 0 2
3783: IFFALSE 3797
// Say ( un2 , D2-FEng1-7 ) ;
3785: LD_VAR 0 2
3789: PPUSH
3790: LD_STRING D2-FEng1-7
3792: PPUSH
3793: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3797: LD_VAR 0 1
3801: PPUSH
3802: LD_STRING D2-Sol1-7
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3809: LD_EXP 18
3813: PPUSH
3814: LD_STRING D2-JMM-8
3816: PPUSH
3817: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3821: LD_INT 22
3823: PUSH
3824: LD_INT 1
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: PPUSH
3831: CALL_OW 69
3835: PPUSH
3836: CALL_OW 141
// InGameOff ;
3840: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3844: LD_STRING M1a
3846: PPUSH
3847: CALL_OW 337
// jmm_in_ovsyenko := true ;
3851: LD_ADDR_EXP 4
3855: PUSH
3856: LD_INT 1
3858: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3859: LD_INT 1050
3861: PPUSH
3862: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3866: LD_ADDR_VAR 0 4
3870: PUSH
3871: LD_INT 25
3873: PUSH
3874: LD_INT 14
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: PPUSH
3881: CALL_OW 69
3885: ST_TO_ADDR
// if not tmp then
3886: LD_VAR 0 4
3890: NOT
3891: IFFALSE 3895
// exit ;
3893: GO 3910
// ComMoveXY ( tmp , 75 , 75 ) ;
3895: LD_VAR 0 4
3899: PPUSH
3900: LD_INT 75
3902: PPUSH
3903: LD_INT 75
3905: PPUSH
3906: CALL_OW 111
// end ;
3910: PPOPN 5
3912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3913: LD_INT 22
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: LD_INT 30
3925: PUSH
3926: LD_INT 30
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: PUSH
3933: LD_INT 3
3935: PUSH
3936: LD_INT 57
3938: PUSH
3939: EMPTY
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: LIST
3950: PPUSH
3951: CALL_OW 69
3955: IFFALSE 3997
3957: GO 3959
3959: DISABLE
3960: LD_INT 0
3962: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3963: LD_ADDR_VAR 0 1
3967: PUSH
3968: LD_STRING M2easy
3970: PUSH
3971: LD_STRING M2
3973: PUSH
3974: LD_STRING M2hard
3976: PUSH
3977: EMPTY
3978: LIST
3979: LIST
3980: LIST
3981: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3982: LD_VAR 0 1
3986: PUSH
3987: LD_OWVAR 67
3991: ARRAY
3992: PPUSH
3993: CALL_OW 337
// end ;
3997: PPOPN 1
3999: END
// every 3 3$00 do
4000: GO 4002
4002: DISABLE
// begin DialogueOn ;
4003: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4007: LD_EXP 25
4011: PPUSH
4012: LD_STRING D3-Pow-1
4014: PPUSH
4015: CALL_OW 94
// if jmm_in_ovsyenko then
4019: LD_EXP 4
4023: IFFALSE 4051
// begin Say ( JMM , D3-JMM-1 ) ;
4025: LD_EXP 18
4029: PPUSH
4030: LD_STRING D3-JMM-1
4032: PPUSH
4033: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4037: LD_EXP 18
4041: PPUSH
4042: LD_STRING D3-JMM-1b
4044: PPUSH
4045: CALL_OW 88
// end else
4049: GO 4063
// Say ( JMM , D3-JMM-1a ) ;
4051: LD_EXP 18
4055: PPUSH
4056: LD_STRING D3-JMM-1a
4058: PPUSH
4059: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4063: LD_EXP 25
4067: PPUSH
4068: LD_STRING D3-Pow-2
4070: PPUSH
4071: CALL_OW 94
// DialogueOff ;
4075: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4079: LD_STRING M3
4081: PPUSH
4082: CALL_OW 337
// powell_want_sib := true ;
4086: LD_ADDR_EXP 5
4090: PUSH
4091: LD_INT 1
4093: ST_TO_ADDR
// end ;
4094: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4095: LD_EXP 6
4099: PUSH
4100: LD_INT 0
4102: EQUAL
4103: IFFALSE 5494
4105: GO 4107
4107: DISABLE
4108: LD_INT 0
4110: PPUSH
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
4115: PPUSH
4116: PPUSH
4117: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4118: LD_INT 4
4120: PPUSH
4121: LD_INT 1
4123: PPUSH
4124: CALL_OW 343
// PowellTransport ;
4128: CALL 2456 0 0
// for i = 1 to 3 do
4132: LD_ADDR_VAR 0 4
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 3
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4213
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4148: LD_ADDR_VAR 0 1
4152: PUSH
4153: LD_INT 6
4155: PPUSH
4156: LD_VAR 0 4
4160: PPUSH
4161: CALL_OW 287
4165: ST_TO_ADDR
// if not tmp then
4166: LD_VAR 0 1
4170: NOT
4171: IFFALSE 4175
// continue ;
4173: GO 4145
// EraseResourceArea ( terminalArea , i ) ;
4175: LD_INT 6
4177: PPUSH
4178: LD_VAR 0 4
4182: PPUSH
4183: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4187: LD_EXP 3
4191: PPUSH
4192: CALL_OW 274
4196: PPUSH
4197: LD_VAR 0 4
4201: PPUSH
4202: LD_VAR 0 1
4206: PPUSH
4207: CALL_OW 276
// end ;
4211: GO 4145
4213: POP
4214: POP
// x := 43 ;
4215: LD_ADDR_VAR 0 2
4219: PUSH
4220: LD_INT 43
4222: ST_TO_ADDR
// y := 3 ;
4223: LD_ADDR_VAR 0 3
4227: PUSH
4228: LD_INT 3
4230: ST_TO_ADDR
// for i = 3 to 4 do
4231: LD_ADDR_VAR 0 4
4235: PUSH
4236: DOUBLE
4237: LD_INT 3
4239: DEC
4240: ST_TO_ADDR
4241: LD_INT 4
4243: PUSH
4244: FOR_TO
4245: IFFALSE 4436
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4247: LD_EXP 24
4251: PUSH
4252: LD_VAR 0 4
4256: ARRAY
4257: PPUSH
4258: LD_INT 4
4260: PPUSH
4261: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4265: LD_EXP 24
4269: PUSH
4270: LD_VAR 0 4
4274: ARRAY
4275: PPUSH
4276: LD_VAR 0 2
4280: PPUSH
4281: LD_VAR 0 3
4285: PPUSH
4286: LD_INT 0
4288: PPUSH
4289: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4293: LD_EXP 24
4297: PUSH
4298: LD_VAR 0 4
4302: PUSH
4303: LD_INT 2
4305: MINUS
4306: ARRAY
4307: PPUSH
4308: LD_EXP 24
4312: PUSH
4313: LD_VAR 0 4
4317: ARRAY
4318: PPUSH
4319: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4323: LD_EXP 24
4327: PUSH
4328: LD_VAR 0 4
4332: ARRAY
4333: PPUSH
4334: LD_INT 1
4336: PPUSH
4337: LD_INT 100
4339: PPUSH
4340: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4344: LD_EXP 24
4348: PUSH
4349: LD_VAR 0 4
4353: PUSH
4354: LD_INT 2
4356: MINUS
4357: ARRAY
4358: PPUSH
4359: LD_INT 54
4361: PPUSH
4362: LD_INT 42
4364: PPUSH
4365: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4369: LD_EXP 24
4373: PUSH
4374: LD_VAR 0 4
4378: PUSH
4379: LD_INT 2
4381: MINUS
4382: ARRAY
4383: PPUSH
4384: LD_EXP 3
4388: PPUSH
4389: CALL_OW 250
4393: PPUSH
4394: LD_EXP 3
4398: PPUSH
4399: CALL_OW 251
4403: PPUSH
4404: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4408: LD_EXP 24
4412: PUSH
4413: LD_VAR 0 4
4417: PUSH
4418: LD_INT 2
4420: MINUS
4421: ARRAY
4422: PPUSH
4423: CALL_OW 200
// Wait ( 0 0$02 ) ;
4427: LD_INT 70
4429: PPUSH
4430: CALL_OW 67
// end ;
4434: GO 4244
4436: POP
4437: POP
// time := 0 0$20 ;
4438: LD_ADDR_VAR 0 8
4442: PUSH
4443: LD_INT 700
4445: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4446: LD_INT 35
4448: PPUSH
4449: CALL_OW 67
// time := time - 0 0$01 ;
4453: LD_ADDR_VAR 0 8
4457: PUSH
4458: LD_VAR 0 8
4462: PUSH
4463: LD_INT 35
4465: MINUS
4466: ST_TO_ADDR
// for i = 3 to 4 do
4467: LD_ADDR_VAR 0 4
4471: PUSH
4472: DOUBLE
4473: LD_INT 3
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 4
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4616
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4483: LD_EXP 24
4487: PUSH
4488: LD_VAR 0 4
4492: ARRAY
4493: PPUSH
4494: LD_INT 1
4496: PPUSH
4497: CALL_OW 289
4501: PUSH
4502: LD_INT 0
4504: GREATER
4505: PUSH
4506: LD_EXP 24
4510: PUSH
4511: LD_VAR 0 4
4515: ARRAY
4516: PPUSH
4517: CALL_OW 314
4521: NOT
4522: AND
4523: IFFALSE 4614
// begin x := rand ( 0 , 5 ) ;
4525: LD_ADDR_VAR 0 2
4529: PUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_INT 5
4535: PPUSH
4536: CALL_OW 12
4540: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4541: LD_EXP 24
4545: PUSH
4546: LD_VAR 0 4
4550: ARRAY
4551: PPUSH
4552: LD_EXP 24
4556: PUSH
4557: LD_VAR 0 4
4561: ARRAY
4562: PPUSH
4563: CALL_OW 250
4567: PPUSH
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL_OW 272
4580: PPUSH
4581: LD_EXP 24
4585: PUSH
4586: LD_VAR 0 4
4590: ARRAY
4591: PPUSH
4592: CALL_OW 251
4596: PPUSH
4597: LD_VAR 0 2
4601: PPUSH
4602: LD_INT 3
4604: PPUSH
4605: CALL_OW 273
4609: PPUSH
4610: CALL_OW 171
// end ;
4614: GO 4480
4616: POP
4617: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4618: LD_EXP 24
4622: PUSH
4623: LD_INT 1
4625: ARRAY
4626: PPUSH
4627: LD_INT 54
4629: PPUSH
4630: LD_INT 42
4632: PPUSH
4633: CALL_OW 297
4637: PUSH
4638: LD_INT 4
4640: LESS
4641: PUSH
4642: LD_VAR 0 8
4646: PUSH
4647: LD_INT 0
4649: EQUAL
4650: OR
4651: IFFALSE 4446
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4653: LD_EXP 24
4657: PUSH
4658: LD_INT 3
4660: ARRAY
4661: PPUSH
4662: LD_INT 1
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4672: LD_EXP 24
4676: PUSH
4677: LD_INT 4
4679: ARRAY
4680: PPUSH
4681: LD_INT 1
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4691: LD_EXP 3
4695: PPUSH
4696: CALL_OW 274
4700: PPUSH
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 200
4706: PPUSH
4707: CALL_OW 276
// DialogueOn ;
4711: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4715: LD_INT 53
4717: PPUSH
4718: LD_INT 35
4720: PPUSH
4721: CALL_OW 86
// un := powell_trans [ 1 ] ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_EXP 24
4734: PUSH
4735: LD_INT 1
4737: ARRAY
4738: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_STRING D4-Mech1-1
4746: PPUSH
4747: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4751: LD_EXP 18
4755: PPUSH
4756: LD_STRING D4-JMM-1
4758: PPUSH
4759: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4763: LD_VAR 0 5
4767: PPUSH
4768: LD_STRING D4-Mech1-2
4770: PPUSH
4771: CALL_OW 88
// powell_happy := false ;
4775: LD_ADDR_VAR 0 6
4779: PUSH
4780: LD_INT 0
4782: ST_TO_ADDR
// take_cargo := false ;
4783: LD_ADDR_VAR 0 7
4787: PUSH
4788: LD_INT 0
4790: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4791: CALL 784 0 0
4795: PUSH
4796: LD_INT 60
4798: GREATEREQUAL
4799: IFFALSE 4847
// begin Say ( JMM , D5-JMM-1 ) ;
4801: LD_EXP 18
4805: PPUSH
4806: LD_STRING D5-JMM-1
4808: PPUSH
4809: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4813: LD_VAR 0 5
4817: PPUSH
4818: LD_STRING D6-Mech1-1
4820: PPUSH
4821: CALL_OW 88
// powell_happy := true ;
4825: LD_ADDR_VAR 0 6
4829: PUSH
4830: LD_INT 1
4832: ST_TO_ADDR
// take_cargo := true ;
4833: LD_ADDR_VAR 0 7
4837: PUSH
4838: LD_INT 1
4840: ST_TO_ADDR
// DialogueOff ;
4841: CALL_OW 7
// end else
4845: GO 5081
// if GetTerminalCargo > 0 then
4847: CALL 784 0 0
4851: PUSH
4852: LD_INT 0
4854: GREATER
4855: IFFALSE 5053
// begin case Query ( QWait ) of 1 :
4857: LD_STRING QWait
4859: PPUSH
4860: CALL_OW 97
4864: PUSH
4865: LD_INT 1
4867: DOUBLE
4868: EQUAL
4869: IFTRUE 4873
4871: GO 4964
4873: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4874: LD_EXP 18
4878: PPUSH
4879: LD_STRING D5b-JMM-1
4881: PPUSH
4882: CALL_OW 88
// DialogueOff ;
4886: CALL_OW 7
// wait ( 5 5$00 ) ;
4890: LD_INT 10500
4892: PPUSH
4893: CALL_OW 67
// if GetTerminalCargo < 60 then
4897: CALL 784 0 0
4901: PUSH
4902: LD_INT 60
4904: LESS
4905: IFFALSE 4946
// begin DialogueOn ;
4907: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4911: LD_EXP 3
4915: PPUSH
4916: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4920: LD_VAR 0 5
4924: PPUSH
4925: LD_STRING D6-Mech1-1a
4927: PPUSH
4928: CALL_OW 88
// DialogueOff ;
4932: CALL_OW 7
// powell_happy := false ;
4936: LD_ADDR_VAR 0 6
4940: PUSH
4941: LD_INT 0
4943: ST_TO_ADDR
// end else
4944: GO 4962
// begin powell_happy := true ;
4946: LD_ADDR_VAR 0 6
4950: PUSH
4951: LD_INT 1
4953: ST_TO_ADDR
// take_cargo := true ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: LD_INT 1
4961: ST_TO_ADDR
// end ; end ; 2 :
4962: GO 5051
4964: LD_INT 2
4966: DOUBLE
4967: EQUAL
4968: IFTRUE 4972
4970: GO 5011
4972: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4973: LD_EXP 18
4977: PPUSH
4978: LD_STRING D5b-JMM-1
4980: PPUSH
4981: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: LD_STRING D6-Mech1-1a
4992: PPUSH
4993: CALL_OW 88
// DialogueOff ;
4997: CALL_OW 7
// take_cargo := true ;
5001: LD_ADDR_VAR 0 7
5005: PUSH
5006: LD_INT 1
5008: ST_TO_ADDR
// end ; 3 :
5009: GO 5051
5011: LD_INT 3
5013: DOUBLE
5014: EQUAL
5015: IFTRUE 5019
5017: GO 5050
5019: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5020: LD_EXP 18
5024: PPUSH
5025: LD_STRING D5c-JMM-1
5027: PPUSH
5028: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5032: LD_VAR 0 5
5036: PPUSH
5037: LD_STRING D6-Mech1-1b
5039: PPUSH
5040: CALL_OW 88
// DialogueOff ;
5044: CALL_OW 7
// end ; end ;
5048: GO 5051
5050: POP
// end else
5051: GO 5081
// begin Say ( JMM , D5c-JMM-1 ) ;
5053: LD_EXP 18
5057: PPUSH
5058: LD_STRING D5c-JMM-1
5060: PPUSH
5061: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5065: LD_VAR 0 5
5069: PPUSH
5070: LD_STRING D6-Mech1-1b
5072: PPUSH
5073: CALL_OW 88
// DialogueOff ;
5077: CALL_OW 7
// end ; if take_cargo then
5081: LD_VAR 0 7
5085: IFFALSE 5164
// begin x := GetTerminalCargo ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: CALL 784 0 0
5096: ST_TO_ADDR
// if x > 60 then
5097: LD_VAR 0 2
5101: PUSH
5102: LD_INT 60
5104: GREATER
5105: IFFALSE 5115
// x := 60 ;
5107: LD_ADDR_VAR 0 2
5111: PUSH
5112: LD_INT 60
5114: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5115: LD_EXP 3
5119: PPUSH
5120: CALL_OW 274
5124: PPUSH
5125: LD_INT 3
5127: PPUSH
5128: CALL 784 0 0
5132: PUSH
5133: LD_VAR 0 2
5137: MINUS
5138: PPUSH
5139: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5143: LD_EXP 24
5147: PUSH
5148: LD_INT 3
5150: ARRAY
5151: PPUSH
5152: LD_INT 3
5154: PPUSH
5155: LD_VAR 0 2
5159: PPUSH
5160: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5164: LD_EXP 24
5168: PPUSH
5169: LD_INT 43
5171: PPUSH
5172: LD_INT 3
5174: PPUSH
5175: CALL_OW 171
// x := 0 0$20 ;
5179: LD_ADDR_VAR 0 2
5183: PUSH
5184: LD_INT 700
5186: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5187: LD_INT 35
5189: PPUSH
5190: CALL_OW 67
// x := x - 0 0$01 ;
5194: LD_ADDR_VAR 0 2
5198: PUSH
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 35
5206: MINUS
5207: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5208: LD_VAR 0 2
5212: PUSH
5213: LD_INT 0
5215: EQUAL
5216: PUSH
5217: LD_EXP 24
5221: PUSH
5222: LD_INT 3
5224: ARRAY
5225: PPUSH
5226: LD_INT 43
5228: PPUSH
5229: LD_INT 3
5231: PPUSH
5232: CALL_OW 297
5236: PUSH
5237: LD_INT 4
5239: LESS
5240: PUSH
5241: LD_EXP 24
5245: PUSH
5246: LD_INT 3
5248: ARRAY
5249: PPUSH
5250: LD_INT 43
5252: PPUSH
5253: LD_INT 3
5255: PPUSH
5256: CALL_OW 297
5260: PUSH
5261: LD_INT 4
5263: LESS
5264: AND
5265: OR
5266: IFFALSE 5187
// for i in powell_trans do
5268: LD_ADDR_VAR 0 4
5272: PUSH
5273: LD_EXP 24
5277: PUSH
5278: FOR_IN
5279: IFFALSE 5292
// RemoveUnit ( i ) ;
5281: LD_VAR 0 4
5285: PPUSH
5286: CALL_OW 64
5290: GO 5278
5292: POP
5293: POP
// if not powell_happy then
5294: LD_VAR 0 6
5298: NOT
5299: IFFALSE 5310
// powell_happy := - 1 ;
5301: LD_ADDR_VAR 0 6
5305: PUSH
5306: LD_INT 1
5308: NEG
5309: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5310: LD_VAR 0 6
5314: PPUSH
5315: LD_STRING EarlySiberite
5317: PPUSH
5318: CALL_OW 101
// if powell_happy then
5322: LD_VAR 0 6
5326: IFFALSE 5337
// ChangeMissionObjectives ( M3a ) else
5328: LD_STRING M3a
5330: PPUSH
5331: CALL_OW 337
5335: GO 5344
// ChangeMissionObjectives ( M3b ) ;
5337: LD_STRING M3b
5339: PPUSH
5340: CALL_OW 337
// ru_can_attack_terminal := true ;
5344: LD_ADDR_EXP 9
5348: PUSH
5349: LD_INT 1
5351: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5352: LD_INT 12600
5354: PPUSH
5355: CALL_OW 67
// if ru_force then
5359: LD_EXP 34
5363: IFFALSE 5462
// for i in ru_force do
5365: LD_ADDR_VAR 0 4
5369: PUSH
5370: LD_EXP 34
5374: PUSH
5375: FOR_IN
5376: IFFALSE 5460
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5378: LD_INT 1
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: CALL_OW 292
5390: NOT
5391: PUSH
5392: LD_VAR 0 4
5396: PPUSH
5397: LD_INT 81
5399: PUSH
5400: LD_INT 3
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PPUSH
5407: CALL_OW 69
5411: PPUSH
5412: LD_VAR 0 4
5416: PPUSH
5417: CALL_OW 74
5421: PPUSH
5422: CALL_OW 296
5426: PUSH
5427: LD_INT 10
5429: GREATER
5430: AND
5431: IFFALSE 5458
// begin RemoveUnit ( i ) ;
5433: LD_VAR 0 4
5437: PPUSH
5438: CALL_OW 64
// ru_force := ru_force diff i ;
5442: LD_ADDR_EXP 34
5446: PUSH
5447: LD_EXP 34
5451: PUSH
5452: LD_VAR 0 4
5456: DIFF
5457: ST_TO_ADDR
// end ;
5458: GO 5375
5460: POP
5461: POP
// repeat wait ( 0 0$03 ) ;
5462: LD_INT 105
5464: PPUSH
5465: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5469: LD_EXP 8
5473: NOT
5474: PUSH
5475: LD_EXP 34
5479: PUSH
5480: LD_INT 3
5482: LESS
5483: OR
5484: IFFALSE 5462
// ar_can_arrive := true ;
5486: LD_ADDR_EXP 10
5490: PUSH
5491: LD_INT 1
5493: ST_TO_ADDR
// end ;
5494: PPOPN 8
5496: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5497: LD_INT 1
5499: PPUSH
5500: LD_INT 20
5502: PPUSH
5503: CALL_OW 325
5507: IFFALSE 5648
5509: GO 5511
5511: DISABLE
5512: LD_INT 0
5514: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5515: LD_ADDR_VAR 0 1
5519: PUSH
5520: LD_INT 22
5522: PUSH
5523: LD_INT 1
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: PUSH
5530: LD_INT 26
5532: PUSH
5533: LD_INT 1
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: PUSH
5540: LD_INT 25
5542: PUSH
5543: LD_INT 4
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: LIST
5554: PPUSH
5555: CALL_OW 69
5559: PUSH
5560: LD_EXP 18
5564: PUSH
5565: LD_EXP 21
5569: PUSH
5570: LD_EXP 20
5574: PUSH
5575: LD_EXP 22
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: DIFF
5586: ST_TO_ADDR
// if not un then
5587: LD_VAR 0 1
5591: NOT
5592: IFFALSE 5596
// exit ;
5594: GO 5648
// DialogueOn ;
5596: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5600: LD_VAR 0 1
5604: PUSH
5605: LD_INT 1
5607: ARRAY
5608: PPUSH
5609: LD_STRING D13-Sci1-1
5611: PPUSH
5612: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5616: LD_EXP 18
5620: PPUSH
5621: LD_STRING D13-JMM-1
5623: PPUSH
5624: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5628: LD_VAR 0 1
5632: PUSH
5633: LD_INT 1
5635: ARRAY
5636: PPUSH
5637: LD_STRING D13-Sci1-2
5639: PPUSH
5640: CALL_OW 88
// DialogueOff ;
5644: CALL_OW 7
// end ;
5648: PPOPN 1
5650: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5651: LD_INT 1
5653: PPUSH
5654: CALL 815 0 1
5658: PUSH
5659: LD_INT 77
5661: GREATER
5662: PUSH
5663: LD_EXP 8
5667: NOT
5668: AND
5669: PUSH
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PUSH
5680: LD_INT 25
5682: PUSH
5683: LD_INT 4
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: PPUSH
5705: CALL_OW 69
5709: PUSH
5710: LD_EXP 18
5714: PUSH
5715: LD_EXP 20
5719: PUSH
5720: LD_EXP 21
5724: PUSH
5725: LD_EXP 19
5729: PUSH
5730: LD_EXP 22
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: DIFF
5742: AND
5743: IFFALSE 5921
5745: GO 5747
5747: DISABLE
5748: LD_INT 0
5750: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5751: LD_ADDR_VAR 0 1
5755: PUSH
5756: LD_INT 22
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: PUSH
5766: LD_INT 25
5768: PUSH
5769: LD_INT 4
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: PUSH
5776: LD_INT 26
5778: PUSH
5779: LD_INT 1
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 69
5795: PUSH
5796: LD_EXP 18
5800: PUSH
5801: LD_EXP 20
5805: PUSH
5806: LD_EXP 21
5810: PUSH
5811: LD_EXP 19
5815: PUSH
5816: LD_EXP 22
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: LIST
5827: DIFF
5828: ST_TO_ADDR
// DialogueOn ;
5829: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5833: LD_VAR 0 1
5837: PUSH
5838: LD_INT 1
5840: ARRAY
5841: PPUSH
5842: LD_STRING D7-Sci1-1
5844: PPUSH
5845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5849: LD_EXP 18
5853: PPUSH
5854: LD_STRING D7-JMM-1
5856: PPUSH
5857: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5861: LD_VAR 0 1
5865: PUSH
5866: LD_INT 1
5868: ARRAY
5869: PPUSH
5870: LD_STRING D7-Sci1-2
5872: PPUSH
5873: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5877: LD_EXP 18
5881: PPUSH
5882: LD_STRING D7-JMM-2
5884: PPUSH
5885: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5889: LD_VAR 0 1
5893: PUSH
5894: LD_INT 1
5896: ARRAY
5897: PPUSH
5898: LD_STRING D7-Sci1-3
5900: PPUSH
5901: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5905: LD_EXP 18
5909: PPUSH
5910: LD_STRING D7-JMM-3
5912: PPUSH
5913: CALL_OW 88
// DialogueOff ;
5917: CALL_OW 7
// end ;
5921: PPOPN 1
5923: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5924: LD_EXP 10
5928: IFFALSE 9288
5930: GO 5932
5932: DISABLE
5933: LD_INT 0
5935: PPUSH
5936: PPUSH
5937: PPUSH
5938: PPUSH
5939: PPUSH
5940: PPUSH
5941: PPUSH
5942: PPUSH
// begin PrepareArabian ;
5943: CALL 11709 0 0
// repeat wait ( 0 0$01 ) ;
5947: LD_INT 35
5949: PPUSH
5950: CALL_OW 67
// until ar_spawned ;
5954: LD_EXP 11
5958: IFFALSE 5947
// DialogueOn ;
5960: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5964: LD_EXP 26
5968: PPUSH
5969: LD_STRING D8-Ar1-1
5971: PPUSH
5972: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5976: LD_EXP 18
5980: PPUSH
5981: LD_STRING D8-JMM-1
5983: PPUSH
5984: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5988: LD_EXP 26
5992: PPUSH
5993: LD_STRING D8-Ar1-2
5995: PPUSH
5996: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6000: LD_EXP 18
6004: PPUSH
6005: LD_STRING D8-JMM-2
6007: PPUSH
6008: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6012: LD_EXP 26
6016: PPUSH
6017: LD_STRING D8-Ar1-3
6019: PPUSH
6020: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6024: LD_EXP 18
6028: PPUSH
6029: LD_STRING D8-JMM-3
6031: PPUSH
6032: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6036: LD_EXP 26
6040: PPUSH
6041: LD_STRING D8-Ar1-4
6043: PPUSH
6044: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6048: LD_EXP 18
6052: PPUSH
6053: LD_STRING D8-JMM-4
6055: PPUSH
6056: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6060: LD_EXP 26
6064: PPUSH
6065: LD_STRING D8-Ar1-5
6067: PPUSH
6068: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6072: LD_EXP 18
6076: PPUSH
6077: LD_STRING D8-JMM-5
6079: PPUSH
6080: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6084: LD_EXP 26
6088: PPUSH
6089: LD_STRING D8-Ar1-6
6091: PPUSH
6092: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6096: LD_EXP 27
6100: PPUSH
6101: LD_STRING D8-Ar2-6
6103: PPUSH
6104: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6108: LD_EXP 18
6112: PPUSH
6113: LD_STRING D8-JMM-6
6115: PPUSH
6116: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6120: LD_EXP 27
6124: PPUSH
6125: LD_STRING D8-Ar2-7
6127: PPUSH
6128: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6132: LD_STRING QBarracks
6134: PPUSH
6135: CALL_OW 97
6139: PUSH
6140: LD_INT 1
6142: DOUBLE
6143: EQUAL
6144: IFTRUE 6148
6146: GO 6183
6148: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6149: LD_EXP 18
6153: PPUSH
6154: LD_STRING D8a-JMM-1
6156: PPUSH
6157: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6161: LD_EXP 26
6165: PPUSH
6166: LD_STRING D8a-Ar1-1
6168: PPUSH
6169: CALL_OW 94
// player_want_mortar := true ;
6173: LD_ADDR_EXP 12
6177: PUSH
6178: LD_INT 1
6180: ST_TO_ADDR
// end ; 2 :
6181: GO 6341
6183: LD_INT 2
6185: DOUBLE
6186: EQUAL
6187: IFTRUE 6191
6189: GO 6305
6191: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6192: LD_EXP 18
6196: PPUSH
6197: LD_STRING D8b-JMM-1
6199: PPUSH
6200: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6204: LD_EXP 26
6208: PPUSH
6209: LD_STRING D8b-Ar1-1
6211: PPUSH
6212: CALL_OW 94
// case Query ( QInfo ) of 1 :
6216: LD_STRING QInfo
6218: PPUSH
6219: CALL_OW 97
6223: PUSH
6224: LD_INT 1
6226: DOUBLE
6227: EQUAL
6228: IFTRUE 6232
6230: GO 6267
6232: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6233: LD_EXP 18
6237: PPUSH
6238: LD_STRING D8b1-JMM-1
6240: PPUSH
6241: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6245: LD_EXP 26
6249: PPUSH
6250: LD_STRING D8b1-Ar1-1
6252: PPUSH
6253: CALL_OW 94
// player_want_info := 2 ;
6257: LD_ADDR_EXP 13
6261: PUSH
6262: LD_INT 2
6264: ST_TO_ADDR
// end ; 2 :
6265: GO 6303
6267: LD_INT 2
6269: DOUBLE
6270: EQUAL
6271: IFTRUE 6275
6273: GO 6302
6275: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6276: LD_EXP 18
6280: PPUSH
6281: LD_STRING D8b2-JMM-1
6283: PPUSH
6284: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6288: LD_EXP 26
6292: PPUSH
6293: LD_STRING D8b2-Ar1-1
6295: PPUSH
6296: CALL_OW 94
// end ; end ;
6300: GO 6303
6302: POP
// end ; 3 :
6303: GO 6341
6305: LD_INT 3
6307: DOUBLE
6308: EQUAL
6309: IFTRUE 6313
6311: GO 6340
6313: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6314: LD_EXP 18
6318: PPUSH
6319: LD_STRING D8c-JMM-1
6321: PPUSH
6322: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6326: LD_EXP 26
6330: PPUSH
6331: LD_STRING D8c-Ar1-1
6333: PPUSH
6334: CALL_OW 94
// end ; end ;
6338: GO 6341
6340: POP
// DialogueOff ;
6341: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6345: LD_ADDR_VAR 0 4
6349: PUSH
6350: LD_INT 9
6352: PPUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 30
6358: PUSH
6359: LD_INT 0
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: LD_INT 30
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: PPUSH
6381: CALL_OW 70
6385: ST_TO_ADDR
// if dep then
6386: LD_VAR 0 4
6390: IFFALSE 6408
// dep := dep [ 1 ] else
6392: LD_ADDR_VAR 0 4
6396: PUSH
6397: LD_VAR 0 4
6401: PUSH
6402: LD_INT 1
6404: ARRAY
6405: ST_TO_ADDR
6406: GO 6470
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6408: LD_ADDR_VAR 0 4
6412: PUSH
6413: LD_INT 22
6415: PUSH
6416: LD_INT 1
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 2
6425: PUSH
6426: LD_INT 30
6428: PUSH
6429: LD_INT 0
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: PUSH
6436: LD_INT 30
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: LIST
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL_OW 69
6459: PPUSH
6460: LD_EXP 27
6464: PPUSH
6465: CALL_OW 74
6469: ST_TO_ADDR
// if not dep then
6470: LD_VAR 0 4
6474: NOT
6475: IFFALSE 6513
// begin case Query ( QInfoNothing ) of 1 :
6477: LD_STRING QInfoNothing
6479: PPUSH
6480: CALL_OW 97
6484: PUSH
6485: LD_INT 1
6487: DOUBLE
6488: EQUAL
6489: IFTRUE 6493
6491: GO 6496
6493: POP
// ; end ;
6494: GO 6497
6496: POP
// player_want_info := false ;
6497: LD_ADDR_EXP 13
6501: PUSH
6502: LD_INT 0
6504: ST_TO_ADDR
// player_want_mortar := false ;
6505: LD_ADDR_EXP 12
6509: PUSH
6510: LD_INT 0
6512: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6513: LD_ADDR_VAR 0 3
6517: PUSH
6518: LD_INT 22
6520: PUSH
6521: LD_INT 2
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: PUSH
6528: LD_INT 21
6530: PUSH
6531: LD_INT 2
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: PPUSH
6542: CALL_OW 69
6546: ST_TO_ADDR
// time := 1 1$35 ;
6547: LD_ADDR_VAR 0 5
6551: PUSH
6552: LD_INT 3325
6554: ST_TO_ADDR
// no_oil_gain := false ;
6555: LD_ADDR_VAR 0 6
6559: PUSH
6560: LD_INT 0
6562: ST_TO_ADDR
// first_warn := false ;
6563: LD_ADDR_VAR 0 7
6567: PUSH
6568: LD_INT 0
6570: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6571: LD_EXP 12
6575: PUSH
6576: LD_EXP 13
6580: OR
6581: IFFALSE 6686
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6583: LD_EXP 33
6587: PPUSH
6588: LD_INT 25
6590: PUSH
6591: LD_INT 1
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PPUSH
6598: CALL_OW 72
6602: PPUSH
6603: LD_VAR 0 4
6607: PPUSH
6608: CALL_OW 250
6612: PPUSH
6613: LD_VAR 0 4
6617: PPUSH
6618: CALL_OW 251
6622: PPUSH
6623: LD_VAR 0 4
6627: PPUSH
6628: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6632: LD_EXP 33
6636: PPUSH
6637: LD_INT 25
6639: PUSH
6640: LD_INT 1
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PPUSH
6647: CALL_OW 72
6651: PPUSH
6652: LD_INT 86
6654: PPUSH
6655: LD_INT 121
6657: PPUSH
6658: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6662: LD_EXP 33
6666: PPUSH
6667: LD_INT 25
6669: PUSH
6670: LD_INT 1
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PPUSH
6677: CALL_OW 72
6681: PPUSH
6682: CALL_OW 200
// end ; if player_attacked_ar then
6686: LD_EXP 16
6690: IFFALSE 6694
// exit ;
6692: GO 9288
// if player_want_mortar then
6694: LD_EXP 12
6698: IFFALSE 8090
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6700: LD_EXP 27
6704: PPUSH
6705: LD_VAR 0 4
6709: PPUSH
6710: CALL_OW 250
6714: PUSH
6715: LD_INT 1
6717: PLUS
6718: PPUSH
6719: LD_VAR 0 4
6723: PPUSH
6724: CALL_OW 251
6728: PUSH
6729: LD_INT 1
6731: PLUS
6732: PPUSH
6733: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6737: LD_INT 35
6739: PPUSH
6740: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6744: LD_EXP 27
6748: PPUSH
6749: LD_VAR 0 4
6753: PPUSH
6754: CALL_OW 296
6758: PUSH
6759: LD_INT 4
6761: LESS
6762: IFFALSE 6737
// for i = 1 to 6 do
6764: LD_ADDR_VAR 0 1
6768: PUSH
6769: DOUBLE
6770: LD_INT 1
6772: DEC
6773: ST_TO_ADDR
6774: LD_INT 6
6776: PUSH
6777: FOR_TO
6778: IFFALSE 6975
// begin if player_attacked_ar then
6780: LD_EXP 16
6784: IFFALSE 6790
// exit ;
6786: POP
6787: POP
6788: GO 9288
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6790: LD_VAR 0 4
6794: PPUSH
6795: CALL_OW 274
6799: PPUSH
6800: LD_INT 2
6802: PPUSH
6803: CALL_OW 275
6807: PUSH
6808: LD_INT 10
6810: LESS
6811: PUSH
6812: LD_VAR 0 7
6816: NOT
6817: AND
6818: IFFALSE 6881
// begin first_warn := true ;
6820: LD_ADDR_VAR 0 7
6824: PUSH
6825: LD_INT 1
6827: ST_TO_ADDR
// DialogueOn ;
6828: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6832: LD_EXP 28
6836: PPUSH
6837: LD_STRING D9a-FAr1-1
6839: PPUSH
6840: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6844: LD_EXP 18
6848: PPUSH
6849: LD_STRING D9a-JMM-1
6851: PPUSH
6852: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6856: LD_EXP 26
6860: PPUSH
6861: LD_STRING D9a2-Ar1-1
6863: PPUSH
6864: CALL_OW 88
// DialogueOff ;
6868: CALL_OW 7
// wait ( time ) ;
6872: LD_VAR 0 5
6876: PPUSH
6877: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6881: LD_VAR 0 4
6885: PPUSH
6886: CALL_OW 274
6890: PPUSH
6891: LD_INT 2
6893: PPUSH
6894: CALL_OW 275
6898: PUSH
6899: LD_INT 10
6901: LESS
6902: IFFALSE 6928
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6904: LD_EXP 26
6908: PPUSH
6909: LD_STRING D9a3-Ar1-1
6911: PPUSH
6912: CALL_OW 88
// no_oil_gain := true ;
6916: LD_ADDR_VAR 0 6
6920: PUSH
6921: LD_INT 1
6923: ST_TO_ADDR
// break ;
6924: GO 6975
// end else
6926: GO 6973
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6928: LD_EXP 27
6932: PPUSH
6933: LD_VAR 0 4
6937: PPUSH
6938: LD_INT 2
6940: PPUSH
6941: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6945: LD_EXP 27
6949: PPUSH
6950: LD_VAR 0 3
6954: PUSH
6955: LD_VAR 0 1
6959: PUSH
6960: LD_INT 3
6962: MOD
6963: PUSH
6964: LD_INT 1
6966: PLUS
6967: ARRAY
6968: PPUSH
6969: CALL_OW 210
// end ; end ;
6973: GO 6777
6975: POP
6976: POP
// if not no_oil_gain then
6977: LD_VAR 0 6
6981: NOT
6982: IFFALSE 8090
// begin repeat wait ( 0 0$01 ) ;
6984: LD_INT 35
6986: PPUSH
6987: CALL_OW 67
// if player_attacked_ar then
6991: LD_EXP 16
6995: IFFALSE 6999
// exit ;
6997: GO 9288
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6999: LD_VAR 0 3
7003: PUSH
7004: LD_INT 1
7006: ARRAY
7007: PPUSH
7008: CALL_OW 261
7012: PUSH
7013: LD_INT 80
7015: GREATER
7016: PUSH
7017: LD_VAR 0 3
7021: PUSH
7022: LD_INT 2
7024: ARRAY
7025: PPUSH
7026: CALL_OW 261
7030: PUSH
7031: LD_INT 80
7033: GREATER
7034: AND
7035: PUSH
7036: LD_VAR 0 3
7040: PUSH
7041: LD_INT 3
7043: ARRAY
7044: PPUSH
7045: CALL_OW 261
7049: PUSH
7050: LD_INT 80
7052: GREATER
7053: AND
7054: IFFALSE 6984
// ComMoveXY ( Gali , 105 , 127 ) ;
7056: LD_EXP 27
7060: PPUSH
7061: LD_INT 105
7063: PPUSH
7064: LD_INT 127
7066: PPUSH
7067: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7071: LD_EXP 27
7075: PPUSH
7076: LD_INT 2
7078: PPUSH
7079: CALL_OW 173
// AddComHold ( Gali ) ;
7083: LD_EXP 27
7087: PPUSH
7088: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7092: LD_INT 35
7094: PPUSH
7095: CALL_OW 67
// if player_attacked_ar then
7099: LD_EXP 16
7103: IFFALSE 7107
// exit ;
7105: GO 9288
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7107: LD_EXP 27
7111: PPUSH
7112: LD_INT 105
7114: PPUSH
7115: LD_INT 127
7117: PPUSH
7118: CALL_OW 297
7122: PUSH
7123: LD_INT 4
7125: LESS
7126: IFFALSE 7092
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7128: LD_VAR 0 4
7132: PPUSH
7133: CALL_OW 274
7137: PPUSH
7138: LD_INT 1
7140: PPUSH
7141: CALL_OW 275
7145: PUSH
7146: LD_INT 50
7148: LESS
7149: IFFALSE 7445
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7151: LD_VAR 0 4
7155: PPUSH
7156: CALL_OW 274
7160: PPUSH
7161: LD_INT 1
7163: PPUSH
7164: CALL_OW 275
7168: PUSH
7169: LD_INT 0
7171: DOUBLE
7172: GREATEREQUAL
7173: IFFALSE 7181
7175: LD_INT 24
7177: DOUBLE
7178: LESSEQUAL
7179: IFTRUE 7183
7181: GO 7198
7183: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7184: LD_EXP 27
7188: PPUSH
7189: LD_STRING D9b-Ar2-1
7191: PPUSH
7192: CALL_OW 88
7196: GO 7228
7198: LD_INT 25
7200: DOUBLE
7201: GREATEREQUAL
7202: IFFALSE 7210
7204: LD_INT 49
7206: DOUBLE
7207: LESSEQUAL
7208: IFTRUE 7212
7210: GO 7227
7212: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7213: LD_EXP 27
7217: PPUSH
7218: LD_STRING D9b-Ar2-1a
7220: PPUSH
7221: CALL_OW 88
7225: GO 7228
7227: POP
// Say ( JMM , D9b-JMM-1 ) ;
7228: LD_EXP 18
7232: PPUSH
7233: LD_STRING D9b-JMM-1
7235: PPUSH
7236: CALL_OW 88
// x := 0 0$0 ;
7240: LD_ADDR_VAR 0 2
7244: PUSH
7245: LD_INT 0
7247: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7248: LD_INT 35
7250: PPUSH
7251: CALL_OW 67
// x := x + 0 0$1 ;
7255: LD_ADDR_VAR 0 2
7259: PUSH
7260: LD_VAR 0 2
7264: PUSH
7265: LD_INT 35
7267: PLUS
7268: ST_TO_ADDR
// if player_attacked_ar then
7269: LD_EXP 16
7273: IFFALSE 7277
// exit ;
7275: GO 9288
// until x >= time ;
7277: LD_VAR 0 2
7281: PUSH
7282: LD_VAR 0 5
7286: GREATEREQUAL
7287: IFFALSE 7248
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7289: LD_VAR 0 4
7293: PPUSH
7294: CALL_OW 274
7298: PPUSH
7299: LD_INT 1
7301: PPUSH
7302: CALL_OW 275
7306: PUSH
7307: LD_INT 50
7309: LESS
7310: IFFALSE 7443
// begin DialogueOn ;
7312: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7316: LD_EXP 26
7320: PPUSH
7321: LD_STRING D9c-Ar1-1
7323: PPUSH
7324: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7328: LD_EXP 18
7332: PPUSH
7333: LD_STRING D9c-JMM-1
7335: PPUSH
7336: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7340: LD_EXP 26
7344: PPUSH
7345: LD_STRING D9c-Ar1-2
7347: PPUSH
7348: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7352: LD_EXP 28
7356: PPUSH
7357: LD_STRING D9c-FAr1-2
7359: PPUSH
7360: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7364: LD_EXP 26
7368: PPUSH
7369: LD_STRING D9c-Ar1-3
7371: PPUSH
7372: CALL_OW 88
// case Query ( QInfo ) of 1 :
7376: LD_STRING QInfo
7378: PPUSH
7379: CALL_OW 97
7383: PUSH
7384: LD_INT 1
7386: DOUBLE
7387: EQUAL
7388: IFTRUE 7392
7390: GO 7415
7392: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7393: LD_EXP 18
7397: PPUSH
7398: LD_STRING D8b1-JMM-1
7400: PPUSH
7401: CALL_OW 88
// player_want_info := 2 ;
7405: LD_ADDR_EXP 13
7409: PUSH
7410: LD_INT 2
7412: ST_TO_ADDR
// end ; 2 :
7413: GO 7439
7415: LD_INT 2
7417: DOUBLE
7418: EQUAL
7419: IFTRUE 7423
7421: GO 7438
7423: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7424: LD_EXP 26
7428: PPUSH
7429: LD_STRING D8b2-Ar1-1
7431: PPUSH
7432: CALL_OW 88
// end ; end ;
7436: GO 7439
7438: POP
// DialogueOff ;
7439: CALL_OW 7
// end ; end else
7443: GO 8090
// begin RemoveEnvironmentArea ( mortarArea ) ;
7445: LD_INT 2
7447: PPUSH
7448: CALL_OW 355
// wait ( 1 ) ;
7452: LD_INT 1
7454: PPUSH
7455: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7459: LD_EXP 27
7463: PPUSH
7464: LD_INT 1
7466: PPUSH
7467: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7471: LD_EXP 27
7475: PPUSH
7476: LD_INT 4
7478: PPUSH
7479: LD_INT 107
7481: PPUSH
7482: LD_INT 131
7484: PPUSH
7485: LD_INT 0
7487: PPUSH
7488: CALL_OW 145
// repeat wait ( 1 ) ;
7492: LD_INT 1
7494: PPUSH
7495: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7499: LD_INT 30
7501: PUSH
7502: LD_INT 4
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 23
7511: PUSH
7512: LD_INT 2
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PPUSH
7523: CALL_OW 69
7527: IFFALSE 7492
// SetSide ( Gali , 2 ) ;
7529: LD_EXP 27
7533: PPUSH
7534: LD_INT 2
7536: PPUSH
7537: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7541: LD_ADDR_VAR 0 8
7545: PUSH
7546: LD_INT 30
7548: PUSH
7549: LD_INT 4
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 23
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 69
7574: PUSH
7575: LD_INT 1
7577: ARRAY
7578: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7579: LD_INT 35
7581: PPUSH
7582: CALL_OW 67
// if player_attacked_ar then
7586: LD_EXP 16
7590: IFFALSE 7594
// exit ;
7592: GO 9288
// until BuildingStatus ( b ) <> bs_build ;
7594: LD_VAR 0 8
7598: PPUSH
7599: CALL_OW 461
7603: PUSH
7604: LD_INT 1
7606: NONEQUAL
7607: IFFALSE 7579
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7609: LD_VAR 0 8
7613: PPUSH
7614: CALL_OW 302
7618: PUSH
7619: LD_VAR 0 4
7623: PPUSH
7624: CALL_OW 274
7628: PPUSH
7629: LD_INT 1
7631: PPUSH
7632: CALL_OW 275
7636: PUSH
7637: LD_INT 25
7639: GREATEREQUAL
7640: AND
7641: IFFALSE 7740
// begin ComUpgrade ( b ) ;
7643: LD_VAR 0 8
7647: PPUSH
7648: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7652: LD_EXP 27
7656: PPUSH
7657: LD_STRING h
7659: PUSH
7660: LD_VAR 0 8
7664: PPUSH
7665: CALL_OW 250
7669: PUSH
7670: LD_VAR 0 8
7674: PPUSH
7675: CALL_OW 251
7679: PUSH
7680: LD_VAR 0 8
7684: PUSH
7685: LD_INT 0
7687: PUSH
7688: LD_INT 0
7690: PUSH
7691: LD_INT 0
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: PPUSH
7706: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7710: LD_INT 35
7712: PPUSH
7713: CALL_OW 67
// if player_attacked_ar then
7717: LD_EXP 16
7721: IFFALSE 7725
// exit ;
7723: GO 9288
// until BuildingStatus ( b ) <> bs_build ;
7725: LD_VAR 0 8
7729: PPUSH
7730: CALL_OW 461
7734: PUSH
7735: LD_INT 1
7737: NONEQUAL
7738: IFFALSE 7710
// end ; if b then
7740: LD_VAR 0 8
7744: IFFALSE 7755
// CenterNowOnUnits ( b ) ;
7746: LD_VAR 0 8
7750: PPUSH
7751: CALL_OW 87
// DialogueOn ;
7755: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7759: LD_EXP 27
7763: PPUSH
7764: LD_STRING D9d-Ar2-1
7766: PPUSH
7767: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7771: LD_EXP 26
7775: PPUSH
7776: LD_STRING D9d-Ar1-1
7778: PPUSH
7779: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7783: LD_EXP 18
7787: PPUSH
7788: LD_STRING D9d-JMM-1
7790: PPUSH
7791: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7795: LD_EXP 26
7799: PPUSH
7800: LD_STRING D9d-Ar1-2
7802: PPUSH
7803: CALL_OW 88
// DialogueOff ;
7807: CALL_OW 7
// i := [ ] ;
7811: LD_ADDR_VAR 0 1
7815: PUSH
7816: EMPTY
7817: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7818: LD_VAR 0 4
7822: PPUSH
7823: CALL_OW 274
7827: PPUSH
7828: LD_INT 3
7830: PPUSH
7831: CALL_OW 275
7835: PUSH
7836: LD_INT 20
7838: GREATEREQUAL
7839: IFFALSE 7858
// i := i ^ [ 1 ] ;
7841: LD_ADDR_VAR 0 1
7845: PUSH
7846: LD_VAR 0 1
7850: PUSH
7851: LD_INT 1
7853: PUSH
7854: EMPTY
7855: LIST
7856: ADD
7857: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7858: LD_VAR 0 4
7862: PPUSH
7863: CALL_OW 274
7867: PPUSH
7868: LD_INT 1
7870: PPUSH
7871: CALL_OW 275
7875: PUSH
7876: LD_INT 50
7878: GREATEREQUAL
7879: IFFALSE 7898
// i := i ^ [ 2 ] ;
7881: LD_ADDR_VAR 0 1
7885: PUSH
7886: LD_VAR 0 1
7890: PUSH
7891: LD_INT 2
7893: PUSH
7894: EMPTY
7895: LIST
7896: ADD
7897: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7898: LD_VAR 0 4
7902: PPUSH
7903: CALL_OW 274
7907: PPUSH
7908: LD_INT 2
7910: PPUSH
7911: CALL_OW 275
7915: PUSH
7916: LD_INT 80
7918: GREATEREQUAL
7919: IFFALSE 7938
// i := i ^ [ 3 ] ;
7921: LD_ADDR_VAR 0 1
7925: PUSH
7926: LD_VAR 0 1
7930: PUSH
7931: LD_INT 3
7933: PUSH
7934: EMPTY
7935: LIST
7936: ADD
7937: ST_TO_ADDR
// i := i diff 0 ;
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 1
7947: PUSH
7948: LD_INT 0
7950: DIFF
7951: ST_TO_ADDR
// if i then
7952: LD_VAR 0 1
7956: IFFALSE 8062
// begin i := i ^ [ 4 ] ;
7958: LD_ADDR_VAR 0 1
7962: PUSH
7963: LD_VAR 0 1
7967: PUSH
7968: LD_INT 4
7970: PUSH
7971: EMPTY
7972: LIST
7973: ADD
7974: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7975: LD_STRING QInfo2
7977: PPUSH
7978: CALL_OW 97
7982: PUSH
7983: LD_INT 1
7985: DOUBLE
7986: EQUAL
7987: IFTRUE 7991
7989: GO 8002
7991: POP
// player_want_info := 3 ; 2 :
7992: LD_ADDR_EXP 13
7996: PUSH
7997: LD_INT 3
7999: ST_TO_ADDR
8000: GO 8060
8002: LD_INT 2
8004: DOUBLE
8005: EQUAL
8006: IFTRUE 8010
8008: GO 8021
8010: POP
// player_want_info := 1 ; 3 :
8011: LD_ADDR_EXP 13
8015: PUSH
8016: LD_INT 1
8018: ST_TO_ADDR
8019: GO 8060
8021: LD_INT 3
8023: DOUBLE
8024: EQUAL
8025: IFTRUE 8029
8027: GO 8040
8029: POP
// player_want_info := 2 ; 4 :
8030: LD_ADDR_EXP 13
8034: PUSH
8035: LD_INT 2
8037: ST_TO_ADDR
8038: GO 8060
8040: LD_INT 4
8042: DOUBLE
8043: EQUAL
8044: IFTRUE 8048
8046: GO 8059
8048: POP
// player_want_info := 0 ; end ;
8049: LD_ADDR_EXP 13
8053: PUSH
8054: LD_INT 0
8056: ST_TO_ADDR
8057: GO 8060
8059: POP
// end else
8060: GO 8090
// case Query ( QInfoNothing ) of 1 :
8062: LD_STRING QInfoNothing
8064: PPUSH
8065: CALL_OW 97
8069: PUSH
8070: LD_INT 1
8072: DOUBLE
8073: EQUAL
8074: IFTRUE 8078
8076: GO 8089
8078: POP
// player_want_info := 0 ; end ;
8079: LD_ADDR_EXP 13
8083: PUSH
8084: LD_INT 0
8086: ST_TO_ADDR
8087: GO 8090
8089: POP
// end ; end ; end ; if player_want_info then
8090: LD_EXP 13
8094: IFFALSE 9108
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8096: LD_ADDR_VAR 0 3
8100: PUSH
8101: LD_VAR 0 3
8105: PPUSH
8106: LD_INT 34
8108: PUSH
8109: LD_INT 32
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PPUSH
8116: CALL_OW 72
8120: ST_TO_ADDR
// if player_want_mortar then
8121: LD_EXP 12
8125: IFFALSE 8447
// begin case player_want_info of 1 :
8127: LD_EXP 13
8131: PUSH
8132: LD_INT 1
8134: DOUBLE
8135: EQUAL
8136: IFTRUE 8140
8138: GO 8151
8140: POP
// x := 5 ; 2 :
8141: LD_ADDR_VAR 0 2
8145: PUSH
8146: LD_INT 5
8148: ST_TO_ADDR
8149: GO 8190
8151: LD_INT 2
8153: DOUBLE
8154: EQUAL
8155: IFTRUE 8159
8157: GO 8170
8159: POP
// x := 8 ; 3 :
8160: LD_ADDR_VAR 0 2
8164: PUSH
8165: LD_INT 8
8167: ST_TO_ADDR
8168: GO 8190
8170: LD_INT 3
8172: DOUBLE
8173: EQUAL
8174: IFTRUE 8178
8176: GO 8189
8178: POP
// x := 2 ; end ;
8179: LD_ADDR_VAR 0 2
8183: PUSH
8184: LD_INT 2
8186: ST_TO_ADDR
8187: GO 8190
8189: POP
// repeat wait ( 0 0$1 ) ;
8190: LD_INT 35
8192: PPUSH
8193: CALL_OW 67
// until not HasTask ( Gali ) ;
8197: LD_EXP 27
8201: PPUSH
8202: CALL_OW 314
8206: NOT
8207: IFFALSE 8190
// for i = 1 to x do
8209: LD_ADDR_VAR 0 1
8213: PUSH
8214: DOUBLE
8215: LD_INT 1
8217: DEC
8218: ST_TO_ADDR
8219: LD_VAR 0 2
8223: PUSH
8224: FOR_TO
8225: IFFALSE 8390
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8227: LD_EXP 27
8231: PPUSH
8232: LD_VAR 0 4
8236: PPUSH
8237: LD_EXP 13
8241: PPUSH
8242: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8246: LD_EXP 27
8250: PPUSH
8251: LD_VAR 0 3
8255: PUSH
8256: LD_INT 1
8258: ARRAY
8259: PPUSH
8260: CALL_OW 172
// AddComHold ( Gali ) ;
8264: LD_EXP 27
8268: PPUSH
8269: CALL_OW 200
// repeat wait ( 3 ) ;
8273: LD_INT 3
8275: PPUSH
8276: CALL_OW 67
// if player_attacked_ar then
8280: LD_EXP 16
8284: IFFALSE 8290
// exit ;
8286: POP
8287: POP
8288: GO 9288
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8290: LD_EXP 27
8294: PPUSH
8295: LD_VAR 0 3
8299: PUSH
8300: LD_INT 1
8302: ARRAY
8303: PPUSH
8304: CALL_OW 296
8308: PUSH
8309: LD_INT 4
8311: LESS
8312: PUSH
8313: LD_EXP 27
8317: PPUSH
8318: LD_EXP 13
8322: PPUSH
8323: CALL_OW 289
8327: AND
8328: IFFALSE 8273
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8330: LD_VAR 0 3
8334: PUSH
8335: LD_INT 1
8337: ARRAY
8338: PPUSH
8339: LD_EXP 13
8343: PPUSH
8344: LD_VAR 0 3
8348: PUSH
8349: LD_INT 1
8351: ARRAY
8352: PPUSH
8353: LD_EXP 13
8357: PPUSH
8358: CALL_OW 289
8362: PUSH
8363: LD_INT 10
8365: PLUS
8366: PPUSH
8367: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8371: LD_EXP 27
8375: PPUSH
8376: LD_EXP 13
8380: PPUSH
8381: LD_INT 0
8383: PPUSH
8384: CALL_OW 290
// end ;
8388: GO 8224
8390: POP
8391: POP
// repeat wait ( 0 0$1 ) ;
8392: LD_INT 35
8394: PPUSH
8395: CALL_OW 67
// if player_attacked_ar then
8399: LD_EXP 16
8403: IFFALSE 8407
// exit ;
8405: GO 9288
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8407: LD_VAR 0 3
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: PPUSH
8416: LD_EXP 13
8420: PPUSH
8421: CALL_OW 289
8425: PUSH
8426: LD_VAR 0 2
8430: PUSH
8431: LD_INT 10
8433: MUL
8434: EQUAL
8435: IFFALSE 8392
// no_oil_gain := false ;
8437: LD_ADDR_VAR 0 6
8441: PUSH
8442: LD_INT 0
8444: ST_TO_ADDR
// end else
8445: GO 8929
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8447: LD_ADDR_VAR 0 3
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 2
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: PUSH
8462: LD_INT 21
8464: PUSH
8465: LD_INT 2
8467: PUSH
8468: EMPTY
8469: LIST
8470: LIST
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: PPUSH
8476: CALL_OW 69
8480: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8481: LD_EXP 27
8485: PPUSH
8486: LD_VAR 0 4
8490: PPUSH
8491: CALL_OW 250
8495: PUSH
8496: LD_INT 1
8498: PLUS
8499: PPUSH
8500: LD_VAR 0 4
8504: PPUSH
8505: CALL_OW 251
8509: PUSH
8510: LD_INT 1
8512: PLUS
8513: PPUSH
8514: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8518: LD_INT 35
8520: PPUSH
8521: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8525: LD_EXP 27
8529: PPUSH
8530: LD_VAR 0 4
8534: PPUSH
8535: CALL_OW 296
8539: PUSH
8540: LD_INT 4
8542: LESS
8543: IFFALSE 8518
// for i = 1 to 6 do
8545: LD_ADDR_VAR 0 1
8549: PUSH
8550: DOUBLE
8551: LD_INT 1
8553: DEC
8554: ST_TO_ADDR
8555: LD_INT 6
8557: PUSH
8558: FOR_TO
8559: IFFALSE 8756
// begin if player_attacked_ar then
8561: LD_EXP 16
8565: IFFALSE 8571
// exit ;
8567: POP
8568: POP
8569: GO 9288
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8571: LD_VAR 0 4
8575: PPUSH
8576: CALL_OW 274
8580: PPUSH
8581: LD_INT 2
8583: PPUSH
8584: CALL_OW 275
8588: PUSH
8589: LD_INT 10
8591: LESS
8592: PUSH
8593: LD_VAR 0 7
8597: NOT
8598: AND
8599: IFFALSE 8662
// begin first_warn := true ;
8601: LD_ADDR_VAR 0 7
8605: PUSH
8606: LD_INT 1
8608: ST_TO_ADDR
// DialogueOn ;
8609: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8613: LD_EXP 28
8617: PPUSH
8618: LD_STRING D9a-FAr1-1
8620: PPUSH
8621: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8625: LD_EXP 18
8629: PPUSH
8630: LD_STRING D9a-JMM-1
8632: PPUSH
8633: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8637: LD_EXP 26
8641: PPUSH
8642: LD_STRING D9a2-Ar1-1
8644: PPUSH
8645: CALL_OW 88
// DialogueOff ;
8649: CALL_OW 7
// wait ( time ) ;
8653: LD_VAR 0 5
8657: PPUSH
8658: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8662: LD_VAR 0 4
8666: PPUSH
8667: CALL_OW 274
8671: PPUSH
8672: LD_INT 2
8674: PPUSH
8675: CALL_OW 275
8679: PUSH
8680: LD_INT 10
8682: LESS
8683: IFFALSE 8709
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8685: LD_EXP 26
8689: PPUSH
8690: LD_STRING D9a3-Ar1-1
8692: PPUSH
8693: CALL_OW 88
// no_oil_gain := true ;
8697: LD_ADDR_VAR 0 6
8701: PUSH
8702: LD_INT 1
8704: ST_TO_ADDR
// break ;
8705: GO 8756
// end else
8707: GO 8754
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8709: LD_EXP 27
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: LD_INT 2
8721: PPUSH
8722: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8726: LD_EXP 27
8730: PPUSH
8731: LD_VAR 0 3
8735: PUSH
8736: LD_VAR 0 1
8740: PUSH
8741: LD_INT 3
8743: MOD
8744: PUSH
8745: LD_INT 1
8747: PLUS
8748: ARRAY
8749: PPUSH
8750: CALL_OW 210
// end ; end ;
8754: GO 8558
8756: POP
8757: POP
// repeat wait ( 0 0$1 ) ;
8758: LD_INT 35
8760: PPUSH
8761: CALL_OW 67
// if player_attacked_ar then
8765: LD_EXP 16
8769: IFFALSE 8773
// exit ;
8771: GO 9288
// for i in tmp do
8773: LD_ADDR_VAR 0 1
8777: PUSH
8778: LD_VAR 0 3
8782: PUSH
8783: FOR_IN
8784: IFFALSE 8815
// if GetFuel ( i ) < 100 then
8786: LD_VAR 0 1
8790: PPUSH
8791: CALL_OW 261
8795: PUSH
8796: LD_INT 100
8798: LESS
8799: IFFALSE 8813
// begin x := i ;
8801: LD_ADDR_VAR 0 2
8805: PUSH
8806: LD_VAR 0 1
8810: ST_TO_ADDR
// break ;
8811: GO 8815
// end ;
8813: GO 8783
8815: POP
8816: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8817: LD_EXP 27
8821: PPUSH
8822: CALL_OW 314
8826: NOT
8827: PUSH
8828: LD_EXP 27
8832: PPUSH
8833: CALL_OW 281
8837: NOT
8838: AND
8839: IFFALSE 8872
// begin ComTransport ( Gali , dep , mat_oil ) ;
8841: LD_EXP 27
8845: PPUSH
8846: LD_VAR 0 4
8850: PPUSH
8851: LD_INT 2
8853: PPUSH
8854: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8858: LD_EXP 27
8862: PPUSH
8863: LD_VAR 0 2
8867: PPUSH
8868: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8872: LD_VAR 0 3
8876: PUSH
8877: LD_INT 1
8879: ARRAY
8880: PPUSH
8881: CALL_OW 261
8885: PUSH
8886: LD_INT 80
8888: GREATER
8889: PUSH
8890: LD_VAR 0 3
8894: PUSH
8895: LD_INT 2
8897: ARRAY
8898: PPUSH
8899: CALL_OW 261
8903: PUSH
8904: LD_INT 80
8906: GREATER
8907: AND
8908: PUSH
8909: LD_VAR 0 3
8913: PUSH
8914: LD_INT 3
8916: ARRAY
8917: PPUSH
8918: CALL_OW 261
8922: PUSH
8923: LD_INT 80
8925: GREATER
8926: AND
8927: IFFALSE 8758
// end ; ComHold ( Gali ) ;
8929: LD_EXP 27
8933: PPUSH
8934: CALL_OW 140
// if not no_oil_gain then
8938: LD_VAR 0 6
8942: NOT
8943: IFFALSE 9108
// begin DialogueOn ;
8945: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8949: LD_EXP 26
8953: PPUSH
8954: CALL_OW 87
// if player_want_mortar then
8958: LD_EXP 12
8962: IFFALSE 8988
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8964: LD_EXP 26
8968: PPUSH
8969: LD_STRING D9e-Ar1-1
8971: PPUSH
8972: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8976: LD_EXP 18
8980: PPUSH
8981: LD_STRING D10a-JMM-1
8983: PPUSH
8984: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8988: LD_EXP 26
8992: PPUSH
8993: LD_STRING D10a-Ar1-1
8995: PPUSH
8996: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9000: LD_EXP 27
9004: PPUSH
9005: LD_STRING D10a-Ar2-1
9007: PPUSH
9008: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9012: LD_EXP 28
9016: PPUSH
9017: LD_STRING D10a-FAr1-1
9019: PPUSH
9020: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9024: LD_EXP 27
9028: PPUSH
9029: LD_STRING D10a-Ar2-2
9031: PPUSH
9032: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9036: LD_EXP 28
9040: PPUSH
9041: LD_STRING D10a-FAr1-2
9043: PPUSH
9044: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9048: LD_EXP 26
9052: PPUSH
9053: LD_STRING D10a-Ar1-2
9055: PPUSH
9056: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9060: LD_EXP 18
9064: PPUSH
9065: LD_STRING D10a-JMM-2
9067: PPUSH
9068: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9072: LD_EXP 26
9076: PPUSH
9077: LD_STRING D10a-Ar1-3
9079: PPUSH
9080: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9084: LD_EXP 18
9088: PPUSH
9089: LD_STRING D10a-JMM-3
9091: PPUSH
9092: CALL_OW 88
// player_get_info := true ;
9096: LD_ADDR_EXP 15
9100: PUSH
9101: LD_INT 1
9103: ST_TO_ADDR
// DialogueOff ;
9104: CALL_OW 7
// end ; end ; if player_attacked_ar then
9108: LD_EXP 16
9112: IFFALSE 9116
// exit ;
9114: GO 9288
// if player_want_mortar or player_want_info then
9116: LD_EXP 12
9120: PUSH
9121: LD_EXP 13
9125: OR
9126: IFFALSE 9140
// Say ( Vervecken , D9f-Ar1-1 ) ;
9128: LD_EXP 26
9132: PPUSH
9133: LD_STRING D9f-Ar1-1
9135: PPUSH
9136: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PPUSH
9150: CALL_OW 69
9154: PPUSH
9155: LD_INT 51
9157: PPUSH
9158: LD_INT 99
9160: PPUSH
9161: CALL_OW 111
// wait ( 0 0$1 ) ;
9165: LD_INT 35
9167: PPUSH
9168: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9172: LD_INT 22
9174: PUSH
9175: LD_INT 2
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 92
9184: PUSH
9185: LD_INT 51
9187: PUSH
9188: LD_INT 99
9190: PUSH
9191: LD_INT 2
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: PPUSH
9204: CALL_OW 69
9208: IFFALSE 9268
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9210: LD_ADDR_VAR 0 1
9214: PUSH
9215: LD_INT 22
9217: PUSH
9218: LD_INT 2
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: PUSH
9225: LD_INT 92
9227: PUSH
9228: LD_INT 51
9230: PUSH
9231: LD_INT 99
9233: PUSH
9234: LD_INT 2
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL_OW 69
9251: PUSH
9252: FOR_IN
9253: IFFALSE 9266
// RemoveUnit ( i ) ;
9255: LD_VAR 0 1
9259: PPUSH
9260: CALL_OW 64
9264: GO 9252
9266: POP
9267: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9268: LD_INT 22
9270: PUSH
9271: LD_INT 2
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: PUSH
9283: LD_INT 0
9285: EQUAL
9286: IFFALSE 9140
// end ;
9288: PPOPN 8
9290: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9291: LD_EXP 16
9295: IFFALSE 9648
9297: GO 9299
9299: DISABLE
9300: LD_INT 0
9302: PPUSH
9303: PPUSH
9304: PPUSH
9305: PPUSH
// begin ru_can_attack := true ;
9306: LD_ADDR_EXP 8
9310: PUSH
9311: LD_INT 1
9313: ST_TO_ADDR
// mine_launched := false ;
9314: LD_ADDR_VAR 0 3
9318: PUSH
9319: LD_INT 0
9321: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9322: LD_INT 22
9324: PUSH
9325: LD_INT 2
9327: PUSH
9328: EMPTY
9329: LIST
9330: LIST
9331: PPUSH
9332: CALL_OW 69
9336: PPUSH
9337: LD_INT 51
9339: PPUSH
9340: LD_INT 99
9342: PPUSH
9343: CALL_OW 111
// if IsOk ( Vervecken ) then
9347: LD_EXP 26
9351: PPUSH
9352: CALL_OW 302
9356: IFFALSE 9370
// Say ( Vervecken , D11a-Ar1-1 ) ;
9358: LD_EXP 26
9362: PPUSH
9363: LD_STRING D11a-Ar1-1
9365: PPUSH
9366: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9370: LD_ADDR_VAR 0 2
9374: PUSH
9375: LD_EXP 33
9379: PPUSH
9380: LD_INT 25
9382: PUSH
9383: LD_INT 1
9385: PUSH
9386: EMPTY
9387: LIST
9388: LIST
9389: PPUSH
9390: CALL_OW 72
9394: ST_TO_ADDR
// for i in tmp do
9395: LD_ADDR_VAR 0 1
9399: PUSH
9400: LD_VAR 0 2
9404: PUSH
9405: FOR_IN
9406: IFFALSE 9469
// if MineOfUnit ( i ) then
9408: LD_VAR 0 1
9412: PPUSH
9413: CALL_OW 459
9417: IFFALSE 9467
// begin x := MineOfUnit ( i ) ;
9419: LD_ADDR_VAR 0 4
9423: PUSH
9424: LD_VAR 0 1
9428: PPUSH
9429: CALL_OW 459
9433: ST_TO_ADDR
// mine_launched := true ;
9434: LD_ADDR_VAR 0 3
9438: PUSH
9439: LD_INT 1
9441: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9442: LD_VAR 0 4
9446: PUSH
9447: LD_INT 1
9449: ARRAY
9450: PPUSH
9451: LD_VAR 0 4
9455: PUSH
9456: LD_INT 2
9458: ARRAY
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: CALL_OW 456
// end ;
9467: GO 9405
9469: POP
9470: POP
// if mine_launched and IsOk ( Vervecken ) then
9471: LD_VAR 0 3
9475: PUSH
9476: LD_EXP 26
9480: PPUSH
9481: CALL_OW 302
9485: AND
9486: IFFALSE 9500
// Say ( Vervecken , D11b-Ar1-1 ) ;
9488: LD_EXP 26
9492: PPUSH
9493: LD_STRING D11b-Ar1-1
9495: PPUSH
9496: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9500: LD_INT 22
9502: PUSH
9503: LD_INT 2
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: PPUSH
9510: CALL_OW 69
9514: PPUSH
9515: LD_INT 51
9517: PPUSH
9518: LD_INT 99
9520: PPUSH
9521: CALL_OW 111
// wait ( 0 0$1 ) ;
9525: LD_INT 35
9527: PPUSH
9528: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9532: LD_INT 22
9534: PUSH
9535: LD_INT 2
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PUSH
9542: LD_INT 92
9544: PUSH
9545: LD_INT 51
9547: PUSH
9548: LD_INT 99
9550: PUSH
9551: LD_INT 2
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PPUSH
9564: CALL_OW 69
9568: IFFALSE 9628
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9570: LD_ADDR_VAR 0 1
9574: PUSH
9575: LD_INT 22
9577: PUSH
9578: LD_INT 2
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: PUSH
9585: LD_INT 92
9587: PUSH
9588: LD_INT 51
9590: PUSH
9591: LD_INT 99
9593: PUSH
9594: LD_INT 2
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: LIST
9601: LIST
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PPUSH
9607: CALL_OW 69
9611: PUSH
9612: FOR_IN
9613: IFFALSE 9626
// RemoveUnit ( i ) ;
9615: LD_VAR 0 1
9619: PPUSH
9620: CALL_OW 64
9624: GO 9612
9626: POP
9627: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9628: LD_INT 22
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PPUSH
9638: CALL_OW 69
9642: PUSH
9643: LD_INT 0
9645: EQUAL
9646: IFFALSE 9500
// end ;
9648: PPOPN 4
9650: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9651: LD_EXP 10
9655: IFFALSE 9834
9657: GO 9659
9659: DISABLE
9660: LD_INT 0
9662: PPUSH
// begin Wait ( 10 10$00 ) ;
9663: LD_INT 21000
9665: PPUSH
9666: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9670: LD_INT 22
9672: PUSH
9673: LD_INT 2
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PPUSH
9680: CALL_OW 69
9684: IFFALSE 9834
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9686: LD_INT 22
9688: PUSH
9689: LD_INT 2
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: PPUSH
9696: CALL_OW 69
9700: PPUSH
9701: LD_INT 51
9703: PPUSH
9704: LD_INT 99
9706: PPUSH
9707: CALL_OW 114
// wait ( 0 0$1 ) ;
9711: LD_INT 35
9713: PPUSH
9714: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9718: LD_INT 22
9720: PUSH
9721: LD_INT 2
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PUSH
9728: LD_INT 92
9730: PUSH
9731: LD_INT 51
9733: PUSH
9734: LD_INT 99
9736: PUSH
9737: LD_INT 2
9739: PUSH
9740: EMPTY
9741: LIST
9742: LIST
9743: LIST
9744: LIST
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PPUSH
9750: CALL_OW 69
9754: IFFALSE 9814
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9756: LD_ADDR_VAR 0 1
9760: PUSH
9761: LD_INT 22
9763: PUSH
9764: LD_INT 2
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PUSH
9771: LD_INT 92
9773: PUSH
9774: LD_INT 51
9776: PUSH
9777: LD_INT 99
9779: PUSH
9780: LD_INT 2
9782: PUSH
9783: EMPTY
9784: LIST
9785: LIST
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: PUSH
9798: FOR_IN
9799: IFFALSE 9812
// RemoveUnit ( i ) ;
9801: LD_VAR 0 1
9805: PPUSH
9806: CALL_OW 64
9810: GO 9798
9812: POP
9813: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9814: LD_INT 22
9816: PUSH
9817: LD_INT 2
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PPUSH
9824: CALL_OW 69
9828: PUSH
9829: LD_INT 0
9831: EQUAL
9832: IFFALSE 9686
// end ; end ;
9834: PPOPN 1
9836: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9837: LD_EXP 4
9841: IFFALSE 10769
9843: GO 9845
9845: DISABLE
9846: LD_INT 0
9848: PPUSH
9849: PPUSH
9850: PPUSH
// begin Wait ( game_time ) ;
9851: LD_EXP 7
9855: PPUSH
9856: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9860: LD_INT 35
9862: PPUSH
9863: CALL_OW 67
// until ( not ru_can_attack ) ;
9867: LD_EXP 8
9871: NOT
9872: IFFALSE 9860
// Wait ( 0 0$35 ) ;
9874: LD_INT 1225
9876: PPUSH
9877: CALL_OW 67
// DialogueOn ;
9881: CALL_OW 6
// InGameOn ;
9885: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9889: LD_EXP 25
9893: PPUSH
9894: LD_STRING D12-Pow-1
9896: PPUSH
9897: CALL_OW 94
// InGameOff ;
9901: CALL_OW 9
// DialogueOff ;
9905: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9909: LD_STRING M4
9911: PPUSH
9912: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9916: LD_INT 5
9918: PPUSH
9919: LD_INT 1
9921: PPUSH
9922: CALL_OW 424
// can_end := true ;
9926: LD_ADDR_EXP 17
9930: PUSH
9931: LD_INT 1
9933: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9934: LD_INT 35
9936: PPUSH
9937: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9941: CALL 784 0 0
9945: PUSH
9946: LD_INT 20
9948: GREATEREQUAL
9949: PUSH
9950: LD_INT 22
9952: PUSH
9953: LD_INT 1
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 21
9962: PUSH
9963: LD_INT 1
9965: PUSH
9966: EMPTY
9967: LIST
9968: LIST
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PPUSH
9974: CALL_OW 69
9978: PUSH
9979: LD_INT 5
9981: PPUSH
9982: LD_INT 22
9984: PUSH
9985: LD_INT 1
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: LD_INT 21
9994: PUSH
9995: LD_INT 1
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 70
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 1
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 55
10023: PUSH
10024: EMPTY
10025: LIST
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PPUSH
10031: CALL_OW 69
10035: PLUS
10036: LESSEQUAL
10037: AND
10038: IFFALSE 9934
// if not player_get_info then
10040: LD_EXP 15
10044: NOT
10045: IFFALSE 10056
// player_get_info := - 1 ;
10047: LD_ADDR_EXP 15
10051: PUSH
10052: LD_INT 1
10054: NEG
10055: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10056: LD_STRING Information
10058: PPUSH
10059: LD_EXP 15
10063: PPUSH
10064: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10068: LD_ADDR_VAR 0 2
10072: PUSH
10073: LD_INT 22
10075: PUSH
10076: LD_INT 1
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 2
10085: PUSH
10086: LD_INT 25
10088: PUSH
10089: LD_INT 2
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: PUSH
10096: LD_INT 25
10098: PUSH
10099: LD_INT 16
10101: PUSH
10102: EMPTY
10103: LIST
10104: LIST
10105: PUSH
10106: LD_INT 34
10108: PUSH
10109: LD_INT 12
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PPUSH
10126: CALL_OW 69
10130: ST_TO_ADDR
// sib := GetTerminalCargo ;
10131: LD_ADDR_VAR 0 3
10135: PUSH
10136: CALL 784 0 0
10140: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10141: LD_ADDR_VAR 0 3
10145: PUSH
10146: LD_VAR 0 3
10150: PUSH
10151: LD_INT 6
10153: PPUSH
10154: LD_INT 3
10156: PPUSH
10157: CALL_OW 287
10161: PLUS
10162: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10163: LD_ADDR_VAR 0 3
10167: PUSH
10168: LD_VAR 0 3
10172: PUSH
10173: LD_VAR 0 2
10177: PPUSH
10178: LD_INT 3
10180: PPUSH
10181: CALL_OW 289
10185: PLUS
10186: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10187: LD_VAR 0 3
10191: PUSH
10192: LD_INT 2
10194: PUSH
10195: LD_OWVAR 67
10199: PLUS
10200: PUSH
10201: LD_INT 50
10203: MUL
10204: LESS
10205: IFFALSE 10230
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10207: LD_STRING MuchSiberite
10209: PPUSH
10210: LD_INT 2
10212: NEG
10213: PUSH
10214: LD_OWVAR 67
10218: MUL
10219: PUSH
10220: LD_INT 1
10222: PLUS
10223: PPUSH
10224: CALL_OW 101
10228: GO 10240
// AddMedal ( MuchSiberite , 1 ) ;
10230: LD_STRING MuchSiberite
10232: PPUSH
10233: LD_INT 1
10235: PPUSH
10236: CALL_OW 101
// GiveMedals ( MAIN ) ;
10240: LD_STRING MAIN
10242: PPUSH
10243: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10247: LD_INT 22
10249: PUSH
10250: LD_INT 1
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: PUSH
10257: LD_INT 2
10259: PUSH
10260: LD_INT 25
10262: PUSH
10263: LD_INT 1
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: PUSH
10270: LD_INT 25
10272: PUSH
10273: LD_INT 2
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 25
10282: PUSH
10283: LD_INT 3
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: LD_INT 25
10292: PUSH
10293: LD_INT 4
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 25
10302: PUSH
10303: LD_INT 8
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: PPUSH
10322: CALL_OW 69
10326: PPUSH
10327: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10331: LD_ADDR_VAR 0 2
10335: PUSH
10336: LD_INT 22
10338: PUSH
10339: LD_INT 1
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PUSH
10346: LD_INT 25
10348: PUSH
10349: LD_INT 8
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 69
10364: ST_TO_ADDR
// if tmp then
10365: LD_VAR 0 2
10369: IFFALSE 10400
// for i in tmp do
10371: LD_ADDR_VAR 0 1
10375: PUSH
10376: LD_VAR 0 2
10380: PUSH
10381: FOR_IN
10382: IFFALSE 10398
// SetClass ( i , 1 ) ;
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 1
10391: PPUSH
10392: CALL_OW 336
10396: GO 10381
10398: POP
10399: POP
// SaveVariable ( sib , 09_sibRes ) ;
10400: LD_VAR 0 3
10404: PPUSH
10405: LD_STRING 09_sibRes
10407: PPUSH
10408: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10412: LD_EXP 15
10416: PPUSH
10417: LD_STRING 09_arInfo
10419: PPUSH
10420: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10424: LD_EXP 18
10428: PPUSH
10429: LD_EXP 1
10433: PUSH
10434: LD_STRING JMM
10436: STR
10437: PPUSH
10438: CALL_OW 38
// if IsLive ( Gary ) then
10442: LD_EXP 19
10446: PPUSH
10447: CALL_OW 300
10451: IFFALSE 10471
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10453: LD_EXP 19
10457: PPUSH
10458: LD_EXP 1
10462: PUSH
10463: LD_STRING Gary
10465: STR
10466: PPUSH
10467: CALL_OW 38
// if IsLive ( Bobby ) then
10471: LD_EXP 20
10475: PPUSH
10476: CALL_OW 300
10480: IFFALSE 10500
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10482: LD_EXP 20
10486: PPUSH
10487: LD_EXP 1
10491: PUSH
10492: LD_STRING Bobby
10494: STR
10495: PPUSH
10496: CALL_OW 38
// if IsLive ( Cyrus ) then
10500: LD_EXP 21
10504: PPUSH
10505: CALL_OW 300
10509: IFFALSE 10529
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10511: LD_EXP 21
10515: PPUSH
10516: LD_EXP 1
10520: PUSH
10521: LD_STRING Cyrus
10523: STR
10524: PPUSH
10525: CALL_OW 38
// if IsLive ( Houten ) then
10529: LD_EXP 22
10533: PPUSH
10534: CALL_OW 300
10538: IFFALSE 10558
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10540: LD_EXP 22
10544: PPUSH
10545: LD_EXP 1
10549: PUSH
10550: LD_STRING Houten
10552: STR
10553: PPUSH
10554: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10558: LD_ADDR_VAR 0 2
10562: PUSH
10563: LD_INT 22
10565: PUSH
10566: LD_INT 1
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: PUSH
10573: LD_INT 2
10575: PUSH
10576: LD_INT 25
10578: PUSH
10579: LD_INT 1
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PUSH
10586: LD_INT 25
10588: PUSH
10589: LD_INT 2
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 25
10598: PUSH
10599: LD_INT 3
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PUSH
10606: LD_INT 25
10608: PUSH
10609: LD_INT 4
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PPUSH
10627: CALL_OW 69
10631: PUSH
10632: LD_EXP 18
10636: PUSH
10637: LD_EXP 21
10641: PUSH
10642: LD_EXP 20
10646: PUSH
10647: LD_EXP 22
10651: PUSH
10652: LD_EXP 19
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: DIFF
10664: ST_TO_ADDR
// if tmp then
10665: LD_VAR 0 2
10669: IFFALSE 10689
// SaveCharacters ( tmp , mission_prefix & others ) ;
10671: LD_VAR 0 2
10675: PPUSH
10676: LD_EXP 1
10680: PUSH
10681: LD_STRING others
10683: STR
10684: PPUSH
10685: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10689: LD_ADDR_VAR 0 2
10693: PUSH
10694: LD_INT 22
10696: PUSH
10697: LD_INT 1
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 2
10706: PUSH
10707: LD_INT 25
10709: PUSH
10710: LD_INT 12
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: PUSH
10717: LD_INT 25
10719: PUSH
10720: LD_INT 16
10722: PUSH
10723: EMPTY
10724: LIST
10725: LIST
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: LIST
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: PPUSH
10736: CALL_OW 69
10740: ST_TO_ADDR
// if tmp then
10741: LD_VAR 0 2
10745: IFFALSE 10765
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10747: LD_VAR 0 2
10751: PPUSH
10752: LD_EXP 1
10756: PUSH
10757: LD_STRING apes
10759: STR
10760: PPUSH
10761: CALL_OW 38
// YouWin ;
10765: CALL_OW 103
// end ; end_of_file
10769: PPOPN 3
10771: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10772: LD_VAR 0 1
10776: PPUSH
10777: CALL_OW 266
10781: PUSH
10782: LD_INT 0
10784: EQUAL
10785: PUSH
10786: LD_EXP 3
10790: NOT
10791: AND
10792: IFFALSE 10816
// begin terminal := b ;
10794: LD_ADDR_EXP 3
10798: PUSH
10799: LD_VAR 0 1
10803: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10804: LD_EXP 3
10808: PPUSH
10809: LD_STRING terminal
10811: PPUSH
10812: CALL_OW 500
// end ; end ;
10816: PPOPN 2
10818: END
// on BuildingComplete ( b ) do var i ;
10819: LD_INT 0
10821: PPUSH
// begin if GetSide ( b ) = 3 then
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 255
10831: PUSH
10832: LD_INT 3
10834: EQUAL
10835: IFFALSE 10875
// for i = 1 to 4 do
10837: LD_ADDR_VAR 0 2
10841: PUSH
10842: DOUBLE
10843: LD_INT 1
10845: DEC
10846: ST_TO_ADDR
10847: LD_INT 4
10849: PUSH
10850: FOR_TO
10851: IFFALSE 10873
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10853: LD_ADDR_EXP 35
10857: PUSH
10858: LD_EXP 35
10862: PPUSH
10863: LD_INT 1
10865: PPUSH
10866: CALL_OW 3
10870: ST_TO_ADDR
10871: GO 10850
10873: POP
10874: POP
// end ;
10875: PPOPN 2
10877: END
// on VehicleConstructed ( veh , fac ) do var i ;
10878: LD_INT 0
10880: PPUSH
// begin if GetSide ( veh ) = 3 then
10881: LD_VAR 0 1
10885: PPUSH
10886: CALL_OW 255
10890: PUSH
10891: LD_INT 3
10893: EQUAL
10894: IFFALSE 11019
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10896: LD_VAR 0 1
10900: PPUSH
10901: CALL_OW 264
10905: PUSH
10906: LD_INT 53
10908: PUSH
10909: LD_INT 52
10911: PUSH
10912: LD_INT 51
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: LIST
10919: IN
10920: NOT
10921: IFFALSE 10939
// ru_force := ru_force ^ veh ;
10923: LD_ADDR_EXP 34
10927: PUSH
10928: LD_EXP 34
10932: PUSH
10933: LD_VAR 0 1
10937: ADD
10938: ST_TO_ADDR
// for i = 1 to 4 do
10939: LD_ADDR_VAR 0 3
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_INT 4
10951: PUSH
10952: FOR_TO
10953: IFFALSE 10975
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10955: LD_ADDR_EXP 36
10959: PUSH
10960: LD_EXP 36
10964: PPUSH
10965: LD_INT 1
10967: PPUSH
10968: CALL_OW 3
10972: ST_TO_ADDR
10973: GO 10952
10975: POP
10976: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10977: LD_VAR 0 1
10981: PPUSH
10982: CALL_OW 264
10986: PUSH
10987: LD_INT 53
10989: EQUAL
10990: IFFALSE 11019
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10992: LD_VAR 0 1
10996: PPUSH
10997: LD_INT 7
10999: PPUSH
11000: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11004: LD_VAR 0 1
11008: PPUSH
11009: LD_INT 170
11011: PPUSH
11012: LD_INT 235
11014: PPUSH
11015: CALL_OW 171
// end ; end ; end ;
11019: PPOPN 3
11021: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11022: LD_VAR 0 1
11026: PUSH
11027: LD_INT 1
11029: EQUAL
11030: PUSH
11031: LD_VAR 0 2
11035: PUSH
11036: LD_INT 2
11038: EQUAL
11039: AND
11040: PUSH
11041: LD_VAR 0 1
11045: PUSH
11046: LD_INT 2
11048: EQUAL
11049: PUSH
11050: LD_VAR 0 2
11054: PUSH
11055: LD_INT 1
11057: EQUAL
11058: AND
11059: OR
11060: IFFALSE 11070
// player_attacked_ar := true ;
11062: LD_ADDR_EXP 16
11066: PUSH
11067: LD_INT 1
11069: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11070: LD_VAR 0 1
11074: PUSH
11075: LD_INT 1
11077: EQUAL
11078: PUSH
11079: LD_VAR 0 2
11083: PUSH
11084: LD_INT 4
11086: EQUAL
11087: AND
11088: PUSH
11089: LD_VAR 0 1
11093: PUSH
11094: LD_INT 4
11096: EQUAL
11097: PUSH
11098: LD_VAR 0 2
11102: PUSH
11103: LD_INT 1
11105: EQUAL
11106: AND
11107: OR
11108: IFFALSE 11117
// YouLost ( Traitor ) ;
11110: LD_STRING Traitor
11112: PPUSH
11113: CALL_OW 104
// end ;
11117: PPOPN 2
11119: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11120: LD_VAR 0 1
11124: PUSH
11125: LD_EXP 18
11129: EQUAL
11130: IFFALSE 11139
// YouLost ( JMM ) ;
11132: LD_STRING JMM
11134: PPUSH
11135: CALL_OW 104
// if un = terminal then
11139: LD_VAR 0 1
11143: PUSH
11144: LD_EXP 3
11148: EQUAL
11149: IFFALSE 11158
// YouLost ( Terminal ) ;
11151: LD_STRING Terminal
11153: PPUSH
11154: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11158: LD_VAR 0 1
11162: PUSH
11163: LD_INT 22
11165: PUSH
11166: LD_INT 3
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PUSH
11173: LD_INT 21
11175: PUSH
11176: LD_INT 3
11178: PUSH
11179: EMPTY
11180: LIST
11181: LIST
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: PPUSH
11187: CALL_OW 69
11191: IN
11192: IFFALSE 11338
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11194: LD_VAR 0 1
11198: PPUSH
11199: CALL_OW 266
11203: PUSH
11204: LD_INT 33
11206: PUSH
11207: LD_INT 26
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: IN
11214: IFFALSE 11273
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11216: LD_ADDR_EXP 35
11220: PUSH
11221: LD_EXP 35
11225: PUSH
11226: LD_VAR 0 1
11230: PPUSH
11231: CALL_OW 266
11235: PUSH
11236: LD_VAR 0 1
11240: PPUSH
11241: CALL_OW 250
11245: PUSH
11246: LD_VAR 0 1
11250: PPUSH
11251: CALL_OW 251
11255: PUSH
11256: LD_VAR 0 1
11260: PPUSH
11261: CALL_OW 254
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: ADD
11272: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11273: LD_VAR 0 1
11277: PPUSH
11278: CALL_OW 266
11282: PUSH
11283: LD_INT 5
11285: EQUAL
11286: IFFALSE 11338
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11288: LD_ADDR_EXP 35
11292: PUSH
11293: LD_EXP 35
11297: PUSH
11298: LD_INT 4
11300: PUSH
11301: LD_VAR 0 1
11305: PPUSH
11306: CALL_OW 250
11310: PUSH
11311: LD_VAR 0 1
11315: PPUSH
11316: CALL_OW 251
11320: PUSH
11321: LD_VAR 0 1
11325: PPUSH
11326: CALL_OW 254
11330: PUSH
11331: EMPTY
11332: LIST
11333: LIST
11334: LIST
11335: LIST
11336: ADD
11337: ST_TO_ADDR
// end ; if un in ru_force then
11338: LD_VAR 0 1
11342: PUSH
11343: LD_EXP 34
11347: IN
11348: IFFALSE 11384
// begin ru_force := ru_force diff un ;
11350: LD_ADDR_EXP 34
11354: PUSH
11355: LD_EXP 34
11359: PUSH
11360: LD_VAR 0 1
11364: DIFF
11365: ST_TO_ADDR
// if ru_force = 0 then
11366: LD_EXP 34
11370: PUSH
11371: LD_INT 0
11373: EQUAL
11374: IFFALSE 11384
// ru_can_attack := false ;
11376: LD_ADDR_EXP 8
11380: PUSH
11381: LD_INT 0
11383: ST_TO_ADDR
// end ; end ; end_of_file
11384: PPOPN 1
11386: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11387: LD_EXP 5
11391: PUSH
11392: LD_EXP 6
11396: AND
11397: IFFALSE 11475
11399: GO 11401
11401: DISABLE
11402: LD_INT 0
11404: PPUSH
// begin enable ;
11405: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11406: LD_ADDR_VAR 0 1
11410: PUSH
11411: LD_INT 60
11413: PUSH
11414: CALL 784 0 0
11418: MINUS
11419: ST_TO_ADDR
// if sib < 0 then
11420: LD_VAR 0 1
11424: PUSH
11425: LD_INT 0
11427: LESS
11428: IFFALSE 11438
// sib := 0 ;
11430: LD_ADDR_VAR 0 1
11434: PUSH
11435: LD_INT 0
11437: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11438: LD_ADDR_OWVAR 47
11442: PUSH
11443: LD_STRING #Am09-1
11445: PUSH
11446: LD_VAR 0 1
11450: PUSH
11451: LD_EXP 6
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11461: LD_ADDR_EXP 6
11465: PUSH
11466: LD_EXP 6
11470: PUSH
11471: LD_INT 35
11473: MINUS
11474: ST_TO_ADDR
// end ;
11475: PPOPN 1
11477: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11478: LD_EXP 6
11482: PUSH
11483: LD_INT 0
11485: EQUAL
11486: IFFALSE 11498
11488: GO 11490
11490: DISABLE
// display_strings := [ ] ;
11491: LD_ADDR_OWVAR 47
11495: PUSH
11496: EMPTY
11497: ST_TO_ADDR
11498: END
// every 0 0$01 trigger ru_force and debug do
11499: LD_EXP 34
11503: PUSH
11504: LD_EXP 2
11508: AND
11509: IFFALSE 11525
11511: GO 11513
11513: DISABLE
// begin enable ;
11514: ENABLE
// display_strings := ru_force ;
11515: LD_ADDR_OWVAR 47
11519: PUSH
11520: LD_EXP 34
11524: ST_TO_ADDR
// end ;
11525: END
// every 1 1$35 do var i , tmp ;
11526: GO 11528
11528: DISABLE
11529: LD_INT 0
11531: PPUSH
11532: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11533: LD_ADDR_VAR 0 2
11537: PUSH
11538: LD_INT 1155
11540: PUSH
11541: LD_INT 1225
11543: PUSH
11544: LD_INT 1435
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: LIST
11551: PUSH
11552: LD_OWVAR 67
11556: ARRAY
11557: ST_TO_ADDR
// i := 0 ;
11558: LD_ADDR_VAR 0 1
11562: PUSH
11563: LD_INT 0
11565: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11566: LD_INT 1
11568: PPUSH
11569: LD_INT 5
11571: PPUSH
11572: CALL_OW 12
11576: PPUSH
11577: LD_INT 75
11579: PPUSH
11580: LD_INT 75
11582: PPUSH
11583: LD_INT 20
11585: PPUSH
11586: LD_INT 1
11588: PPUSH
11589: CALL_OW 56
// wait ( tmp ) ;
11593: LD_VAR 0 2
11597: PPUSH
11598: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11602: LD_ADDR_VAR 0 2
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: LD_INT 105
11614: PPUSH
11615: LD_INT 315
11617: PPUSH
11618: CALL_OW 12
11622: PLUS
11623: ST_TO_ADDR
// i := i + 1 ;
11624: LD_ADDR_VAR 0 1
11628: PUSH
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11638: LD_VAR 0 1
11642: PUSH
11643: LD_INT 3
11645: MOD
11646: PUSH
11647: LD_INT 0
11649: EQUAL
11650: PUSH
11651: LD_EXP 4
11655: AND
11656: IFFALSE 11694
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11658: LD_INT 2
11660: PPUSH
11661: LD_INT 5
11663: PPUSH
11664: CALL_OW 12
11668: PPUSH
11669: LD_INT 8
11671: PPUSH
11672: LD_INT 1
11674: PPUSH
11675: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11679: LD_INT 665
11681: PPUSH
11682: LD_INT 735
11684: PPUSH
11685: CALL_OW 12
11689: PPUSH
11690: CALL_OW 67
// end ; until tick > game_time ;
11694: LD_OWVAR 1
11698: PUSH
11699: LD_EXP 7
11703: GREATER
11704: IFFALSE 11566
// end ; end_of_file
11706: PPOPN 2
11708: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11709: LD_INT 0
11711: PPUSH
11712: PPUSH
11713: PPUSH
11714: PPUSH
11715: PPUSH
11716: PPUSH
// x := 76 ;
11717: LD_ADDR_VAR 0 5
11721: PUSH
11722: LD_INT 76
11724: ST_TO_ADDR
// y := 147 ;
11725: LD_ADDR_VAR 0 6
11729: PUSH
11730: LD_INT 147
11732: ST_TO_ADDR
// uc_side := 2 ;
11733: LD_ADDR_OWVAR 20
11737: PUSH
11738: LD_INT 2
11740: ST_TO_ADDR
// uc_nation := 2 ;
11741: LD_ADDR_OWVAR 21
11745: PUSH
11746: LD_INT 2
11748: ST_TO_ADDR
// InitHc ;
11749: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11753: LD_INT 1
11755: PPUSH
11756: LD_INT 1
11758: PPUSH
11759: LD_INT 6
11761: PPUSH
11762: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11766: LD_ADDR_OWVAR 26
11770: PUSH
11771: LD_STRING Nicolas Vervecken
11773: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11774: LD_ADDR_OWVAR 33
11778: PUSH
11779: LD_STRING SecondCharsGal
11781: ST_TO_ADDR
// hc_face_number := 3 ;
11782: LD_ADDR_OWVAR 34
11786: PUSH
11787: LD_INT 3
11789: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11790: LD_ADDR_OWVAR 29
11794: PUSH
11795: LD_INT 11
11797: PUSH
11798: LD_INT 10
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: ST_TO_ADDR
// Vervecken := CreateHuman ;
11805: LD_ADDR_EXP 26
11809: PUSH
11810: CALL_OW 44
11814: ST_TO_ADDR
// ar_force := Vervecken ;
11815: LD_ADDR_EXP 33
11819: PUSH
11820: LD_EXP 26
11824: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11825: LD_INT 1
11827: PPUSH
11828: LD_INT 2
11830: PPUSH
11831: LD_INT 6
11833: PPUSH
11834: CALL_OW 380
// hc_name := Louis Gali ;
11838: LD_ADDR_OWVAR 26
11842: PUSH
11843: LD_STRING Louis Gali
11845: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11846: LD_ADDR_OWVAR 33
11850: PUSH
11851: LD_STRING SecondCharsGal
11853: ST_TO_ADDR
// hc_face_number := 2 ;
11854: LD_ADDR_OWVAR 34
11858: PUSH
11859: LD_INT 2
11861: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11862: LD_ADDR_OWVAR 29
11866: PUSH
11867: LD_INT 10
11869: PUSH
11870: LD_INT 11
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: ST_TO_ADDR
// Gali := CreateHuman ;
11877: LD_ADDR_EXP 27
11881: PUSH
11882: CALL_OW 44
11886: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11887: LD_ADDR_EXP 33
11891: PUSH
11892: LD_EXP 33
11896: PUSH
11897: LD_EXP 27
11901: ADD
11902: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11903: LD_INT 2
11905: PPUSH
11906: LD_INT 1
11908: PPUSH
11909: LD_INT 6
11911: PPUSH
11912: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11916: LD_ADDR_OWVAR 26
11920: PUSH
11921: LD_STRING Maria Bogdanovic
11923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11924: LD_ADDR_OWVAR 33
11928: PUSH
11929: LD_STRING SecondCharsGal
11931: ST_TO_ADDR
// hc_face_number := 14 ;
11932: LD_ADDR_OWVAR 34
11936: PUSH
11937: LD_INT 14
11939: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11940: LD_ADDR_OWVAR 29
11944: PUSH
11945: LD_INT 12
11947: PUSH
11948: LD_INT 9
11950: PUSH
11951: EMPTY
11952: LIST
11953: LIST
11954: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11955: LD_ADDR_EXP 28
11959: PUSH
11960: CALL_OW 44
11964: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11965: LD_ADDR_EXP 33
11969: PUSH
11970: LD_EXP 33
11974: PUSH
11975: LD_EXP 28
11979: ADD
11980: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11981: LD_INT 1
11983: PPUSH
11984: LD_INT 3
11986: PPUSH
11987: LD_INT 6
11989: PPUSH
11990: CALL_OW 380
// hc_name = Kntor Radomr ;
11994: LD_ADDR_OWVAR 26
11998: PUSH
11999: LD_STRING Kntor Radomr
12001: ST_TO_ADDR
// hc_gallery = sandar ;
12002: LD_ADDR_OWVAR 33
12006: PUSH
12007: LD_STRING sandar
12009: ST_TO_ADDR
// hc_face_number = 12 ;
12010: LD_ADDR_OWVAR 34
12014: PUSH
12015: LD_INT 12
12017: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12018: LD_ADDR_OWVAR 29
12022: PUSH
12023: LD_INT 9
12025: PUSH
12026: LD_INT 9
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: ST_TO_ADDR
// Kantor = CreateHuman ;
12033: LD_ADDR_EXP 29
12037: PUSH
12038: CALL_OW 44
12042: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12043: LD_ADDR_EXP 33
12047: PUSH
12048: LD_EXP 33
12052: PUSH
12053: LD_EXP 29
12057: ADD
12058: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12059: LD_INT 1
12061: PPUSH
12062: LD_INT 3
12064: PPUSH
12065: LD_INT 6
12067: PPUSH
12068: CALL_OW 380
// hc_name = Herczeg Farkas ;
12072: LD_ADDR_OWVAR 26
12076: PUSH
12077: LD_STRING Herczeg Farkas
12079: ST_TO_ADDR
// hc_gallery = sandar ;
12080: LD_ADDR_OWVAR 33
12084: PUSH
12085: LD_STRING sandar
12087: ST_TO_ADDR
// hc_face_number = 28 ;
12088: LD_ADDR_OWVAR 34
12092: PUSH
12093: LD_INT 28
12095: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12096: LD_ADDR_OWVAR 29
12100: PUSH
12101: LD_INT 10
12103: PUSH
12104: LD_INT 9
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: ST_TO_ADDR
// Herczeg = CreateHuman ;
12111: LD_ADDR_EXP 30
12115: PUSH
12116: CALL_OW 44
12120: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12121: LD_ADDR_EXP 33
12125: PUSH
12126: LD_EXP 33
12130: PUSH
12131: LD_EXP 30
12135: ADD
12136: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12137: LD_INT 1
12139: PPUSH
12140: LD_INT 1
12142: PPUSH
12143: LD_INT 6
12145: PPUSH
12146: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12150: LD_ADDR_OWVAR 26
12154: PUSH
12155: LD_STRING Ronn Horntvedt
12157: ST_TO_ADDR
// hc_gallery = sandar ;
12158: LD_ADDR_OWVAR 33
12162: PUSH
12163: LD_STRING sandar
12165: ST_TO_ADDR
// hc_face_number = 29 ;
12166: LD_ADDR_OWVAR 34
12170: PUSH
12171: LD_INT 29
12173: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12174: LD_ADDR_OWVAR 29
12178: PUSH
12179: LD_INT 11
12181: PUSH
12182: LD_INT 11
12184: PUSH
12185: EMPTY
12186: LIST
12187: LIST
12188: ST_TO_ADDR
// Ronn = CreateHuman ;
12189: LD_ADDR_EXP 31
12193: PUSH
12194: CALL_OW 44
12198: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12199: LD_ADDR_EXP 33
12203: PUSH
12204: LD_EXP 33
12208: PUSH
12209: LD_EXP 31
12213: ADD
12214: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12215: LD_INT 2
12217: PPUSH
12218: LD_INT 3
12220: PPUSH
12221: LD_INT 6
12223: PPUSH
12224: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12228: LD_ADDR_OWVAR 26
12232: PUSH
12233: LD_STRING Mia D. Mathiasen
12235: ST_TO_ADDR
// hc_gallery = sandar ;
12236: LD_ADDR_OWVAR 33
12240: PUSH
12241: LD_STRING sandar
12243: ST_TO_ADDR
// hc_face_number = 31 ;
12244: LD_ADDR_OWVAR 34
12248: PUSH
12249: LD_INT 31
12251: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12252: LD_ADDR_OWVAR 29
12256: PUSH
12257: LD_INT 10
12259: PUSH
12260: LD_INT 10
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: ST_TO_ADDR
// Mia = CreateHuman ;
12267: LD_ADDR_EXP 32
12271: PUSH
12272: CALL_OW 44
12276: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12277: LD_ADDR_EXP 33
12281: PUSH
12282: LD_EXP 33
12286: PUSH
12287: LD_EXP 32
12291: ADD
12292: ST_TO_ADDR
// for i = 1 to 2 do
12293: LD_ADDR_VAR 0 4
12297: PUSH
12298: DOUBLE
12299: LD_INT 1
12301: DEC
12302: ST_TO_ADDR
12303: LD_INT 2
12305: PUSH
12306: FOR_TO
12307: IFFALSE 12348
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12309: LD_ADDR_VAR 0 3
12313: PUSH
12314: LD_VAR 0 3
12318: PUSH
12319: LD_INT 2
12321: PPUSH
12322: LD_INT 2
12324: PPUSH
12325: LD_INT 14
12327: PPUSH
12328: LD_INT 1
12330: PPUSH
12331: LD_INT 1
12333: PPUSH
12334: LD_INT 32
12336: PPUSH
12337: LD_INT 30
12339: PPUSH
12340: CALL 264 0 7
12344: ADD
12345: ST_TO_ADDR
12346: GO 12306
12348: POP
12349: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12350: LD_ADDR_VAR 0 3
12354: PUSH
12355: LD_VAR 0 3
12359: PUSH
12360: LD_INT 2
12362: PPUSH
12363: LD_INT 2
12365: PPUSH
12366: LD_INT 14
12368: PPUSH
12369: LD_INT 1
12371: PPUSH
12372: LD_INT 1
12374: PPUSH
12375: LD_INT 26
12377: PPUSH
12378: LD_INT 33
12380: PPUSH
12381: CALL 264 0 7
12385: ADD
12386: ST_TO_ADDR
// tmp := tmp diff 0 ;
12387: LD_ADDR_VAR 0 3
12391: PUSH
12392: LD_VAR 0 3
12396: PUSH
12397: LD_INT 0
12399: DIFF
12400: ST_TO_ADDR
// for i in ar_force do
12401: LD_ADDR_VAR 0 4
12405: PUSH
12406: LD_EXP 33
12410: PUSH
12411: FOR_IN
12412: IFFALSE 12555
// begin if GetClass ( i ) = 3 then
12414: LD_VAR 0 4
12418: PPUSH
12419: CALL_OW 257
12423: PUSH
12424: LD_INT 3
12426: EQUAL
12427: IFFALSE 12509
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12429: LD_VAR 0 3
12433: PUSH
12434: LD_INT 1
12436: ARRAY
12437: PPUSH
12438: LD_INT 1
12440: PPUSH
12441: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12445: LD_VAR 0 3
12449: PUSH
12450: LD_INT 1
12452: ARRAY
12453: PPUSH
12454: LD_VAR 0 5
12458: PPUSH
12459: LD_VAR 0 6
12463: PPUSH
12464: LD_INT 0
12466: PPUSH
12467: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12471: LD_VAR 0 4
12475: PPUSH
12476: LD_VAR 0 3
12480: PUSH
12481: LD_INT 1
12483: ARRAY
12484: PPUSH
12485: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12489: LD_ADDR_VAR 0 3
12493: PUSH
12494: LD_VAR 0 3
12498: PPUSH
12499: LD_INT 1
12501: PPUSH
12502: CALL_OW 3
12506: ST_TO_ADDR
// end else
12507: GO 12531
// PlaceUnitXY ( i , x , y , false ) ;
12509: LD_VAR 0 4
12513: PPUSH
12514: LD_VAR 0 5
12518: PPUSH
12519: LD_VAR 0 6
12523: PPUSH
12524: LD_INT 0
12526: PPUSH
12527: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12531: LD_VAR 0 4
12535: PPUSH
12536: LD_INT 86
12538: PPUSH
12539: LD_INT 121
12541: PPUSH
12542: CALL_OW 111
// wait ( 0 0$2 ) ;
12546: LD_INT 70
12548: PPUSH
12549: CALL_OW 67
// end ;
12553: GO 12411
12555: POP
12556: POP
// ar_force := ar_force ^ tmp ;
12557: LD_ADDR_EXP 33
12561: PUSH
12562: LD_EXP 33
12566: PUSH
12567: LD_VAR 0 3
12571: ADD
12572: ST_TO_ADDR
// ar_spawned := true ;
12573: LD_ADDR_EXP 11
12577: PUSH
12578: LD_INT 1
12580: ST_TO_ADDR
// end ; end_of_file
12581: LD_VAR 0 1
12585: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12586: LD_INT 0
12588: PPUSH
12589: PPUSH
12590: PPUSH
12591: PPUSH
12592: PPUSH
12593: PPUSH
12594: PPUSH
// InitHc ;
12595: CALL_OW 19
// uc_side := 3 ;
12599: LD_ADDR_OWVAR 20
12603: PUSH
12604: LD_INT 3
12606: ST_TO_ADDR
// uc_nation := 3 ;
12607: LD_ADDR_OWVAR 21
12611: PUSH
12612: LD_INT 3
12614: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12615: LD_ADDR_VAR 0 5
12619: PUSH
12620: LD_INT 5
12622: PUSH
12623: LD_INT 6
12625: PUSH
12626: LD_INT 7
12628: PUSH
12629: EMPTY
12630: LIST
12631: LIST
12632: LIST
12633: PUSH
12634: LD_OWVAR 67
12638: ARRAY
12639: ST_TO_ADDR
// ru_force := [ ] ;
12640: LD_ADDR_EXP 34
12644: PUSH
12645: EMPTY
12646: ST_TO_ADDR
// ru_rebuild := [ ] ;
12647: LD_ADDR_EXP 35
12651: PUSH
12652: EMPTY
12653: ST_TO_ADDR
// ru_produce_list := [ ] ;
12654: LD_ADDR_EXP 36
12658: PUSH
12659: EMPTY
12660: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12661: LD_ADDR_VAR 0 6
12665: PUSH
12666: LD_INT 22
12668: PUSH
12669: LD_INT 3
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: PUSH
12676: LD_INT 30
12678: PUSH
12679: LD_INT 8
12681: PUSH
12682: EMPTY
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: PPUSH
12690: CALL_OW 69
12694: PUSH
12695: LD_INT 1
12697: ARRAY
12698: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12699: LD_ADDR_VAR 0 4
12703: PUSH
12704: LD_INT 43
12706: PUSH
12707: LD_INT 46
12709: PUSH
12710: LD_INT 45
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: LIST
12717: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12718: LD_ADDR_VAR 0 7
12722: PUSH
12723: LD_INT 22
12725: PUSH
12726: LD_INT 3
12728: PUSH
12729: EMPTY
12730: LIST
12731: LIST
12732: PUSH
12733: LD_INT 30
12735: PUSH
12736: LD_INT 1
12738: PUSH
12739: EMPTY
12740: LIST
12741: LIST
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PPUSH
12747: CALL_OW 69
12751: PUSH
12752: LD_INT 1
12754: ARRAY
12755: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12756: LD_VAR 0 7
12760: PPUSH
12761: CALL_OW 274
12765: PPUSH
12766: LD_INT 1
12768: PPUSH
12769: LD_INT 5000
12771: PPUSH
12772: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12776: LD_VAR 0 7
12780: PPUSH
12781: CALL_OW 274
12785: PPUSH
12786: LD_INT 2
12788: PPUSH
12789: LD_INT 1000
12791: PPUSH
12792: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12796: LD_VAR 0 7
12800: PPUSH
12801: CALL_OW 274
12805: PPUSH
12806: LD_INT 3
12808: PPUSH
12809: LD_INT 30
12811: PPUSH
12812: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12816: LD_ADDR_VAR 0 2
12820: PUSH
12821: LD_INT 22
12823: PUSH
12824: LD_INT 3
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: LD_INT 30
12833: PUSH
12834: LD_INT 33
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PPUSH
12845: CALL_OW 69
12849: PUSH
12850: FOR_IN
12851: IFFALSE 12883
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12853: LD_VAR 0 2
12857: PPUSH
12858: LD_VAR 0 4
12862: PUSH
12863: LD_VAR 0 2
12867: PUSH
12868: LD_INT 3
12870: MOD
12871: PUSH
12872: LD_INT 1
12874: PLUS
12875: ARRAY
12876: PPUSH
12877: CALL_OW 431
// end ;
12881: GO 12850
12883: POP
12884: POP
// for i = 1 to 4 do
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: DOUBLE
12891: LD_INT 1
12893: DEC
12894: ST_TO_ADDR
12895: LD_INT 4
12897: PUSH
12898: FOR_TO
12899: IFFALSE 12960
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12901: LD_INT 0
12903: PPUSH
12904: LD_INT 9
12906: PPUSH
12907: LD_VAR 0 5
12911: PPUSH
12912: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12916: CALL_OW 44
12920: PPUSH
12921: LD_INT 22
12923: PUSH
12924: LD_INT 3
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: PUSH
12931: LD_INT 30
12933: PUSH
12934: LD_INT 5
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: PPUSH
12945: CALL_OW 69
12949: PUSH
12950: LD_INT 1
12952: ARRAY
12953: PPUSH
12954: CALL_OW 52
// end ;
12958: GO 12898
12960: POP
12961: POP
// for i = 1 to 5 do
12962: LD_ADDR_VAR 0 2
12966: PUSH
12967: DOUBLE
12968: LD_INT 1
12970: DEC
12971: ST_TO_ADDR
12972: LD_INT 5
12974: PUSH
12975: FOR_TO
12976: IFFALSE 13037
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12978: LD_INT 0
12980: PPUSH
12981: LD_INT 3
12983: PPUSH
12984: LD_VAR 0 5
12988: PPUSH
12989: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12993: CALL_OW 44
12997: PPUSH
12998: LD_INT 22
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: PUSH
13008: LD_INT 30
13010: PUSH
13011: LD_INT 3
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: PPUSH
13022: CALL_OW 69
13026: PUSH
13027: LD_INT 1
13029: ARRAY
13030: PPUSH
13031: CALL_OW 52
// end ;
13035: GO 12975
13037: POP
13038: POP
// for i = 1 to 4 do
13039: LD_ADDR_VAR 0 2
13043: PUSH
13044: DOUBLE
13045: LD_INT 1
13047: DEC
13048: ST_TO_ADDR
13049: LD_INT 4
13051: PUSH
13052: FOR_TO
13053: IFFALSE 13114
// begin PrepareHuman ( false , class_engineer , skill ) ;
13055: LD_INT 0
13057: PPUSH
13058: LD_INT 2
13060: PPUSH
13061: LD_VAR 0 5
13065: PPUSH
13066: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13070: CALL_OW 44
13074: PPUSH
13075: LD_INT 22
13077: PUSH
13078: LD_INT 3
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 30
13087: PUSH
13088: LD_INT 1
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PPUSH
13099: CALL_OW 69
13103: PUSH
13104: LD_INT 1
13106: ARRAY
13107: PPUSH
13108: CALL_OW 52
// end ;
13112: GO 13052
13114: POP
13115: POP
// for i = 1 to 3 do
13116: LD_ADDR_VAR 0 2
13120: PUSH
13121: DOUBLE
13122: LD_INT 1
13124: DEC
13125: ST_TO_ADDR
13126: LD_INT 3
13128: PUSH
13129: FOR_TO
13130: IFFALSE 13163
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13132: LD_INT 0
13134: PPUSH
13135: LD_INT 4
13137: PPUSH
13138: LD_VAR 0 5
13142: PPUSH
13143: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13147: CALL_OW 44
13151: PPUSH
13152: LD_VAR 0 6
13156: PPUSH
13157: CALL_OW 52
// end ;
13161: GO 13129
13163: POP
13164: POP
// AddComResearch ( lab , tech_tech2 ) ;
13165: LD_VAR 0 6
13169: PPUSH
13170: LD_INT 49
13172: PPUSH
13173: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13177: LD_VAR 0 6
13181: PPUSH
13182: LD_INT 50
13184: PPUSH
13185: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13189: LD_VAR 0 6
13193: PPUSH
13194: LD_INT 51
13196: PPUSH
13197: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13201: LD_VAR 0 6
13205: PPUSH
13206: LD_INT 52
13208: PPUSH
13209: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13213: LD_VAR 0 6
13217: PPUSH
13218: LD_INT 69
13220: PPUSH
13221: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13225: LD_VAR 0 6
13229: PPUSH
13230: LD_INT 39
13232: PPUSH
13233: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13237: LD_VAR 0 6
13241: PPUSH
13242: LD_INT 34
13244: PPUSH
13245: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13249: LD_VAR 0 6
13253: PPUSH
13254: LD_INT 40
13256: PPUSH
13257: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13261: LD_VAR 0 6
13265: PPUSH
13266: LD_INT 57
13268: PPUSH
13269: CALL_OW 184
// if Difficulty > 1 then
13273: LD_OWVAR 67
13277: PUSH
13278: LD_INT 1
13280: GREATER
13281: IFFALSE 13295
// AddComResearch ( lab , tech_comp2 ) ;
13283: LD_VAR 0 6
13287: PPUSH
13288: LD_INT 58
13290: PPUSH
13291: CALL_OW 184
// end ;
13295: LD_VAR 0 1
13299: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13300: LD_INT 7
13302: PPUSH
13303: CALL_OW 353
13307: PUSH
13308: LD_INT 3
13310: GREATER
13311: PUSH
13312: LD_INT 22
13314: PUSH
13315: LD_INT 3
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 34
13324: PUSH
13325: LD_INT 53
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: PPUSH
13336: CALL_OW 69
13340: NOT
13341: AND
13342: IFFALSE 13377
13344: GO 13346
13346: DISABLE
// begin enable ;
13347: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13348: LD_ADDR_EXP 36
13352: PUSH
13353: LD_EXP 36
13357: PUSH
13358: LD_INT 24
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: LD_INT 3
13366: PUSH
13367: LD_INT 53
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: ADD
13376: ST_TO_ADDR
// end ;
13377: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13378: LD_INT 22
13380: PUSH
13381: LD_INT 3
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 21
13390: PUSH
13391: LD_INT 3
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PPUSH
13402: CALL_OW 69
13406: IFFALSE 14184
13408: GO 13410
13410: DISABLE
13411: LD_INT 0
13413: PPUSH
13414: PPUSH
13415: PPUSH
13416: PPUSH
13417: PPUSH
13418: PPUSH
13419: PPUSH
13420: PPUSH
// begin enable ;
13421: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13422: LD_ADDR_VAR 0 3
13426: PUSH
13427: LD_INT 22
13429: PUSH
13430: LD_INT 3
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: PUSH
13437: LD_INT 21
13439: PUSH
13440: LD_INT 3
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: LD_INT 3
13449: PUSH
13450: LD_INT 24
13452: PUSH
13453: LD_INT 1000
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: LIST
13468: PPUSH
13469: CALL_OW 69
13473: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13474: LD_ADDR_VAR 0 4
13478: PUSH
13479: LD_INT 22
13481: PUSH
13482: LD_INT 3
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 25
13491: PUSH
13492: LD_INT 2
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: PPUSH
13503: CALL_OW 69
13507: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13508: LD_ADDR_VAR 0 5
13512: PUSH
13513: LD_INT 22
13515: PUSH
13516: LD_INT 3
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 30
13525: PUSH
13526: LD_INT 1
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PPUSH
13537: CALL_OW 69
13541: PUSH
13542: LD_INT 1
13544: ARRAY
13545: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13546: LD_ADDR_VAR 0 8
13550: PUSH
13551: LD_INT 22
13553: PUSH
13554: LD_INT 3
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PUSH
13561: LD_INT 2
13563: PUSH
13564: LD_INT 30
13566: PUSH
13567: LD_INT 6
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: PUSH
13574: LD_INT 30
13576: PUSH
13577: LD_INT 7
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: PUSH
13584: LD_INT 30
13586: PUSH
13587: LD_INT 8
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PPUSH
13604: CALL_OW 69
13608: PUSH
13609: LD_INT 1
13611: ARRAY
13612: ST_TO_ADDR
// if not engs then
13613: LD_VAR 0 4
13617: NOT
13618: IFFALSE 13622
// exit ;
13620: GO 14184
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13622: LD_ADDR_VAR 0 6
13626: PUSH
13627: LD_VAR 0 4
13631: PPUSH
13632: LD_INT 3
13634: PUSH
13635: LD_INT 24
13637: PUSH
13638: LD_INT 600
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 72
13653: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13654: LD_ADDR_VAR 0 7
13658: PUSH
13659: LD_INT 22
13661: PUSH
13662: LD_INT 3
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: PUSH
13669: LD_INT 25
13671: PUSH
13672: LD_INT 4
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: PPUSH
13683: CALL_OW 69
13687: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13688: LD_VAR 0 3
13692: NOT
13693: PUSH
13694: LD_EXP 35
13698: NOT
13699: AND
13700: IFFALSE 13760
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13702: LD_VAR 0 4
13706: PPUSH
13707: LD_INT 3
13709: PUSH
13710: LD_INT 54
13712: PUSH
13713: EMPTY
13714: LIST
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PPUSH
13720: CALL_OW 72
13724: IFFALSE 13758
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13726: LD_VAR 0 4
13730: PPUSH
13731: LD_INT 3
13733: PUSH
13734: LD_INT 54
13736: PUSH
13737: EMPTY
13738: LIST
13739: PUSH
13740: EMPTY
13741: LIST
13742: LIST
13743: PPUSH
13744: CALL_OW 72
13748: PPUSH
13749: LD_VAR 0 5
13753: PPUSH
13754: CALL_OW 120
// exit ;
13758: GO 14184
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13760: LD_VAR 0 4
13764: PPUSH
13765: LD_INT 54
13767: PUSH
13768: EMPTY
13769: LIST
13770: PPUSH
13771: CALL_OW 72
13775: IFFALSE 13797
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13777: LD_VAR 0 4
13781: PPUSH
13782: LD_INT 54
13784: PUSH
13785: EMPTY
13786: LIST
13787: PPUSH
13788: CALL_OW 72
13792: PPUSH
13793: CALL_OW 122
// if not tmp then
13797: LD_VAR 0 3
13801: NOT
13802: IFFALSE 13934
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13804: LD_INT 81
13806: PUSH
13807: LD_INT 3
13809: PUSH
13810: EMPTY
13811: LIST
13812: LIST
13813: PUSH
13814: LD_INT 92
13816: PUSH
13817: LD_INT 147
13819: PUSH
13820: LD_INT 212
13822: PUSH
13823: LD_INT 30
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: LIST
13830: LIST
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PPUSH
13836: CALL_OW 69
13840: NOT
13841: IFFALSE 13934
// begin if not HasTask ( engs [ 1 ] ) then
13843: LD_VAR 0 4
13847: PUSH
13848: LD_INT 1
13850: ARRAY
13851: PPUSH
13852: CALL_OW 314
13856: NOT
13857: IFFALSE 13934
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13859: LD_ADDR_VAR 0 2
13863: PUSH
13864: LD_VAR 0 4
13868: PPUSH
13869: LD_EXP 35
13873: PUSH
13874: LD_INT 1
13876: ARRAY
13877: PPUSH
13878: LD_EXP 35
13882: PUSH
13883: LD_INT 2
13885: ARRAY
13886: PPUSH
13887: LD_EXP 35
13891: PUSH
13892: LD_INT 3
13894: ARRAY
13895: PPUSH
13896: LD_EXP 35
13900: PUSH
13901: LD_INT 4
13903: ARRAY
13904: PPUSH
13905: CALL_OW 145
13909: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13910: LD_VAR 0 2
13914: PPUSH
13915: CALL_OW 266
13919: PUSH
13920: LD_INT 4
13922: EQUAL
13923: IFFALSE 13934
// AddComUpgrade ( i ) ;
13925: LD_VAR 0 2
13929: PPUSH
13930: CALL_OW 206
// end ; end ; end ; for i in engs do
13934: LD_ADDR_VAR 0 2
13938: PUSH
13939: LD_VAR 0 4
13943: PUSH
13944: FOR_IN
13945: IFFALSE 14063
// begin if i in to_heal and sci then
13947: LD_VAR 0 2
13951: PUSH
13952: LD_VAR 0 6
13956: IN
13957: PUSH
13958: LD_VAR 0 7
13962: AND
13963: IFFALSE 14014
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13965: LD_VAR 0 2
13969: PPUSH
13970: LD_INT 149
13972: PPUSH
13973: LD_INT 220
13975: PPUSH
13976: CALL_OW 297
13980: PUSH
13981: LD_INT 5
13983: LESS
13984: IFFALSE 13988
// continue ;
13986: GO 13944
// ComMoveXY ( i , 149 , 220 ) ;
13988: LD_VAR 0 2
13992: PPUSH
13993: LD_INT 149
13995: PPUSH
13996: LD_INT 220
13998: PPUSH
13999: CALL_OW 111
// AddComHold ( i ) ;
14003: LD_VAR 0 2
14007: PPUSH
14008: CALL_OW 200
// end else
14012: GO 14061
// if not HasTask ( i ) or WantsToAttack ( i ) then
14014: LD_VAR 0 2
14018: PPUSH
14019: CALL_OW 314
14023: NOT
14024: PUSH
14025: LD_VAR 0 2
14029: PPUSH
14030: CALL_OW 319
14034: OR
14035: IFFALSE 14061
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14037: LD_VAR 0 2
14041: PPUSH
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_VAR 0 2
14051: PPUSH
14052: CALL_OW 74
14056: PPUSH
14057: CALL_OW 130
// end ;
14061: GO 13944
14063: POP
14064: POP
// if to_heal and sci then
14065: LD_VAR 0 6
14069: PUSH
14070: LD_VAR 0 7
14074: AND
14075: IFFALSE 14136
// begin if UnitFilter ( sci , [ f_inside ] ) then
14077: LD_VAR 0 7
14081: PPUSH
14082: LD_INT 54
14084: PUSH
14085: EMPTY
14086: LIST
14087: PPUSH
14088: CALL_OW 72
14092: IFFALSE 14116
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14094: LD_VAR 0 7
14098: PPUSH
14099: LD_INT 54
14101: PUSH
14102: EMPTY
14103: LIST
14104: PPUSH
14105: CALL_OW 72
14109: PPUSH
14110: CALL_OW 122
14114: GO 14134
// ComHeal ( sci , to_heal [ 1 ] ) ;
14116: LD_VAR 0 7
14120: PPUSH
14121: LD_VAR 0 6
14125: PUSH
14126: LD_INT 1
14128: ARRAY
14129: PPUSH
14130: CALL_OW 128
// end else
14134: GO 14184
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14136: LD_VAR 0 7
14140: PPUSH
14141: LD_INT 56
14143: PUSH
14144: EMPTY
14145: LIST
14146: PPUSH
14147: CALL_OW 72
14151: PUSH
14152: LD_VAR 0 8
14156: AND
14157: IFFALSE 14184
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14159: LD_VAR 0 7
14163: PPUSH
14164: LD_INT 56
14166: PUSH
14167: EMPTY
14168: LIST
14169: PPUSH
14170: CALL_OW 72
14174: PPUSH
14175: LD_VAR 0 8
14179: PPUSH
14180: CALL_OW 120
// end ;
14184: PPOPN 8
14186: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14187: LD_INT 22
14189: PUSH
14190: LD_INT 3
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: PUSH
14197: LD_INT 30
14199: PUSH
14200: LD_INT 3
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: PPUSH
14211: CALL_OW 69
14215: PUSH
14216: LD_EXP 36
14220: AND
14221: IFFALSE 14347
14223: GO 14225
14225: DISABLE
14226: LD_INT 0
14228: PPUSH
14229: PPUSH
14230: PPUSH
// begin enable ;
14231: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14232: LD_ADDR_VAR 0 3
14236: PUSH
14237: LD_INT 22
14239: PUSH
14240: LD_INT 3
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 30
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PPUSH
14261: CALL_OW 69
14265: PUSH
14266: LD_INT 1
14268: ARRAY
14269: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14270: LD_VAR 0 3
14274: PPUSH
14275: CALL_OW 313
14279: PUSH
14280: LD_INT 0
14282: EQUAL
14283: IFFALSE 14287
// exit ;
14285: GO 14347
// if BuildingStatus ( fac ) = bs_idle then
14287: LD_VAR 0 3
14291: PPUSH
14292: CALL_OW 461
14296: PUSH
14297: LD_INT 2
14299: EQUAL
14300: IFFALSE 14347
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14302: LD_VAR 0 3
14306: PPUSH
14307: LD_EXP 36
14311: PUSH
14312: LD_INT 1
14314: ARRAY
14315: PPUSH
14316: LD_EXP 36
14320: PUSH
14321: LD_INT 2
14323: ARRAY
14324: PPUSH
14325: LD_EXP 36
14329: PUSH
14330: LD_INT 3
14332: ARRAY
14333: PPUSH
14334: LD_EXP 36
14338: PUSH
14339: LD_INT 4
14341: ARRAY
14342: PPUSH
14343: CALL_OW 125
// end ;
14347: PPOPN 3
14349: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14350: LD_INT 0
14352: PPUSH
14353: PPUSH
14354: PPUSH
14355: PPUSH
14356: PPUSH
// uc_side := 3 ;
14357: LD_ADDR_OWVAR 20
14361: PUSH
14362: LD_INT 3
14364: ST_TO_ADDR
// uc_nation := 3 ;
14365: LD_ADDR_OWVAR 21
14369: PUSH
14370: LD_INT 3
14372: ST_TO_ADDR
// ru_can_attack := false ;
14373: LD_ADDR_EXP 8
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14381: LD_ADDR_VAR 0 6
14385: PUSH
14386: LD_INT 22
14388: PUSH
14389: LD_INT 3
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: PUSH
14396: LD_INT 30
14398: PUSH
14399: LD_INT 3
14401: PUSH
14402: EMPTY
14403: LIST
14404: LIST
14405: PUSH
14406: EMPTY
14407: LIST
14408: LIST
14409: PPUSH
14410: CALL_OW 69
14414: ST_TO_ADDR
// if fac then
14415: LD_VAR 0 6
14419: IFFALSE 14571
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14421: LD_ADDR_EXP 36
14425: PUSH
14426: LD_INT 24
14428: PUSH
14429: LD_INT 1
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: LD_INT 43
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: LIST
14442: LIST
14443: ST_TO_ADDR
// if wave > 1 then
14444: LD_VAR 0 1
14448: PUSH
14449: LD_INT 1
14451: GREATER
14452: IFFALSE 14505
// for i = 1 to Difficulty do
14454: LD_ADDR_VAR 0 3
14458: PUSH
14459: DOUBLE
14460: LD_INT 1
14462: DEC
14463: ST_TO_ADDR
14464: LD_OWVAR 67
14468: PUSH
14469: FOR_TO
14470: IFFALSE 14503
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14472: LD_ADDR_EXP 36
14476: PUSH
14477: LD_EXP 36
14481: PUSH
14482: LD_INT 24
14484: PUSH
14485: LD_INT 1
14487: PUSH
14488: LD_INT 3
14490: PUSH
14491: LD_INT 45
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: ADD
14500: ST_TO_ADDR
14501: GO 14469
14503: POP
14504: POP
// repeat wait ( 0 0$1 ) ;
14505: LD_INT 35
14507: PPUSH
14508: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14512: LD_EXP 36
14516: PUSH
14517: LD_INT 4
14519: LESS
14520: PUSH
14521: LD_VAR 0 6
14525: PUSH
14526: LD_INT 1
14528: ARRAY
14529: PPUSH
14530: CALL_OW 313
14534: PUSH
14535: LD_INT 0
14537: EQUAL
14538: OR
14539: PUSH
14540: LD_VAR 0 6
14544: PUSH
14545: LD_INT 1
14547: ARRAY
14548: PPUSH
14549: CALL_OW 461
14553: PUSH
14554: LD_INT 8
14556: PUSH
14557: LD_INT 6
14559: PUSH
14560: LD_INT 7
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: LIST
14567: IN
14568: OR
14569: IFFALSE 14505
// end ; case wave of 1 :
14571: LD_VAR 0 1
14575: PUSH
14576: LD_INT 1
14578: DOUBLE
14579: EQUAL
14580: IFTRUE 14584
14582: GO 14669
14584: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14585: LD_ADDR_VAR 0 3
14589: PUSH
14590: DOUBLE
14591: LD_INT 1
14593: DEC
14594: ST_TO_ADDR
14595: LD_INT 4
14597: PUSH
14598: LD_INT 5
14600: PUSH
14601: LD_INT 6
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: LIST
14608: PUSH
14609: LD_OWVAR 67
14613: ARRAY
14614: PUSH
14615: FOR_TO
14616: IFFALSE 14624
// Sold ;
14618: CALL 14895 0 0
14622: GO 14615
14624: POP
14625: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14626: LD_ADDR_VAR 0 3
14630: PUSH
14631: DOUBLE
14632: LD_INT 1
14634: DEC
14635: ST_TO_ADDR
14636: LD_INT 2
14638: PUSH
14639: LD_INT 3
14641: PUSH
14642: LD_INT 3
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: PUSH
14650: LD_OWVAR 67
14654: ARRAY
14655: PUSH
14656: FOR_TO
14657: IFFALSE 14665
// Tank ;
14659: CALL 15025 0 0
14663: GO 14656
14665: POP
14666: POP
// end ; 2 .. 9 :
14667: GO 14882
14669: LD_INT 2
14671: DOUBLE
14672: GREATEREQUAL
14673: IFFALSE 14681
14675: LD_INT 9
14677: DOUBLE
14678: LESSEQUAL
14679: IFTRUE 14683
14681: GO 14788
14683: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14684: LD_ADDR_VAR 0 3
14688: PUSH
14689: DOUBLE
14690: LD_INT 1
14692: DEC
14693: ST_TO_ADDR
14694: LD_INT 4
14696: PUSH
14697: LD_INT 5
14699: PUSH
14700: LD_INT 6
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PUSH
14708: LD_OWVAR 67
14712: ARRAY
14713: PUSH
14714: LD_VAR 0 1
14718: PUSH
14719: LD_INT 2
14721: DIV
14722: PLUS
14723: PUSH
14724: FOR_TO
14725: IFFALSE 14733
// Sold ;
14727: CALL 14895 0 0
14731: GO 14724
14733: POP
14734: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14735: LD_ADDR_VAR 0 3
14739: PUSH
14740: DOUBLE
14741: LD_INT 1
14743: DEC
14744: ST_TO_ADDR
14745: LD_INT 3
14747: PUSH
14748: LD_INT 4
14750: PUSH
14751: LD_INT 4
14753: PUSH
14754: EMPTY
14755: LIST
14756: LIST
14757: LIST
14758: PUSH
14759: LD_OWVAR 67
14763: ARRAY
14764: PUSH
14765: LD_VAR 0 1
14769: PUSH
14770: LD_INT 2
14772: DIV
14773: PLUS
14774: PUSH
14775: FOR_TO
14776: IFFALSE 14784
// Tank ;
14778: CALL 15025 0 0
14782: GO 14775
14784: POP
14785: POP
// end ; 10 :
14786: GO 14882
14788: LD_INT 10
14790: DOUBLE
14791: EQUAL
14792: IFTRUE 14796
14794: GO 14881
14796: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14797: LD_ADDR_VAR 0 3
14801: PUSH
14802: DOUBLE
14803: LD_INT 1
14805: DEC
14806: ST_TO_ADDR
14807: LD_INT 10
14809: PUSH
14810: LD_INT 12
14812: PUSH
14813: LD_INT 14
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: LIST
14820: PUSH
14821: LD_OWVAR 67
14825: ARRAY
14826: PUSH
14827: FOR_TO
14828: IFFALSE 14836
// Sold ;
14830: CALL 14895 0 0
14834: GO 14827
14836: POP
14837: POP
// for i = 1 to [ 9 , 11 , 15 ] [ Difficulty ] do
14838: LD_ADDR_VAR 0 3
14842: PUSH
14843: DOUBLE
14844: LD_INT 1
14846: DEC
14847: ST_TO_ADDR
14848: LD_INT 9
14850: PUSH
14851: LD_INT 11
14853: PUSH
14854: LD_INT 15
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: LIST
14861: PUSH
14862: LD_OWVAR 67
14866: ARRAY
14867: PUSH
14868: FOR_TO
14869: IFFALSE 14877
// Tank ;
14871: CALL 15025 0 0
14875: GO 14868
14877: POP
14878: POP
// end ; end ;
14879: GO 14882
14881: POP
// ru_can_attack := true ;
14882: LD_ADDR_EXP 8
14886: PUSH
14887: LD_INT 1
14889: ST_TO_ADDR
// end ;
14890: LD_VAR 0 2
14894: RET
// function Sold ( ) ; var un , skill ; begin
14895: LD_INT 0
14897: PPUSH
14898: PPUSH
14899: PPUSH
// uc_side := 3 ;
14900: LD_ADDR_OWVAR 20
14904: PUSH
14905: LD_INT 3
14907: ST_TO_ADDR
// uc_nation := 3 ;
14908: LD_ADDR_OWVAR 21
14912: PUSH
14913: LD_INT 3
14915: ST_TO_ADDR
// InitHc ;
14916: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14920: LD_ADDR_VAR 0 3
14924: PUSH
14925: LD_INT 6
14927: PUSH
14928: LD_INT 7
14930: PUSH
14931: LD_INT 7
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: LIST
14938: PUSH
14939: LD_OWVAR 67
14943: ARRAY
14944: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14945: LD_INT 0
14947: PPUSH
14948: LD_INT 1
14950: PUSH
14951: LD_INT 9
14953: PUSH
14954: EMPTY
14955: LIST
14956: LIST
14957: PUSH
14958: LD_INT 1
14960: PPUSH
14961: LD_INT 2
14963: PPUSH
14964: CALL_OW 12
14968: ARRAY
14969: PPUSH
14970: LD_VAR 0 3
14974: PPUSH
14975: CALL_OW 380
// un := CreateHuman ;
14979: LD_ADDR_VAR 0 2
14983: PUSH
14984: CALL_OW 44
14988: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14989: LD_VAR 0 2
14993: PPUSH
14994: LD_INT 4
14996: PPUSH
14997: LD_INT 0
14999: PPUSH
15000: CALL_OW 49
// ru_force := ru_force ^ un ;
15004: LD_ADDR_EXP 34
15008: PUSH
15009: LD_EXP 34
15013: PUSH
15014: LD_VAR 0 2
15018: ADD
15019: ST_TO_ADDR
// end ;
15020: LD_VAR 0 1
15024: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15025: LD_INT 0
15027: PPUSH
15028: PPUSH
15029: PPUSH
15030: PPUSH
15031: PPUSH
// uc_side := 3 ;
15032: LD_ADDR_OWVAR 20
15036: PUSH
15037: LD_INT 3
15039: ST_TO_ADDR
// uc_nation := 3 ;
15040: LD_ADDR_OWVAR 21
15044: PUSH
15045: LD_INT 3
15047: ST_TO_ADDR
// InitHc ;
15048: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15052: LD_ADDR_VAR 0 5
15056: PUSH
15057: LD_INT 5
15059: PUSH
15060: LD_INT 6
15062: PUSH
15063: LD_INT 7
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: LIST
15070: PUSH
15071: LD_OWVAR 67
15075: ARRAY
15076: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15077: LD_ADDR_VAR 0 3
15081: PUSH
15082: LD_INT 22
15084: PUSH
15085: LD_INT 24
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PUSH
15092: LD_INT 1
15094: PPUSH
15095: LD_INT 2
15097: PPUSH
15098: CALL_OW 12
15102: ARRAY
15103: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15104: LD_VAR 0 3
15108: PUSH
15109: LD_INT 22
15111: EQUAL
15112: IFFALSE 15147
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15114: LD_ADDR_VAR 0 4
15118: PUSH
15119: LD_INT 45
15121: PUSH
15122: LD_INT 43
15124: PUSH
15125: LD_INT 44
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: LIST
15132: PUSH
15133: LD_INT 1
15135: PPUSH
15136: LD_INT 3
15138: PPUSH
15139: CALL_OW 12
15143: ARRAY
15144: ST_TO_ADDR
15145: GO 15178
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15147: LD_ADDR_VAR 0 4
15151: PUSH
15152: LD_INT 46
15154: PUSH
15155: LD_INT 44
15157: PUSH
15158: LD_INT 45
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: LIST
15165: PUSH
15166: LD_INT 1
15168: PPUSH
15169: LD_INT 3
15171: PPUSH
15172: CALL_OW 12
15176: ARRAY
15177: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15178: LD_ADDR_VAR 0 2
15182: PUSH
15183: LD_INT 3
15185: PPUSH
15186: LD_INT 3
15188: PPUSH
15189: LD_VAR 0 3
15193: PPUSH
15194: LD_INT 1
15196: PPUSH
15197: LD_INT 3
15199: PUSH
15200: LD_INT 3
15202: PUSH
15203: LD_INT 3
15205: PUSH
15206: LD_INT 1
15208: PUSH
15209: EMPTY
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: PUSH
15215: LD_INT 1
15217: PPUSH
15218: LD_INT 4
15220: PPUSH
15221: CALL_OW 12
15225: ARRAY
15226: PPUSH
15227: LD_VAR 0 4
15231: PPUSH
15232: LD_INT 99
15234: PPUSH
15235: CALL 264 0 7
15239: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15240: LD_VAR 0 2
15244: PPUSH
15245: CALL_OW 263
15249: PUSH
15250: LD_INT 1
15252: EQUAL
15253: IFFALSE 15284
// begin PrepareHuman ( false , 3 , skill ) ;
15255: LD_INT 0
15257: PPUSH
15258: LD_INT 3
15260: PPUSH
15261: LD_VAR 0 5
15265: PPUSH
15266: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15270: CALL_OW 44
15274: PPUSH
15275: LD_VAR 0 2
15279: PPUSH
15280: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15284: LD_VAR 0 2
15288: PPUSH
15289: LD_INT 3
15291: PPUSH
15292: LD_INT 0
15294: PPUSH
15295: CALL_OW 49
// ru_force := ru_force ^ un ;
15299: LD_ADDR_EXP 34
15303: PUSH
15304: LD_EXP 34
15308: PUSH
15309: LD_VAR 0 2
15313: ADD
15314: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15315: LD_VAR 0 2
15319: PPUSH
15320: LD_INT 126
15322: PPUSH
15323: LD_INT 158
15325: PPUSH
15326: CALL_OW 111
// Wait ( 0 0$3 ) ;
15330: LD_INT 105
15332: PPUSH
15333: CALL_OW 67
// ComStop ( un ) ;
15337: LD_VAR 0 2
15341: PPUSH
15342: CALL_OW 141
// end ;
15346: LD_VAR 0 1
15350: RET
// every 0 0$1 do var i , time , wave ;
15351: GO 15353
15353: DISABLE
15354: LD_INT 0
15356: PPUSH
15357: PPUSH
15358: PPUSH
// begin time := [ 14 14$00 , 12 12$30 , 11 11$00 ] [ Difficulty ] ;
15359: LD_ADDR_VAR 0 2
15363: PUSH
15364: LD_INT 29400
15366: PUSH
15367: LD_INT 26250
15369: PUSH
15370: LD_INT 23100
15372: PUSH
15373: EMPTY
15374: LIST
15375: LIST
15376: LIST
15377: PUSH
15378: LD_OWVAR 67
15382: ARRAY
15383: ST_TO_ADDR
// wait ( time ) ;
15384: LD_VAR 0 2
15388: PPUSH
15389: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
15393: LD_ADDR_VAR 0 2
15397: PUSH
15398: LD_INT 17850
15400: PUSH
15401: LD_INT 16450
15403: PUSH
15404: LD_INT 15750
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: LIST
15411: PUSH
15412: LD_OWVAR 67
15416: ARRAY
15417: ST_TO_ADDR
// wave := 0 ;
15418: LD_ADDR_VAR 0 3
15422: PUSH
15423: LD_INT 0
15425: ST_TO_ADDR
// while true do
15426: LD_INT 1
15428: IFFALSE 15525
// begin wave := wave + 1 ;
15430: LD_ADDR_VAR 0 3
15434: PUSH
15435: LD_VAR 0 3
15439: PUSH
15440: LD_INT 1
15442: PLUS
15443: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15444: LD_INT 22
15446: PUSH
15447: LD_INT 2
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PPUSH
15454: CALL_OW 69
15458: IFFALSE 15487
// repeat wait ( 0 0$1 ) ;
15460: LD_INT 35
15462: PPUSH
15463: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15467: LD_INT 22
15469: PUSH
15470: LD_INT 2
15472: PUSH
15473: EMPTY
15474: LIST
15475: LIST
15476: PPUSH
15477: CALL_OW 69
15481: PUSH
15482: LD_INT 0
15484: EQUAL
15485: IFFALSE 15460
// if ru_force < 20 then
15487: LD_EXP 34
15491: PUSH
15492: LD_INT 20
15494: LESS
15495: IFFALSE 15506
// PrepareAttack ( wave ) ;
15497: LD_VAR 0 3
15501: PPUSH
15502: CALL 14350 0 1
// ru_can_attack := true ;
15506: LD_ADDR_EXP 8
15510: PUSH
15511: LD_INT 1
15513: ST_TO_ADDR
// wait ( time ) ;
15514: LD_VAR 0 2
15518: PPUSH
15519: CALL_OW 67
// end ;
15523: GO 15426
// end ;
15525: PPOPN 3
15527: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15528: LD_EXP 8
15532: PUSH
15533: LD_EXP 34
15537: AND
15538: IFFALSE 16355
15540: GO 15542
15542: DISABLE
15543: LD_INT 0
15545: PPUSH
15546: PPUSH
15547: PPUSH
15548: PPUSH
15549: PPUSH
15550: PPUSH
15551: PPUSH
15552: PPUSH
15553: PPUSH
// begin enable ;
15554: ENABLE
// points1 := [ 107 , 123 ] ;
15555: LD_ADDR_VAR 0 4
15559: PUSH
15560: LD_INT 107
15562: PUSH
15563: LD_INT 123
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15570: LD_ADDR_VAR 0 5
15574: PUSH
15575: LD_INT 55
15577: PUSH
15578: LD_INT 42
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15585: LD_ADDR_VAR 0 6
15589: PUSH
15590: LD_INT 102
15592: PUSH
15593: LD_INT 140
15595: PUSH
15596: EMPTY
15597: LIST
15598: LIST
15599: PUSH
15600: LD_INT 105
15602: PUSH
15603: LD_INT 142
15605: PUSH
15606: EMPTY
15607: LIST
15608: LIST
15609: PUSH
15610: LD_INT 129
15612: PUSH
15613: LD_INT 131
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: LIST
15624: ST_TO_ADDR
// for i in ru_force do
15625: LD_ADDR_VAR 0 1
15629: PUSH
15630: LD_EXP 34
15634: PUSH
15635: FOR_IN
15636: IFFALSE 16353
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15638: LD_ADDR_VAR 0 3
15642: PUSH
15643: LD_INT 81
15645: PUSH
15646: LD_INT 3
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: PPUSH
15653: CALL_OW 69
15657: PPUSH
15658: LD_VAR 0 1
15662: PPUSH
15663: CALL_OW 74
15667: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15668: LD_VAR 0 1
15672: PPUSH
15673: LD_VAR 0 3
15677: PPUSH
15678: CALL_OW 296
15682: PUSH
15683: LD_INT 12
15685: LESS
15686: IFFALSE 15831
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15688: LD_VAR 0 1
15692: PPUSH
15693: CALL_OW 247
15697: PUSH
15698: LD_INT 1
15700: EQUAL
15701: PUSH
15702: LD_VAR 0 1
15706: PPUSH
15707: CALL_OW 257
15711: PUSH
15712: LD_INT 1
15714: EQUAL
15715: AND
15716: PUSH
15717: LD_VAR 0 3
15721: PUSH
15722: LD_INT 21
15724: PUSH
15725: LD_INT 2
15727: PUSH
15728: EMPTY
15729: LIST
15730: LIST
15731: PUSH
15732: LD_INT 58
15734: PUSH
15735: EMPTY
15736: LIST
15737: PUSH
15738: EMPTY
15739: LIST
15740: LIST
15741: PPUSH
15742: CALL_OW 69
15746: IN
15747: AND
15748: IFFALSE 15766
// ComEnterUnit ( i , un ) else
15750: LD_VAR 0 1
15754: PPUSH
15755: LD_VAR 0 3
15759: PPUSH
15760: CALL_OW 120
15764: GO 15829
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15766: LD_VAR 0 3
15770: PUSH
15771: LD_INT 21
15773: PUSH
15774: LD_INT 2
15776: PUSH
15777: EMPTY
15778: LIST
15779: LIST
15780: PUSH
15781: LD_INT 58
15783: PUSH
15784: EMPTY
15785: LIST
15786: PUSH
15787: EMPTY
15788: LIST
15789: LIST
15790: PPUSH
15791: CALL_OW 69
15795: IN
15796: NOT
15797: IFFALSE 15815
// ComAttackUnit ( i , un ) else
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_VAR 0 3
15808: PPUSH
15809: CALL_OW 115
15813: GO 15829
// ComAttackUnit ( i , JMM ) ;
15815: LD_VAR 0 1
15819: PPUSH
15820: LD_EXP 18
15824: PPUSH
15825: CALL_OW 115
// end else
15829: GO 16351
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_VAR 0 4
15840: PUSH
15841: LD_INT 1
15843: ARRAY
15844: PPUSH
15845: LD_VAR 0 4
15849: PUSH
15850: LD_INT 2
15852: ARRAY
15853: PPUSH
15854: CALL_OW 297
15858: PUSH
15859: LD_VAR 0 1
15863: PPUSH
15864: LD_VAR 0 5
15868: PUSH
15869: LD_INT 1
15871: ARRAY
15872: PPUSH
15873: LD_VAR 0 5
15877: PUSH
15878: LD_INT 2
15880: ARRAY
15881: PPUSH
15882: CALL_OW 297
15886: GREATER
15887: PUSH
15888: LD_EXP 9
15892: AND
15893: PUSH
15894: LD_INT 9
15896: PPUSH
15897: LD_INT 81
15899: PUSH
15900: LD_INT 3
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL_OW 70
15911: PUSH
15912: LD_INT 0
15914: EQUAL
15915: OR
15916: IFFALSE 15947
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15918: LD_VAR 0 1
15922: PPUSH
15923: LD_VAR 0 5
15927: PUSH
15928: LD_INT 1
15930: ARRAY
15931: PPUSH
15932: LD_VAR 0 5
15936: PUSH
15937: LD_INT 2
15939: ARRAY
15940: PPUSH
15941: CALL_OW 114
15945: GO 16351
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 4 then
15947: LD_VAR 0 1
15951: PPUSH
15952: CALL_OW 264
15956: PUSH
15957: LD_INT 45
15959: EQUAL
15960: PUSH
15961: LD_EXP 34
15965: PPUSH
15966: LD_INT 3
15968: PUSH
15969: LD_INT 34
15971: PUSH
15972: LD_INT 45
15974: PUSH
15975: EMPTY
15976: LIST
15977: LIST
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: PPUSH
15983: CALL_OW 72
15987: PUSH
15988: LD_INT 4
15990: GREATER
15991: AND
15992: IFFALSE 16173
// begin dist := 9999 ;
15994: LD_ADDR_VAR 0 8
15998: PUSH
15999: LD_INT 9999
16001: ST_TO_ADDR
// xy := 0 ;
16002: LD_ADDR_VAR 0 9
16006: PUSH
16007: LD_INT 0
16009: ST_TO_ADDR
// for x in pointsr do
16010: LD_ADDR_VAR 0 7
16014: PUSH
16015: LD_VAR 0 6
16019: PUSH
16020: FOR_IN
16021: IFFALSE 16169
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 7
16032: PUSH
16033: LD_INT 1
16035: ARRAY
16036: PPUSH
16037: LD_VAR 0 7
16041: PUSH
16042: LD_INT 2
16044: ARRAY
16045: PPUSH
16046: CALL_OW 297
16050: PUSH
16051: LD_VAR 0 8
16055: LESS
16056: IFFALSE 16101
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16058: LD_ADDR_VAR 0 8
16062: PUSH
16063: LD_VAR 0 1
16067: PPUSH
16068: LD_VAR 0 7
16072: PUSH
16073: LD_INT 1
16075: ARRAY
16076: PPUSH
16077: LD_VAR 0 7
16081: PUSH
16082: LD_INT 2
16084: ARRAY
16085: PPUSH
16086: CALL_OW 297
16090: ST_TO_ADDR
// xy := x ;
16091: LD_ADDR_VAR 0 9
16095: PUSH
16096: LD_VAR 0 7
16100: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16101: LD_VAR 0 9
16105: PUSH
16106: LD_VAR 0 1
16110: PPUSH
16111: LD_VAR 0 9
16115: PUSH
16116: LD_INT 1
16118: ARRAY
16119: PPUSH
16120: LD_VAR 0 9
16124: PUSH
16125: LD_INT 2
16127: ARRAY
16128: PPUSH
16129: CALL_OW 297
16133: PUSH
16134: LD_INT 9
16136: GREATER
16137: AND
16138: IFFALSE 16167
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16140: LD_VAR 0 1
16144: PPUSH
16145: LD_VAR 0 9
16149: PUSH
16150: LD_INT 1
16152: ARRAY
16153: PPUSH
16154: LD_VAR 0 9
16158: PUSH
16159: LD_INT 2
16161: ARRAY
16162: PPUSH
16163: CALL_OW 114
// end ;
16167: GO 16020
16169: POP
16170: POP
// end else
16171: GO 16351
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16173: LD_ADDR_VAR 0 3
16177: PUSH
16178: LD_OWVAR 3
16182: PUSH
16183: LD_VAR 0 1
16187: DIFF
16188: PPUSH
16189: LD_VAR 0 1
16193: PPUSH
16194: CALL_OW 74
16198: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16199: LD_VAR 0 1
16203: PPUSH
16204: CALL_OW 320
16208: NOT
16209: PUSH
16210: LD_VAR 0 3
16214: PUSH
16215: LD_INT 21
16217: PUSH
16218: LD_INT 2
16220: PUSH
16221: EMPTY
16222: LIST
16223: LIST
16224: PUSH
16225: LD_INT 33
16227: PUSH
16228: LD_INT 1
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PUSH
16235: LD_INT 58
16237: PUSH
16238: EMPTY
16239: LIST
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: LIST
16245: PPUSH
16246: CALL_OW 69
16250: IN
16251: PUSH
16252: LD_VAR 0 3
16256: PUSH
16257: LD_INT 22
16259: PUSH
16260: LD_INT 3
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: PUSH
16267: LD_INT 21
16269: PUSH
16270: LD_INT 2
16272: PUSH
16273: EMPTY
16274: LIST
16275: LIST
16276: PUSH
16277: LD_INT 3
16279: PUSH
16280: LD_INT 24
16282: PUSH
16283: LD_INT 249
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: LIST
16298: PPUSH
16299: CALL_OW 69
16303: IN
16304: OR
16305: AND
16306: IFFALSE 16324
// ComAttackUnit ( i , un ) else
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_VAR 0 3
16317: PPUSH
16318: CALL_OW 115
16322: GO 16351
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_VAR 0 4
16333: PUSH
16334: LD_INT 1
16336: ARRAY
16337: PPUSH
16338: LD_VAR 0 4
16342: PUSH
16343: LD_INT 2
16345: ARRAY
16346: PPUSH
16347: CALL_OW 114
// end ; end ; end ; end ;
16351: GO 15635
16353: POP
16354: POP
// end ;
16355: PPOPN 9
16357: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16358: LD_INT 22
16360: PUSH
16361: LD_INT 3
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 32
16370: PUSH
16371: LD_INT 1
16373: PUSH
16374: EMPTY
16375: LIST
16376: LIST
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PPUSH
16382: CALL_OW 69
16386: IFFALSE 16474
16388: GO 16390
16390: DISABLE
16391: LD_INT 0
16393: PPUSH
16394: PPUSH
// begin enable ;
16395: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16396: LD_ADDR_VAR 0 2
16400: PUSH
16401: LD_INT 22
16403: PUSH
16404: LD_INT 3
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 32
16413: PUSH
16414: LD_INT 1
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PPUSH
16425: CALL_OW 69
16429: ST_TO_ADDR
// for i in tmp do
16430: LD_ADDR_VAR 0 1
16434: PUSH
16435: LD_VAR 0 2
16439: PUSH
16440: FOR_IN
16441: IFFALSE 16472
// if GetFuel ( i ) < 12 then
16443: LD_VAR 0 1
16447: PPUSH
16448: CALL_OW 261
16452: PUSH
16453: LD_INT 12
16455: LESS
16456: IFFALSE 16470
// SetFuel ( i , 12 ) ;
16458: LD_VAR 0 1
16462: PPUSH
16463: LD_INT 12
16465: PPUSH
16466: CALL_OW 240
16470: GO 16440
16472: POP
16473: POP
// end ;
16474: PPOPN 2
16476: END
// every 0 0$1 trigger can_end do
16477: LD_EXP 17
16481: IFFALSE 16500
16483: GO 16485
16485: DISABLE
// begin Wait ( 1 1$35 ) ;
16486: LD_INT 3325
16488: PPUSH
16489: CALL_OW 67
// PrepareAttack ( 10 ) ;
16493: LD_INT 10
16495: PPUSH
16496: CALL 14350 0 1
// end ;
16500: END
