// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12622 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1708 0 0
// Action ;
  32: CALL 2583 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1676
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1676: LD_ADDR_EXP 25
1680: PUSH
1681: LD_STRING Powell
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_STRING 
1689: PPUSH
1690: CALL 201 0 3
1694: ST_TO_ADDR
// InitHc ;
1695: CALL_OW 19
// InitUc ;
1699: CALL_OW 18
// end ;
1703: LD_VAR 0 1
1707: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1708: LD_INT 0
1710: PPUSH
1711: PPUSH
1712: PPUSH
1713: PPUSH
1714: PPUSH
// uc_side := 4 ;
1715: LD_ADDR_OWVAR 20
1719: PUSH
1720: LD_INT 4
1722: ST_TO_ADDR
// uc_nation := 3 ;
1723: LD_ADDR_OWVAR 21
1727: PUSH
1728: LD_INT 3
1730: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_STRING 09_ovsyenko_base
1738: PPUSH
1739: LD_INT 0
1741: PUSH
1742: LD_INT 101
1744: PUSH
1745: LD_INT 118
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 500
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: LD_INT 31
1763: PUSH
1764: LD_INT 109
1766: PUSH
1767: LD_INT 114
1769: PUSH
1770: LD_INT 4
1772: PUSH
1773: LD_INT 500
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 115
1788: PUSH
1789: LD_INT 132
1791: PUSH
1792: LD_INT 5
1794: PUSH
1795: LD_INT 500
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 31
1807: PUSH
1808: LD_INT 98
1810: PUSH
1811: LD_INT 120
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 500
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL_OW 30
1837: ST_TO_ADDR
// for i in tmp do
1838: LD_ADDR_VAR 0 2
1842: PUSH
1843: LD_VAR 0 4
1847: PUSH
1848: FOR_IN
1849: IFFALSE 2005
// begin bc_type := i [ 1 ] ;
1851: LD_ADDR_OWVAR 42
1855: PUSH
1856: LD_VAR 0 2
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: ST_TO_ADDR
// bc_level := 3 ;
1865: LD_ADDR_OWVAR 43
1869: PUSH
1870: LD_INT 3
1872: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_VAR 0 2
1882: PUSH
1883: LD_INT 2
1885: ARRAY
1886: PPUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_INT 3
1894: ARRAY
1895: PPUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 4
1903: ARRAY
1904: PPUSH
1905: CALL_OW 47
1909: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 266
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: IFFALSE 1957
// begin SetBName ( b , ovsyenko ) ;
1925: LD_VAR 0 3
1929: PPUSH
1930: LD_STRING ovsyenko
1932: PPUSH
1933: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: CALL_OW 274
1946: PPUSH
1947: LD_INT 1
1949: PPUSH
1950: LD_INT 50
1952: PPUSH
1953: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 5
1964: ARRAY
1965: PUSH
1966: LD_INT 250
1968: LESS
1969: IFFALSE 1985
// SetLives ( b , 333 ) else
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_INT 333
1978: PPUSH
1979: CALL_OW 234
1983: GO 2003
// SetLives ( b , i [ 5 ] ) ;
1985: LD_VAR 0 3
1989: PPUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 5
1997: ARRAY
1998: PPUSH
1999: CALL_OW 234
// end ;
2003: GO 1848
2005: POP
2006: POP
// uc_nation := 1 ;
2007: LD_ADDR_OWVAR 21
2011: PUSH
2012: LD_INT 1
2014: ST_TO_ADDR
// tmp := [ ] ;
2015: LD_ADDR_VAR 0 4
2019: PUSH
2020: EMPTY
2021: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2022: LD_ADDR_EXP 19
2026: PUSH
2027: LD_STRING Gary
2029: PPUSH
2030: LD_EXP 2
2034: NOT
2035: PPUSH
2036: LD_STRING 
2038: PPUSH
2039: CALL 201 0 3
2043: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2044: LD_ADDR_VAR 0 4
2048: PUSH
2049: LD_VAR 0 4
2053: PUSH
2054: LD_EXP 19
2058: ADD
2059: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2060: LD_ADDR_EXP 20
2064: PUSH
2065: LD_STRING Bobby
2067: PPUSH
2068: LD_EXP 2
2072: NOT
2073: PPUSH
2074: LD_STRING 03_
2076: PPUSH
2077: CALL 201 0 3
2081: ST_TO_ADDR
// if Bobby then
2082: LD_EXP 20
2086: IFFALSE 2104
// tmp := tmp ^ Bobby ;
2088: LD_ADDR_VAR 0 4
2092: PUSH
2093: LD_VAR 0 4
2097: PUSH
2098: LD_EXP 20
2102: ADD
2103: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2104: LD_ADDR_EXP 21
2108: PUSH
2109: LD_STRING Cyrus
2111: PPUSH
2112: LD_EXP 2
2116: NOT
2117: PPUSH
2118: LD_STRING 03_
2120: PPUSH
2121: CALL 201 0 3
2125: ST_TO_ADDR
// if Cyrus then
2126: LD_EXP 21
2130: IFFALSE 2148
// tmp := tmp ^ Cyrus ;
2132: LD_ADDR_VAR 0 4
2136: PUSH
2137: LD_VAR 0 4
2141: PUSH
2142: LD_EXP 21
2146: ADD
2147: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2148: LD_ADDR_VAR 0 4
2152: PUSH
2153: LD_VAR 0 4
2157: PUSH
2158: LD_STRING 09_prev_squad
2160: PPUSH
2161: CALL_OW 31
2165: ADD
2166: ST_TO_ADDR
// tmp := tmp diff 0 ;
2167: LD_ADDR_VAR 0 4
2171: PUSH
2172: LD_VAR 0 4
2176: PUSH
2177: LD_INT 0
2179: DIFF
2180: ST_TO_ADDR
// if debug then
2181: LD_EXP 2
2185: IFFALSE 2236
// begin for i = 1 to 6 do
2187: LD_ADDR_VAR 0 2
2191: PUSH
2192: DOUBLE
2193: LD_INT 1
2195: DEC
2196: ST_TO_ADDR
2197: LD_INT 6
2199: PUSH
2200: FOR_TO
2201: IFFALSE 2234
// begin PrepareHuman ( false , 1 , 6 ) ;
2203: LD_INT 0
2205: PPUSH
2206: LD_INT 1
2208: PPUSH
2209: LD_INT 6
2211: PPUSH
2212: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2216: LD_ADDR_VAR 0 4
2220: PUSH
2221: LD_VAR 0 4
2225: PUSH
2226: CALL_OW 44
2230: ADD
2231: ST_TO_ADDR
// end ;
2232: GO 2200
2234: POP
2235: POP
// end ; for i in tmp do
2236: LD_ADDR_VAR 0 2
2240: PUSH
2241: LD_VAR 0 4
2245: PUSH
2246: FOR_IN
2247: IFFALSE 2306
// begin if GetClass ( i ) in [ 2 , 3 ] then
2249: LD_VAR 0 2
2253: PPUSH
2254: CALL_OW 257
2258: PUSH
2259: LD_INT 2
2261: PUSH
2262: LD_INT 3
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: IN
2269: IFFALSE 2283
// SetClass ( i , 1 ) ;
2271: LD_VAR 0 2
2275: PPUSH
2276: LD_INT 1
2278: PPUSH
2279: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2283: LD_VAR 0 2
2287: PPUSH
2288: LD_INT 106
2290: PPUSH
2291: LD_INT 122
2293: PPUSH
2294: LD_INT 5
2296: PPUSH
2297: LD_INT 0
2299: PPUSH
2300: CALL_OW 50
// end ;
2304: GO 2246
2306: POP
2307: POP
// tmp := tmp diff Gary ;
2308: LD_ADDR_VAR 0 4
2312: PUSH
2313: LD_VAR 0 4
2317: PUSH
2318: LD_EXP 19
2322: DIFF
2323: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2324: LD_ADDR_VAR 0 3
2328: PUSH
2329: LD_INT 22
2331: PUSH
2332: LD_INT 4
2334: PUSH
2335: EMPTY
2336: LIST
2337: LIST
2338: PUSH
2339: LD_INT 30
2341: PUSH
2342: LD_INT 31
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PPUSH
2353: CALL_OW 69
2357: ST_TO_ADDR
// for i = 1 to b do
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: DOUBLE
2364: LD_INT 1
2366: DEC
2367: ST_TO_ADDR
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_TO
2374: IFFALSE 2404
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2376: LD_VAR 0 4
2380: PUSH
2381: LD_VAR 0 2
2385: ARRAY
2386: PPUSH
2387: LD_VAR 0 3
2391: PUSH
2392: LD_VAR 0 2
2396: ARRAY
2397: PPUSH
2398: CALL_OW 120
// end ;
2402: GO 2373
2404: POP
2405: POP
// InitHc ;
2406: CALL_OW 19
// InitUc ;
2410: CALL_OW 18
// end ;
2414: LD_VAR 0 1
2418: RET
// export function PowellTransport ; var i , un ; begin
2419: LD_INT 0
2421: PPUSH
2422: PPUSH
2423: PPUSH
// uc_side := 4 ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_INT 4
2431: ST_TO_ADDR
// uc_nation := 1 ;
2432: LD_ADDR_OWVAR 21
2436: PUSH
2437: LD_INT 1
2439: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2440: LD_INT 1
2442: PPUSH
2443: LD_INT 3
2445: PPUSH
2446: LD_INT 6
2448: PPUSH
2449: CALL_OW 380
// hc_name :=  ;
2453: LD_ADDR_OWVAR 26
2457: PUSH
2458: LD_STRING 
2460: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2461: LD_ADDR_OWVAR 33
2465: PUSH
2466: LD_STRING SecondCharsGal
2468: ST_TO_ADDR
// hc_face_number := 30 ;
2469: LD_ADDR_OWVAR 34
2473: PUSH
2474: LD_INT 30
2476: ST_TO_ADDR
// powell_trans := CreateHuman ;
2477: LD_ADDR_EXP 24
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// hc_face_number := 31 ;
2487: LD_ADDR_OWVAR 34
2491: PUSH
2492: LD_INT 31
2494: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2495: LD_ADDR_EXP 24
2499: PUSH
2500: LD_EXP 24
2504: PUSH
2505: CALL_OW 44
2509: ADD
2510: ST_TO_ADDR
// for i = 1 to 2 do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: DOUBLE
2517: LD_INT 1
2519: DEC
2520: ST_TO_ADDR
2521: LD_INT 2
2523: PUSH
2524: FOR_TO
2525: IFFALSE 2576
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2527: LD_ADDR_VAR 0 3
2531: PUSH
2532: LD_INT 4
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: LD_INT 3
2540: PPUSH
2541: LD_INT 1
2543: PPUSH
2544: LD_INT 1
2546: PPUSH
2547: LD_INT 12
2549: PPUSH
2550: LD_INT 66
2552: PPUSH
2553: CALL 264 0 7
2557: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2558: LD_ADDR_EXP 24
2562: PUSH
2563: LD_EXP 24
2567: PUSH
2568: LD_VAR 0 3
2572: ADD
2573: ST_TO_ADDR
// end ;
2574: GO 2524
2576: POP
2577: POP
// end ; end_of_file
2578: LD_VAR 0 1
2582: RET
// export function Action ; var i , veh ; begin
2583: LD_INT 0
2585: PPUSH
2586: PPUSH
2587: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2588: LD_EXP 23
2592: PPUSH
2593: LD_INT 0
2595: PPUSH
2596: LD_INT 50
2598: PPUSH
2599: LD_INT 38
2601: PPUSH
2602: LD_INT 2
2604: PPUSH
2605: CALL_OW 145
// InGameOn ;
2609: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2613: LD_INT 43
2615: PPUSH
2616: LD_INT 9
2618: PPUSH
2619: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2623: LD_EXP 18
2627: PPUSH
2628: LD_INT 54
2630: PPUSH
2631: LD_INT 34
2633: PPUSH
2634: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2638: LD_EXP 18
2642: PPUSH
2643: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2647: LD_EXP 18
2651: PPUSH
2652: LD_EXP 23
2656: PUSH
2657: LD_INT 1
2659: ARRAY
2660: PPUSH
2661: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2665: LD_INT 35
2667: PPUSH
2668: CALL_OW 67
// until See ( 4 , JMM ) ;
2672: LD_INT 4
2674: PPUSH
2675: LD_EXP 18
2679: PPUSH
2680: CALL_OW 292
2684: IFFALSE 2665
// CenterNowOnUnits ( JMM ) ;
2686: LD_EXP 18
2690: PPUSH
2691: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2695: LD_EXP 18
2699: PPUSH
2700: LD_STRING D2-JMM-1
2702: PPUSH
2703: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2707: LD_EXP 23
2711: PUSH
2712: LD_INT 3
2714: ARRAY
2715: PPUSH
2716: LD_EXP 18
2720: PPUSH
2721: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2725: LD_EXP 23
2729: PUSH
2730: LD_INT 3
2732: ARRAY
2733: PPUSH
2734: LD_STRING D2-Eng1-1
2736: PPUSH
2737: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2741: LD_EXP 18
2745: PPUSH
2746: LD_STRING D2-JMM-2
2748: PPUSH
2749: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2753: LD_EXP 23
2757: PUSH
2758: LD_INT 3
2760: ARRAY
2761: PPUSH
2762: LD_STRING D2-Eng1-2
2764: PPUSH
2765: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2769: LD_EXP 18
2773: PPUSH
2774: LD_STRING D2-JMM-3
2776: PPUSH
2777: CALL_OW 88
// if Houten then
2781: LD_EXP 22
2785: IFFALSE 2983
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2787: LD_ADDR_VAR 0 3
2791: PUSH
2792: LD_INT 4
2794: PPUSH
2795: LD_INT 1
2797: PPUSH
2798: LD_INT 3
2800: PPUSH
2801: LD_INT 2
2803: PPUSH
2804: LD_INT 1
2806: PPUSH
2807: LD_INT 4
2809: PPUSH
2810: LD_INT 55
2812: PPUSH
2813: CALL 264 0 7
2817: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2818: LD_VAR 0 3
2822: PPUSH
2823: LD_INT 3
2825: PPUSH
2826: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2830: LD_VAR 0 3
2834: PPUSH
2835: LD_INT 46
2837: PPUSH
2838: LD_INT 19
2840: PPUSH
2841: LD_INT 0
2843: PPUSH
2844: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2848: LD_EXP 22
2852: PPUSH
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2862: LD_EXP 22
2866: PPUSH
2867: LD_INT 49
2869: PPUSH
2870: LD_INT 33
2872: PPUSH
2873: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2877: LD_EXP 22
2881: PPUSH
2882: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2886: LD_EXP 22
2890: PPUSH
2891: LD_EXP 18
2895: PPUSH
2896: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2900: LD_INT 35
2902: PPUSH
2903: CALL_OW 67
// until See ( 1 , Houten ) ;
2907: LD_INT 1
2909: PPUSH
2910: LD_EXP 22
2914: PPUSH
2915: CALL_OW 292
2919: IFFALSE 2900
// ComTurnUnit ( JMM , Houten ) ;
2921: LD_EXP 18
2925: PPUSH
2926: LD_EXP 22
2930: PPUSH
2931: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2935: LD_EXP 18
2939: PPUSH
2940: LD_STRING D1d-JMM-1
2942: PPUSH
2943: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2947: LD_EXP 22
2951: PPUSH
2952: LD_STRING D1-VanH-1
2954: PPUSH
2955: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2959: LD_EXP 18
2963: PPUSH
2964: LD_STRING D1-JMM-1v
2966: PPUSH
2967: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2971: LD_EXP 18
2975: PPUSH
2976: LD_STRING D1-JMM-2v
2978: PPUSH
2979: CALL_OW 88
// end ; InGameOff ;
2983: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2987: LD_STRING M1
2989: PPUSH
2990: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2994: LD_INT 22
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: PUSH
3004: LD_INT 92
3006: PUSH
3007: LD_EXP 18
3011: PPUSH
3012: CALL_OW 250
3016: PUSH
3017: LD_EXP 18
3021: PPUSH
3022: CALL_OW 251
3026: PUSH
3027: LD_INT 15
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: PPUSH
3040: CALL_OW 69
3044: PPUSH
3045: LD_INT 1
3047: PPUSH
3048: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3052: LD_EXP 23
3056: PUSH
3057: LD_EXP 18
3061: ADD
3062: PUSH
3063: LD_EXP 22
3067: ADD
3068: PPUSH
3069: CALL_OW 141
// end ;
3073: LD_VAR 0 1
3077: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3078: LD_INT 1
3080: PPUSH
3081: LD_EXP 19
3085: PPUSH
3086: CALL_OW 292
3090: PUSH
3091: LD_EXP 18
3095: PPUSH
3096: LD_EXP 19
3100: PPUSH
3101: CALL_OW 296
3105: PUSH
3106: LD_INT 6
3108: LESS
3109: AND
3110: IFFALSE 3873
3112: GO 3114
3114: DISABLE
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
// begin InGameOn ;
3122: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3126: LD_INT 22
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PPUSH
3136: CALL_OW 69
3140: PPUSH
3141: LD_INT 1
3143: PPUSH
3144: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3148: LD_ADDR_VAR 0 4
3152: PUSH
3153: LD_INT 22
3155: PUSH
3156: LD_INT 1
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 2
3165: PUSH
3166: LD_INT 25
3168: PUSH
3169: LD_INT 1
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PUSH
3176: LD_INT 25
3178: PUSH
3179: LD_INT 2
3181: PUSH
3182: EMPTY
3183: LIST
3184: LIST
3185: PUSH
3186: LD_INT 25
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: PUSH
3196: LD_INT 25
3198: PUSH
3199: LD_INT 4
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PPUSH
3217: CALL_OW 69
3221: ST_TO_ADDR
// ComHold ( tmp ) ;
3222: LD_VAR 0 4
3226: PPUSH
3227: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3231: LD_EXP 18
3235: PPUSH
3236: LD_STRING D2-JMM-3a
3238: PPUSH
3239: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3243: LD_EXP 19
3247: PPUSH
3248: LD_EXP 18
3252: PPUSH
3253: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3257: LD_EXP 19
3261: PPUSH
3262: LD_STRING D2-Gary-3
3264: PPUSH
3265: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3269: LD_EXP 18
3273: PPUSH
3274: LD_EXP 19
3278: PPUSH
3279: CALL_OW 119
// for i in tmp do
3283: LD_ADDR_VAR 0 5
3287: PUSH
3288: LD_VAR 0 4
3292: PUSH
3293: FOR_IN
3294: IFFALSE 3339
// begin if IsInUnit ( i ) then
3296: LD_VAR 0 5
3300: PPUSH
3301: CALL_OW 310
3305: IFFALSE 3316
// ComExitBuilding ( i ) ;
3307: LD_VAR 0 5
3311: PPUSH
3312: CALL_OW 122
// wait ( 1 ) ;
3316: LD_INT 1
3318: PPUSH
3319: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3323: LD_VAR 0 5
3327: PPUSH
3328: LD_EXP 18
3332: PPUSH
3333: CALL_OW 119
// end ;
3337: GO 3293
3339: POP
3340: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3341: LD_ADDR_VAR 0 4
3345: PUSH
3346: LD_VAR 0 4
3350: PUSH
3351: LD_EXP 18
3355: PUSH
3356: LD_EXP 22
3360: PUSH
3361: LD_EXP 19
3365: PUSH
3366: LD_EXP 21
3370: PUSH
3371: LD_EXP 20
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_EXP 23
3387: ADD
3388: DIFF
3389: ST_TO_ADDR
// if Bobby then
3390: LD_EXP 20
3394: IFFALSE 3408
// Say ( Bobby , D2-Bobby-3 ) ;
3396: LD_EXP 20
3400: PPUSH
3401: LD_STRING D2-Bobby-3
3403: PPUSH
3404: CALL_OW 88
// if Cyrus then
3408: LD_EXP 21
3412: IFFALSE 3426
// Say ( Cyrus , D2-Cyrus-3 ) ;
3414: LD_EXP 21
3418: PPUSH
3419: LD_STRING D2-Cyrus-3
3421: PPUSH
3422: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3426: LD_EXP 18
3430: PPUSH
3431: LD_STRING D2-JMM-4
3433: PPUSH
3434: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3438: LD_EXP 19
3442: PPUSH
3443: LD_STRING D2-Gary-4
3445: PPUSH
3446: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3450: LD_ADDR_VAR 0 1
3454: PUSH
3455: LD_VAR 0 4
3459: PPUSH
3460: LD_INT 26
3462: PUSH
3463: LD_INT 1
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: PPUSH
3470: CALL_OW 72
3474: PUSH
3475: LD_INT 1
3477: ARRAY
3478: ST_TO_ADDR
// if Cyrus then
3479: LD_EXP 21
3483: IFFALSE 3499
// Say ( Cyrus , D2-Cyrus-4 ) else
3485: LD_EXP 21
3489: PPUSH
3490: LD_STRING D2-Cyrus-4
3492: PPUSH
3493: CALL_OW 88
3497: GO 3511
// Say ( un1 , D2-Sol1-4 ) ;
3499: LD_VAR 0 1
3503: PPUSH
3504: LD_STRING D2-Sol1-4
3506: PPUSH
3507: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3511: LD_EXP 18
3515: PPUSH
3516: LD_STRING D2-JMM-5
3518: PPUSH
3519: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3523: LD_ADDR_VAR 0 2
3527: PUSH
3528: LD_EXP 23
3532: PPUSH
3533: LD_INT 91
3535: PUSH
3536: LD_EXP 18
3540: PUSH
3541: LD_INT 10
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: PUSH
3549: LD_INT 26
3551: PUSH
3552: LD_INT 2
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: PPUSH
3563: CALL_OW 72
3567: ST_TO_ADDR
// if un2 then
3568: LD_VAR 0 2
3572: IFFALSE 3626
// begin un2 := un2 [ un2 ] ;
3574: LD_ADDR_VAR 0 2
3578: PUSH
3579: LD_VAR 0 2
3583: PUSH
3584: LD_VAR 0 2
3588: ARRAY
3589: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3590: LD_VAR 0 2
3594: PPUSH
3595: LD_STRING D2-FEng1-5
3597: PPUSH
3598: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3602: LD_EXP 18
3606: PPUSH
3607: LD_STRING D2-JMM-6
3609: PPUSH
3610: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3614: LD_VAR 0 2
3618: PPUSH
3619: LD_STRING D2-FEng1-6
3621: PPUSH
3622: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3626: LD_ADDR_VAR 0 3
3630: PUSH
3631: LD_EXP 23
3635: PPUSH
3636: LD_INT 91
3638: PUSH
3639: LD_EXP 18
3643: PUSH
3644: LD_INT 10
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: PUSH
3652: LD_INT 26
3654: PUSH
3655: LD_INT 1
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PPUSH
3666: CALL_OW 72
3670: ST_TO_ADDR
// if un3 then
3671: LD_VAR 0 3
3675: IFFALSE 3730
// begin un3 := un3 [ 1 ] ;
3677: LD_ADDR_VAR 0 3
3681: PUSH
3682: LD_VAR 0 3
3686: PUSH
3687: LD_INT 1
3689: ARRAY
3690: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3691: LD_VAR 0 3
3695: PPUSH
3696: LD_INT 114
3698: PPUSH
3699: LD_INT 122
3701: PPUSH
3702: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3706: LD_VAR 0 3
3710: PPUSH
3711: LD_STRING D2-Eng1-6
3713: PPUSH
3714: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3718: LD_EXP 18
3722: PPUSH
3723: LD_STRING D2-JMM-7
3725: PPUSH
3726: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3730: LD_EXP 19
3734: PPUSH
3735: LD_STRING D2-Gary-7
3737: PPUSH
3738: CALL_OW 88
// if un2 then
3742: LD_VAR 0 2
3746: IFFALSE 3760
// Say ( un2 , D2-FEng1-7 ) ;
3748: LD_VAR 0 2
3752: PPUSH
3753: LD_STRING D2-FEng1-7
3755: PPUSH
3756: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3760: LD_VAR 0 1
3764: PPUSH
3765: LD_STRING D2-Sol1-7
3767: PPUSH
3768: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3772: LD_EXP 18
3776: PPUSH
3777: LD_STRING D2-JMM-8
3779: PPUSH
3780: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3784: LD_INT 22
3786: PUSH
3787: LD_INT 1
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PPUSH
3799: CALL_OW 141
// InGameOff ;
3803: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3807: LD_STRING M1a
3809: PPUSH
3810: CALL_OW 337
// jmm_in_ovsyenko := true ;
3814: LD_ADDR_EXP 4
3818: PUSH
3819: LD_INT 1
3821: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3822: LD_INT 1050
3824: PPUSH
3825: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3829: LD_ADDR_VAR 0 4
3833: PUSH
3834: LD_INT 25
3836: PUSH
3837: LD_INT 14
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PPUSH
3844: CALL_OW 69
3848: ST_TO_ADDR
// if not tmp then
3849: LD_VAR 0 4
3853: NOT
3854: IFFALSE 3858
// exit ;
3856: GO 3873
// ComMoveXY ( tmp , 75 , 75 ) ;
3858: LD_VAR 0 4
3862: PPUSH
3863: LD_INT 75
3865: PPUSH
3866: LD_INT 75
3868: PPUSH
3869: CALL_OW 111
// end ;
3873: PPOPN 5
3875: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3876: LD_INT 22
3878: PUSH
3879: LD_INT 1
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: LD_INT 30
3888: PUSH
3889: LD_INT 30
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: PUSH
3896: LD_INT 3
3898: PUSH
3899: LD_INT 57
3901: PUSH
3902: EMPTY
3903: LIST
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: LIST
3913: PPUSH
3914: CALL_OW 69
3918: IFFALSE 3960
3920: GO 3922
3922: DISABLE
3923: LD_INT 0
3925: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3926: LD_ADDR_VAR 0 1
3930: PUSH
3931: LD_STRING M2easy
3933: PUSH
3934: LD_STRING M2
3936: PUSH
3937: LD_STRING M2hard
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: LIST
3944: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3945: LD_VAR 0 1
3949: PUSH
3950: LD_OWVAR 67
3954: ARRAY
3955: PPUSH
3956: CALL_OW 337
// end ;
3960: PPOPN 1
3962: END
// every 3 3$00 do
3963: GO 3965
3965: DISABLE
// begin DialogueOn ;
3966: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3970: LD_EXP 25
3974: PPUSH
3975: LD_STRING D3-Pow-1
3977: PPUSH
3978: CALL_OW 94
// if jmm_in_ovsyenko then
3982: LD_EXP 4
3986: IFFALSE 4014
// begin Say ( JMM , D3-JMM-1 ) ;
3988: LD_EXP 18
3992: PPUSH
3993: LD_STRING D3-JMM-1
3995: PPUSH
3996: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4000: LD_EXP 18
4004: PPUSH
4005: LD_STRING D3-JMM-1b
4007: PPUSH
4008: CALL_OW 88
// end else
4012: GO 4026
// Say ( JMM , D3-JMM-1a ) ;
4014: LD_EXP 18
4018: PPUSH
4019: LD_STRING D3-JMM-1a
4021: PPUSH
4022: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4026: LD_EXP 25
4030: PPUSH
4031: LD_STRING D3-Pow-2
4033: PPUSH
4034: CALL_OW 94
// DialogueOff ;
4038: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4042: LD_STRING M3
4044: PPUSH
4045: CALL_OW 337
// powell_want_sib := true ;
4049: LD_ADDR_EXP 5
4053: PUSH
4054: LD_INT 1
4056: ST_TO_ADDR
// end ;
4057: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4058: LD_EXP 6
4062: PUSH
4063: LD_INT 0
4065: EQUAL
4066: IFFALSE 5513
4068: GO 4070
4070: DISABLE
4071: LD_INT 0
4073: PPUSH
4074: PPUSH
4075: PPUSH
4076: PPUSH
4077: PPUSH
4078: PPUSH
4079: PPUSH
4080: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4081: LD_INT 4
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: CALL_OW 343
// PowellTransport ;
4091: CALL 2419 0 0
// for i = 1 to 3 do
4095: LD_ADDR_VAR 0 4
4099: PUSH
4100: DOUBLE
4101: LD_INT 1
4103: DEC
4104: ST_TO_ADDR
4105: LD_INT 3
4107: PUSH
4108: FOR_TO
4109: IFFALSE 4176
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4111: LD_ADDR_VAR 0 1
4115: PUSH
4116: LD_INT 6
4118: PPUSH
4119: LD_VAR 0 4
4123: PPUSH
4124: CALL_OW 287
4128: ST_TO_ADDR
// if not tmp then
4129: LD_VAR 0 1
4133: NOT
4134: IFFALSE 4138
// continue ;
4136: GO 4108
// EraseResourceArea ( terminalArea , i ) ;
4138: LD_INT 6
4140: PPUSH
4141: LD_VAR 0 4
4145: PPUSH
4146: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4150: LD_EXP 3
4154: PPUSH
4155: CALL_OW 274
4159: PPUSH
4160: LD_VAR 0 4
4164: PPUSH
4165: LD_VAR 0 1
4169: PPUSH
4170: CALL_OW 276
// end ;
4174: GO 4108
4176: POP
4177: POP
// x := 43 ;
4178: LD_ADDR_VAR 0 2
4182: PUSH
4183: LD_INT 43
4185: ST_TO_ADDR
// y := 3 ;
4186: LD_ADDR_VAR 0 3
4190: PUSH
4191: LD_INT 3
4193: ST_TO_ADDR
// for i = 3 to 4 do
4194: LD_ADDR_VAR 0 4
4198: PUSH
4199: DOUBLE
4200: LD_INT 3
4202: DEC
4203: ST_TO_ADDR
4204: LD_INT 4
4206: PUSH
4207: FOR_TO
4208: IFFALSE 4399
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4210: LD_EXP 24
4214: PUSH
4215: LD_VAR 0 4
4219: ARRAY
4220: PPUSH
4221: LD_INT 4
4223: PPUSH
4224: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4228: LD_EXP 24
4232: PUSH
4233: LD_VAR 0 4
4237: ARRAY
4238: PPUSH
4239: LD_VAR 0 2
4243: PPUSH
4244: LD_VAR 0 3
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4256: LD_EXP 24
4260: PUSH
4261: LD_VAR 0 4
4265: PUSH
4266: LD_INT 2
4268: MINUS
4269: ARRAY
4270: PPUSH
4271: LD_EXP 24
4275: PUSH
4276: LD_VAR 0 4
4280: ARRAY
4281: PPUSH
4282: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4286: LD_EXP 24
4290: PUSH
4291: LD_VAR 0 4
4295: ARRAY
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 100
4302: PPUSH
4303: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4307: LD_EXP 24
4311: PUSH
4312: LD_VAR 0 4
4316: PUSH
4317: LD_INT 2
4319: MINUS
4320: ARRAY
4321: PPUSH
4322: LD_INT 54
4324: PPUSH
4325: LD_INT 42
4327: PPUSH
4328: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4332: LD_EXP 24
4336: PUSH
4337: LD_VAR 0 4
4341: PUSH
4342: LD_INT 2
4344: MINUS
4345: ARRAY
4346: PPUSH
4347: LD_EXP 3
4351: PPUSH
4352: CALL_OW 250
4356: PPUSH
4357: LD_EXP 3
4361: PPUSH
4362: CALL_OW 251
4366: PPUSH
4367: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4371: LD_EXP 24
4375: PUSH
4376: LD_VAR 0 4
4380: PUSH
4381: LD_INT 2
4383: MINUS
4384: ARRAY
4385: PPUSH
4386: CALL_OW 200
// Wait ( 0 0$02 ) ;
4390: LD_INT 70
4392: PPUSH
4393: CALL_OW 67
// end ;
4397: GO 4207
4399: POP
4400: POP
// time := 0 0$20 ;
4401: LD_ADDR_VAR 0 8
4405: PUSH
4406: LD_INT 700
4408: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4409: LD_INT 35
4411: PPUSH
4412: CALL_OW 67
// time := time - 0 0$01 ;
4416: LD_ADDR_VAR 0 8
4420: PUSH
4421: LD_VAR 0 8
4425: PUSH
4426: LD_INT 35
4428: MINUS
4429: ST_TO_ADDR
// for i = 3 to 4 do
4430: LD_ADDR_VAR 0 4
4434: PUSH
4435: DOUBLE
4436: LD_INT 3
4438: DEC
4439: ST_TO_ADDR
4440: LD_INT 4
4442: PUSH
4443: FOR_TO
4444: IFFALSE 4579
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4446: LD_EXP 24
4450: PUSH
4451: LD_VAR 0 4
4455: ARRAY
4456: PPUSH
4457: LD_INT 1
4459: PPUSH
4460: CALL_OW 289
4464: PUSH
4465: LD_INT 0
4467: GREATER
4468: PUSH
4469: LD_EXP 24
4473: PUSH
4474: LD_VAR 0 4
4478: ARRAY
4479: PPUSH
4480: CALL_OW 314
4484: NOT
4485: AND
4486: IFFALSE 4577
// begin x := rand ( 0 , 5 ) ;
4488: LD_ADDR_VAR 0 2
4492: PUSH
4493: LD_INT 0
4495: PPUSH
4496: LD_INT 5
4498: PPUSH
4499: CALL_OW 12
4503: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4504: LD_EXP 24
4508: PUSH
4509: LD_VAR 0 4
4513: ARRAY
4514: PPUSH
4515: LD_EXP 24
4519: PUSH
4520: LD_VAR 0 4
4524: ARRAY
4525: PPUSH
4526: CALL_OW 250
4530: PPUSH
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_INT 3
4538: PPUSH
4539: CALL_OW 272
4543: PPUSH
4544: LD_EXP 24
4548: PUSH
4549: LD_VAR 0 4
4553: ARRAY
4554: PPUSH
4555: CALL_OW 251
4559: PPUSH
4560: LD_VAR 0 2
4564: PPUSH
4565: LD_INT 3
4567: PPUSH
4568: CALL_OW 273
4572: PPUSH
4573: CALL_OW 171
// end ;
4577: GO 4443
4579: POP
4580: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4581: LD_EXP 24
4585: PUSH
4586: LD_INT 1
4588: ARRAY
4589: PPUSH
4590: LD_INT 54
4592: PPUSH
4593: LD_INT 42
4595: PPUSH
4596: CALL_OW 297
4600: PUSH
4601: LD_INT 4
4603: LESS
4604: PUSH
4605: LD_VAR 0 8
4609: PUSH
4610: LD_INT 0
4612: EQUAL
4613: OR
4614: IFFALSE 4409
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4616: LD_EXP 24
4620: PUSH
4621: LD_INT 3
4623: ARRAY
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: LD_INT 0
4630: PPUSH
4631: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4635: LD_EXP 24
4639: PUSH
4640: LD_INT 4
4642: ARRAY
4643: PPUSH
4644: LD_INT 1
4646: PPUSH
4647: LD_INT 0
4649: PPUSH
4650: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4654: LD_EXP 3
4658: PPUSH
4659: CALL_OW 274
4663: PPUSH
4664: LD_INT 1
4666: PPUSH
4667: LD_INT 200
4669: PPUSH
4670: CALL_OW 276
// DialogueOn ;
4674: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4678: LD_INT 53
4680: PPUSH
4681: LD_INT 35
4683: PPUSH
4684: CALL_OW 86
// un := powell_trans [ 1 ] ;
4688: LD_ADDR_VAR 0 5
4692: PUSH
4693: LD_EXP 24
4697: PUSH
4698: LD_INT 1
4700: ARRAY
4701: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4702: LD_VAR 0 5
4706: PPUSH
4707: LD_STRING D4-Mech1-1
4709: PPUSH
4710: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4714: LD_EXP 18
4718: PPUSH
4719: LD_STRING D4-JMM-1
4721: PPUSH
4722: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4726: LD_VAR 0 5
4730: PPUSH
4731: LD_STRING D4-Mech1-2
4733: PPUSH
4734: CALL_OW 88
// powell_happy := false ;
4738: LD_ADDR_VAR 0 6
4742: PUSH
4743: LD_INT 0
4745: ST_TO_ADDR
// take_cargo := false ;
4746: LD_ADDR_VAR 0 7
4750: PUSH
4751: LD_INT 0
4753: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4754: CALL 784 0 0
4758: PUSH
4759: LD_INT 60
4761: GREATEREQUAL
4762: IFFALSE 4810
// begin Say ( JMM , D5-JMM-1 ) ;
4764: LD_EXP 18
4768: PPUSH
4769: LD_STRING D5-JMM-1
4771: PPUSH
4772: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4776: LD_VAR 0 5
4780: PPUSH
4781: LD_STRING D6-Mech1-1
4783: PPUSH
4784: CALL_OW 88
// powell_happy := true ;
4788: LD_ADDR_VAR 0 6
4792: PUSH
4793: LD_INT 1
4795: ST_TO_ADDR
// take_cargo := true ;
4796: LD_ADDR_VAR 0 7
4800: PUSH
4801: LD_INT 1
4803: ST_TO_ADDR
// DialogueOff ;
4804: CALL_OW 7
// end else
4808: GO 5044
// if GetTerminalCargo > 0 then
4810: CALL 784 0 0
4814: PUSH
4815: LD_INT 0
4817: GREATER
4818: IFFALSE 5016
// begin case Query ( QWait ) of 1 :
4820: LD_STRING QWait
4822: PPUSH
4823: CALL_OW 97
4827: PUSH
4828: LD_INT 1
4830: DOUBLE
4831: EQUAL
4832: IFTRUE 4836
4834: GO 4927
4836: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4837: LD_EXP 18
4841: PPUSH
4842: LD_STRING D5b-JMM-1
4844: PPUSH
4845: CALL_OW 88
// DialogueOff ;
4849: CALL_OW 7
// wait ( 5 5$00 ) ;
4853: LD_INT 10500
4855: PPUSH
4856: CALL_OW 67
// if GetTerminalCargo < 60 then
4860: CALL 784 0 0
4864: PUSH
4865: LD_INT 60
4867: LESS
4868: IFFALSE 4909
// begin DialogueOn ;
4870: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4874: LD_EXP 3
4878: PPUSH
4879: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4883: LD_VAR 0 5
4887: PPUSH
4888: LD_STRING D6-Mech1-1a
4890: PPUSH
4891: CALL_OW 88
// DialogueOff ;
4895: CALL_OW 7
// powell_happy := false ;
4899: LD_ADDR_VAR 0 6
4903: PUSH
4904: LD_INT 0
4906: ST_TO_ADDR
// end else
4907: GO 4925
// begin powell_happy := true ;
4909: LD_ADDR_VAR 0 6
4913: PUSH
4914: LD_INT 1
4916: ST_TO_ADDR
// take_cargo := true ;
4917: LD_ADDR_VAR 0 7
4921: PUSH
4922: LD_INT 1
4924: ST_TO_ADDR
// end ; end ; 2 :
4925: GO 5014
4927: LD_INT 2
4929: DOUBLE
4930: EQUAL
4931: IFTRUE 4935
4933: GO 4974
4935: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4936: LD_EXP 18
4940: PPUSH
4941: LD_STRING D5b-JMM-1
4943: PPUSH
4944: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_STRING D6-Mech1-1a
4955: PPUSH
4956: CALL_OW 88
// DialogueOff ;
4960: CALL_OW 7
// take_cargo := true ;
4964: LD_ADDR_VAR 0 7
4968: PUSH
4969: LD_INT 1
4971: ST_TO_ADDR
// end ; 3 :
4972: GO 5014
4974: LD_INT 3
4976: DOUBLE
4977: EQUAL
4978: IFTRUE 4982
4980: GO 5013
4982: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4983: LD_EXP 18
4987: PPUSH
4988: LD_STRING D5c-JMM-1
4990: PPUSH
4991: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4995: LD_VAR 0 5
4999: PPUSH
5000: LD_STRING D6-Mech1-1b
5002: PPUSH
5003: CALL_OW 88
// DialogueOff ;
5007: CALL_OW 7
// end ; end ;
5011: GO 5014
5013: POP
// end else
5014: GO 5044
// begin Say ( JMM , D5c-JMM-1 ) ;
5016: LD_EXP 18
5020: PPUSH
5021: LD_STRING D5c-JMM-1
5023: PPUSH
5024: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5028: LD_VAR 0 5
5032: PPUSH
5033: LD_STRING D6-Mech1-1b
5035: PPUSH
5036: CALL_OW 88
// DialogueOff ;
5040: CALL_OW 7
// end ; if take_cargo then
5044: LD_VAR 0 7
5048: IFFALSE 5127
// begin x := GetTerminalCargo ;
5050: LD_ADDR_VAR 0 2
5054: PUSH
5055: CALL 784 0 0
5059: ST_TO_ADDR
// if x > 60 then
5060: LD_VAR 0 2
5064: PUSH
5065: LD_INT 60
5067: GREATER
5068: IFFALSE 5078
// x := 60 ;
5070: LD_ADDR_VAR 0 2
5074: PUSH
5075: LD_INT 60
5077: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5078: LD_EXP 3
5082: PPUSH
5083: CALL_OW 274
5087: PPUSH
5088: LD_INT 3
5090: PPUSH
5091: CALL 784 0 0
5095: PUSH
5096: LD_VAR 0 2
5100: MINUS
5101: PPUSH
5102: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5106: LD_EXP 24
5110: PUSH
5111: LD_INT 3
5113: ARRAY
5114: PPUSH
5115: LD_INT 3
5117: PPUSH
5118: LD_VAR 0 2
5122: PPUSH
5123: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5127: LD_EXP 24
5131: PPUSH
5132: LD_INT 43
5134: PPUSH
5135: LD_INT 3
5137: PPUSH
5138: CALL_OW 171
// x := 0 0$20 ;
5142: LD_ADDR_VAR 0 2
5146: PUSH
5147: LD_INT 700
5149: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5150: LD_INT 35
5152: PPUSH
5153: CALL_OW 67
// x := x - 0 0$01 ;
5157: LD_ADDR_VAR 0 2
5161: PUSH
5162: LD_VAR 0 2
5166: PUSH
5167: LD_INT 35
5169: MINUS
5170: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5171: LD_VAR 0 2
5175: PUSH
5176: LD_INT 0
5178: EQUAL
5179: PUSH
5180: LD_EXP 24
5184: PUSH
5185: LD_INT 3
5187: ARRAY
5188: PPUSH
5189: LD_INT 43
5191: PPUSH
5192: LD_INT 3
5194: PPUSH
5195: CALL_OW 297
5199: PUSH
5200: LD_INT 4
5202: LESS
5203: PUSH
5204: LD_EXP 24
5208: PUSH
5209: LD_INT 3
5211: ARRAY
5212: PPUSH
5213: LD_INT 43
5215: PPUSH
5216: LD_INT 3
5218: PPUSH
5219: CALL_OW 297
5223: PUSH
5224: LD_INT 4
5226: LESS
5227: AND
5228: OR
5229: IFFALSE 5150
// for i in powell_trans do
5231: LD_ADDR_VAR 0 4
5235: PUSH
5236: LD_EXP 24
5240: PUSH
5241: FOR_IN
5242: IFFALSE 5255
// RemoveUnit ( i ) ;
5244: LD_VAR 0 4
5248: PPUSH
5249: CALL_OW 64
5253: GO 5241
5255: POP
5256: POP
// if not powell_happy then
5257: LD_VAR 0 6
5261: NOT
5262: IFFALSE 5273
// powell_happy := - 1 ;
5264: LD_ADDR_VAR 0 6
5268: PUSH
5269: LD_INT 1
5271: NEG
5272: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5273: LD_STRING EarlySiberite
5275: PPUSH
5276: LD_VAR 0 6
5280: PPUSH
5281: CALL_OW 101
// if powell_happy then
5285: LD_VAR 0 6
5289: IFFALSE 5300
// ChangeMissionObjectives ( M3a ) else
5291: LD_STRING M3a
5293: PPUSH
5294: CALL_OW 337
5298: GO 5307
// ChangeMissionObjectives ( M3b ) ;
5300: LD_STRING M3b
5302: PPUSH
5303: CALL_OW 337
// ru_can_attack_terminal := true ;
5307: LD_ADDR_EXP 9
5311: PUSH
5312: LD_INT 1
5314: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5315: LD_INT 25200
5317: PPUSH
5318: CALL_OW 67
// time := 2 2$00 ;
5322: LD_ADDR_VAR 0 8
5326: PUSH
5327: LD_INT 4200
5329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5330: LD_INT 35
5332: PPUSH
5333: CALL_OW 67
// time := time - 0 0$1 ;
5337: LD_ADDR_VAR 0 8
5341: PUSH
5342: LD_VAR 0 8
5346: PUSH
5347: LD_INT 35
5349: MINUS
5350: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5351: LD_EXP 8
5355: NOT
5356: PUSH
5357: LD_EXP 35
5361: PUSH
5362: LD_INT 0
5364: EQUAL
5365: OR
5366: PUSH
5367: LD_VAR 0 8
5371: PUSH
5372: LD_INT 0
5374: EQUAL
5375: OR
5376: IFFALSE 5330
// if ru_force then
5378: LD_EXP 35
5382: IFFALSE 5481
// for i in ru_force do
5384: LD_ADDR_VAR 0 4
5388: PUSH
5389: LD_EXP 35
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5479
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5397: LD_INT 1
5399: PPUSH
5400: LD_VAR 0 4
5404: PPUSH
5405: CALL_OW 292
5409: NOT
5410: PUSH
5411: LD_VAR 0 4
5415: PPUSH
5416: LD_INT 81
5418: PUSH
5419: LD_INT 3
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: PPUSH
5426: CALL_OW 69
5430: PPUSH
5431: LD_VAR 0 4
5435: PPUSH
5436: CALL_OW 74
5440: PPUSH
5441: CALL_OW 296
5445: PUSH
5446: LD_INT 10
5448: GREATER
5449: AND
5450: IFFALSE 5477
// begin RemoveUnit ( i ) ;
5452: LD_VAR 0 4
5456: PPUSH
5457: CALL_OW 64
// ru_force := ru_force diff i ;
5461: LD_ADDR_EXP 35
5465: PUSH
5466: LD_EXP 35
5470: PUSH
5471: LD_VAR 0 4
5475: DIFF
5476: ST_TO_ADDR
// end ;
5477: GO 5394
5479: POP
5480: POP
// repeat wait ( 0 0$03 ) ;
5481: LD_INT 105
5483: PPUSH
5484: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5488: LD_EXP 8
5492: NOT
5493: PUSH
5494: LD_EXP 35
5498: PUSH
5499: LD_INT 3
5501: LESS
5502: OR
5503: IFFALSE 5481
// ar_can_arrive := true ;
5505: LD_ADDR_EXP 10
5509: PUSH
5510: LD_INT 1
5512: ST_TO_ADDR
// end ;
5513: PPOPN 8
5515: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 20
5521: PPUSH
5522: CALL_OW 325
5526: IFFALSE 5667
5528: GO 5530
5530: DISABLE
5531: LD_INT 0
5533: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5534: LD_ADDR_VAR 0 1
5538: PUSH
5539: LD_INT 22
5541: PUSH
5542: LD_INT 1
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 26
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 25
5561: PUSH
5562: LD_INT 4
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: LIST
5573: PPUSH
5574: CALL_OW 69
5578: PUSH
5579: LD_EXP 18
5583: PUSH
5584: LD_EXP 21
5588: PUSH
5589: LD_EXP 20
5593: PUSH
5594: LD_EXP 22
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: LIST
5604: DIFF
5605: ST_TO_ADDR
// if not un then
5606: LD_VAR 0 1
5610: NOT
5611: IFFALSE 5615
// exit ;
5613: GO 5667
// DialogueOn ;
5615: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5619: LD_VAR 0 1
5623: PUSH
5624: LD_INT 1
5626: ARRAY
5627: PPUSH
5628: LD_STRING D13-Sci1-1
5630: PPUSH
5631: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5635: LD_EXP 18
5639: PPUSH
5640: LD_STRING D13-JMM-1
5642: PPUSH
5643: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5647: LD_VAR 0 1
5651: PUSH
5652: LD_INT 1
5654: ARRAY
5655: PPUSH
5656: LD_STRING D13-Sci1-2
5658: PPUSH
5659: CALL_OW 88
// DialogueOff ;
5663: CALL_OW 7
// end ;
5667: PPOPN 1
5669: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5670: LD_INT 1
5672: PPUSH
5673: CALL 815 0 1
5677: PUSH
5678: LD_INT 77
5680: GREATER
5681: PUSH
5682: LD_EXP 8
5686: NOT
5687: AND
5688: PUSH
5689: LD_INT 22
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: LD_INT 25
5701: PUSH
5702: LD_INT 4
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: LD_INT 26
5711: PUSH
5712: LD_INT 1
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: PPUSH
5724: CALL_OW 69
5728: PUSH
5729: LD_EXP 18
5733: PUSH
5734: LD_EXP 20
5738: PUSH
5739: LD_EXP 21
5743: PUSH
5744: LD_EXP 19
5748: PUSH
5749: LD_EXP 22
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: LIST
5758: LIST
5759: LIST
5760: DIFF
5761: AND
5762: IFFALSE 5940
5764: GO 5766
5766: DISABLE
5767: LD_INT 0
5769: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5770: LD_ADDR_VAR 0 1
5774: PUSH
5775: LD_INT 22
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: PUSH
5785: LD_INT 25
5787: PUSH
5788: LD_INT 4
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: PPUSH
5810: CALL_OW 69
5814: PUSH
5815: LD_EXP 18
5819: PUSH
5820: LD_EXP 20
5824: PUSH
5825: LD_EXP 21
5829: PUSH
5830: LD_EXP 19
5834: PUSH
5835: LD_EXP 22
5839: PUSH
5840: EMPTY
5841: LIST
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: DIFF
5847: ST_TO_ADDR
// DialogueOn ;
5848: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5852: LD_VAR 0 1
5856: PUSH
5857: LD_INT 1
5859: ARRAY
5860: PPUSH
5861: LD_STRING D7-Sci1-1
5863: PPUSH
5864: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5868: LD_EXP 18
5872: PPUSH
5873: LD_STRING D7-JMM-1
5875: PPUSH
5876: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5880: LD_VAR 0 1
5884: PUSH
5885: LD_INT 1
5887: ARRAY
5888: PPUSH
5889: LD_STRING D7-Sci1-2
5891: PPUSH
5892: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5896: LD_EXP 18
5900: PPUSH
5901: LD_STRING D7-JMM-2
5903: PPUSH
5904: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5908: LD_VAR 0 1
5912: PUSH
5913: LD_INT 1
5915: ARRAY
5916: PPUSH
5917: LD_STRING D7-Sci1-3
5919: PPUSH
5920: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5924: LD_EXP 18
5928: PPUSH
5929: LD_STRING D7-JMM-3
5931: PPUSH
5932: CALL_OW 88
// DialogueOff ;
5936: CALL_OW 7
// end ;
5940: PPOPN 1
5942: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5943: LD_EXP 10
5947: IFFALSE 9324
5949: GO 5951
5951: DISABLE
5952: LD_INT 0
5954: PPUSH
5955: PPUSH
5956: PPUSH
5957: PPUSH
5958: PPUSH
5959: PPUSH
5960: PPUSH
5961: PPUSH
// begin PrepareArabian ;
5962: CALL 11745 0 0
// repeat wait ( 0 0$01 ) ;
5966: LD_INT 35
5968: PPUSH
5969: CALL_OW 67
// until ar_spawned ;
5973: LD_EXP 11
5977: IFFALSE 5966
// DialogueOn ;
5979: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5983: LD_EXP 26
5987: PPUSH
5988: LD_STRING D8-Ar1-1
5990: PPUSH
5991: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5995: LD_EXP 18
5999: PPUSH
6000: LD_STRING D8-JMM-1
6002: PPUSH
6003: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6007: LD_EXP 26
6011: PPUSH
6012: LD_STRING D8-Ar1-2
6014: PPUSH
6015: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6019: LD_EXP 18
6023: PPUSH
6024: LD_STRING D8-JMM-2
6026: PPUSH
6027: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6031: LD_EXP 26
6035: PPUSH
6036: LD_STRING D8-Ar1-3
6038: PPUSH
6039: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6043: LD_EXP 18
6047: PPUSH
6048: LD_STRING D8-JMM-3
6050: PPUSH
6051: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6055: LD_EXP 26
6059: PPUSH
6060: LD_STRING D8-Ar1-4
6062: PPUSH
6063: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6067: LD_EXP 18
6071: PPUSH
6072: LD_STRING D8-JMM-4
6074: PPUSH
6075: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6079: LD_EXP 26
6083: PPUSH
6084: LD_STRING D8-Ar1-5
6086: PPUSH
6087: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6091: LD_EXP 18
6095: PPUSH
6096: LD_STRING D8-JMM-5
6098: PPUSH
6099: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6103: LD_EXP 26
6107: PPUSH
6108: LD_STRING D8-Ar1-6
6110: PPUSH
6111: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6115: LD_EXP 27
6119: PPUSH
6120: LD_STRING D8-Ar2-6
6122: PPUSH
6123: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6127: LD_EXP 18
6131: PPUSH
6132: LD_STRING D8-JMM-6
6134: PPUSH
6135: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6139: LD_EXP 27
6143: PPUSH
6144: LD_STRING D8-Ar2-7
6146: PPUSH
6147: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6151: LD_STRING QBarracks
6153: PPUSH
6154: CALL_OW 97
6158: PUSH
6159: LD_INT 1
6161: DOUBLE
6162: EQUAL
6163: IFTRUE 6167
6165: GO 6202
6167: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6168: LD_EXP 18
6172: PPUSH
6173: LD_STRING D8a-JMM-1
6175: PPUSH
6176: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6180: LD_EXP 26
6184: PPUSH
6185: LD_STRING D8a-Ar1-1
6187: PPUSH
6188: CALL_OW 94
// player_want_mortar := true ;
6192: LD_ADDR_EXP 12
6196: PUSH
6197: LD_INT 1
6199: ST_TO_ADDR
// end ; 2 :
6200: GO 6360
6202: LD_INT 2
6204: DOUBLE
6205: EQUAL
6206: IFTRUE 6210
6208: GO 6324
6210: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6211: LD_EXP 18
6215: PPUSH
6216: LD_STRING D8b-JMM-1
6218: PPUSH
6219: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6223: LD_EXP 26
6227: PPUSH
6228: LD_STRING D8b-Ar1-1
6230: PPUSH
6231: CALL_OW 94
// case Query ( QInfo ) of 1 :
6235: LD_STRING QInfo
6237: PPUSH
6238: CALL_OW 97
6242: PUSH
6243: LD_INT 1
6245: DOUBLE
6246: EQUAL
6247: IFTRUE 6251
6249: GO 6286
6251: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6252: LD_EXP 18
6256: PPUSH
6257: LD_STRING D8b1-JMM-1
6259: PPUSH
6260: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6264: LD_EXP 26
6268: PPUSH
6269: LD_STRING D8b1-Ar1-1
6271: PPUSH
6272: CALL_OW 94
// player_want_info := 2 ;
6276: LD_ADDR_EXP 13
6280: PUSH
6281: LD_INT 2
6283: ST_TO_ADDR
// end ; 2 :
6284: GO 6322
6286: LD_INT 2
6288: DOUBLE
6289: EQUAL
6290: IFTRUE 6294
6292: GO 6321
6294: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6295: LD_EXP 18
6299: PPUSH
6300: LD_STRING D8b2-JMM-1
6302: PPUSH
6303: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6307: LD_EXP 26
6311: PPUSH
6312: LD_STRING D8b2-Ar1-1
6314: PPUSH
6315: CALL_OW 94
// end ; end ;
6319: GO 6322
6321: POP
// end ; 3 :
6322: GO 6360
6324: LD_INT 3
6326: DOUBLE
6327: EQUAL
6328: IFTRUE 6332
6330: GO 6359
6332: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6333: LD_EXP 18
6337: PPUSH
6338: LD_STRING D8c-JMM-1
6340: PPUSH
6341: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6345: LD_EXP 26
6349: PPUSH
6350: LD_STRING D8c-Ar1-1
6352: PPUSH
6353: CALL_OW 94
// end ; end ;
6357: GO 6360
6359: POP
// DialogueOff ;
6360: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6364: LD_ADDR_VAR 0 4
6368: PUSH
6369: LD_INT 9
6371: PPUSH
6372: LD_INT 2
6374: PUSH
6375: LD_INT 30
6377: PUSH
6378: LD_INT 0
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 30
6387: PUSH
6388: LD_INT 1
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: LIST
6399: PPUSH
6400: CALL_OW 70
6404: ST_TO_ADDR
// if dep then
6405: LD_VAR 0 4
6409: IFFALSE 6427
// dep := dep [ 1 ] else
6411: LD_ADDR_VAR 0 4
6415: PUSH
6416: LD_VAR 0 4
6420: PUSH
6421: LD_INT 1
6423: ARRAY
6424: ST_TO_ADDR
6425: GO 6489
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6427: LD_ADDR_VAR 0 4
6431: PUSH
6432: LD_INT 22
6434: PUSH
6435: LD_INT 1
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 30
6447: PUSH
6448: LD_INT 0
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 30
6457: PUSH
6458: LD_INT 1
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PPUSH
6474: CALL_OW 69
6478: PPUSH
6479: LD_EXP 27
6483: PPUSH
6484: CALL_OW 74
6488: ST_TO_ADDR
// if not dep then
6489: LD_VAR 0 4
6493: NOT
6494: IFFALSE 6532
// begin case Query ( QInfoNothing ) of 1 :
6496: LD_STRING QInfoNothing
6498: PPUSH
6499: CALL_OW 97
6503: PUSH
6504: LD_INT 1
6506: DOUBLE
6507: EQUAL
6508: IFTRUE 6512
6510: GO 6515
6512: POP
// ; end ;
6513: GO 6516
6515: POP
// player_want_info := false ;
6516: LD_ADDR_EXP 13
6520: PUSH
6521: LD_INT 0
6523: ST_TO_ADDR
// player_want_mortar := false ;
6524: LD_ADDR_EXP 12
6528: PUSH
6529: LD_INT 0
6531: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6532: LD_ADDR_VAR 0 3
6536: PUSH
6537: LD_INT 22
6539: PUSH
6540: LD_INT 2
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 21
6549: PUSH
6550: LD_INT 2
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: PPUSH
6561: CALL_OW 69
6565: ST_TO_ADDR
// time := 1 1$35 ;
6566: LD_ADDR_VAR 0 5
6570: PUSH
6571: LD_INT 3325
6573: ST_TO_ADDR
// no_oil_gain := false ;
6574: LD_ADDR_VAR 0 6
6578: PUSH
6579: LD_INT 0
6581: ST_TO_ADDR
// first_warn := false ;
6582: LD_ADDR_VAR 0 7
6586: PUSH
6587: LD_INT 0
6589: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6590: LD_EXP 12
6594: PUSH
6595: LD_EXP 13
6599: OR
6600: IFFALSE 6705
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6602: LD_EXP 33
6606: PPUSH
6607: LD_INT 25
6609: PUSH
6610: LD_INT 1
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: PPUSH
6617: CALL_OW 72
6621: PPUSH
6622: LD_VAR 0 4
6626: PPUSH
6627: CALL_OW 250
6631: PPUSH
6632: LD_VAR 0 4
6636: PPUSH
6637: CALL_OW 251
6641: PPUSH
6642: LD_VAR 0 4
6646: PPUSH
6647: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6651: LD_EXP 33
6655: PPUSH
6656: LD_INT 25
6658: PUSH
6659: LD_INT 1
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PPUSH
6666: CALL_OW 72
6670: PPUSH
6671: LD_INT 86
6673: PPUSH
6674: LD_INT 121
6676: PPUSH
6677: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6681: LD_EXP 33
6685: PPUSH
6686: LD_INT 25
6688: PUSH
6689: LD_INT 1
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: PPUSH
6696: CALL_OW 72
6700: PPUSH
6701: CALL_OW 200
// end ; if player_attacked_ar then
6705: LD_EXP 16
6709: IFFALSE 6713
// exit ;
6711: GO 9324
// if player_want_mortar then
6713: LD_EXP 12
6717: IFFALSE 8126
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6719: LD_EXP 27
6723: PPUSH
6724: LD_VAR 0 4
6728: PPUSH
6729: CALL_OW 250
6733: PUSH
6734: LD_INT 1
6736: PLUS
6737: PPUSH
6738: LD_VAR 0 4
6742: PPUSH
6743: CALL_OW 251
6747: PUSH
6748: LD_INT 1
6750: PLUS
6751: PPUSH
6752: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6756: LD_INT 35
6758: PPUSH
6759: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6763: LD_EXP 27
6767: PPUSH
6768: LD_VAR 0 4
6772: PPUSH
6773: CALL_OW 296
6777: PUSH
6778: LD_INT 4
6780: LESS
6781: IFFALSE 6756
// for i = 1 to 6 do
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: DOUBLE
6789: LD_INT 1
6791: DEC
6792: ST_TO_ADDR
6793: LD_INT 6
6795: PUSH
6796: FOR_TO
6797: IFFALSE 6994
// begin if player_attacked_ar then
6799: LD_EXP 16
6803: IFFALSE 6809
// exit ;
6805: POP
6806: POP
6807: GO 9324
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6809: LD_VAR 0 4
6813: PPUSH
6814: CALL_OW 274
6818: PPUSH
6819: LD_INT 2
6821: PPUSH
6822: CALL_OW 275
6826: PUSH
6827: LD_INT 10
6829: LESS
6830: PUSH
6831: LD_VAR 0 7
6835: NOT
6836: AND
6837: IFFALSE 6900
// begin first_warn := true ;
6839: LD_ADDR_VAR 0 7
6843: PUSH
6844: LD_INT 1
6846: ST_TO_ADDR
// DialogueOn ;
6847: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6851: LD_EXP 28
6855: PPUSH
6856: LD_STRING D9a-FAr1-1
6858: PPUSH
6859: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6863: LD_EXP 18
6867: PPUSH
6868: LD_STRING D9a-JMM-1
6870: PPUSH
6871: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6875: LD_EXP 26
6879: PPUSH
6880: LD_STRING D9a2-Ar1-1
6882: PPUSH
6883: CALL_OW 88
// DialogueOff ;
6887: CALL_OW 7
// wait ( time ) ;
6891: LD_VAR 0 5
6895: PPUSH
6896: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6900: LD_VAR 0 4
6904: PPUSH
6905: CALL_OW 274
6909: PPUSH
6910: LD_INT 2
6912: PPUSH
6913: CALL_OW 275
6917: PUSH
6918: LD_INT 10
6920: LESS
6921: IFFALSE 6947
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6923: LD_EXP 26
6927: PPUSH
6928: LD_STRING D9a3-Ar1-1
6930: PPUSH
6931: CALL_OW 88
// no_oil_gain := true ;
6935: LD_ADDR_VAR 0 6
6939: PUSH
6940: LD_INT 1
6942: ST_TO_ADDR
// break ;
6943: GO 6994
// end else
6945: GO 6992
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6947: LD_EXP 27
6951: PPUSH
6952: LD_VAR 0 4
6956: PPUSH
6957: LD_INT 2
6959: PPUSH
6960: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6964: LD_EXP 27
6968: PPUSH
6969: LD_VAR 0 3
6973: PUSH
6974: LD_VAR 0 1
6978: PUSH
6979: LD_INT 3
6981: MOD
6982: PUSH
6983: LD_INT 1
6985: PLUS
6986: ARRAY
6987: PPUSH
6988: CALL_OW 210
// end ; end ;
6992: GO 6796
6994: POP
6995: POP
// if not no_oil_gain then
6996: LD_VAR 0 6
7000: NOT
7001: IFFALSE 8126
// begin repeat wait ( 0 0$01 ) ;
7003: LD_INT 35
7005: PPUSH
7006: CALL_OW 67
// if player_attacked_ar then
7010: LD_EXP 16
7014: IFFALSE 7018
// exit ;
7016: GO 9324
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7018: LD_VAR 0 3
7022: PUSH
7023: LD_INT 1
7025: ARRAY
7026: PPUSH
7027: CALL_OW 261
7031: PUSH
7032: LD_INT 80
7034: GREATER
7035: PUSH
7036: LD_VAR 0 3
7040: PUSH
7041: LD_INT 2
7043: ARRAY
7044: PPUSH
7045: CALL_OW 261
7049: PUSH
7050: LD_INT 80
7052: GREATER
7053: AND
7054: PUSH
7055: LD_VAR 0 3
7059: PUSH
7060: LD_INT 3
7062: ARRAY
7063: PPUSH
7064: CALL_OW 261
7068: PUSH
7069: LD_INT 80
7071: GREATER
7072: AND
7073: IFFALSE 7003
// ComMoveXY ( Gali , 105 , 127 ) ;
7075: LD_EXP 27
7079: PPUSH
7080: LD_INT 105
7082: PPUSH
7083: LD_INT 127
7085: PPUSH
7086: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7090: LD_EXP 27
7094: PPUSH
7095: LD_INT 2
7097: PPUSH
7098: CALL_OW 173
// AddComHold ( Gali ) ;
7102: LD_EXP 27
7106: PPUSH
7107: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7111: LD_INT 35
7113: PPUSH
7114: CALL_OW 67
// if player_attacked_ar then
7118: LD_EXP 16
7122: IFFALSE 7126
// exit ;
7124: GO 9324
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7126: LD_EXP 27
7130: PPUSH
7131: LD_INT 105
7133: PPUSH
7134: LD_INT 127
7136: PPUSH
7137: CALL_OW 297
7141: PUSH
7142: LD_INT 4
7144: LESS
7145: IFFALSE 7111
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7147: LD_VAR 0 4
7151: PPUSH
7152: CALL_OW 274
7156: PPUSH
7157: LD_INT 1
7159: PPUSH
7160: CALL_OW 275
7164: PUSH
7165: LD_INT 50
7167: LESS
7168: IFFALSE 7464
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7170: LD_VAR 0 4
7174: PPUSH
7175: CALL_OW 274
7179: PPUSH
7180: LD_INT 1
7182: PPUSH
7183: CALL_OW 275
7187: PUSH
7188: LD_INT 0
7190: DOUBLE
7191: GREATEREQUAL
7192: IFFALSE 7200
7194: LD_INT 24
7196: DOUBLE
7197: LESSEQUAL
7198: IFTRUE 7202
7200: GO 7217
7202: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7203: LD_EXP 27
7207: PPUSH
7208: LD_STRING D9b-Ar2-1
7210: PPUSH
7211: CALL_OW 88
7215: GO 7247
7217: LD_INT 25
7219: DOUBLE
7220: GREATEREQUAL
7221: IFFALSE 7229
7223: LD_INT 49
7225: DOUBLE
7226: LESSEQUAL
7227: IFTRUE 7231
7229: GO 7246
7231: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7232: LD_EXP 27
7236: PPUSH
7237: LD_STRING D9b-Ar2-1a
7239: PPUSH
7240: CALL_OW 88
7244: GO 7247
7246: POP
// Say ( JMM , D9b-JMM-1 ) ;
7247: LD_EXP 18
7251: PPUSH
7252: LD_STRING D9b-JMM-1
7254: PPUSH
7255: CALL_OW 88
// x := 0 0$0 ;
7259: LD_ADDR_VAR 0 2
7263: PUSH
7264: LD_INT 0
7266: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7267: LD_INT 35
7269: PPUSH
7270: CALL_OW 67
// x := x + 0 0$1 ;
7274: LD_ADDR_VAR 0 2
7278: PUSH
7279: LD_VAR 0 2
7283: PUSH
7284: LD_INT 35
7286: PLUS
7287: ST_TO_ADDR
// if player_attacked_ar then
7288: LD_EXP 16
7292: IFFALSE 7296
// exit ;
7294: GO 9324
// until x >= time ;
7296: LD_VAR 0 2
7300: PUSH
7301: LD_VAR 0 5
7305: GREATEREQUAL
7306: IFFALSE 7267
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7308: LD_VAR 0 4
7312: PPUSH
7313: CALL_OW 274
7317: PPUSH
7318: LD_INT 1
7320: PPUSH
7321: CALL_OW 275
7325: PUSH
7326: LD_INT 50
7328: LESS
7329: IFFALSE 7462
// begin DialogueOn ;
7331: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7335: LD_EXP 26
7339: PPUSH
7340: LD_STRING D9c-Ar1-1
7342: PPUSH
7343: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7347: LD_EXP 18
7351: PPUSH
7352: LD_STRING D9c-JMM-1
7354: PPUSH
7355: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7359: LD_EXP 26
7363: PPUSH
7364: LD_STRING D9c-Ar1-2
7366: PPUSH
7367: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7371: LD_EXP 28
7375: PPUSH
7376: LD_STRING D9c-FAr1-2
7378: PPUSH
7379: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7383: LD_EXP 26
7387: PPUSH
7388: LD_STRING D9c-Ar1-3
7390: PPUSH
7391: CALL_OW 88
// case Query ( QInfo ) of 1 :
7395: LD_STRING QInfo
7397: PPUSH
7398: CALL_OW 97
7402: PUSH
7403: LD_INT 1
7405: DOUBLE
7406: EQUAL
7407: IFTRUE 7411
7409: GO 7434
7411: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7412: LD_EXP 18
7416: PPUSH
7417: LD_STRING D8b1-JMM-1
7419: PPUSH
7420: CALL_OW 88
// player_want_info := 2 ;
7424: LD_ADDR_EXP 13
7428: PUSH
7429: LD_INT 2
7431: ST_TO_ADDR
// end ; 2 :
7432: GO 7458
7434: LD_INT 2
7436: DOUBLE
7437: EQUAL
7438: IFTRUE 7442
7440: GO 7457
7442: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7443: LD_EXP 26
7447: PPUSH
7448: LD_STRING D8b2-Ar1-1
7450: PPUSH
7451: CALL_OW 88
// end ; end ;
7455: GO 7458
7457: POP
// DialogueOff ;
7458: CALL_OW 7
// end ; end else
7462: GO 8126
// begin RemoveEnvironmentArea ( mortarArea ) ;
7464: LD_INT 2
7466: PPUSH
7467: CALL_OW 355
// wait ( 1 ) ;
7471: LD_INT 1
7473: PPUSH
7474: CALL_OW 67
// InGameOn ;
7478: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7482: LD_EXP 27
7486: PPUSH
7487: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7491: LD_EXP 27
7495: PPUSH
7496: LD_INT 1
7498: PPUSH
7499: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7503: LD_EXP 27
7507: PPUSH
7508: LD_INT 4
7510: PPUSH
7511: LD_INT 107
7513: PPUSH
7514: LD_INT 131
7516: PPUSH
7517: LD_INT 0
7519: PPUSH
7520: CALL_OW 145
// repeat wait ( 1 ) ;
7524: LD_INT 1
7526: PPUSH
7527: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7531: LD_INT 30
7533: PUSH
7534: LD_INT 4
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: PUSH
7541: LD_INT 23
7543: PUSH
7544: LD_INT 2
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PPUSH
7555: CALL_OW 69
7559: IFFALSE 7524
// SetSide ( Gali , 2 ) ;
7561: LD_EXP 27
7565: PPUSH
7566: LD_INT 2
7568: PPUSH
7569: CALL_OW 235
// InGameOff ;
7573: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7577: LD_ADDR_VAR 0 8
7581: PUSH
7582: LD_INT 30
7584: PUSH
7585: LD_INT 4
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 23
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PPUSH
7606: CALL_OW 69
7610: PUSH
7611: LD_INT 1
7613: ARRAY
7614: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7615: LD_INT 35
7617: PPUSH
7618: CALL_OW 67
// if player_attacked_ar then
7622: LD_EXP 16
7626: IFFALSE 7630
// exit ;
7628: GO 9324
// until BuildingStatus ( b ) <> bs_build ;
7630: LD_VAR 0 8
7634: PPUSH
7635: CALL_OW 461
7639: PUSH
7640: LD_INT 1
7642: NONEQUAL
7643: IFFALSE 7615
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7645: LD_VAR 0 8
7649: PPUSH
7650: CALL_OW 302
7654: PUSH
7655: LD_VAR 0 4
7659: PPUSH
7660: CALL_OW 274
7664: PPUSH
7665: LD_INT 1
7667: PPUSH
7668: CALL_OW 275
7672: PUSH
7673: LD_INT 25
7675: GREATEREQUAL
7676: AND
7677: IFFALSE 7776
// begin ComUpgrade ( b ) ;
7679: LD_VAR 0 8
7683: PPUSH
7684: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7688: LD_EXP 27
7692: PPUSH
7693: LD_STRING h
7695: PUSH
7696: LD_VAR 0 8
7700: PPUSH
7701: CALL_OW 250
7705: PUSH
7706: LD_VAR 0 8
7710: PPUSH
7711: CALL_OW 251
7715: PUSH
7716: LD_VAR 0 8
7720: PUSH
7721: LD_INT 0
7723: PUSH
7724: LD_INT 0
7726: PUSH
7727: LD_INT 0
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: LIST
7738: PUSH
7739: EMPTY
7740: LIST
7741: PPUSH
7742: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7746: LD_INT 35
7748: PPUSH
7749: CALL_OW 67
// if player_attacked_ar then
7753: LD_EXP 16
7757: IFFALSE 7761
// exit ;
7759: GO 9324
// until BuildingStatus ( b ) <> bs_build ;
7761: LD_VAR 0 8
7765: PPUSH
7766: CALL_OW 461
7770: PUSH
7771: LD_INT 1
7773: NONEQUAL
7774: IFFALSE 7746
// end ; if b then
7776: LD_VAR 0 8
7780: IFFALSE 7791
// CenterNowOnUnits ( b ) ;
7782: LD_VAR 0 8
7786: PPUSH
7787: CALL_OW 87
// DialogueOn ;
7791: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7795: LD_EXP 27
7799: PPUSH
7800: LD_STRING D9d-Ar2-1
7802: PPUSH
7803: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7807: LD_EXP 26
7811: PPUSH
7812: LD_STRING D9d-Ar1-1
7814: PPUSH
7815: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7819: LD_EXP 18
7823: PPUSH
7824: LD_STRING D9d-JMM-1
7826: PPUSH
7827: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7831: LD_EXP 26
7835: PPUSH
7836: LD_STRING D9d-Ar1-2
7838: PPUSH
7839: CALL_OW 88
// DialogueOff ;
7843: CALL_OW 7
// i := [ ] ;
7847: LD_ADDR_VAR 0 1
7851: PUSH
7852: EMPTY
7853: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7854: LD_VAR 0 4
7858: PPUSH
7859: CALL_OW 274
7863: PPUSH
7864: LD_INT 3
7866: PPUSH
7867: CALL_OW 275
7871: PUSH
7872: LD_INT 20
7874: GREATEREQUAL
7875: IFFALSE 7894
// i := i ^ [ 1 ] ;
7877: LD_ADDR_VAR 0 1
7881: PUSH
7882: LD_VAR 0 1
7886: PUSH
7887: LD_INT 1
7889: PUSH
7890: EMPTY
7891: LIST
7892: ADD
7893: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7894: LD_VAR 0 4
7898: PPUSH
7899: CALL_OW 274
7903: PPUSH
7904: LD_INT 1
7906: PPUSH
7907: CALL_OW 275
7911: PUSH
7912: LD_INT 50
7914: GREATEREQUAL
7915: IFFALSE 7934
// i := i ^ [ 2 ] ;
7917: LD_ADDR_VAR 0 1
7921: PUSH
7922: LD_VAR 0 1
7926: PUSH
7927: LD_INT 2
7929: PUSH
7930: EMPTY
7931: LIST
7932: ADD
7933: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7934: LD_VAR 0 4
7938: PPUSH
7939: CALL_OW 274
7943: PPUSH
7944: LD_INT 2
7946: PPUSH
7947: CALL_OW 275
7951: PUSH
7952: LD_INT 80
7954: GREATEREQUAL
7955: IFFALSE 7974
// i := i ^ [ 3 ] ;
7957: LD_ADDR_VAR 0 1
7961: PUSH
7962: LD_VAR 0 1
7966: PUSH
7967: LD_INT 3
7969: PUSH
7970: EMPTY
7971: LIST
7972: ADD
7973: ST_TO_ADDR
// i := i diff 0 ;
7974: LD_ADDR_VAR 0 1
7978: PUSH
7979: LD_VAR 0 1
7983: PUSH
7984: LD_INT 0
7986: DIFF
7987: ST_TO_ADDR
// if i then
7988: LD_VAR 0 1
7992: IFFALSE 8098
// begin i := i ^ [ 4 ] ;
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: LD_VAR 0 1
8003: PUSH
8004: LD_INT 4
8006: PUSH
8007: EMPTY
8008: LIST
8009: ADD
8010: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8011: LD_STRING QInfo2
8013: PPUSH
8014: CALL_OW 97
8018: PUSH
8019: LD_INT 1
8021: DOUBLE
8022: EQUAL
8023: IFTRUE 8027
8025: GO 8038
8027: POP
// player_want_info := 3 ; 2 :
8028: LD_ADDR_EXP 13
8032: PUSH
8033: LD_INT 3
8035: ST_TO_ADDR
8036: GO 8096
8038: LD_INT 2
8040: DOUBLE
8041: EQUAL
8042: IFTRUE 8046
8044: GO 8057
8046: POP
// player_want_info := 1 ; 3 :
8047: LD_ADDR_EXP 13
8051: PUSH
8052: LD_INT 1
8054: ST_TO_ADDR
8055: GO 8096
8057: LD_INT 3
8059: DOUBLE
8060: EQUAL
8061: IFTRUE 8065
8063: GO 8076
8065: POP
// player_want_info := 2 ; 4 :
8066: LD_ADDR_EXP 13
8070: PUSH
8071: LD_INT 2
8073: ST_TO_ADDR
8074: GO 8096
8076: LD_INT 4
8078: DOUBLE
8079: EQUAL
8080: IFTRUE 8084
8082: GO 8095
8084: POP
// player_want_info := 0 ; end ;
8085: LD_ADDR_EXP 13
8089: PUSH
8090: LD_INT 0
8092: ST_TO_ADDR
8093: GO 8096
8095: POP
// end else
8096: GO 8126
// case Query ( QInfoNothing ) of 1 :
8098: LD_STRING QInfoNothing
8100: PPUSH
8101: CALL_OW 97
8105: PUSH
8106: LD_INT 1
8108: DOUBLE
8109: EQUAL
8110: IFTRUE 8114
8112: GO 8125
8114: POP
// player_want_info := 0 ; end ;
8115: LD_ADDR_EXP 13
8119: PUSH
8120: LD_INT 0
8122: ST_TO_ADDR
8123: GO 8126
8125: POP
// end ; end ; end ; if player_want_info then
8126: LD_EXP 13
8130: IFFALSE 9144
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8132: LD_ADDR_VAR 0 3
8136: PUSH
8137: LD_VAR 0 3
8141: PPUSH
8142: LD_INT 34
8144: PUSH
8145: LD_INT 32
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PPUSH
8152: CALL_OW 72
8156: ST_TO_ADDR
// if player_want_mortar then
8157: LD_EXP 12
8161: IFFALSE 8483
// begin case player_want_info of 1 :
8163: LD_EXP 13
8167: PUSH
8168: LD_INT 1
8170: DOUBLE
8171: EQUAL
8172: IFTRUE 8176
8174: GO 8187
8176: POP
// x := 5 ; 2 :
8177: LD_ADDR_VAR 0 2
8181: PUSH
8182: LD_INT 5
8184: ST_TO_ADDR
8185: GO 8226
8187: LD_INT 2
8189: DOUBLE
8190: EQUAL
8191: IFTRUE 8195
8193: GO 8206
8195: POP
// x := 8 ; 3 :
8196: LD_ADDR_VAR 0 2
8200: PUSH
8201: LD_INT 8
8203: ST_TO_ADDR
8204: GO 8226
8206: LD_INT 3
8208: DOUBLE
8209: EQUAL
8210: IFTRUE 8214
8212: GO 8225
8214: POP
// x := 2 ; end ;
8215: LD_ADDR_VAR 0 2
8219: PUSH
8220: LD_INT 2
8222: ST_TO_ADDR
8223: GO 8226
8225: POP
// repeat wait ( 0 0$1 ) ;
8226: LD_INT 35
8228: PPUSH
8229: CALL_OW 67
// until not HasTask ( Gali ) ;
8233: LD_EXP 27
8237: PPUSH
8238: CALL_OW 314
8242: NOT
8243: IFFALSE 8226
// for i = 1 to x do
8245: LD_ADDR_VAR 0 1
8249: PUSH
8250: DOUBLE
8251: LD_INT 1
8253: DEC
8254: ST_TO_ADDR
8255: LD_VAR 0 2
8259: PUSH
8260: FOR_TO
8261: IFFALSE 8426
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8263: LD_EXP 27
8267: PPUSH
8268: LD_VAR 0 4
8272: PPUSH
8273: LD_EXP 13
8277: PPUSH
8278: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8282: LD_EXP 27
8286: PPUSH
8287: LD_VAR 0 3
8291: PUSH
8292: LD_INT 1
8294: ARRAY
8295: PPUSH
8296: CALL_OW 172
// AddComHold ( Gali ) ;
8300: LD_EXP 27
8304: PPUSH
8305: CALL_OW 200
// repeat wait ( 3 ) ;
8309: LD_INT 3
8311: PPUSH
8312: CALL_OW 67
// if player_attacked_ar then
8316: LD_EXP 16
8320: IFFALSE 8326
// exit ;
8322: POP
8323: POP
8324: GO 9324
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8326: LD_EXP 27
8330: PPUSH
8331: LD_VAR 0 3
8335: PUSH
8336: LD_INT 1
8338: ARRAY
8339: PPUSH
8340: CALL_OW 296
8344: PUSH
8345: LD_INT 4
8347: LESS
8348: PUSH
8349: LD_EXP 27
8353: PPUSH
8354: LD_EXP 13
8358: PPUSH
8359: CALL_OW 289
8363: AND
8364: IFFALSE 8309
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8366: LD_VAR 0 3
8370: PUSH
8371: LD_INT 1
8373: ARRAY
8374: PPUSH
8375: LD_EXP 13
8379: PPUSH
8380: LD_VAR 0 3
8384: PUSH
8385: LD_INT 1
8387: ARRAY
8388: PPUSH
8389: LD_EXP 13
8393: PPUSH
8394: CALL_OW 289
8398: PUSH
8399: LD_INT 10
8401: PLUS
8402: PPUSH
8403: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8407: LD_EXP 27
8411: PPUSH
8412: LD_EXP 13
8416: PPUSH
8417: LD_INT 0
8419: PPUSH
8420: CALL_OW 290
// end ;
8424: GO 8260
8426: POP
8427: POP
// repeat wait ( 0 0$1 ) ;
8428: LD_INT 35
8430: PPUSH
8431: CALL_OW 67
// if player_attacked_ar then
8435: LD_EXP 16
8439: IFFALSE 8443
// exit ;
8441: GO 9324
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8443: LD_VAR 0 3
8447: PUSH
8448: LD_INT 1
8450: ARRAY
8451: PPUSH
8452: LD_EXP 13
8456: PPUSH
8457: CALL_OW 289
8461: PUSH
8462: LD_VAR 0 2
8466: PUSH
8467: LD_INT 10
8469: MUL
8470: EQUAL
8471: IFFALSE 8428
// no_oil_gain := false ;
8473: LD_ADDR_VAR 0 6
8477: PUSH
8478: LD_INT 0
8480: ST_TO_ADDR
// end else
8481: GO 8965
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8483: LD_ADDR_VAR 0 3
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 2
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: LD_INT 21
8500: PUSH
8501: LD_INT 2
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PUSH
8508: EMPTY
8509: LIST
8510: LIST
8511: PPUSH
8512: CALL_OW 69
8516: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8517: LD_EXP 27
8521: PPUSH
8522: LD_VAR 0 4
8526: PPUSH
8527: CALL_OW 250
8531: PUSH
8532: LD_INT 1
8534: PLUS
8535: PPUSH
8536: LD_VAR 0 4
8540: PPUSH
8541: CALL_OW 251
8545: PUSH
8546: LD_INT 1
8548: PLUS
8549: PPUSH
8550: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8554: LD_INT 35
8556: PPUSH
8557: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8561: LD_EXP 27
8565: PPUSH
8566: LD_VAR 0 4
8570: PPUSH
8571: CALL_OW 296
8575: PUSH
8576: LD_INT 4
8578: LESS
8579: IFFALSE 8554
// for i = 1 to 6 do
8581: LD_ADDR_VAR 0 1
8585: PUSH
8586: DOUBLE
8587: LD_INT 1
8589: DEC
8590: ST_TO_ADDR
8591: LD_INT 6
8593: PUSH
8594: FOR_TO
8595: IFFALSE 8792
// begin if player_attacked_ar then
8597: LD_EXP 16
8601: IFFALSE 8607
// exit ;
8603: POP
8604: POP
8605: GO 9324
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8607: LD_VAR 0 4
8611: PPUSH
8612: CALL_OW 274
8616: PPUSH
8617: LD_INT 2
8619: PPUSH
8620: CALL_OW 275
8624: PUSH
8625: LD_INT 10
8627: LESS
8628: PUSH
8629: LD_VAR 0 7
8633: NOT
8634: AND
8635: IFFALSE 8698
// begin first_warn := true ;
8637: LD_ADDR_VAR 0 7
8641: PUSH
8642: LD_INT 1
8644: ST_TO_ADDR
// DialogueOn ;
8645: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8649: LD_EXP 28
8653: PPUSH
8654: LD_STRING D9a-FAr1-1
8656: PPUSH
8657: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8661: LD_EXP 18
8665: PPUSH
8666: LD_STRING D9a-JMM-1
8668: PPUSH
8669: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8673: LD_EXP 26
8677: PPUSH
8678: LD_STRING D9a2-Ar1-1
8680: PPUSH
8681: CALL_OW 88
// DialogueOff ;
8685: CALL_OW 7
// wait ( time ) ;
8689: LD_VAR 0 5
8693: PPUSH
8694: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 274
8707: PPUSH
8708: LD_INT 2
8710: PPUSH
8711: CALL_OW 275
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: IFFALSE 8745
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8721: LD_EXP 26
8725: PPUSH
8726: LD_STRING D9a3-Ar1-1
8728: PPUSH
8729: CALL_OW 88
// no_oil_gain := true ;
8733: LD_ADDR_VAR 0 6
8737: PUSH
8738: LD_INT 1
8740: ST_TO_ADDR
// break ;
8741: GO 8792
// end else
8743: GO 8790
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8745: LD_EXP 27
8749: PPUSH
8750: LD_VAR 0 4
8754: PPUSH
8755: LD_INT 2
8757: PPUSH
8758: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8762: LD_EXP 27
8766: PPUSH
8767: LD_VAR 0 3
8771: PUSH
8772: LD_VAR 0 1
8776: PUSH
8777: LD_INT 3
8779: MOD
8780: PUSH
8781: LD_INT 1
8783: PLUS
8784: ARRAY
8785: PPUSH
8786: CALL_OW 210
// end ; end ;
8790: GO 8594
8792: POP
8793: POP
// repeat wait ( 0 0$1 ) ;
8794: LD_INT 35
8796: PPUSH
8797: CALL_OW 67
// if player_attacked_ar then
8801: LD_EXP 16
8805: IFFALSE 8809
// exit ;
8807: GO 9324
// for i in tmp do
8809: LD_ADDR_VAR 0 1
8813: PUSH
8814: LD_VAR 0 3
8818: PUSH
8819: FOR_IN
8820: IFFALSE 8851
// if GetFuel ( i ) < 100 then
8822: LD_VAR 0 1
8826: PPUSH
8827: CALL_OW 261
8831: PUSH
8832: LD_INT 100
8834: LESS
8835: IFFALSE 8849
// begin x := i ;
8837: LD_ADDR_VAR 0 2
8841: PUSH
8842: LD_VAR 0 1
8846: ST_TO_ADDR
// break ;
8847: GO 8851
// end ;
8849: GO 8819
8851: POP
8852: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8853: LD_EXP 27
8857: PPUSH
8858: CALL_OW 314
8862: NOT
8863: PUSH
8864: LD_EXP 27
8868: PPUSH
8869: CALL_OW 281
8873: NOT
8874: AND
8875: IFFALSE 8908
// begin ComTransport ( Gali , dep , mat_oil ) ;
8877: LD_EXP 27
8881: PPUSH
8882: LD_VAR 0 4
8886: PPUSH
8887: LD_INT 2
8889: PPUSH
8890: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8894: LD_EXP 27
8898: PPUSH
8899: LD_VAR 0 2
8903: PPUSH
8904: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8908: LD_VAR 0 3
8912: PUSH
8913: LD_INT 1
8915: ARRAY
8916: PPUSH
8917: CALL_OW 261
8921: PUSH
8922: LD_INT 80
8924: GREATER
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 2
8933: ARRAY
8934: PPUSH
8935: CALL_OW 261
8939: PUSH
8940: LD_INT 80
8942: GREATER
8943: AND
8944: PUSH
8945: LD_VAR 0 3
8949: PUSH
8950: LD_INT 3
8952: ARRAY
8953: PPUSH
8954: CALL_OW 261
8958: PUSH
8959: LD_INT 80
8961: GREATER
8962: AND
8963: IFFALSE 8794
// end ; ComHold ( Gali ) ;
8965: LD_EXP 27
8969: PPUSH
8970: CALL_OW 140
// if not no_oil_gain then
8974: LD_VAR 0 6
8978: NOT
8979: IFFALSE 9144
// begin DialogueOn ;
8981: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8985: LD_EXP 26
8989: PPUSH
8990: CALL_OW 87
// if player_want_mortar then
8994: LD_EXP 12
8998: IFFALSE 9024
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9000: LD_EXP 26
9004: PPUSH
9005: LD_STRING D9e-Ar1-1
9007: PPUSH
9008: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9012: LD_EXP 18
9016: PPUSH
9017: LD_STRING D10a-JMM-1
9019: PPUSH
9020: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9024: LD_EXP 26
9028: PPUSH
9029: LD_STRING D10a-Ar1-1
9031: PPUSH
9032: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9036: LD_EXP 27
9040: PPUSH
9041: LD_STRING D10a-Ar2-1
9043: PPUSH
9044: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9048: LD_EXP 28
9052: PPUSH
9053: LD_STRING D10a-FAr1-1
9055: PPUSH
9056: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9060: LD_EXP 27
9064: PPUSH
9065: LD_STRING D10a-Ar2-2
9067: PPUSH
9068: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9072: LD_EXP 28
9076: PPUSH
9077: LD_STRING D10a-FAr1-2
9079: PPUSH
9080: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9084: LD_EXP 26
9088: PPUSH
9089: LD_STRING D10a-Ar1-2
9091: PPUSH
9092: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9096: LD_EXP 18
9100: PPUSH
9101: LD_STRING D10a-JMM-2
9103: PPUSH
9104: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9108: LD_EXP 26
9112: PPUSH
9113: LD_STRING D10a-Ar1-3
9115: PPUSH
9116: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9120: LD_EXP 18
9124: PPUSH
9125: LD_STRING D10a-JMM-3
9127: PPUSH
9128: CALL_OW 88
// player_get_info := true ;
9132: LD_ADDR_EXP 15
9136: PUSH
9137: LD_INT 1
9139: ST_TO_ADDR
// DialogueOff ;
9140: CALL_OW 7
// end ; end ; if player_attacked_ar then
9144: LD_EXP 16
9148: IFFALSE 9152
// exit ;
9150: GO 9324
// if player_want_mortar or player_want_info then
9152: LD_EXP 12
9156: PUSH
9157: LD_EXP 13
9161: OR
9162: IFFALSE 9176
// Say ( Vervecken , D9f-Ar1-1 ) ;
9164: LD_EXP 26
9168: PPUSH
9169: LD_STRING D9f-Ar1-1
9171: PPUSH
9172: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9176: LD_INT 22
9178: PUSH
9179: LD_INT 2
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: PPUSH
9186: CALL_OW 69
9190: PPUSH
9191: LD_INT 51
9193: PPUSH
9194: LD_INT 99
9196: PPUSH
9197: CALL_OW 111
// wait ( 0 0$1 ) ;
9201: LD_INT 35
9203: PPUSH
9204: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9208: LD_INT 22
9210: PUSH
9211: LD_INT 2
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: PUSH
9218: LD_INT 92
9220: PUSH
9221: LD_INT 51
9223: PUSH
9224: LD_INT 99
9226: PUSH
9227: LD_INT 2
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: PPUSH
9240: CALL_OW 69
9244: IFFALSE 9304
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9246: LD_ADDR_VAR 0 1
9250: PUSH
9251: LD_INT 22
9253: PUSH
9254: LD_INT 2
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: LD_INT 92
9263: PUSH
9264: LD_INT 51
9266: PUSH
9267: LD_INT 99
9269: PUSH
9270: LD_INT 2
9272: PUSH
9273: EMPTY
9274: LIST
9275: LIST
9276: LIST
9277: LIST
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: PPUSH
9283: CALL_OW 69
9287: PUSH
9288: FOR_IN
9289: IFFALSE 9302
// RemoveUnit ( i ) ;
9291: LD_VAR 0 1
9295: PPUSH
9296: CALL_OW 64
9300: GO 9288
9302: POP
9303: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9304: LD_INT 22
9306: PUSH
9307: LD_INT 2
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: PUSH
9319: LD_INT 0
9321: EQUAL
9322: IFFALSE 9176
// end ;
9324: PPOPN 8
9326: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9327: LD_EXP 16
9331: IFFALSE 9684
9333: GO 9335
9335: DISABLE
9336: LD_INT 0
9338: PPUSH
9339: PPUSH
9340: PPUSH
9341: PPUSH
// begin ru_can_attack := true ;
9342: LD_ADDR_EXP 8
9346: PUSH
9347: LD_INT 1
9349: ST_TO_ADDR
// mine_launched := false ;
9350: LD_ADDR_VAR 0 3
9354: PUSH
9355: LD_INT 0
9357: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9358: LD_INT 22
9360: PUSH
9361: LD_INT 2
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PPUSH
9368: CALL_OW 69
9372: PPUSH
9373: LD_INT 51
9375: PPUSH
9376: LD_INT 99
9378: PPUSH
9379: CALL_OW 111
// if IsOk ( Vervecken ) then
9383: LD_EXP 26
9387: PPUSH
9388: CALL_OW 302
9392: IFFALSE 9406
// Say ( Vervecken , D11a-Ar1-1 ) ;
9394: LD_EXP 26
9398: PPUSH
9399: LD_STRING D11a-Ar1-1
9401: PPUSH
9402: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9406: LD_ADDR_VAR 0 2
9410: PUSH
9411: LD_EXP 33
9415: PPUSH
9416: LD_INT 25
9418: PUSH
9419: LD_INT 1
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PPUSH
9426: CALL_OW 72
9430: ST_TO_ADDR
// for i in tmp do
9431: LD_ADDR_VAR 0 1
9435: PUSH
9436: LD_VAR 0 2
9440: PUSH
9441: FOR_IN
9442: IFFALSE 9505
// if MineOfUnit ( i ) then
9444: LD_VAR 0 1
9448: PPUSH
9449: CALL_OW 459
9453: IFFALSE 9503
// begin x := MineOfUnit ( i ) ;
9455: LD_ADDR_VAR 0 4
9459: PUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: CALL_OW 459
9469: ST_TO_ADDR
// mine_launched := true ;
9470: LD_ADDR_VAR 0 3
9474: PUSH
9475: LD_INT 1
9477: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9478: LD_VAR 0 4
9482: PUSH
9483: LD_INT 1
9485: ARRAY
9486: PPUSH
9487: LD_VAR 0 4
9491: PUSH
9492: LD_INT 2
9494: ARRAY
9495: PPUSH
9496: LD_INT 2
9498: PPUSH
9499: CALL_OW 456
// end ;
9503: GO 9441
9505: POP
9506: POP
// if mine_launched and IsOk ( Vervecken ) then
9507: LD_VAR 0 3
9511: PUSH
9512: LD_EXP 26
9516: PPUSH
9517: CALL_OW 302
9521: AND
9522: IFFALSE 9536
// Say ( Vervecken , D11b-Ar1-1 ) ;
9524: LD_EXP 26
9528: PPUSH
9529: LD_STRING D11b-Ar1-1
9531: PPUSH
9532: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9536: LD_INT 22
9538: PUSH
9539: LD_INT 2
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: PPUSH
9546: CALL_OW 69
9550: PPUSH
9551: LD_INT 51
9553: PPUSH
9554: LD_INT 99
9556: PPUSH
9557: CALL_OW 111
// wait ( 0 0$1 ) ;
9561: LD_INT 35
9563: PPUSH
9564: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9568: LD_INT 22
9570: PUSH
9571: LD_INT 2
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PUSH
9578: LD_INT 92
9580: PUSH
9581: LD_INT 51
9583: PUSH
9584: LD_INT 99
9586: PUSH
9587: LD_INT 2
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: LIST
9594: LIST
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PPUSH
9600: CALL_OW 69
9604: IFFALSE 9664
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9606: LD_ADDR_VAR 0 1
9610: PUSH
9611: LD_INT 22
9613: PUSH
9614: LD_INT 2
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PUSH
9621: LD_INT 92
9623: PUSH
9624: LD_INT 51
9626: PUSH
9627: LD_INT 99
9629: PUSH
9630: LD_INT 2
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: PPUSH
9643: CALL_OW 69
9647: PUSH
9648: FOR_IN
9649: IFFALSE 9662
// RemoveUnit ( i ) ;
9651: LD_VAR 0 1
9655: PPUSH
9656: CALL_OW 64
9660: GO 9648
9662: POP
9663: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9664: LD_INT 22
9666: PUSH
9667: LD_INT 2
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PPUSH
9674: CALL_OW 69
9678: PUSH
9679: LD_INT 0
9681: EQUAL
9682: IFFALSE 9536
// end ;
9684: PPOPN 4
9686: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9687: LD_EXP 10
9691: IFFALSE 9870
9693: GO 9695
9695: DISABLE
9696: LD_INT 0
9698: PPUSH
// begin Wait ( 10 10$00 ) ;
9699: LD_INT 21000
9701: PPUSH
9702: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9706: LD_INT 22
9708: PUSH
9709: LD_INT 2
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: PPUSH
9716: CALL_OW 69
9720: IFFALSE 9870
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9722: LD_INT 22
9724: PUSH
9725: LD_INT 2
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: PPUSH
9732: CALL_OW 69
9736: PPUSH
9737: LD_INT 51
9739: PPUSH
9740: LD_INT 99
9742: PPUSH
9743: CALL_OW 114
// wait ( 0 0$1 ) ;
9747: LD_INT 35
9749: PPUSH
9750: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9754: LD_INT 22
9756: PUSH
9757: LD_INT 2
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 92
9766: PUSH
9767: LD_INT 51
9769: PUSH
9770: LD_INT 99
9772: PUSH
9773: LD_INT 2
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 69
9790: IFFALSE 9850
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9792: LD_ADDR_VAR 0 1
9796: PUSH
9797: LD_INT 22
9799: PUSH
9800: LD_INT 2
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PUSH
9807: LD_INT 92
9809: PUSH
9810: LD_INT 51
9812: PUSH
9813: LD_INT 99
9815: PUSH
9816: LD_INT 2
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PPUSH
9829: CALL_OW 69
9833: PUSH
9834: FOR_IN
9835: IFFALSE 9848
// RemoveUnit ( i ) ;
9837: LD_VAR 0 1
9841: PPUSH
9842: CALL_OW 64
9846: GO 9834
9848: POP
9849: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9850: LD_INT 22
9852: PUSH
9853: LD_INT 2
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: PPUSH
9860: CALL_OW 69
9864: PUSH
9865: LD_INT 0
9867: EQUAL
9868: IFFALSE 9722
// end ; end ;
9870: PPOPN 1
9872: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9873: LD_EXP 4
9877: IFFALSE 10805
9879: GO 9881
9881: DISABLE
9882: LD_INT 0
9884: PPUSH
9885: PPUSH
9886: PPUSH
// begin Wait ( game_time ) ;
9887: LD_EXP 7
9891: PPUSH
9892: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9896: LD_INT 35
9898: PPUSH
9899: CALL_OW 67
// until ( not ru_can_attack ) ;
9903: LD_EXP 8
9907: NOT
9908: IFFALSE 9896
// Wait ( 0 0$35 ) ;
9910: LD_INT 1225
9912: PPUSH
9913: CALL_OW 67
// DialogueOn ;
9917: CALL_OW 6
// InGameOn ;
9921: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9925: LD_EXP 25
9929: PPUSH
9930: LD_STRING D12-Pow-1
9932: PPUSH
9933: CALL_OW 94
// InGameOff ;
9937: CALL_OW 9
// DialogueOff ;
9941: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9945: LD_STRING M4
9947: PPUSH
9948: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9952: LD_INT 5
9954: PPUSH
9955: LD_INT 1
9957: PPUSH
9958: CALL_OW 424
// can_end := true ;
9962: LD_ADDR_EXP 17
9966: PUSH
9967: LD_INT 1
9969: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9970: LD_INT 35
9972: PPUSH
9973: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9977: CALL 784 0 0
9981: PUSH
9982: LD_INT 20
9984: GREATEREQUAL
9985: PUSH
9986: LD_INT 22
9988: PUSH
9989: LD_INT 1
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PUSH
9996: LD_INT 21
9998: PUSH
9999: LD_INT 1
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PPUSH
10010: CALL_OW 69
10014: PUSH
10015: LD_INT 5
10017: PPUSH
10018: LD_INT 22
10020: PUSH
10021: LD_INT 1
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: PUSH
10028: LD_INT 21
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 70
10046: PUSH
10047: LD_INT 22
10049: PUSH
10050: LD_INT 1
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: LD_INT 55
10059: PUSH
10060: EMPTY
10061: LIST
10062: PUSH
10063: EMPTY
10064: LIST
10065: LIST
10066: PPUSH
10067: CALL_OW 69
10071: PLUS
10072: LESSEQUAL
10073: AND
10074: IFFALSE 9970
// if not player_get_info then
10076: LD_EXP 15
10080: NOT
10081: IFFALSE 10092
// player_get_info := - 1 ;
10083: LD_ADDR_EXP 15
10087: PUSH
10088: LD_INT 1
10090: NEG
10091: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10092: LD_STRING Information
10094: PPUSH
10095: LD_EXP 15
10099: PPUSH
10100: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10104: LD_ADDR_VAR 0 2
10108: PUSH
10109: LD_INT 22
10111: PUSH
10112: LD_INT 1
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: LD_INT 25
10124: PUSH
10125: LD_INT 2
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: PUSH
10132: LD_INT 25
10134: PUSH
10135: LD_INT 16
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: PUSH
10142: LD_INT 34
10144: PUSH
10145: LD_INT 12
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: EMPTY
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PPUSH
10162: CALL_OW 69
10166: ST_TO_ADDR
// sib := GetTerminalCargo ;
10167: LD_ADDR_VAR 0 3
10171: PUSH
10172: CALL 784 0 0
10176: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10177: LD_ADDR_VAR 0 3
10181: PUSH
10182: LD_VAR 0 3
10186: PUSH
10187: LD_INT 6
10189: PPUSH
10190: LD_INT 3
10192: PPUSH
10193: CALL_OW 287
10197: PLUS
10198: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10199: LD_ADDR_VAR 0 3
10203: PUSH
10204: LD_VAR 0 3
10208: PUSH
10209: LD_VAR 0 2
10213: PPUSH
10214: LD_INT 3
10216: PPUSH
10217: CALL_OW 289
10221: PLUS
10222: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10223: LD_VAR 0 3
10227: PUSH
10228: LD_INT 2
10230: PUSH
10231: LD_OWVAR 67
10235: PLUS
10236: PUSH
10237: LD_INT 50
10239: MUL
10240: LESS
10241: IFFALSE 10266
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10243: LD_STRING MuchSiberite
10245: PPUSH
10246: LD_INT 2
10248: NEG
10249: PUSH
10250: LD_OWVAR 67
10254: MUL
10255: PUSH
10256: LD_INT 1
10258: PLUS
10259: PPUSH
10260: CALL_OW 101
10264: GO 10276
// AddMedal ( MuchSiberite , 1 ) ;
10266: LD_STRING MuchSiberite
10268: PPUSH
10269: LD_INT 1
10271: PPUSH
10272: CALL_OW 101
// GiveMedals ( MAIN ) ;
10276: LD_STRING MAIN
10278: PPUSH
10279: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10283: LD_INT 22
10285: PUSH
10286: LD_INT 1
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 2
10295: PUSH
10296: LD_INT 25
10298: PUSH
10299: LD_INT 1
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PUSH
10306: LD_INT 25
10308: PUSH
10309: LD_INT 2
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: PUSH
10316: LD_INT 25
10318: PUSH
10319: LD_INT 3
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: PUSH
10326: LD_INT 25
10328: PUSH
10329: LD_INT 4
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 25
10338: PUSH
10339: LD_INT 8
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: PPUSH
10358: CALL_OW 69
10362: PPUSH
10363: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10367: LD_ADDR_VAR 0 2
10371: PUSH
10372: LD_INT 22
10374: PUSH
10375: LD_INT 1
10377: PUSH
10378: EMPTY
10379: LIST
10380: LIST
10381: PUSH
10382: LD_INT 25
10384: PUSH
10385: LD_INT 8
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: PPUSH
10396: CALL_OW 69
10400: ST_TO_ADDR
// if tmp then
10401: LD_VAR 0 2
10405: IFFALSE 10436
// for i in tmp do
10407: LD_ADDR_VAR 0 1
10411: PUSH
10412: LD_VAR 0 2
10416: PUSH
10417: FOR_IN
10418: IFFALSE 10434
// SetClass ( i , 1 ) ;
10420: LD_VAR 0 1
10424: PPUSH
10425: LD_INT 1
10427: PPUSH
10428: CALL_OW 336
10432: GO 10417
10434: POP
10435: POP
// SaveVariable ( sib , 09_sibRes ) ;
10436: LD_VAR 0 3
10440: PPUSH
10441: LD_STRING 09_sibRes
10443: PPUSH
10444: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10448: LD_EXP 15
10452: PPUSH
10453: LD_STRING 09_arInfo
10455: PPUSH
10456: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10460: LD_EXP 18
10464: PPUSH
10465: LD_EXP 1
10469: PUSH
10470: LD_STRING JMM
10472: STR
10473: PPUSH
10474: CALL_OW 38
// if IsLive ( Gary ) then
10478: LD_EXP 19
10482: PPUSH
10483: CALL_OW 300
10487: IFFALSE 10507
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10489: LD_EXP 19
10493: PPUSH
10494: LD_EXP 1
10498: PUSH
10499: LD_STRING Gary
10501: STR
10502: PPUSH
10503: CALL_OW 38
// if IsLive ( Bobby ) then
10507: LD_EXP 20
10511: PPUSH
10512: CALL_OW 300
10516: IFFALSE 10536
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10518: LD_EXP 20
10522: PPUSH
10523: LD_EXP 1
10527: PUSH
10528: LD_STRING Bobby
10530: STR
10531: PPUSH
10532: CALL_OW 38
// if IsLive ( Cyrus ) then
10536: LD_EXP 21
10540: PPUSH
10541: CALL_OW 300
10545: IFFALSE 10565
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10547: LD_EXP 21
10551: PPUSH
10552: LD_EXP 1
10556: PUSH
10557: LD_STRING Cyrus
10559: STR
10560: PPUSH
10561: CALL_OW 38
// if IsLive ( Houten ) then
10565: LD_EXP 22
10569: PPUSH
10570: CALL_OW 300
10574: IFFALSE 10594
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10576: LD_EXP 22
10580: PPUSH
10581: LD_EXP 1
10585: PUSH
10586: LD_STRING Houten
10588: STR
10589: PPUSH
10590: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10594: LD_ADDR_VAR 0 2
10598: PUSH
10599: LD_INT 22
10601: PUSH
10602: LD_INT 1
10604: PUSH
10605: EMPTY
10606: LIST
10607: LIST
10608: PUSH
10609: LD_INT 2
10611: PUSH
10612: LD_INT 25
10614: PUSH
10615: LD_INT 1
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PUSH
10622: LD_INT 25
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PUSH
10632: LD_INT 25
10634: PUSH
10635: LD_INT 3
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: PUSH
10642: LD_INT 25
10644: PUSH
10645: LD_INT 4
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 69
10667: PUSH
10668: LD_EXP 18
10672: PUSH
10673: LD_EXP 21
10677: PUSH
10678: LD_EXP 20
10682: PUSH
10683: LD_EXP 22
10687: PUSH
10688: LD_EXP 19
10692: PUSH
10693: EMPTY
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: DIFF
10700: ST_TO_ADDR
// if tmp then
10701: LD_VAR 0 2
10705: IFFALSE 10725
// SaveCharacters ( tmp , mission_prefix & others ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: LD_EXP 1
10716: PUSH
10717: LD_STRING others
10719: STR
10720: PPUSH
10721: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10725: LD_ADDR_VAR 0 2
10729: PUSH
10730: LD_INT 22
10732: PUSH
10733: LD_INT 1
10735: PUSH
10736: EMPTY
10737: LIST
10738: LIST
10739: PUSH
10740: LD_INT 2
10742: PUSH
10743: LD_INT 25
10745: PUSH
10746: LD_INT 12
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PUSH
10753: LD_INT 25
10755: PUSH
10756: LD_INT 16
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: LIST
10767: PUSH
10768: EMPTY
10769: LIST
10770: LIST
10771: PPUSH
10772: CALL_OW 69
10776: ST_TO_ADDR
// if tmp then
10777: LD_VAR 0 2
10781: IFFALSE 10801
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10783: LD_VAR 0 2
10787: PPUSH
10788: LD_EXP 1
10792: PUSH
10793: LD_STRING apes
10795: STR
10796: PPUSH
10797: CALL_OW 38
// YouWin ;
10801: CALL_OW 103
// end ; end_of_file
10805: PPOPN 3
10807: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10808: LD_VAR 0 1
10812: PPUSH
10813: CALL_OW 266
10817: PUSH
10818: LD_INT 0
10820: EQUAL
10821: PUSH
10822: LD_EXP 3
10826: NOT
10827: AND
10828: IFFALSE 10852
// begin terminal := b ;
10830: LD_ADDR_EXP 3
10834: PUSH
10835: LD_VAR 0 1
10839: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10840: LD_EXP 3
10844: PPUSH
10845: LD_STRING terminal
10847: PPUSH
10848: CALL_OW 500
// end ; end ;
10852: PPOPN 2
10854: END
// on BuildingComplete ( b ) do var i ;
10855: LD_INT 0
10857: PPUSH
// begin if GetSide ( b ) = 3 then
10858: LD_VAR 0 1
10862: PPUSH
10863: CALL_OW 255
10867: PUSH
10868: LD_INT 3
10870: EQUAL
10871: IFFALSE 10911
// for i = 1 to 4 do
10873: LD_ADDR_VAR 0 2
10877: PUSH
10878: DOUBLE
10879: LD_INT 1
10881: DEC
10882: ST_TO_ADDR
10883: LD_INT 4
10885: PUSH
10886: FOR_TO
10887: IFFALSE 10909
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10889: LD_ADDR_EXP 36
10893: PUSH
10894: LD_EXP 36
10898: PPUSH
10899: LD_INT 1
10901: PPUSH
10902: CALL_OW 3
10906: ST_TO_ADDR
10907: GO 10886
10909: POP
10910: POP
// end ;
10911: PPOPN 2
10913: END
// on VehicleConstructed ( veh , fac ) do var i ;
10914: LD_INT 0
10916: PPUSH
// begin if GetSide ( veh ) = 3 then
10917: LD_VAR 0 1
10921: PPUSH
10922: CALL_OW 255
10926: PUSH
10927: LD_INT 3
10929: EQUAL
10930: IFFALSE 11055
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10932: LD_VAR 0 1
10936: PPUSH
10937: CALL_OW 264
10941: PUSH
10942: LD_INT 53
10944: PUSH
10945: LD_INT 52
10947: PUSH
10948: LD_INT 51
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: IN
10956: NOT
10957: IFFALSE 10975
// ru_force := ru_force ^ veh ;
10959: LD_ADDR_EXP 35
10963: PUSH
10964: LD_EXP 35
10968: PUSH
10969: LD_VAR 0 1
10973: ADD
10974: ST_TO_ADDR
// for i = 1 to 4 do
10975: LD_ADDR_VAR 0 3
10979: PUSH
10980: DOUBLE
10981: LD_INT 1
10983: DEC
10984: ST_TO_ADDR
10985: LD_INT 4
10987: PUSH
10988: FOR_TO
10989: IFFALSE 11011
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10991: LD_ADDR_EXP 37
10995: PUSH
10996: LD_EXP 37
11000: PPUSH
11001: LD_INT 1
11003: PPUSH
11004: CALL_OW 3
11008: ST_TO_ADDR
11009: GO 10988
11011: POP
11012: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11013: LD_VAR 0 1
11017: PPUSH
11018: CALL_OW 264
11022: PUSH
11023: LD_INT 53
11025: EQUAL
11026: IFFALSE 11055
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11028: LD_VAR 0 1
11032: PPUSH
11033: LD_INT 7
11035: PPUSH
11036: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11040: LD_VAR 0 1
11044: PPUSH
11045: LD_INT 170
11047: PPUSH
11048: LD_INT 235
11050: PPUSH
11051: CALL_OW 171
// end ; end ; end ;
11055: PPOPN 3
11057: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11058: LD_VAR 0 1
11062: PUSH
11063: LD_INT 1
11065: EQUAL
11066: PUSH
11067: LD_VAR 0 2
11071: PUSH
11072: LD_INT 2
11074: EQUAL
11075: AND
11076: PUSH
11077: LD_VAR 0 1
11081: PUSH
11082: LD_INT 2
11084: EQUAL
11085: PUSH
11086: LD_VAR 0 2
11090: PUSH
11091: LD_INT 1
11093: EQUAL
11094: AND
11095: OR
11096: IFFALSE 11106
// player_attacked_ar := true ;
11098: LD_ADDR_EXP 16
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11106: LD_VAR 0 1
11110: PUSH
11111: LD_INT 1
11113: EQUAL
11114: PUSH
11115: LD_VAR 0 2
11119: PUSH
11120: LD_INT 4
11122: EQUAL
11123: AND
11124: PUSH
11125: LD_VAR 0 1
11129: PUSH
11130: LD_INT 4
11132: EQUAL
11133: PUSH
11134: LD_VAR 0 2
11138: PUSH
11139: LD_INT 1
11141: EQUAL
11142: AND
11143: OR
11144: IFFALSE 11153
// YouLost ( Traitor ) ;
11146: LD_STRING Traitor
11148: PPUSH
11149: CALL_OW 104
// end ;
11153: PPOPN 2
11155: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11156: LD_VAR 0 1
11160: PUSH
11161: LD_EXP 18
11165: EQUAL
11166: IFFALSE 11175
// YouLost ( JMM ) ;
11168: LD_STRING JMM
11170: PPUSH
11171: CALL_OW 104
// if un = terminal then
11175: LD_VAR 0 1
11179: PUSH
11180: LD_EXP 3
11184: EQUAL
11185: IFFALSE 11194
// YouLost ( Terminal ) ;
11187: LD_STRING Terminal
11189: PPUSH
11190: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11194: LD_VAR 0 1
11198: PUSH
11199: LD_INT 22
11201: PUSH
11202: LD_INT 3
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: PUSH
11209: LD_INT 21
11211: PUSH
11212: LD_INT 3
11214: PUSH
11215: EMPTY
11216: LIST
11217: LIST
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: IN
11228: IFFALSE 11374
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11230: LD_VAR 0 1
11234: PPUSH
11235: CALL_OW 266
11239: PUSH
11240: LD_INT 33
11242: PUSH
11243: LD_INT 26
11245: PUSH
11246: EMPTY
11247: LIST
11248: LIST
11249: IN
11250: IFFALSE 11309
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11252: LD_ADDR_EXP 36
11256: PUSH
11257: LD_EXP 36
11261: PUSH
11262: LD_VAR 0 1
11266: PPUSH
11267: CALL_OW 266
11271: PUSH
11272: LD_VAR 0 1
11276: PPUSH
11277: CALL_OW 250
11281: PUSH
11282: LD_VAR 0 1
11286: PPUSH
11287: CALL_OW 251
11291: PUSH
11292: LD_VAR 0 1
11296: PPUSH
11297: CALL_OW 254
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: ADD
11308: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11309: LD_VAR 0 1
11313: PPUSH
11314: CALL_OW 266
11318: PUSH
11319: LD_INT 5
11321: EQUAL
11322: IFFALSE 11374
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11324: LD_ADDR_EXP 36
11328: PUSH
11329: LD_EXP 36
11333: PUSH
11334: LD_INT 4
11336: PUSH
11337: LD_VAR 0 1
11341: PPUSH
11342: CALL_OW 250
11346: PUSH
11347: LD_VAR 0 1
11351: PPUSH
11352: CALL_OW 251
11356: PUSH
11357: LD_VAR 0 1
11361: PPUSH
11362: CALL_OW 254
11366: PUSH
11367: EMPTY
11368: LIST
11369: LIST
11370: LIST
11371: LIST
11372: ADD
11373: ST_TO_ADDR
// end ; if un in ru_force then
11374: LD_VAR 0 1
11378: PUSH
11379: LD_EXP 35
11383: IN
11384: IFFALSE 11420
// begin ru_force := ru_force diff un ;
11386: LD_ADDR_EXP 35
11390: PUSH
11391: LD_EXP 35
11395: PUSH
11396: LD_VAR 0 1
11400: DIFF
11401: ST_TO_ADDR
// if ru_force = 0 then
11402: LD_EXP 35
11406: PUSH
11407: LD_INT 0
11409: EQUAL
11410: IFFALSE 11420
// ru_can_attack := false ;
11412: LD_ADDR_EXP 8
11416: PUSH
11417: LD_INT 0
11419: ST_TO_ADDR
// end ; end ; end_of_file
11420: PPOPN 1
11422: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11423: LD_EXP 5
11427: PUSH
11428: LD_EXP 6
11432: AND
11433: IFFALSE 11511
11435: GO 11437
11437: DISABLE
11438: LD_INT 0
11440: PPUSH
// begin enable ;
11441: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11442: LD_ADDR_VAR 0 1
11446: PUSH
11447: LD_INT 60
11449: PUSH
11450: CALL 784 0 0
11454: MINUS
11455: ST_TO_ADDR
// if sib < 0 then
11456: LD_VAR 0 1
11460: PUSH
11461: LD_INT 0
11463: LESS
11464: IFFALSE 11474
// sib := 0 ;
11466: LD_ADDR_VAR 0 1
11470: PUSH
11471: LD_INT 0
11473: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11474: LD_ADDR_OWVAR 47
11478: PUSH
11479: LD_STRING #Am09-1
11481: PUSH
11482: LD_VAR 0 1
11486: PUSH
11487: LD_EXP 6
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: LIST
11496: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11497: LD_ADDR_EXP 6
11501: PUSH
11502: LD_EXP 6
11506: PUSH
11507: LD_INT 35
11509: MINUS
11510: ST_TO_ADDR
// end ;
11511: PPOPN 1
11513: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11514: LD_EXP 6
11518: PUSH
11519: LD_INT 0
11521: EQUAL
11522: IFFALSE 11534
11524: GO 11526
11526: DISABLE
// display_strings := [ ] ;
11527: LD_ADDR_OWVAR 47
11531: PUSH
11532: EMPTY
11533: ST_TO_ADDR
11534: END
// every 0 0$01 trigger ru_force and debug do
11535: LD_EXP 35
11539: PUSH
11540: LD_EXP 2
11544: AND
11545: IFFALSE 11561
11547: GO 11549
11549: DISABLE
// begin enable ;
11550: ENABLE
// display_strings := ru_force ;
11551: LD_ADDR_OWVAR 47
11555: PUSH
11556: LD_EXP 35
11560: ST_TO_ADDR
// end ;
11561: END
// every 1 1$35 do var i , tmp ;
11562: GO 11564
11564: DISABLE
11565: LD_INT 0
11567: PPUSH
11568: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11569: LD_ADDR_VAR 0 2
11573: PUSH
11574: LD_INT 1155
11576: PUSH
11577: LD_INT 1225
11579: PUSH
11580: LD_INT 1435
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: LIST
11587: PUSH
11588: LD_OWVAR 67
11592: ARRAY
11593: ST_TO_ADDR
// i := 0 ;
11594: LD_ADDR_VAR 0 1
11598: PUSH
11599: LD_INT 0
11601: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11602: LD_INT 1
11604: PPUSH
11605: LD_INT 5
11607: PPUSH
11608: CALL_OW 12
11612: PPUSH
11613: LD_INT 75
11615: PPUSH
11616: LD_INT 75
11618: PPUSH
11619: LD_INT 20
11621: PPUSH
11622: LD_INT 1
11624: PPUSH
11625: CALL_OW 56
// wait ( tmp ) ;
11629: LD_VAR 0 2
11633: PPUSH
11634: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11638: LD_ADDR_VAR 0 2
11642: PUSH
11643: LD_VAR 0 2
11647: PUSH
11648: LD_INT 105
11650: PPUSH
11651: LD_INT 315
11653: PPUSH
11654: CALL_OW 12
11658: PLUS
11659: ST_TO_ADDR
// i := i + 1 ;
11660: LD_ADDR_VAR 0 1
11664: PUSH
11665: LD_VAR 0 1
11669: PUSH
11670: LD_INT 1
11672: PLUS
11673: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11674: LD_VAR 0 1
11678: PUSH
11679: LD_INT 3
11681: MOD
11682: PUSH
11683: LD_INT 0
11685: EQUAL
11686: PUSH
11687: LD_EXP 4
11691: AND
11692: IFFALSE 11730
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11694: LD_INT 2
11696: PPUSH
11697: LD_INT 5
11699: PPUSH
11700: CALL_OW 12
11704: PPUSH
11705: LD_INT 8
11707: PPUSH
11708: LD_INT 1
11710: PPUSH
11711: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11715: LD_INT 665
11717: PPUSH
11718: LD_INT 735
11720: PPUSH
11721: CALL_OW 12
11725: PPUSH
11726: CALL_OW 67
// end ; until tick > game_time ;
11730: LD_OWVAR 1
11734: PUSH
11735: LD_EXP 7
11739: GREATER
11740: IFFALSE 11602
// end ; end_of_file
11742: PPOPN 2
11744: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11745: LD_INT 0
11747: PPUSH
11748: PPUSH
11749: PPUSH
11750: PPUSH
11751: PPUSH
11752: PPUSH
// x := 76 ;
11753: LD_ADDR_VAR 0 5
11757: PUSH
11758: LD_INT 76
11760: ST_TO_ADDR
// y := 147 ;
11761: LD_ADDR_VAR 0 6
11765: PUSH
11766: LD_INT 147
11768: ST_TO_ADDR
// uc_side := 2 ;
11769: LD_ADDR_OWVAR 20
11773: PUSH
11774: LD_INT 2
11776: ST_TO_ADDR
// uc_nation := 2 ;
11777: LD_ADDR_OWVAR 21
11781: PUSH
11782: LD_INT 2
11784: ST_TO_ADDR
// InitHc ;
11785: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11789: LD_INT 1
11791: PPUSH
11792: LD_INT 1
11794: PPUSH
11795: LD_INT 6
11797: PPUSH
11798: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11802: LD_ADDR_OWVAR 26
11806: PUSH
11807: LD_STRING Nicolas Vervecken
11809: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11810: LD_ADDR_OWVAR 33
11814: PUSH
11815: LD_STRING SecondCharsGal
11817: ST_TO_ADDR
// hc_face_number := 3 ;
11818: LD_ADDR_OWVAR 34
11822: PUSH
11823: LD_INT 3
11825: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11826: LD_ADDR_OWVAR 29
11830: PUSH
11831: LD_INT 11
11833: PUSH
11834: LD_INT 10
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: ST_TO_ADDR
// Vervecken := CreateHuman ;
11841: LD_ADDR_EXP 26
11845: PUSH
11846: CALL_OW 44
11850: ST_TO_ADDR
// ar_force := Vervecken ;
11851: LD_ADDR_EXP 33
11855: PUSH
11856: LD_EXP 26
11860: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11861: LD_INT 1
11863: PPUSH
11864: LD_INT 2
11866: PPUSH
11867: LD_INT 6
11869: PPUSH
11870: CALL_OW 380
// hc_name := Louis Gali ;
11874: LD_ADDR_OWVAR 26
11878: PUSH
11879: LD_STRING Louis Gali
11881: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11882: LD_ADDR_OWVAR 33
11886: PUSH
11887: LD_STRING SecondCharsGal
11889: ST_TO_ADDR
// hc_face_number := 2 ;
11890: LD_ADDR_OWVAR 34
11894: PUSH
11895: LD_INT 2
11897: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11898: LD_ADDR_OWVAR 29
11902: PUSH
11903: LD_INT 10
11905: PUSH
11906: LD_INT 11
11908: PUSH
11909: EMPTY
11910: LIST
11911: LIST
11912: ST_TO_ADDR
// Gali := CreateHuman ;
11913: LD_ADDR_EXP 27
11917: PUSH
11918: CALL_OW 44
11922: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11923: LD_ADDR_EXP 33
11927: PUSH
11928: LD_EXP 33
11932: PUSH
11933: LD_EXP 27
11937: ADD
11938: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11939: LD_INT 2
11941: PPUSH
11942: LD_INT 1
11944: PPUSH
11945: LD_INT 6
11947: PPUSH
11948: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11952: LD_ADDR_OWVAR 26
11956: PUSH
11957: LD_STRING Maria Bogdanovic
11959: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11960: LD_ADDR_OWVAR 33
11964: PUSH
11965: LD_STRING SecondCharsGal
11967: ST_TO_ADDR
// hc_face_number := 14 ;
11968: LD_ADDR_OWVAR 34
11972: PUSH
11973: LD_INT 14
11975: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11976: LD_ADDR_OWVAR 29
11980: PUSH
11981: LD_INT 12
11983: PUSH
11984: LD_INT 9
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11991: LD_ADDR_EXP 28
11995: PUSH
11996: CALL_OW 44
12000: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12001: LD_ADDR_EXP 33
12005: PUSH
12006: LD_EXP 33
12010: PUSH
12011: LD_EXP 28
12015: ADD
12016: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12017: LD_INT 1
12019: PPUSH
12020: LD_INT 3
12022: PPUSH
12023: LD_INT 6
12025: PPUSH
12026: CALL_OW 380
// hc_name = Kntor Radomr ;
12030: LD_ADDR_OWVAR 26
12034: PUSH
12035: LD_STRING Kntor Radomr
12037: ST_TO_ADDR
// hc_gallery = sandar ;
12038: LD_ADDR_OWVAR 33
12042: PUSH
12043: LD_STRING sandar
12045: ST_TO_ADDR
// hc_face_number = 12 ;
12046: LD_ADDR_OWVAR 34
12050: PUSH
12051: LD_INT 12
12053: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12054: LD_ADDR_OWVAR 29
12058: PUSH
12059: LD_INT 9
12061: PUSH
12062: LD_INT 9
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: ST_TO_ADDR
// Kantor = CreateHuman ;
12069: LD_ADDR_EXP 29
12073: PUSH
12074: CALL_OW 44
12078: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12079: LD_ADDR_EXP 33
12083: PUSH
12084: LD_EXP 33
12088: PUSH
12089: LD_EXP 29
12093: ADD
12094: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12095: LD_INT 1
12097: PPUSH
12098: LD_INT 3
12100: PPUSH
12101: LD_INT 6
12103: PPUSH
12104: CALL_OW 380
// hc_name = Herczeg Farkas ;
12108: LD_ADDR_OWVAR 26
12112: PUSH
12113: LD_STRING Herczeg Farkas
12115: ST_TO_ADDR
// hc_gallery = sandar ;
12116: LD_ADDR_OWVAR 33
12120: PUSH
12121: LD_STRING sandar
12123: ST_TO_ADDR
// hc_face_number = 28 ;
12124: LD_ADDR_OWVAR 34
12128: PUSH
12129: LD_INT 28
12131: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12132: LD_ADDR_OWVAR 29
12136: PUSH
12137: LD_INT 10
12139: PUSH
12140: LD_INT 9
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: ST_TO_ADDR
// Herczeg = CreateHuman ;
12147: LD_ADDR_EXP 30
12151: PUSH
12152: CALL_OW 44
12156: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12157: LD_ADDR_EXP 33
12161: PUSH
12162: LD_EXP 33
12166: PUSH
12167: LD_EXP 30
12171: ADD
12172: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12173: LD_INT 1
12175: PPUSH
12176: LD_INT 1
12178: PPUSH
12179: LD_INT 6
12181: PPUSH
12182: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12186: LD_ADDR_OWVAR 26
12190: PUSH
12191: LD_STRING Ronn Horntvedt
12193: ST_TO_ADDR
// hc_gallery = sandar ;
12194: LD_ADDR_OWVAR 33
12198: PUSH
12199: LD_STRING sandar
12201: ST_TO_ADDR
// hc_face_number = 29 ;
12202: LD_ADDR_OWVAR 34
12206: PUSH
12207: LD_INT 29
12209: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12210: LD_ADDR_OWVAR 29
12214: PUSH
12215: LD_INT 11
12217: PUSH
12218: LD_INT 11
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: ST_TO_ADDR
// Ronn = CreateHuman ;
12225: LD_ADDR_EXP 31
12229: PUSH
12230: CALL_OW 44
12234: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12235: LD_ADDR_EXP 33
12239: PUSH
12240: LD_EXP 33
12244: PUSH
12245: LD_EXP 31
12249: ADD
12250: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12251: LD_INT 2
12253: PPUSH
12254: LD_INT 3
12256: PPUSH
12257: LD_INT 6
12259: PPUSH
12260: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12264: LD_ADDR_OWVAR 26
12268: PUSH
12269: LD_STRING Mia D. Mathiasen
12271: ST_TO_ADDR
// hc_gallery = sandar ;
12272: LD_ADDR_OWVAR 33
12276: PUSH
12277: LD_STRING sandar
12279: ST_TO_ADDR
// hc_face_number = 31 ;
12280: LD_ADDR_OWVAR 34
12284: PUSH
12285: LD_INT 31
12287: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12288: LD_ADDR_OWVAR 29
12292: PUSH
12293: LD_INT 10
12295: PUSH
12296: LD_INT 10
12298: PUSH
12299: EMPTY
12300: LIST
12301: LIST
12302: ST_TO_ADDR
// Mia = CreateHuman ;
12303: LD_ADDR_EXP 32
12307: PUSH
12308: CALL_OW 44
12312: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12313: LD_ADDR_EXP 33
12317: PUSH
12318: LD_EXP 33
12322: PUSH
12323: LD_EXP 32
12327: ADD
12328: ST_TO_ADDR
// for i = 1 to 2 do
12329: LD_ADDR_VAR 0 4
12333: PUSH
12334: DOUBLE
12335: LD_INT 1
12337: DEC
12338: ST_TO_ADDR
12339: LD_INT 2
12341: PUSH
12342: FOR_TO
12343: IFFALSE 12384
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12345: LD_ADDR_VAR 0 3
12349: PUSH
12350: LD_VAR 0 3
12354: PUSH
12355: LD_INT 2
12357: PPUSH
12358: LD_INT 2
12360: PPUSH
12361: LD_INT 14
12363: PPUSH
12364: LD_INT 1
12366: PPUSH
12367: LD_INT 1
12369: PPUSH
12370: LD_INT 32
12372: PPUSH
12373: LD_INT 30
12375: PPUSH
12376: CALL 264 0 7
12380: ADD
12381: ST_TO_ADDR
12382: GO 12342
12384: POP
12385: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12386: LD_ADDR_VAR 0 3
12390: PUSH
12391: LD_VAR 0 3
12395: PUSH
12396: LD_INT 2
12398: PPUSH
12399: LD_INT 2
12401: PPUSH
12402: LD_INT 14
12404: PPUSH
12405: LD_INT 1
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: LD_INT 26
12413: PPUSH
12414: LD_INT 33
12416: PPUSH
12417: CALL 264 0 7
12421: ADD
12422: ST_TO_ADDR
// tmp := tmp diff 0 ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_VAR 0 3
12432: PUSH
12433: LD_INT 0
12435: DIFF
12436: ST_TO_ADDR
// for i in ar_force do
12437: LD_ADDR_VAR 0 4
12441: PUSH
12442: LD_EXP 33
12446: PUSH
12447: FOR_IN
12448: IFFALSE 12591
// begin if GetClass ( i ) = 3 then
12450: LD_VAR 0 4
12454: PPUSH
12455: CALL_OW 257
12459: PUSH
12460: LD_INT 3
12462: EQUAL
12463: IFFALSE 12545
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12465: LD_VAR 0 3
12469: PUSH
12470: LD_INT 1
12472: ARRAY
12473: PPUSH
12474: LD_INT 1
12476: PPUSH
12477: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12481: LD_VAR 0 3
12485: PUSH
12486: LD_INT 1
12488: ARRAY
12489: PPUSH
12490: LD_VAR 0 5
12494: PPUSH
12495: LD_VAR 0 6
12499: PPUSH
12500: LD_INT 0
12502: PPUSH
12503: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12507: LD_VAR 0 4
12511: PPUSH
12512: LD_VAR 0 3
12516: PUSH
12517: LD_INT 1
12519: ARRAY
12520: PPUSH
12521: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12525: LD_ADDR_VAR 0 3
12529: PUSH
12530: LD_VAR 0 3
12534: PPUSH
12535: LD_INT 1
12537: PPUSH
12538: CALL_OW 3
12542: ST_TO_ADDR
// end else
12543: GO 12567
// PlaceUnitXY ( i , x , y , false ) ;
12545: LD_VAR 0 4
12549: PPUSH
12550: LD_VAR 0 5
12554: PPUSH
12555: LD_VAR 0 6
12559: PPUSH
12560: LD_INT 0
12562: PPUSH
12563: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12567: LD_VAR 0 4
12571: PPUSH
12572: LD_INT 86
12574: PPUSH
12575: LD_INT 121
12577: PPUSH
12578: CALL_OW 111
// wait ( 0 0$2 ) ;
12582: LD_INT 70
12584: PPUSH
12585: CALL_OW 67
// end ;
12589: GO 12447
12591: POP
12592: POP
// ar_force := ar_force ^ tmp ;
12593: LD_ADDR_EXP 33
12597: PUSH
12598: LD_EXP 33
12602: PUSH
12603: LD_VAR 0 3
12607: ADD
12608: ST_TO_ADDR
// ar_spawned := true ;
12609: LD_ADDR_EXP 11
12613: PUSH
12614: LD_INT 1
12616: ST_TO_ADDR
// end ; end_of_file
12617: LD_VAR 0 1
12621: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12622: LD_INT 0
12624: PPUSH
12625: PPUSH
12626: PPUSH
12627: PPUSH
12628: PPUSH
12629: PPUSH
12630: PPUSH
// InitHc ;
12631: CALL_OW 19
// uc_side := 3 ;
12635: LD_ADDR_OWVAR 20
12639: PUSH
12640: LD_INT 3
12642: ST_TO_ADDR
// uc_nation := 3 ;
12643: LD_ADDR_OWVAR 21
12647: PUSH
12648: LD_INT 3
12650: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12651: LD_ADDR_VAR 0 5
12655: PUSH
12656: LD_INT 5
12658: PUSH
12659: LD_INT 6
12661: PUSH
12662: LD_INT 7
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: LD_OWVAR 67
12674: ARRAY
12675: ST_TO_ADDR
// ru_force := [ ] ;
12676: LD_ADDR_EXP 35
12680: PUSH
12681: EMPTY
12682: ST_TO_ADDR
// ru_rebuild := [ ] ;
12683: LD_ADDR_EXP 36
12687: PUSH
12688: EMPTY
12689: ST_TO_ADDR
// ru_produce_list := [ ] ;
12690: LD_ADDR_EXP 37
12694: PUSH
12695: EMPTY
12696: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12697: LD_ADDR_VAR 0 6
12701: PUSH
12702: LD_INT 22
12704: PUSH
12705: LD_INT 3
12707: PUSH
12708: EMPTY
12709: LIST
12710: LIST
12711: PUSH
12712: LD_INT 30
12714: PUSH
12715: LD_INT 8
12717: PUSH
12718: EMPTY
12719: LIST
12720: LIST
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PPUSH
12726: CALL_OW 69
12730: PUSH
12731: LD_INT 1
12733: ARRAY
12734: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12735: LD_ADDR_VAR 0 4
12739: PUSH
12740: LD_INT 43
12742: PUSH
12743: LD_INT 46
12745: PUSH
12746: LD_INT 45
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: LIST
12753: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12754: LD_ADDR_VAR 0 7
12758: PUSH
12759: LD_INT 22
12761: PUSH
12762: LD_INT 3
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PUSH
12769: LD_INT 30
12771: PUSH
12772: LD_INT 1
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: PUSH
12779: EMPTY
12780: LIST
12781: LIST
12782: PPUSH
12783: CALL_OW 69
12787: PUSH
12788: LD_INT 1
12790: ARRAY
12791: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12792: LD_VAR 0 7
12796: PPUSH
12797: CALL_OW 274
12801: PPUSH
12802: LD_INT 1
12804: PPUSH
12805: LD_INT 5000
12807: PPUSH
12808: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12812: LD_VAR 0 7
12816: PPUSH
12817: CALL_OW 274
12821: PPUSH
12822: LD_INT 2
12824: PPUSH
12825: LD_INT 1000
12827: PPUSH
12828: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12832: LD_VAR 0 7
12836: PPUSH
12837: CALL_OW 274
12841: PPUSH
12842: LD_INT 3
12844: PPUSH
12845: LD_INT 30
12847: PPUSH
12848: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12852: LD_ADDR_VAR 0 2
12856: PUSH
12857: LD_INT 22
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 30
12869: PUSH
12870: LD_INT 33
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: FOR_IN
12887: IFFALSE 12919
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12889: LD_VAR 0 2
12893: PPUSH
12894: LD_VAR 0 4
12898: PUSH
12899: LD_VAR 0 2
12903: PUSH
12904: LD_INT 3
12906: MOD
12907: PUSH
12908: LD_INT 1
12910: PLUS
12911: ARRAY
12912: PPUSH
12913: CALL_OW 431
// end ;
12917: GO 12886
12919: POP
12920: POP
// for i = 1 to 4 do
12921: LD_ADDR_VAR 0 2
12925: PUSH
12926: DOUBLE
12927: LD_INT 1
12929: DEC
12930: ST_TO_ADDR
12931: LD_INT 4
12933: PUSH
12934: FOR_TO
12935: IFFALSE 12996
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12937: LD_INT 0
12939: PPUSH
12940: LD_INT 9
12942: PPUSH
12943: LD_VAR 0 5
12947: PPUSH
12948: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12952: CALL_OW 44
12956: PPUSH
12957: LD_INT 22
12959: PUSH
12960: LD_INT 3
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PUSH
12967: LD_INT 30
12969: PUSH
12970: LD_INT 5
12972: PUSH
12973: EMPTY
12974: LIST
12975: LIST
12976: PUSH
12977: EMPTY
12978: LIST
12979: LIST
12980: PPUSH
12981: CALL_OW 69
12985: PUSH
12986: LD_INT 1
12988: ARRAY
12989: PPUSH
12990: CALL_OW 52
// end ;
12994: GO 12934
12996: POP
12997: POP
// for i = 1 to 5 do
12998: LD_ADDR_VAR 0 2
13002: PUSH
13003: DOUBLE
13004: LD_INT 1
13006: DEC
13007: ST_TO_ADDR
13008: LD_INT 5
13010: PUSH
13011: FOR_TO
13012: IFFALSE 13073
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13014: LD_INT 0
13016: PPUSH
13017: LD_INT 3
13019: PPUSH
13020: LD_VAR 0 5
13024: PPUSH
13025: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13029: CALL_OW 44
13033: PPUSH
13034: LD_INT 22
13036: PUSH
13037: LD_INT 3
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: PUSH
13044: LD_INT 30
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: PPUSH
13058: CALL_OW 69
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: CALL_OW 52
// end ;
13071: GO 13011
13073: POP
13074: POP
// for i = 1 to 4 do
13075: LD_ADDR_VAR 0 2
13079: PUSH
13080: DOUBLE
13081: LD_INT 1
13083: DEC
13084: ST_TO_ADDR
13085: LD_INT 4
13087: PUSH
13088: FOR_TO
13089: IFFALSE 13150
// begin PrepareHuman ( false , class_engineer , skill ) ;
13091: LD_INT 0
13093: PPUSH
13094: LD_INT 2
13096: PPUSH
13097: LD_VAR 0 5
13101: PPUSH
13102: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13106: CALL_OW 44
13110: PPUSH
13111: LD_INT 22
13113: PUSH
13114: LD_INT 3
13116: PUSH
13117: EMPTY
13118: LIST
13119: LIST
13120: PUSH
13121: LD_INT 30
13123: PUSH
13124: LD_INT 1
13126: PUSH
13127: EMPTY
13128: LIST
13129: LIST
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PPUSH
13135: CALL_OW 69
13139: PUSH
13140: LD_INT 1
13142: ARRAY
13143: PPUSH
13144: CALL_OW 52
// end ;
13148: GO 13088
13150: POP
13151: POP
// for i = 1 to 3 do
13152: LD_ADDR_VAR 0 2
13156: PUSH
13157: DOUBLE
13158: LD_INT 1
13160: DEC
13161: ST_TO_ADDR
13162: LD_INT 3
13164: PUSH
13165: FOR_TO
13166: IFFALSE 13199
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13168: LD_INT 0
13170: PPUSH
13171: LD_INT 4
13173: PPUSH
13174: LD_VAR 0 5
13178: PPUSH
13179: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13183: CALL_OW 44
13187: PPUSH
13188: LD_VAR 0 6
13192: PPUSH
13193: CALL_OW 52
// end ;
13197: GO 13165
13199: POP
13200: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13201: LD_ADDR_EXP 34
13205: PUSH
13206: LD_STRING Yakotich
13208: PPUSH
13209: LD_EXP 2
13213: NOT
13214: PPUSH
13215: LD_STRING 
13217: PPUSH
13218: CALL 201 0 3
13222: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13223: LD_EXP 34
13227: PPUSH
13228: LD_INT 74
13230: PPUSH
13231: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13235: LD_VAR 0 6
13239: PPUSH
13240: LD_INT 49
13242: PPUSH
13243: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13247: LD_VAR 0 6
13251: PPUSH
13252: LD_INT 50
13254: PPUSH
13255: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13259: LD_VAR 0 6
13263: PPUSH
13264: LD_INT 51
13266: PPUSH
13267: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13271: LD_VAR 0 6
13275: PPUSH
13276: LD_INT 52
13278: PPUSH
13279: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13283: LD_VAR 0 6
13287: PPUSH
13288: LD_INT 69
13290: PPUSH
13291: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13295: LD_VAR 0 6
13299: PPUSH
13300: LD_INT 39
13302: PPUSH
13303: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13307: LD_VAR 0 6
13311: PPUSH
13312: LD_INT 34
13314: PPUSH
13315: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13319: LD_VAR 0 6
13323: PPUSH
13324: LD_INT 40
13326: PPUSH
13327: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13331: LD_VAR 0 6
13335: PPUSH
13336: LD_INT 57
13338: PPUSH
13339: CALL_OW 184
// if Difficulty > 1 then
13343: LD_OWVAR 67
13347: PUSH
13348: LD_INT 1
13350: GREATER
13351: IFFALSE 13365
// AddComResearch ( lab , tech_comp2 ) ;
13353: LD_VAR 0 6
13357: PPUSH
13358: LD_INT 58
13360: PPUSH
13361: CALL_OW 184
// end ;
13365: LD_VAR 0 1
13369: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13370: LD_INT 7
13372: PPUSH
13373: CALL_OW 353
13377: PUSH
13378: LD_INT 3
13380: GREATER
13381: PUSH
13382: LD_INT 22
13384: PUSH
13385: LD_INT 3
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PUSH
13392: LD_INT 34
13394: PUSH
13395: LD_INT 53
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PPUSH
13406: CALL_OW 69
13410: NOT
13411: AND
13412: IFFALSE 13447
13414: GO 13416
13416: DISABLE
// begin enable ;
13417: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13418: LD_ADDR_EXP 37
13422: PUSH
13423: LD_EXP 37
13427: PUSH
13428: LD_INT 24
13430: PUSH
13431: LD_INT 1
13433: PUSH
13434: LD_INT 3
13436: PUSH
13437: LD_INT 53
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: ADD
13446: ST_TO_ADDR
// end ;
13447: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13448: LD_INT 22
13450: PUSH
13451: LD_INT 3
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PUSH
13458: LD_INT 21
13460: PUSH
13461: LD_INT 3
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PPUSH
13472: CALL_OW 69
13476: IFFALSE 14254
13478: GO 13480
13480: DISABLE
13481: LD_INT 0
13483: PPUSH
13484: PPUSH
13485: PPUSH
13486: PPUSH
13487: PPUSH
13488: PPUSH
13489: PPUSH
13490: PPUSH
// begin enable ;
13491: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13492: LD_ADDR_VAR 0 3
13496: PUSH
13497: LD_INT 22
13499: PUSH
13500: LD_INT 3
13502: PUSH
13503: EMPTY
13504: LIST
13505: LIST
13506: PUSH
13507: LD_INT 21
13509: PUSH
13510: LD_INT 3
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: PUSH
13517: LD_INT 3
13519: PUSH
13520: LD_INT 24
13522: PUSH
13523: LD_INT 1000
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: LIST
13538: PPUSH
13539: CALL_OW 69
13543: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13544: LD_ADDR_VAR 0 4
13548: PUSH
13549: LD_INT 22
13551: PUSH
13552: LD_INT 3
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 25
13561: PUSH
13562: LD_INT 2
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 69
13577: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13578: LD_ADDR_VAR 0 5
13582: PUSH
13583: LD_INT 22
13585: PUSH
13586: LD_INT 3
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: LD_INT 30
13595: PUSH
13596: LD_INT 1
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 69
13611: PUSH
13612: LD_INT 1
13614: ARRAY
13615: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13616: LD_ADDR_VAR 0 8
13620: PUSH
13621: LD_INT 22
13623: PUSH
13624: LD_INT 3
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 2
13633: PUSH
13634: LD_INT 30
13636: PUSH
13637: LD_INT 6
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PUSH
13644: LD_INT 30
13646: PUSH
13647: LD_INT 7
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: PUSH
13654: LD_INT 30
13656: PUSH
13657: LD_INT 8
13659: PUSH
13660: EMPTY
13661: LIST
13662: LIST
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: LIST
13668: LIST
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: PPUSH
13674: CALL_OW 69
13678: PUSH
13679: LD_INT 1
13681: ARRAY
13682: ST_TO_ADDR
// if not engs then
13683: LD_VAR 0 4
13687: NOT
13688: IFFALSE 13692
// exit ;
13690: GO 14254
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13692: LD_ADDR_VAR 0 6
13696: PUSH
13697: LD_VAR 0 4
13701: PPUSH
13702: LD_INT 3
13704: PUSH
13705: LD_INT 24
13707: PUSH
13708: LD_INT 600
13710: PUSH
13711: EMPTY
13712: LIST
13713: LIST
13714: PUSH
13715: EMPTY
13716: LIST
13717: LIST
13718: PPUSH
13719: CALL_OW 72
13723: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13724: LD_ADDR_VAR 0 7
13728: PUSH
13729: LD_INT 22
13731: PUSH
13732: LD_INT 3
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: LD_INT 25
13741: PUSH
13742: LD_INT 4
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: PPUSH
13753: CALL_OW 69
13757: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13758: LD_VAR 0 3
13762: NOT
13763: PUSH
13764: LD_EXP 36
13768: NOT
13769: AND
13770: IFFALSE 13830
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13772: LD_VAR 0 4
13776: PPUSH
13777: LD_INT 3
13779: PUSH
13780: LD_INT 54
13782: PUSH
13783: EMPTY
13784: LIST
13785: PUSH
13786: EMPTY
13787: LIST
13788: LIST
13789: PPUSH
13790: CALL_OW 72
13794: IFFALSE 13828
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13796: LD_VAR 0 4
13800: PPUSH
13801: LD_INT 3
13803: PUSH
13804: LD_INT 54
13806: PUSH
13807: EMPTY
13808: LIST
13809: PUSH
13810: EMPTY
13811: LIST
13812: LIST
13813: PPUSH
13814: CALL_OW 72
13818: PPUSH
13819: LD_VAR 0 5
13823: PPUSH
13824: CALL_OW 120
// exit ;
13828: GO 14254
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13830: LD_VAR 0 4
13834: PPUSH
13835: LD_INT 54
13837: PUSH
13838: EMPTY
13839: LIST
13840: PPUSH
13841: CALL_OW 72
13845: IFFALSE 13867
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13847: LD_VAR 0 4
13851: PPUSH
13852: LD_INT 54
13854: PUSH
13855: EMPTY
13856: LIST
13857: PPUSH
13858: CALL_OW 72
13862: PPUSH
13863: CALL_OW 122
// if not tmp then
13867: LD_VAR 0 3
13871: NOT
13872: IFFALSE 14004
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13874: LD_INT 81
13876: PUSH
13877: LD_INT 3
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 92
13886: PUSH
13887: LD_INT 147
13889: PUSH
13890: LD_INT 212
13892: PUSH
13893: LD_INT 30
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PPUSH
13906: CALL_OW 69
13910: NOT
13911: IFFALSE 14004
// begin if not HasTask ( engs [ 1 ] ) then
13913: LD_VAR 0 4
13917: PUSH
13918: LD_INT 1
13920: ARRAY
13921: PPUSH
13922: CALL_OW 314
13926: NOT
13927: IFFALSE 14004
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13929: LD_ADDR_VAR 0 2
13933: PUSH
13934: LD_VAR 0 4
13938: PPUSH
13939: LD_EXP 36
13943: PUSH
13944: LD_INT 1
13946: ARRAY
13947: PPUSH
13948: LD_EXP 36
13952: PUSH
13953: LD_INT 2
13955: ARRAY
13956: PPUSH
13957: LD_EXP 36
13961: PUSH
13962: LD_INT 3
13964: ARRAY
13965: PPUSH
13966: LD_EXP 36
13970: PUSH
13971: LD_INT 4
13973: ARRAY
13974: PPUSH
13975: CALL_OW 145
13979: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13980: LD_VAR 0 2
13984: PPUSH
13985: CALL_OW 266
13989: PUSH
13990: LD_INT 4
13992: EQUAL
13993: IFFALSE 14004
// AddComUpgrade ( i ) ;
13995: LD_VAR 0 2
13999: PPUSH
14000: CALL_OW 206
// end ; end ; end ; for i in engs do
14004: LD_ADDR_VAR 0 2
14008: PUSH
14009: LD_VAR 0 4
14013: PUSH
14014: FOR_IN
14015: IFFALSE 14133
// begin if i in to_heal and sci then
14017: LD_VAR 0 2
14021: PUSH
14022: LD_VAR 0 6
14026: IN
14027: PUSH
14028: LD_VAR 0 7
14032: AND
14033: IFFALSE 14084
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14035: LD_VAR 0 2
14039: PPUSH
14040: LD_INT 149
14042: PPUSH
14043: LD_INT 220
14045: PPUSH
14046: CALL_OW 297
14050: PUSH
14051: LD_INT 5
14053: LESS
14054: IFFALSE 14058
// continue ;
14056: GO 14014
// ComMoveXY ( i , 149 , 220 ) ;
14058: LD_VAR 0 2
14062: PPUSH
14063: LD_INT 149
14065: PPUSH
14066: LD_INT 220
14068: PPUSH
14069: CALL_OW 111
// AddComHold ( i ) ;
14073: LD_VAR 0 2
14077: PPUSH
14078: CALL_OW 200
// end else
14082: GO 14131
// if not HasTask ( i ) or WantsToAttack ( i ) then
14084: LD_VAR 0 2
14088: PPUSH
14089: CALL_OW 314
14093: NOT
14094: PUSH
14095: LD_VAR 0 2
14099: PPUSH
14100: CALL_OW 319
14104: OR
14105: IFFALSE 14131
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14107: LD_VAR 0 2
14111: PPUSH
14112: LD_VAR 0 3
14116: PPUSH
14117: LD_VAR 0 2
14121: PPUSH
14122: CALL_OW 74
14126: PPUSH
14127: CALL_OW 130
// end ;
14131: GO 14014
14133: POP
14134: POP
// if to_heal and sci then
14135: LD_VAR 0 6
14139: PUSH
14140: LD_VAR 0 7
14144: AND
14145: IFFALSE 14206
// begin if UnitFilter ( sci , [ f_inside ] ) then
14147: LD_VAR 0 7
14151: PPUSH
14152: LD_INT 54
14154: PUSH
14155: EMPTY
14156: LIST
14157: PPUSH
14158: CALL_OW 72
14162: IFFALSE 14186
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14164: LD_VAR 0 7
14168: PPUSH
14169: LD_INT 54
14171: PUSH
14172: EMPTY
14173: LIST
14174: PPUSH
14175: CALL_OW 72
14179: PPUSH
14180: CALL_OW 122
14184: GO 14204
// ComHeal ( sci , to_heal [ 1 ] ) ;
14186: LD_VAR 0 7
14190: PPUSH
14191: LD_VAR 0 6
14195: PUSH
14196: LD_INT 1
14198: ARRAY
14199: PPUSH
14200: CALL_OW 128
// end else
14204: GO 14254
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14206: LD_VAR 0 7
14210: PPUSH
14211: LD_INT 56
14213: PUSH
14214: EMPTY
14215: LIST
14216: PPUSH
14217: CALL_OW 72
14221: PUSH
14222: LD_VAR 0 8
14226: AND
14227: IFFALSE 14254
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14229: LD_VAR 0 7
14233: PPUSH
14234: LD_INT 56
14236: PUSH
14237: EMPTY
14238: LIST
14239: PPUSH
14240: CALL_OW 72
14244: PPUSH
14245: LD_VAR 0 8
14249: PPUSH
14250: CALL_OW 120
// end ;
14254: PPOPN 8
14256: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14257: LD_INT 22
14259: PUSH
14260: LD_INT 3
14262: PUSH
14263: EMPTY
14264: LIST
14265: LIST
14266: PUSH
14267: LD_INT 30
14269: PUSH
14270: LD_INT 3
14272: PUSH
14273: EMPTY
14274: LIST
14275: LIST
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PPUSH
14281: CALL_OW 69
14285: PUSH
14286: LD_EXP 37
14290: AND
14291: IFFALSE 14417
14293: GO 14295
14295: DISABLE
14296: LD_INT 0
14298: PPUSH
14299: PPUSH
14300: PPUSH
// begin enable ;
14301: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14302: LD_ADDR_VAR 0 3
14306: PUSH
14307: LD_INT 22
14309: PUSH
14310: LD_INT 3
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PUSH
14317: LD_INT 30
14319: PUSH
14320: LD_INT 3
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PPUSH
14331: CALL_OW 69
14335: PUSH
14336: LD_INT 1
14338: ARRAY
14339: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14340: LD_VAR 0 3
14344: PPUSH
14345: CALL_OW 313
14349: PUSH
14350: LD_INT 0
14352: EQUAL
14353: IFFALSE 14357
// exit ;
14355: GO 14417
// if BuildingStatus ( fac ) = bs_idle then
14357: LD_VAR 0 3
14361: PPUSH
14362: CALL_OW 461
14366: PUSH
14367: LD_INT 2
14369: EQUAL
14370: IFFALSE 14417
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14372: LD_VAR 0 3
14376: PPUSH
14377: LD_EXP 37
14381: PUSH
14382: LD_INT 1
14384: ARRAY
14385: PPUSH
14386: LD_EXP 37
14390: PUSH
14391: LD_INT 2
14393: ARRAY
14394: PPUSH
14395: LD_EXP 37
14399: PUSH
14400: LD_INT 3
14402: ARRAY
14403: PPUSH
14404: LD_EXP 37
14408: PUSH
14409: LD_INT 4
14411: ARRAY
14412: PPUSH
14413: CALL_OW 125
// end ;
14417: PPOPN 3
14419: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14420: LD_INT 0
14422: PPUSH
14423: PPUSH
14424: PPUSH
14425: PPUSH
14426: PPUSH
// uc_side := 3 ;
14427: LD_ADDR_OWVAR 20
14431: PUSH
14432: LD_INT 3
14434: ST_TO_ADDR
// uc_nation := 3 ;
14435: LD_ADDR_OWVAR 21
14439: PUSH
14440: LD_INT 3
14442: ST_TO_ADDR
// ru_can_attack := false ;
14443: LD_ADDR_EXP 8
14447: PUSH
14448: LD_INT 0
14450: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14451: LD_ADDR_VAR 0 6
14455: PUSH
14456: LD_INT 22
14458: PUSH
14459: LD_INT 3
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 30
14468: PUSH
14469: LD_INT 3
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PPUSH
14480: CALL_OW 69
14484: ST_TO_ADDR
// if fac then
14485: LD_VAR 0 6
14489: IFFALSE 14641
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14491: LD_ADDR_EXP 37
14495: PUSH
14496: LD_INT 24
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: LD_INT 3
14504: PUSH
14505: LD_INT 43
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: ST_TO_ADDR
// if wave > 1 then
14514: LD_VAR 0 1
14518: PUSH
14519: LD_INT 1
14521: GREATER
14522: IFFALSE 14575
// for i = 1 to Difficulty do
14524: LD_ADDR_VAR 0 3
14528: PUSH
14529: DOUBLE
14530: LD_INT 1
14532: DEC
14533: ST_TO_ADDR
14534: LD_OWVAR 67
14538: PUSH
14539: FOR_TO
14540: IFFALSE 14573
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14542: LD_ADDR_EXP 37
14546: PUSH
14547: LD_EXP 37
14551: PUSH
14552: LD_INT 24
14554: PUSH
14555: LD_INT 1
14557: PUSH
14558: LD_INT 3
14560: PUSH
14561: LD_INT 45
14563: PUSH
14564: EMPTY
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: ADD
14570: ST_TO_ADDR
14571: GO 14539
14573: POP
14574: POP
// repeat wait ( 0 0$1 ) ;
14575: LD_INT 35
14577: PPUSH
14578: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14582: LD_EXP 37
14586: PUSH
14587: LD_INT 4
14589: LESS
14590: PUSH
14591: LD_VAR 0 6
14595: PUSH
14596: LD_INT 1
14598: ARRAY
14599: PPUSH
14600: CALL_OW 313
14604: PUSH
14605: LD_INT 0
14607: EQUAL
14608: OR
14609: PUSH
14610: LD_VAR 0 6
14614: PUSH
14615: LD_INT 1
14617: ARRAY
14618: PPUSH
14619: CALL_OW 461
14623: PUSH
14624: LD_INT 8
14626: PUSH
14627: LD_INT 6
14629: PUSH
14630: LD_INT 7
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: LIST
14637: IN
14638: OR
14639: IFFALSE 14575
// end ; case wave of 1 :
14641: LD_VAR 0 1
14645: PUSH
14646: LD_INT 1
14648: DOUBLE
14649: EQUAL
14650: IFTRUE 14654
14652: GO 14739
14654: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14655: LD_ADDR_VAR 0 3
14659: PUSH
14660: DOUBLE
14661: LD_INT 1
14663: DEC
14664: ST_TO_ADDR
14665: LD_INT 4
14667: PUSH
14668: LD_INT 5
14670: PUSH
14671: LD_INT 6
14673: PUSH
14674: EMPTY
14675: LIST
14676: LIST
14677: LIST
14678: PUSH
14679: LD_OWVAR 67
14683: ARRAY
14684: PUSH
14685: FOR_TO
14686: IFFALSE 14694
// Sold ;
14688: CALL 14965 0 0
14692: GO 14685
14694: POP
14695: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14696: LD_ADDR_VAR 0 3
14700: PUSH
14701: DOUBLE
14702: LD_INT 1
14704: DEC
14705: ST_TO_ADDR
14706: LD_INT 2
14708: PUSH
14709: LD_INT 3
14711: PUSH
14712: LD_INT 3
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: LIST
14719: PUSH
14720: LD_OWVAR 67
14724: ARRAY
14725: PUSH
14726: FOR_TO
14727: IFFALSE 14735
// Tank ;
14729: CALL 15095 0 0
14733: GO 14726
14735: POP
14736: POP
// end ; 2 .. 9 :
14737: GO 14952
14739: LD_INT 2
14741: DOUBLE
14742: GREATEREQUAL
14743: IFFALSE 14751
14745: LD_INT 9
14747: DOUBLE
14748: LESSEQUAL
14749: IFTRUE 14753
14751: GO 14858
14753: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14754: LD_ADDR_VAR 0 3
14758: PUSH
14759: DOUBLE
14760: LD_INT 1
14762: DEC
14763: ST_TO_ADDR
14764: LD_INT 4
14766: PUSH
14767: LD_INT 5
14769: PUSH
14770: LD_INT 6
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: LIST
14777: PUSH
14778: LD_OWVAR 67
14782: ARRAY
14783: PUSH
14784: LD_VAR 0 1
14788: PUSH
14789: LD_INT 2
14791: DIV
14792: PLUS
14793: PUSH
14794: FOR_TO
14795: IFFALSE 14803
// Sold ;
14797: CALL 14965 0 0
14801: GO 14794
14803: POP
14804: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14805: LD_ADDR_VAR 0 3
14809: PUSH
14810: DOUBLE
14811: LD_INT 1
14813: DEC
14814: ST_TO_ADDR
14815: LD_INT 3
14817: PUSH
14818: LD_INT 4
14820: PUSH
14821: LD_INT 4
14823: PUSH
14824: EMPTY
14825: LIST
14826: LIST
14827: LIST
14828: PUSH
14829: LD_OWVAR 67
14833: ARRAY
14834: PUSH
14835: LD_VAR 0 1
14839: PUSH
14840: LD_INT 2
14842: DIV
14843: PLUS
14844: PUSH
14845: FOR_TO
14846: IFFALSE 14854
// Tank ;
14848: CALL 15095 0 0
14852: GO 14845
14854: POP
14855: POP
// end ; 10 :
14856: GO 14952
14858: LD_INT 10
14860: DOUBLE
14861: EQUAL
14862: IFTRUE 14866
14864: GO 14951
14866: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14867: LD_ADDR_VAR 0 3
14871: PUSH
14872: DOUBLE
14873: LD_INT 1
14875: DEC
14876: ST_TO_ADDR
14877: LD_INT 10
14879: PUSH
14880: LD_INT 12
14882: PUSH
14883: LD_INT 14
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: LIST
14890: PUSH
14891: LD_OWVAR 67
14895: ARRAY
14896: PUSH
14897: FOR_TO
14898: IFFALSE 14906
// Sold ;
14900: CALL 14965 0 0
14904: GO 14897
14906: POP
14907: POP
// for i = 1 to [ 9 , 11 , 15 ] [ Difficulty ] do
14908: LD_ADDR_VAR 0 3
14912: PUSH
14913: DOUBLE
14914: LD_INT 1
14916: DEC
14917: ST_TO_ADDR
14918: LD_INT 9
14920: PUSH
14921: LD_INT 11
14923: PUSH
14924: LD_INT 15
14926: PUSH
14927: EMPTY
14928: LIST
14929: LIST
14930: LIST
14931: PUSH
14932: LD_OWVAR 67
14936: ARRAY
14937: PUSH
14938: FOR_TO
14939: IFFALSE 14947
// Tank ;
14941: CALL 15095 0 0
14945: GO 14938
14947: POP
14948: POP
// end ; end ;
14949: GO 14952
14951: POP
// ru_can_attack := true ;
14952: LD_ADDR_EXP 8
14956: PUSH
14957: LD_INT 1
14959: ST_TO_ADDR
// end ;
14960: LD_VAR 0 2
14964: RET
// function Sold ( ) ; var un , skill ; begin
14965: LD_INT 0
14967: PPUSH
14968: PPUSH
14969: PPUSH
// uc_side := 3 ;
14970: LD_ADDR_OWVAR 20
14974: PUSH
14975: LD_INT 3
14977: ST_TO_ADDR
// uc_nation := 3 ;
14978: LD_ADDR_OWVAR 21
14982: PUSH
14983: LD_INT 3
14985: ST_TO_ADDR
// InitHc ;
14986: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14990: LD_ADDR_VAR 0 3
14994: PUSH
14995: LD_INT 6
14997: PUSH
14998: LD_INT 7
15000: PUSH
15001: LD_INT 7
15003: PUSH
15004: EMPTY
15005: LIST
15006: LIST
15007: LIST
15008: PUSH
15009: LD_OWVAR 67
15013: ARRAY
15014: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15015: LD_INT 0
15017: PPUSH
15018: LD_INT 1
15020: PUSH
15021: LD_INT 9
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PUSH
15028: LD_INT 1
15030: PPUSH
15031: LD_INT 2
15033: PPUSH
15034: CALL_OW 12
15038: ARRAY
15039: PPUSH
15040: LD_VAR 0 3
15044: PPUSH
15045: CALL_OW 380
// un := CreateHuman ;
15049: LD_ADDR_VAR 0 2
15053: PUSH
15054: CALL_OW 44
15058: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15059: LD_VAR 0 2
15063: PPUSH
15064: LD_INT 4
15066: PPUSH
15067: LD_INT 0
15069: PPUSH
15070: CALL_OW 49
// ru_force := ru_force ^ un ;
15074: LD_ADDR_EXP 35
15078: PUSH
15079: LD_EXP 35
15083: PUSH
15084: LD_VAR 0 2
15088: ADD
15089: ST_TO_ADDR
// end ;
15090: LD_VAR 0 1
15094: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15095: LD_INT 0
15097: PPUSH
15098: PPUSH
15099: PPUSH
15100: PPUSH
15101: PPUSH
// uc_side := 3 ;
15102: LD_ADDR_OWVAR 20
15106: PUSH
15107: LD_INT 3
15109: ST_TO_ADDR
// uc_nation := 3 ;
15110: LD_ADDR_OWVAR 21
15114: PUSH
15115: LD_INT 3
15117: ST_TO_ADDR
// InitHc ;
15118: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15122: LD_ADDR_VAR 0 5
15126: PUSH
15127: LD_INT 5
15129: PUSH
15130: LD_INT 6
15132: PUSH
15133: LD_INT 7
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: LIST
15140: PUSH
15141: LD_OWVAR 67
15145: ARRAY
15146: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 22
15154: PUSH
15155: LD_INT 24
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 1
15164: PPUSH
15165: LD_INT 2
15167: PPUSH
15168: CALL_OW 12
15172: ARRAY
15173: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15174: LD_VAR 0 3
15178: PUSH
15179: LD_INT 22
15181: EQUAL
15182: IFFALSE 15217
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15184: LD_ADDR_VAR 0 4
15188: PUSH
15189: LD_INT 45
15191: PUSH
15192: LD_INT 43
15194: PUSH
15195: LD_INT 44
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: LIST
15202: PUSH
15203: LD_INT 1
15205: PPUSH
15206: LD_INT 3
15208: PPUSH
15209: CALL_OW 12
15213: ARRAY
15214: ST_TO_ADDR
15215: GO 15248
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15217: LD_ADDR_VAR 0 4
15221: PUSH
15222: LD_INT 46
15224: PUSH
15225: LD_INT 44
15227: PUSH
15228: LD_INT 45
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: LIST
15235: PUSH
15236: LD_INT 1
15238: PPUSH
15239: LD_INT 3
15241: PPUSH
15242: CALL_OW 12
15246: ARRAY
15247: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15248: LD_ADDR_VAR 0 2
15252: PUSH
15253: LD_INT 3
15255: PPUSH
15256: LD_INT 3
15258: PPUSH
15259: LD_VAR 0 3
15263: PPUSH
15264: LD_INT 1
15266: PPUSH
15267: LD_INT 3
15269: PUSH
15270: LD_INT 3
15272: PUSH
15273: LD_INT 3
15275: PUSH
15276: LD_INT 1
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: LIST
15283: LIST
15284: PUSH
15285: LD_INT 1
15287: PPUSH
15288: LD_INT 4
15290: PPUSH
15291: CALL_OW 12
15295: ARRAY
15296: PPUSH
15297: LD_VAR 0 4
15301: PPUSH
15302: LD_INT 99
15304: PPUSH
15305: CALL 264 0 7
15309: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15310: LD_VAR 0 2
15314: PPUSH
15315: CALL_OW 263
15319: PUSH
15320: LD_INT 1
15322: EQUAL
15323: IFFALSE 15354
// begin PrepareHuman ( false , 3 , skill ) ;
15325: LD_INT 0
15327: PPUSH
15328: LD_INT 3
15330: PPUSH
15331: LD_VAR 0 5
15335: PPUSH
15336: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15340: CALL_OW 44
15344: PPUSH
15345: LD_VAR 0 2
15349: PPUSH
15350: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15354: LD_VAR 0 2
15358: PPUSH
15359: LD_INT 3
15361: PPUSH
15362: LD_INT 0
15364: PPUSH
15365: CALL_OW 49
// ru_force := ru_force ^ un ;
15369: LD_ADDR_EXP 35
15373: PUSH
15374: LD_EXP 35
15378: PUSH
15379: LD_VAR 0 2
15383: ADD
15384: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15385: LD_VAR 0 2
15389: PPUSH
15390: LD_INT 126
15392: PPUSH
15393: LD_INT 158
15395: PPUSH
15396: CALL_OW 111
// Wait ( 0 0$3 ) ;
15400: LD_INT 105
15402: PPUSH
15403: CALL_OW 67
// ComStop ( un ) ;
15407: LD_VAR 0 2
15411: PPUSH
15412: CALL_OW 141
// end ;
15416: LD_VAR 0 1
15420: RET
// every 0 0$1 do var i , time , wave ;
15421: GO 15423
15423: DISABLE
15424: LD_INT 0
15426: PPUSH
15427: PPUSH
15428: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15429: LD_ADDR_VAR 0 2
15433: PUSH
15434: LD_INT 25200
15436: PUSH
15437: LD_INT 24150
15439: PUSH
15440: LD_INT 23100
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: LIST
15447: PUSH
15448: LD_OWVAR 67
15452: ARRAY
15453: ST_TO_ADDR
// wait ( time ) ;
15454: LD_VAR 0 2
15458: PPUSH
15459: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15463: LD_ADDR_VAR 0 2
15467: PUSH
15468: LD_INT 15750
15470: PUSH
15471: LD_INT 15050
15473: PUSH
15474: LD_INT 14350
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: LIST
15481: PUSH
15482: LD_OWVAR 67
15486: ARRAY
15487: ST_TO_ADDR
// wave := 0 ;
15488: LD_ADDR_VAR 0 3
15492: PUSH
15493: LD_INT 0
15495: ST_TO_ADDR
// while true do
15496: LD_INT 1
15498: IFFALSE 15595
// begin wave := wave + 1 ;
15500: LD_ADDR_VAR 0 3
15504: PUSH
15505: LD_VAR 0 3
15509: PUSH
15510: LD_INT 1
15512: PLUS
15513: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15514: LD_INT 22
15516: PUSH
15517: LD_INT 2
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PPUSH
15524: CALL_OW 69
15528: IFFALSE 15557
// repeat wait ( 0 0$1 ) ;
15530: LD_INT 35
15532: PPUSH
15533: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15537: LD_INT 22
15539: PUSH
15540: LD_INT 2
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PPUSH
15547: CALL_OW 69
15551: PUSH
15552: LD_INT 0
15554: EQUAL
15555: IFFALSE 15530
// if ru_force < 20 then
15557: LD_EXP 35
15561: PUSH
15562: LD_INT 20
15564: LESS
15565: IFFALSE 15576
// PrepareAttack ( wave ) ;
15567: LD_VAR 0 3
15571: PPUSH
15572: CALL 14420 0 1
// ru_can_attack := true ;
15576: LD_ADDR_EXP 8
15580: PUSH
15581: LD_INT 1
15583: ST_TO_ADDR
// wait ( time ) ;
15584: LD_VAR 0 2
15588: PPUSH
15589: CALL_OW 67
// end ;
15593: GO 15496
// end ;
15595: PPOPN 3
15597: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15598: LD_EXP 8
15602: PUSH
15603: LD_EXP 35
15607: AND
15608: IFFALSE 16442
15610: GO 15612
15612: DISABLE
15613: LD_INT 0
15615: PPUSH
15616: PPUSH
15617: PPUSH
15618: PPUSH
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
15623: PPUSH
// begin enable ;
15624: ENABLE
// points1 := [ 107 , 123 ] ;
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_INT 107
15632: PUSH
15633: LD_INT 123
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_INT 55
15647: PUSH
15648: LD_INT 42
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_INT 102
15662: PUSH
15663: LD_INT 140
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PUSH
15670: LD_INT 105
15672: PUSH
15673: LD_INT 142
15675: PUSH
15676: EMPTY
15677: LIST
15678: LIST
15679: PUSH
15680: LD_INT 129
15682: PUSH
15683: LD_INT 131
15685: PUSH
15686: EMPTY
15687: LIST
15688: LIST
15689: PUSH
15690: EMPTY
15691: LIST
15692: LIST
15693: LIST
15694: ST_TO_ADDR
// for i in ru_force do
15695: LD_ADDR_VAR 0 1
15699: PUSH
15700: LD_EXP 35
15704: PUSH
15705: FOR_IN
15706: IFFALSE 16440
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15708: LD_ADDR_VAR 0 3
15712: PUSH
15713: LD_INT 81
15715: PUSH
15716: LD_INT 3
15718: PUSH
15719: EMPTY
15720: LIST
15721: LIST
15722: PPUSH
15723: CALL_OW 69
15727: PPUSH
15728: LD_VAR 0 1
15732: PPUSH
15733: CALL_OW 74
15737: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_VAR 0 3
15747: PPUSH
15748: CALL_OW 296
15752: PUSH
15753: LD_INT 12
15755: LESS
15756: IFFALSE 15901
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15758: LD_VAR 0 1
15762: PPUSH
15763: CALL_OW 247
15767: PUSH
15768: LD_INT 1
15770: EQUAL
15771: PUSH
15772: LD_VAR 0 1
15776: PPUSH
15777: CALL_OW 257
15781: PUSH
15782: LD_INT 1
15784: EQUAL
15785: AND
15786: PUSH
15787: LD_VAR 0 3
15791: PUSH
15792: LD_INT 21
15794: PUSH
15795: LD_INT 2
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 58
15804: PUSH
15805: EMPTY
15806: LIST
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PPUSH
15812: CALL_OW 69
15816: IN
15817: AND
15818: IFFALSE 15836
// ComEnterUnit ( i , un ) else
15820: LD_VAR 0 1
15824: PPUSH
15825: LD_VAR 0 3
15829: PPUSH
15830: CALL_OW 120
15834: GO 15899
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15836: LD_VAR 0 3
15840: PUSH
15841: LD_INT 21
15843: PUSH
15844: LD_INT 2
15846: PUSH
15847: EMPTY
15848: LIST
15849: LIST
15850: PUSH
15851: LD_INT 58
15853: PUSH
15854: EMPTY
15855: LIST
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: PPUSH
15861: CALL_OW 69
15865: IN
15866: NOT
15867: IFFALSE 15885
// ComAttackUnit ( i , un ) else
15869: LD_VAR 0 1
15873: PPUSH
15874: LD_VAR 0 3
15878: PPUSH
15879: CALL_OW 115
15883: GO 15899
// ComAttackUnit ( i , JMM ) ;
15885: LD_VAR 0 1
15889: PPUSH
15890: LD_EXP 18
15894: PPUSH
15895: CALL_OW 115
// end else
15899: GO 16438
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15901: LD_VAR 0 1
15905: PPUSH
15906: LD_VAR 0 4
15910: PUSH
15911: LD_INT 1
15913: ARRAY
15914: PPUSH
15915: LD_VAR 0 4
15919: PUSH
15920: LD_INT 2
15922: ARRAY
15923: PPUSH
15924: CALL_OW 297
15928: PUSH
15929: LD_VAR 0 1
15933: PPUSH
15934: LD_VAR 0 5
15938: PUSH
15939: LD_INT 1
15941: ARRAY
15942: PPUSH
15943: LD_VAR 0 5
15947: PUSH
15948: LD_INT 2
15950: ARRAY
15951: PPUSH
15952: CALL_OW 297
15956: GREATER
15957: PUSH
15958: LD_EXP 9
15962: AND
15963: PUSH
15964: LD_INT 9
15966: PPUSH
15967: LD_INT 81
15969: PUSH
15970: LD_INT 3
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PPUSH
15977: CALL_OW 70
15981: PUSH
15982: LD_INT 0
15984: EQUAL
15985: OR
15986: IFFALSE 16024
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
15988: LD_VAR 0 1
15992: PPUSH
15993: LD_INT 81
15995: PUSH
15996: LD_INT 3
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: PPUSH
16008: LD_VAR 0 1
16012: PPUSH
16013: CALL_OW 74
16017: PPUSH
16018: CALL_OW 115
16022: GO 16438
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16024: LD_VAR 0 1
16028: PPUSH
16029: CALL_OW 264
16033: PUSH
16034: LD_INT 45
16036: EQUAL
16037: PUSH
16038: LD_EXP 35
16042: PPUSH
16043: LD_INT 3
16045: PUSH
16046: LD_INT 34
16048: PUSH
16049: LD_INT 45
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: PPUSH
16060: CALL_OW 72
16064: PUSH
16065: LD_INT 6
16067: GREATER
16068: AND
16069: IFFALSE 16250
// begin dist := 9999 ;
16071: LD_ADDR_VAR 0 8
16075: PUSH
16076: LD_INT 9999
16078: ST_TO_ADDR
// xy := 0 ;
16079: LD_ADDR_VAR 0 9
16083: PUSH
16084: LD_INT 0
16086: ST_TO_ADDR
// for x in pointsr do
16087: LD_ADDR_VAR 0 7
16091: PUSH
16092: LD_VAR 0 6
16096: PUSH
16097: FOR_IN
16098: IFFALSE 16246
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16100: LD_VAR 0 1
16104: PPUSH
16105: LD_VAR 0 7
16109: PUSH
16110: LD_INT 1
16112: ARRAY
16113: PPUSH
16114: LD_VAR 0 7
16118: PUSH
16119: LD_INT 2
16121: ARRAY
16122: PPUSH
16123: CALL_OW 297
16127: PUSH
16128: LD_VAR 0 8
16132: LESS
16133: IFFALSE 16178
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16135: LD_ADDR_VAR 0 8
16139: PUSH
16140: LD_VAR 0 1
16144: PPUSH
16145: LD_VAR 0 7
16149: PUSH
16150: LD_INT 1
16152: ARRAY
16153: PPUSH
16154: LD_VAR 0 7
16158: PUSH
16159: LD_INT 2
16161: ARRAY
16162: PPUSH
16163: CALL_OW 297
16167: ST_TO_ADDR
// xy := x ;
16168: LD_ADDR_VAR 0 9
16172: PUSH
16173: LD_VAR 0 7
16177: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16178: LD_VAR 0 9
16182: PUSH
16183: LD_VAR 0 1
16187: PPUSH
16188: LD_VAR 0 9
16192: PUSH
16193: LD_INT 1
16195: ARRAY
16196: PPUSH
16197: LD_VAR 0 9
16201: PUSH
16202: LD_INT 2
16204: ARRAY
16205: PPUSH
16206: CALL_OW 297
16210: PUSH
16211: LD_INT 9
16213: GREATER
16214: AND
16215: IFFALSE 16244
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16217: LD_VAR 0 1
16221: PPUSH
16222: LD_VAR 0 9
16226: PUSH
16227: LD_INT 1
16229: ARRAY
16230: PPUSH
16231: LD_VAR 0 9
16235: PUSH
16236: LD_INT 2
16238: ARRAY
16239: PPUSH
16240: CALL_OW 114
// end ;
16244: GO 16097
16246: POP
16247: POP
// end else
16248: GO 16438
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16250: LD_ADDR_VAR 0 3
16254: PUSH
16255: LD_OWVAR 3
16259: PUSH
16260: LD_VAR 0 1
16264: DIFF
16265: PPUSH
16266: LD_VAR 0 1
16270: PPUSH
16271: CALL_OW 74
16275: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16276: LD_VAR 0 1
16280: PPUSH
16281: CALL_OW 320
16285: NOT
16286: PUSH
16287: LD_VAR 0 3
16291: PUSH
16292: LD_INT 21
16294: PUSH
16295: LD_INT 2
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: PUSH
16302: LD_INT 33
16304: PUSH
16305: LD_INT 1
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: PUSH
16312: LD_INT 58
16314: PUSH
16315: EMPTY
16316: LIST
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: LIST
16322: PPUSH
16323: CALL_OW 69
16327: IN
16328: PUSH
16329: LD_VAR 0 3
16333: PUSH
16334: LD_INT 22
16336: PUSH
16337: LD_INT 3
16339: PUSH
16340: EMPTY
16341: LIST
16342: LIST
16343: PUSH
16344: LD_INT 21
16346: PUSH
16347: LD_INT 2
16349: PUSH
16350: EMPTY
16351: LIST
16352: LIST
16353: PUSH
16354: LD_INT 3
16356: PUSH
16357: LD_INT 24
16359: PUSH
16360: LD_INT 249
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: PUSH
16371: EMPTY
16372: LIST
16373: LIST
16374: LIST
16375: PPUSH
16376: CALL_OW 69
16380: IN
16381: OR
16382: AND
16383: IFFALSE 16401
// ComAttackUnit ( i , un ) else
16385: LD_VAR 0 1
16389: PPUSH
16390: LD_VAR 0 3
16394: PPUSH
16395: CALL_OW 115
16399: GO 16438
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16401: LD_VAR 0 1
16405: PPUSH
16406: LD_INT 9
16408: PPUSH
16409: LD_INT 81
16411: PUSH
16412: LD_INT 3
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: PPUSH
16419: CALL_OW 70
16423: PPUSH
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL_OW 74
16433: PPUSH
16434: CALL_OW 115
// end ; end ; end ; end ;
16438: GO 15705
16440: POP
16441: POP
// end ;
16442: PPOPN 9
16444: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16445: LD_INT 22
16447: PUSH
16448: LD_INT 3
16450: PUSH
16451: EMPTY
16452: LIST
16453: LIST
16454: PUSH
16455: LD_INT 32
16457: PUSH
16458: LD_INT 1
16460: PUSH
16461: EMPTY
16462: LIST
16463: LIST
16464: PUSH
16465: EMPTY
16466: LIST
16467: LIST
16468: PPUSH
16469: CALL_OW 69
16473: IFFALSE 16561
16475: GO 16477
16477: DISABLE
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
// begin enable ;
16482: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16483: LD_ADDR_VAR 0 2
16487: PUSH
16488: LD_INT 22
16490: PUSH
16491: LD_INT 3
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: PUSH
16498: LD_INT 32
16500: PUSH
16501: LD_INT 1
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PPUSH
16512: CALL_OW 69
16516: ST_TO_ADDR
// for i in tmp do
16517: LD_ADDR_VAR 0 1
16521: PUSH
16522: LD_VAR 0 2
16526: PUSH
16527: FOR_IN
16528: IFFALSE 16559
// if GetFuel ( i ) < 12 then
16530: LD_VAR 0 1
16534: PPUSH
16535: CALL_OW 261
16539: PUSH
16540: LD_INT 12
16542: LESS
16543: IFFALSE 16557
// SetFuel ( i , 12 ) ;
16545: LD_VAR 0 1
16549: PPUSH
16550: LD_INT 12
16552: PPUSH
16553: CALL_OW 240
16557: GO 16527
16559: POP
16560: POP
// end ;
16561: PPOPN 2
16563: END
// every 0 0$1 trigger can_end do
16564: LD_EXP 17
16568: IFFALSE 16587
16570: GO 16572
16572: DISABLE
// begin Wait ( 1 1$35 ) ;
16573: LD_INT 3325
16575: PPUSH
16576: CALL_OW 67
// PrepareAttack ( 10 ) ;
16580: LD_INT 10
16582: PPUSH
16583: CALL 14420 0 1
// end ;
16587: END
