// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12623 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1708 0 0
// Action ;
  32: CALL 2648 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1641: LD_STRING GammaCommander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1676
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1676: LD_ADDR_EXP 25
1680: PUSH
1681: LD_STRING Powell
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_STRING 
1689: PPUSH
1690: CALL 201 0 3
1694: ST_TO_ADDR
// InitHc ;
1695: CALL_OW 19
// InitUc ;
1699: CALL_OW 18
// end ;
1703: LD_VAR 0 1
1707: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1708: LD_INT 0
1710: PPUSH
1711: PPUSH
1712: PPUSH
1713: PPUSH
1714: PPUSH
// uc_side := 4 ;
1715: LD_ADDR_OWVAR 20
1719: PUSH
1720: LD_INT 4
1722: ST_TO_ADDR
// uc_nation := 3 ;
1723: LD_ADDR_OWVAR 21
1727: PUSH
1728: LD_INT 3
1730: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_STRING 09_ovsyenko_base
1738: PPUSH
1739: LD_INT 0
1741: PUSH
1742: LD_INT 101
1744: PUSH
1745: LD_INT 118
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 500
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: LD_INT 31
1763: PUSH
1764: LD_INT 109
1766: PUSH
1767: LD_INT 114
1769: PUSH
1770: LD_INT 4
1772: PUSH
1773: LD_INT 500
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 115
1788: PUSH
1789: LD_INT 132
1791: PUSH
1792: LD_INT 5
1794: PUSH
1795: LD_INT 500
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 31
1807: PUSH
1808: LD_INT 98
1810: PUSH
1811: LD_INT 120
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 500
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL_OW 30
1837: ST_TO_ADDR
// for i in tmp do
1838: LD_ADDR_VAR 0 2
1842: PUSH
1843: LD_VAR 0 4
1847: PUSH
1848: FOR_IN
1849: IFFALSE 2005
// begin bc_type := i [ 1 ] ;
1851: LD_ADDR_OWVAR 42
1855: PUSH
1856: LD_VAR 0 2
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: ST_TO_ADDR
// bc_level := 3 ;
1865: LD_ADDR_OWVAR 43
1869: PUSH
1870: LD_INT 3
1872: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_VAR 0 2
1882: PUSH
1883: LD_INT 2
1885: ARRAY
1886: PPUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_INT 3
1894: ARRAY
1895: PPUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 4
1903: ARRAY
1904: PPUSH
1905: CALL_OW 47
1909: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 266
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: IFFALSE 1957
// begin SetBName ( b , ovsyenko ) ;
1925: LD_VAR 0 3
1929: PPUSH
1930: LD_STRING ovsyenko
1932: PPUSH
1933: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: CALL_OW 274
1946: PPUSH
1947: LD_INT 1
1949: PPUSH
1950: LD_INT 50
1952: PPUSH
1953: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 5
1964: ARRAY
1965: PUSH
1966: LD_INT 250
1968: LESS
1969: IFFALSE 1985
// SetLives ( b , 333 ) else
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_INT 333
1978: PPUSH
1979: CALL_OW 234
1983: GO 2003
// SetLives ( b , i [ 5 ] ) ;
1985: LD_VAR 0 3
1989: PPUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 5
1997: ARRAY
1998: PPUSH
1999: CALL_OW 234
// end ;
2003: GO 1848
2005: POP
2006: POP
// uc_nation := 1 ;
2007: LD_ADDR_OWVAR 21
2011: PUSH
2012: LD_INT 1
2014: ST_TO_ADDR
// tmp := [ ] ;
2015: LD_ADDR_VAR 0 4
2019: PUSH
2020: EMPTY
2021: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2022: LD_ADDR_EXP 19
2026: PUSH
2027: LD_STRING Gary
2029: PPUSH
2030: LD_EXP 2
2034: NOT
2035: PPUSH
2036: LD_STRING 
2038: PPUSH
2039: CALL 201 0 3
2043: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2044: LD_ADDR_VAR 0 4
2048: PUSH
2049: LD_VAR 0 4
2053: PUSH
2054: LD_EXP 19
2058: ADD
2059: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2060: LD_ADDR_EXP 20
2064: PUSH
2065: LD_STRING Bobby
2067: PPUSH
2068: LD_EXP 2
2072: NOT
2073: PPUSH
2074: LD_STRING 08_
2076: PPUSH
2077: CALL 201 0 3
2081: ST_TO_ADDR
// if not Bobby then
2082: LD_EXP 20
2086: NOT
2087: IFFALSE 2111
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2089: LD_ADDR_EXP 20
2093: PUSH
2094: LD_STRING Bobby
2096: PPUSH
2097: LD_EXP 2
2101: NOT
2102: PPUSH
2103: LD_STRING 03_
2105: PPUSH
2106: CALL 201 0 3
2110: ST_TO_ADDR
// if Bobby then
2111: LD_EXP 20
2115: IFFALSE 2133
// tmp := tmp ^ Bobby ;
2117: LD_ADDR_VAR 0 4
2121: PUSH
2122: LD_VAR 0 4
2126: PUSH
2127: LD_EXP 20
2131: ADD
2132: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2133: LD_ADDR_EXP 21
2137: PUSH
2138: LD_STRING Cyrus
2140: PPUSH
2141: LD_EXP 2
2145: NOT
2146: PPUSH
2147: LD_STRING 08_
2149: PPUSH
2150: CALL 201 0 3
2154: ST_TO_ADDR
// if not Cyrus then
2155: LD_EXP 21
2159: NOT
2160: IFFALSE 2184
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2162: LD_ADDR_EXP 21
2166: PUSH
2167: LD_STRING Cyrus
2169: PPUSH
2170: LD_EXP 2
2174: NOT
2175: PPUSH
2176: LD_STRING 03_
2178: PPUSH
2179: CALL 201 0 3
2183: ST_TO_ADDR
// if Cyrus then
2184: LD_EXP 21
2188: IFFALSE 2206
// tmp := tmp ^ Cyrus ;
2190: LD_ADDR_VAR 0 4
2194: PUSH
2195: LD_VAR 0 4
2199: PUSH
2200: LD_EXP 21
2204: ADD
2205: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2206: LD_ADDR_VAR 0 4
2210: PUSH
2211: LD_VAR 0 4
2215: PUSH
2216: LD_STRING 09_prev_squad
2218: PPUSH
2219: CALL_OW 31
2223: ADD
2224: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2225: LD_STRING 09_prev_squad
2227: PPUSH
2228: CALL_OW 40
// tmp := tmp diff 0 ;
2232: LD_ADDR_VAR 0 4
2236: PUSH
2237: LD_VAR 0 4
2241: PUSH
2242: LD_INT 0
2244: DIFF
2245: ST_TO_ADDR
// if debug then
2246: LD_EXP 2
2250: IFFALSE 2301
// begin for i = 1 to 6 do
2252: LD_ADDR_VAR 0 2
2256: PUSH
2257: DOUBLE
2258: LD_INT 1
2260: DEC
2261: ST_TO_ADDR
2262: LD_INT 6
2264: PUSH
2265: FOR_TO
2266: IFFALSE 2299
// begin PrepareHuman ( false , 1 , 6 ) ;
2268: LD_INT 0
2270: PPUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 6
2276: PPUSH
2277: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: CALL_OW 44
2295: ADD
2296: ST_TO_ADDR
// end ;
2297: GO 2265
2299: POP
2300: POP
// end ; for i in tmp do
2301: LD_ADDR_VAR 0 2
2305: PUSH
2306: LD_VAR 0 4
2310: PUSH
2311: FOR_IN
2312: IFFALSE 2371
// begin if GetClass ( i ) in [ 2 , 3 ] then
2314: LD_VAR 0 2
2318: PPUSH
2319: CALL_OW 257
2323: PUSH
2324: LD_INT 2
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: IN
2334: IFFALSE 2348
// SetClass ( i , 1 ) ;
2336: LD_VAR 0 2
2340: PPUSH
2341: LD_INT 1
2343: PPUSH
2344: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2348: LD_VAR 0 2
2352: PPUSH
2353: LD_INT 106
2355: PPUSH
2356: LD_INT 122
2358: PPUSH
2359: LD_INT 5
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 50
// end ;
2369: GO 2311
2371: POP
2372: POP
// tmp := tmp diff Gary ;
2373: LD_ADDR_VAR 0 4
2377: PUSH
2378: LD_VAR 0 4
2382: PUSH
2383: LD_EXP 19
2387: DIFF
2388: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2389: LD_ADDR_VAR 0 3
2393: PUSH
2394: LD_INT 22
2396: PUSH
2397: LD_INT 4
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PUSH
2404: LD_INT 30
2406: PUSH
2407: LD_INT 31
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: PPUSH
2418: CALL_OW 69
2422: ST_TO_ADDR
// for i = 1 to b do
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: DOUBLE
2429: LD_INT 1
2431: DEC
2432: ST_TO_ADDR
2433: LD_VAR 0 3
2437: PUSH
2438: FOR_TO
2439: IFFALSE 2469
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2441: LD_VAR 0 4
2445: PUSH
2446: LD_VAR 0 2
2450: ARRAY
2451: PPUSH
2452: LD_VAR 0 3
2456: PUSH
2457: LD_VAR 0 2
2461: ARRAY
2462: PPUSH
2463: CALL_OW 120
// end ;
2467: GO 2438
2469: POP
2470: POP
// InitHc ;
2471: CALL_OW 19
// InitUc ;
2475: CALL_OW 18
// end ;
2479: LD_VAR 0 1
2483: RET
// export function PowellTransport ; var i , un ; begin
2484: LD_INT 0
2486: PPUSH
2487: PPUSH
2488: PPUSH
// uc_side := 4 ;
2489: LD_ADDR_OWVAR 20
2493: PUSH
2494: LD_INT 4
2496: ST_TO_ADDR
// uc_nation := 1 ;
2497: LD_ADDR_OWVAR 21
2501: PUSH
2502: LD_INT 1
2504: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2505: LD_INT 1
2507: PPUSH
2508: LD_INT 3
2510: PPUSH
2511: LD_INT 6
2513: PPUSH
2514: CALL_OW 380
// hc_name :=  ;
2518: LD_ADDR_OWVAR 26
2522: PUSH
2523: LD_STRING 
2525: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2526: LD_ADDR_OWVAR 33
2530: PUSH
2531: LD_STRING SecondCharsGal
2533: ST_TO_ADDR
// hc_face_number := 30 ;
2534: LD_ADDR_OWVAR 34
2538: PUSH
2539: LD_INT 30
2541: ST_TO_ADDR
// powell_trans := CreateHuman ;
2542: LD_ADDR_EXP 24
2546: PUSH
2547: CALL_OW 44
2551: ST_TO_ADDR
// hc_face_number := 31 ;
2552: LD_ADDR_OWVAR 34
2556: PUSH
2557: LD_INT 31
2559: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2560: LD_ADDR_EXP 24
2564: PUSH
2565: LD_EXP 24
2569: PUSH
2570: CALL_OW 44
2574: ADD
2575: ST_TO_ADDR
// for i = 1 to 2 do
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: DOUBLE
2582: LD_INT 1
2584: DEC
2585: ST_TO_ADDR
2586: LD_INT 2
2588: PUSH
2589: FOR_TO
2590: IFFALSE 2641
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2592: LD_ADDR_VAR 0 3
2596: PUSH
2597: LD_INT 4
2599: PPUSH
2600: LD_INT 1
2602: PPUSH
2603: LD_INT 3
2605: PPUSH
2606: LD_INT 1
2608: PPUSH
2609: LD_INT 1
2611: PPUSH
2612: LD_INT 12
2614: PPUSH
2615: LD_INT 66
2617: PPUSH
2618: CALL 264 0 7
2622: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2623: LD_ADDR_EXP 24
2627: PUSH
2628: LD_EXP 24
2632: PUSH
2633: LD_VAR 0 3
2637: ADD
2638: ST_TO_ADDR
// end ;
2639: GO 2589
2641: POP
2642: POP
// end ; end_of_file
2643: LD_VAR 0 1
2647: RET
// export function Action ; var i , veh ; begin
2648: LD_INT 0
2650: PPUSH
2651: PPUSH
2652: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2653: LD_EXP 23
2657: PPUSH
2658: LD_INT 0
2660: PPUSH
2661: LD_INT 50
2663: PPUSH
2664: LD_INT 38
2666: PPUSH
2667: LD_INT 2
2669: PPUSH
2670: CALL_OW 145
// InGameOn ;
2674: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2678: LD_INT 43
2680: PPUSH
2681: LD_INT 9
2683: PPUSH
2684: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2688: LD_EXP 18
2692: PPUSH
2693: LD_INT 54
2695: PPUSH
2696: LD_INT 34
2698: PPUSH
2699: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2703: LD_EXP 18
2707: PPUSH
2708: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2712: LD_EXP 18
2716: PPUSH
2717: LD_EXP 23
2721: PUSH
2722: LD_INT 1
2724: ARRAY
2725: PPUSH
2726: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2730: LD_INT 35
2732: PPUSH
2733: CALL_OW 67
// until See ( 4 , JMM ) ;
2737: LD_INT 4
2739: PPUSH
2740: LD_EXP 18
2744: PPUSH
2745: CALL_OW 292
2749: IFFALSE 2730
// CenterNowOnUnits ( JMM ) ;
2751: LD_EXP 18
2755: PPUSH
2756: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2760: LD_EXP 18
2764: PPUSH
2765: LD_STRING D2-JMM-1
2767: PPUSH
2768: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2772: LD_EXP 23
2776: PUSH
2777: LD_INT 3
2779: ARRAY
2780: PPUSH
2781: LD_EXP 18
2785: PPUSH
2786: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2790: LD_EXP 23
2794: PUSH
2795: LD_INT 3
2797: ARRAY
2798: PPUSH
2799: LD_STRING D2-Eng1-1
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2806: LD_EXP 18
2810: PPUSH
2811: LD_STRING D2-JMM-2
2813: PPUSH
2814: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2818: LD_EXP 23
2822: PUSH
2823: LD_INT 3
2825: ARRAY
2826: PPUSH
2827: LD_STRING D2-Eng1-2
2829: PPUSH
2830: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2834: LD_EXP 18
2838: PPUSH
2839: LD_STRING D2-JMM-3
2841: PPUSH
2842: CALL_OW 88
// if Houten then
2846: LD_EXP 22
2850: IFFALSE 3048
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2852: LD_ADDR_VAR 0 3
2856: PUSH
2857: LD_INT 4
2859: PPUSH
2860: LD_INT 1
2862: PPUSH
2863: LD_INT 3
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: LD_INT 1
2871: PPUSH
2872: LD_INT 4
2874: PPUSH
2875: LD_INT 55
2877: PPUSH
2878: CALL 264 0 7
2882: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2883: LD_VAR 0 3
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2895: LD_VAR 0 3
2899: PPUSH
2900: LD_INT 46
2902: PPUSH
2903: LD_INT 19
2905: PPUSH
2906: LD_INT 0
2908: PPUSH
2909: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2913: LD_EXP 22
2917: PPUSH
2918: LD_VAR 0 3
2922: PPUSH
2923: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2927: LD_EXP 22
2931: PPUSH
2932: LD_INT 49
2934: PPUSH
2935: LD_INT 33
2937: PPUSH
2938: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2942: LD_EXP 22
2946: PPUSH
2947: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2951: LD_EXP 22
2955: PPUSH
2956: LD_EXP 18
2960: PPUSH
2961: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2965: LD_INT 35
2967: PPUSH
2968: CALL_OW 67
// until See ( 1 , Houten ) ;
2972: LD_INT 1
2974: PPUSH
2975: LD_EXP 22
2979: PPUSH
2980: CALL_OW 292
2984: IFFALSE 2965
// ComTurnUnit ( JMM , Houten ) ;
2986: LD_EXP 18
2990: PPUSH
2991: LD_EXP 22
2995: PPUSH
2996: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3000: LD_EXP 18
3004: PPUSH
3005: LD_STRING D1d-JMM-1
3007: PPUSH
3008: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3012: LD_EXP 22
3016: PPUSH
3017: LD_STRING D1-VanH-1
3019: PPUSH
3020: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3024: LD_EXP 18
3028: PPUSH
3029: LD_STRING D1-JMM-1v
3031: PPUSH
3032: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3036: LD_EXP 18
3040: PPUSH
3041: LD_STRING D1-JMM-2v
3043: PPUSH
3044: CALL_OW 88
// end ; InGameOff ;
3048: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3052: LD_STRING M1
3054: PPUSH
3055: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3059: LD_INT 22
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 92
3071: PUSH
3072: LD_EXP 18
3076: PPUSH
3077: CALL_OW 250
3081: PUSH
3082: LD_EXP 18
3086: PPUSH
3087: CALL_OW 251
3091: PUSH
3092: LD_INT 15
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PPUSH
3110: LD_INT 1
3112: PPUSH
3113: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3117: LD_EXP 23
3121: PUSH
3122: LD_EXP 18
3126: ADD
3127: PUSH
3128: LD_EXP 22
3132: ADD
3133: PPUSH
3134: CALL_OW 141
// end ;
3138: LD_VAR 0 1
3142: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3143: LD_INT 1
3145: PPUSH
3146: LD_EXP 19
3150: PPUSH
3151: CALL_OW 292
3155: PUSH
3156: LD_EXP 18
3160: PPUSH
3161: LD_EXP 19
3165: PPUSH
3166: CALL_OW 296
3170: PUSH
3171: LD_INT 6
3173: LESS
3174: AND
3175: IFFALSE 3938
3177: GO 3179
3179: DISABLE
3180: LD_INT 0
3182: PPUSH
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
// begin InGameOn ;
3187: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3191: LD_INT 22
3193: PUSH
3194: LD_INT 4
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: PPUSH
3201: CALL_OW 69
3205: PPUSH
3206: LD_INT 1
3208: PPUSH
3209: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3213: LD_ADDR_VAR 0 4
3217: PUSH
3218: LD_INT 22
3220: PUSH
3221: LD_INT 1
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: LD_INT 2
3230: PUSH
3231: LD_INT 25
3233: PUSH
3234: LD_INT 1
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: PUSH
3241: LD_INT 25
3243: PUSH
3244: LD_INT 2
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 25
3253: PUSH
3254: LD_INT 3
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 25
3263: PUSH
3264: LD_INT 4
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 69
3286: ST_TO_ADDR
// ComHold ( tmp ) ;
3287: LD_VAR 0 4
3291: PPUSH
3292: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3296: LD_EXP 18
3300: PPUSH
3301: LD_STRING D2-JMM-3a
3303: PPUSH
3304: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3308: LD_EXP 19
3312: PPUSH
3313: LD_EXP 18
3317: PPUSH
3318: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3322: LD_EXP 19
3326: PPUSH
3327: LD_STRING D2-Gary-3
3329: PPUSH
3330: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3334: LD_EXP 18
3338: PPUSH
3339: LD_EXP 19
3343: PPUSH
3344: CALL_OW 119
// for i in tmp do
3348: LD_ADDR_VAR 0 5
3352: PUSH
3353: LD_VAR 0 4
3357: PUSH
3358: FOR_IN
3359: IFFALSE 3404
// begin if IsInUnit ( i ) then
3361: LD_VAR 0 5
3365: PPUSH
3366: CALL_OW 310
3370: IFFALSE 3381
// ComExitBuilding ( i ) ;
3372: LD_VAR 0 5
3376: PPUSH
3377: CALL_OW 122
// wait ( 1 ) ;
3381: LD_INT 1
3383: PPUSH
3384: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3388: LD_VAR 0 5
3392: PPUSH
3393: LD_EXP 18
3397: PPUSH
3398: CALL_OW 119
// end ;
3402: GO 3358
3404: POP
3405: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3406: LD_ADDR_VAR 0 4
3410: PUSH
3411: LD_VAR 0 4
3415: PUSH
3416: LD_EXP 18
3420: PUSH
3421: LD_EXP 22
3425: PUSH
3426: LD_EXP 19
3430: PUSH
3431: LD_EXP 21
3435: PUSH
3436: LD_EXP 20
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: PUSH
3448: LD_EXP 23
3452: ADD
3453: DIFF
3454: ST_TO_ADDR
// if Bobby then
3455: LD_EXP 20
3459: IFFALSE 3473
// Say ( Bobby , D2-Bobby-3 ) ;
3461: LD_EXP 20
3465: PPUSH
3466: LD_STRING D2-Bobby-3
3468: PPUSH
3469: CALL_OW 88
// if Cyrus then
3473: LD_EXP 21
3477: IFFALSE 3491
// Say ( Cyrus , D2-Cyrus-3 ) ;
3479: LD_EXP 21
3483: PPUSH
3484: LD_STRING D2-Cyrus-3
3486: PPUSH
3487: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3491: LD_EXP 18
3495: PPUSH
3496: LD_STRING D2-JMM-4
3498: PPUSH
3499: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3503: LD_EXP 19
3507: PPUSH
3508: LD_STRING D2-Gary-4
3510: PPUSH
3511: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3515: LD_ADDR_VAR 0 1
3519: PUSH
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 26
3527: PUSH
3528: LD_INT 1
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: PUSH
3540: LD_INT 1
3542: ARRAY
3543: ST_TO_ADDR
// if Cyrus then
3544: LD_EXP 21
3548: IFFALSE 3564
// Say ( Cyrus , D2-Cyrus-4 ) else
3550: LD_EXP 21
3554: PPUSH
3555: LD_STRING D2-Cyrus-4
3557: PPUSH
3558: CALL_OW 88
3562: GO 3576
// Say ( un1 , D2-Sol1-4 ) ;
3564: LD_VAR 0 1
3568: PPUSH
3569: LD_STRING D2-Sol1-4
3571: PPUSH
3572: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3576: LD_EXP 18
3580: PPUSH
3581: LD_STRING D2-JMM-5
3583: PPUSH
3584: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_EXP 23
3597: PPUSH
3598: LD_INT 91
3600: PUSH
3601: LD_EXP 18
3605: PUSH
3606: LD_INT 10
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 26
3616: PUSH
3617: LD_INT 2
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PPUSH
3628: CALL_OW 72
3632: ST_TO_ADDR
// if un2 then
3633: LD_VAR 0 2
3637: IFFALSE 3691
// begin un2 := un2 [ un2 ] ;
3639: LD_ADDR_VAR 0 2
3643: PUSH
3644: LD_VAR 0 2
3648: PUSH
3649: LD_VAR 0 2
3653: ARRAY
3654: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3655: LD_VAR 0 2
3659: PPUSH
3660: LD_STRING D2-FEng1-5
3662: PPUSH
3663: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3667: LD_EXP 18
3671: PPUSH
3672: LD_STRING D2-JMM-6
3674: PPUSH
3675: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3679: LD_VAR 0 2
3683: PPUSH
3684: LD_STRING D2-FEng1-6
3686: PPUSH
3687: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3691: LD_ADDR_VAR 0 3
3695: PUSH
3696: LD_EXP 23
3700: PPUSH
3701: LD_INT 91
3703: PUSH
3704: LD_EXP 18
3708: PUSH
3709: LD_INT 10
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 26
3719: PUSH
3720: LD_INT 1
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PPUSH
3731: CALL_OW 72
3735: ST_TO_ADDR
// if un3 then
3736: LD_VAR 0 3
3740: IFFALSE 3795
// begin un3 := un3 [ 1 ] ;
3742: LD_ADDR_VAR 0 3
3746: PUSH
3747: LD_VAR 0 3
3751: PUSH
3752: LD_INT 1
3754: ARRAY
3755: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3756: LD_VAR 0 3
3760: PPUSH
3761: LD_INT 114
3763: PPUSH
3764: LD_INT 122
3766: PPUSH
3767: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3771: LD_VAR 0 3
3775: PPUSH
3776: LD_STRING D2-Eng1-6
3778: PPUSH
3779: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3783: LD_EXP 18
3787: PPUSH
3788: LD_STRING D2-JMM-7
3790: PPUSH
3791: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3795: LD_EXP 19
3799: PPUSH
3800: LD_STRING D2-Gary-7
3802: PPUSH
3803: CALL_OW 88
// if un2 then
3807: LD_VAR 0 2
3811: IFFALSE 3825
// Say ( un2 , D2-FEng1-7 ) ;
3813: LD_VAR 0 2
3817: PPUSH
3818: LD_STRING D2-FEng1-7
3820: PPUSH
3821: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3825: LD_VAR 0 1
3829: PPUSH
3830: LD_STRING D2-Sol1-7
3832: PPUSH
3833: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3837: LD_EXP 18
3841: PPUSH
3842: LD_STRING D2-JMM-8
3844: PPUSH
3845: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3849: LD_INT 22
3851: PUSH
3852: LD_INT 1
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PPUSH
3859: CALL_OW 69
3863: PPUSH
3864: CALL_OW 141
// InGameOff ;
3868: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3872: LD_STRING M1a
3874: PPUSH
3875: CALL_OW 337
// jmm_in_ovsyenko := true ;
3879: LD_ADDR_EXP 4
3883: PUSH
3884: LD_INT 1
3886: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3887: LD_INT 1050
3889: PPUSH
3890: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: LD_INT 25
3901: PUSH
3902: LD_INT 14
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PPUSH
3909: CALL_OW 69
3913: ST_TO_ADDR
// if not tmp then
3914: LD_VAR 0 4
3918: NOT
3919: IFFALSE 3923
// exit ;
3921: GO 3938
// ComMoveXY ( tmp , 75 , 75 ) ;
3923: LD_VAR 0 4
3927: PPUSH
3928: LD_INT 75
3930: PPUSH
3931: LD_INT 75
3933: PPUSH
3934: CALL_OW 111
// end ;
3938: PPOPN 5
3940: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3941: LD_INT 22
3943: PUSH
3944: LD_INT 1
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: PUSH
3951: LD_INT 30
3953: PUSH
3954: LD_INT 30
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PUSH
3961: LD_INT 3
3963: PUSH
3964: LD_INT 57
3966: PUSH
3967: EMPTY
3968: LIST
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: PPUSH
3979: CALL_OW 69
3983: IFFALSE 4025
3985: GO 3987
3987: DISABLE
3988: LD_INT 0
3990: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3991: LD_ADDR_VAR 0 1
3995: PUSH
3996: LD_STRING M2easy
3998: PUSH
3999: LD_STRING M2
4001: PUSH
4002: LD_STRING M2hard
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4010: LD_VAR 0 1
4014: PUSH
4015: LD_OWVAR 67
4019: ARRAY
4020: PPUSH
4021: CALL_OW 337
// end ;
4025: PPOPN 1
4027: END
// every 3 3$00 do
4028: GO 4030
4030: DISABLE
// begin DialogueOn ;
4031: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4035: LD_EXP 25
4039: PPUSH
4040: LD_STRING D3-Pow-1
4042: PPUSH
4043: CALL_OW 94
// if jmm_in_ovsyenko then
4047: LD_EXP 4
4051: IFFALSE 4079
// begin Say ( JMM , D3-JMM-1 ) ;
4053: LD_EXP 18
4057: PPUSH
4058: LD_STRING D3-JMM-1
4060: PPUSH
4061: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4065: LD_EXP 18
4069: PPUSH
4070: LD_STRING D3-JMM-1b
4072: PPUSH
4073: CALL_OW 88
// end else
4077: GO 4091
// Say ( JMM , D3-JMM-1a ) ;
4079: LD_EXP 18
4083: PPUSH
4084: LD_STRING D3-JMM-1a
4086: PPUSH
4087: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4091: LD_EXP 25
4095: PPUSH
4096: LD_STRING D3-Pow-2
4098: PPUSH
4099: CALL_OW 94
// DialogueOff ;
4103: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4107: LD_STRING M3
4109: PPUSH
4110: CALL_OW 337
// powell_want_sib := true ;
4114: LD_ADDR_EXP 5
4118: PUSH
4119: LD_INT 1
4121: ST_TO_ADDR
// end ;
4122: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4123: LD_EXP 6
4127: PUSH
4128: LD_INT 0
4130: EQUAL
4131: IFFALSE 5578
4133: GO 4135
4135: DISABLE
4136: LD_INT 0
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
4145: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4146: LD_INT 4
4148: PPUSH
4149: LD_INT 1
4151: PPUSH
4152: CALL_OW 343
// PowellTransport ;
4156: CALL 2484 0 0
// for i = 1 to 3 do
4160: LD_ADDR_VAR 0 4
4164: PUSH
4165: DOUBLE
4166: LD_INT 1
4168: DEC
4169: ST_TO_ADDR
4170: LD_INT 3
4172: PUSH
4173: FOR_TO
4174: IFFALSE 4241
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4176: LD_ADDR_VAR 0 1
4180: PUSH
4181: LD_INT 6
4183: PPUSH
4184: LD_VAR 0 4
4188: PPUSH
4189: CALL_OW 287
4193: ST_TO_ADDR
// if not tmp then
4194: LD_VAR 0 1
4198: NOT
4199: IFFALSE 4203
// continue ;
4201: GO 4173
// EraseResourceArea ( terminalArea , i ) ;
4203: LD_INT 6
4205: PPUSH
4206: LD_VAR 0 4
4210: PPUSH
4211: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4215: LD_EXP 3
4219: PPUSH
4220: CALL_OW 274
4224: PPUSH
4225: LD_VAR 0 4
4229: PPUSH
4230: LD_VAR 0 1
4234: PPUSH
4235: CALL_OW 276
// end ;
4239: GO 4173
4241: POP
4242: POP
// x := 43 ;
4243: LD_ADDR_VAR 0 2
4247: PUSH
4248: LD_INT 43
4250: ST_TO_ADDR
// y := 3 ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: LD_INT 3
4258: ST_TO_ADDR
// for i = 3 to 4 do
4259: LD_ADDR_VAR 0 4
4263: PUSH
4264: DOUBLE
4265: LD_INT 3
4267: DEC
4268: ST_TO_ADDR
4269: LD_INT 4
4271: PUSH
4272: FOR_TO
4273: IFFALSE 4464
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4275: LD_EXP 24
4279: PUSH
4280: LD_VAR 0 4
4284: ARRAY
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4293: LD_EXP 24
4297: PUSH
4298: LD_VAR 0 4
4302: ARRAY
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: LD_VAR 0 3
4313: PPUSH
4314: LD_INT 0
4316: PPUSH
4317: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4321: LD_EXP 24
4325: PUSH
4326: LD_VAR 0 4
4330: PUSH
4331: LD_INT 2
4333: MINUS
4334: ARRAY
4335: PPUSH
4336: LD_EXP 24
4340: PUSH
4341: LD_VAR 0 4
4345: ARRAY
4346: PPUSH
4347: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4351: LD_EXP 24
4355: PUSH
4356: LD_VAR 0 4
4360: ARRAY
4361: PPUSH
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 100
4367: PPUSH
4368: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4372: LD_EXP 24
4376: PUSH
4377: LD_VAR 0 4
4381: PUSH
4382: LD_INT 2
4384: MINUS
4385: ARRAY
4386: PPUSH
4387: LD_INT 54
4389: PPUSH
4390: LD_INT 42
4392: PPUSH
4393: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4397: LD_EXP 24
4401: PUSH
4402: LD_VAR 0 4
4406: PUSH
4407: LD_INT 2
4409: MINUS
4410: ARRAY
4411: PPUSH
4412: LD_EXP 3
4416: PPUSH
4417: CALL_OW 250
4421: PPUSH
4422: LD_EXP 3
4426: PPUSH
4427: CALL_OW 251
4431: PPUSH
4432: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4436: LD_EXP 24
4440: PUSH
4441: LD_VAR 0 4
4445: PUSH
4446: LD_INT 2
4448: MINUS
4449: ARRAY
4450: PPUSH
4451: CALL_OW 200
// Wait ( 0 0$02 ) ;
4455: LD_INT 70
4457: PPUSH
4458: CALL_OW 67
// end ;
4462: GO 4272
4464: POP
4465: POP
// time := 0 0$20 ;
4466: LD_ADDR_VAR 0 8
4470: PUSH
4471: LD_INT 700
4473: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4474: LD_INT 35
4476: PPUSH
4477: CALL_OW 67
// time := time - 0 0$01 ;
4481: LD_ADDR_VAR 0 8
4485: PUSH
4486: LD_VAR 0 8
4490: PUSH
4491: LD_INT 35
4493: MINUS
4494: ST_TO_ADDR
// for i = 3 to 4 do
4495: LD_ADDR_VAR 0 4
4499: PUSH
4500: DOUBLE
4501: LD_INT 3
4503: DEC
4504: ST_TO_ADDR
4505: LD_INT 4
4507: PUSH
4508: FOR_TO
4509: IFFALSE 4644
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4511: LD_EXP 24
4515: PUSH
4516: LD_VAR 0 4
4520: ARRAY
4521: PPUSH
4522: LD_INT 1
4524: PPUSH
4525: CALL_OW 289
4529: PUSH
4530: LD_INT 0
4532: GREATER
4533: PUSH
4534: LD_EXP 24
4538: PUSH
4539: LD_VAR 0 4
4543: ARRAY
4544: PPUSH
4545: CALL_OW 314
4549: NOT
4550: AND
4551: IFFALSE 4642
// begin x := rand ( 0 , 5 ) ;
4553: LD_ADDR_VAR 0 2
4557: PUSH
4558: LD_INT 0
4560: PPUSH
4561: LD_INT 5
4563: PPUSH
4564: CALL_OW 12
4568: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4569: LD_EXP 24
4573: PUSH
4574: LD_VAR 0 4
4578: ARRAY
4579: PPUSH
4580: LD_EXP 24
4584: PUSH
4585: LD_VAR 0 4
4589: ARRAY
4590: PPUSH
4591: CALL_OW 250
4595: PPUSH
4596: LD_VAR 0 2
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: CALL_OW 272
4608: PPUSH
4609: LD_EXP 24
4613: PUSH
4614: LD_VAR 0 4
4618: ARRAY
4619: PPUSH
4620: CALL_OW 251
4624: PPUSH
4625: LD_VAR 0 2
4629: PPUSH
4630: LD_INT 3
4632: PPUSH
4633: CALL_OW 273
4637: PPUSH
4638: CALL_OW 171
// end ;
4642: GO 4508
4644: POP
4645: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4646: LD_EXP 24
4650: PUSH
4651: LD_INT 1
4653: ARRAY
4654: PPUSH
4655: LD_INT 54
4657: PPUSH
4658: LD_INT 42
4660: PPUSH
4661: CALL_OW 297
4665: PUSH
4666: LD_INT 4
4668: LESS
4669: PUSH
4670: LD_VAR 0 8
4674: PUSH
4675: LD_INT 0
4677: EQUAL
4678: OR
4679: IFFALSE 4474
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4681: LD_EXP 24
4685: PUSH
4686: LD_INT 3
4688: ARRAY
4689: PPUSH
4690: LD_INT 1
4692: PPUSH
4693: LD_INT 0
4695: PPUSH
4696: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4700: LD_EXP 24
4704: PUSH
4705: LD_INT 4
4707: ARRAY
4708: PPUSH
4709: LD_INT 1
4711: PPUSH
4712: LD_INT 0
4714: PPUSH
4715: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4719: LD_EXP 3
4723: PPUSH
4724: CALL_OW 274
4728: PPUSH
4729: LD_INT 1
4731: PPUSH
4732: LD_INT 200
4734: PPUSH
4735: CALL_OW 276
// DialogueOn ;
4739: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4743: LD_INT 53
4745: PPUSH
4746: LD_INT 35
4748: PPUSH
4749: CALL_OW 86
// un := powell_trans [ 1 ] ;
4753: LD_ADDR_VAR 0 5
4757: PUSH
4758: LD_EXP 24
4762: PUSH
4763: LD_INT 1
4765: ARRAY
4766: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4767: LD_VAR 0 5
4771: PPUSH
4772: LD_STRING D4-Mech1-1
4774: PPUSH
4775: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4779: LD_EXP 18
4783: PPUSH
4784: LD_STRING D4-JMM-1
4786: PPUSH
4787: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4791: LD_VAR 0 5
4795: PPUSH
4796: LD_STRING D4-Mech1-2
4798: PPUSH
4799: CALL_OW 88
// powell_happy := false ;
4803: LD_ADDR_VAR 0 6
4807: PUSH
4808: LD_INT 0
4810: ST_TO_ADDR
// take_cargo := false ;
4811: LD_ADDR_VAR 0 7
4815: PUSH
4816: LD_INT 0
4818: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4819: CALL 784 0 0
4823: PUSH
4824: LD_INT 60
4826: GREATEREQUAL
4827: IFFALSE 4875
// begin Say ( JMM , D5-JMM-1 ) ;
4829: LD_EXP 18
4833: PPUSH
4834: LD_STRING D5-JMM-1
4836: PPUSH
4837: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4841: LD_VAR 0 5
4845: PPUSH
4846: LD_STRING D6-Mech1-1
4848: PPUSH
4849: CALL_OW 88
// powell_happy := true ;
4853: LD_ADDR_VAR 0 6
4857: PUSH
4858: LD_INT 1
4860: ST_TO_ADDR
// take_cargo := true ;
4861: LD_ADDR_VAR 0 7
4865: PUSH
4866: LD_INT 1
4868: ST_TO_ADDR
// DialogueOff ;
4869: CALL_OW 7
// end else
4873: GO 5109
// if GetTerminalCargo > 0 then
4875: CALL 784 0 0
4879: PUSH
4880: LD_INT 0
4882: GREATER
4883: IFFALSE 5081
// begin case Query ( QWait ) of 1 :
4885: LD_STRING QWait
4887: PPUSH
4888: CALL_OW 97
4892: PUSH
4893: LD_INT 1
4895: DOUBLE
4896: EQUAL
4897: IFTRUE 4901
4899: GO 4992
4901: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4902: LD_EXP 18
4906: PPUSH
4907: LD_STRING D5b-JMM-1
4909: PPUSH
4910: CALL_OW 88
// DialogueOff ;
4914: CALL_OW 7
// wait ( 5 5$00 ) ;
4918: LD_INT 10500
4920: PPUSH
4921: CALL_OW 67
// if GetTerminalCargo < 60 then
4925: CALL 784 0 0
4929: PUSH
4930: LD_INT 60
4932: LESS
4933: IFFALSE 4974
// begin DialogueOn ;
4935: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4939: LD_EXP 3
4943: PPUSH
4944: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_STRING D6-Mech1-1a
4955: PPUSH
4956: CALL_OW 88
// DialogueOff ;
4960: CALL_OW 7
// powell_happy := false ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_INT 0
4971: ST_TO_ADDR
// end else
4972: GO 4990
// begin powell_happy := true ;
4974: LD_ADDR_VAR 0 6
4978: PUSH
4979: LD_INT 1
4981: ST_TO_ADDR
// take_cargo := true ;
4982: LD_ADDR_VAR 0 7
4986: PUSH
4987: LD_INT 1
4989: ST_TO_ADDR
// end ; end ; 2 :
4990: GO 5079
4992: LD_INT 2
4994: DOUBLE
4995: EQUAL
4996: IFTRUE 5000
4998: GO 5039
5000: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5001: LD_EXP 18
5005: PPUSH
5006: LD_STRING D5b-JMM-1
5008: PPUSH
5009: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5013: LD_VAR 0 5
5017: PPUSH
5018: LD_STRING D6-Mech1-1a
5020: PPUSH
5021: CALL_OW 88
// DialogueOff ;
5025: CALL_OW 7
// take_cargo := true ;
5029: LD_ADDR_VAR 0 7
5033: PUSH
5034: LD_INT 1
5036: ST_TO_ADDR
// end ; 3 :
5037: GO 5079
5039: LD_INT 3
5041: DOUBLE
5042: EQUAL
5043: IFTRUE 5047
5045: GO 5078
5047: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5048: LD_EXP 18
5052: PPUSH
5053: LD_STRING D5c-JMM-1
5055: PPUSH
5056: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5060: LD_VAR 0 5
5064: PPUSH
5065: LD_STRING D6-Mech1-1b
5067: PPUSH
5068: CALL_OW 88
// DialogueOff ;
5072: CALL_OW 7
// end ; end ;
5076: GO 5079
5078: POP
// end else
5079: GO 5109
// begin Say ( JMM , D5c-JMM-1 ) ;
5081: LD_EXP 18
5085: PPUSH
5086: LD_STRING D5c-JMM-1
5088: PPUSH
5089: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5093: LD_VAR 0 5
5097: PPUSH
5098: LD_STRING D6-Mech1-1b
5100: PPUSH
5101: CALL_OW 88
// DialogueOff ;
5105: CALL_OW 7
// end ; if take_cargo then
5109: LD_VAR 0 7
5113: IFFALSE 5192
// begin x := GetTerminalCargo ;
5115: LD_ADDR_VAR 0 2
5119: PUSH
5120: CALL 784 0 0
5124: ST_TO_ADDR
// if x > 60 then
5125: LD_VAR 0 2
5129: PUSH
5130: LD_INT 60
5132: GREATER
5133: IFFALSE 5143
// x := 60 ;
5135: LD_ADDR_VAR 0 2
5139: PUSH
5140: LD_INT 60
5142: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5143: LD_EXP 3
5147: PPUSH
5148: CALL_OW 274
5152: PPUSH
5153: LD_INT 3
5155: PPUSH
5156: CALL 784 0 0
5160: PUSH
5161: LD_VAR 0 2
5165: MINUS
5166: PPUSH
5167: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5171: LD_EXP 24
5175: PUSH
5176: LD_INT 3
5178: ARRAY
5179: PPUSH
5180: LD_INT 3
5182: PPUSH
5183: LD_VAR 0 2
5187: PPUSH
5188: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5192: LD_EXP 24
5196: PPUSH
5197: LD_INT 43
5199: PPUSH
5200: LD_INT 3
5202: PPUSH
5203: CALL_OW 171
// x := 0 0$20 ;
5207: LD_ADDR_VAR 0 2
5211: PUSH
5212: LD_INT 700
5214: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5215: LD_INT 35
5217: PPUSH
5218: CALL_OW 67
// x := x - 0 0$01 ;
5222: LD_ADDR_VAR 0 2
5226: PUSH
5227: LD_VAR 0 2
5231: PUSH
5232: LD_INT 35
5234: MINUS
5235: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5236: LD_VAR 0 2
5240: PUSH
5241: LD_INT 0
5243: EQUAL
5244: PUSH
5245: LD_EXP 24
5249: PUSH
5250: LD_INT 3
5252: ARRAY
5253: PPUSH
5254: LD_INT 43
5256: PPUSH
5257: LD_INT 3
5259: PPUSH
5260: CALL_OW 297
5264: PUSH
5265: LD_INT 4
5267: LESS
5268: PUSH
5269: LD_EXP 24
5273: PUSH
5274: LD_INT 3
5276: ARRAY
5277: PPUSH
5278: LD_INT 43
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: CALL_OW 297
5288: PUSH
5289: LD_INT 4
5291: LESS
5292: AND
5293: OR
5294: IFFALSE 5215
// for i in powell_trans do
5296: LD_ADDR_VAR 0 4
5300: PUSH
5301: LD_EXP 24
5305: PUSH
5306: FOR_IN
5307: IFFALSE 5320
// RemoveUnit ( i ) ;
5309: LD_VAR 0 4
5313: PPUSH
5314: CALL_OW 64
5318: GO 5306
5320: POP
5321: POP
// if not powell_happy then
5322: LD_VAR 0 6
5326: NOT
5327: IFFALSE 5338
// powell_happy := - 1 ;
5329: LD_ADDR_VAR 0 6
5333: PUSH
5334: LD_INT 1
5336: NEG
5337: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5338: LD_STRING EarlySiberite
5340: PPUSH
5341: LD_VAR 0 6
5345: PPUSH
5346: CALL_OW 101
// if powell_happy then
5350: LD_VAR 0 6
5354: IFFALSE 5365
// ChangeMissionObjectives ( M3a ) else
5356: LD_STRING M3a
5358: PPUSH
5359: CALL_OW 337
5363: GO 5372
// ChangeMissionObjectives ( M3b ) ;
5365: LD_STRING M3b
5367: PPUSH
5368: CALL_OW 337
// ru_can_attack_terminal := true ;
5372: LD_ADDR_EXP 9
5376: PUSH
5377: LD_INT 1
5379: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5380: LD_INT 25200
5382: PPUSH
5383: CALL_OW 67
// time := 2 2$00 ;
5387: LD_ADDR_VAR 0 8
5391: PUSH
5392: LD_INT 4200
5394: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5395: LD_INT 35
5397: PPUSH
5398: CALL_OW 67
// time := time - 0 0$1 ;
5402: LD_ADDR_VAR 0 8
5406: PUSH
5407: LD_VAR 0 8
5411: PUSH
5412: LD_INT 35
5414: MINUS
5415: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5416: LD_EXP 8
5420: NOT
5421: PUSH
5422: LD_EXP 35
5426: PUSH
5427: LD_INT 0
5429: EQUAL
5430: OR
5431: PUSH
5432: LD_VAR 0 8
5436: PUSH
5437: LD_INT 0
5439: EQUAL
5440: OR
5441: IFFALSE 5395
// if ru_force then
5443: LD_EXP 35
5447: IFFALSE 5546
// for i in ru_force do
5449: LD_ADDR_VAR 0 4
5453: PUSH
5454: LD_EXP 35
5458: PUSH
5459: FOR_IN
5460: IFFALSE 5544
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5462: LD_INT 1
5464: PPUSH
5465: LD_VAR 0 4
5469: PPUSH
5470: CALL_OW 292
5474: NOT
5475: PUSH
5476: LD_VAR 0 4
5480: PPUSH
5481: LD_INT 81
5483: PUSH
5484: LD_INT 3
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PPUSH
5491: CALL_OW 69
5495: PPUSH
5496: LD_VAR 0 4
5500: PPUSH
5501: CALL_OW 74
5505: PPUSH
5506: CALL_OW 296
5510: PUSH
5511: LD_INT 10
5513: GREATER
5514: AND
5515: IFFALSE 5542
// begin RemoveUnit ( i ) ;
5517: LD_VAR 0 4
5521: PPUSH
5522: CALL_OW 64
// ru_force := ru_force diff i ;
5526: LD_ADDR_EXP 35
5530: PUSH
5531: LD_EXP 35
5535: PUSH
5536: LD_VAR 0 4
5540: DIFF
5541: ST_TO_ADDR
// end ;
5542: GO 5459
5544: POP
5545: POP
// repeat wait ( 0 0$03 ) ;
5546: LD_INT 105
5548: PPUSH
5549: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5553: LD_EXP 8
5557: NOT
5558: PUSH
5559: LD_EXP 35
5563: PUSH
5564: LD_INT 3
5566: LESS
5567: OR
5568: IFFALSE 5546
// ar_can_arrive := true ;
5570: LD_ADDR_EXP 10
5574: PUSH
5575: LD_INT 1
5577: ST_TO_ADDR
// end ;
5578: PPOPN 8
5580: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5581: LD_INT 1
5583: PPUSH
5584: LD_INT 20
5586: PPUSH
5587: CALL_OW 325
5591: IFFALSE 5732
5593: GO 5595
5595: DISABLE
5596: LD_INT 0
5598: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5599: LD_ADDR_VAR 0 1
5603: PUSH
5604: LD_INT 22
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 26
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 25
5626: PUSH
5627: LD_INT 4
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: PUSH
5644: LD_EXP 18
5648: PUSH
5649: LD_EXP 21
5653: PUSH
5654: LD_EXP 20
5658: PUSH
5659: LD_EXP 22
5663: PUSH
5664: EMPTY
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: DIFF
5670: ST_TO_ADDR
// if not un then
5671: LD_VAR 0 1
5675: NOT
5676: IFFALSE 5680
// exit ;
5678: GO 5732
// DialogueOn ;
5680: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5684: LD_VAR 0 1
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PPUSH
5693: LD_STRING D13-Sci1-1
5695: PPUSH
5696: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5700: LD_EXP 18
5704: PPUSH
5705: LD_STRING D13-JMM-1
5707: PPUSH
5708: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5712: LD_VAR 0 1
5716: PUSH
5717: LD_INT 1
5719: ARRAY
5720: PPUSH
5721: LD_STRING D13-Sci1-2
5723: PPUSH
5724: CALL_OW 88
// DialogueOff ;
5728: CALL_OW 7
// end ;
5732: PPOPN 1
5734: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5735: LD_INT 1
5737: PPUSH
5738: CALL 815 0 1
5742: PUSH
5743: LD_INT 77
5745: GREATER
5746: PUSH
5747: LD_EXP 8
5751: NOT
5752: AND
5753: PUSH
5754: LD_INT 22
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PUSH
5774: LD_INT 26
5776: PUSH
5777: LD_INT 1
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: PPUSH
5789: CALL_OW 69
5793: PUSH
5794: LD_EXP 18
5798: PUSH
5799: LD_EXP 20
5803: PUSH
5804: LD_EXP 21
5808: PUSH
5809: LD_EXP 19
5813: PUSH
5814: LD_EXP 22
5818: PUSH
5819: EMPTY
5820: LIST
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: DIFF
5826: AND
5827: IFFALSE 6005
5829: GO 5831
5831: DISABLE
5832: LD_INT 0
5834: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5835: LD_ADDR_VAR 0 1
5839: PUSH
5840: LD_INT 22
5842: PUSH
5843: LD_INT 1
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 25
5852: PUSH
5853: LD_INT 4
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 26
5862: PUSH
5863: LD_INT 1
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: LIST
5874: PPUSH
5875: CALL_OW 69
5879: PUSH
5880: LD_EXP 18
5884: PUSH
5885: LD_EXP 20
5889: PUSH
5890: LD_EXP 21
5894: PUSH
5895: LD_EXP 19
5899: PUSH
5900: LD_EXP 22
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: DIFF
5912: ST_TO_ADDR
// DialogueOn ;
5913: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5917: LD_VAR 0 1
5921: PUSH
5922: LD_INT 1
5924: ARRAY
5925: PPUSH
5926: LD_STRING D7-Sci1-1
5928: PPUSH
5929: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5933: LD_EXP 18
5937: PPUSH
5938: LD_STRING D7-JMM-1
5940: PPUSH
5941: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5945: LD_VAR 0 1
5949: PUSH
5950: LD_INT 1
5952: ARRAY
5953: PPUSH
5954: LD_STRING D7-Sci1-2
5956: PPUSH
5957: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5961: LD_EXP 18
5965: PPUSH
5966: LD_STRING D7-JMM-2
5968: PPUSH
5969: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5973: LD_VAR 0 1
5977: PUSH
5978: LD_INT 1
5980: ARRAY
5981: PPUSH
5982: LD_STRING D7-Sci1-3
5984: PPUSH
5985: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5989: LD_EXP 18
5993: PPUSH
5994: LD_STRING D7-JMM-3
5996: PPUSH
5997: CALL_OW 88
// DialogueOff ;
6001: CALL_OW 7
// end ;
6005: PPOPN 1
6007: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
6008: LD_EXP 10
6012: IFFALSE 9325
6014: GO 6016
6016: DISABLE
6017: LD_INT 0
6019: PPUSH
6020: PPUSH
6021: PPUSH
6022: PPUSH
6023: PPUSH
6024: PPUSH
6025: PPUSH
6026: PPUSH
// begin PrepareArabian ;
6027: CALL 11746 0 0
// repeat wait ( 0 0$01 ) ;
6031: LD_INT 35
6033: PPUSH
6034: CALL_OW 67
// until ar_spawned ;
6038: LD_EXP 11
6042: IFFALSE 6031
// DialogueOn ;
6044: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6048: LD_EXP 26
6052: PPUSH
6053: LD_STRING D8-Ar1-1
6055: PPUSH
6056: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6060: LD_EXP 18
6064: PPUSH
6065: LD_STRING D8-JMM-1
6067: PPUSH
6068: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6072: LD_EXP 26
6076: PPUSH
6077: LD_STRING D8-Ar1-2
6079: PPUSH
6080: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6084: LD_EXP 18
6088: PPUSH
6089: LD_STRING D8-JMM-2
6091: PPUSH
6092: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6096: LD_EXP 26
6100: PPUSH
6101: LD_STRING D8-Ar1-3
6103: PPUSH
6104: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6108: LD_EXP 18
6112: PPUSH
6113: LD_STRING D8-JMM-3
6115: PPUSH
6116: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6120: LD_EXP 26
6124: PPUSH
6125: LD_STRING D8-Ar1-4
6127: PPUSH
6128: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6132: LD_EXP 18
6136: PPUSH
6137: LD_STRING D8-JMM-4
6139: PPUSH
6140: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6144: LD_EXP 26
6148: PPUSH
6149: LD_STRING D8-Ar1-5
6151: PPUSH
6152: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6156: LD_EXP 18
6160: PPUSH
6161: LD_STRING D8-JMM-5
6163: PPUSH
6164: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6168: LD_EXP 26
6172: PPUSH
6173: LD_STRING D8-Ar1-6
6175: PPUSH
6176: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6180: LD_EXP 27
6184: PPUSH
6185: LD_STRING D8-Ar2-6
6187: PPUSH
6188: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6192: LD_EXP 18
6196: PPUSH
6197: LD_STRING D8-JMM-6
6199: PPUSH
6200: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6204: LD_EXP 27
6208: PPUSH
6209: LD_STRING D8-Ar2-7
6211: PPUSH
6212: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6216: LD_STRING QBarracks
6218: PPUSH
6219: CALL_OW 97
6223: PUSH
6224: LD_INT 1
6226: DOUBLE
6227: EQUAL
6228: IFTRUE 6232
6230: GO 6267
6232: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6233: LD_EXP 18
6237: PPUSH
6238: LD_STRING D8a-JMM-1
6240: PPUSH
6241: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6245: LD_EXP 26
6249: PPUSH
6250: LD_STRING D8a-Ar1-1
6252: PPUSH
6253: CALL_OW 94
// player_want_mortar := true ;
6257: LD_ADDR_EXP 12
6261: PUSH
6262: LD_INT 1
6264: ST_TO_ADDR
// end ; 2 :
6265: GO 6425
6267: LD_INT 2
6269: DOUBLE
6270: EQUAL
6271: IFTRUE 6275
6273: GO 6389
6275: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6276: LD_EXP 18
6280: PPUSH
6281: LD_STRING D8b-JMM-1
6283: PPUSH
6284: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6288: LD_EXP 26
6292: PPUSH
6293: LD_STRING D8b-Ar1-1
6295: PPUSH
6296: CALL_OW 94
// case Query ( QInfo ) of 1 :
6300: LD_STRING QInfo
6302: PPUSH
6303: CALL_OW 97
6307: PUSH
6308: LD_INT 1
6310: DOUBLE
6311: EQUAL
6312: IFTRUE 6316
6314: GO 6351
6316: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6317: LD_EXP 18
6321: PPUSH
6322: LD_STRING D8b1-JMM-1
6324: PPUSH
6325: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6329: LD_EXP 26
6333: PPUSH
6334: LD_STRING D8b1-Ar1-1
6336: PPUSH
6337: CALL_OW 94
// player_want_info := 2 ;
6341: LD_ADDR_EXP 13
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// end ; 2 :
6349: GO 6387
6351: LD_INT 2
6353: DOUBLE
6354: EQUAL
6355: IFTRUE 6359
6357: GO 6386
6359: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6360: LD_EXP 18
6364: PPUSH
6365: LD_STRING D8b2-JMM-1
6367: PPUSH
6368: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6372: LD_EXP 26
6376: PPUSH
6377: LD_STRING D8b2-Ar1-1
6379: PPUSH
6380: CALL_OW 94
// end ; end ;
6384: GO 6387
6386: POP
// end ; 3 :
6387: GO 6425
6389: LD_INT 3
6391: DOUBLE
6392: EQUAL
6393: IFTRUE 6397
6395: GO 6424
6397: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6398: LD_EXP 18
6402: PPUSH
6403: LD_STRING D8c-JMM-1
6405: PPUSH
6406: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6410: LD_EXP 26
6414: PPUSH
6415: LD_STRING D8c-Ar1-1
6417: PPUSH
6418: CALL_OW 94
// end ; end ;
6422: GO 6425
6424: POP
// DialogueOff ;
6425: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6429: LD_ADDR_VAR 0 4
6433: PUSH
6434: LD_INT 9
6436: PPUSH
6437: LD_INT 2
6439: PUSH
6440: LD_INT 30
6442: PUSH
6443: LD_INT 0
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 30
6452: PUSH
6453: LD_INT 1
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: LIST
6464: PPUSH
6465: CALL_OW 70
6469: ST_TO_ADDR
// if dep then
6470: LD_VAR 0 4
6474: IFFALSE 6490
// dep := dep [ 1 ] ;
6476: LD_ADDR_VAR 0 4
6480: PUSH
6481: LD_VAR 0 4
6485: PUSH
6486: LD_INT 1
6488: ARRAY
6489: ST_TO_ADDR
// if not dep then
6490: LD_VAR 0 4
6494: NOT
6495: IFFALSE 6533
// begin case Query ( QInfoNothing ) of 1 :
6497: LD_STRING QInfoNothing
6499: PPUSH
6500: CALL_OW 97
6504: PUSH
6505: LD_INT 1
6507: DOUBLE
6508: EQUAL
6509: IFTRUE 6513
6511: GO 6516
6513: POP
// ; end ;
6514: GO 6517
6516: POP
// player_want_info := false ;
6517: LD_ADDR_EXP 13
6521: PUSH
6522: LD_INT 0
6524: ST_TO_ADDR
// player_want_mortar := false ;
6525: LD_ADDR_EXP 12
6529: PUSH
6530: LD_INT 0
6532: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6533: LD_ADDR_VAR 0 3
6537: PUSH
6538: LD_INT 22
6540: PUSH
6541: LD_INT 2
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: LD_INT 21
6550: PUSH
6551: LD_INT 2
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: PPUSH
6562: CALL_OW 69
6566: ST_TO_ADDR
// time := 1 1$35 ;
6567: LD_ADDR_VAR 0 5
6571: PUSH
6572: LD_INT 3325
6574: ST_TO_ADDR
// no_oil_gain := false ;
6575: LD_ADDR_VAR 0 6
6579: PUSH
6580: LD_INT 0
6582: ST_TO_ADDR
// first_warn := false ;
6583: LD_ADDR_VAR 0 7
6587: PUSH
6588: LD_INT 0
6590: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6591: LD_EXP 12
6595: PUSH
6596: LD_EXP 13
6600: OR
6601: IFFALSE 6706
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6603: LD_EXP 33
6607: PPUSH
6608: LD_INT 25
6610: PUSH
6611: LD_INT 1
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: PPUSH
6618: CALL_OW 72
6622: PPUSH
6623: LD_VAR 0 4
6627: PPUSH
6628: CALL_OW 250
6632: PPUSH
6633: LD_VAR 0 4
6637: PPUSH
6638: CALL_OW 251
6642: PPUSH
6643: LD_VAR 0 4
6647: PPUSH
6648: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6652: LD_EXP 33
6656: PPUSH
6657: LD_INT 25
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 72
6671: PPUSH
6672: LD_INT 86
6674: PPUSH
6675: LD_INT 121
6677: PPUSH
6678: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6682: LD_EXP 33
6686: PPUSH
6687: LD_INT 25
6689: PUSH
6690: LD_INT 1
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PPUSH
6697: CALL_OW 72
6701: PPUSH
6702: CALL_OW 200
// end ; if player_attacked_ar then
6706: LD_EXP 16
6710: IFFALSE 6714
// exit ;
6712: GO 9325
// if player_want_mortar then
6714: LD_EXP 12
6718: IFFALSE 8127
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6720: LD_EXP 27
6724: PPUSH
6725: LD_VAR 0 4
6729: PPUSH
6730: CALL_OW 250
6734: PUSH
6735: LD_INT 1
6737: PLUS
6738: PPUSH
6739: LD_VAR 0 4
6743: PPUSH
6744: CALL_OW 251
6748: PUSH
6749: LD_INT 1
6751: PLUS
6752: PPUSH
6753: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6757: LD_INT 35
6759: PPUSH
6760: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6764: LD_EXP 27
6768: PPUSH
6769: LD_VAR 0 4
6773: PPUSH
6774: CALL_OW 296
6778: PUSH
6779: LD_INT 4
6781: LESS
6782: IFFALSE 6757
// for i = 1 to 6 do
6784: LD_ADDR_VAR 0 1
6788: PUSH
6789: DOUBLE
6790: LD_INT 1
6792: DEC
6793: ST_TO_ADDR
6794: LD_INT 6
6796: PUSH
6797: FOR_TO
6798: IFFALSE 6995
// begin if player_attacked_ar then
6800: LD_EXP 16
6804: IFFALSE 6810
// exit ;
6806: POP
6807: POP
6808: GO 9325
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6810: LD_VAR 0 4
6814: PPUSH
6815: CALL_OW 274
6819: PPUSH
6820: LD_INT 2
6822: PPUSH
6823: CALL_OW 275
6827: PUSH
6828: LD_INT 10
6830: LESS
6831: PUSH
6832: LD_VAR 0 7
6836: NOT
6837: AND
6838: IFFALSE 6901
// begin first_warn := true ;
6840: LD_ADDR_VAR 0 7
6844: PUSH
6845: LD_INT 1
6847: ST_TO_ADDR
// DialogueOn ;
6848: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6852: LD_EXP 28
6856: PPUSH
6857: LD_STRING D9a-FAr1-1
6859: PPUSH
6860: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6864: LD_EXP 18
6868: PPUSH
6869: LD_STRING D9a-JMM-1
6871: PPUSH
6872: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6876: LD_EXP 26
6880: PPUSH
6881: LD_STRING D9a2-Ar1-1
6883: PPUSH
6884: CALL_OW 88
// DialogueOff ;
6888: CALL_OW 7
// wait ( time ) ;
6892: LD_VAR 0 5
6896: PPUSH
6897: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL_OW 274
6910: PPUSH
6911: LD_INT 2
6913: PPUSH
6914: CALL_OW 275
6918: PUSH
6919: LD_INT 10
6921: LESS
6922: IFFALSE 6948
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6924: LD_EXP 26
6928: PPUSH
6929: LD_STRING D9a3-Ar1-1
6931: PPUSH
6932: CALL_OW 88
// no_oil_gain := true ;
6936: LD_ADDR_VAR 0 6
6940: PUSH
6941: LD_INT 1
6943: ST_TO_ADDR
// break ;
6944: GO 6995
// end else
6946: GO 6993
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6948: LD_EXP 27
6952: PPUSH
6953: LD_VAR 0 4
6957: PPUSH
6958: LD_INT 2
6960: PPUSH
6961: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6965: LD_EXP 27
6969: PPUSH
6970: LD_VAR 0 3
6974: PUSH
6975: LD_VAR 0 1
6979: PUSH
6980: LD_INT 3
6982: MOD
6983: PUSH
6984: LD_INT 1
6986: PLUS
6987: ARRAY
6988: PPUSH
6989: CALL_OW 210
// end ; end ;
6993: GO 6797
6995: POP
6996: POP
// if not no_oil_gain then
6997: LD_VAR 0 6
7001: NOT
7002: IFFALSE 8127
// begin repeat wait ( 0 0$01 ) ;
7004: LD_INT 35
7006: PPUSH
7007: CALL_OW 67
// if player_attacked_ar then
7011: LD_EXP 16
7015: IFFALSE 7019
// exit ;
7017: GO 9325
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7019: LD_VAR 0 3
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: CALL_OW 261
7032: PUSH
7033: LD_INT 80
7035: GREATER
7036: PUSH
7037: LD_VAR 0 3
7041: PUSH
7042: LD_INT 2
7044: ARRAY
7045: PPUSH
7046: CALL_OW 261
7050: PUSH
7051: LD_INT 80
7053: GREATER
7054: AND
7055: PUSH
7056: LD_VAR 0 3
7060: PUSH
7061: LD_INT 3
7063: ARRAY
7064: PPUSH
7065: CALL_OW 261
7069: PUSH
7070: LD_INT 80
7072: GREATER
7073: AND
7074: IFFALSE 7004
// ComMoveXY ( Gali , 105 , 127 ) ;
7076: LD_EXP 27
7080: PPUSH
7081: LD_INT 105
7083: PPUSH
7084: LD_INT 127
7086: PPUSH
7087: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7091: LD_EXP 27
7095: PPUSH
7096: LD_INT 2
7098: PPUSH
7099: CALL_OW 173
// AddComHold ( Gali ) ;
7103: LD_EXP 27
7107: PPUSH
7108: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7112: LD_INT 35
7114: PPUSH
7115: CALL_OW 67
// if player_attacked_ar then
7119: LD_EXP 16
7123: IFFALSE 7127
// exit ;
7125: GO 9325
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7127: LD_EXP 27
7131: PPUSH
7132: LD_INT 105
7134: PPUSH
7135: LD_INT 127
7137: PPUSH
7138: CALL_OW 297
7142: PUSH
7143: LD_INT 4
7145: LESS
7146: IFFALSE 7112
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7148: LD_VAR 0 4
7152: PPUSH
7153: CALL_OW 274
7157: PPUSH
7158: LD_INT 1
7160: PPUSH
7161: CALL_OW 275
7165: PUSH
7166: LD_INT 50
7168: LESS
7169: IFFALSE 7465
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7171: LD_VAR 0 4
7175: PPUSH
7176: CALL_OW 274
7180: PPUSH
7181: LD_INT 1
7183: PPUSH
7184: CALL_OW 275
7188: PUSH
7189: LD_INT 0
7191: DOUBLE
7192: GREATEREQUAL
7193: IFFALSE 7201
7195: LD_INT 24
7197: DOUBLE
7198: LESSEQUAL
7199: IFTRUE 7203
7201: GO 7218
7203: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7204: LD_EXP 27
7208: PPUSH
7209: LD_STRING D9b-Ar2-1
7211: PPUSH
7212: CALL_OW 88
7216: GO 7248
7218: LD_INT 25
7220: DOUBLE
7221: GREATEREQUAL
7222: IFFALSE 7230
7224: LD_INT 49
7226: DOUBLE
7227: LESSEQUAL
7228: IFTRUE 7232
7230: GO 7247
7232: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7233: LD_EXP 27
7237: PPUSH
7238: LD_STRING D9b-Ar2-1a
7240: PPUSH
7241: CALL_OW 88
7245: GO 7248
7247: POP
// Say ( JMM , D9b-JMM-1 ) ;
7248: LD_EXP 18
7252: PPUSH
7253: LD_STRING D9b-JMM-1
7255: PPUSH
7256: CALL_OW 88
// x := 0 0$0 ;
7260: LD_ADDR_VAR 0 2
7264: PUSH
7265: LD_INT 0
7267: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7268: LD_INT 35
7270: PPUSH
7271: CALL_OW 67
// x := x + 0 0$1 ;
7275: LD_ADDR_VAR 0 2
7279: PUSH
7280: LD_VAR 0 2
7284: PUSH
7285: LD_INT 35
7287: PLUS
7288: ST_TO_ADDR
// if player_attacked_ar then
7289: LD_EXP 16
7293: IFFALSE 7297
// exit ;
7295: GO 9325
// until x >= time ;
7297: LD_VAR 0 2
7301: PUSH
7302: LD_VAR 0 5
7306: GREATEREQUAL
7307: IFFALSE 7268
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7309: LD_VAR 0 4
7313: PPUSH
7314: CALL_OW 274
7318: PPUSH
7319: LD_INT 1
7321: PPUSH
7322: CALL_OW 275
7326: PUSH
7327: LD_INT 50
7329: LESS
7330: IFFALSE 7463
// begin DialogueOn ;
7332: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7336: LD_EXP 26
7340: PPUSH
7341: LD_STRING D9c-Ar1-1
7343: PPUSH
7344: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7348: LD_EXP 18
7352: PPUSH
7353: LD_STRING D9c-JMM-1
7355: PPUSH
7356: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7360: LD_EXP 26
7364: PPUSH
7365: LD_STRING D9c-Ar1-2
7367: PPUSH
7368: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7372: LD_EXP 28
7376: PPUSH
7377: LD_STRING D9c-FAr1-2
7379: PPUSH
7380: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7384: LD_EXP 26
7388: PPUSH
7389: LD_STRING D9c-Ar1-3
7391: PPUSH
7392: CALL_OW 88
// case Query ( QInfo ) of 1 :
7396: LD_STRING QInfo
7398: PPUSH
7399: CALL_OW 97
7403: PUSH
7404: LD_INT 1
7406: DOUBLE
7407: EQUAL
7408: IFTRUE 7412
7410: GO 7435
7412: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7413: LD_EXP 18
7417: PPUSH
7418: LD_STRING D8b1-JMM-1
7420: PPUSH
7421: CALL_OW 88
// player_want_info := 2 ;
7425: LD_ADDR_EXP 13
7429: PUSH
7430: LD_INT 2
7432: ST_TO_ADDR
// end ; 2 :
7433: GO 7459
7435: LD_INT 2
7437: DOUBLE
7438: EQUAL
7439: IFTRUE 7443
7441: GO 7458
7443: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7444: LD_EXP 26
7448: PPUSH
7449: LD_STRING D8b2-Ar1-1
7451: PPUSH
7452: CALL_OW 88
// end ; end ;
7456: GO 7459
7458: POP
// DialogueOff ;
7459: CALL_OW 7
// end ; end else
7463: GO 8127
// begin RemoveEnvironmentArea ( mortarArea ) ;
7465: LD_INT 2
7467: PPUSH
7468: CALL_OW 355
// wait ( 1 ) ;
7472: LD_INT 1
7474: PPUSH
7475: CALL_OW 67
// InGameOn ;
7479: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7483: LD_EXP 27
7487: PPUSH
7488: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7492: LD_EXP 27
7496: PPUSH
7497: LD_INT 1
7499: PPUSH
7500: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7504: LD_EXP 27
7508: PPUSH
7509: LD_INT 4
7511: PPUSH
7512: LD_INT 107
7514: PPUSH
7515: LD_INT 131
7517: PPUSH
7518: LD_INT 0
7520: PPUSH
7521: CALL_OW 145
// repeat wait ( 1 ) ;
7525: LD_INT 1
7527: PPUSH
7528: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7532: LD_INT 30
7534: PUSH
7535: LD_INT 4
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 23
7544: PUSH
7545: LD_INT 2
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PPUSH
7556: CALL_OW 69
7560: IFFALSE 7525
// SetSide ( Gali , 2 ) ;
7562: LD_EXP 27
7566: PPUSH
7567: LD_INT 2
7569: PPUSH
7570: CALL_OW 235
// InGameOff ;
7574: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7578: LD_ADDR_VAR 0 8
7582: PUSH
7583: LD_INT 30
7585: PUSH
7586: LD_INT 4
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: PUSH
7593: LD_INT 23
7595: PUSH
7596: LD_INT 2
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL_OW 69
7611: PUSH
7612: LD_INT 1
7614: ARRAY
7615: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7616: LD_INT 35
7618: PPUSH
7619: CALL_OW 67
// if player_attacked_ar then
7623: LD_EXP 16
7627: IFFALSE 7631
// exit ;
7629: GO 9325
// until BuildingStatus ( b ) <> bs_build ;
7631: LD_VAR 0 8
7635: PPUSH
7636: CALL_OW 461
7640: PUSH
7641: LD_INT 1
7643: NONEQUAL
7644: IFFALSE 7616
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7646: LD_VAR 0 8
7650: PPUSH
7651: CALL_OW 302
7655: PUSH
7656: LD_VAR 0 4
7660: PPUSH
7661: CALL_OW 274
7665: PPUSH
7666: LD_INT 1
7668: PPUSH
7669: CALL_OW 275
7673: PUSH
7674: LD_INT 25
7676: GREATEREQUAL
7677: AND
7678: IFFALSE 7777
// begin ComUpgrade ( b ) ;
7680: LD_VAR 0 8
7684: PPUSH
7685: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7689: LD_EXP 27
7693: PPUSH
7694: LD_STRING h
7696: PUSH
7697: LD_VAR 0 8
7701: PPUSH
7702: CALL_OW 250
7706: PUSH
7707: LD_VAR 0 8
7711: PPUSH
7712: CALL_OW 251
7716: PUSH
7717: LD_VAR 0 8
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: LD_INT 0
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: LIST
7738: LIST
7739: PUSH
7740: EMPTY
7741: LIST
7742: PPUSH
7743: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7747: LD_INT 35
7749: PPUSH
7750: CALL_OW 67
// if player_attacked_ar then
7754: LD_EXP 16
7758: IFFALSE 7762
// exit ;
7760: GO 9325
// until BuildingStatus ( b ) <> bs_build ;
7762: LD_VAR 0 8
7766: PPUSH
7767: CALL_OW 461
7771: PUSH
7772: LD_INT 1
7774: NONEQUAL
7775: IFFALSE 7747
// end ; if b then
7777: LD_VAR 0 8
7781: IFFALSE 7792
// CenterNowOnUnits ( b ) ;
7783: LD_VAR 0 8
7787: PPUSH
7788: CALL_OW 87
// DialogueOn ;
7792: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7796: LD_EXP 27
7800: PPUSH
7801: LD_STRING D9d-Ar2-1
7803: PPUSH
7804: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7808: LD_EXP 26
7812: PPUSH
7813: LD_STRING D9d-Ar1-1
7815: PPUSH
7816: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7820: LD_EXP 18
7824: PPUSH
7825: LD_STRING D9d-JMM-1
7827: PPUSH
7828: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7832: LD_EXP 26
7836: PPUSH
7837: LD_STRING D9d-Ar1-2
7839: PPUSH
7840: CALL_OW 88
// DialogueOff ;
7844: CALL_OW 7
// i := [ ] ;
7848: LD_ADDR_VAR 0 1
7852: PUSH
7853: EMPTY
7854: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7855: LD_VAR 0 4
7859: PPUSH
7860: CALL_OW 274
7864: PPUSH
7865: LD_INT 3
7867: PPUSH
7868: CALL_OW 275
7872: PUSH
7873: LD_INT 20
7875: GREATEREQUAL
7876: IFFALSE 7895
// i := i ^ [ 1 ] ;
7878: LD_ADDR_VAR 0 1
7882: PUSH
7883: LD_VAR 0 1
7887: PUSH
7888: LD_INT 1
7890: PUSH
7891: EMPTY
7892: LIST
7893: ADD
7894: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7895: LD_VAR 0 4
7899: PPUSH
7900: CALL_OW 274
7904: PPUSH
7905: LD_INT 1
7907: PPUSH
7908: CALL_OW 275
7912: PUSH
7913: LD_INT 50
7915: GREATEREQUAL
7916: IFFALSE 7935
// i := i ^ [ 2 ] ;
7918: LD_ADDR_VAR 0 1
7922: PUSH
7923: LD_VAR 0 1
7927: PUSH
7928: LD_INT 2
7930: PUSH
7931: EMPTY
7932: LIST
7933: ADD
7934: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7935: LD_VAR 0 4
7939: PPUSH
7940: CALL_OW 274
7944: PPUSH
7945: LD_INT 2
7947: PPUSH
7948: CALL_OW 275
7952: PUSH
7953: LD_INT 80
7955: GREATEREQUAL
7956: IFFALSE 7975
// i := i ^ [ 3 ] ;
7958: LD_ADDR_VAR 0 1
7962: PUSH
7963: LD_VAR 0 1
7967: PUSH
7968: LD_INT 3
7970: PUSH
7971: EMPTY
7972: LIST
7973: ADD
7974: ST_TO_ADDR
// i := i diff 0 ;
7975: LD_ADDR_VAR 0 1
7979: PUSH
7980: LD_VAR 0 1
7984: PUSH
7985: LD_INT 0
7987: DIFF
7988: ST_TO_ADDR
// if i then
7989: LD_VAR 0 1
7993: IFFALSE 8099
// begin i := i ^ [ 4 ] ;
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: LD_VAR 0 1
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: EMPTY
8009: LIST
8010: ADD
8011: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8012: LD_STRING QInfo2
8014: PPUSH
8015: CALL_OW 97
8019: PUSH
8020: LD_INT 1
8022: DOUBLE
8023: EQUAL
8024: IFTRUE 8028
8026: GO 8039
8028: POP
// player_want_info := 3 ; 2 :
8029: LD_ADDR_EXP 13
8033: PUSH
8034: LD_INT 3
8036: ST_TO_ADDR
8037: GO 8097
8039: LD_INT 2
8041: DOUBLE
8042: EQUAL
8043: IFTRUE 8047
8045: GO 8058
8047: POP
// player_want_info := 1 ; 3 :
8048: LD_ADDR_EXP 13
8052: PUSH
8053: LD_INT 1
8055: ST_TO_ADDR
8056: GO 8097
8058: LD_INT 3
8060: DOUBLE
8061: EQUAL
8062: IFTRUE 8066
8064: GO 8077
8066: POP
// player_want_info := 2 ; 4 :
8067: LD_ADDR_EXP 13
8071: PUSH
8072: LD_INT 2
8074: ST_TO_ADDR
8075: GO 8097
8077: LD_INT 4
8079: DOUBLE
8080: EQUAL
8081: IFTRUE 8085
8083: GO 8096
8085: POP
// player_want_info := 0 ; end ;
8086: LD_ADDR_EXP 13
8090: PUSH
8091: LD_INT 0
8093: ST_TO_ADDR
8094: GO 8097
8096: POP
// end else
8097: GO 8127
// case Query ( QInfoNothing ) of 1 :
8099: LD_STRING QInfoNothing
8101: PPUSH
8102: CALL_OW 97
8106: PUSH
8107: LD_INT 1
8109: DOUBLE
8110: EQUAL
8111: IFTRUE 8115
8113: GO 8126
8115: POP
// player_want_info := 0 ; end ;
8116: LD_ADDR_EXP 13
8120: PUSH
8121: LD_INT 0
8123: ST_TO_ADDR
8124: GO 8127
8126: POP
// end ; end ; end ; if player_want_info then
8127: LD_EXP 13
8131: IFFALSE 9145
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8133: LD_ADDR_VAR 0 3
8137: PUSH
8138: LD_VAR 0 3
8142: PPUSH
8143: LD_INT 34
8145: PUSH
8146: LD_INT 32
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PPUSH
8153: CALL_OW 72
8157: ST_TO_ADDR
// if player_want_mortar then
8158: LD_EXP 12
8162: IFFALSE 8484
// begin case player_want_info of 1 :
8164: LD_EXP 13
8168: PUSH
8169: LD_INT 1
8171: DOUBLE
8172: EQUAL
8173: IFTRUE 8177
8175: GO 8188
8177: POP
// x := 5 ; 2 :
8178: LD_ADDR_VAR 0 2
8182: PUSH
8183: LD_INT 5
8185: ST_TO_ADDR
8186: GO 8227
8188: LD_INT 2
8190: DOUBLE
8191: EQUAL
8192: IFTRUE 8196
8194: GO 8207
8196: POP
// x := 8 ; 3 :
8197: LD_ADDR_VAR 0 2
8201: PUSH
8202: LD_INT 8
8204: ST_TO_ADDR
8205: GO 8227
8207: LD_INT 3
8209: DOUBLE
8210: EQUAL
8211: IFTRUE 8215
8213: GO 8226
8215: POP
// x := 2 ; end ;
8216: LD_ADDR_VAR 0 2
8220: PUSH
8221: LD_INT 2
8223: ST_TO_ADDR
8224: GO 8227
8226: POP
// repeat wait ( 0 0$1 ) ;
8227: LD_INT 35
8229: PPUSH
8230: CALL_OW 67
// until not HasTask ( Gali ) ;
8234: LD_EXP 27
8238: PPUSH
8239: CALL_OW 314
8243: NOT
8244: IFFALSE 8227
// for i = 1 to x do
8246: LD_ADDR_VAR 0 1
8250: PUSH
8251: DOUBLE
8252: LD_INT 1
8254: DEC
8255: ST_TO_ADDR
8256: LD_VAR 0 2
8260: PUSH
8261: FOR_TO
8262: IFFALSE 8427
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8264: LD_EXP 27
8268: PPUSH
8269: LD_VAR 0 4
8273: PPUSH
8274: LD_EXP 13
8278: PPUSH
8279: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8283: LD_EXP 27
8287: PPUSH
8288: LD_VAR 0 3
8292: PUSH
8293: LD_INT 1
8295: ARRAY
8296: PPUSH
8297: CALL_OW 172
// AddComHold ( Gali ) ;
8301: LD_EXP 27
8305: PPUSH
8306: CALL_OW 200
// repeat wait ( 3 ) ;
8310: LD_INT 3
8312: PPUSH
8313: CALL_OW 67
// if player_attacked_ar then
8317: LD_EXP 16
8321: IFFALSE 8327
// exit ;
8323: POP
8324: POP
8325: GO 9325
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8327: LD_EXP 27
8331: PPUSH
8332: LD_VAR 0 3
8336: PUSH
8337: LD_INT 1
8339: ARRAY
8340: PPUSH
8341: CALL_OW 296
8345: PUSH
8346: LD_INT 4
8348: LESS
8349: PUSH
8350: LD_EXP 27
8354: PPUSH
8355: LD_EXP 13
8359: PPUSH
8360: CALL_OW 289
8364: AND
8365: IFFALSE 8310
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8367: LD_VAR 0 3
8371: PUSH
8372: LD_INT 1
8374: ARRAY
8375: PPUSH
8376: LD_EXP 13
8380: PPUSH
8381: LD_VAR 0 3
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: PPUSH
8390: LD_EXP 13
8394: PPUSH
8395: CALL_OW 289
8399: PUSH
8400: LD_INT 10
8402: PLUS
8403: PPUSH
8404: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8408: LD_EXP 27
8412: PPUSH
8413: LD_EXP 13
8417: PPUSH
8418: LD_INT 0
8420: PPUSH
8421: CALL_OW 290
// end ;
8425: GO 8261
8427: POP
8428: POP
// repeat wait ( 0 0$1 ) ;
8429: LD_INT 35
8431: PPUSH
8432: CALL_OW 67
// if player_attacked_ar then
8436: LD_EXP 16
8440: IFFALSE 8444
// exit ;
8442: GO 9325
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8444: LD_VAR 0 3
8448: PUSH
8449: LD_INT 1
8451: ARRAY
8452: PPUSH
8453: LD_EXP 13
8457: PPUSH
8458: CALL_OW 289
8462: PUSH
8463: LD_VAR 0 2
8467: PUSH
8468: LD_INT 10
8470: MUL
8471: EQUAL
8472: IFFALSE 8429
// no_oil_gain := false ;
8474: LD_ADDR_VAR 0 6
8478: PUSH
8479: LD_INT 0
8481: ST_TO_ADDR
// end else
8482: GO 8966
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_INT 22
8491: PUSH
8492: LD_INT 2
8494: PUSH
8495: EMPTY
8496: LIST
8497: LIST
8498: PUSH
8499: LD_INT 21
8501: PUSH
8502: LD_INT 2
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: EMPTY
8510: LIST
8511: LIST
8512: PPUSH
8513: CALL_OW 69
8517: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8518: LD_EXP 27
8522: PPUSH
8523: LD_VAR 0 4
8527: PPUSH
8528: CALL_OW 250
8532: PUSH
8533: LD_INT 1
8535: PLUS
8536: PPUSH
8537: LD_VAR 0 4
8541: PPUSH
8542: CALL_OW 251
8546: PUSH
8547: LD_INT 1
8549: PLUS
8550: PPUSH
8551: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8555: LD_INT 35
8557: PPUSH
8558: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8562: LD_EXP 27
8566: PPUSH
8567: LD_VAR 0 4
8571: PPUSH
8572: CALL_OW 296
8576: PUSH
8577: LD_INT 4
8579: LESS
8580: IFFALSE 8555
// for i = 1 to 6 do
8582: LD_ADDR_VAR 0 1
8586: PUSH
8587: DOUBLE
8588: LD_INT 1
8590: DEC
8591: ST_TO_ADDR
8592: LD_INT 6
8594: PUSH
8595: FOR_TO
8596: IFFALSE 8793
// begin if player_attacked_ar then
8598: LD_EXP 16
8602: IFFALSE 8608
// exit ;
8604: POP
8605: POP
8606: GO 9325
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8608: LD_VAR 0 4
8612: PPUSH
8613: CALL_OW 274
8617: PPUSH
8618: LD_INT 2
8620: PPUSH
8621: CALL_OW 275
8625: PUSH
8626: LD_INT 10
8628: LESS
8629: PUSH
8630: LD_VAR 0 7
8634: NOT
8635: AND
8636: IFFALSE 8699
// begin first_warn := true ;
8638: LD_ADDR_VAR 0 7
8642: PUSH
8643: LD_INT 1
8645: ST_TO_ADDR
// DialogueOn ;
8646: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8650: LD_EXP 28
8654: PPUSH
8655: LD_STRING D9a-FAr1-1
8657: PPUSH
8658: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8662: LD_EXP 18
8666: PPUSH
8667: LD_STRING D9a-JMM-1
8669: PPUSH
8670: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8674: LD_EXP 26
8678: PPUSH
8679: LD_STRING D9a2-Ar1-1
8681: PPUSH
8682: CALL_OW 88
// DialogueOff ;
8686: CALL_OW 7
// wait ( time ) ;
8690: LD_VAR 0 5
8694: PPUSH
8695: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 274
8708: PPUSH
8709: LD_INT 2
8711: PPUSH
8712: CALL_OW 275
8716: PUSH
8717: LD_INT 10
8719: LESS
8720: IFFALSE 8746
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8722: LD_EXP 26
8726: PPUSH
8727: LD_STRING D9a3-Ar1-1
8729: PPUSH
8730: CALL_OW 88
// no_oil_gain := true ;
8734: LD_ADDR_VAR 0 6
8738: PUSH
8739: LD_INT 1
8741: ST_TO_ADDR
// break ;
8742: GO 8793
// end else
8744: GO 8791
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8746: LD_EXP 27
8750: PPUSH
8751: LD_VAR 0 4
8755: PPUSH
8756: LD_INT 2
8758: PPUSH
8759: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8763: LD_EXP 27
8767: PPUSH
8768: LD_VAR 0 3
8772: PUSH
8773: LD_VAR 0 1
8777: PUSH
8778: LD_INT 3
8780: MOD
8781: PUSH
8782: LD_INT 1
8784: PLUS
8785: ARRAY
8786: PPUSH
8787: CALL_OW 210
// end ; end ;
8791: GO 8595
8793: POP
8794: POP
// repeat wait ( 0 0$1 ) ;
8795: LD_INT 35
8797: PPUSH
8798: CALL_OW 67
// if player_attacked_ar then
8802: LD_EXP 16
8806: IFFALSE 8810
// exit ;
8808: GO 9325
// for i in tmp do
8810: LD_ADDR_VAR 0 1
8814: PUSH
8815: LD_VAR 0 3
8819: PUSH
8820: FOR_IN
8821: IFFALSE 8852
// if GetFuel ( i ) < 100 then
8823: LD_VAR 0 1
8827: PPUSH
8828: CALL_OW 261
8832: PUSH
8833: LD_INT 100
8835: LESS
8836: IFFALSE 8850
// begin x := i ;
8838: LD_ADDR_VAR 0 2
8842: PUSH
8843: LD_VAR 0 1
8847: ST_TO_ADDR
// break ;
8848: GO 8852
// end ;
8850: GO 8820
8852: POP
8853: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8854: LD_EXP 27
8858: PPUSH
8859: CALL_OW 314
8863: NOT
8864: PUSH
8865: LD_EXP 27
8869: PPUSH
8870: CALL_OW 281
8874: NOT
8875: AND
8876: IFFALSE 8909
// begin ComTransport ( Gali , dep , mat_oil ) ;
8878: LD_EXP 27
8882: PPUSH
8883: LD_VAR 0 4
8887: PPUSH
8888: LD_INT 2
8890: PPUSH
8891: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8895: LD_EXP 27
8899: PPUSH
8900: LD_VAR 0 2
8904: PPUSH
8905: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8909: LD_VAR 0 3
8913: PUSH
8914: LD_INT 1
8916: ARRAY
8917: PPUSH
8918: CALL_OW 261
8922: PUSH
8923: LD_INT 80
8925: GREATER
8926: PUSH
8927: LD_VAR 0 3
8931: PUSH
8932: LD_INT 2
8934: ARRAY
8935: PPUSH
8936: CALL_OW 261
8940: PUSH
8941: LD_INT 80
8943: GREATER
8944: AND
8945: PUSH
8946: LD_VAR 0 3
8950: PUSH
8951: LD_INT 3
8953: ARRAY
8954: PPUSH
8955: CALL_OW 261
8959: PUSH
8960: LD_INT 80
8962: GREATER
8963: AND
8964: IFFALSE 8795
// end ; ComHold ( Gali ) ;
8966: LD_EXP 27
8970: PPUSH
8971: CALL_OW 140
// if not no_oil_gain then
8975: LD_VAR 0 6
8979: NOT
8980: IFFALSE 9145
// begin DialogueOn ;
8982: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8986: LD_EXP 26
8990: PPUSH
8991: CALL_OW 87
// if player_want_mortar then
8995: LD_EXP 12
8999: IFFALSE 9025
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9001: LD_EXP 26
9005: PPUSH
9006: LD_STRING D9e-Ar1-1
9008: PPUSH
9009: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9013: LD_EXP 18
9017: PPUSH
9018: LD_STRING D10a-JMM-1
9020: PPUSH
9021: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9025: LD_EXP 26
9029: PPUSH
9030: LD_STRING D10a-Ar1-1
9032: PPUSH
9033: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9037: LD_EXP 27
9041: PPUSH
9042: LD_STRING D10a-Ar2-1
9044: PPUSH
9045: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9049: LD_EXP 28
9053: PPUSH
9054: LD_STRING D10a-FAr1-1
9056: PPUSH
9057: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9061: LD_EXP 27
9065: PPUSH
9066: LD_STRING D10a-Ar2-2
9068: PPUSH
9069: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9073: LD_EXP 28
9077: PPUSH
9078: LD_STRING D10a-FAr1-2
9080: PPUSH
9081: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9085: LD_EXP 26
9089: PPUSH
9090: LD_STRING D10a-Ar1-2
9092: PPUSH
9093: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9097: LD_EXP 18
9101: PPUSH
9102: LD_STRING D10a-JMM-2
9104: PPUSH
9105: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9109: LD_EXP 26
9113: PPUSH
9114: LD_STRING D10a-Ar1-3
9116: PPUSH
9117: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9121: LD_EXP 18
9125: PPUSH
9126: LD_STRING D10a-JMM-3
9128: PPUSH
9129: CALL_OW 88
// player_get_info := true ;
9133: LD_ADDR_EXP 15
9137: PUSH
9138: LD_INT 1
9140: ST_TO_ADDR
// DialogueOff ;
9141: CALL_OW 7
// end ; end ; if player_attacked_ar then
9145: LD_EXP 16
9149: IFFALSE 9153
// exit ;
9151: GO 9325
// if player_want_mortar or player_want_info then
9153: LD_EXP 12
9157: PUSH
9158: LD_EXP 13
9162: OR
9163: IFFALSE 9177
// Say ( Vervecken , D9f-Ar1-1 ) ;
9165: LD_EXP 26
9169: PPUSH
9170: LD_STRING D9f-Ar1-1
9172: PPUSH
9173: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9177: LD_INT 22
9179: PUSH
9180: LD_INT 2
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: PPUSH
9187: CALL_OW 69
9191: PPUSH
9192: LD_INT 51
9194: PPUSH
9195: LD_INT 99
9197: PPUSH
9198: CALL_OW 111
// wait ( 0 0$1 ) ;
9202: LD_INT 35
9204: PPUSH
9205: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9209: LD_INT 22
9211: PUSH
9212: LD_INT 2
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: PUSH
9219: LD_INT 92
9221: PUSH
9222: LD_INT 51
9224: PUSH
9225: LD_INT 99
9227: PUSH
9228: LD_INT 2
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: PPUSH
9241: CALL_OW 69
9245: IFFALSE 9305
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9247: LD_ADDR_VAR 0 1
9251: PUSH
9252: LD_INT 22
9254: PUSH
9255: LD_INT 2
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: PUSH
9262: LD_INT 92
9264: PUSH
9265: LD_INT 51
9267: PUSH
9268: LD_INT 99
9270: PUSH
9271: LD_INT 2
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: LIST
9278: LIST
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: PPUSH
9284: CALL_OW 69
9288: PUSH
9289: FOR_IN
9290: IFFALSE 9303
// RemoveUnit ( i ) ;
9292: LD_VAR 0 1
9296: PPUSH
9297: CALL_OW 64
9301: GO 9289
9303: POP
9304: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9305: LD_INT 22
9307: PUSH
9308: LD_INT 2
9310: PUSH
9311: EMPTY
9312: LIST
9313: LIST
9314: PPUSH
9315: CALL_OW 69
9319: PUSH
9320: LD_INT 0
9322: EQUAL
9323: IFFALSE 9177
// end ;
9325: PPOPN 8
9327: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9328: LD_EXP 16
9332: IFFALSE 9685
9334: GO 9336
9336: DISABLE
9337: LD_INT 0
9339: PPUSH
9340: PPUSH
9341: PPUSH
9342: PPUSH
// begin ru_can_attack := true ;
9343: LD_ADDR_EXP 8
9347: PUSH
9348: LD_INT 1
9350: ST_TO_ADDR
// mine_launched := false ;
9351: LD_ADDR_VAR 0 3
9355: PUSH
9356: LD_INT 0
9358: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9359: LD_INT 22
9361: PUSH
9362: LD_INT 2
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PPUSH
9369: CALL_OW 69
9373: PPUSH
9374: LD_INT 51
9376: PPUSH
9377: LD_INT 99
9379: PPUSH
9380: CALL_OW 111
// if IsOk ( Vervecken ) then
9384: LD_EXP 26
9388: PPUSH
9389: CALL_OW 302
9393: IFFALSE 9407
// Say ( Vervecken , D11a-Ar1-1 ) ;
9395: LD_EXP 26
9399: PPUSH
9400: LD_STRING D11a-Ar1-1
9402: PPUSH
9403: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9407: LD_ADDR_VAR 0 2
9411: PUSH
9412: LD_EXP 33
9416: PPUSH
9417: LD_INT 25
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 72
9431: ST_TO_ADDR
// for i in tmp do
9432: LD_ADDR_VAR 0 1
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: FOR_IN
9443: IFFALSE 9506
// if MineOfUnit ( i ) then
9445: LD_VAR 0 1
9449: PPUSH
9450: CALL_OW 459
9454: IFFALSE 9504
// begin x := MineOfUnit ( i ) ;
9456: LD_ADDR_VAR 0 4
9460: PUSH
9461: LD_VAR 0 1
9465: PPUSH
9466: CALL_OW 459
9470: ST_TO_ADDR
// mine_launched := true ;
9471: LD_ADDR_VAR 0 3
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9479: LD_VAR 0 4
9483: PUSH
9484: LD_INT 1
9486: ARRAY
9487: PPUSH
9488: LD_VAR 0 4
9492: PUSH
9493: LD_INT 2
9495: ARRAY
9496: PPUSH
9497: LD_INT 2
9499: PPUSH
9500: CALL_OW 456
// end ;
9504: GO 9442
9506: POP
9507: POP
// if mine_launched and IsOk ( Vervecken ) then
9508: LD_VAR 0 3
9512: PUSH
9513: LD_EXP 26
9517: PPUSH
9518: CALL_OW 302
9522: AND
9523: IFFALSE 9537
// Say ( Vervecken , D11b-Ar1-1 ) ;
9525: LD_EXP 26
9529: PPUSH
9530: LD_STRING D11b-Ar1-1
9532: PPUSH
9533: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9537: LD_INT 22
9539: PUSH
9540: LD_INT 2
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: PPUSH
9547: CALL_OW 69
9551: PPUSH
9552: LD_INT 51
9554: PPUSH
9555: LD_INT 99
9557: PPUSH
9558: CALL_OW 111
// wait ( 0 0$1 ) ;
9562: LD_INT 35
9564: PPUSH
9565: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9569: LD_INT 22
9571: PUSH
9572: LD_INT 2
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PUSH
9579: LD_INT 92
9581: PUSH
9582: LD_INT 51
9584: PUSH
9585: LD_INT 99
9587: PUSH
9588: LD_INT 2
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: LIST
9595: LIST
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: PPUSH
9601: CALL_OW 69
9605: IFFALSE 9665
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9607: LD_ADDR_VAR 0 1
9611: PUSH
9612: LD_INT 22
9614: PUSH
9615: LD_INT 2
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: PUSH
9622: LD_INT 92
9624: PUSH
9625: LD_INT 51
9627: PUSH
9628: LD_INT 99
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PPUSH
9644: CALL_OW 69
9648: PUSH
9649: FOR_IN
9650: IFFALSE 9663
// RemoveUnit ( i ) ;
9652: LD_VAR 0 1
9656: PPUSH
9657: CALL_OW 64
9661: GO 9649
9663: POP
9664: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9665: LD_INT 22
9667: PUSH
9668: LD_INT 2
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PPUSH
9675: CALL_OW 69
9679: PUSH
9680: LD_INT 0
9682: EQUAL
9683: IFFALSE 9537
// end ;
9685: PPOPN 4
9687: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9688: LD_EXP 10
9692: IFFALSE 9871
9694: GO 9696
9696: DISABLE
9697: LD_INT 0
9699: PPUSH
// begin Wait ( 10 10$00 ) ;
9700: LD_INT 21000
9702: PPUSH
9703: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9707: LD_INT 22
9709: PUSH
9710: LD_INT 2
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: PPUSH
9717: CALL_OW 69
9721: IFFALSE 9871
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9723: LD_INT 22
9725: PUSH
9726: LD_INT 2
9728: PUSH
9729: EMPTY
9730: LIST
9731: LIST
9732: PPUSH
9733: CALL_OW 69
9737: PPUSH
9738: LD_INT 51
9740: PPUSH
9741: LD_INT 99
9743: PPUSH
9744: CALL_OW 114
// wait ( 0 0$1 ) ;
9748: LD_INT 35
9750: PPUSH
9751: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9755: LD_INT 22
9757: PUSH
9758: LD_INT 2
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: PUSH
9765: LD_INT 92
9767: PUSH
9768: LD_INT 51
9770: PUSH
9771: LD_INT 99
9773: PUSH
9774: LD_INT 2
9776: PUSH
9777: EMPTY
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: EMPTY
9784: LIST
9785: LIST
9786: PPUSH
9787: CALL_OW 69
9791: IFFALSE 9851
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9793: LD_ADDR_VAR 0 1
9797: PUSH
9798: LD_INT 22
9800: PUSH
9801: LD_INT 2
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PUSH
9808: LD_INT 92
9810: PUSH
9811: LD_INT 51
9813: PUSH
9814: LD_INT 99
9816: PUSH
9817: LD_INT 2
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: PUSH
9826: EMPTY
9827: LIST
9828: LIST
9829: PPUSH
9830: CALL_OW 69
9834: PUSH
9835: FOR_IN
9836: IFFALSE 9849
// RemoveUnit ( i ) ;
9838: LD_VAR 0 1
9842: PPUSH
9843: CALL_OW 64
9847: GO 9835
9849: POP
9850: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9851: LD_INT 22
9853: PUSH
9854: LD_INT 2
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: PPUSH
9861: CALL_OW 69
9865: PUSH
9866: LD_INT 0
9868: EQUAL
9869: IFFALSE 9723
// end ; end ;
9871: PPOPN 1
9873: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9874: LD_EXP 4
9878: IFFALSE 10806
9880: GO 9882
9882: DISABLE
9883: LD_INT 0
9885: PPUSH
9886: PPUSH
9887: PPUSH
// begin Wait ( game_time ) ;
9888: LD_EXP 7
9892: PPUSH
9893: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9897: LD_INT 35
9899: PPUSH
9900: CALL_OW 67
// until ( not ru_can_attack ) ;
9904: LD_EXP 8
9908: NOT
9909: IFFALSE 9897
// Wait ( 0 0$35 ) ;
9911: LD_INT 1225
9913: PPUSH
9914: CALL_OW 67
// DialogueOn ;
9918: CALL_OW 6
// InGameOn ;
9922: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9926: LD_EXP 25
9930: PPUSH
9931: LD_STRING D12-Pow-1
9933: PPUSH
9934: CALL_OW 94
// InGameOff ;
9938: CALL_OW 9
// DialogueOff ;
9942: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9946: LD_STRING M4
9948: PPUSH
9949: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9953: LD_INT 5
9955: PPUSH
9956: LD_INT 1
9958: PPUSH
9959: CALL_OW 424
// can_end := true ;
9963: LD_ADDR_EXP 17
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9971: LD_INT 35
9973: PPUSH
9974: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9978: CALL 784 0 0
9982: PUSH
9983: LD_INT 20
9985: GREATEREQUAL
9986: PUSH
9987: LD_INT 22
9989: PUSH
9990: LD_INT 1
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 21
9999: PUSH
10000: LD_INT 1
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PPUSH
10011: CALL_OW 69
10015: PUSH
10016: LD_INT 5
10018: PPUSH
10019: LD_INT 22
10021: PUSH
10022: LD_INT 1
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PUSH
10029: LD_INT 21
10031: PUSH
10032: LD_INT 1
10034: PUSH
10035: EMPTY
10036: LIST
10037: LIST
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: PPUSH
10043: CALL_OW 70
10047: PUSH
10048: LD_INT 22
10050: PUSH
10051: LD_INT 1
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 55
10060: PUSH
10061: EMPTY
10062: LIST
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PPUSH
10068: CALL_OW 69
10072: PLUS
10073: LESSEQUAL
10074: AND
10075: IFFALSE 9971
// if not player_get_info then
10077: LD_EXP 15
10081: NOT
10082: IFFALSE 10093
// player_get_info := - 1 ;
10084: LD_ADDR_EXP 15
10088: PUSH
10089: LD_INT 1
10091: NEG
10092: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10093: LD_STRING Information
10095: PPUSH
10096: LD_EXP 15
10100: PPUSH
10101: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10105: LD_ADDR_VAR 0 2
10109: PUSH
10110: LD_INT 22
10112: PUSH
10113: LD_INT 1
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 2
10122: PUSH
10123: LD_INT 25
10125: PUSH
10126: LD_INT 2
10128: PUSH
10129: EMPTY
10130: LIST
10131: LIST
10132: PUSH
10133: LD_INT 25
10135: PUSH
10136: LD_INT 16
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: LD_INT 34
10145: PUSH
10146: LD_INT 12
10148: PUSH
10149: EMPTY
10150: LIST
10151: LIST
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: PPUSH
10163: CALL_OW 69
10167: ST_TO_ADDR
// sib := GetTerminalCargo ;
10168: LD_ADDR_VAR 0 3
10172: PUSH
10173: CALL 784 0 0
10177: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10178: LD_ADDR_VAR 0 3
10182: PUSH
10183: LD_VAR 0 3
10187: PUSH
10188: LD_INT 6
10190: PPUSH
10191: LD_INT 3
10193: PPUSH
10194: CALL_OW 287
10198: PLUS
10199: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10200: LD_ADDR_VAR 0 3
10204: PUSH
10205: LD_VAR 0 3
10209: PUSH
10210: LD_VAR 0 2
10214: PPUSH
10215: LD_INT 3
10217: PPUSH
10218: CALL_OW 289
10222: PLUS
10223: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10224: LD_VAR 0 3
10228: PUSH
10229: LD_INT 2
10231: PUSH
10232: LD_OWVAR 67
10236: PLUS
10237: PUSH
10238: LD_INT 50
10240: MUL
10241: LESS
10242: IFFALSE 10267
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10244: LD_STRING MuchSiberite
10246: PPUSH
10247: LD_INT 2
10249: NEG
10250: PUSH
10251: LD_OWVAR 67
10255: MUL
10256: PUSH
10257: LD_INT 1
10259: PLUS
10260: PPUSH
10261: CALL_OW 101
10265: GO 10277
// AddMedal ( MuchSiberite , 1 ) ;
10267: LD_STRING MuchSiberite
10269: PPUSH
10270: LD_INT 1
10272: PPUSH
10273: CALL_OW 101
// GiveMedals ( MAIN ) ;
10277: LD_STRING MAIN
10279: PPUSH
10280: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10284: LD_INT 22
10286: PUSH
10287: LD_INT 1
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: PUSH
10294: LD_INT 2
10296: PUSH
10297: LD_INT 25
10299: PUSH
10300: LD_INT 1
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 25
10309: PUSH
10310: LD_INT 2
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PUSH
10317: LD_INT 25
10319: PUSH
10320: LD_INT 3
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 25
10329: PUSH
10330: LD_INT 4
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: LD_INT 25
10339: PUSH
10340: LD_INT 8
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: PPUSH
10359: CALL_OW 69
10363: PPUSH
10364: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10368: LD_ADDR_VAR 0 2
10372: PUSH
10373: LD_INT 22
10375: PUSH
10376: LD_INT 1
10378: PUSH
10379: EMPTY
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 25
10385: PUSH
10386: LD_INT 8
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PPUSH
10397: CALL_OW 69
10401: ST_TO_ADDR
// if tmp then
10402: LD_VAR 0 2
10406: IFFALSE 10437
// for i in tmp do
10408: LD_ADDR_VAR 0 1
10412: PUSH
10413: LD_VAR 0 2
10417: PUSH
10418: FOR_IN
10419: IFFALSE 10435
// SetClass ( i , 1 ) ;
10421: LD_VAR 0 1
10425: PPUSH
10426: LD_INT 1
10428: PPUSH
10429: CALL_OW 336
10433: GO 10418
10435: POP
10436: POP
// SaveVariable ( sib , 09_sibRes ) ;
10437: LD_VAR 0 3
10441: PPUSH
10442: LD_STRING 09_sibRes
10444: PPUSH
10445: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10449: LD_EXP 15
10453: PPUSH
10454: LD_STRING 09_arInfo
10456: PPUSH
10457: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10461: LD_EXP 18
10465: PPUSH
10466: LD_EXP 1
10470: PUSH
10471: LD_STRING JMM
10473: STR
10474: PPUSH
10475: CALL_OW 38
// if IsLive ( Gary ) then
10479: LD_EXP 19
10483: PPUSH
10484: CALL_OW 300
10488: IFFALSE 10508
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10490: LD_EXP 19
10494: PPUSH
10495: LD_EXP 1
10499: PUSH
10500: LD_STRING Gary
10502: STR
10503: PPUSH
10504: CALL_OW 38
// if IsLive ( Bobby ) then
10508: LD_EXP 20
10512: PPUSH
10513: CALL_OW 300
10517: IFFALSE 10537
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10519: LD_EXP 20
10523: PPUSH
10524: LD_EXP 1
10528: PUSH
10529: LD_STRING Bobby
10531: STR
10532: PPUSH
10533: CALL_OW 38
// if IsLive ( Cyrus ) then
10537: LD_EXP 21
10541: PPUSH
10542: CALL_OW 300
10546: IFFALSE 10566
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10548: LD_EXP 21
10552: PPUSH
10553: LD_EXP 1
10557: PUSH
10558: LD_STRING Cyrus
10560: STR
10561: PPUSH
10562: CALL_OW 38
// if IsLive ( Houten ) then
10566: LD_EXP 22
10570: PPUSH
10571: CALL_OW 300
10575: IFFALSE 10595
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10577: LD_EXP 22
10581: PPUSH
10582: LD_EXP 1
10586: PUSH
10587: LD_STRING Houten
10589: STR
10590: PPUSH
10591: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10595: LD_ADDR_VAR 0 2
10599: PUSH
10600: LD_INT 22
10602: PUSH
10603: LD_INT 1
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PUSH
10610: LD_INT 2
10612: PUSH
10613: LD_INT 25
10615: PUSH
10616: LD_INT 1
10618: PUSH
10619: EMPTY
10620: LIST
10621: LIST
10622: PUSH
10623: LD_INT 25
10625: PUSH
10626: LD_INT 2
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 25
10635: PUSH
10636: LD_INT 3
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 25
10645: PUSH
10646: LD_INT 4
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PPUSH
10664: CALL_OW 69
10668: PUSH
10669: LD_EXP 18
10673: PUSH
10674: LD_EXP 21
10678: PUSH
10679: LD_EXP 20
10683: PUSH
10684: LD_EXP 22
10688: PUSH
10689: LD_EXP 19
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: LIST
10700: DIFF
10701: ST_TO_ADDR
// if tmp then
10702: LD_VAR 0 2
10706: IFFALSE 10726
// SaveCharacters ( tmp , mission_prefix & others ) ;
10708: LD_VAR 0 2
10712: PPUSH
10713: LD_EXP 1
10717: PUSH
10718: LD_STRING others
10720: STR
10721: PPUSH
10722: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10726: LD_ADDR_VAR 0 2
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 1
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 2
10743: PUSH
10744: LD_INT 25
10746: PUSH
10747: LD_INT 12
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PUSH
10754: LD_INT 25
10756: PUSH
10757: LD_INT 16
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: LIST
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PPUSH
10773: CALL_OW 69
10777: ST_TO_ADDR
// if tmp then
10778: LD_VAR 0 2
10782: IFFALSE 10802
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10784: LD_VAR 0 2
10788: PPUSH
10789: LD_EXP 1
10793: PUSH
10794: LD_STRING apes
10796: STR
10797: PPUSH
10798: CALL_OW 38
// YouWin ;
10802: CALL_OW 103
// end ; end_of_file
10806: PPOPN 3
10808: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10809: LD_VAR 0 1
10813: PPUSH
10814: CALL_OW 266
10818: PUSH
10819: LD_INT 0
10821: EQUAL
10822: PUSH
10823: LD_EXP 3
10827: NOT
10828: AND
10829: IFFALSE 10853
// begin terminal := b ;
10831: LD_ADDR_EXP 3
10835: PUSH
10836: LD_VAR 0 1
10840: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10841: LD_EXP 3
10845: PPUSH
10846: LD_STRING terminal
10848: PPUSH
10849: CALL_OW 500
// end ; end ;
10853: PPOPN 2
10855: END
// on BuildingComplete ( b ) do var i ;
10856: LD_INT 0
10858: PPUSH
// begin if GetSide ( b ) = 3 then
10859: LD_VAR 0 1
10863: PPUSH
10864: CALL_OW 255
10868: PUSH
10869: LD_INT 3
10871: EQUAL
10872: IFFALSE 10912
// for i = 1 to 4 do
10874: LD_ADDR_VAR 0 2
10878: PUSH
10879: DOUBLE
10880: LD_INT 1
10882: DEC
10883: ST_TO_ADDR
10884: LD_INT 4
10886: PUSH
10887: FOR_TO
10888: IFFALSE 10910
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10890: LD_ADDR_EXP 36
10894: PUSH
10895: LD_EXP 36
10899: PPUSH
10900: LD_INT 1
10902: PPUSH
10903: CALL_OW 3
10907: ST_TO_ADDR
10908: GO 10887
10910: POP
10911: POP
// end ;
10912: PPOPN 2
10914: END
// on VehicleConstructed ( veh , fac ) do var i ;
10915: LD_INT 0
10917: PPUSH
// begin if GetSide ( veh ) = 3 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 255
10927: PUSH
10928: LD_INT 3
10930: EQUAL
10931: IFFALSE 11056
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 53
10945: PUSH
10946: LD_INT 52
10948: PUSH
10949: LD_INT 51
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: LIST
10956: IN
10957: NOT
10958: IFFALSE 10976
// ru_force := ru_force ^ veh ;
10960: LD_ADDR_EXP 35
10964: PUSH
10965: LD_EXP 35
10969: PUSH
10970: LD_VAR 0 1
10974: ADD
10975: ST_TO_ADDR
// for i = 1 to 4 do
10976: LD_ADDR_VAR 0 3
10980: PUSH
10981: DOUBLE
10982: LD_INT 1
10984: DEC
10985: ST_TO_ADDR
10986: LD_INT 4
10988: PUSH
10989: FOR_TO
10990: IFFALSE 11012
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10992: LD_ADDR_EXP 37
10996: PUSH
10997: LD_EXP 37
11001: PPUSH
11002: LD_INT 1
11004: PPUSH
11005: CALL_OW 3
11009: ST_TO_ADDR
11010: GO 10989
11012: POP
11013: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11014: LD_VAR 0 1
11018: PPUSH
11019: CALL_OW 264
11023: PUSH
11024: LD_INT 53
11026: EQUAL
11027: IFFALSE 11056
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11029: LD_VAR 0 1
11033: PPUSH
11034: LD_INT 7
11036: PPUSH
11037: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11041: LD_VAR 0 1
11045: PPUSH
11046: LD_INT 170
11048: PPUSH
11049: LD_INT 235
11051: PPUSH
11052: CALL_OW 171
// end ; end ; end ;
11056: PPOPN 3
11058: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11059: LD_VAR 0 1
11063: PUSH
11064: LD_INT 1
11066: EQUAL
11067: PUSH
11068: LD_VAR 0 2
11072: PUSH
11073: LD_INT 2
11075: EQUAL
11076: AND
11077: PUSH
11078: LD_VAR 0 1
11082: PUSH
11083: LD_INT 2
11085: EQUAL
11086: PUSH
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 1
11094: EQUAL
11095: AND
11096: OR
11097: IFFALSE 11107
// player_attacked_ar := true ;
11099: LD_ADDR_EXP 16
11103: PUSH
11104: LD_INT 1
11106: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11107: LD_VAR 0 1
11111: PUSH
11112: LD_INT 1
11114: EQUAL
11115: PUSH
11116: LD_VAR 0 2
11120: PUSH
11121: LD_INT 4
11123: EQUAL
11124: AND
11125: PUSH
11126: LD_VAR 0 1
11130: PUSH
11131: LD_INT 4
11133: EQUAL
11134: PUSH
11135: LD_VAR 0 2
11139: PUSH
11140: LD_INT 1
11142: EQUAL
11143: AND
11144: OR
11145: IFFALSE 11154
// YouLost ( Traitor ) ;
11147: LD_STRING Traitor
11149: PPUSH
11150: CALL_OW 104
// end ;
11154: PPOPN 2
11156: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11157: LD_VAR 0 1
11161: PUSH
11162: LD_EXP 18
11166: EQUAL
11167: IFFALSE 11176
// YouLost ( JMM ) ;
11169: LD_STRING JMM
11171: PPUSH
11172: CALL_OW 104
// if un = terminal then
11176: LD_VAR 0 1
11180: PUSH
11181: LD_EXP 3
11185: EQUAL
11186: IFFALSE 11195
// YouLost ( Terminal ) ;
11188: LD_STRING Terminal
11190: PPUSH
11191: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11195: LD_VAR 0 1
11199: PUSH
11200: LD_INT 22
11202: PUSH
11203: LD_INT 3
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: PUSH
11210: LD_INT 21
11212: PUSH
11213: LD_INT 3
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: PPUSH
11224: CALL_OW 69
11228: IN
11229: IFFALSE 11375
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11231: LD_VAR 0 1
11235: PPUSH
11236: CALL_OW 266
11240: PUSH
11241: LD_INT 33
11243: PUSH
11244: LD_INT 26
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: IN
11251: IFFALSE 11310
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11253: LD_ADDR_EXP 36
11257: PUSH
11258: LD_EXP 36
11262: PUSH
11263: LD_VAR 0 1
11267: PPUSH
11268: CALL_OW 266
11272: PUSH
11273: LD_VAR 0 1
11277: PPUSH
11278: CALL_OW 250
11282: PUSH
11283: LD_VAR 0 1
11287: PPUSH
11288: CALL_OW 251
11292: PUSH
11293: LD_VAR 0 1
11297: PPUSH
11298: CALL_OW 254
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: ADD
11309: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11310: LD_VAR 0 1
11314: PPUSH
11315: CALL_OW 266
11319: PUSH
11320: LD_INT 5
11322: EQUAL
11323: IFFALSE 11375
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11325: LD_ADDR_EXP 36
11329: PUSH
11330: LD_EXP 36
11334: PUSH
11335: LD_INT 4
11337: PUSH
11338: LD_VAR 0 1
11342: PPUSH
11343: CALL_OW 250
11347: PUSH
11348: LD_VAR 0 1
11352: PPUSH
11353: CALL_OW 251
11357: PUSH
11358: LD_VAR 0 1
11362: PPUSH
11363: CALL_OW 254
11367: PUSH
11368: EMPTY
11369: LIST
11370: LIST
11371: LIST
11372: LIST
11373: ADD
11374: ST_TO_ADDR
// end ; if un in ru_force then
11375: LD_VAR 0 1
11379: PUSH
11380: LD_EXP 35
11384: IN
11385: IFFALSE 11421
// begin ru_force := ru_force diff un ;
11387: LD_ADDR_EXP 35
11391: PUSH
11392: LD_EXP 35
11396: PUSH
11397: LD_VAR 0 1
11401: DIFF
11402: ST_TO_ADDR
// if ru_force = 0 then
11403: LD_EXP 35
11407: PUSH
11408: LD_INT 0
11410: EQUAL
11411: IFFALSE 11421
// ru_can_attack := false ;
11413: LD_ADDR_EXP 8
11417: PUSH
11418: LD_INT 0
11420: ST_TO_ADDR
// end ; end ; end_of_file
11421: PPOPN 1
11423: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11424: LD_EXP 5
11428: PUSH
11429: LD_EXP 6
11433: AND
11434: IFFALSE 11512
11436: GO 11438
11438: DISABLE
11439: LD_INT 0
11441: PPUSH
// begin enable ;
11442: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11443: LD_ADDR_VAR 0 1
11447: PUSH
11448: LD_INT 60
11450: PUSH
11451: CALL 784 0 0
11455: MINUS
11456: ST_TO_ADDR
// if sib < 0 then
11457: LD_VAR 0 1
11461: PUSH
11462: LD_INT 0
11464: LESS
11465: IFFALSE 11475
// sib := 0 ;
11467: LD_ADDR_VAR 0 1
11471: PUSH
11472: LD_INT 0
11474: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11475: LD_ADDR_OWVAR 47
11479: PUSH
11480: LD_STRING #Am09-1
11482: PUSH
11483: LD_VAR 0 1
11487: PUSH
11488: LD_EXP 6
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: LIST
11497: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11498: LD_ADDR_EXP 6
11502: PUSH
11503: LD_EXP 6
11507: PUSH
11508: LD_INT 35
11510: MINUS
11511: ST_TO_ADDR
// end ;
11512: PPOPN 1
11514: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11515: LD_EXP 6
11519: PUSH
11520: LD_INT 0
11522: EQUAL
11523: IFFALSE 11535
11525: GO 11527
11527: DISABLE
// display_strings := [ ] ;
11528: LD_ADDR_OWVAR 47
11532: PUSH
11533: EMPTY
11534: ST_TO_ADDR
11535: END
// every 0 0$01 trigger ru_force and debug do
11536: LD_EXP 35
11540: PUSH
11541: LD_EXP 2
11545: AND
11546: IFFALSE 11562
11548: GO 11550
11550: DISABLE
// begin enable ;
11551: ENABLE
// display_strings := ru_force ;
11552: LD_ADDR_OWVAR 47
11556: PUSH
11557: LD_EXP 35
11561: ST_TO_ADDR
// end ;
11562: END
// every 1 1$35 do var i , tmp ;
11563: GO 11565
11565: DISABLE
11566: LD_INT 0
11568: PPUSH
11569: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11570: LD_ADDR_VAR 0 2
11574: PUSH
11575: LD_INT 1155
11577: PUSH
11578: LD_INT 1225
11580: PUSH
11581: LD_INT 1435
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: LIST
11588: PUSH
11589: LD_OWVAR 67
11593: ARRAY
11594: ST_TO_ADDR
// i := 0 ;
11595: LD_ADDR_VAR 0 1
11599: PUSH
11600: LD_INT 0
11602: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11603: LD_INT 1
11605: PPUSH
11606: LD_INT 5
11608: PPUSH
11609: CALL_OW 12
11613: PPUSH
11614: LD_INT 75
11616: PPUSH
11617: LD_INT 75
11619: PPUSH
11620: LD_INT 20
11622: PPUSH
11623: LD_INT 1
11625: PPUSH
11626: CALL_OW 56
// wait ( tmp ) ;
11630: LD_VAR 0 2
11634: PPUSH
11635: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11639: LD_ADDR_VAR 0 2
11643: PUSH
11644: LD_VAR 0 2
11648: PUSH
11649: LD_INT 105
11651: PPUSH
11652: LD_INT 315
11654: PPUSH
11655: CALL_OW 12
11659: PLUS
11660: ST_TO_ADDR
// i := i + 1 ;
11661: LD_ADDR_VAR 0 1
11665: PUSH
11666: LD_VAR 0 1
11670: PUSH
11671: LD_INT 1
11673: PLUS
11674: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11675: LD_VAR 0 1
11679: PUSH
11680: LD_INT 3
11682: MOD
11683: PUSH
11684: LD_INT 0
11686: EQUAL
11687: PUSH
11688: LD_EXP 4
11692: AND
11693: IFFALSE 11731
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11695: LD_INT 2
11697: PPUSH
11698: LD_INT 5
11700: PPUSH
11701: CALL_OW 12
11705: PPUSH
11706: LD_INT 8
11708: PPUSH
11709: LD_INT 1
11711: PPUSH
11712: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11716: LD_INT 665
11718: PPUSH
11719: LD_INT 735
11721: PPUSH
11722: CALL_OW 12
11726: PPUSH
11727: CALL_OW 67
// end ; until tick > game_time ;
11731: LD_OWVAR 1
11735: PUSH
11736: LD_EXP 7
11740: GREATER
11741: IFFALSE 11603
// end ; end_of_file
11743: PPOPN 2
11745: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11746: LD_INT 0
11748: PPUSH
11749: PPUSH
11750: PPUSH
11751: PPUSH
11752: PPUSH
11753: PPUSH
// x := 76 ;
11754: LD_ADDR_VAR 0 5
11758: PUSH
11759: LD_INT 76
11761: ST_TO_ADDR
// y := 147 ;
11762: LD_ADDR_VAR 0 6
11766: PUSH
11767: LD_INT 147
11769: ST_TO_ADDR
// uc_side := 2 ;
11770: LD_ADDR_OWVAR 20
11774: PUSH
11775: LD_INT 2
11777: ST_TO_ADDR
// uc_nation := 2 ;
11778: LD_ADDR_OWVAR 21
11782: PUSH
11783: LD_INT 2
11785: ST_TO_ADDR
// InitHc ;
11786: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11790: LD_INT 1
11792: PPUSH
11793: LD_INT 1
11795: PPUSH
11796: LD_INT 6
11798: PPUSH
11799: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11803: LD_ADDR_OWVAR 26
11807: PUSH
11808: LD_STRING Nicolas Vervecken
11810: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11811: LD_ADDR_OWVAR 33
11815: PUSH
11816: LD_STRING SecondCharsGal
11818: ST_TO_ADDR
// hc_face_number := 3 ;
11819: LD_ADDR_OWVAR 34
11823: PUSH
11824: LD_INT 3
11826: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11827: LD_ADDR_OWVAR 29
11831: PUSH
11832: LD_INT 11
11834: PUSH
11835: LD_INT 10
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: ST_TO_ADDR
// Vervecken := CreateHuman ;
11842: LD_ADDR_EXP 26
11846: PUSH
11847: CALL_OW 44
11851: ST_TO_ADDR
// ar_force := Vervecken ;
11852: LD_ADDR_EXP 33
11856: PUSH
11857: LD_EXP 26
11861: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11862: LD_INT 1
11864: PPUSH
11865: LD_INT 2
11867: PPUSH
11868: LD_INT 6
11870: PPUSH
11871: CALL_OW 380
// hc_name := Louis Gali ;
11875: LD_ADDR_OWVAR 26
11879: PUSH
11880: LD_STRING Louis Gali
11882: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11883: LD_ADDR_OWVAR 33
11887: PUSH
11888: LD_STRING SecondCharsGal
11890: ST_TO_ADDR
// hc_face_number := 2 ;
11891: LD_ADDR_OWVAR 34
11895: PUSH
11896: LD_INT 2
11898: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11899: LD_ADDR_OWVAR 29
11903: PUSH
11904: LD_INT 10
11906: PUSH
11907: LD_INT 11
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: ST_TO_ADDR
// Gali := CreateHuman ;
11914: LD_ADDR_EXP 27
11918: PUSH
11919: CALL_OW 44
11923: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11924: LD_ADDR_EXP 33
11928: PUSH
11929: LD_EXP 33
11933: PUSH
11934: LD_EXP 27
11938: ADD
11939: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11940: LD_INT 2
11942: PPUSH
11943: LD_INT 1
11945: PPUSH
11946: LD_INT 6
11948: PPUSH
11949: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11953: LD_ADDR_OWVAR 26
11957: PUSH
11958: LD_STRING Maria Bogdanovic
11960: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11961: LD_ADDR_OWVAR 33
11965: PUSH
11966: LD_STRING SecondCharsGal
11968: ST_TO_ADDR
// hc_face_number := 14 ;
11969: LD_ADDR_OWVAR 34
11973: PUSH
11974: LD_INT 14
11976: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11977: LD_ADDR_OWVAR 29
11981: PUSH
11982: LD_INT 12
11984: PUSH
11985: LD_INT 9
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11992: LD_ADDR_EXP 28
11996: PUSH
11997: CALL_OW 44
12001: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12002: LD_ADDR_EXP 33
12006: PUSH
12007: LD_EXP 33
12011: PUSH
12012: LD_EXP 28
12016: ADD
12017: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12018: LD_INT 1
12020: PPUSH
12021: LD_INT 3
12023: PPUSH
12024: LD_INT 6
12026: PPUSH
12027: CALL_OW 380
// hc_name = Kntor Radomr ;
12031: LD_ADDR_OWVAR 26
12035: PUSH
12036: LD_STRING Kntor Radomr
12038: ST_TO_ADDR
// hc_gallery = sandar ;
12039: LD_ADDR_OWVAR 33
12043: PUSH
12044: LD_STRING sandar
12046: ST_TO_ADDR
// hc_face_number = 12 ;
12047: LD_ADDR_OWVAR 34
12051: PUSH
12052: LD_INT 12
12054: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12055: LD_ADDR_OWVAR 29
12059: PUSH
12060: LD_INT 9
12062: PUSH
12063: LD_INT 9
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: ST_TO_ADDR
// Kantor = CreateHuman ;
12070: LD_ADDR_EXP 29
12074: PUSH
12075: CALL_OW 44
12079: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12080: LD_ADDR_EXP 33
12084: PUSH
12085: LD_EXP 33
12089: PUSH
12090: LD_EXP 29
12094: ADD
12095: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12096: LD_INT 1
12098: PPUSH
12099: LD_INT 3
12101: PPUSH
12102: LD_INT 6
12104: PPUSH
12105: CALL_OW 380
// hc_name = Herczeg Farkas ;
12109: LD_ADDR_OWVAR 26
12113: PUSH
12114: LD_STRING Herczeg Farkas
12116: ST_TO_ADDR
// hc_gallery = sandar ;
12117: LD_ADDR_OWVAR 33
12121: PUSH
12122: LD_STRING sandar
12124: ST_TO_ADDR
// hc_face_number = 28 ;
12125: LD_ADDR_OWVAR 34
12129: PUSH
12130: LD_INT 28
12132: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12133: LD_ADDR_OWVAR 29
12137: PUSH
12138: LD_INT 10
12140: PUSH
12141: LD_INT 9
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: ST_TO_ADDR
// Herczeg = CreateHuman ;
12148: LD_ADDR_EXP 30
12152: PUSH
12153: CALL_OW 44
12157: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12158: LD_ADDR_EXP 33
12162: PUSH
12163: LD_EXP 33
12167: PUSH
12168: LD_EXP 30
12172: ADD
12173: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12174: LD_INT 1
12176: PPUSH
12177: LD_INT 1
12179: PPUSH
12180: LD_INT 6
12182: PPUSH
12183: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12187: LD_ADDR_OWVAR 26
12191: PUSH
12192: LD_STRING Ronn Horntvedt
12194: ST_TO_ADDR
// hc_gallery = sandar ;
12195: LD_ADDR_OWVAR 33
12199: PUSH
12200: LD_STRING sandar
12202: ST_TO_ADDR
// hc_face_number = 29 ;
12203: LD_ADDR_OWVAR 34
12207: PUSH
12208: LD_INT 29
12210: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12211: LD_ADDR_OWVAR 29
12215: PUSH
12216: LD_INT 11
12218: PUSH
12219: LD_INT 11
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: ST_TO_ADDR
// Ronn = CreateHuman ;
12226: LD_ADDR_EXP 31
12230: PUSH
12231: CALL_OW 44
12235: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12236: LD_ADDR_EXP 33
12240: PUSH
12241: LD_EXP 33
12245: PUSH
12246: LD_EXP 31
12250: ADD
12251: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12252: LD_INT 2
12254: PPUSH
12255: LD_INT 3
12257: PPUSH
12258: LD_INT 6
12260: PPUSH
12261: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12265: LD_ADDR_OWVAR 26
12269: PUSH
12270: LD_STRING Mia D. Mathiasen
12272: ST_TO_ADDR
// hc_gallery = sandar ;
12273: LD_ADDR_OWVAR 33
12277: PUSH
12278: LD_STRING sandar
12280: ST_TO_ADDR
// hc_face_number = 31 ;
12281: LD_ADDR_OWVAR 34
12285: PUSH
12286: LD_INT 31
12288: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12289: LD_ADDR_OWVAR 29
12293: PUSH
12294: LD_INT 10
12296: PUSH
12297: LD_INT 10
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: ST_TO_ADDR
// Mia = CreateHuman ;
12304: LD_ADDR_EXP 32
12308: PUSH
12309: CALL_OW 44
12313: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12314: LD_ADDR_EXP 33
12318: PUSH
12319: LD_EXP 33
12323: PUSH
12324: LD_EXP 32
12328: ADD
12329: ST_TO_ADDR
// for i = 1 to 2 do
12330: LD_ADDR_VAR 0 4
12334: PUSH
12335: DOUBLE
12336: LD_INT 1
12338: DEC
12339: ST_TO_ADDR
12340: LD_INT 2
12342: PUSH
12343: FOR_TO
12344: IFFALSE 12385
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12346: LD_ADDR_VAR 0 3
12350: PUSH
12351: LD_VAR 0 3
12355: PUSH
12356: LD_INT 2
12358: PPUSH
12359: LD_INT 2
12361: PPUSH
12362: LD_INT 14
12364: PPUSH
12365: LD_INT 1
12367: PPUSH
12368: LD_INT 1
12370: PPUSH
12371: LD_INT 32
12373: PPUSH
12374: LD_INT 30
12376: PPUSH
12377: CALL 264 0 7
12381: ADD
12382: ST_TO_ADDR
12383: GO 12343
12385: POP
12386: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12387: LD_ADDR_VAR 0 3
12391: PUSH
12392: LD_VAR 0 3
12396: PUSH
12397: LD_INT 2
12399: PPUSH
12400: LD_INT 2
12402: PPUSH
12403: LD_INT 14
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: LD_INT 1
12411: PPUSH
12412: LD_INT 26
12414: PPUSH
12415: LD_INT 33
12417: PPUSH
12418: CALL 264 0 7
12422: ADD
12423: ST_TO_ADDR
// tmp := tmp diff 0 ;
12424: LD_ADDR_VAR 0 3
12428: PUSH
12429: LD_VAR 0 3
12433: PUSH
12434: LD_INT 0
12436: DIFF
12437: ST_TO_ADDR
// for i in ar_force do
12438: LD_ADDR_VAR 0 4
12442: PUSH
12443: LD_EXP 33
12447: PUSH
12448: FOR_IN
12449: IFFALSE 12592
// begin if GetClass ( i ) = 3 then
12451: LD_VAR 0 4
12455: PPUSH
12456: CALL_OW 257
12460: PUSH
12461: LD_INT 3
12463: EQUAL
12464: IFFALSE 12546
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12466: LD_VAR 0 3
12470: PUSH
12471: LD_INT 1
12473: ARRAY
12474: PPUSH
12475: LD_INT 1
12477: PPUSH
12478: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12482: LD_VAR 0 3
12486: PUSH
12487: LD_INT 1
12489: ARRAY
12490: PPUSH
12491: LD_VAR 0 5
12495: PPUSH
12496: LD_VAR 0 6
12500: PPUSH
12501: LD_INT 0
12503: PPUSH
12504: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12508: LD_VAR 0 4
12512: PPUSH
12513: LD_VAR 0 3
12517: PUSH
12518: LD_INT 1
12520: ARRAY
12521: PPUSH
12522: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12526: LD_ADDR_VAR 0 3
12530: PUSH
12531: LD_VAR 0 3
12535: PPUSH
12536: LD_INT 1
12538: PPUSH
12539: CALL_OW 3
12543: ST_TO_ADDR
// end else
12544: GO 12568
// PlaceUnitXY ( i , x , y , false ) ;
12546: LD_VAR 0 4
12550: PPUSH
12551: LD_VAR 0 5
12555: PPUSH
12556: LD_VAR 0 6
12560: PPUSH
12561: LD_INT 0
12563: PPUSH
12564: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12568: LD_VAR 0 4
12572: PPUSH
12573: LD_INT 86
12575: PPUSH
12576: LD_INT 121
12578: PPUSH
12579: CALL_OW 111
// wait ( 0 0$2 ) ;
12583: LD_INT 70
12585: PPUSH
12586: CALL_OW 67
// end ;
12590: GO 12448
12592: POP
12593: POP
// ar_force := ar_force ^ tmp ;
12594: LD_ADDR_EXP 33
12598: PUSH
12599: LD_EXP 33
12603: PUSH
12604: LD_VAR 0 3
12608: ADD
12609: ST_TO_ADDR
// ar_spawned := true ;
12610: LD_ADDR_EXP 11
12614: PUSH
12615: LD_INT 1
12617: ST_TO_ADDR
// end ; end_of_file
12618: LD_VAR 0 1
12622: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12623: LD_INT 0
12625: PPUSH
12626: PPUSH
12627: PPUSH
12628: PPUSH
12629: PPUSH
12630: PPUSH
12631: PPUSH
// InitHc ;
12632: CALL_OW 19
// uc_side := 3 ;
12636: LD_ADDR_OWVAR 20
12640: PUSH
12641: LD_INT 3
12643: ST_TO_ADDR
// uc_nation := 3 ;
12644: LD_ADDR_OWVAR 21
12648: PUSH
12649: LD_INT 3
12651: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12652: LD_ADDR_VAR 0 5
12656: PUSH
12657: LD_INT 5
12659: PUSH
12660: LD_INT 6
12662: PUSH
12663: LD_INT 7
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: LIST
12670: PUSH
12671: LD_OWVAR 67
12675: ARRAY
12676: ST_TO_ADDR
// ru_force := [ ] ;
12677: LD_ADDR_EXP 35
12681: PUSH
12682: EMPTY
12683: ST_TO_ADDR
// ru_rebuild := [ ] ;
12684: LD_ADDR_EXP 36
12688: PUSH
12689: EMPTY
12690: ST_TO_ADDR
// ru_produce_list := [ ] ;
12691: LD_ADDR_EXP 37
12695: PUSH
12696: EMPTY
12697: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12698: LD_ADDR_VAR 0 6
12702: PUSH
12703: LD_INT 22
12705: PUSH
12706: LD_INT 3
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: LD_INT 30
12715: PUSH
12716: LD_INT 8
12718: PUSH
12719: EMPTY
12720: LIST
12721: LIST
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PPUSH
12727: CALL_OW 69
12731: PUSH
12732: LD_INT 1
12734: ARRAY
12735: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12736: LD_ADDR_VAR 0 4
12740: PUSH
12741: LD_INT 43
12743: PUSH
12744: LD_INT 46
12746: PUSH
12747: LD_INT 45
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: LIST
12754: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12755: LD_ADDR_VAR 0 7
12759: PUSH
12760: LD_INT 22
12762: PUSH
12763: LD_INT 3
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 30
12772: PUSH
12773: LD_INT 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PPUSH
12784: CALL_OW 69
12788: PUSH
12789: LD_INT 1
12791: ARRAY
12792: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12793: LD_VAR 0 7
12797: PPUSH
12798: CALL_OW 274
12802: PPUSH
12803: LD_INT 1
12805: PPUSH
12806: LD_INT 5000
12808: PPUSH
12809: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12813: LD_VAR 0 7
12817: PPUSH
12818: CALL_OW 274
12822: PPUSH
12823: LD_INT 2
12825: PPUSH
12826: LD_INT 1000
12828: PPUSH
12829: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12833: LD_VAR 0 7
12837: PPUSH
12838: CALL_OW 274
12842: PPUSH
12843: LD_INT 3
12845: PPUSH
12846: LD_INT 30
12848: PPUSH
12849: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12853: LD_ADDR_VAR 0 2
12857: PUSH
12858: LD_INT 22
12860: PUSH
12861: LD_INT 3
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PUSH
12868: LD_INT 30
12870: PUSH
12871: LD_INT 33
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PPUSH
12882: CALL_OW 69
12886: PUSH
12887: FOR_IN
12888: IFFALSE 12920
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12890: LD_VAR 0 2
12894: PPUSH
12895: LD_VAR 0 4
12899: PUSH
12900: LD_VAR 0 2
12904: PUSH
12905: LD_INT 3
12907: MOD
12908: PUSH
12909: LD_INT 1
12911: PLUS
12912: ARRAY
12913: PPUSH
12914: CALL_OW 431
// end ;
12918: GO 12887
12920: POP
12921: POP
// for i = 1 to 4 do
12922: LD_ADDR_VAR 0 2
12926: PUSH
12927: DOUBLE
12928: LD_INT 1
12930: DEC
12931: ST_TO_ADDR
12932: LD_INT 4
12934: PUSH
12935: FOR_TO
12936: IFFALSE 12997
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12938: LD_INT 0
12940: PPUSH
12941: LD_INT 9
12943: PPUSH
12944: LD_VAR 0 5
12948: PPUSH
12949: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12953: CALL_OW 44
12957: PPUSH
12958: LD_INT 22
12960: PUSH
12961: LD_INT 3
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 30
12970: PUSH
12971: LD_INT 5
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PPUSH
12982: CALL_OW 69
12986: PUSH
12987: LD_INT 1
12989: ARRAY
12990: PPUSH
12991: CALL_OW 52
// end ;
12995: GO 12935
12997: POP
12998: POP
// for i = 1 to 5 do
12999: LD_ADDR_VAR 0 2
13003: PUSH
13004: DOUBLE
13005: LD_INT 1
13007: DEC
13008: ST_TO_ADDR
13009: LD_INT 5
13011: PUSH
13012: FOR_TO
13013: IFFALSE 13074
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13015: LD_INT 0
13017: PPUSH
13018: LD_INT 3
13020: PPUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13030: CALL_OW 44
13034: PPUSH
13035: LD_INT 22
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PUSH
13045: LD_INT 30
13047: PUSH
13048: LD_INT 3
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PUSH
13055: EMPTY
13056: LIST
13057: LIST
13058: PPUSH
13059: CALL_OW 69
13063: PUSH
13064: LD_INT 1
13066: ARRAY
13067: PPUSH
13068: CALL_OW 52
// end ;
13072: GO 13012
13074: POP
13075: POP
// for i = 1 to 4 do
13076: LD_ADDR_VAR 0 2
13080: PUSH
13081: DOUBLE
13082: LD_INT 1
13084: DEC
13085: ST_TO_ADDR
13086: LD_INT 4
13088: PUSH
13089: FOR_TO
13090: IFFALSE 13151
// begin PrepareHuman ( false , class_engineer , skill ) ;
13092: LD_INT 0
13094: PPUSH
13095: LD_INT 2
13097: PPUSH
13098: LD_VAR 0 5
13102: PPUSH
13103: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13107: CALL_OW 44
13111: PPUSH
13112: LD_INT 22
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: PUSH
13122: LD_INT 30
13124: PUSH
13125: LD_INT 1
13127: PUSH
13128: EMPTY
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: PPUSH
13136: CALL_OW 69
13140: PUSH
13141: LD_INT 1
13143: ARRAY
13144: PPUSH
13145: CALL_OW 52
// end ;
13149: GO 13089
13151: POP
13152: POP
// for i = 1 to 3 do
13153: LD_ADDR_VAR 0 2
13157: PUSH
13158: DOUBLE
13159: LD_INT 1
13161: DEC
13162: ST_TO_ADDR
13163: LD_INT 3
13165: PUSH
13166: FOR_TO
13167: IFFALSE 13200
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13169: LD_INT 0
13171: PPUSH
13172: LD_INT 4
13174: PPUSH
13175: LD_VAR 0 5
13179: PPUSH
13180: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13184: CALL_OW 44
13188: PPUSH
13189: LD_VAR 0 6
13193: PPUSH
13194: CALL_OW 52
// end ;
13198: GO 13166
13200: POP
13201: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13202: LD_ADDR_EXP 34
13206: PUSH
13207: LD_STRING Yakotich
13209: PPUSH
13210: LD_EXP 2
13214: NOT
13215: PPUSH
13216: LD_STRING 
13218: PPUSH
13219: CALL 201 0 3
13223: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13224: LD_EXP 34
13228: PPUSH
13229: LD_INT 74
13231: PPUSH
13232: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13236: LD_VAR 0 6
13240: PPUSH
13241: LD_INT 49
13243: PPUSH
13244: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13248: LD_VAR 0 6
13252: PPUSH
13253: LD_INT 50
13255: PPUSH
13256: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13260: LD_VAR 0 6
13264: PPUSH
13265: LD_INT 51
13267: PPUSH
13268: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13272: LD_VAR 0 6
13276: PPUSH
13277: LD_INT 52
13279: PPUSH
13280: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13284: LD_VAR 0 6
13288: PPUSH
13289: LD_INT 69
13291: PPUSH
13292: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13296: LD_VAR 0 6
13300: PPUSH
13301: LD_INT 39
13303: PPUSH
13304: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13308: LD_VAR 0 6
13312: PPUSH
13313: LD_INT 34
13315: PPUSH
13316: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13320: LD_VAR 0 6
13324: PPUSH
13325: LD_INT 40
13327: PPUSH
13328: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13332: LD_VAR 0 6
13336: PPUSH
13337: LD_INT 57
13339: PPUSH
13340: CALL_OW 184
// if Difficulty > 1 then
13344: LD_OWVAR 67
13348: PUSH
13349: LD_INT 1
13351: GREATER
13352: IFFALSE 13366
// AddComResearch ( lab , tech_comp2 ) ;
13354: LD_VAR 0 6
13358: PPUSH
13359: LD_INT 58
13361: PPUSH
13362: CALL_OW 184
// end ;
13366: LD_VAR 0 1
13370: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13371: LD_INT 7
13373: PPUSH
13374: CALL_OW 353
13378: PUSH
13379: LD_INT 3
13381: GREATER
13382: PUSH
13383: LD_INT 22
13385: PUSH
13386: LD_INT 3
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: PUSH
13393: LD_INT 34
13395: PUSH
13396: LD_INT 53
13398: PUSH
13399: EMPTY
13400: LIST
13401: LIST
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PPUSH
13407: CALL_OW 69
13411: NOT
13412: AND
13413: IFFALSE 13448
13415: GO 13417
13417: DISABLE
// begin enable ;
13418: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13419: LD_ADDR_EXP 37
13423: PUSH
13424: LD_EXP 37
13428: PUSH
13429: LD_INT 24
13431: PUSH
13432: LD_INT 1
13434: PUSH
13435: LD_INT 3
13437: PUSH
13438: LD_INT 53
13440: PUSH
13441: EMPTY
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: ADD
13447: ST_TO_ADDR
// end ;
13448: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13449: LD_INT 22
13451: PUSH
13452: LD_INT 3
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PUSH
13459: LD_INT 21
13461: PUSH
13462: LD_INT 3
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: PPUSH
13473: CALL_OW 69
13477: IFFALSE 14255
13479: GO 13481
13481: DISABLE
13482: LD_INT 0
13484: PPUSH
13485: PPUSH
13486: PPUSH
13487: PPUSH
13488: PPUSH
13489: PPUSH
13490: PPUSH
13491: PPUSH
// begin enable ;
13492: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13493: LD_ADDR_VAR 0 3
13497: PUSH
13498: LD_INT 22
13500: PUSH
13501: LD_INT 3
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PUSH
13508: LD_INT 21
13510: PUSH
13511: LD_INT 3
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: PUSH
13518: LD_INT 3
13520: PUSH
13521: LD_INT 24
13523: PUSH
13524: LD_INT 1000
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: LIST
13539: PPUSH
13540: CALL_OW 69
13544: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13545: LD_ADDR_VAR 0 4
13549: PUSH
13550: LD_INT 22
13552: PUSH
13553: LD_INT 3
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PUSH
13560: LD_INT 25
13562: PUSH
13563: LD_INT 2
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: PPUSH
13574: CALL_OW 69
13578: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13579: LD_ADDR_VAR 0 5
13583: PUSH
13584: LD_INT 22
13586: PUSH
13587: LD_INT 3
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: PUSH
13594: LD_INT 30
13596: PUSH
13597: LD_INT 1
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PPUSH
13608: CALL_OW 69
13612: PUSH
13613: LD_INT 1
13615: ARRAY
13616: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13617: LD_ADDR_VAR 0 8
13621: PUSH
13622: LD_INT 22
13624: PUSH
13625: LD_INT 3
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: PUSH
13632: LD_INT 2
13634: PUSH
13635: LD_INT 30
13637: PUSH
13638: LD_INT 6
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 30
13647: PUSH
13648: LD_INT 7
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: PUSH
13655: LD_INT 30
13657: PUSH
13658: LD_INT 8
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: PUSH
13671: EMPTY
13672: LIST
13673: LIST
13674: PPUSH
13675: CALL_OW 69
13679: PUSH
13680: LD_INT 1
13682: ARRAY
13683: ST_TO_ADDR
// if not engs then
13684: LD_VAR 0 4
13688: NOT
13689: IFFALSE 13693
// exit ;
13691: GO 14255
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13693: LD_ADDR_VAR 0 6
13697: PUSH
13698: LD_VAR 0 4
13702: PPUSH
13703: LD_INT 3
13705: PUSH
13706: LD_INT 24
13708: PUSH
13709: LD_INT 600
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PPUSH
13720: CALL_OW 72
13724: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13725: LD_ADDR_VAR 0 7
13729: PUSH
13730: LD_INT 22
13732: PUSH
13733: LD_INT 3
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: PUSH
13740: LD_INT 25
13742: PUSH
13743: LD_INT 4
13745: PUSH
13746: EMPTY
13747: LIST
13748: LIST
13749: PUSH
13750: EMPTY
13751: LIST
13752: LIST
13753: PPUSH
13754: CALL_OW 69
13758: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13759: LD_VAR 0 3
13763: NOT
13764: PUSH
13765: LD_EXP 36
13769: NOT
13770: AND
13771: IFFALSE 13831
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13773: LD_VAR 0 4
13777: PPUSH
13778: LD_INT 3
13780: PUSH
13781: LD_INT 54
13783: PUSH
13784: EMPTY
13785: LIST
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 72
13795: IFFALSE 13829
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13797: LD_VAR 0 4
13801: PPUSH
13802: LD_INT 3
13804: PUSH
13805: LD_INT 54
13807: PUSH
13808: EMPTY
13809: LIST
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PPUSH
13815: CALL_OW 72
13819: PPUSH
13820: LD_VAR 0 5
13824: PPUSH
13825: CALL_OW 120
// exit ;
13829: GO 14255
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13831: LD_VAR 0 4
13835: PPUSH
13836: LD_INT 54
13838: PUSH
13839: EMPTY
13840: LIST
13841: PPUSH
13842: CALL_OW 72
13846: IFFALSE 13868
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13848: LD_VAR 0 4
13852: PPUSH
13853: LD_INT 54
13855: PUSH
13856: EMPTY
13857: LIST
13858: PPUSH
13859: CALL_OW 72
13863: PPUSH
13864: CALL_OW 122
// if not tmp then
13868: LD_VAR 0 3
13872: NOT
13873: IFFALSE 14005
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13875: LD_INT 81
13877: PUSH
13878: LD_INT 3
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: PUSH
13885: LD_INT 92
13887: PUSH
13888: LD_INT 147
13890: PUSH
13891: LD_INT 212
13893: PUSH
13894: LD_INT 30
13896: PUSH
13897: EMPTY
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PPUSH
13907: CALL_OW 69
13911: NOT
13912: IFFALSE 14005
// begin if not HasTask ( engs [ 1 ] ) then
13914: LD_VAR 0 4
13918: PUSH
13919: LD_INT 1
13921: ARRAY
13922: PPUSH
13923: CALL_OW 314
13927: NOT
13928: IFFALSE 14005
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13930: LD_ADDR_VAR 0 2
13934: PUSH
13935: LD_VAR 0 4
13939: PPUSH
13940: LD_EXP 36
13944: PUSH
13945: LD_INT 1
13947: ARRAY
13948: PPUSH
13949: LD_EXP 36
13953: PUSH
13954: LD_INT 2
13956: ARRAY
13957: PPUSH
13958: LD_EXP 36
13962: PUSH
13963: LD_INT 3
13965: ARRAY
13966: PPUSH
13967: LD_EXP 36
13971: PUSH
13972: LD_INT 4
13974: ARRAY
13975: PPUSH
13976: CALL_OW 145
13980: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13981: LD_VAR 0 2
13985: PPUSH
13986: CALL_OW 266
13990: PUSH
13991: LD_INT 4
13993: EQUAL
13994: IFFALSE 14005
// AddComUpgrade ( i ) ;
13996: LD_VAR 0 2
14000: PPUSH
14001: CALL_OW 206
// end ; end ; end ; for i in engs do
14005: LD_ADDR_VAR 0 2
14009: PUSH
14010: LD_VAR 0 4
14014: PUSH
14015: FOR_IN
14016: IFFALSE 14134
// begin if i in to_heal and sci then
14018: LD_VAR 0 2
14022: PUSH
14023: LD_VAR 0 6
14027: IN
14028: PUSH
14029: LD_VAR 0 7
14033: AND
14034: IFFALSE 14085
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14036: LD_VAR 0 2
14040: PPUSH
14041: LD_INT 149
14043: PPUSH
14044: LD_INT 220
14046: PPUSH
14047: CALL_OW 297
14051: PUSH
14052: LD_INT 5
14054: LESS
14055: IFFALSE 14059
// continue ;
14057: GO 14015
// ComMoveXY ( i , 149 , 220 ) ;
14059: LD_VAR 0 2
14063: PPUSH
14064: LD_INT 149
14066: PPUSH
14067: LD_INT 220
14069: PPUSH
14070: CALL_OW 111
// AddComHold ( i ) ;
14074: LD_VAR 0 2
14078: PPUSH
14079: CALL_OW 200
// end else
14083: GO 14132
// if not HasTask ( i ) or WantsToAttack ( i ) then
14085: LD_VAR 0 2
14089: PPUSH
14090: CALL_OW 314
14094: NOT
14095: PUSH
14096: LD_VAR 0 2
14100: PPUSH
14101: CALL_OW 319
14105: OR
14106: IFFALSE 14132
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14108: LD_VAR 0 2
14112: PPUSH
14113: LD_VAR 0 3
14117: PPUSH
14118: LD_VAR 0 2
14122: PPUSH
14123: CALL_OW 74
14127: PPUSH
14128: CALL_OW 130
// end ;
14132: GO 14015
14134: POP
14135: POP
// if to_heal and sci then
14136: LD_VAR 0 6
14140: PUSH
14141: LD_VAR 0 7
14145: AND
14146: IFFALSE 14207
// begin if UnitFilter ( sci , [ f_inside ] ) then
14148: LD_VAR 0 7
14152: PPUSH
14153: LD_INT 54
14155: PUSH
14156: EMPTY
14157: LIST
14158: PPUSH
14159: CALL_OW 72
14163: IFFALSE 14187
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14165: LD_VAR 0 7
14169: PPUSH
14170: LD_INT 54
14172: PUSH
14173: EMPTY
14174: LIST
14175: PPUSH
14176: CALL_OW 72
14180: PPUSH
14181: CALL_OW 122
14185: GO 14205
// ComHeal ( sci , to_heal [ 1 ] ) ;
14187: LD_VAR 0 7
14191: PPUSH
14192: LD_VAR 0 6
14196: PUSH
14197: LD_INT 1
14199: ARRAY
14200: PPUSH
14201: CALL_OW 128
// end else
14205: GO 14255
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14207: LD_VAR 0 7
14211: PPUSH
14212: LD_INT 56
14214: PUSH
14215: EMPTY
14216: LIST
14217: PPUSH
14218: CALL_OW 72
14222: PUSH
14223: LD_VAR 0 8
14227: AND
14228: IFFALSE 14255
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14230: LD_VAR 0 7
14234: PPUSH
14235: LD_INT 56
14237: PUSH
14238: EMPTY
14239: LIST
14240: PPUSH
14241: CALL_OW 72
14245: PPUSH
14246: LD_VAR 0 8
14250: PPUSH
14251: CALL_OW 120
// end ;
14255: PPOPN 8
14257: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14258: LD_INT 22
14260: PUSH
14261: LD_INT 3
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_INT 30
14270: PUSH
14271: LD_INT 3
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PPUSH
14282: CALL_OW 69
14286: PUSH
14287: LD_EXP 37
14291: AND
14292: IFFALSE 14418
14294: GO 14296
14296: DISABLE
14297: LD_INT 0
14299: PPUSH
14300: PPUSH
14301: PPUSH
// begin enable ;
14302: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14303: LD_ADDR_VAR 0 3
14307: PUSH
14308: LD_INT 22
14310: PUSH
14311: LD_INT 3
14313: PUSH
14314: EMPTY
14315: LIST
14316: LIST
14317: PUSH
14318: LD_INT 30
14320: PUSH
14321: LD_INT 3
14323: PUSH
14324: EMPTY
14325: LIST
14326: LIST
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: PPUSH
14332: CALL_OW 69
14336: PUSH
14337: LD_INT 1
14339: ARRAY
14340: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14341: LD_VAR 0 3
14345: PPUSH
14346: CALL_OW 313
14350: PUSH
14351: LD_INT 0
14353: EQUAL
14354: IFFALSE 14358
// exit ;
14356: GO 14418
// if BuildingStatus ( fac ) = bs_idle then
14358: LD_VAR 0 3
14362: PPUSH
14363: CALL_OW 461
14367: PUSH
14368: LD_INT 2
14370: EQUAL
14371: IFFALSE 14418
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14373: LD_VAR 0 3
14377: PPUSH
14378: LD_EXP 37
14382: PUSH
14383: LD_INT 1
14385: ARRAY
14386: PPUSH
14387: LD_EXP 37
14391: PUSH
14392: LD_INT 2
14394: ARRAY
14395: PPUSH
14396: LD_EXP 37
14400: PUSH
14401: LD_INT 3
14403: ARRAY
14404: PPUSH
14405: LD_EXP 37
14409: PUSH
14410: LD_INT 4
14412: ARRAY
14413: PPUSH
14414: CALL_OW 125
// end ;
14418: PPOPN 3
14420: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14421: LD_INT 0
14423: PPUSH
14424: PPUSH
14425: PPUSH
14426: PPUSH
14427: PPUSH
// uc_side := 3 ;
14428: LD_ADDR_OWVAR 20
14432: PUSH
14433: LD_INT 3
14435: ST_TO_ADDR
// uc_nation := 3 ;
14436: LD_ADDR_OWVAR 21
14440: PUSH
14441: LD_INT 3
14443: ST_TO_ADDR
// ru_can_attack := false ;
14444: LD_ADDR_EXP 8
14448: PUSH
14449: LD_INT 0
14451: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14452: LD_ADDR_VAR 0 6
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 3
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PUSH
14467: LD_INT 30
14469: PUSH
14470: LD_INT 3
14472: PUSH
14473: EMPTY
14474: LIST
14475: LIST
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PPUSH
14481: CALL_OW 69
14485: ST_TO_ADDR
// if fac then
14486: LD_VAR 0 6
14490: IFFALSE 14642
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14492: LD_ADDR_EXP 37
14496: PUSH
14497: LD_INT 24
14499: PUSH
14500: LD_INT 1
14502: PUSH
14503: LD_INT 3
14505: PUSH
14506: LD_INT 43
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: ST_TO_ADDR
// if wave > 1 then
14515: LD_VAR 0 1
14519: PUSH
14520: LD_INT 1
14522: GREATER
14523: IFFALSE 14576
// for i = 1 to Difficulty do
14525: LD_ADDR_VAR 0 3
14529: PUSH
14530: DOUBLE
14531: LD_INT 1
14533: DEC
14534: ST_TO_ADDR
14535: LD_OWVAR 67
14539: PUSH
14540: FOR_TO
14541: IFFALSE 14574
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14543: LD_ADDR_EXP 37
14547: PUSH
14548: LD_EXP 37
14552: PUSH
14553: LD_INT 24
14555: PUSH
14556: LD_INT 1
14558: PUSH
14559: LD_INT 3
14561: PUSH
14562: LD_INT 45
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: ADD
14571: ST_TO_ADDR
14572: GO 14540
14574: POP
14575: POP
// repeat wait ( 0 0$1 ) ;
14576: LD_INT 35
14578: PPUSH
14579: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14583: LD_EXP 37
14587: PUSH
14588: LD_INT 4
14590: LESS
14591: PUSH
14592: LD_VAR 0 6
14596: PUSH
14597: LD_INT 1
14599: ARRAY
14600: PPUSH
14601: CALL_OW 313
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: OR
14610: PUSH
14611: LD_VAR 0 6
14615: PUSH
14616: LD_INT 1
14618: ARRAY
14619: PPUSH
14620: CALL_OW 461
14624: PUSH
14625: LD_INT 8
14627: PUSH
14628: LD_INT 6
14630: PUSH
14631: LD_INT 7
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: LIST
14638: IN
14639: OR
14640: IFFALSE 14576
// end ; case wave of 1 :
14642: LD_VAR 0 1
14646: PUSH
14647: LD_INT 1
14649: DOUBLE
14650: EQUAL
14651: IFTRUE 14655
14653: GO 14740
14655: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14656: LD_ADDR_VAR 0 3
14660: PUSH
14661: DOUBLE
14662: LD_INT 1
14664: DEC
14665: ST_TO_ADDR
14666: LD_INT 4
14668: PUSH
14669: LD_INT 5
14671: PUSH
14672: LD_INT 6
14674: PUSH
14675: EMPTY
14676: LIST
14677: LIST
14678: LIST
14679: PUSH
14680: LD_OWVAR 67
14684: ARRAY
14685: PUSH
14686: FOR_TO
14687: IFFALSE 14695
// Sold ;
14689: CALL 14966 0 0
14693: GO 14686
14695: POP
14696: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14697: LD_ADDR_VAR 0 3
14701: PUSH
14702: DOUBLE
14703: LD_INT 1
14705: DEC
14706: ST_TO_ADDR
14707: LD_INT 2
14709: PUSH
14710: LD_INT 3
14712: PUSH
14713: LD_INT 3
14715: PUSH
14716: EMPTY
14717: LIST
14718: LIST
14719: LIST
14720: PUSH
14721: LD_OWVAR 67
14725: ARRAY
14726: PUSH
14727: FOR_TO
14728: IFFALSE 14736
// Tank ;
14730: CALL 15096 0 0
14734: GO 14727
14736: POP
14737: POP
// end ; 2 .. 9 :
14738: GO 14953
14740: LD_INT 2
14742: DOUBLE
14743: GREATEREQUAL
14744: IFFALSE 14752
14746: LD_INT 9
14748: DOUBLE
14749: LESSEQUAL
14750: IFTRUE 14754
14752: GO 14859
14754: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14755: LD_ADDR_VAR 0 3
14759: PUSH
14760: DOUBLE
14761: LD_INT 1
14763: DEC
14764: ST_TO_ADDR
14765: LD_INT 4
14767: PUSH
14768: LD_INT 5
14770: PUSH
14771: LD_INT 6
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: LIST
14778: PUSH
14779: LD_OWVAR 67
14783: ARRAY
14784: PUSH
14785: LD_VAR 0 1
14789: PUSH
14790: LD_INT 2
14792: DIV
14793: PLUS
14794: PUSH
14795: FOR_TO
14796: IFFALSE 14804
// Sold ;
14798: CALL 14966 0 0
14802: GO 14795
14804: POP
14805: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14806: LD_ADDR_VAR 0 3
14810: PUSH
14811: DOUBLE
14812: LD_INT 1
14814: DEC
14815: ST_TO_ADDR
14816: LD_INT 3
14818: PUSH
14819: LD_INT 4
14821: PUSH
14822: LD_INT 4
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: PUSH
14830: LD_OWVAR 67
14834: ARRAY
14835: PUSH
14836: LD_VAR 0 1
14840: PUSH
14841: LD_INT 2
14843: DIV
14844: PLUS
14845: PUSH
14846: FOR_TO
14847: IFFALSE 14855
// Tank ;
14849: CALL 15096 0 0
14853: GO 14846
14855: POP
14856: POP
// end ; 10 :
14857: GO 14953
14859: LD_INT 10
14861: DOUBLE
14862: EQUAL
14863: IFTRUE 14867
14865: GO 14952
14867: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14868: LD_ADDR_VAR 0 3
14872: PUSH
14873: DOUBLE
14874: LD_INT 1
14876: DEC
14877: ST_TO_ADDR
14878: LD_INT 10
14880: PUSH
14881: LD_INT 12
14883: PUSH
14884: LD_INT 14
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: LIST
14891: PUSH
14892: LD_OWVAR 67
14896: ARRAY
14897: PUSH
14898: FOR_TO
14899: IFFALSE 14907
// Sold ;
14901: CALL 14966 0 0
14905: GO 14898
14907: POP
14908: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: DOUBLE
14915: LD_INT 1
14917: DEC
14918: ST_TO_ADDR
14919: LD_INT 11
14921: PUSH
14922: LD_INT 13
14924: PUSH
14925: LD_INT 15
14927: PUSH
14928: EMPTY
14929: LIST
14930: LIST
14931: LIST
14932: PUSH
14933: LD_OWVAR 67
14937: ARRAY
14938: PUSH
14939: FOR_TO
14940: IFFALSE 14948
// Tank ;
14942: CALL 15096 0 0
14946: GO 14939
14948: POP
14949: POP
// end ; end ;
14950: GO 14953
14952: POP
// ru_can_attack := true ;
14953: LD_ADDR_EXP 8
14957: PUSH
14958: LD_INT 1
14960: ST_TO_ADDR
// end ;
14961: LD_VAR 0 2
14965: RET
// function Sold ( ) ; var un , skill ; begin
14966: LD_INT 0
14968: PPUSH
14969: PPUSH
14970: PPUSH
// uc_side := 3 ;
14971: LD_ADDR_OWVAR 20
14975: PUSH
14976: LD_INT 3
14978: ST_TO_ADDR
// uc_nation := 3 ;
14979: LD_ADDR_OWVAR 21
14983: PUSH
14984: LD_INT 3
14986: ST_TO_ADDR
// InitHc ;
14987: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14991: LD_ADDR_VAR 0 3
14995: PUSH
14996: LD_INT 6
14998: PUSH
14999: LD_INT 7
15001: PUSH
15002: LD_INT 7
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: PUSH
15010: LD_OWVAR 67
15014: ARRAY
15015: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15016: LD_INT 0
15018: PPUSH
15019: LD_INT 1
15021: PUSH
15022: LD_INT 9
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PUSH
15029: LD_INT 1
15031: PPUSH
15032: LD_INT 2
15034: PPUSH
15035: CALL_OW 12
15039: ARRAY
15040: PPUSH
15041: LD_VAR 0 3
15045: PPUSH
15046: CALL_OW 380
// un := CreateHuman ;
15050: LD_ADDR_VAR 0 2
15054: PUSH
15055: CALL_OW 44
15059: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15060: LD_VAR 0 2
15064: PPUSH
15065: LD_INT 4
15067: PPUSH
15068: LD_INT 0
15070: PPUSH
15071: CALL_OW 49
// ru_force := ru_force ^ un ;
15075: LD_ADDR_EXP 35
15079: PUSH
15080: LD_EXP 35
15084: PUSH
15085: LD_VAR 0 2
15089: ADD
15090: ST_TO_ADDR
// end ;
15091: LD_VAR 0 1
15095: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15096: LD_INT 0
15098: PPUSH
15099: PPUSH
15100: PPUSH
15101: PPUSH
15102: PPUSH
// uc_side := 3 ;
15103: LD_ADDR_OWVAR 20
15107: PUSH
15108: LD_INT 3
15110: ST_TO_ADDR
// uc_nation := 3 ;
15111: LD_ADDR_OWVAR 21
15115: PUSH
15116: LD_INT 3
15118: ST_TO_ADDR
// InitHc ;
15119: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15123: LD_ADDR_VAR 0 5
15127: PUSH
15128: LD_INT 5
15130: PUSH
15131: LD_INT 6
15133: PUSH
15134: LD_INT 7
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: LIST
15141: PUSH
15142: LD_OWVAR 67
15146: ARRAY
15147: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15148: LD_ADDR_VAR 0 3
15152: PUSH
15153: LD_INT 22
15155: PUSH
15156: LD_INT 24
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: PUSH
15163: LD_INT 1
15165: PPUSH
15166: LD_INT 2
15168: PPUSH
15169: CALL_OW 12
15173: ARRAY
15174: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15175: LD_VAR 0 3
15179: PUSH
15180: LD_INT 22
15182: EQUAL
15183: IFFALSE 15218
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15185: LD_ADDR_VAR 0 4
15189: PUSH
15190: LD_INT 45
15192: PUSH
15193: LD_INT 43
15195: PUSH
15196: LD_INT 44
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: LIST
15203: PUSH
15204: LD_INT 1
15206: PPUSH
15207: LD_INT 3
15209: PPUSH
15210: CALL_OW 12
15214: ARRAY
15215: ST_TO_ADDR
15216: GO 15249
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15218: LD_ADDR_VAR 0 4
15222: PUSH
15223: LD_INT 46
15225: PUSH
15226: LD_INT 44
15228: PUSH
15229: LD_INT 45
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: LIST
15236: PUSH
15237: LD_INT 1
15239: PPUSH
15240: LD_INT 3
15242: PPUSH
15243: CALL_OW 12
15247: ARRAY
15248: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15249: LD_ADDR_VAR 0 2
15253: PUSH
15254: LD_INT 3
15256: PPUSH
15257: LD_INT 3
15259: PPUSH
15260: LD_VAR 0 3
15264: PPUSH
15265: LD_INT 1
15267: PPUSH
15268: LD_INT 3
15270: PUSH
15271: LD_INT 3
15273: PUSH
15274: LD_INT 3
15276: PUSH
15277: LD_INT 1
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 1
15288: PPUSH
15289: LD_INT 4
15291: PPUSH
15292: CALL_OW 12
15296: ARRAY
15297: PPUSH
15298: LD_VAR 0 4
15302: PPUSH
15303: LD_INT 99
15305: PPUSH
15306: CALL 264 0 7
15310: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15311: LD_VAR 0 2
15315: PPUSH
15316: CALL_OW 263
15320: PUSH
15321: LD_INT 1
15323: EQUAL
15324: IFFALSE 15355
// begin PrepareHuman ( false , 3 , skill ) ;
15326: LD_INT 0
15328: PPUSH
15329: LD_INT 3
15331: PPUSH
15332: LD_VAR 0 5
15336: PPUSH
15337: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15341: CALL_OW 44
15345: PPUSH
15346: LD_VAR 0 2
15350: PPUSH
15351: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15355: LD_VAR 0 2
15359: PPUSH
15360: LD_INT 3
15362: PPUSH
15363: LD_INT 0
15365: PPUSH
15366: CALL_OW 49
// ru_force := ru_force ^ un ;
15370: LD_ADDR_EXP 35
15374: PUSH
15375: LD_EXP 35
15379: PUSH
15380: LD_VAR 0 2
15384: ADD
15385: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15386: LD_VAR 0 2
15390: PPUSH
15391: LD_INT 126
15393: PPUSH
15394: LD_INT 158
15396: PPUSH
15397: CALL_OW 111
// Wait ( 0 0$3 ) ;
15401: LD_INT 105
15403: PPUSH
15404: CALL_OW 67
// ComStop ( un ) ;
15408: LD_VAR 0 2
15412: PPUSH
15413: CALL_OW 141
// end ;
15417: LD_VAR 0 1
15421: RET
// every 0 0$1 do var i , time , wave ;
15422: GO 15424
15424: DISABLE
15425: LD_INT 0
15427: PPUSH
15428: PPUSH
15429: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15430: LD_ADDR_VAR 0 2
15434: PUSH
15435: LD_INT 25200
15437: PUSH
15438: LD_INT 24150
15440: PUSH
15441: LD_INT 23100
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: LIST
15448: PUSH
15449: LD_OWVAR 67
15453: ARRAY
15454: ST_TO_ADDR
// wait ( time ) ;
15455: LD_VAR 0 2
15459: PPUSH
15460: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15464: LD_ADDR_VAR 0 2
15468: PUSH
15469: LD_INT 15750
15471: PUSH
15472: LD_INT 15050
15474: PUSH
15475: LD_INT 14350
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: LIST
15482: PUSH
15483: LD_OWVAR 67
15487: ARRAY
15488: ST_TO_ADDR
// wave := 0 ;
15489: LD_ADDR_VAR 0 3
15493: PUSH
15494: LD_INT 0
15496: ST_TO_ADDR
// while true do
15497: LD_INT 1
15499: IFFALSE 15596
// begin wave := wave + 1 ;
15501: LD_ADDR_VAR 0 3
15505: PUSH
15506: LD_VAR 0 3
15510: PUSH
15511: LD_INT 1
15513: PLUS
15514: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15515: LD_INT 22
15517: PUSH
15518: LD_INT 2
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: PPUSH
15525: CALL_OW 69
15529: IFFALSE 15558
// repeat wait ( 0 0$1 ) ;
15531: LD_INT 35
15533: PPUSH
15534: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15538: LD_INT 22
15540: PUSH
15541: LD_INT 2
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PPUSH
15548: CALL_OW 69
15552: PUSH
15553: LD_INT 0
15555: EQUAL
15556: IFFALSE 15531
// if ru_force < 20 then
15558: LD_EXP 35
15562: PUSH
15563: LD_INT 20
15565: LESS
15566: IFFALSE 15577
// PrepareAttack ( wave ) ;
15568: LD_VAR 0 3
15572: PPUSH
15573: CALL 14421 0 1
// ru_can_attack := true ;
15577: LD_ADDR_EXP 8
15581: PUSH
15582: LD_INT 1
15584: ST_TO_ADDR
// wait ( time ) ;
15585: LD_VAR 0 2
15589: PPUSH
15590: CALL_OW 67
// end ;
15594: GO 15497
// end ;
15596: PPOPN 3
15598: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15599: LD_EXP 8
15603: PUSH
15604: LD_EXP 35
15608: AND
15609: IFFALSE 16443
15611: GO 15613
15613: DISABLE
15614: LD_INT 0
15616: PPUSH
15617: PPUSH
15618: PPUSH
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
15623: PPUSH
15624: PPUSH
// begin enable ;
15625: ENABLE
// points1 := [ 107 , 123 ] ;
15626: LD_ADDR_VAR 0 4
15630: PUSH
15631: LD_INT 107
15633: PUSH
15634: LD_INT 123
15636: PUSH
15637: EMPTY
15638: LIST
15639: LIST
15640: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15641: LD_ADDR_VAR 0 5
15645: PUSH
15646: LD_INT 55
15648: PUSH
15649: LD_INT 42
15651: PUSH
15652: EMPTY
15653: LIST
15654: LIST
15655: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15656: LD_ADDR_VAR 0 6
15660: PUSH
15661: LD_INT 102
15663: PUSH
15664: LD_INT 140
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: LD_INT 105
15673: PUSH
15674: LD_INT 142
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: PUSH
15681: LD_INT 129
15683: PUSH
15684: LD_INT 131
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PUSH
15691: EMPTY
15692: LIST
15693: LIST
15694: LIST
15695: ST_TO_ADDR
// for i in ru_force do
15696: LD_ADDR_VAR 0 1
15700: PUSH
15701: LD_EXP 35
15705: PUSH
15706: FOR_IN
15707: IFFALSE 16441
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15709: LD_ADDR_VAR 0 3
15713: PUSH
15714: LD_INT 81
15716: PUSH
15717: LD_INT 3
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PPUSH
15724: CALL_OW 69
15728: PPUSH
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 74
15738: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_VAR 0 3
15748: PPUSH
15749: CALL_OW 296
15753: PUSH
15754: LD_INT 12
15756: LESS
15757: IFFALSE 15902
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15759: LD_VAR 0 1
15763: PPUSH
15764: CALL_OW 247
15768: PUSH
15769: LD_INT 1
15771: EQUAL
15772: PUSH
15773: LD_VAR 0 1
15777: PPUSH
15778: CALL_OW 257
15782: PUSH
15783: LD_INT 1
15785: EQUAL
15786: AND
15787: PUSH
15788: LD_VAR 0 3
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 2
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 58
15805: PUSH
15806: EMPTY
15807: LIST
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PPUSH
15813: CALL_OW 69
15817: IN
15818: AND
15819: IFFALSE 15837
// ComEnterUnit ( i , un ) else
15821: LD_VAR 0 1
15825: PPUSH
15826: LD_VAR 0 3
15830: PPUSH
15831: CALL_OW 120
15835: GO 15900
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15837: LD_VAR 0 3
15841: PUSH
15842: LD_INT 21
15844: PUSH
15845: LD_INT 2
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: LD_INT 58
15854: PUSH
15855: EMPTY
15856: LIST
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 69
15866: IN
15867: NOT
15868: IFFALSE 15886
// ComAttackUnit ( i , un ) else
15870: LD_VAR 0 1
15874: PPUSH
15875: LD_VAR 0 3
15879: PPUSH
15880: CALL_OW 115
15884: GO 15900
// ComAttackUnit ( i , JMM ) ;
15886: LD_VAR 0 1
15890: PPUSH
15891: LD_EXP 18
15895: PPUSH
15896: CALL_OW 115
// end else
15900: GO 16439
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15902: LD_VAR 0 1
15906: PPUSH
15907: LD_VAR 0 4
15911: PUSH
15912: LD_INT 1
15914: ARRAY
15915: PPUSH
15916: LD_VAR 0 4
15920: PUSH
15921: LD_INT 2
15923: ARRAY
15924: PPUSH
15925: CALL_OW 297
15929: PUSH
15930: LD_VAR 0 1
15934: PPUSH
15935: LD_VAR 0 5
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PPUSH
15944: LD_VAR 0 5
15948: PUSH
15949: LD_INT 2
15951: ARRAY
15952: PPUSH
15953: CALL_OW 297
15957: GREATER
15958: PUSH
15959: LD_EXP 9
15963: AND
15964: PUSH
15965: LD_INT 9
15967: PPUSH
15968: LD_INT 81
15970: PUSH
15971: LD_INT 3
15973: PUSH
15974: EMPTY
15975: LIST
15976: LIST
15977: PPUSH
15978: CALL_OW 70
15982: PUSH
15983: LD_INT 0
15985: EQUAL
15986: OR
15987: IFFALSE 16025
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
15989: LD_VAR 0 1
15993: PPUSH
15994: LD_INT 81
15996: PUSH
15997: LD_INT 3
15999: PUSH
16000: EMPTY
16001: LIST
16002: LIST
16003: PPUSH
16004: CALL_OW 69
16008: PPUSH
16009: LD_VAR 0 1
16013: PPUSH
16014: CALL_OW 74
16018: PPUSH
16019: CALL_OW 115
16023: GO 16439
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16025: LD_VAR 0 1
16029: PPUSH
16030: CALL_OW 264
16034: PUSH
16035: LD_INT 45
16037: EQUAL
16038: PUSH
16039: LD_EXP 35
16043: PPUSH
16044: LD_INT 3
16046: PUSH
16047: LD_INT 34
16049: PUSH
16050: LD_INT 45
16052: PUSH
16053: EMPTY
16054: LIST
16055: LIST
16056: PUSH
16057: EMPTY
16058: LIST
16059: LIST
16060: PPUSH
16061: CALL_OW 72
16065: PUSH
16066: LD_INT 6
16068: GREATER
16069: AND
16070: IFFALSE 16251
// begin dist := 9999 ;
16072: LD_ADDR_VAR 0 8
16076: PUSH
16077: LD_INT 9999
16079: ST_TO_ADDR
// xy := 0 ;
16080: LD_ADDR_VAR 0 9
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// for x in pointsr do
16088: LD_ADDR_VAR 0 7
16092: PUSH
16093: LD_VAR 0 6
16097: PUSH
16098: FOR_IN
16099: IFFALSE 16247
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16101: LD_VAR 0 1
16105: PPUSH
16106: LD_VAR 0 7
16110: PUSH
16111: LD_INT 1
16113: ARRAY
16114: PPUSH
16115: LD_VAR 0 7
16119: PUSH
16120: LD_INT 2
16122: ARRAY
16123: PPUSH
16124: CALL_OW 297
16128: PUSH
16129: LD_VAR 0 8
16133: LESS
16134: IFFALSE 16179
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16136: LD_ADDR_VAR 0 8
16140: PUSH
16141: LD_VAR 0 1
16145: PPUSH
16146: LD_VAR 0 7
16150: PUSH
16151: LD_INT 1
16153: ARRAY
16154: PPUSH
16155: LD_VAR 0 7
16159: PUSH
16160: LD_INT 2
16162: ARRAY
16163: PPUSH
16164: CALL_OW 297
16168: ST_TO_ADDR
// xy := x ;
16169: LD_ADDR_VAR 0 9
16173: PUSH
16174: LD_VAR 0 7
16178: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16179: LD_VAR 0 9
16183: PUSH
16184: LD_VAR 0 1
16188: PPUSH
16189: LD_VAR 0 9
16193: PUSH
16194: LD_INT 1
16196: ARRAY
16197: PPUSH
16198: LD_VAR 0 9
16202: PUSH
16203: LD_INT 2
16205: ARRAY
16206: PPUSH
16207: CALL_OW 297
16211: PUSH
16212: LD_INT 9
16214: GREATER
16215: AND
16216: IFFALSE 16245
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16218: LD_VAR 0 1
16222: PPUSH
16223: LD_VAR 0 9
16227: PUSH
16228: LD_INT 1
16230: ARRAY
16231: PPUSH
16232: LD_VAR 0 9
16236: PUSH
16237: LD_INT 2
16239: ARRAY
16240: PPUSH
16241: CALL_OW 114
// end ;
16245: GO 16098
16247: POP
16248: POP
// end else
16249: GO 16439
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16251: LD_ADDR_VAR 0 3
16255: PUSH
16256: LD_OWVAR 3
16260: PUSH
16261: LD_VAR 0 1
16265: DIFF
16266: PPUSH
16267: LD_VAR 0 1
16271: PPUSH
16272: CALL_OW 74
16276: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16277: LD_VAR 0 1
16281: PPUSH
16282: CALL_OW 320
16286: NOT
16287: PUSH
16288: LD_VAR 0 3
16292: PUSH
16293: LD_INT 21
16295: PUSH
16296: LD_INT 2
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: LD_INT 33
16305: PUSH
16306: LD_INT 1
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: LD_INT 58
16315: PUSH
16316: EMPTY
16317: LIST
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: LIST
16323: PPUSH
16324: CALL_OW 69
16328: IN
16329: PUSH
16330: LD_VAR 0 3
16334: PUSH
16335: LD_INT 22
16337: PUSH
16338: LD_INT 3
16340: PUSH
16341: EMPTY
16342: LIST
16343: LIST
16344: PUSH
16345: LD_INT 21
16347: PUSH
16348: LD_INT 2
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PUSH
16355: LD_INT 3
16357: PUSH
16358: LD_INT 24
16360: PUSH
16361: LD_INT 249
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: LIST
16376: PPUSH
16377: CALL_OW 69
16381: IN
16382: OR
16383: AND
16384: IFFALSE 16402
// ComAttackUnit ( i , un ) else
16386: LD_VAR 0 1
16390: PPUSH
16391: LD_VAR 0 3
16395: PPUSH
16396: CALL_OW 115
16400: GO 16439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16402: LD_VAR 0 1
16406: PPUSH
16407: LD_INT 9
16409: PPUSH
16410: LD_INT 81
16412: PUSH
16413: LD_INT 3
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: PPUSH
16420: CALL_OW 70
16424: PPUSH
16425: LD_VAR 0 1
16429: PPUSH
16430: CALL_OW 74
16434: PPUSH
16435: CALL_OW 115
// end ; end ; end ; end ;
16439: GO 15706
16441: POP
16442: POP
// end ;
16443: PPOPN 9
16445: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16446: LD_INT 22
16448: PUSH
16449: LD_INT 3
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: PUSH
16456: LD_INT 32
16458: PUSH
16459: LD_INT 1
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PPUSH
16470: CALL_OW 69
16474: IFFALSE 16562
16476: GO 16478
16478: DISABLE
16479: LD_INT 0
16481: PPUSH
16482: PPUSH
// begin enable ;
16483: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16484: LD_ADDR_VAR 0 2
16488: PUSH
16489: LD_INT 22
16491: PUSH
16492: LD_INT 3
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: PUSH
16499: LD_INT 32
16501: PUSH
16502: LD_INT 1
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PPUSH
16513: CALL_OW 69
16517: ST_TO_ADDR
// for i in tmp do
16518: LD_ADDR_VAR 0 1
16522: PUSH
16523: LD_VAR 0 2
16527: PUSH
16528: FOR_IN
16529: IFFALSE 16560
// if GetFuel ( i ) < 12 then
16531: LD_VAR 0 1
16535: PPUSH
16536: CALL_OW 261
16540: PUSH
16541: LD_INT 12
16543: LESS
16544: IFFALSE 16558
// SetFuel ( i , 12 ) ;
16546: LD_VAR 0 1
16550: PPUSH
16551: LD_INT 12
16553: PPUSH
16554: CALL_OW 240
16558: GO 16528
16560: POP
16561: POP
// end ;
16562: PPOPN 2
16564: END
// every 0 0$1 trigger can_end do
16565: LD_EXP 17
16569: IFFALSE 16588
16571: GO 16573
16573: DISABLE
// begin Wait ( 1 1$35 ) ;
16574: LD_INT 3325
16576: PPUSH
16577: CALL_OW 67
// PrepareAttack ( 10 ) ;
16581: LD_INT 10
16583: PPUSH
16584: CALL 14421 0 1
// end ;
16588: END
