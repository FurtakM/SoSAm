// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12558 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1708 0 0
// Action ;
  32: CALL 2583 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1676
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1676: LD_ADDR_EXP 25
1680: PUSH
1681: LD_STRING Powell
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_STRING 
1689: PPUSH
1690: CALL 201 0 3
1694: ST_TO_ADDR
// InitHc ;
1695: CALL_OW 19
// InitUc ;
1699: CALL_OW 18
// end ;
1703: LD_VAR 0 1
1707: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1708: LD_INT 0
1710: PPUSH
1711: PPUSH
1712: PPUSH
1713: PPUSH
1714: PPUSH
// uc_side := 4 ;
1715: LD_ADDR_OWVAR 20
1719: PUSH
1720: LD_INT 4
1722: ST_TO_ADDR
// uc_nation := 3 ;
1723: LD_ADDR_OWVAR 21
1727: PUSH
1728: LD_INT 3
1730: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_STRING 09_ovsyenko_base
1738: PPUSH
1739: LD_INT 0
1741: PUSH
1742: LD_INT 101
1744: PUSH
1745: LD_INT 118
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 500
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: LD_INT 31
1763: PUSH
1764: LD_INT 109
1766: PUSH
1767: LD_INT 114
1769: PUSH
1770: LD_INT 4
1772: PUSH
1773: LD_INT 500
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 115
1788: PUSH
1789: LD_INT 132
1791: PUSH
1792: LD_INT 5
1794: PUSH
1795: LD_INT 500
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 31
1807: PUSH
1808: LD_INT 98
1810: PUSH
1811: LD_INT 120
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 500
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL_OW 30
1837: ST_TO_ADDR
// for i in tmp do
1838: LD_ADDR_VAR 0 2
1842: PUSH
1843: LD_VAR 0 4
1847: PUSH
1848: FOR_IN
1849: IFFALSE 2005
// begin bc_type := i [ 1 ] ;
1851: LD_ADDR_OWVAR 42
1855: PUSH
1856: LD_VAR 0 2
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: ST_TO_ADDR
// bc_level := 3 ;
1865: LD_ADDR_OWVAR 43
1869: PUSH
1870: LD_INT 3
1872: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_VAR 0 2
1882: PUSH
1883: LD_INT 2
1885: ARRAY
1886: PPUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_INT 3
1894: ARRAY
1895: PPUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 4
1903: ARRAY
1904: PPUSH
1905: CALL_OW 47
1909: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 266
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: IFFALSE 1957
// begin SetBName ( b , ovsyenko ) ;
1925: LD_VAR 0 3
1929: PPUSH
1930: LD_STRING ovsyenko
1932: PPUSH
1933: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: CALL_OW 274
1946: PPUSH
1947: LD_INT 1
1949: PPUSH
1950: LD_INT 50
1952: PPUSH
1953: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 5
1964: ARRAY
1965: PUSH
1966: LD_INT 250
1968: LESS
1969: IFFALSE 1985
// SetLives ( b , 333 ) else
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_INT 333
1978: PPUSH
1979: CALL_OW 234
1983: GO 2003
// SetLives ( b , i [ 5 ] ) ;
1985: LD_VAR 0 3
1989: PPUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 5
1997: ARRAY
1998: PPUSH
1999: CALL_OW 234
// end ;
2003: GO 1848
2005: POP
2006: POP
// uc_nation := 1 ;
2007: LD_ADDR_OWVAR 21
2011: PUSH
2012: LD_INT 1
2014: ST_TO_ADDR
// tmp := [ ] ;
2015: LD_ADDR_VAR 0 4
2019: PUSH
2020: EMPTY
2021: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2022: LD_ADDR_EXP 19
2026: PUSH
2027: LD_STRING Gary
2029: PPUSH
2030: LD_EXP 2
2034: NOT
2035: PPUSH
2036: LD_STRING 
2038: PPUSH
2039: CALL 201 0 3
2043: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2044: LD_ADDR_VAR 0 4
2048: PUSH
2049: LD_VAR 0 4
2053: PUSH
2054: LD_EXP 19
2058: ADD
2059: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2060: LD_ADDR_EXP 20
2064: PUSH
2065: LD_STRING Bobby
2067: PPUSH
2068: LD_EXP 2
2072: NOT
2073: PPUSH
2074: LD_STRING 03_
2076: PPUSH
2077: CALL 201 0 3
2081: ST_TO_ADDR
// if Bobby then
2082: LD_EXP 20
2086: IFFALSE 2104
// tmp := tmp ^ Bobby ;
2088: LD_ADDR_VAR 0 4
2092: PUSH
2093: LD_VAR 0 4
2097: PUSH
2098: LD_EXP 20
2102: ADD
2103: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2104: LD_ADDR_EXP 21
2108: PUSH
2109: LD_STRING Cyrus
2111: PPUSH
2112: LD_EXP 2
2116: NOT
2117: PPUSH
2118: LD_STRING 03_
2120: PPUSH
2121: CALL 201 0 3
2125: ST_TO_ADDR
// if Cyrus then
2126: LD_EXP 21
2130: IFFALSE 2148
// tmp := tmp ^ Cyrus ;
2132: LD_ADDR_VAR 0 4
2136: PUSH
2137: LD_VAR 0 4
2141: PUSH
2142: LD_EXP 21
2146: ADD
2147: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2148: LD_ADDR_VAR 0 4
2152: PUSH
2153: LD_VAR 0 4
2157: PUSH
2158: LD_STRING 09_prev_squad
2160: PPUSH
2161: CALL_OW 31
2165: ADD
2166: ST_TO_ADDR
// tmp := tmp diff 0 ;
2167: LD_ADDR_VAR 0 4
2171: PUSH
2172: LD_VAR 0 4
2176: PUSH
2177: LD_INT 0
2179: DIFF
2180: ST_TO_ADDR
// if debug then
2181: LD_EXP 2
2185: IFFALSE 2236
// begin for i = 1 to 6 do
2187: LD_ADDR_VAR 0 2
2191: PUSH
2192: DOUBLE
2193: LD_INT 1
2195: DEC
2196: ST_TO_ADDR
2197: LD_INT 6
2199: PUSH
2200: FOR_TO
2201: IFFALSE 2234
// begin PrepareHuman ( false , 1 , 6 ) ;
2203: LD_INT 0
2205: PPUSH
2206: LD_INT 1
2208: PPUSH
2209: LD_INT 6
2211: PPUSH
2212: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2216: LD_ADDR_VAR 0 4
2220: PUSH
2221: LD_VAR 0 4
2225: PUSH
2226: CALL_OW 44
2230: ADD
2231: ST_TO_ADDR
// end ;
2232: GO 2200
2234: POP
2235: POP
// end ; for i in tmp do
2236: LD_ADDR_VAR 0 2
2240: PUSH
2241: LD_VAR 0 4
2245: PUSH
2246: FOR_IN
2247: IFFALSE 2306
// begin if GetClass ( i ) in [ 2 , 3 ] then
2249: LD_VAR 0 2
2253: PPUSH
2254: CALL_OW 257
2258: PUSH
2259: LD_INT 2
2261: PUSH
2262: LD_INT 3
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: IN
2269: IFFALSE 2283
// SetClass ( i , 1 ) ;
2271: LD_VAR 0 2
2275: PPUSH
2276: LD_INT 1
2278: PPUSH
2279: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2283: LD_VAR 0 2
2287: PPUSH
2288: LD_INT 106
2290: PPUSH
2291: LD_INT 122
2293: PPUSH
2294: LD_INT 5
2296: PPUSH
2297: LD_INT 0
2299: PPUSH
2300: CALL_OW 50
// end ;
2304: GO 2246
2306: POP
2307: POP
// tmp := tmp diff Gary ;
2308: LD_ADDR_VAR 0 4
2312: PUSH
2313: LD_VAR 0 4
2317: PUSH
2318: LD_EXP 19
2322: DIFF
2323: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2324: LD_ADDR_VAR 0 3
2328: PUSH
2329: LD_INT 22
2331: PUSH
2332: LD_INT 4
2334: PUSH
2335: EMPTY
2336: LIST
2337: LIST
2338: PUSH
2339: LD_INT 30
2341: PUSH
2342: LD_INT 31
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PPUSH
2353: CALL_OW 69
2357: ST_TO_ADDR
// for i = 1 to b do
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: DOUBLE
2364: LD_INT 1
2366: DEC
2367: ST_TO_ADDR
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_TO
2374: IFFALSE 2404
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2376: LD_VAR 0 4
2380: PUSH
2381: LD_VAR 0 2
2385: ARRAY
2386: PPUSH
2387: LD_VAR 0 3
2391: PUSH
2392: LD_VAR 0 2
2396: ARRAY
2397: PPUSH
2398: CALL_OW 120
// end ;
2402: GO 2373
2404: POP
2405: POP
// InitHc ;
2406: CALL_OW 19
// InitUc ;
2410: CALL_OW 18
// end ;
2414: LD_VAR 0 1
2418: RET
// export function PowellTransport ; var i , un ; begin
2419: LD_INT 0
2421: PPUSH
2422: PPUSH
2423: PPUSH
// uc_side := 4 ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_INT 4
2431: ST_TO_ADDR
// uc_nation := 1 ;
2432: LD_ADDR_OWVAR 21
2436: PUSH
2437: LD_INT 1
2439: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2440: LD_INT 1
2442: PPUSH
2443: LD_INT 3
2445: PPUSH
2446: LD_INT 6
2448: PPUSH
2449: CALL_OW 380
// hc_name :=  ;
2453: LD_ADDR_OWVAR 26
2457: PUSH
2458: LD_STRING 
2460: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2461: LD_ADDR_OWVAR 33
2465: PUSH
2466: LD_STRING SecondCharsGal
2468: ST_TO_ADDR
// hc_face_number := 30 ;
2469: LD_ADDR_OWVAR 34
2473: PUSH
2474: LD_INT 30
2476: ST_TO_ADDR
// powell_trans := CreateHuman ;
2477: LD_ADDR_EXP 24
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// hc_face_number := 31 ;
2487: LD_ADDR_OWVAR 34
2491: PUSH
2492: LD_INT 31
2494: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2495: LD_ADDR_EXP 24
2499: PUSH
2500: LD_EXP 24
2504: PUSH
2505: CALL_OW 44
2509: ADD
2510: ST_TO_ADDR
// for i = 1 to 2 do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: DOUBLE
2517: LD_INT 1
2519: DEC
2520: ST_TO_ADDR
2521: LD_INT 2
2523: PUSH
2524: FOR_TO
2525: IFFALSE 2576
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2527: LD_ADDR_VAR 0 3
2531: PUSH
2532: LD_INT 4
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: LD_INT 3
2540: PPUSH
2541: LD_INT 1
2543: PPUSH
2544: LD_INT 1
2546: PPUSH
2547: LD_INT 12
2549: PPUSH
2550: LD_INT 66
2552: PPUSH
2553: CALL 264 0 7
2557: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2558: LD_ADDR_EXP 24
2562: PUSH
2563: LD_EXP 24
2567: PUSH
2568: LD_VAR 0 3
2572: ADD
2573: ST_TO_ADDR
// end ;
2574: GO 2524
2576: POP
2577: POP
// end ; end_of_file
2578: LD_VAR 0 1
2582: RET
// export function Action ; var i , veh ; begin
2583: LD_INT 0
2585: PPUSH
2586: PPUSH
2587: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2588: LD_EXP 23
2592: PPUSH
2593: LD_INT 0
2595: PPUSH
2596: LD_INT 50
2598: PPUSH
2599: LD_INT 38
2601: PPUSH
2602: LD_INT 2
2604: PPUSH
2605: CALL_OW 145
// InGameOn ;
2609: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2613: LD_INT 43
2615: PPUSH
2616: LD_INT 9
2618: PPUSH
2619: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2623: LD_EXP 18
2627: PPUSH
2628: LD_INT 54
2630: PPUSH
2631: LD_INT 34
2633: PPUSH
2634: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2638: LD_EXP 18
2642: PPUSH
2643: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2647: LD_EXP 18
2651: PPUSH
2652: LD_EXP 23
2656: PUSH
2657: LD_INT 1
2659: ARRAY
2660: PPUSH
2661: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2665: LD_INT 35
2667: PPUSH
2668: CALL_OW 67
// until See ( 4 , JMM ) ;
2672: LD_INT 4
2674: PPUSH
2675: LD_EXP 18
2679: PPUSH
2680: CALL_OW 292
2684: IFFALSE 2665
// CenterNowOnUnits ( JMM ) ;
2686: LD_EXP 18
2690: PPUSH
2691: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2695: LD_EXP 18
2699: PPUSH
2700: LD_STRING D2-JMM-1
2702: PPUSH
2703: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2707: LD_EXP 23
2711: PUSH
2712: LD_INT 3
2714: ARRAY
2715: PPUSH
2716: LD_EXP 18
2720: PPUSH
2721: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2725: LD_EXP 23
2729: PUSH
2730: LD_INT 3
2732: ARRAY
2733: PPUSH
2734: LD_STRING D2-Eng1-1
2736: PPUSH
2737: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2741: LD_EXP 18
2745: PPUSH
2746: LD_STRING D2-JMM-2
2748: PPUSH
2749: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2753: LD_EXP 23
2757: PUSH
2758: LD_INT 3
2760: ARRAY
2761: PPUSH
2762: LD_STRING D2-Eng1-2
2764: PPUSH
2765: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2769: LD_EXP 18
2773: PPUSH
2774: LD_STRING D2-JMM-3
2776: PPUSH
2777: CALL_OW 88
// if Houten then
2781: LD_EXP 22
2785: IFFALSE 2983
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2787: LD_ADDR_VAR 0 3
2791: PUSH
2792: LD_INT 4
2794: PPUSH
2795: LD_INT 1
2797: PPUSH
2798: LD_INT 3
2800: PPUSH
2801: LD_INT 2
2803: PPUSH
2804: LD_INT 1
2806: PPUSH
2807: LD_INT 4
2809: PPUSH
2810: LD_INT 55
2812: PPUSH
2813: CALL 264 0 7
2817: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2818: LD_VAR 0 3
2822: PPUSH
2823: LD_INT 3
2825: PPUSH
2826: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2830: LD_VAR 0 3
2834: PPUSH
2835: LD_INT 46
2837: PPUSH
2838: LD_INT 19
2840: PPUSH
2841: LD_INT 0
2843: PPUSH
2844: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2848: LD_EXP 22
2852: PPUSH
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2862: LD_EXP 22
2866: PPUSH
2867: LD_INT 49
2869: PPUSH
2870: LD_INT 33
2872: PPUSH
2873: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2877: LD_EXP 22
2881: PPUSH
2882: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2886: LD_EXP 22
2890: PPUSH
2891: LD_EXP 18
2895: PPUSH
2896: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2900: LD_INT 35
2902: PPUSH
2903: CALL_OW 67
// until See ( 1 , Houten ) ;
2907: LD_INT 1
2909: PPUSH
2910: LD_EXP 22
2914: PPUSH
2915: CALL_OW 292
2919: IFFALSE 2900
// ComTurnUnit ( JMM , Houten ) ;
2921: LD_EXP 18
2925: PPUSH
2926: LD_EXP 22
2930: PPUSH
2931: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2935: LD_EXP 18
2939: PPUSH
2940: LD_STRING D1d-JMM-1
2942: PPUSH
2943: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2947: LD_EXP 22
2951: PPUSH
2952: LD_STRING D1-VanH-1
2954: PPUSH
2955: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2959: LD_EXP 18
2963: PPUSH
2964: LD_STRING D1-JMM-1v
2966: PPUSH
2967: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2971: LD_EXP 18
2975: PPUSH
2976: LD_STRING D1-JMM-2v
2978: PPUSH
2979: CALL_OW 88
// end ; InGameOff ;
2983: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2987: LD_STRING M1
2989: PPUSH
2990: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2994: LD_INT 22
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: PUSH
3004: LD_INT 92
3006: PUSH
3007: LD_EXP 18
3011: PPUSH
3012: CALL_OW 250
3016: PUSH
3017: LD_EXP 18
3021: PPUSH
3022: CALL_OW 251
3026: PUSH
3027: LD_INT 15
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: PPUSH
3040: CALL_OW 69
3044: PPUSH
3045: LD_INT 1
3047: PPUSH
3048: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3052: LD_EXP 23
3056: PUSH
3057: LD_EXP 18
3061: ADD
3062: PUSH
3063: LD_EXP 22
3067: ADD
3068: PPUSH
3069: CALL_OW 141
// end ;
3073: LD_VAR 0 1
3077: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3078: LD_INT 1
3080: PPUSH
3081: LD_EXP 19
3085: PPUSH
3086: CALL_OW 292
3090: PUSH
3091: LD_EXP 18
3095: PPUSH
3096: LD_EXP 19
3100: PPUSH
3101: CALL_OW 296
3105: PUSH
3106: LD_INT 6
3108: LESS
3109: AND
3110: IFFALSE 3873
3112: GO 3114
3114: DISABLE
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
// begin InGameOn ;
3122: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3126: LD_INT 22
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PPUSH
3136: CALL_OW 69
3140: PPUSH
3141: LD_INT 1
3143: PPUSH
3144: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3148: LD_ADDR_VAR 0 4
3152: PUSH
3153: LD_INT 22
3155: PUSH
3156: LD_INT 1
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 2
3165: PUSH
3166: LD_INT 25
3168: PUSH
3169: LD_INT 1
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PUSH
3176: LD_INT 25
3178: PUSH
3179: LD_INT 2
3181: PUSH
3182: EMPTY
3183: LIST
3184: LIST
3185: PUSH
3186: LD_INT 25
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: PUSH
3196: LD_INT 25
3198: PUSH
3199: LD_INT 4
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PPUSH
3217: CALL_OW 69
3221: ST_TO_ADDR
// ComHold ( tmp ) ;
3222: LD_VAR 0 4
3226: PPUSH
3227: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3231: LD_EXP 18
3235: PPUSH
3236: LD_STRING D2-JMM-3a
3238: PPUSH
3239: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3243: LD_EXP 19
3247: PPUSH
3248: LD_EXP 18
3252: PPUSH
3253: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3257: LD_EXP 19
3261: PPUSH
3262: LD_STRING D2-Gary-3
3264: PPUSH
3265: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3269: LD_EXP 18
3273: PPUSH
3274: LD_EXP 19
3278: PPUSH
3279: CALL_OW 119
// for i in tmp do
3283: LD_ADDR_VAR 0 5
3287: PUSH
3288: LD_VAR 0 4
3292: PUSH
3293: FOR_IN
3294: IFFALSE 3339
// begin if IsInUnit ( i ) then
3296: LD_VAR 0 5
3300: PPUSH
3301: CALL_OW 310
3305: IFFALSE 3316
// ComExitBuilding ( i ) ;
3307: LD_VAR 0 5
3311: PPUSH
3312: CALL_OW 122
// wait ( 1 ) ;
3316: LD_INT 1
3318: PPUSH
3319: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3323: LD_VAR 0 5
3327: PPUSH
3328: LD_EXP 18
3332: PPUSH
3333: CALL_OW 119
// end ;
3337: GO 3293
3339: POP
3340: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3341: LD_ADDR_VAR 0 4
3345: PUSH
3346: LD_VAR 0 4
3350: PUSH
3351: LD_EXP 18
3355: PUSH
3356: LD_EXP 22
3360: PUSH
3361: LD_EXP 19
3365: PUSH
3366: LD_EXP 21
3370: PUSH
3371: LD_EXP 20
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_EXP 23
3387: ADD
3388: DIFF
3389: ST_TO_ADDR
// if Bobby then
3390: LD_EXP 20
3394: IFFALSE 3408
// Say ( Bobby , D2-Bobby-3 ) ;
3396: LD_EXP 20
3400: PPUSH
3401: LD_STRING D2-Bobby-3
3403: PPUSH
3404: CALL_OW 88
// if Cyrus then
3408: LD_EXP 21
3412: IFFALSE 3426
// Say ( Cyrus , D2-Cyrus-3 ) ;
3414: LD_EXP 21
3418: PPUSH
3419: LD_STRING D2-Cyrus-3
3421: PPUSH
3422: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3426: LD_EXP 18
3430: PPUSH
3431: LD_STRING D2-JMM-4
3433: PPUSH
3434: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3438: LD_EXP 19
3442: PPUSH
3443: LD_STRING D2-Gary-4
3445: PPUSH
3446: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3450: LD_ADDR_VAR 0 1
3454: PUSH
3455: LD_VAR 0 4
3459: PPUSH
3460: LD_INT 26
3462: PUSH
3463: LD_INT 1
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: PPUSH
3470: CALL_OW 72
3474: PUSH
3475: LD_INT 1
3477: ARRAY
3478: ST_TO_ADDR
// if Cyrus then
3479: LD_EXP 21
3483: IFFALSE 3499
// Say ( Cyrus , D2-Cyrus-4 ) else
3485: LD_EXP 21
3489: PPUSH
3490: LD_STRING D2-Cyrus-4
3492: PPUSH
3493: CALL_OW 88
3497: GO 3511
// Say ( un1 , D2-Sol1-4 ) ;
3499: LD_VAR 0 1
3503: PPUSH
3504: LD_STRING D2-Sol1-4
3506: PPUSH
3507: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3511: LD_EXP 18
3515: PPUSH
3516: LD_STRING D2-JMM-5
3518: PPUSH
3519: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3523: LD_ADDR_VAR 0 2
3527: PUSH
3528: LD_EXP 23
3532: PPUSH
3533: LD_INT 91
3535: PUSH
3536: LD_EXP 18
3540: PUSH
3541: LD_INT 10
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: PUSH
3549: LD_INT 26
3551: PUSH
3552: LD_INT 2
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: PPUSH
3563: CALL_OW 72
3567: ST_TO_ADDR
// if un2 then
3568: LD_VAR 0 2
3572: IFFALSE 3626
// begin un2 := un2 [ un2 ] ;
3574: LD_ADDR_VAR 0 2
3578: PUSH
3579: LD_VAR 0 2
3583: PUSH
3584: LD_VAR 0 2
3588: ARRAY
3589: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3590: LD_VAR 0 2
3594: PPUSH
3595: LD_STRING D2-FEng1-5
3597: PPUSH
3598: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3602: LD_EXP 18
3606: PPUSH
3607: LD_STRING D2-JMM-6
3609: PPUSH
3610: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3614: LD_VAR 0 2
3618: PPUSH
3619: LD_STRING D2-FEng1-6
3621: PPUSH
3622: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3626: LD_ADDR_VAR 0 3
3630: PUSH
3631: LD_EXP 23
3635: PPUSH
3636: LD_INT 91
3638: PUSH
3639: LD_EXP 18
3643: PUSH
3644: LD_INT 10
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: PUSH
3652: LD_INT 26
3654: PUSH
3655: LD_INT 1
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PPUSH
3666: CALL_OW 72
3670: ST_TO_ADDR
// if un3 then
3671: LD_VAR 0 3
3675: IFFALSE 3730
// begin un3 := un3 [ 1 ] ;
3677: LD_ADDR_VAR 0 3
3681: PUSH
3682: LD_VAR 0 3
3686: PUSH
3687: LD_INT 1
3689: ARRAY
3690: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3691: LD_VAR 0 3
3695: PPUSH
3696: LD_INT 114
3698: PPUSH
3699: LD_INT 122
3701: PPUSH
3702: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3706: LD_VAR 0 3
3710: PPUSH
3711: LD_STRING D2-Eng1-6
3713: PPUSH
3714: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3718: LD_EXP 18
3722: PPUSH
3723: LD_STRING D2-JMM-7
3725: PPUSH
3726: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3730: LD_EXP 19
3734: PPUSH
3735: LD_STRING D2-Gary-7
3737: PPUSH
3738: CALL_OW 88
// if un2 then
3742: LD_VAR 0 2
3746: IFFALSE 3760
// Say ( un2 , D2-FEng1-7 ) ;
3748: LD_VAR 0 2
3752: PPUSH
3753: LD_STRING D2-FEng1-7
3755: PPUSH
3756: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3760: LD_VAR 0 1
3764: PPUSH
3765: LD_STRING D2-Sol1-7
3767: PPUSH
3768: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3772: LD_EXP 18
3776: PPUSH
3777: LD_STRING D2-JMM-8
3779: PPUSH
3780: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3784: LD_INT 22
3786: PUSH
3787: LD_INT 1
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PPUSH
3799: CALL_OW 141
// InGameOff ;
3803: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3807: LD_STRING M1a
3809: PPUSH
3810: CALL_OW 337
// jmm_in_ovsyenko := true ;
3814: LD_ADDR_EXP 4
3818: PUSH
3819: LD_INT 1
3821: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3822: LD_INT 1050
3824: PPUSH
3825: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3829: LD_ADDR_VAR 0 4
3833: PUSH
3834: LD_INT 25
3836: PUSH
3837: LD_INT 14
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PPUSH
3844: CALL_OW 69
3848: ST_TO_ADDR
// if not tmp then
3849: LD_VAR 0 4
3853: NOT
3854: IFFALSE 3858
// exit ;
3856: GO 3873
// ComMoveXY ( tmp , 75 , 75 ) ;
3858: LD_VAR 0 4
3862: PPUSH
3863: LD_INT 75
3865: PPUSH
3866: LD_INT 75
3868: PPUSH
3869: CALL_OW 111
// end ;
3873: PPOPN 5
3875: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3876: LD_INT 22
3878: PUSH
3879: LD_INT 1
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: LD_INT 30
3888: PUSH
3889: LD_INT 30
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: PUSH
3896: LD_INT 3
3898: PUSH
3899: LD_INT 57
3901: PUSH
3902: EMPTY
3903: LIST
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: LIST
3913: PPUSH
3914: CALL_OW 69
3918: IFFALSE 3960
3920: GO 3922
3922: DISABLE
3923: LD_INT 0
3925: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3926: LD_ADDR_VAR 0 1
3930: PUSH
3931: LD_STRING M2easy
3933: PUSH
3934: LD_STRING M2
3936: PUSH
3937: LD_STRING M2hard
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: LIST
3944: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3945: LD_VAR 0 1
3949: PUSH
3950: LD_OWVAR 67
3954: ARRAY
3955: PPUSH
3956: CALL_OW 337
// end ;
3960: PPOPN 1
3962: END
// every 3 3$00 do
3963: GO 3965
3965: DISABLE
// begin DialogueOn ;
3966: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3970: LD_EXP 25
3974: PPUSH
3975: LD_STRING D3-Pow-1
3977: PPUSH
3978: CALL_OW 94
// if jmm_in_ovsyenko then
3982: LD_EXP 4
3986: IFFALSE 4014
// begin Say ( JMM , D3-JMM-1 ) ;
3988: LD_EXP 18
3992: PPUSH
3993: LD_STRING D3-JMM-1
3995: PPUSH
3996: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4000: LD_EXP 18
4004: PPUSH
4005: LD_STRING D3-JMM-1b
4007: PPUSH
4008: CALL_OW 88
// end else
4012: GO 4026
// Say ( JMM , D3-JMM-1a ) ;
4014: LD_EXP 18
4018: PPUSH
4019: LD_STRING D3-JMM-1a
4021: PPUSH
4022: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4026: LD_EXP 25
4030: PPUSH
4031: LD_STRING D3-Pow-2
4033: PPUSH
4034: CALL_OW 94
// DialogueOff ;
4038: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4042: LD_STRING M3
4044: PPUSH
4045: CALL_OW 337
// powell_want_sib := true ;
4049: LD_ADDR_EXP 5
4053: PUSH
4054: LD_INT 1
4056: ST_TO_ADDR
// end ;
4057: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4058: LD_EXP 6
4062: PUSH
4063: LD_INT 0
4065: EQUAL
4066: IFFALSE 5513
4068: GO 4070
4070: DISABLE
4071: LD_INT 0
4073: PPUSH
4074: PPUSH
4075: PPUSH
4076: PPUSH
4077: PPUSH
4078: PPUSH
4079: PPUSH
4080: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4081: LD_INT 4
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: CALL_OW 343
// PowellTransport ;
4091: CALL 2419 0 0
// for i = 1 to 3 do
4095: LD_ADDR_VAR 0 4
4099: PUSH
4100: DOUBLE
4101: LD_INT 1
4103: DEC
4104: ST_TO_ADDR
4105: LD_INT 3
4107: PUSH
4108: FOR_TO
4109: IFFALSE 4176
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4111: LD_ADDR_VAR 0 1
4115: PUSH
4116: LD_INT 6
4118: PPUSH
4119: LD_VAR 0 4
4123: PPUSH
4124: CALL_OW 287
4128: ST_TO_ADDR
// if not tmp then
4129: LD_VAR 0 1
4133: NOT
4134: IFFALSE 4138
// continue ;
4136: GO 4108
// EraseResourceArea ( terminalArea , i ) ;
4138: LD_INT 6
4140: PPUSH
4141: LD_VAR 0 4
4145: PPUSH
4146: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4150: LD_EXP 3
4154: PPUSH
4155: CALL_OW 274
4159: PPUSH
4160: LD_VAR 0 4
4164: PPUSH
4165: LD_VAR 0 1
4169: PPUSH
4170: CALL_OW 276
// end ;
4174: GO 4108
4176: POP
4177: POP
// x := 43 ;
4178: LD_ADDR_VAR 0 2
4182: PUSH
4183: LD_INT 43
4185: ST_TO_ADDR
// y := 3 ;
4186: LD_ADDR_VAR 0 3
4190: PUSH
4191: LD_INT 3
4193: ST_TO_ADDR
// for i = 3 to 4 do
4194: LD_ADDR_VAR 0 4
4198: PUSH
4199: DOUBLE
4200: LD_INT 3
4202: DEC
4203: ST_TO_ADDR
4204: LD_INT 4
4206: PUSH
4207: FOR_TO
4208: IFFALSE 4399
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4210: LD_EXP 24
4214: PUSH
4215: LD_VAR 0 4
4219: ARRAY
4220: PPUSH
4221: LD_INT 4
4223: PPUSH
4224: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4228: LD_EXP 24
4232: PUSH
4233: LD_VAR 0 4
4237: ARRAY
4238: PPUSH
4239: LD_VAR 0 2
4243: PPUSH
4244: LD_VAR 0 3
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4256: LD_EXP 24
4260: PUSH
4261: LD_VAR 0 4
4265: PUSH
4266: LD_INT 2
4268: MINUS
4269: ARRAY
4270: PPUSH
4271: LD_EXP 24
4275: PUSH
4276: LD_VAR 0 4
4280: ARRAY
4281: PPUSH
4282: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4286: LD_EXP 24
4290: PUSH
4291: LD_VAR 0 4
4295: ARRAY
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 100
4302: PPUSH
4303: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4307: LD_EXP 24
4311: PUSH
4312: LD_VAR 0 4
4316: PUSH
4317: LD_INT 2
4319: MINUS
4320: ARRAY
4321: PPUSH
4322: LD_INT 54
4324: PPUSH
4325: LD_INT 42
4327: PPUSH
4328: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4332: LD_EXP 24
4336: PUSH
4337: LD_VAR 0 4
4341: PUSH
4342: LD_INT 2
4344: MINUS
4345: ARRAY
4346: PPUSH
4347: LD_EXP 3
4351: PPUSH
4352: CALL_OW 250
4356: PPUSH
4357: LD_EXP 3
4361: PPUSH
4362: CALL_OW 251
4366: PPUSH
4367: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4371: LD_EXP 24
4375: PUSH
4376: LD_VAR 0 4
4380: PUSH
4381: LD_INT 2
4383: MINUS
4384: ARRAY
4385: PPUSH
4386: CALL_OW 200
// Wait ( 0 0$02 ) ;
4390: LD_INT 70
4392: PPUSH
4393: CALL_OW 67
// end ;
4397: GO 4207
4399: POP
4400: POP
// time := 0 0$20 ;
4401: LD_ADDR_VAR 0 8
4405: PUSH
4406: LD_INT 700
4408: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4409: LD_INT 35
4411: PPUSH
4412: CALL_OW 67
// time := time - 0 0$01 ;
4416: LD_ADDR_VAR 0 8
4420: PUSH
4421: LD_VAR 0 8
4425: PUSH
4426: LD_INT 35
4428: MINUS
4429: ST_TO_ADDR
// for i = 3 to 4 do
4430: LD_ADDR_VAR 0 4
4434: PUSH
4435: DOUBLE
4436: LD_INT 3
4438: DEC
4439: ST_TO_ADDR
4440: LD_INT 4
4442: PUSH
4443: FOR_TO
4444: IFFALSE 4579
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4446: LD_EXP 24
4450: PUSH
4451: LD_VAR 0 4
4455: ARRAY
4456: PPUSH
4457: LD_INT 1
4459: PPUSH
4460: CALL_OW 289
4464: PUSH
4465: LD_INT 0
4467: GREATER
4468: PUSH
4469: LD_EXP 24
4473: PUSH
4474: LD_VAR 0 4
4478: ARRAY
4479: PPUSH
4480: CALL_OW 314
4484: NOT
4485: AND
4486: IFFALSE 4577
// begin x := rand ( 0 , 5 ) ;
4488: LD_ADDR_VAR 0 2
4492: PUSH
4493: LD_INT 0
4495: PPUSH
4496: LD_INT 5
4498: PPUSH
4499: CALL_OW 12
4503: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4504: LD_EXP 24
4508: PUSH
4509: LD_VAR 0 4
4513: ARRAY
4514: PPUSH
4515: LD_EXP 24
4519: PUSH
4520: LD_VAR 0 4
4524: ARRAY
4525: PPUSH
4526: CALL_OW 250
4530: PPUSH
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_INT 3
4538: PPUSH
4539: CALL_OW 272
4543: PPUSH
4544: LD_EXP 24
4548: PUSH
4549: LD_VAR 0 4
4553: ARRAY
4554: PPUSH
4555: CALL_OW 251
4559: PPUSH
4560: LD_VAR 0 2
4564: PPUSH
4565: LD_INT 3
4567: PPUSH
4568: CALL_OW 273
4572: PPUSH
4573: CALL_OW 171
// end ;
4577: GO 4443
4579: POP
4580: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4581: LD_EXP 24
4585: PUSH
4586: LD_INT 1
4588: ARRAY
4589: PPUSH
4590: LD_INT 54
4592: PPUSH
4593: LD_INT 42
4595: PPUSH
4596: CALL_OW 297
4600: PUSH
4601: LD_INT 4
4603: LESS
4604: PUSH
4605: LD_VAR 0 8
4609: PUSH
4610: LD_INT 0
4612: EQUAL
4613: OR
4614: IFFALSE 4409
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4616: LD_EXP 24
4620: PUSH
4621: LD_INT 3
4623: ARRAY
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: LD_INT 0
4630: PPUSH
4631: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4635: LD_EXP 24
4639: PUSH
4640: LD_INT 4
4642: ARRAY
4643: PPUSH
4644: LD_INT 1
4646: PPUSH
4647: LD_INT 0
4649: PPUSH
4650: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4654: LD_EXP 3
4658: PPUSH
4659: CALL_OW 274
4663: PPUSH
4664: LD_INT 1
4666: PPUSH
4667: LD_INT 200
4669: PPUSH
4670: CALL_OW 276
// DialogueOn ;
4674: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4678: LD_INT 53
4680: PPUSH
4681: LD_INT 35
4683: PPUSH
4684: CALL_OW 86
// un := powell_trans [ 1 ] ;
4688: LD_ADDR_VAR 0 5
4692: PUSH
4693: LD_EXP 24
4697: PUSH
4698: LD_INT 1
4700: ARRAY
4701: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4702: LD_VAR 0 5
4706: PPUSH
4707: LD_STRING D4-Mech1-1
4709: PPUSH
4710: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4714: LD_EXP 18
4718: PPUSH
4719: LD_STRING D4-JMM-1
4721: PPUSH
4722: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4726: LD_VAR 0 5
4730: PPUSH
4731: LD_STRING D4-Mech1-2
4733: PPUSH
4734: CALL_OW 88
// powell_happy := false ;
4738: LD_ADDR_VAR 0 6
4742: PUSH
4743: LD_INT 0
4745: ST_TO_ADDR
// take_cargo := false ;
4746: LD_ADDR_VAR 0 7
4750: PUSH
4751: LD_INT 0
4753: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4754: CALL 784 0 0
4758: PUSH
4759: LD_INT 60
4761: GREATEREQUAL
4762: IFFALSE 4810
// begin Say ( JMM , D5-JMM-1 ) ;
4764: LD_EXP 18
4768: PPUSH
4769: LD_STRING D5-JMM-1
4771: PPUSH
4772: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4776: LD_VAR 0 5
4780: PPUSH
4781: LD_STRING D6-Mech1-1
4783: PPUSH
4784: CALL_OW 88
// powell_happy := true ;
4788: LD_ADDR_VAR 0 6
4792: PUSH
4793: LD_INT 1
4795: ST_TO_ADDR
// take_cargo := true ;
4796: LD_ADDR_VAR 0 7
4800: PUSH
4801: LD_INT 1
4803: ST_TO_ADDR
// DialogueOff ;
4804: CALL_OW 7
// end else
4808: GO 5044
// if GetTerminalCargo > 0 then
4810: CALL 784 0 0
4814: PUSH
4815: LD_INT 0
4817: GREATER
4818: IFFALSE 5016
// begin case Query ( QWait ) of 1 :
4820: LD_STRING QWait
4822: PPUSH
4823: CALL_OW 97
4827: PUSH
4828: LD_INT 1
4830: DOUBLE
4831: EQUAL
4832: IFTRUE 4836
4834: GO 4927
4836: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4837: LD_EXP 18
4841: PPUSH
4842: LD_STRING D5b-JMM-1
4844: PPUSH
4845: CALL_OW 88
// DialogueOff ;
4849: CALL_OW 7
// wait ( 5 5$00 ) ;
4853: LD_INT 10500
4855: PPUSH
4856: CALL_OW 67
// if GetTerminalCargo < 60 then
4860: CALL 784 0 0
4864: PUSH
4865: LD_INT 60
4867: LESS
4868: IFFALSE 4909
// begin DialogueOn ;
4870: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4874: LD_EXP 3
4878: PPUSH
4879: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4883: LD_VAR 0 5
4887: PPUSH
4888: LD_STRING D6-Mech1-1a
4890: PPUSH
4891: CALL_OW 88
// DialogueOff ;
4895: CALL_OW 7
// powell_happy := false ;
4899: LD_ADDR_VAR 0 6
4903: PUSH
4904: LD_INT 0
4906: ST_TO_ADDR
// end else
4907: GO 4925
// begin powell_happy := true ;
4909: LD_ADDR_VAR 0 6
4913: PUSH
4914: LD_INT 1
4916: ST_TO_ADDR
// take_cargo := true ;
4917: LD_ADDR_VAR 0 7
4921: PUSH
4922: LD_INT 1
4924: ST_TO_ADDR
// end ; end ; 2 :
4925: GO 5014
4927: LD_INT 2
4929: DOUBLE
4930: EQUAL
4931: IFTRUE 4935
4933: GO 4974
4935: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4936: LD_EXP 18
4940: PPUSH
4941: LD_STRING D5b-JMM-1
4943: PPUSH
4944: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_STRING D6-Mech1-1a
4955: PPUSH
4956: CALL_OW 88
// DialogueOff ;
4960: CALL_OW 7
// take_cargo := true ;
4964: LD_ADDR_VAR 0 7
4968: PUSH
4969: LD_INT 1
4971: ST_TO_ADDR
// end ; 3 :
4972: GO 5014
4974: LD_INT 3
4976: DOUBLE
4977: EQUAL
4978: IFTRUE 4982
4980: GO 5013
4982: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4983: LD_EXP 18
4987: PPUSH
4988: LD_STRING D5c-JMM-1
4990: PPUSH
4991: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4995: LD_VAR 0 5
4999: PPUSH
5000: LD_STRING D6-Mech1-1b
5002: PPUSH
5003: CALL_OW 88
// DialogueOff ;
5007: CALL_OW 7
// end ; end ;
5011: GO 5014
5013: POP
// end else
5014: GO 5044
// begin Say ( JMM , D5c-JMM-1 ) ;
5016: LD_EXP 18
5020: PPUSH
5021: LD_STRING D5c-JMM-1
5023: PPUSH
5024: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5028: LD_VAR 0 5
5032: PPUSH
5033: LD_STRING D6-Mech1-1b
5035: PPUSH
5036: CALL_OW 88
// DialogueOff ;
5040: CALL_OW 7
// end ; if take_cargo then
5044: LD_VAR 0 7
5048: IFFALSE 5127
// begin x := GetTerminalCargo ;
5050: LD_ADDR_VAR 0 2
5054: PUSH
5055: CALL 784 0 0
5059: ST_TO_ADDR
// if x > 60 then
5060: LD_VAR 0 2
5064: PUSH
5065: LD_INT 60
5067: GREATER
5068: IFFALSE 5078
// x := 60 ;
5070: LD_ADDR_VAR 0 2
5074: PUSH
5075: LD_INT 60
5077: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5078: LD_EXP 3
5082: PPUSH
5083: CALL_OW 274
5087: PPUSH
5088: LD_INT 3
5090: PPUSH
5091: CALL 784 0 0
5095: PUSH
5096: LD_VAR 0 2
5100: MINUS
5101: PPUSH
5102: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5106: LD_EXP 24
5110: PUSH
5111: LD_INT 3
5113: ARRAY
5114: PPUSH
5115: LD_INT 3
5117: PPUSH
5118: LD_VAR 0 2
5122: PPUSH
5123: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5127: LD_EXP 24
5131: PPUSH
5132: LD_INT 43
5134: PPUSH
5135: LD_INT 3
5137: PPUSH
5138: CALL_OW 171
// x := 0 0$20 ;
5142: LD_ADDR_VAR 0 2
5146: PUSH
5147: LD_INT 700
5149: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5150: LD_INT 35
5152: PPUSH
5153: CALL_OW 67
// x := x - 0 0$01 ;
5157: LD_ADDR_VAR 0 2
5161: PUSH
5162: LD_VAR 0 2
5166: PUSH
5167: LD_INT 35
5169: MINUS
5170: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5171: LD_VAR 0 2
5175: PUSH
5176: LD_INT 0
5178: EQUAL
5179: PUSH
5180: LD_EXP 24
5184: PUSH
5185: LD_INT 3
5187: ARRAY
5188: PPUSH
5189: LD_INT 43
5191: PPUSH
5192: LD_INT 3
5194: PPUSH
5195: CALL_OW 297
5199: PUSH
5200: LD_INT 4
5202: LESS
5203: PUSH
5204: LD_EXP 24
5208: PUSH
5209: LD_INT 3
5211: ARRAY
5212: PPUSH
5213: LD_INT 43
5215: PPUSH
5216: LD_INT 3
5218: PPUSH
5219: CALL_OW 297
5223: PUSH
5224: LD_INT 4
5226: LESS
5227: AND
5228: OR
5229: IFFALSE 5150
// for i in powell_trans do
5231: LD_ADDR_VAR 0 4
5235: PUSH
5236: LD_EXP 24
5240: PUSH
5241: FOR_IN
5242: IFFALSE 5255
// RemoveUnit ( i ) ;
5244: LD_VAR 0 4
5248: PPUSH
5249: CALL_OW 64
5253: GO 5241
5255: POP
5256: POP
// if not powell_happy then
5257: LD_VAR 0 6
5261: NOT
5262: IFFALSE 5273
// powell_happy := - 1 ;
5264: LD_ADDR_VAR 0 6
5268: PUSH
5269: LD_INT 1
5271: NEG
5272: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5273: LD_STRING EarlySiberite
5275: PPUSH
5276: LD_VAR 0 6
5280: PPUSH
5281: CALL_OW 101
// if powell_happy then
5285: LD_VAR 0 6
5289: IFFALSE 5300
// ChangeMissionObjectives ( M3a ) else
5291: LD_STRING M3a
5293: PPUSH
5294: CALL_OW 337
5298: GO 5307
// ChangeMissionObjectives ( M3b ) ;
5300: LD_STRING M3b
5302: PPUSH
5303: CALL_OW 337
// ru_can_attack_terminal := true ;
5307: LD_ADDR_EXP 9
5311: PUSH
5312: LD_INT 1
5314: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5315: LD_INT 25200
5317: PPUSH
5318: CALL_OW 67
// time := 2 2$00 ;
5322: LD_ADDR_VAR 0 8
5326: PUSH
5327: LD_INT 4200
5329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5330: LD_INT 35
5332: PPUSH
5333: CALL_OW 67
// time := time - 0 0$1 ;
5337: LD_ADDR_VAR 0 8
5341: PUSH
5342: LD_VAR 0 8
5346: PUSH
5347: LD_INT 35
5349: MINUS
5350: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5351: LD_EXP 8
5355: NOT
5356: PUSH
5357: LD_EXP 35
5361: PUSH
5362: LD_INT 0
5364: EQUAL
5365: OR
5366: PUSH
5367: LD_VAR 0 8
5371: PUSH
5372: LD_INT 0
5374: EQUAL
5375: OR
5376: IFFALSE 5330
// if ru_force then
5378: LD_EXP 35
5382: IFFALSE 5481
// for i in ru_force do
5384: LD_ADDR_VAR 0 4
5388: PUSH
5389: LD_EXP 35
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5479
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5397: LD_INT 1
5399: PPUSH
5400: LD_VAR 0 4
5404: PPUSH
5405: CALL_OW 292
5409: NOT
5410: PUSH
5411: LD_VAR 0 4
5415: PPUSH
5416: LD_INT 81
5418: PUSH
5419: LD_INT 3
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: PPUSH
5426: CALL_OW 69
5430: PPUSH
5431: LD_VAR 0 4
5435: PPUSH
5436: CALL_OW 74
5440: PPUSH
5441: CALL_OW 296
5445: PUSH
5446: LD_INT 10
5448: GREATER
5449: AND
5450: IFFALSE 5477
// begin RemoveUnit ( i ) ;
5452: LD_VAR 0 4
5456: PPUSH
5457: CALL_OW 64
// ru_force := ru_force diff i ;
5461: LD_ADDR_EXP 35
5465: PUSH
5466: LD_EXP 35
5470: PUSH
5471: LD_VAR 0 4
5475: DIFF
5476: ST_TO_ADDR
// end ;
5477: GO 5394
5479: POP
5480: POP
// repeat wait ( 0 0$03 ) ;
5481: LD_INT 105
5483: PPUSH
5484: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5488: LD_EXP 8
5492: NOT
5493: PUSH
5494: LD_EXP 35
5498: PUSH
5499: LD_INT 3
5501: LESS
5502: OR
5503: IFFALSE 5481
// ar_can_arrive := true ;
5505: LD_ADDR_EXP 10
5509: PUSH
5510: LD_INT 1
5512: ST_TO_ADDR
// end ;
5513: PPOPN 8
5515: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 20
5521: PPUSH
5522: CALL_OW 325
5526: IFFALSE 5667
5528: GO 5530
5530: DISABLE
5531: LD_INT 0
5533: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5534: LD_ADDR_VAR 0 1
5538: PUSH
5539: LD_INT 22
5541: PUSH
5542: LD_INT 1
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 26
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 25
5561: PUSH
5562: LD_INT 4
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: LIST
5573: PPUSH
5574: CALL_OW 69
5578: PUSH
5579: LD_EXP 18
5583: PUSH
5584: LD_EXP 21
5588: PUSH
5589: LD_EXP 20
5593: PUSH
5594: LD_EXP 22
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: LIST
5604: DIFF
5605: ST_TO_ADDR
// if not un then
5606: LD_VAR 0 1
5610: NOT
5611: IFFALSE 5615
// exit ;
5613: GO 5667
// DialogueOn ;
5615: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5619: LD_VAR 0 1
5623: PUSH
5624: LD_INT 1
5626: ARRAY
5627: PPUSH
5628: LD_STRING D13-Sci1-1
5630: PPUSH
5631: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5635: LD_EXP 18
5639: PPUSH
5640: LD_STRING D13-JMM-1
5642: PPUSH
5643: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5647: LD_VAR 0 1
5651: PUSH
5652: LD_INT 1
5654: ARRAY
5655: PPUSH
5656: LD_STRING D13-Sci1-2
5658: PPUSH
5659: CALL_OW 88
// DialogueOff ;
5663: CALL_OW 7
// end ;
5667: PPOPN 1
5669: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5670: LD_INT 1
5672: PPUSH
5673: CALL 815 0 1
5677: PUSH
5678: LD_INT 77
5680: GREATER
5681: PUSH
5682: LD_EXP 8
5686: NOT
5687: AND
5688: PUSH
5689: LD_INT 22
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: LD_INT 25
5701: PUSH
5702: LD_INT 4
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: LD_INT 26
5711: PUSH
5712: LD_INT 1
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: PPUSH
5724: CALL_OW 69
5728: PUSH
5729: LD_EXP 18
5733: PUSH
5734: LD_EXP 20
5738: PUSH
5739: LD_EXP 21
5743: PUSH
5744: LD_EXP 19
5748: PUSH
5749: LD_EXP 22
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: LIST
5758: LIST
5759: LIST
5760: DIFF
5761: AND
5762: IFFALSE 5940
5764: GO 5766
5766: DISABLE
5767: LD_INT 0
5769: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5770: LD_ADDR_VAR 0 1
5774: PUSH
5775: LD_INT 22
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: PUSH
5785: LD_INT 25
5787: PUSH
5788: LD_INT 4
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: PPUSH
5810: CALL_OW 69
5814: PUSH
5815: LD_EXP 18
5819: PUSH
5820: LD_EXP 20
5824: PUSH
5825: LD_EXP 21
5829: PUSH
5830: LD_EXP 19
5834: PUSH
5835: LD_EXP 22
5839: PUSH
5840: EMPTY
5841: LIST
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: DIFF
5847: ST_TO_ADDR
// DialogueOn ;
5848: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5852: LD_VAR 0 1
5856: PUSH
5857: LD_INT 1
5859: ARRAY
5860: PPUSH
5861: LD_STRING D7-Sci1-1
5863: PPUSH
5864: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5868: LD_EXP 18
5872: PPUSH
5873: LD_STRING D7-JMM-1
5875: PPUSH
5876: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5880: LD_VAR 0 1
5884: PUSH
5885: LD_INT 1
5887: ARRAY
5888: PPUSH
5889: LD_STRING D7-Sci1-2
5891: PPUSH
5892: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5896: LD_EXP 18
5900: PPUSH
5901: LD_STRING D7-JMM-2
5903: PPUSH
5904: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5908: LD_VAR 0 1
5912: PUSH
5913: LD_INT 1
5915: ARRAY
5916: PPUSH
5917: LD_STRING D7-Sci1-3
5919: PPUSH
5920: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5924: LD_EXP 18
5928: PPUSH
5929: LD_STRING D7-JMM-3
5931: PPUSH
5932: CALL_OW 88
// DialogueOff ;
5936: CALL_OW 7
// end ;
5940: PPOPN 1
5942: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5943: LD_EXP 10
5947: IFFALSE 9260
5949: GO 5951
5951: DISABLE
5952: LD_INT 0
5954: PPUSH
5955: PPUSH
5956: PPUSH
5957: PPUSH
5958: PPUSH
5959: PPUSH
5960: PPUSH
5961: PPUSH
// begin PrepareArabian ;
5962: CALL 11681 0 0
// repeat wait ( 0 0$01 ) ;
5966: LD_INT 35
5968: PPUSH
5969: CALL_OW 67
// until ar_spawned ;
5973: LD_EXP 11
5977: IFFALSE 5966
// DialogueOn ;
5979: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5983: LD_EXP 26
5987: PPUSH
5988: LD_STRING D8-Ar1-1
5990: PPUSH
5991: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5995: LD_EXP 18
5999: PPUSH
6000: LD_STRING D8-JMM-1
6002: PPUSH
6003: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6007: LD_EXP 26
6011: PPUSH
6012: LD_STRING D8-Ar1-2
6014: PPUSH
6015: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6019: LD_EXP 18
6023: PPUSH
6024: LD_STRING D8-JMM-2
6026: PPUSH
6027: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6031: LD_EXP 26
6035: PPUSH
6036: LD_STRING D8-Ar1-3
6038: PPUSH
6039: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6043: LD_EXP 18
6047: PPUSH
6048: LD_STRING D8-JMM-3
6050: PPUSH
6051: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6055: LD_EXP 26
6059: PPUSH
6060: LD_STRING D8-Ar1-4
6062: PPUSH
6063: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6067: LD_EXP 18
6071: PPUSH
6072: LD_STRING D8-JMM-4
6074: PPUSH
6075: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6079: LD_EXP 26
6083: PPUSH
6084: LD_STRING D8-Ar1-5
6086: PPUSH
6087: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6091: LD_EXP 18
6095: PPUSH
6096: LD_STRING D8-JMM-5
6098: PPUSH
6099: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6103: LD_EXP 26
6107: PPUSH
6108: LD_STRING D8-Ar1-6
6110: PPUSH
6111: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6115: LD_EXP 27
6119: PPUSH
6120: LD_STRING D8-Ar2-6
6122: PPUSH
6123: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6127: LD_EXP 18
6131: PPUSH
6132: LD_STRING D8-JMM-6
6134: PPUSH
6135: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6139: LD_EXP 27
6143: PPUSH
6144: LD_STRING D8-Ar2-7
6146: PPUSH
6147: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6151: LD_STRING QBarracks
6153: PPUSH
6154: CALL_OW 97
6158: PUSH
6159: LD_INT 1
6161: DOUBLE
6162: EQUAL
6163: IFTRUE 6167
6165: GO 6202
6167: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6168: LD_EXP 18
6172: PPUSH
6173: LD_STRING D8a-JMM-1
6175: PPUSH
6176: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6180: LD_EXP 26
6184: PPUSH
6185: LD_STRING D8a-Ar1-1
6187: PPUSH
6188: CALL_OW 94
// player_want_mortar := true ;
6192: LD_ADDR_EXP 12
6196: PUSH
6197: LD_INT 1
6199: ST_TO_ADDR
// end ; 2 :
6200: GO 6360
6202: LD_INT 2
6204: DOUBLE
6205: EQUAL
6206: IFTRUE 6210
6208: GO 6324
6210: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6211: LD_EXP 18
6215: PPUSH
6216: LD_STRING D8b-JMM-1
6218: PPUSH
6219: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6223: LD_EXP 26
6227: PPUSH
6228: LD_STRING D8b-Ar1-1
6230: PPUSH
6231: CALL_OW 94
// case Query ( QInfo ) of 1 :
6235: LD_STRING QInfo
6237: PPUSH
6238: CALL_OW 97
6242: PUSH
6243: LD_INT 1
6245: DOUBLE
6246: EQUAL
6247: IFTRUE 6251
6249: GO 6286
6251: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6252: LD_EXP 18
6256: PPUSH
6257: LD_STRING D8b1-JMM-1
6259: PPUSH
6260: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6264: LD_EXP 26
6268: PPUSH
6269: LD_STRING D8b1-Ar1-1
6271: PPUSH
6272: CALL_OW 94
// player_want_info := 2 ;
6276: LD_ADDR_EXP 13
6280: PUSH
6281: LD_INT 2
6283: ST_TO_ADDR
// end ; 2 :
6284: GO 6322
6286: LD_INT 2
6288: DOUBLE
6289: EQUAL
6290: IFTRUE 6294
6292: GO 6321
6294: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6295: LD_EXP 18
6299: PPUSH
6300: LD_STRING D8b2-JMM-1
6302: PPUSH
6303: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6307: LD_EXP 26
6311: PPUSH
6312: LD_STRING D8b2-Ar1-1
6314: PPUSH
6315: CALL_OW 94
// end ; end ;
6319: GO 6322
6321: POP
// end ; 3 :
6322: GO 6360
6324: LD_INT 3
6326: DOUBLE
6327: EQUAL
6328: IFTRUE 6332
6330: GO 6359
6332: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6333: LD_EXP 18
6337: PPUSH
6338: LD_STRING D8c-JMM-1
6340: PPUSH
6341: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6345: LD_EXP 26
6349: PPUSH
6350: LD_STRING D8c-Ar1-1
6352: PPUSH
6353: CALL_OW 94
// end ; end ;
6357: GO 6360
6359: POP
// DialogueOff ;
6360: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6364: LD_ADDR_VAR 0 4
6368: PUSH
6369: LD_INT 9
6371: PPUSH
6372: LD_INT 2
6374: PUSH
6375: LD_INT 30
6377: PUSH
6378: LD_INT 0
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 30
6387: PUSH
6388: LD_INT 1
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: LIST
6399: PPUSH
6400: CALL_OW 70
6404: ST_TO_ADDR
// if dep then
6405: LD_VAR 0 4
6409: IFFALSE 6425
// dep := dep [ 1 ] ;
6411: LD_ADDR_VAR 0 4
6415: PUSH
6416: LD_VAR 0 4
6420: PUSH
6421: LD_INT 1
6423: ARRAY
6424: ST_TO_ADDR
// if not dep then
6425: LD_VAR 0 4
6429: NOT
6430: IFFALSE 6468
// begin case Query ( QInfoNothing ) of 1 :
6432: LD_STRING QInfoNothing
6434: PPUSH
6435: CALL_OW 97
6439: PUSH
6440: LD_INT 1
6442: DOUBLE
6443: EQUAL
6444: IFTRUE 6448
6446: GO 6451
6448: POP
// ; end ;
6449: GO 6452
6451: POP
// player_want_info := false ;
6452: LD_ADDR_EXP 13
6456: PUSH
6457: LD_INT 0
6459: ST_TO_ADDR
// player_want_mortar := false ;
6460: LD_ADDR_EXP 12
6464: PUSH
6465: LD_INT 0
6467: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6468: LD_ADDR_VAR 0 3
6472: PUSH
6473: LD_INT 22
6475: PUSH
6476: LD_INT 2
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: LD_INT 21
6485: PUSH
6486: LD_INT 2
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: EMPTY
6494: LIST
6495: LIST
6496: PPUSH
6497: CALL_OW 69
6501: ST_TO_ADDR
// time := 1 1$35 ;
6502: LD_ADDR_VAR 0 5
6506: PUSH
6507: LD_INT 3325
6509: ST_TO_ADDR
// no_oil_gain := false ;
6510: LD_ADDR_VAR 0 6
6514: PUSH
6515: LD_INT 0
6517: ST_TO_ADDR
// first_warn := false ;
6518: LD_ADDR_VAR 0 7
6522: PUSH
6523: LD_INT 0
6525: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6526: LD_EXP 12
6530: PUSH
6531: LD_EXP 13
6535: OR
6536: IFFALSE 6641
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6538: LD_EXP 33
6542: PPUSH
6543: LD_INT 25
6545: PUSH
6546: LD_INT 1
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: PPUSH
6553: CALL_OW 72
6557: PPUSH
6558: LD_VAR 0 4
6562: PPUSH
6563: CALL_OW 250
6567: PPUSH
6568: LD_VAR 0 4
6572: PPUSH
6573: CALL_OW 251
6577: PPUSH
6578: LD_VAR 0 4
6582: PPUSH
6583: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6587: LD_EXP 33
6591: PPUSH
6592: LD_INT 25
6594: PUSH
6595: LD_INT 1
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: PPUSH
6602: CALL_OW 72
6606: PPUSH
6607: LD_INT 86
6609: PPUSH
6610: LD_INT 121
6612: PPUSH
6613: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6617: LD_EXP 33
6621: PPUSH
6622: LD_INT 25
6624: PUSH
6625: LD_INT 1
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PPUSH
6632: CALL_OW 72
6636: PPUSH
6637: CALL_OW 200
// end ; if player_attacked_ar then
6641: LD_EXP 16
6645: IFFALSE 6649
// exit ;
6647: GO 9260
// if player_want_mortar then
6649: LD_EXP 12
6653: IFFALSE 8062
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6655: LD_EXP 27
6659: PPUSH
6660: LD_VAR 0 4
6664: PPUSH
6665: CALL_OW 250
6669: PUSH
6670: LD_INT 1
6672: PLUS
6673: PPUSH
6674: LD_VAR 0 4
6678: PPUSH
6679: CALL_OW 251
6683: PUSH
6684: LD_INT 1
6686: PLUS
6687: PPUSH
6688: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6692: LD_INT 35
6694: PPUSH
6695: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6699: LD_EXP 27
6703: PPUSH
6704: LD_VAR 0 4
6708: PPUSH
6709: CALL_OW 296
6713: PUSH
6714: LD_INT 4
6716: LESS
6717: IFFALSE 6692
// for i = 1 to 6 do
6719: LD_ADDR_VAR 0 1
6723: PUSH
6724: DOUBLE
6725: LD_INT 1
6727: DEC
6728: ST_TO_ADDR
6729: LD_INT 6
6731: PUSH
6732: FOR_TO
6733: IFFALSE 6930
// begin if player_attacked_ar then
6735: LD_EXP 16
6739: IFFALSE 6745
// exit ;
6741: POP
6742: POP
6743: GO 9260
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL_OW 274
6754: PPUSH
6755: LD_INT 2
6757: PPUSH
6758: CALL_OW 275
6762: PUSH
6763: LD_INT 10
6765: LESS
6766: PUSH
6767: LD_VAR 0 7
6771: NOT
6772: AND
6773: IFFALSE 6836
// begin first_warn := true ;
6775: LD_ADDR_VAR 0 7
6779: PUSH
6780: LD_INT 1
6782: ST_TO_ADDR
// DialogueOn ;
6783: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6787: LD_EXP 28
6791: PPUSH
6792: LD_STRING D9a-FAr1-1
6794: PPUSH
6795: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6799: LD_EXP 18
6803: PPUSH
6804: LD_STRING D9a-JMM-1
6806: PPUSH
6807: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6811: LD_EXP 26
6815: PPUSH
6816: LD_STRING D9a2-Ar1-1
6818: PPUSH
6819: CALL_OW 88
// DialogueOff ;
6823: CALL_OW 7
// wait ( time ) ;
6827: LD_VAR 0 5
6831: PPUSH
6832: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6836: LD_VAR 0 4
6840: PPUSH
6841: CALL_OW 274
6845: PPUSH
6846: LD_INT 2
6848: PPUSH
6849: CALL_OW 275
6853: PUSH
6854: LD_INT 10
6856: LESS
6857: IFFALSE 6883
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6859: LD_EXP 26
6863: PPUSH
6864: LD_STRING D9a3-Ar1-1
6866: PPUSH
6867: CALL_OW 88
// no_oil_gain := true ;
6871: LD_ADDR_VAR 0 6
6875: PUSH
6876: LD_INT 1
6878: ST_TO_ADDR
// break ;
6879: GO 6930
// end else
6881: GO 6928
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6883: LD_EXP 27
6887: PPUSH
6888: LD_VAR 0 4
6892: PPUSH
6893: LD_INT 2
6895: PPUSH
6896: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6900: LD_EXP 27
6904: PPUSH
6905: LD_VAR 0 3
6909: PUSH
6910: LD_VAR 0 1
6914: PUSH
6915: LD_INT 3
6917: MOD
6918: PUSH
6919: LD_INT 1
6921: PLUS
6922: ARRAY
6923: PPUSH
6924: CALL_OW 210
// end ; end ;
6928: GO 6732
6930: POP
6931: POP
// if not no_oil_gain then
6932: LD_VAR 0 6
6936: NOT
6937: IFFALSE 8062
// begin repeat wait ( 0 0$01 ) ;
6939: LD_INT 35
6941: PPUSH
6942: CALL_OW 67
// if player_attacked_ar then
6946: LD_EXP 16
6950: IFFALSE 6954
// exit ;
6952: GO 9260
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6954: LD_VAR 0 3
6958: PUSH
6959: LD_INT 1
6961: ARRAY
6962: PPUSH
6963: CALL_OW 261
6967: PUSH
6968: LD_INT 80
6970: GREATER
6971: PUSH
6972: LD_VAR 0 3
6976: PUSH
6977: LD_INT 2
6979: ARRAY
6980: PPUSH
6981: CALL_OW 261
6985: PUSH
6986: LD_INT 80
6988: GREATER
6989: AND
6990: PUSH
6991: LD_VAR 0 3
6995: PUSH
6996: LD_INT 3
6998: ARRAY
6999: PPUSH
7000: CALL_OW 261
7004: PUSH
7005: LD_INT 80
7007: GREATER
7008: AND
7009: IFFALSE 6939
// ComMoveXY ( Gali , 105 , 127 ) ;
7011: LD_EXP 27
7015: PPUSH
7016: LD_INT 105
7018: PPUSH
7019: LD_INT 127
7021: PPUSH
7022: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7026: LD_EXP 27
7030: PPUSH
7031: LD_INT 2
7033: PPUSH
7034: CALL_OW 173
// AddComHold ( Gali ) ;
7038: LD_EXP 27
7042: PPUSH
7043: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7047: LD_INT 35
7049: PPUSH
7050: CALL_OW 67
// if player_attacked_ar then
7054: LD_EXP 16
7058: IFFALSE 7062
// exit ;
7060: GO 9260
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7062: LD_EXP 27
7066: PPUSH
7067: LD_INT 105
7069: PPUSH
7070: LD_INT 127
7072: PPUSH
7073: CALL_OW 297
7077: PUSH
7078: LD_INT 4
7080: LESS
7081: IFFALSE 7047
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7083: LD_VAR 0 4
7087: PPUSH
7088: CALL_OW 274
7092: PPUSH
7093: LD_INT 1
7095: PPUSH
7096: CALL_OW 275
7100: PUSH
7101: LD_INT 50
7103: LESS
7104: IFFALSE 7400
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7106: LD_VAR 0 4
7110: PPUSH
7111: CALL_OW 274
7115: PPUSH
7116: LD_INT 1
7118: PPUSH
7119: CALL_OW 275
7123: PUSH
7124: LD_INT 0
7126: DOUBLE
7127: GREATEREQUAL
7128: IFFALSE 7136
7130: LD_INT 24
7132: DOUBLE
7133: LESSEQUAL
7134: IFTRUE 7138
7136: GO 7153
7138: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7139: LD_EXP 27
7143: PPUSH
7144: LD_STRING D9b-Ar2-1
7146: PPUSH
7147: CALL_OW 88
7151: GO 7183
7153: LD_INT 25
7155: DOUBLE
7156: GREATEREQUAL
7157: IFFALSE 7165
7159: LD_INT 49
7161: DOUBLE
7162: LESSEQUAL
7163: IFTRUE 7167
7165: GO 7182
7167: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7168: LD_EXP 27
7172: PPUSH
7173: LD_STRING D9b-Ar2-1a
7175: PPUSH
7176: CALL_OW 88
7180: GO 7183
7182: POP
// Say ( JMM , D9b-JMM-1 ) ;
7183: LD_EXP 18
7187: PPUSH
7188: LD_STRING D9b-JMM-1
7190: PPUSH
7191: CALL_OW 88
// x := 0 0$0 ;
7195: LD_ADDR_VAR 0 2
7199: PUSH
7200: LD_INT 0
7202: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7203: LD_INT 35
7205: PPUSH
7206: CALL_OW 67
// x := x + 0 0$1 ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: LD_VAR 0 2
7219: PUSH
7220: LD_INT 35
7222: PLUS
7223: ST_TO_ADDR
// if player_attacked_ar then
7224: LD_EXP 16
7228: IFFALSE 7232
// exit ;
7230: GO 9260
// until x >= time ;
7232: LD_VAR 0 2
7236: PUSH
7237: LD_VAR 0 5
7241: GREATEREQUAL
7242: IFFALSE 7203
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7244: LD_VAR 0 4
7248: PPUSH
7249: CALL_OW 274
7253: PPUSH
7254: LD_INT 1
7256: PPUSH
7257: CALL_OW 275
7261: PUSH
7262: LD_INT 50
7264: LESS
7265: IFFALSE 7398
// begin DialogueOn ;
7267: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7271: LD_EXP 26
7275: PPUSH
7276: LD_STRING D9c-Ar1-1
7278: PPUSH
7279: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7283: LD_EXP 18
7287: PPUSH
7288: LD_STRING D9c-JMM-1
7290: PPUSH
7291: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7295: LD_EXP 26
7299: PPUSH
7300: LD_STRING D9c-Ar1-2
7302: PPUSH
7303: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7307: LD_EXP 28
7311: PPUSH
7312: LD_STRING D9c-FAr1-2
7314: PPUSH
7315: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7319: LD_EXP 26
7323: PPUSH
7324: LD_STRING D9c-Ar1-3
7326: PPUSH
7327: CALL_OW 88
// case Query ( QInfo ) of 1 :
7331: LD_STRING QInfo
7333: PPUSH
7334: CALL_OW 97
7338: PUSH
7339: LD_INT 1
7341: DOUBLE
7342: EQUAL
7343: IFTRUE 7347
7345: GO 7370
7347: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7348: LD_EXP 18
7352: PPUSH
7353: LD_STRING D8b1-JMM-1
7355: PPUSH
7356: CALL_OW 88
// player_want_info := 2 ;
7360: LD_ADDR_EXP 13
7364: PUSH
7365: LD_INT 2
7367: ST_TO_ADDR
// end ; 2 :
7368: GO 7394
7370: LD_INT 2
7372: DOUBLE
7373: EQUAL
7374: IFTRUE 7378
7376: GO 7393
7378: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7379: LD_EXP 26
7383: PPUSH
7384: LD_STRING D8b2-Ar1-1
7386: PPUSH
7387: CALL_OW 88
// end ; end ;
7391: GO 7394
7393: POP
// DialogueOff ;
7394: CALL_OW 7
// end ; end else
7398: GO 8062
// begin RemoveEnvironmentArea ( mortarArea ) ;
7400: LD_INT 2
7402: PPUSH
7403: CALL_OW 355
// wait ( 1 ) ;
7407: LD_INT 1
7409: PPUSH
7410: CALL_OW 67
// InGameOn ;
7414: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7418: LD_EXP 27
7422: PPUSH
7423: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7427: LD_EXP 27
7431: PPUSH
7432: LD_INT 1
7434: PPUSH
7435: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7439: LD_EXP 27
7443: PPUSH
7444: LD_INT 4
7446: PPUSH
7447: LD_INT 107
7449: PPUSH
7450: LD_INT 131
7452: PPUSH
7453: LD_INT 0
7455: PPUSH
7456: CALL_OW 145
// repeat wait ( 1 ) ;
7460: LD_INT 1
7462: PPUSH
7463: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7467: LD_INT 30
7469: PUSH
7470: LD_INT 4
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: PUSH
7477: LD_INT 23
7479: PUSH
7480: LD_INT 2
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PPUSH
7491: CALL_OW 69
7495: IFFALSE 7460
// SetSide ( Gali , 2 ) ;
7497: LD_EXP 27
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: CALL_OW 235
// InGameOff ;
7509: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7513: LD_ADDR_VAR 0 8
7517: PUSH
7518: LD_INT 30
7520: PUSH
7521: LD_INT 4
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 23
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PPUSH
7542: CALL_OW 69
7546: PUSH
7547: LD_INT 1
7549: ARRAY
7550: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7551: LD_INT 35
7553: PPUSH
7554: CALL_OW 67
// if player_attacked_ar then
7558: LD_EXP 16
7562: IFFALSE 7566
// exit ;
7564: GO 9260
// until BuildingStatus ( b ) <> bs_build ;
7566: LD_VAR 0 8
7570: PPUSH
7571: CALL_OW 461
7575: PUSH
7576: LD_INT 1
7578: NONEQUAL
7579: IFFALSE 7551
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7581: LD_VAR 0 8
7585: PPUSH
7586: CALL_OW 302
7590: PUSH
7591: LD_VAR 0 4
7595: PPUSH
7596: CALL_OW 274
7600: PPUSH
7601: LD_INT 1
7603: PPUSH
7604: CALL_OW 275
7608: PUSH
7609: LD_INT 25
7611: GREATEREQUAL
7612: AND
7613: IFFALSE 7712
// begin ComUpgrade ( b ) ;
7615: LD_VAR 0 8
7619: PPUSH
7620: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7624: LD_EXP 27
7628: PPUSH
7629: LD_STRING h
7631: PUSH
7632: LD_VAR 0 8
7636: PPUSH
7637: CALL_OW 250
7641: PUSH
7642: LD_VAR 0 8
7646: PPUSH
7647: CALL_OW 251
7651: PUSH
7652: LD_VAR 0 8
7656: PUSH
7657: LD_INT 0
7659: PUSH
7660: LD_INT 0
7662: PUSH
7663: LD_INT 0
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: PPUSH
7678: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7682: LD_INT 35
7684: PPUSH
7685: CALL_OW 67
// if player_attacked_ar then
7689: LD_EXP 16
7693: IFFALSE 7697
// exit ;
7695: GO 9260
// until BuildingStatus ( b ) <> bs_build ;
7697: LD_VAR 0 8
7701: PPUSH
7702: CALL_OW 461
7706: PUSH
7707: LD_INT 1
7709: NONEQUAL
7710: IFFALSE 7682
// end ; if b then
7712: LD_VAR 0 8
7716: IFFALSE 7727
// CenterNowOnUnits ( b ) ;
7718: LD_VAR 0 8
7722: PPUSH
7723: CALL_OW 87
// DialogueOn ;
7727: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7731: LD_EXP 27
7735: PPUSH
7736: LD_STRING D9d-Ar2-1
7738: PPUSH
7739: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7743: LD_EXP 26
7747: PPUSH
7748: LD_STRING D9d-Ar1-1
7750: PPUSH
7751: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7755: LD_EXP 18
7759: PPUSH
7760: LD_STRING D9d-JMM-1
7762: PPUSH
7763: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7767: LD_EXP 26
7771: PPUSH
7772: LD_STRING D9d-Ar1-2
7774: PPUSH
7775: CALL_OW 88
// DialogueOff ;
7779: CALL_OW 7
// i := [ ] ;
7783: LD_ADDR_VAR 0 1
7787: PUSH
7788: EMPTY
7789: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7790: LD_VAR 0 4
7794: PPUSH
7795: CALL_OW 274
7799: PPUSH
7800: LD_INT 3
7802: PPUSH
7803: CALL_OW 275
7807: PUSH
7808: LD_INT 20
7810: GREATEREQUAL
7811: IFFALSE 7830
// i := i ^ [ 1 ] ;
7813: LD_ADDR_VAR 0 1
7817: PUSH
7818: LD_VAR 0 1
7822: PUSH
7823: LD_INT 1
7825: PUSH
7826: EMPTY
7827: LIST
7828: ADD
7829: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7830: LD_VAR 0 4
7834: PPUSH
7835: CALL_OW 274
7839: PPUSH
7840: LD_INT 1
7842: PPUSH
7843: CALL_OW 275
7847: PUSH
7848: LD_INT 50
7850: GREATEREQUAL
7851: IFFALSE 7870
// i := i ^ [ 2 ] ;
7853: LD_ADDR_VAR 0 1
7857: PUSH
7858: LD_VAR 0 1
7862: PUSH
7863: LD_INT 2
7865: PUSH
7866: EMPTY
7867: LIST
7868: ADD
7869: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7870: LD_VAR 0 4
7874: PPUSH
7875: CALL_OW 274
7879: PPUSH
7880: LD_INT 2
7882: PPUSH
7883: CALL_OW 275
7887: PUSH
7888: LD_INT 80
7890: GREATEREQUAL
7891: IFFALSE 7910
// i := i ^ [ 3 ] ;
7893: LD_ADDR_VAR 0 1
7897: PUSH
7898: LD_VAR 0 1
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: ADD
7909: ST_TO_ADDR
// i := i diff 0 ;
7910: LD_ADDR_VAR 0 1
7914: PUSH
7915: LD_VAR 0 1
7919: PUSH
7920: LD_INT 0
7922: DIFF
7923: ST_TO_ADDR
// if i then
7924: LD_VAR 0 1
7928: IFFALSE 8034
// begin i := i ^ [ 4 ] ;
7930: LD_ADDR_VAR 0 1
7934: PUSH
7935: LD_VAR 0 1
7939: PUSH
7940: LD_INT 4
7942: PUSH
7943: EMPTY
7944: LIST
7945: ADD
7946: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7947: LD_STRING QInfo2
7949: PPUSH
7950: CALL_OW 97
7954: PUSH
7955: LD_INT 1
7957: DOUBLE
7958: EQUAL
7959: IFTRUE 7963
7961: GO 7974
7963: POP
// player_want_info := 3 ; 2 :
7964: LD_ADDR_EXP 13
7968: PUSH
7969: LD_INT 3
7971: ST_TO_ADDR
7972: GO 8032
7974: LD_INT 2
7976: DOUBLE
7977: EQUAL
7978: IFTRUE 7982
7980: GO 7993
7982: POP
// player_want_info := 1 ; 3 :
7983: LD_ADDR_EXP 13
7987: PUSH
7988: LD_INT 1
7990: ST_TO_ADDR
7991: GO 8032
7993: LD_INT 3
7995: DOUBLE
7996: EQUAL
7997: IFTRUE 8001
7999: GO 8012
8001: POP
// player_want_info := 2 ; 4 :
8002: LD_ADDR_EXP 13
8006: PUSH
8007: LD_INT 2
8009: ST_TO_ADDR
8010: GO 8032
8012: LD_INT 4
8014: DOUBLE
8015: EQUAL
8016: IFTRUE 8020
8018: GO 8031
8020: POP
// player_want_info := 0 ; end ;
8021: LD_ADDR_EXP 13
8025: PUSH
8026: LD_INT 0
8028: ST_TO_ADDR
8029: GO 8032
8031: POP
// end else
8032: GO 8062
// case Query ( QInfoNothing ) of 1 :
8034: LD_STRING QInfoNothing
8036: PPUSH
8037: CALL_OW 97
8041: PUSH
8042: LD_INT 1
8044: DOUBLE
8045: EQUAL
8046: IFTRUE 8050
8048: GO 8061
8050: POP
// player_want_info := 0 ; end ;
8051: LD_ADDR_EXP 13
8055: PUSH
8056: LD_INT 0
8058: ST_TO_ADDR
8059: GO 8062
8061: POP
// end ; end ; end ; if player_want_info then
8062: LD_EXP 13
8066: IFFALSE 9080
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8068: LD_ADDR_VAR 0 3
8072: PUSH
8073: LD_VAR 0 3
8077: PPUSH
8078: LD_INT 34
8080: PUSH
8081: LD_INT 32
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PPUSH
8088: CALL_OW 72
8092: ST_TO_ADDR
// if player_want_mortar then
8093: LD_EXP 12
8097: IFFALSE 8419
// begin case player_want_info of 1 :
8099: LD_EXP 13
8103: PUSH
8104: LD_INT 1
8106: DOUBLE
8107: EQUAL
8108: IFTRUE 8112
8110: GO 8123
8112: POP
// x := 5 ; 2 :
8113: LD_ADDR_VAR 0 2
8117: PUSH
8118: LD_INT 5
8120: ST_TO_ADDR
8121: GO 8162
8123: LD_INT 2
8125: DOUBLE
8126: EQUAL
8127: IFTRUE 8131
8129: GO 8142
8131: POP
// x := 8 ; 3 :
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: LD_INT 8
8139: ST_TO_ADDR
8140: GO 8162
8142: LD_INT 3
8144: DOUBLE
8145: EQUAL
8146: IFTRUE 8150
8148: GO 8161
8150: POP
// x := 2 ; end ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_INT 2
8158: ST_TO_ADDR
8159: GO 8162
8161: POP
// repeat wait ( 0 0$1 ) ;
8162: LD_INT 35
8164: PPUSH
8165: CALL_OW 67
// until not HasTask ( Gali ) ;
8169: LD_EXP 27
8173: PPUSH
8174: CALL_OW 314
8178: NOT
8179: IFFALSE 8162
// for i = 1 to x do
8181: LD_ADDR_VAR 0 1
8185: PUSH
8186: DOUBLE
8187: LD_INT 1
8189: DEC
8190: ST_TO_ADDR
8191: LD_VAR 0 2
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8362
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8199: LD_EXP 27
8203: PPUSH
8204: LD_VAR 0 4
8208: PPUSH
8209: LD_EXP 13
8213: PPUSH
8214: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8218: LD_EXP 27
8222: PPUSH
8223: LD_VAR 0 3
8227: PUSH
8228: LD_INT 1
8230: ARRAY
8231: PPUSH
8232: CALL_OW 172
// AddComHold ( Gali ) ;
8236: LD_EXP 27
8240: PPUSH
8241: CALL_OW 200
// repeat wait ( 3 ) ;
8245: LD_INT 3
8247: PPUSH
8248: CALL_OW 67
// if player_attacked_ar then
8252: LD_EXP 16
8256: IFFALSE 8262
// exit ;
8258: POP
8259: POP
8260: GO 9260
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8262: LD_EXP 27
8266: PPUSH
8267: LD_VAR 0 3
8271: PUSH
8272: LD_INT 1
8274: ARRAY
8275: PPUSH
8276: CALL_OW 296
8280: PUSH
8281: LD_INT 4
8283: LESS
8284: PUSH
8285: LD_EXP 27
8289: PPUSH
8290: LD_EXP 13
8294: PPUSH
8295: CALL_OW 289
8299: AND
8300: IFFALSE 8245
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8302: LD_VAR 0 3
8306: PUSH
8307: LD_INT 1
8309: ARRAY
8310: PPUSH
8311: LD_EXP 13
8315: PPUSH
8316: LD_VAR 0 3
8320: PUSH
8321: LD_INT 1
8323: ARRAY
8324: PPUSH
8325: LD_EXP 13
8329: PPUSH
8330: CALL_OW 289
8334: PUSH
8335: LD_INT 10
8337: PLUS
8338: PPUSH
8339: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8343: LD_EXP 27
8347: PPUSH
8348: LD_EXP 13
8352: PPUSH
8353: LD_INT 0
8355: PPUSH
8356: CALL_OW 290
// end ;
8360: GO 8196
8362: POP
8363: POP
// repeat wait ( 0 0$1 ) ;
8364: LD_INT 35
8366: PPUSH
8367: CALL_OW 67
// if player_attacked_ar then
8371: LD_EXP 16
8375: IFFALSE 8379
// exit ;
8377: GO 9260
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8379: LD_VAR 0 3
8383: PUSH
8384: LD_INT 1
8386: ARRAY
8387: PPUSH
8388: LD_EXP 13
8392: PPUSH
8393: CALL_OW 289
8397: PUSH
8398: LD_VAR 0 2
8402: PUSH
8403: LD_INT 10
8405: MUL
8406: EQUAL
8407: IFFALSE 8364
// no_oil_gain := false ;
8409: LD_ADDR_VAR 0 6
8413: PUSH
8414: LD_INT 0
8416: ST_TO_ADDR
// end else
8417: GO 8901
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8419: LD_ADDR_VAR 0 3
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_INT 2
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 21
8436: PUSH
8437: LD_INT 2
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: PPUSH
8448: CALL_OW 69
8452: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8453: LD_EXP 27
8457: PPUSH
8458: LD_VAR 0 4
8462: PPUSH
8463: CALL_OW 250
8467: PUSH
8468: LD_INT 1
8470: PLUS
8471: PPUSH
8472: LD_VAR 0 4
8476: PPUSH
8477: CALL_OW 251
8481: PUSH
8482: LD_INT 1
8484: PLUS
8485: PPUSH
8486: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8490: LD_INT 35
8492: PPUSH
8493: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8497: LD_EXP 27
8501: PPUSH
8502: LD_VAR 0 4
8506: PPUSH
8507: CALL_OW 296
8511: PUSH
8512: LD_INT 4
8514: LESS
8515: IFFALSE 8490
// for i = 1 to 6 do
8517: LD_ADDR_VAR 0 1
8521: PUSH
8522: DOUBLE
8523: LD_INT 1
8525: DEC
8526: ST_TO_ADDR
8527: LD_INT 6
8529: PUSH
8530: FOR_TO
8531: IFFALSE 8728
// begin if player_attacked_ar then
8533: LD_EXP 16
8537: IFFALSE 8543
// exit ;
8539: POP
8540: POP
8541: GO 9260
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8543: LD_VAR 0 4
8547: PPUSH
8548: CALL_OW 274
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 275
8560: PUSH
8561: LD_INT 10
8563: LESS
8564: PUSH
8565: LD_VAR 0 7
8569: NOT
8570: AND
8571: IFFALSE 8634
// begin first_warn := true ;
8573: LD_ADDR_VAR 0 7
8577: PUSH
8578: LD_INT 1
8580: ST_TO_ADDR
// DialogueOn ;
8581: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8585: LD_EXP 28
8589: PPUSH
8590: LD_STRING D9a-FAr1-1
8592: PPUSH
8593: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8597: LD_EXP 18
8601: PPUSH
8602: LD_STRING D9a-JMM-1
8604: PPUSH
8605: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8609: LD_EXP 26
8613: PPUSH
8614: LD_STRING D9a2-Ar1-1
8616: PPUSH
8617: CALL_OW 88
// DialogueOff ;
8621: CALL_OW 7
// wait ( time ) ;
8625: LD_VAR 0 5
8629: PPUSH
8630: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 274
8643: PPUSH
8644: LD_INT 2
8646: PPUSH
8647: CALL_OW 275
8651: PUSH
8652: LD_INT 10
8654: LESS
8655: IFFALSE 8681
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8657: LD_EXP 26
8661: PPUSH
8662: LD_STRING D9a3-Ar1-1
8664: PPUSH
8665: CALL_OW 88
// no_oil_gain := true ;
8669: LD_ADDR_VAR 0 6
8673: PUSH
8674: LD_INT 1
8676: ST_TO_ADDR
// break ;
8677: GO 8728
// end else
8679: GO 8726
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8681: LD_EXP 27
8685: PPUSH
8686: LD_VAR 0 4
8690: PPUSH
8691: LD_INT 2
8693: PPUSH
8694: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8698: LD_EXP 27
8702: PPUSH
8703: LD_VAR 0 3
8707: PUSH
8708: LD_VAR 0 1
8712: PUSH
8713: LD_INT 3
8715: MOD
8716: PUSH
8717: LD_INT 1
8719: PLUS
8720: ARRAY
8721: PPUSH
8722: CALL_OW 210
// end ; end ;
8726: GO 8530
8728: POP
8729: POP
// repeat wait ( 0 0$1 ) ;
8730: LD_INT 35
8732: PPUSH
8733: CALL_OW 67
// if player_attacked_ar then
8737: LD_EXP 16
8741: IFFALSE 8745
// exit ;
8743: GO 9260
// for i in tmp do
8745: LD_ADDR_VAR 0 1
8749: PUSH
8750: LD_VAR 0 3
8754: PUSH
8755: FOR_IN
8756: IFFALSE 8787
// if GetFuel ( i ) < 100 then
8758: LD_VAR 0 1
8762: PPUSH
8763: CALL_OW 261
8767: PUSH
8768: LD_INT 100
8770: LESS
8771: IFFALSE 8785
// begin x := i ;
8773: LD_ADDR_VAR 0 2
8777: PUSH
8778: LD_VAR 0 1
8782: ST_TO_ADDR
// break ;
8783: GO 8787
// end ;
8785: GO 8755
8787: POP
8788: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8789: LD_EXP 27
8793: PPUSH
8794: CALL_OW 314
8798: NOT
8799: PUSH
8800: LD_EXP 27
8804: PPUSH
8805: CALL_OW 281
8809: NOT
8810: AND
8811: IFFALSE 8844
// begin ComTransport ( Gali , dep , mat_oil ) ;
8813: LD_EXP 27
8817: PPUSH
8818: LD_VAR 0 4
8822: PPUSH
8823: LD_INT 2
8825: PPUSH
8826: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8830: LD_EXP 27
8834: PPUSH
8835: LD_VAR 0 2
8839: PPUSH
8840: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8844: LD_VAR 0 3
8848: PUSH
8849: LD_INT 1
8851: ARRAY
8852: PPUSH
8853: CALL_OW 261
8857: PUSH
8858: LD_INT 80
8860: GREATER
8861: PUSH
8862: LD_VAR 0 3
8866: PUSH
8867: LD_INT 2
8869: ARRAY
8870: PPUSH
8871: CALL_OW 261
8875: PUSH
8876: LD_INT 80
8878: GREATER
8879: AND
8880: PUSH
8881: LD_VAR 0 3
8885: PUSH
8886: LD_INT 3
8888: ARRAY
8889: PPUSH
8890: CALL_OW 261
8894: PUSH
8895: LD_INT 80
8897: GREATER
8898: AND
8899: IFFALSE 8730
// end ; ComHold ( Gali ) ;
8901: LD_EXP 27
8905: PPUSH
8906: CALL_OW 140
// if not no_oil_gain then
8910: LD_VAR 0 6
8914: NOT
8915: IFFALSE 9080
// begin DialogueOn ;
8917: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8921: LD_EXP 26
8925: PPUSH
8926: CALL_OW 87
// if player_want_mortar then
8930: LD_EXP 12
8934: IFFALSE 8960
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8936: LD_EXP 26
8940: PPUSH
8941: LD_STRING D9e-Ar1-1
8943: PPUSH
8944: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8948: LD_EXP 18
8952: PPUSH
8953: LD_STRING D10a-JMM-1
8955: PPUSH
8956: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8960: LD_EXP 26
8964: PPUSH
8965: LD_STRING D10a-Ar1-1
8967: PPUSH
8968: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8972: LD_EXP 27
8976: PPUSH
8977: LD_STRING D10a-Ar2-1
8979: PPUSH
8980: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8984: LD_EXP 28
8988: PPUSH
8989: LD_STRING D10a-FAr1-1
8991: PPUSH
8992: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8996: LD_EXP 27
9000: PPUSH
9001: LD_STRING D10a-Ar2-2
9003: PPUSH
9004: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9008: LD_EXP 28
9012: PPUSH
9013: LD_STRING D10a-FAr1-2
9015: PPUSH
9016: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9020: LD_EXP 26
9024: PPUSH
9025: LD_STRING D10a-Ar1-2
9027: PPUSH
9028: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9032: LD_EXP 18
9036: PPUSH
9037: LD_STRING D10a-JMM-2
9039: PPUSH
9040: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9044: LD_EXP 26
9048: PPUSH
9049: LD_STRING D10a-Ar1-3
9051: PPUSH
9052: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9056: LD_EXP 18
9060: PPUSH
9061: LD_STRING D10a-JMM-3
9063: PPUSH
9064: CALL_OW 88
// player_get_info := true ;
9068: LD_ADDR_EXP 15
9072: PUSH
9073: LD_INT 1
9075: ST_TO_ADDR
// DialogueOff ;
9076: CALL_OW 7
// end ; end ; if player_attacked_ar then
9080: LD_EXP 16
9084: IFFALSE 9088
// exit ;
9086: GO 9260
// if player_want_mortar or player_want_info then
9088: LD_EXP 12
9092: PUSH
9093: LD_EXP 13
9097: OR
9098: IFFALSE 9112
// Say ( Vervecken , D9f-Ar1-1 ) ;
9100: LD_EXP 26
9104: PPUSH
9105: LD_STRING D9f-Ar1-1
9107: PPUSH
9108: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9112: LD_INT 22
9114: PUSH
9115: LD_INT 2
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PPUSH
9122: CALL_OW 69
9126: PPUSH
9127: LD_INT 51
9129: PPUSH
9130: LD_INT 99
9132: PPUSH
9133: CALL_OW 111
// wait ( 0 0$1 ) ;
9137: LD_INT 35
9139: PPUSH
9140: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9144: LD_INT 22
9146: PUSH
9147: LD_INT 2
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: LD_INT 92
9156: PUSH
9157: LD_INT 51
9159: PUSH
9160: LD_INT 99
9162: PUSH
9163: LD_INT 2
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: PPUSH
9176: CALL_OW 69
9180: IFFALSE 9240
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9182: LD_ADDR_VAR 0 1
9186: PUSH
9187: LD_INT 22
9189: PUSH
9190: LD_INT 2
9192: PUSH
9193: EMPTY
9194: LIST
9195: LIST
9196: PUSH
9197: LD_INT 92
9199: PUSH
9200: LD_INT 51
9202: PUSH
9203: LD_INT 99
9205: PUSH
9206: LD_INT 2
9208: PUSH
9209: EMPTY
9210: LIST
9211: LIST
9212: LIST
9213: LIST
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: PPUSH
9219: CALL_OW 69
9223: PUSH
9224: FOR_IN
9225: IFFALSE 9238
// RemoveUnit ( i ) ;
9227: LD_VAR 0 1
9231: PPUSH
9232: CALL_OW 64
9236: GO 9224
9238: POP
9239: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9240: LD_INT 22
9242: PUSH
9243: LD_INT 2
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: PPUSH
9250: CALL_OW 69
9254: PUSH
9255: LD_INT 0
9257: EQUAL
9258: IFFALSE 9112
// end ;
9260: PPOPN 8
9262: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9263: LD_EXP 16
9267: IFFALSE 9620
9269: GO 9271
9271: DISABLE
9272: LD_INT 0
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
// begin ru_can_attack := true ;
9278: LD_ADDR_EXP 8
9282: PUSH
9283: LD_INT 1
9285: ST_TO_ADDR
// mine_launched := false ;
9286: LD_ADDR_VAR 0 3
9290: PUSH
9291: LD_INT 0
9293: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9294: LD_INT 22
9296: PUSH
9297: LD_INT 2
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PPUSH
9304: CALL_OW 69
9308: PPUSH
9309: LD_INT 51
9311: PPUSH
9312: LD_INT 99
9314: PPUSH
9315: CALL_OW 111
// if IsOk ( Vervecken ) then
9319: LD_EXP 26
9323: PPUSH
9324: CALL_OW 302
9328: IFFALSE 9342
// Say ( Vervecken , D11a-Ar1-1 ) ;
9330: LD_EXP 26
9334: PPUSH
9335: LD_STRING D11a-Ar1-1
9337: PPUSH
9338: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9342: LD_ADDR_VAR 0 2
9346: PUSH
9347: LD_EXP 33
9351: PPUSH
9352: LD_INT 25
9354: PUSH
9355: LD_INT 1
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PPUSH
9362: CALL_OW 72
9366: ST_TO_ADDR
// for i in tmp do
9367: LD_ADDR_VAR 0 1
9371: PUSH
9372: LD_VAR 0 2
9376: PUSH
9377: FOR_IN
9378: IFFALSE 9441
// if MineOfUnit ( i ) then
9380: LD_VAR 0 1
9384: PPUSH
9385: CALL_OW 459
9389: IFFALSE 9439
// begin x := MineOfUnit ( i ) ;
9391: LD_ADDR_VAR 0 4
9395: PUSH
9396: LD_VAR 0 1
9400: PPUSH
9401: CALL_OW 459
9405: ST_TO_ADDR
// mine_launched := true ;
9406: LD_ADDR_VAR 0 3
9410: PUSH
9411: LD_INT 1
9413: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9414: LD_VAR 0 4
9418: PUSH
9419: LD_INT 1
9421: ARRAY
9422: PPUSH
9423: LD_VAR 0 4
9427: PUSH
9428: LD_INT 2
9430: ARRAY
9431: PPUSH
9432: LD_INT 2
9434: PPUSH
9435: CALL_OW 456
// end ;
9439: GO 9377
9441: POP
9442: POP
// if mine_launched and IsOk ( Vervecken ) then
9443: LD_VAR 0 3
9447: PUSH
9448: LD_EXP 26
9452: PPUSH
9453: CALL_OW 302
9457: AND
9458: IFFALSE 9472
// Say ( Vervecken , D11b-Ar1-1 ) ;
9460: LD_EXP 26
9464: PPUSH
9465: LD_STRING D11b-Ar1-1
9467: PPUSH
9468: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9472: LD_INT 22
9474: PUSH
9475: LD_INT 2
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: PPUSH
9482: CALL_OW 69
9486: PPUSH
9487: LD_INT 51
9489: PPUSH
9490: LD_INT 99
9492: PPUSH
9493: CALL_OW 111
// wait ( 0 0$1 ) ;
9497: LD_INT 35
9499: PPUSH
9500: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9504: LD_INT 22
9506: PUSH
9507: LD_INT 2
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: PUSH
9514: LD_INT 92
9516: PUSH
9517: LD_INT 51
9519: PUSH
9520: LD_INT 99
9522: PUSH
9523: LD_INT 2
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PPUSH
9536: CALL_OW 69
9540: IFFALSE 9600
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9542: LD_ADDR_VAR 0 1
9546: PUSH
9547: LD_INT 22
9549: PUSH
9550: LD_INT 2
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: PUSH
9557: LD_INT 92
9559: PUSH
9560: LD_INT 51
9562: PUSH
9563: LD_INT 99
9565: PUSH
9566: LD_INT 2
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PPUSH
9579: CALL_OW 69
9583: PUSH
9584: FOR_IN
9585: IFFALSE 9598
// RemoveUnit ( i ) ;
9587: LD_VAR 0 1
9591: PPUSH
9592: CALL_OW 64
9596: GO 9584
9598: POP
9599: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9600: LD_INT 22
9602: PUSH
9603: LD_INT 2
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: PUSH
9615: LD_INT 0
9617: EQUAL
9618: IFFALSE 9472
// end ;
9620: PPOPN 4
9622: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9623: LD_EXP 10
9627: IFFALSE 9806
9629: GO 9631
9631: DISABLE
9632: LD_INT 0
9634: PPUSH
// begin Wait ( 10 10$00 ) ;
9635: LD_INT 21000
9637: PPUSH
9638: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9642: LD_INT 22
9644: PUSH
9645: LD_INT 2
9647: PUSH
9648: EMPTY
9649: LIST
9650: LIST
9651: PPUSH
9652: CALL_OW 69
9656: IFFALSE 9806
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9658: LD_INT 22
9660: PUSH
9661: LD_INT 2
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: PPUSH
9673: LD_INT 51
9675: PPUSH
9676: LD_INT 99
9678: PPUSH
9679: CALL_OW 114
// wait ( 0 0$1 ) ;
9683: LD_INT 35
9685: PPUSH
9686: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9690: LD_INT 22
9692: PUSH
9693: LD_INT 2
9695: PUSH
9696: EMPTY
9697: LIST
9698: LIST
9699: PUSH
9700: LD_INT 92
9702: PUSH
9703: LD_INT 51
9705: PUSH
9706: LD_INT 99
9708: PUSH
9709: LD_INT 2
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: PPUSH
9722: CALL_OW 69
9726: IFFALSE 9786
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9728: LD_ADDR_VAR 0 1
9732: PUSH
9733: LD_INT 22
9735: PUSH
9736: LD_INT 2
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: PUSH
9743: LD_INT 92
9745: PUSH
9746: LD_INT 51
9748: PUSH
9749: LD_INT 99
9751: PUSH
9752: LD_INT 2
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: PPUSH
9765: CALL_OW 69
9769: PUSH
9770: FOR_IN
9771: IFFALSE 9784
// RemoveUnit ( i ) ;
9773: LD_VAR 0 1
9777: PPUSH
9778: CALL_OW 64
9782: GO 9770
9784: POP
9785: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9786: LD_INT 22
9788: PUSH
9789: LD_INT 2
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: PPUSH
9796: CALL_OW 69
9800: PUSH
9801: LD_INT 0
9803: EQUAL
9804: IFFALSE 9658
// end ; end ;
9806: PPOPN 1
9808: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9809: LD_EXP 4
9813: IFFALSE 10741
9815: GO 9817
9817: DISABLE
9818: LD_INT 0
9820: PPUSH
9821: PPUSH
9822: PPUSH
// begin Wait ( game_time ) ;
9823: LD_EXP 7
9827: PPUSH
9828: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9832: LD_INT 35
9834: PPUSH
9835: CALL_OW 67
// until ( not ru_can_attack ) ;
9839: LD_EXP 8
9843: NOT
9844: IFFALSE 9832
// Wait ( 0 0$35 ) ;
9846: LD_INT 1225
9848: PPUSH
9849: CALL_OW 67
// DialogueOn ;
9853: CALL_OW 6
// InGameOn ;
9857: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9861: LD_EXP 25
9865: PPUSH
9866: LD_STRING D12-Pow-1
9868: PPUSH
9869: CALL_OW 94
// InGameOff ;
9873: CALL_OW 9
// DialogueOff ;
9877: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9881: LD_STRING M4
9883: PPUSH
9884: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9888: LD_INT 5
9890: PPUSH
9891: LD_INT 1
9893: PPUSH
9894: CALL_OW 424
// can_end := true ;
9898: LD_ADDR_EXP 17
9902: PUSH
9903: LD_INT 1
9905: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9906: LD_INT 35
9908: PPUSH
9909: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9913: CALL 784 0 0
9917: PUSH
9918: LD_INT 20
9920: GREATEREQUAL
9921: PUSH
9922: LD_INT 22
9924: PUSH
9925: LD_INT 1
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: PUSH
9932: LD_INT 21
9934: PUSH
9935: LD_INT 1
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PUSH
9942: EMPTY
9943: LIST
9944: LIST
9945: PPUSH
9946: CALL_OW 69
9950: PUSH
9951: LD_INT 5
9953: PPUSH
9954: LD_INT 22
9956: PUSH
9957: LD_INT 1
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: LD_INT 21
9966: PUSH
9967: LD_INT 1
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PPUSH
9978: CALL_OW 70
9982: PUSH
9983: LD_INT 22
9985: PUSH
9986: LD_INT 1
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 55
9995: PUSH
9996: EMPTY
9997: LIST
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: PPUSH
10003: CALL_OW 69
10007: PLUS
10008: LESSEQUAL
10009: AND
10010: IFFALSE 9906
// if not player_get_info then
10012: LD_EXP 15
10016: NOT
10017: IFFALSE 10028
// player_get_info := - 1 ;
10019: LD_ADDR_EXP 15
10023: PUSH
10024: LD_INT 1
10026: NEG
10027: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10028: LD_STRING Information
10030: PPUSH
10031: LD_EXP 15
10035: PPUSH
10036: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10040: LD_ADDR_VAR 0 2
10044: PUSH
10045: LD_INT 22
10047: PUSH
10048: LD_INT 1
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: PUSH
10055: LD_INT 2
10057: PUSH
10058: LD_INT 25
10060: PUSH
10061: LD_INT 2
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: LD_INT 25
10070: PUSH
10071: LD_INT 16
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 34
10080: PUSH
10081: LD_INT 12
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PPUSH
10098: CALL_OW 69
10102: ST_TO_ADDR
// sib := GetTerminalCargo ;
10103: LD_ADDR_VAR 0 3
10107: PUSH
10108: CALL 784 0 0
10112: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10113: LD_ADDR_VAR 0 3
10117: PUSH
10118: LD_VAR 0 3
10122: PUSH
10123: LD_INT 6
10125: PPUSH
10126: LD_INT 3
10128: PPUSH
10129: CALL_OW 287
10133: PLUS
10134: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10135: LD_ADDR_VAR 0 3
10139: PUSH
10140: LD_VAR 0 3
10144: PUSH
10145: LD_VAR 0 2
10149: PPUSH
10150: LD_INT 3
10152: PPUSH
10153: CALL_OW 289
10157: PLUS
10158: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10159: LD_VAR 0 3
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: LD_OWVAR 67
10171: PLUS
10172: PUSH
10173: LD_INT 50
10175: MUL
10176: LESS
10177: IFFALSE 10202
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10179: LD_STRING MuchSiberite
10181: PPUSH
10182: LD_INT 2
10184: NEG
10185: PUSH
10186: LD_OWVAR 67
10190: MUL
10191: PUSH
10192: LD_INT 1
10194: PLUS
10195: PPUSH
10196: CALL_OW 101
10200: GO 10212
// AddMedal ( MuchSiberite , 1 ) ;
10202: LD_STRING MuchSiberite
10204: PPUSH
10205: LD_INT 1
10207: PPUSH
10208: CALL_OW 101
// GiveMedals ( MAIN ) ;
10212: LD_STRING MAIN
10214: PPUSH
10215: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10219: LD_INT 22
10221: PUSH
10222: LD_INT 1
10224: PUSH
10225: EMPTY
10226: LIST
10227: LIST
10228: PUSH
10229: LD_INT 2
10231: PUSH
10232: LD_INT 25
10234: PUSH
10235: LD_INT 1
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PUSH
10242: LD_INT 25
10244: PUSH
10245: LD_INT 2
10247: PUSH
10248: EMPTY
10249: LIST
10250: LIST
10251: PUSH
10252: LD_INT 25
10254: PUSH
10255: LD_INT 3
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: PUSH
10262: LD_INT 25
10264: PUSH
10265: LD_INT 4
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 25
10274: PUSH
10275: LD_INT 8
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: PPUSH
10294: CALL_OW 69
10298: PPUSH
10299: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10303: LD_ADDR_VAR 0 2
10307: PUSH
10308: LD_INT 22
10310: PUSH
10311: LD_INT 1
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 25
10320: PUSH
10321: LD_INT 8
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: PUSH
10328: EMPTY
10329: LIST
10330: LIST
10331: PPUSH
10332: CALL_OW 69
10336: ST_TO_ADDR
// if tmp then
10337: LD_VAR 0 2
10341: IFFALSE 10372
// for i in tmp do
10343: LD_ADDR_VAR 0 1
10347: PUSH
10348: LD_VAR 0 2
10352: PUSH
10353: FOR_IN
10354: IFFALSE 10370
// SetClass ( i , 1 ) ;
10356: LD_VAR 0 1
10360: PPUSH
10361: LD_INT 1
10363: PPUSH
10364: CALL_OW 336
10368: GO 10353
10370: POP
10371: POP
// SaveVariable ( sib , 09_sibRes ) ;
10372: LD_VAR 0 3
10376: PPUSH
10377: LD_STRING 09_sibRes
10379: PPUSH
10380: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10384: LD_EXP 15
10388: PPUSH
10389: LD_STRING 09_arInfo
10391: PPUSH
10392: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10396: LD_EXP 18
10400: PPUSH
10401: LD_EXP 1
10405: PUSH
10406: LD_STRING JMM
10408: STR
10409: PPUSH
10410: CALL_OW 38
// if IsLive ( Gary ) then
10414: LD_EXP 19
10418: PPUSH
10419: CALL_OW 300
10423: IFFALSE 10443
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10425: LD_EXP 19
10429: PPUSH
10430: LD_EXP 1
10434: PUSH
10435: LD_STRING Gary
10437: STR
10438: PPUSH
10439: CALL_OW 38
// if IsLive ( Bobby ) then
10443: LD_EXP 20
10447: PPUSH
10448: CALL_OW 300
10452: IFFALSE 10472
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10454: LD_EXP 20
10458: PPUSH
10459: LD_EXP 1
10463: PUSH
10464: LD_STRING Bobby
10466: STR
10467: PPUSH
10468: CALL_OW 38
// if IsLive ( Cyrus ) then
10472: LD_EXP 21
10476: PPUSH
10477: CALL_OW 300
10481: IFFALSE 10501
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10483: LD_EXP 21
10487: PPUSH
10488: LD_EXP 1
10492: PUSH
10493: LD_STRING Cyrus
10495: STR
10496: PPUSH
10497: CALL_OW 38
// if IsLive ( Houten ) then
10501: LD_EXP 22
10505: PPUSH
10506: CALL_OW 300
10510: IFFALSE 10530
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10512: LD_EXP 22
10516: PPUSH
10517: LD_EXP 1
10521: PUSH
10522: LD_STRING Houten
10524: STR
10525: PPUSH
10526: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10530: LD_ADDR_VAR 0 2
10534: PUSH
10535: LD_INT 22
10537: PUSH
10538: LD_INT 1
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: PUSH
10545: LD_INT 2
10547: PUSH
10548: LD_INT 25
10550: PUSH
10551: LD_INT 1
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: PUSH
10558: LD_INT 25
10560: PUSH
10561: LD_INT 2
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 25
10570: PUSH
10571: LD_INT 3
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PUSH
10578: LD_INT 25
10580: PUSH
10581: LD_INT 4
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: PPUSH
10599: CALL_OW 69
10603: PUSH
10604: LD_EXP 18
10608: PUSH
10609: LD_EXP 21
10613: PUSH
10614: LD_EXP 20
10618: PUSH
10619: LD_EXP 22
10623: PUSH
10624: LD_EXP 19
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: LIST
10635: DIFF
10636: ST_TO_ADDR
// if tmp then
10637: LD_VAR 0 2
10641: IFFALSE 10661
// SaveCharacters ( tmp , mission_prefix & others ) ;
10643: LD_VAR 0 2
10647: PPUSH
10648: LD_EXP 1
10652: PUSH
10653: LD_STRING others
10655: STR
10656: PPUSH
10657: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10661: LD_ADDR_VAR 0 2
10665: PUSH
10666: LD_INT 22
10668: PUSH
10669: LD_INT 1
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: PUSH
10676: LD_INT 2
10678: PUSH
10679: LD_INT 25
10681: PUSH
10682: LD_INT 12
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PUSH
10689: LD_INT 25
10691: PUSH
10692: LD_INT 16
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: LIST
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PPUSH
10708: CALL_OW 69
10712: ST_TO_ADDR
// if tmp then
10713: LD_VAR 0 2
10717: IFFALSE 10737
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10719: LD_VAR 0 2
10723: PPUSH
10724: LD_EXP 1
10728: PUSH
10729: LD_STRING apes
10731: STR
10732: PPUSH
10733: CALL_OW 38
// YouWin ;
10737: CALL_OW 103
// end ; end_of_file
10741: PPOPN 3
10743: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10744: LD_VAR 0 1
10748: PPUSH
10749: CALL_OW 266
10753: PUSH
10754: LD_INT 0
10756: EQUAL
10757: PUSH
10758: LD_EXP 3
10762: NOT
10763: AND
10764: IFFALSE 10788
// begin terminal := b ;
10766: LD_ADDR_EXP 3
10770: PUSH
10771: LD_VAR 0 1
10775: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10776: LD_EXP 3
10780: PPUSH
10781: LD_STRING terminal
10783: PPUSH
10784: CALL_OW 500
// end ; end ;
10788: PPOPN 2
10790: END
// on BuildingComplete ( b ) do var i ;
10791: LD_INT 0
10793: PPUSH
// begin if GetSide ( b ) = 3 then
10794: LD_VAR 0 1
10798: PPUSH
10799: CALL_OW 255
10803: PUSH
10804: LD_INT 3
10806: EQUAL
10807: IFFALSE 10847
// for i = 1 to 4 do
10809: LD_ADDR_VAR 0 2
10813: PUSH
10814: DOUBLE
10815: LD_INT 1
10817: DEC
10818: ST_TO_ADDR
10819: LD_INT 4
10821: PUSH
10822: FOR_TO
10823: IFFALSE 10845
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10825: LD_ADDR_EXP 36
10829: PUSH
10830: LD_EXP 36
10834: PPUSH
10835: LD_INT 1
10837: PPUSH
10838: CALL_OW 3
10842: ST_TO_ADDR
10843: GO 10822
10845: POP
10846: POP
// end ;
10847: PPOPN 2
10849: END
// on VehicleConstructed ( veh , fac ) do var i ;
10850: LD_INT 0
10852: PPUSH
// begin if GetSide ( veh ) = 3 then
10853: LD_VAR 0 1
10857: PPUSH
10858: CALL_OW 255
10862: PUSH
10863: LD_INT 3
10865: EQUAL
10866: IFFALSE 10991
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10868: LD_VAR 0 1
10872: PPUSH
10873: CALL_OW 264
10877: PUSH
10878: LD_INT 53
10880: PUSH
10881: LD_INT 52
10883: PUSH
10884: LD_INT 51
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: LIST
10891: IN
10892: NOT
10893: IFFALSE 10911
// ru_force := ru_force ^ veh ;
10895: LD_ADDR_EXP 35
10899: PUSH
10900: LD_EXP 35
10904: PUSH
10905: LD_VAR 0 1
10909: ADD
10910: ST_TO_ADDR
// for i = 1 to 4 do
10911: LD_ADDR_VAR 0 3
10915: PUSH
10916: DOUBLE
10917: LD_INT 1
10919: DEC
10920: ST_TO_ADDR
10921: LD_INT 4
10923: PUSH
10924: FOR_TO
10925: IFFALSE 10947
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10927: LD_ADDR_EXP 37
10931: PUSH
10932: LD_EXP 37
10936: PPUSH
10937: LD_INT 1
10939: PPUSH
10940: CALL_OW 3
10944: ST_TO_ADDR
10945: GO 10924
10947: POP
10948: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10949: LD_VAR 0 1
10953: PPUSH
10954: CALL_OW 264
10958: PUSH
10959: LD_INT 53
10961: EQUAL
10962: IFFALSE 10991
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10964: LD_VAR 0 1
10968: PPUSH
10969: LD_INT 7
10971: PPUSH
10972: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10976: LD_VAR 0 1
10980: PPUSH
10981: LD_INT 170
10983: PPUSH
10984: LD_INT 235
10986: PPUSH
10987: CALL_OW 171
// end ; end ; end ;
10991: PPOPN 3
10993: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10994: LD_VAR 0 1
10998: PUSH
10999: LD_INT 1
11001: EQUAL
11002: PUSH
11003: LD_VAR 0 2
11007: PUSH
11008: LD_INT 2
11010: EQUAL
11011: AND
11012: PUSH
11013: LD_VAR 0 1
11017: PUSH
11018: LD_INT 2
11020: EQUAL
11021: PUSH
11022: LD_VAR 0 2
11026: PUSH
11027: LD_INT 1
11029: EQUAL
11030: AND
11031: OR
11032: IFFALSE 11042
// player_attacked_ar := true ;
11034: LD_ADDR_EXP 16
11038: PUSH
11039: LD_INT 1
11041: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11042: LD_VAR 0 1
11046: PUSH
11047: LD_INT 1
11049: EQUAL
11050: PUSH
11051: LD_VAR 0 2
11055: PUSH
11056: LD_INT 4
11058: EQUAL
11059: AND
11060: PUSH
11061: LD_VAR 0 1
11065: PUSH
11066: LD_INT 4
11068: EQUAL
11069: PUSH
11070: LD_VAR 0 2
11074: PUSH
11075: LD_INT 1
11077: EQUAL
11078: AND
11079: OR
11080: IFFALSE 11089
// YouLost ( Traitor ) ;
11082: LD_STRING Traitor
11084: PPUSH
11085: CALL_OW 104
// end ;
11089: PPOPN 2
11091: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11092: LD_VAR 0 1
11096: PUSH
11097: LD_EXP 18
11101: EQUAL
11102: IFFALSE 11111
// YouLost ( JMM ) ;
11104: LD_STRING JMM
11106: PPUSH
11107: CALL_OW 104
// if un = terminal then
11111: LD_VAR 0 1
11115: PUSH
11116: LD_EXP 3
11120: EQUAL
11121: IFFALSE 11130
// YouLost ( Terminal ) ;
11123: LD_STRING Terminal
11125: PPUSH
11126: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11130: LD_VAR 0 1
11134: PUSH
11135: LD_INT 22
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PPUSH
11159: CALL_OW 69
11163: IN
11164: IFFALSE 11310
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11166: LD_VAR 0 1
11170: PPUSH
11171: CALL_OW 266
11175: PUSH
11176: LD_INT 33
11178: PUSH
11179: LD_INT 26
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: IN
11186: IFFALSE 11245
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11188: LD_ADDR_EXP 36
11192: PUSH
11193: LD_EXP 36
11197: PUSH
11198: LD_VAR 0 1
11202: PPUSH
11203: CALL_OW 266
11207: PUSH
11208: LD_VAR 0 1
11212: PPUSH
11213: CALL_OW 250
11217: PUSH
11218: LD_VAR 0 1
11222: PPUSH
11223: CALL_OW 251
11227: PUSH
11228: LD_VAR 0 1
11232: PPUSH
11233: CALL_OW 254
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: ADD
11244: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11245: LD_VAR 0 1
11249: PPUSH
11250: CALL_OW 266
11254: PUSH
11255: LD_INT 5
11257: EQUAL
11258: IFFALSE 11310
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11260: LD_ADDR_EXP 36
11264: PUSH
11265: LD_EXP 36
11269: PUSH
11270: LD_INT 4
11272: PUSH
11273: LD_VAR 0 1
11277: PPUSH
11278: CALL_OW 250
11282: PUSH
11283: LD_VAR 0 1
11287: PPUSH
11288: CALL_OW 251
11292: PUSH
11293: LD_VAR 0 1
11297: PPUSH
11298: CALL_OW 254
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: ADD
11309: ST_TO_ADDR
// end ; if un in ru_force then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 35
11319: IN
11320: IFFALSE 11356
// begin ru_force := ru_force diff un ;
11322: LD_ADDR_EXP 35
11326: PUSH
11327: LD_EXP 35
11331: PUSH
11332: LD_VAR 0 1
11336: DIFF
11337: ST_TO_ADDR
// if ru_force = 0 then
11338: LD_EXP 35
11342: PUSH
11343: LD_INT 0
11345: EQUAL
11346: IFFALSE 11356
// ru_can_attack := false ;
11348: LD_ADDR_EXP 8
11352: PUSH
11353: LD_INT 0
11355: ST_TO_ADDR
// end ; end ; end_of_file
11356: PPOPN 1
11358: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11359: LD_EXP 5
11363: PUSH
11364: LD_EXP 6
11368: AND
11369: IFFALSE 11447
11371: GO 11373
11373: DISABLE
11374: LD_INT 0
11376: PPUSH
// begin enable ;
11377: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11378: LD_ADDR_VAR 0 1
11382: PUSH
11383: LD_INT 60
11385: PUSH
11386: CALL 784 0 0
11390: MINUS
11391: ST_TO_ADDR
// if sib < 0 then
11392: LD_VAR 0 1
11396: PUSH
11397: LD_INT 0
11399: LESS
11400: IFFALSE 11410
// sib := 0 ;
11402: LD_ADDR_VAR 0 1
11406: PUSH
11407: LD_INT 0
11409: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11410: LD_ADDR_OWVAR 47
11414: PUSH
11415: LD_STRING #Am09-1
11417: PUSH
11418: LD_VAR 0 1
11422: PUSH
11423: LD_EXP 6
11427: PUSH
11428: EMPTY
11429: LIST
11430: LIST
11431: LIST
11432: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11433: LD_ADDR_EXP 6
11437: PUSH
11438: LD_EXP 6
11442: PUSH
11443: LD_INT 35
11445: MINUS
11446: ST_TO_ADDR
// end ;
11447: PPOPN 1
11449: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11450: LD_EXP 6
11454: PUSH
11455: LD_INT 0
11457: EQUAL
11458: IFFALSE 11470
11460: GO 11462
11462: DISABLE
// display_strings := [ ] ;
11463: LD_ADDR_OWVAR 47
11467: PUSH
11468: EMPTY
11469: ST_TO_ADDR
11470: END
// every 0 0$01 trigger ru_force and debug do
11471: LD_EXP 35
11475: PUSH
11476: LD_EXP 2
11480: AND
11481: IFFALSE 11497
11483: GO 11485
11485: DISABLE
// begin enable ;
11486: ENABLE
// display_strings := ru_force ;
11487: LD_ADDR_OWVAR 47
11491: PUSH
11492: LD_EXP 35
11496: ST_TO_ADDR
// end ;
11497: END
// every 1 1$35 do var i , tmp ;
11498: GO 11500
11500: DISABLE
11501: LD_INT 0
11503: PPUSH
11504: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11505: LD_ADDR_VAR 0 2
11509: PUSH
11510: LD_INT 1155
11512: PUSH
11513: LD_INT 1225
11515: PUSH
11516: LD_INT 1435
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: LIST
11523: PUSH
11524: LD_OWVAR 67
11528: ARRAY
11529: ST_TO_ADDR
// i := 0 ;
11530: LD_ADDR_VAR 0 1
11534: PUSH
11535: LD_INT 0
11537: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11538: LD_INT 1
11540: PPUSH
11541: LD_INT 5
11543: PPUSH
11544: CALL_OW 12
11548: PPUSH
11549: LD_INT 75
11551: PPUSH
11552: LD_INT 75
11554: PPUSH
11555: LD_INT 20
11557: PPUSH
11558: LD_INT 1
11560: PPUSH
11561: CALL_OW 56
// wait ( tmp ) ;
11565: LD_VAR 0 2
11569: PPUSH
11570: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11574: LD_ADDR_VAR 0 2
11578: PUSH
11579: LD_VAR 0 2
11583: PUSH
11584: LD_INT 105
11586: PPUSH
11587: LD_INT 315
11589: PPUSH
11590: CALL_OW 12
11594: PLUS
11595: ST_TO_ADDR
// i := i + 1 ;
11596: LD_ADDR_VAR 0 1
11600: PUSH
11601: LD_VAR 0 1
11605: PUSH
11606: LD_INT 1
11608: PLUS
11609: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: PUSH
11623: LD_EXP 4
11627: AND
11628: IFFALSE 11666
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11630: LD_INT 2
11632: PPUSH
11633: LD_INT 5
11635: PPUSH
11636: CALL_OW 12
11640: PPUSH
11641: LD_INT 8
11643: PPUSH
11644: LD_INT 1
11646: PPUSH
11647: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11651: LD_INT 665
11653: PPUSH
11654: LD_INT 735
11656: PPUSH
11657: CALL_OW 12
11661: PPUSH
11662: CALL_OW 67
// end ; until tick > game_time ;
11666: LD_OWVAR 1
11670: PUSH
11671: LD_EXP 7
11675: GREATER
11676: IFFALSE 11538
// end ; end_of_file
11678: PPOPN 2
11680: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11681: LD_INT 0
11683: PPUSH
11684: PPUSH
11685: PPUSH
11686: PPUSH
11687: PPUSH
11688: PPUSH
// x := 76 ;
11689: LD_ADDR_VAR 0 5
11693: PUSH
11694: LD_INT 76
11696: ST_TO_ADDR
// y := 147 ;
11697: LD_ADDR_VAR 0 6
11701: PUSH
11702: LD_INT 147
11704: ST_TO_ADDR
// uc_side := 2 ;
11705: LD_ADDR_OWVAR 20
11709: PUSH
11710: LD_INT 2
11712: ST_TO_ADDR
// uc_nation := 2 ;
11713: LD_ADDR_OWVAR 21
11717: PUSH
11718: LD_INT 2
11720: ST_TO_ADDR
// InitHc ;
11721: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11725: LD_INT 1
11727: PPUSH
11728: LD_INT 1
11730: PPUSH
11731: LD_INT 6
11733: PPUSH
11734: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11738: LD_ADDR_OWVAR 26
11742: PUSH
11743: LD_STRING Nicolas Vervecken
11745: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11746: LD_ADDR_OWVAR 33
11750: PUSH
11751: LD_STRING SecondCharsGal
11753: ST_TO_ADDR
// hc_face_number := 3 ;
11754: LD_ADDR_OWVAR 34
11758: PUSH
11759: LD_INT 3
11761: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11762: LD_ADDR_OWVAR 29
11766: PUSH
11767: LD_INT 11
11769: PUSH
11770: LD_INT 10
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: ST_TO_ADDR
// Vervecken := CreateHuman ;
11777: LD_ADDR_EXP 26
11781: PUSH
11782: CALL_OW 44
11786: ST_TO_ADDR
// ar_force := Vervecken ;
11787: LD_ADDR_EXP 33
11791: PUSH
11792: LD_EXP 26
11796: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11797: LD_INT 1
11799: PPUSH
11800: LD_INT 2
11802: PPUSH
11803: LD_INT 6
11805: PPUSH
11806: CALL_OW 380
// hc_name := Louis Gali ;
11810: LD_ADDR_OWVAR 26
11814: PUSH
11815: LD_STRING Louis Gali
11817: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11818: LD_ADDR_OWVAR 33
11822: PUSH
11823: LD_STRING SecondCharsGal
11825: ST_TO_ADDR
// hc_face_number := 2 ;
11826: LD_ADDR_OWVAR 34
11830: PUSH
11831: LD_INT 2
11833: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11834: LD_ADDR_OWVAR 29
11838: PUSH
11839: LD_INT 10
11841: PUSH
11842: LD_INT 11
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: ST_TO_ADDR
// Gali := CreateHuman ;
11849: LD_ADDR_EXP 27
11853: PUSH
11854: CALL_OW 44
11858: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11859: LD_ADDR_EXP 33
11863: PUSH
11864: LD_EXP 33
11868: PUSH
11869: LD_EXP 27
11873: ADD
11874: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11875: LD_INT 2
11877: PPUSH
11878: LD_INT 1
11880: PPUSH
11881: LD_INT 6
11883: PPUSH
11884: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11888: LD_ADDR_OWVAR 26
11892: PUSH
11893: LD_STRING Maria Bogdanovic
11895: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11896: LD_ADDR_OWVAR 33
11900: PUSH
11901: LD_STRING SecondCharsGal
11903: ST_TO_ADDR
// hc_face_number := 14 ;
11904: LD_ADDR_OWVAR 34
11908: PUSH
11909: LD_INT 14
11911: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11912: LD_ADDR_OWVAR 29
11916: PUSH
11917: LD_INT 12
11919: PUSH
11920: LD_INT 9
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11927: LD_ADDR_EXP 28
11931: PUSH
11932: CALL_OW 44
11936: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11937: LD_ADDR_EXP 33
11941: PUSH
11942: LD_EXP 33
11946: PUSH
11947: LD_EXP 28
11951: ADD
11952: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11953: LD_INT 1
11955: PPUSH
11956: LD_INT 3
11958: PPUSH
11959: LD_INT 6
11961: PPUSH
11962: CALL_OW 380
// hc_name = Kntor Radomr ;
11966: LD_ADDR_OWVAR 26
11970: PUSH
11971: LD_STRING Kntor Radomr
11973: ST_TO_ADDR
// hc_gallery = sandar ;
11974: LD_ADDR_OWVAR 33
11978: PUSH
11979: LD_STRING sandar
11981: ST_TO_ADDR
// hc_face_number = 12 ;
11982: LD_ADDR_OWVAR 34
11986: PUSH
11987: LD_INT 12
11989: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11990: LD_ADDR_OWVAR 29
11994: PUSH
11995: LD_INT 9
11997: PUSH
11998: LD_INT 9
12000: PUSH
12001: EMPTY
12002: LIST
12003: LIST
12004: ST_TO_ADDR
// Kantor = CreateHuman ;
12005: LD_ADDR_EXP 29
12009: PUSH
12010: CALL_OW 44
12014: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12015: LD_ADDR_EXP 33
12019: PUSH
12020: LD_EXP 33
12024: PUSH
12025: LD_EXP 29
12029: ADD
12030: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12031: LD_INT 1
12033: PPUSH
12034: LD_INT 3
12036: PPUSH
12037: LD_INT 6
12039: PPUSH
12040: CALL_OW 380
// hc_name = Herczeg Farkas ;
12044: LD_ADDR_OWVAR 26
12048: PUSH
12049: LD_STRING Herczeg Farkas
12051: ST_TO_ADDR
// hc_gallery = sandar ;
12052: LD_ADDR_OWVAR 33
12056: PUSH
12057: LD_STRING sandar
12059: ST_TO_ADDR
// hc_face_number = 28 ;
12060: LD_ADDR_OWVAR 34
12064: PUSH
12065: LD_INT 28
12067: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12068: LD_ADDR_OWVAR 29
12072: PUSH
12073: LD_INT 10
12075: PUSH
12076: LD_INT 9
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: ST_TO_ADDR
// Herczeg = CreateHuman ;
12083: LD_ADDR_EXP 30
12087: PUSH
12088: CALL_OW 44
12092: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12093: LD_ADDR_EXP 33
12097: PUSH
12098: LD_EXP 33
12102: PUSH
12103: LD_EXP 30
12107: ADD
12108: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12109: LD_INT 1
12111: PPUSH
12112: LD_INT 1
12114: PPUSH
12115: LD_INT 6
12117: PPUSH
12118: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12122: LD_ADDR_OWVAR 26
12126: PUSH
12127: LD_STRING Ronn Horntvedt
12129: ST_TO_ADDR
// hc_gallery = sandar ;
12130: LD_ADDR_OWVAR 33
12134: PUSH
12135: LD_STRING sandar
12137: ST_TO_ADDR
// hc_face_number = 29 ;
12138: LD_ADDR_OWVAR 34
12142: PUSH
12143: LD_INT 29
12145: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12146: LD_ADDR_OWVAR 29
12150: PUSH
12151: LD_INT 11
12153: PUSH
12154: LD_INT 11
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: ST_TO_ADDR
// Ronn = CreateHuman ;
12161: LD_ADDR_EXP 31
12165: PUSH
12166: CALL_OW 44
12170: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12171: LD_ADDR_EXP 33
12175: PUSH
12176: LD_EXP 33
12180: PUSH
12181: LD_EXP 31
12185: ADD
12186: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12187: LD_INT 2
12189: PPUSH
12190: LD_INT 3
12192: PPUSH
12193: LD_INT 6
12195: PPUSH
12196: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12200: LD_ADDR_OWVAR 26
12204: PUSH
12205: LD_STRING Mia D. Mathiasen
12207: ST_TO_ADDR
// hc_gallery = sandar ;
12208: LD_ADDR_OWVAR 33
12212: PUSH
12213: LD_STRING sandar
12215: ST_TO_ADDR
// hc_face_number = 31 ;
12216: LD_ADDR_OWVAR 34
12220: PUSH
12221: LD_INT 31
12223: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12224: LD_ADDR_OWVAR 29
12228: PUSH
12229: LD_INT 10
12231: PUSH
12232: LD_INT 10
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: ST_TO_ADDR
// Mia = CreateHuman ;
12239: LD_ADDR_EXP 32
12243: PUSH
12244: CALL_OW 44
12248: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12249: LD_ADDR_EXP 33
12253: PUSH
12254: LD_EXP 33
12258: PUSH
12259: LD_EXP 32
12263: ADD
12264: ST_TO_ADDR
// for i = 1 to 2 do
12265: LD_ADDR_VAR 0 4
12269: PUSH
12270: DOUBLE
12271: LD_INT 1
12273: DEC
12274: ST_TO_ADDR
12275: LD_INT 2
12277: PUSH
12278: FOR_TO
12279: IFFALSE 12320
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12281: LD_ADDR_VAR 0 3
12285: PUSH
12286: LD_VAR 0 3
12290: PUSH
12291: LD_INT 2
12293: PPUSH
12294: LD_INT 2
12296: PPUSH
12297: LD_INT 14
12299: PPUSH
12300: LD_INT 1
12302: PPUSH
12303: LD_INT 1
12305: PPUSH
12306: LD_INT 32
12308: PPUSH
12309: LD_INT 30
12311: PPUSH
12312: CALL 264 0 7
12316: ADD
12317: ST_TO_ADDR
12318: GO 12278
12320: POP
12321: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12322: LD_ADDR_VAR 0 3
12326: PUSH
12327: LD_VAR 0 3
12331: PUSH
12332: LD_INT 2
12334: PPUSH
12335: LD_INT 2
12337: PPUSH
12338: LD_INT 14
12340: PPUSH
12341: LD_INT 1
12343: PPUSH
12344: LD_INT 1
12346: PPUSH
12347: LD_INT 26
12349: PPUSH
12350: LD_INT 33
12352: PPUSH
12353: CALL 264 0 7
12357: ADD
12358: ST_TO_ADDR
// tmp := tmp diff 0 ;
12359: LD_ADDR_VAR 0 3
12363: PUSH
12364: LD_VAR 0 3
12368: PUSH
12369: LD_INT 0
12371: DIFF
12372: ST_TO_ADDR
// for i in ar_force do
12373: LD_ADDR_VAR 0 4
12377: PUSH
12378: LD_EXP 33
12382: PUSH
12383: FOR_IN
12384: IFFALSE 12527
// begin if GetClass ( i ) = 3 then
12386: LD_VAR 0 4
12390: PPUSH
12391: CALL_OW 257
12395: PUSH
12396: LD_INT 3
12398: EQUAL
12399: IFFALSE 12481
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12401: LD_VAR 0 3
12405: PUSH
12406: LD_INT 1
12408: ARRAY
12409: PPUSH
12410: LD_INT 1
12412: PPUSH
12413: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12417: LD_VAR 0 3
12421: PUSH
12422: LD_INT 1
12424: ARRAY
12425: PPUSH
12426: LD_VAR 0 5
12430: PPUSH
12431: LD_VAR 0 6
12435: PPUSH
12436: LD_INT 0
12438: PPUSH
12439: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12443: LD_VAR 0 4
12447: PPUSH
12448: LD_VAR 0 3
12452: PUSH
12453: LD_INT 1
12455: ARRAY
12456: PPUSH
12457: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12461: LD_ADDR_VAR 0 3
12465: PUSH
12466: LD_VAR 0 3
12470: PPUSH
12471: LD_INT 1
12473: PPUSH
12474: CALL_OW 3
12478: ST_TO_ADDR
// end else
12479: GO 12503
// PlaceUnitXY ( i , x , y , false ) ;
12481: LD_VAR 0 4
12485: PPUSH
12486: LD_VAR 0 5
12490: PPUSH
12491: LD_VAR 0 6
12495: PPUSH
12496: LD_INT 0
12498: PPUSH
12499: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12503: LD_VAR 0 4
12507: PPUSH
12508: LD_INT 86
12510: PPUSH
12511: LD_INT 121
12513: PPUSH
12514: CALL_OW 111
// wait ( 0 0$2 ) ;
12518: LD_INT 70
12520: PPUSH
12521: CALL_OW 67
// end ;
12525: GO 12383
12527: POP
12528: POP
// ar_force := ar_force ^ tmp ;
12529: LD_ADDR_EXP 33
12533: PUSH
12534: LD_EXP 33
12538: PUSH
12539: LD_VAR 0 3
12543: ADD
12544: ST_TO_ADDR
// ar_spawned := true ;
12545: LD_ADDR_EXP 11
12549: PUSH
12550: LD_INT 1
12552: ST_TO_ADDR
// end ; end_of_file
12553: LD_VAR 0 1
12557: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12558: LD_INT 0
12560: PPUSH
12561: PPUSH
12562: PPUSH
12563: PPUSH
12564: PPUSH
12565: PPUSH
12566: PPUSH
// InitHc ;
12567: CALL_OW 19
// uc_side := 3 ;
12571: LD_ADDR_OWVAR 20
12575: PUSH
12576: LD_INT 3
12578: ST_TO_ADDR
// uc_nation := 3 ;
12579: LD_ADDR_OWVAR 21
12583: PUSH
12584: LD_INT 3
12586: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12587: LD_ADDR_VAR 0 5
12591: PUSH
12592: LD_INT 5
12594: PUSH
12595: LD_INT 6
12597: PUSH
12598: LD_INT 7
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: LIST
12605: PUSH
12606: LD_OWVAR 67
12610: ARRAY
12611: ST_TO_ADDR
// ru_force := [ ] ;
12612: LD_ADDR_EXP 35
12616: PUSH
12617: EMPTY
12618: ST_TO_ADDR
// ru_rebuild := [ ] ;
12619: LD_ADDR_EXP 36
12623: PUSH
12624: EMPTY
12625: ST_TO_ADDR
// ru_produce_list := [ ] ;
12626: LD_ADDR_EXP 37
12630: PUSH
12631: EMPTY
12632: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12633: LD_ADDR_VAR 0 6
12637: PUSH
12638: LD_INT 22
12640: PUSH
12641: LD_INT 3
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: LD_INT 30
12650: PUSH
12651: LD_INT 8
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 69
12666: PUSH
12667: LD_INT 1
12669: ARRAY
12670: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12671: LD_ADDR_VAR 0 4
12675: PUSH
12676: LD_INT 43
12678: PUSH
12679: LD_INT 46
12681: PUSH
12682: LD_INT 45
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: LIST
12689: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12690: LD_ADDR_VAR 0 7
12694: PUSH
12695: LD_INT 22
12697: PUSH
12698: LD_INT 3
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: PUSH
12705: LD_INT 30
12707: PUSH
12708: LD_INT 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: EMPTY
12716: LIST
12717: LIST
12718: PPUSH
12719: CALL_OW 69
12723: PUSH
12724: LD_INT 1
12726: ARRAY
12727: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12728: LD_VAR 0 7
12732: PPUSH
12733: CALL_OW 274
12737: PPUSH
12738: LD_INT 1
12740: PPUSH
12741: LD_INT 5000
12743: PPUSH
12744: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12748: LD_VAR 0 7
12752: PPUSH
12753: CALL_OW 274
12757: PPUSH
12758: LD_INT 2
12760: PPUSH
12761: LD_INT 1000
12763: PPUSH
12764: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12768: LD_VAR 0 7
12772: PPUSH
12773: CALL_OW 274
12777: PPUSH
12778: LD_INT 3
12780: PPUSH
12781: LD_INT 30
12783: PPUSH
12784: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12788: LD_ADDR_VAR 0 2
12792: PUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 3
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 30
12805: PUSH
12806: LD_INT 33
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PPUSH
12817: CALL_OW 69
12821: PUSH
12822: FOR_IN
12823: IFFALSE 12855
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12825: LD_VAR 0 2
12829: PPUSH
12830: LD_VAR 0 4
12834: PUSH
12835: LD_VAR 0 2
12839: PUSH
12840: LD_INT 3
12842: MOD
12843: PUSH
12844: LD_INT 1
12846: PLUS
12847: ARRAY
12848: PPUSH
12849: CALL_OW 431
// end ;
12853: GO 12822
12855: POP
12856: POP
// for i = 1 to 4 do
12857: LD_ADDR_VAR 0 2
12861: PUSH
12862: DOUBLE
12863: LD_INT 1
12865: DEC
12866: ST_TO_ADDR
12867: LD_INT 4
12869: PUSH
12870: FOR_TO
12871: IFFALSE 12932
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12873: LD_INT 0
12875: PPUSH
12876: LD_INT 9
12878: PPUSH
12879: LD_VAR 0 5
12883: PPUSH
12884: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12888: CALL_OW 44
12892: PPUSH
12893: LD_INT 22
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 30
12905: PUSH
12906: LD_INT 5
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PPUSH
12917: CALL_OW 69
12921: PUSH
12922: LD_INT 1
12924: ARRAY
12925: PPUSH
12926: CALL_OW 52
// end ;
12930: GO 12870
12932: POP
12933: POP
// for i = 1 to 5 do
12934: LD_ADDR_VAR 0 2
12938: PUSH
12939: DOUBLE
12940: LD_INT 1
12942: DEC
12943: ST_TO_ADDR
12944: LD_INT 5
12946: PUSH
12947: FOR_TO
12948: IFFALSE 13009
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12950: LD_INT 0
12952: PPUSH
12953: LD_INT 3
12955: PPUSH
12956: LD_VAR 0 5
12960: PPUSH
12961: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12965: CALL_OW 44
12969: PPUSH
12970: LD_INT 22
12972: PUSH
12973: LD_INT 3
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 30
12982: PUSH
12983: LD_INT 3
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PPUSH
12994: CALL_OW 69
12998: PUSH
12999: LD_INT 1
13001: ARRAY
13002: PPUSH
13003: CALL_OW 52
// end ;
13007: GO 12947
13009: POP
13010: POP
// for i = 1 to 4 do
13011: LD_ADDR_VAR 0 2
13015: PUSH
13016: DOUBLE
13017: LD_INT 1
13019: DEC
13020: ST_TO_ADDR
13021: LD_INT 4
13023: PUSH
13024: FOR_TO
13025: IFFALSE 13086
// begin PrepareHuman ( false , class_engineer , skill ) ;
13027: LD_INT 0
13029: PPUSH
13030: LD_INT 2
13032: PPUSH
13033: LD_VAR 0 5
13037: PPUSH
13038: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13042: CALL_OW 44
13046: PPUSH
13047: LD_INT 22
13049: PUSH
13050: LD_INT 3
13052: PUSH
13053: EMPTY
13054: LIST
13055: LIST
13056: PUSH
13057: LD_INT 30
13059: PUSH
13060: LD_INT 1
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: PUSH
13067: EMPTY
13068: LIST
13069: LIST
13070: PPUSH
13071: CALL_OW 69
13075: PUSH
13076: LD_INT 1
13078: ARRAY
13079: PPUSH
13080: CALL_OW 52
// end ;
13084: GO 13024
13086: POP
13087: POP
// for i = 1 to 3 do
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: DOUBLE
13094: LD_INT 1
13096: DEC
13097: ST_TO_ADDR
13098: LD_INT 3
13100: PUSH
13101: FOR_TO
13102: IFFALSE 13135
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13104: LD_INT 0
13106: PPUSH
13107: LD_INT 4
13109: PPUSH
13110: LD_VAR 0 5
13114: PPUSH
13115: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13119: CALL_OW 44
13123: PPUSH
13124: LD_VAR 0 6
13128: PPUSH
13129: CALL_OW 52
// end ;
13133: GO 13101
13135: POP
13136: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13137: LD_ADDR_EXP 34
13141: PUSH
13142: LD_STRING Yakotich
13144: PPUSH
13145: LD_EXP 2
13149: NOT
13150: PPUSH
13151: LD_STRING 
13153: PPUSH
13154: CALL 201 0 3
13158: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13159: LD_EXP 34
13163: PPUSH
13164: LD_INT 74
13166: PPUSH
13167: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13171: LD_VAR 0 6
13175: PPUSH
13176: LD_INT 49
13178: PPUSH
13179: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13183: LD_VAR 0 6
13187: PPUSH
13188: LD_INT 50
13190: PPUSH
13191: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13195: LD_VAR 0 6
13199: PPUSH
13200: LD_INT 51
13202: PPUSH
13203: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13207: LD_VAR 0 6
13211: PPUSH
13212: LD_INT 52
13214: PPUSH
13215: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13219: LD_VAR 0 6
13223: PPUSH
13224: LD_INT 69
13226: PPUSH
13227: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13231: LD_VAR 0 6
13235: PPUSH
13236: LD_INT 39
13238: PPUSH
13239: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13243: LD_VAR 0 6
13247: PPUSH
13248: LD_INT 34
13250: PPUSH
13251: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13255: LD_VAR 0 6
13259: PPUSH
13260: LD_INT 40
13262: PPUSH
13263: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13267: LD_VAR 0 6
13271: PPUSH
13272: LD_INT 57
13274: PPUSH
13275: CALL_OW 184
// if Difficulty > 1 then
13279: LD_OWVAR 67
13283: PUSH
13284: LD_INT 1
13286: GREATER
13287: IFFALSE 13301
// AddComResearch ( lab , tech_comp2 ) ;
13289: LD_VAR 0 6
13293: PPUSH
13294: LD_INT 58
13296: PPUSH
13297: CALL_OW 184
// end ;
13301: LD_VAR 0 1
13305: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13306: LD_INT 7
13308: PPUSH
13309: CALL_OW 353
13313: PUSH
13314: LD_INT 3
13316: GREATER
13317: PUSH
13318: LD_INT 22
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PUSH
13328: LD_INT 34
13330: PUSH
13331: LD_INT 53
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: PPUSH
13342: CALL_OW 69
13346: NOT
13347: AND
13348: IFFALSE 13383
13350: GO 13352
13352: DISABLE
// begin enable ;
13353: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13354: LD_ADDR_EXP 37
13358: PUSH
13359: LD_EXP 37
13363: PUSH
13364: LD_INT 24
13366: PUSH
13367: LD_INT 1
13369: PUSH
13370: LD_INT 3
13372: PUSH
13373: LD_INT 53
13375: PUSH
13376: EMPTY
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: ADD
13382: ST_TO_ADDR
// end ;
13383: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13384: LD_INT 22
13386: PUSH
13387: LD_INT 3
13389: PUSH
13390: EMPTY
13391: LIST
13392: LIST
13393: PUSH
13394: LD_INT 21
13396: PUSH
13397: LD_INT 3
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PPUSH
13408: CALL_OW 69
13412: IFFALSE 14190
13414: GO 13416
13416: DISABLE
13417: LD_INT 0
13419: PPUSH
13420: PPUSH
13421: PPUSH
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
// begin enable ;
13427: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13428: LD_ADDR_VAR 0 3
13432: PUSH
13433: LD_INT 22
13435: PUSH
13436: LD_INT 3
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PUSH
13443: LD_INT 21
13445: PUSH
13446: LD_INT 3
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PUSH
13453: LD_INT 3
13455: PUSH
13456: LD_INT 24
13458: PUSH
13459: LD_INT 1000
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: LIST
13474: PPUSH
13475: CALL_OW 69
13479: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13480: LD_ADDR_VAR 0 4
13484: PUSH
13485: LD_INT 22
13487: PUSH
13488: LD_INT 3
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: PUSH
13495: LD_INT 25
13497: PUSH
13498: LD_INT 2
13500: PUSH
13501: EMPTY
13502: LIST
13503: LIST
13504: PUSH
13505: EMPTY
13506: LIST
13507: LIST
13508: PPUSH
13509: CALL_OW 69
13513: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13514: LD_ADDR_VAR 0 5
13518: PUSH
13519: LD_INT 22
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 30
13531: PUSH
13532: LD_INT 1
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PPUSH
13543: CALL_OW 69
13547: PUSH
13548: LD_INT 1
13550: ARRAY
13551: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13552: LD_ADDR_VAR 0 8
13556: PUSH
13557: LD_INT 22
13559: PUSH
13560: LD_INT 3
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 2
13569: PUSH
13570: LD_INT 30
13572: PUSH
13573: LD_INT 6
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PUSH
13580: LD_INT 30
13582: PUSH
13583: LD_INT 7
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: LD_INT 30
13592: PUSH
13593: LD_INT 8
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: PPUSH
13610: CALL_OW 69
13614: PUSH
13615: LD_INT 1
13617: ARRAY
13618: ST_TO_ADDR
// if not engs then
13619: LD_VAR 0 4
13623: NOT
13624: IFFALSE 13628
// exit ;
13626: GO 14190
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13628: LD_ADDR_VAR 0 6
13632: PUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: LD_INT 3
13640: PUSH
13641: LD_INT 24
13643: PUSH
13644: LD_INT 600
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: PPUSH
13655: CALL_OW 72
13659: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13660: LD_ADDR_VAR 0 7
13664: PUSH
13665: LD_INT 22
13667: PUSH
13668: LD_INT 3
13670: PUSH
13671: EMPTY
13672: LIST
13673: LIST
13674: PUSH
13675: LD_INT 25
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PPUSH
13689: CALL_OW 69
13693: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13694: LD_VAR 0 3
13698: NOT
13699: PUSH
13700: LD_EXP 36
13704: NOT
13705: AND
13706: IFFALSE 13766
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13708: LD_VAR 0 4
13712: PPUSH
13713: LD_INT 3
13715: PUSH
13716: LD_INT 54
13718: PUSH
13719: EMPTY
13720: LIST
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: PPUSH
13726: CALL_OW 72
13730: IFFALSE 13764
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13732: LD_VAR 0 4
13736: PPUSH
13737: LD_INT 3
13739: PUSH
13740: LD_INT 54
13742: PUSH
13743: EMPTY
13744: LIST
13745: PUSH
13746: EMPTY
13747: LIST
13748: LIST
13749: PPUSH
13750: CALL_OW 72
13754: PPUSH
13755: LD_VAR 0 5
13759: PPUSH
13760: CALL_OW 120
// exit ;
13764: GO 14190
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13766: LD_VAR 0 4
13770: PPUSH
13771: LD_INT 54
13773: PUSH
13774: EMPTY
13775: LIST
13776: PPUSH
13777: CALL_OW 72
13781: IFFALSE 13803
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13783: LD_VAR 0 4
13787: PPUSH
13788: LD_INT 54
13790: PUSH
13791: EMPTY
13792: LIST
13793: PPUSH
13794: CALL_OW 72
13798: PPUSH
13799: CALL_OW 122
// if not tmp then
13803: LD_VAR 0 3
13807: NOT
13808: IFFALSE 13940
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13810: LD_INT 81
13812: PUSH
13813: LD_INT 3
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: PUSH
13820: LD_INT 92
13822: PUSH
13823: LD_INT 147
13825: PUSH
13826: LD_INT 212
13828: PUSH
13829: LD_INT 30
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: LIST
13836: LIST
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PPUSH
13842: CALL_OW 69
13846: NOT
13847: IFFALSE 13940
// begin if not HasTask ( engs [ 1 ] ) then
13849: LD_VAR 0 4
13853: PUSH
13854: LD_INT 1
13856: ARRAY
13857: PPUSH
13858: CALL_OW 314
13862: NOT
13863: IFFALSE 13940
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_VAR 0 4
13874: PPUSH
13875: LD_EXP 36
13879: PUSH
13880: LD_INT 1
13882: ARRAY
13883: PPUSH
13884: LD_EXP 36
13888: PUSH
13889: LD_INT 2
13891: ARRAY
13892: PPUSH
13893: LD_EXP 36
13897: PUSH
13898: LD_INT 3
13900: ARRAY
13901: PPUSH
13902: LD_EXP 36
13906: PUSH
13907: LD_INT 4
13909: ARRAY
13910: PPUSH
13911: CALL_OW 145
13915: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13916: LD_VAR 0 2
13920: PPUSH
13921: CALL_OW 266
13925: PUSH
13926: LD_INT 4
13928: EQUAL
13929: IFFALSE 13940
// AddComUpgrade ( i ) ;
13931: LD_VAR 0 2
13935: PPUSH
13936: CALL_OW 206
// end ; end ; end ; for i in engs do
13940: LD_ADDR_VAR 0 2
13944: PUSH
13945: LD_VAR 0 4
13949: PUSH
13950: FOR_IN
13951: IFFALSE 14069
// begin if i in to_heal and sci then
13953: LD_VAR 0 2
13957: PUSH
13958: LD_VAR 0 6
13962: IN
13963: PUSH
13964: LD_VAR 0 7
13968: AND
13969: IFFALSE 14020
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13971: LD_VAR 0 2
13975: PPUSH
13976: LD_INT 149
13978: PPUSH
13979: LD_INT 220
13981: PPUSH
13982: CALL_OW 297
13986: PUSH
13987: LD_INT 5
13989: LESS
13990: IFFALSE 13994
// continue ;
13992: GO 13950
// ComMoveXY ( i , 149 , 220 ) ;
13994: LD_VAR 0 2
13998: PPUSH
13999: LD_INT 149
14001: PPUSH
14002: LD_INT 220
14004: PPUSH
14005: CALL_OW 111
// AddComHold ( i ) ;
14009: LD_VAR 0 2
14013: PPUSH
14014: CALL_OW 200
// end else
14018: GO 14067
// if not HasTask ( i ) or WantsToAttack ( i ) then
14020: LD_VAR 0 2
14024: PPUSH
14025: CALL_OW 314
14029: NOT
14030: PUSH
14031: LD_VAR 0 2
14035: PPUSH
14036: CALL_OW 319
14040: OR
14041: IFFALSE 14067
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14043: LD_VAR 0 2
14047: PPUSH
14048: LD_VAR 0 3
14052: PPUSH
14053: LD_VAR 0 2
14057: PPUSH
14058: CALL_OW 74
14062: PPUSH
14063: CALL_OW 130
// end ;
14067: GO 13950
14069: POP
14070: POP
// if to_heal and sci then
14071: LD_VAR 0 6
14075: PUSH
14076: LD_VAR 0 7
14080: AND
14081: IFFALSE 14142
// begin if UnitFilter ( sci , [ f_inside ] ) then
14083: LD_VAR 0 7
14087: PPUSH
14088: LD_INT 54
14090: PUSH
14091: EMPTY
14092: LIST
14093: PPUSH
14094: CALL_OW 72
14098: IFFALSE 14122
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14100: LD_VAR 0 7
14104: PPUSH
14105: LD_INT 54
14107: PUSH
14108: EMPTY
14109: LIST
14110: PPUSH
14111: CALL_OW 72
14115: PPUSH
14116: CALL_OW 122
14120: GO 14140
// ComHeal ( sci , to_heal [ 1 ] ) ;
14122: LD_VAR 0 7
14126: PPUSH
14127: LD_VAR 0 6
14131: PUSH
14132: LD_INT 1
14134: ARRAY
14135: PPUSH
14136: CALL_OW 128
// end else
14140: GO 14190
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14142: LD_VAR 0 7
14146: PPUSH
14147: LD_INT 56
14149: PUSH
14150: EMPTY
14151: LIST
14152: PPUSH
14153: CALL_OW 72
14157: PUSH
14158: LD_VAR 0 8
14162: AND
14163: IFFALSE 14190
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14165: LD_VAR 0 7
14169: PPUSH
14170: LD_INT 56
14172: PUSH
14173: EMPTY
14174: LIST
14175: PPUSH
14176: CALL_OW 72
14180: PPUSH
14181: LD_VAR 0 8
14185: PPUSH
14186: CALL_OW 120
// end ;
14190: PPOPN 8
14192: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14193: LD_INT 22
14195: PUSH
14196: LD_INT 3
14198: PUSH
14199: EMPTY
14200: LIST
14201: LIST
14202: PUSH
14203: LD_INT 30
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PPUSH
14217: CALL_OW 69
14221: PUSH
14222: LD_EXP 37
14226: AND
14227: IFFALSE 14353
14229: GO 14231
14231: DISABLE
14232: LD_INT 0
14234: PPUSH
14235: PPUSH
14236: PPUSH
// begin enable ;
14237: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14238: LD_ADDR_VAR 0 3
14242: PUSH
14243: LD_INT 22
14245: PUSH
14246: LD_INT 3
14248: PUSH
14249: EMPTY
14250: LIST
14251: LIST
14252: PUSH
14253: LD_INT 30
14255: PUSH
14256: LD_INT 3
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: PUSH
14263: EMPTY
14264: LIST
14265: LIST
14266: PPUSH
14267: CALL_OW 69
14271: PUSH
14272: LD_INT 1
14274: ARRAY
14275: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14276: LD_VAR 0 3
14280: PPUSH
14281: CALL_OW 313
14285: PUSH
14286: LD_INT 0
14288: EQUAL
14289: IFFALSE 14293
// exit ;
14291: GO 14353
// if BuildingStatus ( fac ) = bs_idle then
14293: LD_VAR 0 3
14297: PPUSH
14298: CALL_OW 461
14302: PUSH
14303: LD_INT 2
14305: EQUAL
14306: IFFALSE 14353
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14308: LD_VAR 0 3
14312: PPUSH
14313: LD_EXP 37
14317: PUSH
14318: LD_INT 1
14320: ARRAY
14321: PPUSH
14322: LD_EXP 37
14326: PUSH
14327: LD_INT 2
14329: ARRAY
14330: PPUSH
14331: LD_EXP 37
14335: PUSH
14336: LD_INT 3
14338: ARRAY
14339: PPUSH
14340: LD_EXP 37
14344: PUSH
14345: LD_INT 4
14347: ARRAY
14348: PPUSH
14349: CALL_OW 125
// end ;
14353: PPOPN 3
14355: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14356: LD_INT 0
14358: PPUSH
14359: PPUSH
14360: PPUSH
14361: PPUSH
14362: PPUSH
// uc_side := 3 ;
14363: LD_ADDR_OWVAR 20
14367: PUSH
14368: LD_INT 3
14370: ST_TO_ADDR
// uc_nation := 3 ;
14371: LD_ADDR_OWVAR 21
14375: PUSH
14376: LD_INT 3
14378: ST_TO_ADDR
// ru_can_attack := false ;
14379: LD_ADDR_EXP 8
14383: PUSH
14384: LD_INT 0
14386: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14387: LD_ADDR_VAR 0 6
14391: PUSH
14392: LD_INT 22
14394: PUSH
14395: LD_INT 3
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: PUSH
14402: LD_INT 30
14404: PUSH
14405: LD_INT 3
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: PUSH
14412: EMPTY
14413: LIST
14414: LIST
14415: PPUSH
14416: CALL_OW 69
14420: ST_TO_ADDR
// if fac then
14421: LD_VAR 0 6
14425: IFFALSE 14577
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14427: LD_ADDR_EXP 37
14431: PUSH
14432: LD_INT 24
14434: PUSH
14435: LD_INT 1
14437: PUSH
14438: LD_INT 3
14440: PUSH
14441: LD_INT 43
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: ST_TO_ADDR
// if wave > 1 then
14450: LD_VAR 0 1
14454: PUSH
14455: LD_INT 1
14457: GREATER
14458: IFFALSE 14511
// for i = 1 to Difficulty do
14460: LD_ADDR_VAR 0 3
14464: PUSH
14465: DOUBLE
14466: LD_INT 1
14468: DEC
14469: ST_TO_ADDR
14470: LD_OWVAR 67
14474: PUSH
14475: FOR_TO
14476: IFFALSE 14509
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14478: LD_ADDR_EXP 37
14482: PUSH
14483: LD_EXP 37
14487: PUSH
14488: LD_INT 24
14490: PUSH
14491: LD_INT 1
14493: PUSH
14494: LD_INT 3
14496: PUSH
14497: LD_INT 45
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: LIST
14504: LIST
14505: ADD
14506: ST_TO_ADDR
14507: GO 14475
14509: POP
14510: POP
// repeat wait ( 0 0$1 ) ;
14511: LD_INT 35
14513: PPUSH
14514: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14518: LD_EXP 37
14522: PUSH
14523: LD_INT 4
14525: LESS
14526: PUSH
14527: LD_VAR 0 6
14531: PUSH
14532: LD_INT 1
14534: ARRAY
14535: PPUSH
14536: CALL_OW 313
14540: PUSH
14541: LD_INT 0
14543: EQUAL
14544: OR
14545: PUSH
14546: LD_VAR 0 6
14550: PUSH
14551: LD_INT 1
14553: ARRAY
14554: PPUSH
14555: CALL_OW 461
14559: PUSH
14560: LD_INT 8
14562: PUSH
14563: LD_INT 6
14565: PUSH
14566: LD_INT 7
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: IN
14574: OR
14575: IFFALSE 14511
// end ; case wave of 1 :
14577: LD_VAR 0 1
14581: PUSH
14582: LD_INT 1
14584: DOUBLE
14585: EQUAL
14586: IFTRUE 14590
14588: GO 14675
14590: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14591: LD_ADDR_VAR 0 3
14595: PUSH
14596: DOUBLE
14597: LD_INT 1
14599: DEC
14600: ST_TO_ADDR
14601: LD_INT 4
14603: PUSH
14604: LD_INT 5
14606: PUSH
14607: LD_INT 6
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: LIST
14614: PUSH
14615: LD_OWVAR 67
14619: ARRAY
14620: PUSH
14621: FOR_TO
14622: IFFALSE 14630
// Sold ;
14624: CALL 14901 0 0
14628: GO 14621
14630: POP
14631: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14632: LD_ADDR_VAR 0 3
14636: PUSH
14637: DOUBLE
14638: LD_INT 1
14640: DEC
14641: ST_TO_ADDR
14642: LD_INT 2
14644: PUSH
14645: LD_INT 3
14647: PUSH
14648: LD_INT 3
14650: PUSH
14651: EMPTY
14652: LIST
14653: LIST
14654: LIST
14655: PUSH
14656: LD_OWVAR 67
14660: ARRAY
14661: PUSH
14662: FOR_TO
14663: IFFALSE 14671
// Tank ;
14665: CALL 15031 0 0
14669: GO 14662
14671: POP
14672: POP
// end ; 2 .. 9 :
14673: GO 14888
14675: LD_INT 2
14677: DOUBLE
14678: GREATEREQUAL
14679: IFFALSE 14687
14681: LD_INT 9
14683: DOUBLE
14684: LESSEQUAL
14685: IFTRUE 14689
14687: GO 14794
14689: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14690: LD_ADDR_VAR 0 3
14694: PUSH
14695: DOUBLE
14696: LD_INT 1
14698: DEC
14699: ST_TO_ADDR
14700: LD_INT 4
14702: PUSH
14703: LD_INT 5
14705: PUSH
14706: LD_INT 6
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: LIST
14713: PUSH
14714: LD_OWVAR 67
14718: ARRAY
14719: PUSH
14720: LD_VAR 0 1
14724: PUSH
14725: LD_INT 2
14727: DIV
14728: PLUS
14729: PUSH
14730: FOR_TO
14731: IFFALSE 14739
// Sold ;
14733: CALL 14901 0 0
14737: GO 14730
14739: POP
14740: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14741: LD_ADDR_VAR 0 3
14745: PUSH
14746: DOUBLE
14747: LD_INT 1
14749: DEC
14750: ST_TO_ADDR
14751: LD_INT 3
14753: PUSH
14754: LD_INT 4
14756: PUSH
14757: LD_INT 4
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: LIST
14764: PUSH
14765: LD_OWVAR 67
14769: ARRAY
14770: PUSH
14771: LD_VAR 0 1
14775: PUSH
14776: LD_INT 2
14778: DIV
14779: PLUS
14780: PUSH
14781: FOR_TO
14782: IFFALSE 14790
// Tank ;
14784: CALL 15031 0 0
14788: GO 14781
14790: POP
14791: POP
// end ; 10 :
14792: GO 14888
14794: LD_INT 10
14796: DOUBLE
14797: EQUAL
14798: IFTRUE 14802
14800: GO 14887
14802: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14803: LD_ADDR_VAR 0 3
14807: PUSH
14808: DOUBLE
14809: LD_INT 1
14811: DEC
14812: ST_TO_ADDR
14813: LD_INT 10
14815: PUSH
14816: LD_INT 12
14818: PUSH
14819: LD_INT 14
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: LIST
14826: PUSH
14827: LD_OWVAR 67
14831: ARRAY
14832: PUSH
14833: FOR_TO
14834: IFFALSE 14842
// Sold ;
14836: CALL 14901 0 0
14840: GO 14833
14842: POP
14843: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: DOUBLE
14850: LD_INT 1
14852: DEC
14853: ST_TO_ADDR
14854: LD_INT 11
14856: PUSH
14857: LD_INT 13
14859: PUSH
14860: LD_INT 15
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: PUSH
14868: LD_OWVAR 67
14872: ARRAY
14873: PUSH
14874: FOR_TO
14875: IFFALSE 14883
// Tank ;
14877: CALL 15031 0 0
14881: GO 14874
14883: POP
14884: POP
// end ; end ;
14885: GO 14888
14887: POP
// ru_can_attack := true ;
14888: LD_ADDR_EXP 8
14892: PUSH
14893: LD_INT 1
14895: ST_TO_ADDR
// end ;
14896: LD_VAR 0 2
14900: RET
// function Sold ( ) ; var un , skill ; begin
14901: LD_INT 0
14903: PPUSH
14904: PPUSH
14905: PPUSH
// uc_side := 3 ;
14906: LD_ADDR_OWVAR 20
14910: PUSH
14911: LD_INT 3
14913: ST_TO_ADDR
// uc_nation := 3 ;
14914: LD_ADDR_OWVAR 21
14918: PUSH
14919: LD_INT 3
14921: ST_TO_ADDR
// InitHc ;
14922: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14926: LD_ADDR_VAR 0 3
14930: PUSH
14931: LD_INT 6
14933: PUSH
14934: LD_INT 7
14936: PUSH
14937: LD_INT 7
14939: PUSH
14940: EMPTY
14941: LIST
14942: LIST
14943: LIST
14944: PUSH
14945: LD_OWVAR 67
14949: ARRAY
14950: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14951: LD_INT 0
14953: PPUSH
14954: LD_INT 1
14956: PUSH
14957: LD_INT 9
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: PUSH
14964: LD_INT 1
14966: PPUSH
14967: LD_INT 2
14969: PPUSH
14970: CALL_OW 12
14974: ARRAY
14975: PPUSH
14976: LD_VAR 0 3
14980: PPUSH
14981: CALL_OW 380
// un := CreateHuman ;
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: CALL_OW 44
14994: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14995: LD_VAR 0 2
14999: PPUSH
15000: LD_INT 4
15002: PPUSH
15003: LD_INT 0
15005: PPUSH
15006: CALL_OW 49
// ru_force := ru_force ^ un ;
15010: LD_ADDR_EXP 35
15014: PUSH
15015: LD_EXP 35
15019: PUSH
15020: LD_VAR 0 2
15024: ADD
15025: ST_TO_ADDR
// end ;
15026: LD_VAR 0 1
15030: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15031: LD_INT 0
15033: PPUSH
15034: PPUSH
15035: PPUSH
15036: PPUSH
15037: PPUSH
// uc_side := 3 ;
15038: LD_ADDR_OWVAR 20
15042: PUSH
15043: LD_INT 3
15045: ST_TO_ADDR
// uc_nation := 3 ;
15046: LD_ADDR_OWVAR 21
15050: PUSH
15051: LD_INT 3
15053: ST_TO_ADDR
// InitHc ;
15054: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15058: LD_ADDR_VAR 0 5
15062: PUSH
15063: LD_INT 5
15065: PUSH
15066: LD_INT 6
15068: PUSH
15069: LD_INT 7
15071: PUSH
15072: EMPTY
15073: LIST
15074: LIST
15075: LIST
15076: PUSH
15077: LD_OWVAR 67
15081: ARRAY
15082: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15083: LD_ADDR_VAR 0 3
15087: PUSH
15088: LD_INT 22
15090: PUSH
15091: LD_INT 24
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PUSH
15098: LD_INT 1
15100: PPUSH
15101: LD_INT 2
15103: PPUSH
15104: CALL_OW 12
15108: ARRAY
15109: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15110: LD_VAR 0 3
15114: PUSH
15115: LD_INT 22
15117: EQUAL
15118: IFFALSE 15153
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15120: LD_ADDR_VAR 0 4
15124: PUSH
15125: LD_INT 45
15127: PUSH
15128: LD_INT 43
15130: PUSH
15131: LD_INT 44
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 1
15141: PPUSH
15142: LD_INT 3
15144: PPUSH
15145: CALL_OW 12
15149: ARRAY
15150: ST_TO_ADDR
15151: GO 15184
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15153: LD_ADDR_VAR 0 4
15157: PUSH
15158: LD_INT 46
15160: PUSH
15161: LD_INT 44
15163: PUSH
15164: LD_INT 45
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 1
15174: PPUSH
15175: LD_INT 3
15177: PPUSH
15178: CALL_OW 12
15182: ARRAY
15183: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15184: LD_ADDR_VAR 0 2
15188: PUSH
15189: LD_INT 3
15191: PPUSH
15192: LD_INT 3
15194: PPUSH
15195: LD_VAR 0 3
15199: PPUSH
15200: LD_INT 1
15202: PPUSH
15203: LD_INT 3
15205: PUSH
15206: LD_INT 3
15208: PUSH
15209: LD_INT 3
15211: PUSH
15212: LD_INT 1
15214: PUSH
15215: EMPTY
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: PUSH
15221: LD_INT 1
15223: PPUSH
15224: LD_INT 4
15226: PPUSH
15227: CALL_OW 12
15231: ARRAY
15232: PPUSH
15233: LD_VAR 0 4
15237: PPUSH
15238: LD_INT 99
15240: PPUSH
15241: CALL 264 0 7
15245: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15246: LD_VAR 0 2
15250: PPUSH
15251: CALL_OW 263
15255: PUSH
15256: LD_INT 1
15258: EQUAL
15259: IFFALSE 15290
// begin PrepareHuman ( false , 3 , skill ) ;
15261: LD_INT 0
15263: PPUSH
15264: LD_INT 3
15266: PPUSH
15267: LD_VAR 0 5
15271: PPUSH
15272: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15276: CALL_OW 44
15280: PPUSH
15281: LD_VAR 0 2
15285: PPUSH
15286: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15290: LD_VAR 0 2
15294: PPUSH
15295: LD_INT 3
15297: PPUSH
15298: LD_INT 0
15300: PPUSH
15301: CALL_OW 49
// ru_force := ru_force ^ un ;
15305: LD_ADDR_EXP 35
15309: PUSH
15310: LD_EXP 35
15314: PUSH
15315: LD_VAR 0 2
15319: ADD
15320: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15321: LD_VAR 0 2
15325: PPUSH
15326: LD_INT 126
15328: PPUSH
15329: LD_INT 158
15331: PPUSH
15332: CALL_OW 111
// Wait ( 0 0$3 ) ;
15336: LD_INT 105
15338: PPUSH
15339: CALL_OW 67
// ComStop ( un ) ;
15343: LD_VAR 0 2
15347: PPUSH
15348: CALL_OW 141
// end ;
15352: LD_VAR 0 1
15356: RET
// every 0 0$1 do var i , time , wave ;
15357: GO 15359
15359: DISABLE
15360: LD_INT 0
15362: PPUSH
15363: PPUSH
15364: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15365: LD_ADDR_VAR 0 2
15369: PUSH
15370: LD_INT 25200
15372: PUSH
15373: LD_INT 24150
15375: PUSH
15376: LD_INT 23100
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: LIST
15383: PUSH
15384: LD_OWVAR 67
15388: ARRAY
15389: ST_TO_ADDR
// wait ( time ) ;
15390: LD_VAR 0 2
15394: PPUSH
15395: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15399: LD_ADDR_VAR 0 2
15403: PUSH
15404: LD_INT 15750
15406: PUSH
15407: LD_INT 15050
15409: PUSH
15410: LD_INT 14350
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: PUSH
15418: LD_OWVAR 67
15422: ARRAY
15423: ST_TO_ADDR
// wave := 0 ;
15424: LD_ADDR_VAR 0 3
15428: PUSH
15429: LD_INT 0
15431: ST_TO_ADDR
// while true do
15432: LD_INT 1
15434: IFFALSE 15531
// begin wave := wave + 1 ;
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: LD_VAR 0 3
15445: PUSH
15446: LD_INT 1
15448: PLUS
15449: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15450: LD_INT 22
15452: PUSH
15453: LD_INT 2
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: PPUSH
15460: CALL_OW 69
15464: IFFALSE 15493
// repeat wait ( 0 0$1 ) ;
15466: LD_INT 35
15468: PPUSH
15469: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15473: LD_INT 22
15475: PUSH
15476: LD_INT 2
15478: PUSH
15479: EMPTY
15480: LIST
15481: LIST
15482: PPUSH
15483: CALL_OW 69
15487: PUSH
15488: LD_INT 0
15490: EQUAL
15491: IFFALSE 15466
// if ru_force < 20 then
15493: LD_EXP 35
15497: PUSH
15498: LD_INT 20
15500: LESS
15501: IFFALSE 15512
// PrepareAttack ( wave ) ;
15503: LD_VAR 0 3
15507: PPUSH
15508: CALL 14356 0 1
// ru_can_attack := true ;
15512: LD_ADDR_EXP 8
15516: PUSH
15517: LD_INT 1
15519: ST_TO_ADDR
// wait ( time ) ;
15520: LD_VAR 0 2
15524: PPUSH
15525: CALL_OW 67
// end ;
15529: GO 15432
// end ;
15531: PPOPN 3
15533: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15534: LD_EXP 8
15538: PUSH
15539: LD_EXP 35
15543: AND
15544: IFFALSE 16378
15546: GO 15548
15548: DISABLE
15549: LD_INT 0
15551: PPUSH
15552: PPUSH
15553: PPUSH
15554: PPUSH
15555: PPUSH
15556: PPUSH
15557: PPUSH
15558: PPUSH
15559: PPUSH
// begin enable ;
15560: ENABLE
// points1 := [ 107 , 123 ] ;
15561: LD_ADDR_VAR 0 4
15565: PUSH
15566: LD_INT 107
15568: PUSH
15569: LD_INT 123
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15576: LD_ADDR_VAR 0 5
15580: PUSH
15581: LD_INT 55
15583: PUSH
15584: LD_INT 42
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15591: LD_ADDR_VAR 0 6
15595: PUSH
15596: LD_INT 102
15598: PUSH
15599: LD_INT 140
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 105
15608: PUSH
15609: LD_INT 142
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 129
15618: PUSH
15619: LD_INT 131
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: LIST
15630: ST_TO_ADDR
// for i in ru_force do
15631: LD_ADDR_VAR 0 1
15635: PUSH
15636: LD_EXP 35
15640: PUSH
15641: FOR_IN
15642: IFFALSE 16376
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15644: LD_ADDR_VAR 0 3
15648: PUSH
15649: LD_INT 81
15651: PUSH
15652: LD_INT 3
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PPUSH
15659: CALL_OW 69
15663: PPUSH
15664: LD_VAR 0 1
15668: PPUSH
15669: CALL_OW 74
15673: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15674: LD_VAR 0 1
15678: PPUSH
15679: LD_VAR 0 3
15683: PPUSH
15684: CALL_OW 296
15688: PUSH
15689: LD_INT 12
15691: LESS
15692: IFFALSE 15837
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15694: LD_VAR 0 1
15698: PPUSH
15699: CALL_OW 247
15703: PUSH
15704: LD_INT 1
15706: EQUAL
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 257
15717: PUSH
15718: LD_INT 1
15720: EQUAL
15721: AND
15722: PUSH
15723: LD_VAR 0 3
15727: PUSH
15728: LD_INT 21
15730: PUSH
15731: LD_INT 2
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: PUSH
15738: LD_INT 58
15740: PUSH
15741: EMPTY
15742: LIST
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: PPUSH
15748: CALL_OW 69
15752: IN
15753: AND
15754: IFFALSE 15772
// ComEnterUnit ( i , un ) else
15756: LD_VAR 0 1
15760: PPUSH
15761: LD_VAR 0 3
15765: PPUSH
15766: CALL_OW 120
15770: GO 15835
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15772: LD_VAR 0 3
15776: PUSH
15777: LD_INT 21
15779: PUSH
15780: LD_INT 2
15782: PUSH
15783: EMPTY
15784: LIST
15785: LIST
15786: PUSH
15787: LD_INT 58
15789: PUSH
15790: EMPTY
15791: LIST
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PPUSH
15797: CALL_OW 69
15801: IN
15802: NOT
15803: IFFALSE 15821
// ComAttackUnit ( i , un ) else
15805: LD_VAR 0 1
15809: PPUSH
15810: LD_VAR 0 3
15814: PPUSH
15815: CALL_OW 115
15819: GO 15835
// ComAttackUnit ( i , JMM ) ;
15821: LD_VAR 0 1
15825: PPUSH
15826: LD_EXP 18
15830: PPUSH
15831: CALL_OW 115
// end else
15835: GO 16374
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15837: LD_VAR 0 1
15841: PPUSH
15842: LD_VAR 0 4
15846: PUSH
15847: LD_INT 1
15849: ARRAY
15850: PPUSH
15851: LD_VAR 0 4
15855: PUSH
15856: LD_INT 2
15858: ARRAY
15859: PPUSH
15860: CALL_OW 297
15864: PUSH
15865: LD_VAR 0 1
15869: PPUSH
15870: LD_VAR 0 5
15874: PUSH
15875: LD_INT 1
15877: ARRAY
15878: PPUSH
15879: LD_VAR 0 5
15883: PUSH
15884: LD_INT 2
15886: ARRAY
15887: PPUSH
15888: CALL_OW 297
15892: GREATER
15893: PUSH
15894: LD_EXP 9
15898: AND
15899: PUSH
15900: LD_INT 9
15902: PPUSH
15903: LD_INT 81
15905: PUSH
15906: LD_INT 3
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PPUSH
15913: CALL_OW 70
15917: PUSH
15918: LD_INT 0
15920: EQUAL
15921: OR
15922: IFFALSE 15960
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
15924: LD_VAR 0 1
15928: PPUSH
15929: LD_INT 81
15931: PUSH
15932: LD_INT 3
15934: PUSH
15935: EMPTY
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 69
15943: PPUSH
15944: LD_VAR 0 1
15948: PPUSH
15949: CALL_OW 74
15953: PPUSH
15954: CALL_OW 115
15958: GO 16374
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
15960: LD_VAR 0 1
15964: PPUSH
15965: CALL_OW 264
15969: PUSH
15970: LD_INT 45
15972: EQUAL
15973: PUSH
15974: LD_EXP 35
15978: PPUSH
15979: LD_INT 3
15981: PUSH
15982: LD_INT 34
15984: PUSH
15985: LD_INT 45
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PPUSH
15996: CALL_OW 72
16000: PUSH
16001: LD_INT 6
16003: GREATER
16004: AND
16005: IFFALSE 16186
// begin dist := 9999 ;
16007: LD_ADDR_VAR 0 8
16011: PUSH
16012: LD_INT 9999
16014: ST_TO_ADDR
// xy := 0 ;
16015: LD_ADDR_VAR 0 9
16019: PUSH
16020: LD_INT 0
16022: ST_TO_ADDR
// for x in pointsr do
16023: LD_ADDR_VAR 0 7
16027: PUSH
16028: LD_VAR 0 6
16032: PUSH
16033: FOR_IN
16034: IFFALSE 16182
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_VAR 0 7
16045: PUSH
16046: LD_INT 1
16048: ARRAY
16049: PPUSH
16050: LD_VAR 0 7
16054: PUSH
16055: LD_INT 2
16057: ARRAY
16058: PPUSH
16059: CALL_OW 297
16063: PUSH
16064: LD_VAR 0 8
16068: LESS
16069: IFFALSE 16114
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16071: LD_ADDR_VAR 0 8
16075: PUSH
16076: LD_VAR 0 1
16080: PPUSH
16081: LD_VAR 0 7
16085: PUSH
16086: LD_INT 1
16088: ARRAY
16089: PPUSH
16090: LD_VAR 0 7
16094: PUSH
16095: LD_INT 2
16097: ARRAY
16098: PPUSH
16099: CALL_OW 297
16103: ST_TO_ADDR
// xy := x ;
16104: LD_ADDR_VAR 0 9
16108: PUSH
16109: LD_VAR 0 7
16113: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16114: LD_VAR 0 9
16118: PUSH
16119: LD_VAR 0 1
16123: PPUSH
16124: LD_VAR 0 9
16128: PUSH
16129: LD_INT 1
16131: ARRAY
16132: PPUSH
16133: LD_VAR 0 9
16137: PUSH
16138: LD_INT 2
16140: ARRAY
16141: PPUSH
16142: CALL_OW 297
16146: PUSH
16147: LD_INT 9
16149: GREATER
16150: AND
16151: IFFALSE 16180
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16153: LD_VAR 0 1
16157: PPUSH
16158: LD_VAR 0 9
16162: PUSH
16163: LD_INT 1
16165: ARRAY
16166: PPUSH
16167: LD_VAR 0 9
16171: PUSH
16172: LD_INT 2
16174: ARRAY
16175: PPUSH
16176: CALL_OW 114
// end ;
16180: GO 16033
16182: POP
16183: POP
// end else
16184: GO 16374
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16186: LD_ADDR_VAR 0 3
16190: PUSH
16191: LD_OWVAR 3
16195: PUSH
16196: LD_VAR 0 1
16200: DIFF
16201: PPUSH
16202: LD_VAR 0 1
16206: PPUSH
16207: CALL_OW 74
16211: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16212: LD_VAR 0 1
16216: PPUSH
16217: CALL_OW 320
16221: NOT
16222: PUSH
16223: LD_VAR 0 3
16227: PUSH
16228: LD_INT 21
16230: PUSH
16231: LD_INT 2
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: LD_INT 33
16240: PUSH
16241: LD_INT 1
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: PUSH
16248: LD_INT 58
16250: PUSH
16251: EMPTY
16252: LIST
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: LIST
16258: PPUSH
16259: CALL_OW 69
16263: IN
16264: PUSH
16265: LD_VAR 0 3
16269: PUSH
16270: LD_INT 22
16272: PUSH
16273: LD_INT 3
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: PUSH
16280: LD_INT 21
16282: PUSH
16283: LD_INT 2
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: PUSH
16290: LD_INT 3
16292: PUSH
16293: LD_INT 24
16295: PUSH
16296: LD_INT 249
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: LIST
16311: PPUSH
16312: CALL_OW 69
16316: IN
16317: OR
16318: AND
16319: IFFALSE 16337
// ComAttackUnit ( i , un ) else
16321: LD_VAR 0 1
16325: PPUSH
16326: LD_VAR 0 3
16330: PPUSH
16331: CALL_OW 115
16335: GO 16374
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16337: LD_VAR 0 1
16341: PPUSH
16342: LD_INT 9
16344: PPUSH
16345: LD_INT 81
16347: PUSH
16348: LD_INT 3
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PPUSH
16355: CALL_OW 70
16359: PPUSH
16360: LD_VAR 0 1
16364: PPUSH
16365: CALL_OW 74
16369: PPUSH
16370: CALL_OW 115
// end ; end ; end ; end ;
16374: GO 15641
16376: POP
16377: POP
// end ;
16378: PPOPN 9
16380: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16381: LD_INT 22
16383: PUSH
16384: LD_INT 3
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: LD_INT 32
16393: PUSH
16394: LD_INT 1
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PPUSH
16405: CALL_OW 69
16409: IFFALSE 16497
16411: GO 16413
16413: DISABLE
16414: LD_INT 0
16416: PPUSH
16417: PPUSH
// begin enable ;
16418: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16419: LD_ADDR_VAR 0 2
16423: PUSH
16424: LD_INT 22
16426: PUSH
16427: LD_INT 3
16429: PUSH
16430: EMPTY
16431: LIST
16432: LIST
16433: PUSH
16434: LD_INT 32
16436: PUSH
16437: LD_INT 1
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PUSH
16444: EMPTY
16445: LIST
16446: LIST
16447: PPUSH
16448: CALL_OW 69
16452: ST_TO_ADDR
// for i in tmp do
16453: LD_ADDR_VAR 0 1
16457: PUSH
16458: LD_VAR 0 2
16462: PUSH
16463: FOR_IN
16464: IFFALSE 16495
// if GetFuel ( i ) < 12 then
16466: LD_VAR 0 1
16470: PPUSH
16471: CALL_OW 261
16475: PUSH
16476: LD_INT 12
16478: LESS
16479: IFFALSE 16493
// SetFuel ( i , 12 ) ;
16481: LD_VAR 0 1
16485: PPUSH
16486: LD_INT 12
16488: PPUSH
16489: CALL_OW 240
16493: GO 16463
16495: POP
16496: POP
// end ;
16497: PPOPN 2
16499: END
// every 0 0$1 trigger can_end do
16500: LD_EXP 17
16504: IFFALSE 16523
16506: GO 16508
16508: DISABLE
// begin Wait ( 1 1$35 ) ;
16509: LD_INT 3325
16511: PPUSH
16512: CALL_OW 67
// PrepareAttack ( 10 ) ;
16516: LD_INT 10
16518: PPUSH
16519: CALL 14356 0 1
// end ;
16523: END
