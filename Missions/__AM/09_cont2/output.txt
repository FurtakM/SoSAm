// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12658 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1708 0 0
// Action ;
  32: CALL 2648 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1641: LD_STRING GammaCommander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1676
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1676: LD_ADDR_EXP 25
1680: PUSH
1681: LD_STRING Powell
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_STRING 
1689: PPUSH
1690: CALL 201 0 3
1694: ST_TO_ADDR
// InitHc ;
1695: CALL_OW 19
// InitUc ;
1699: CALL_OW 18
// end ;
1703: LD_VAR 0 1
1707: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1708: LD_INT 0
1710: PPUSH
1711: PPUSH
1712: PPUSH
1713: PPUSH
1714: PPUSH
// uc_side := 4 ;
1715: LD_ADDR_OWVAR 20
1719: PUSH
1720: LD_INT 4
1722: ST_TO_ADDR
// uc_nation := 3 ;
1723: LD_ADDR_OWVAR 21
1727: PUSH
1728: LD_INT 3
1730: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_STRING 09_ovsyenko_base
1738: PPUSH
1739: LD_INT 0
1741: PUSH
1742: LD_INT 101
1744: PUSH
1745: LD_INT 118
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 500
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: LD_INT 31
1763: PUSH
1764: LD_INT 109
1766: PUSH
1767: LD_INT 114
1769: PUSH
1770: LD_INT 4
1772: PUSH
1773: LD_INT 500
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 115
1788: PUSH
1789: LD_INT 132
1791: PUSH
1792: LD_INT 5
1794: PUSH
1795: LD_INT 500
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 31
1807: PUSH
1808: LD_INT 98
1810: PUSH
1811: LD_INT 120
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 500
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL_OW 30
1837: ST_TO_ADDR
// for i in tmp do
1838: LD_ADDR_VAR 0 2
1842: PUSH
1843: LD_VAR 0 4
1847: PUSH
1848: FOR_IN
1849: IFFALSE 2005
// begin bc_type := i [ 1 ] ;
1851: LD_ADDR_OWVAR 42
1855: PUSH
1856: LD_VAR 0 2
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: ST_TO_ADDR
// bc_level := 3 ;
1865: LD_ADDR_OWVAR 43
1869: PUSH
1870: LD_INT 3
1872: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_VAR 0 2
1882: PUSH
1883: LD_INT 2
1885: ARRAY
1886: PPUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_INT 3
1894: ARRAY
1895: PPUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 4
1903: ARRAY
1904: PPUSH
1905: CALL_OW 47
1909: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 266
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: IFFALSE 1957
// begin SetBName ( b , ovsyenko ) ;
1925: LD_VAR 0 3
1929: PPUSH
1930: LD_STRING ovsyenko
1932: PPUSH
1933: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: CALL_OW 274
1946: PPUSH
1947: LD_INT 1
1949: PPUSH
1950: LD_INT 50
1952: PPUSH
1953: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 5
1964: ARRAY
1965: PUSH
1966: LD_INT 250
1968: LESS
1969: IFFALSE 1985
// SetLives ( b , 333 ) else
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_INT 333
1978: PPUSH
1979: CALL_OW 234
1983: GO 2003
// SetLives ( b , i [ 5 ] ) ;
1985: LD_VAR 0 3
1989: PPUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 5
1997: ARRAY
1998: PPUSH
1999: CALL_OW 234
// end ;
2003: GO 1848
2005: POP
2006: POP
// uc_nation := 1 ;
2007: LD_ADDR_OWVAR 21
2011: PUSH
2012: LD_INT 1
2014: ST_TO_ADDR
// tmp := [ ] ;
2015: LD_ADDR_VAR 0 4
2019: PUSH
2020: EMPTY
2021: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2022: LD_ADDR_EXP 19
2026: PUSH
2027: LD_STRING Gary
2029: PPUSH
2030: LD_EXP 2
2034: NOT
2035: PPUSH
2036: LD_STRING 
2038: PPUSH
2039: CALL 201 0 3
2043: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2044: LD_ADDR_VAR 0 4
2048: PUSH
2049: LD_VAR 0 4
2053: PUSH
2054: LD_EXP 19
2058: ADD
2059: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2060: LD_ADDR_EXP 20
2064: PUSH
2065: LD_STRING Bobby
2067: PPUSH
2068: LD_EXP 2
2072: NOT
2073: PPUSH
2074: LD_STRING 08_
2076: PPUSH
2077: CALL 201 0 3
2081: ST_TO_ADDR
// if not Bobby then
2082: LD_EXP 20
2086: NOT
2087: IFFALSE 2111
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2089: LD_ADDR_EXP 20
2093: PUSH
2094: LD_STRING Bobby
2096: PPUSH
2097: LD_EXP 2
2101: NOT
2102: PPUSH
2103: LD_STRING 03_
2105: PPUSH
2106: CALL 201 0 3
2110: ST_TO_ADDR
// if Bobby then
2111: LD_EXP 20
2115: IFFALSE 2133
// tmp := tmp ^ Bobby ;
2117: LD_ADDR_VAR 0 4
2121: PUSH
2122: LD_VAR 0 4
2126: PUSH
2127: LD_EXP 20
2131: ADD
2132: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2133: LD_ADDR_EXP 21
2137: PUSH
2138: LD_STRING Cyrus
2140: PPUSH
2141: LD_EXP 2
2145: NOT
2146: PPUSH
2147: LD_STRING 08_
2149: PPUSH
2150: CALL 201 0 3
2154: ST_TO_ADDR
// if not Cyrus then
2155: LD_EXP 21
2159: NOT
2160: IFFALSE 2184
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2162: LD_ADDR_EXP 21
2166: PUSH
2167: LD_STRING Cyrus
2169: PPUSH
2170: LD_EXP 2
2174: NOT
2175: PPUSH
2176: LD_STRING 03_
2178: PPUSH
2179: CALL 201 0 3
2183: ST_TO_ADDR
// if Cyrus then
2184: LD_EXP 21
2188: IFFALSE 2206
// tmp := tmp ^ Cyrus ;
2190: LD_ADDR_VAR 0 4
2194: PUSH
2195: LD_VAR 0 4
2199: PUSH
2200: LD_EXP 21
2204: ADD
2205: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2206: LD_ADDR_VAR 0 4
2210: PUSH
2211: LD_VAR 0 4
2215: PUSH
2216: LD_STRING 09_prev_squad
2218: PPUSH
2219: CALL_OW 31
2223: ADD
2224: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2225: LD_STRING 09_prev_squad
2227: PPUSH
2228: CALL_OW 40
// tmp := tmp diff 0 ;
2232: LD_ADDR_VAR 0 4
2236: PUSH
2237: LD_VAR 0 4
2241: PUSH
2242: LD_INT 0
2244: DIFF
2245: ST_TO_ADDR
// if debug then
2246: LD_EXP 2
2250: IFFALSE 2301
// begin for i = 1 to 6 do
2252: LD_ADDR_VAR 0 2
2256: PUSH
2257: DOUBLE
2258: LD_INT 1
2260: DEC
2261: ST_TO_ADDR
2262: LD_INT 6
2264: PUSH
2265: FOR_TO
2266: IFFALSE 2299
// begin PrepareHuman ( false , 1 , 6 ) ;
2268: LD_INT 0
2270: PPUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 6
2276: PPUSH
2277: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: CALL_OW 44
2295: ADD
2296: ST_TO_ADDR
// end ;
2297: GO 2265
2299: POP
2300: POP
// end ; for i in tmp do
2301: LD_ADDR_VAR 0 2
2305: PUSH
2306: LD_VAR 0 4
2310: PUSH
2311: FOR_IN
2312: IFFALSE 2371
// begin if GetClass ( i ) in [ 2 , 3 ] then
2314: LD_VAR 0 2
2318: PPUSH
2319: CALL_OW 257
2323: PUSH
2324: LD_INT 2
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: IN
2334: IFFALSE 2348
// SetClass ( i , 1 ) ;
2336: LD_VAR 0 2
2340: PPUSH
2341: LD_INT 1
2343: PPUSH
2344: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2348: LD_VAR 0 2
2352: PPUSH
2353: LD_INT 106
2355: PPUSH
2356: LD_INT 122
2358: PPUSH
2359: LD_INT 5
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 50
// end ;
2369: GO 2311
2371: POP
2372: POP
// tmp := tmp diff Gary ;
2373: LD_ADDR_VAR 0 4
2377: PUSH
2378: LD_VAR 0 4
2382: PUSH
2383: LD_EXP 19
2387: DIFF
2388: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2389: LD_ADDR_VAR 0 3
2393: PUSH
2394: LD_INT 22
2396: PUSH
2397: LD_INT 4
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PUSH
2404: LD_INT 30
2406: PUSH
2407: LD_INT 31
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: PPUSH
2418: CALL_OW 69
2422: ST_TO_ADDR
// for i = 1 to b do
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: DOUBLE
2429: LD_INT 1
2431: DEC
2432: ST_TO_ADDR
2433: LD_VAR 0 3
2437: PUSH
2438: FOR_TO
2439: IFFALSE 2469
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2441: LD_VAR 0 4
2445: PUSH
2446: LD_VAR 0 2
2450: ARRAY
2451: PPUSH
2452: LD_VAR 0 3
2456: PUSH
2457: LD_VAR 0 2
2461: ARRAY
2462: PPUSH
2463: CALL_OW 120
// end ;
2467: GO 2438
2469: POP
2470: POP
// InitHc ;
2471: CALL_OW 19
// InitUc ;
2475: CALL_OW 18
// end ;
2479: LD_VAR 0 1
2483: RET
// export function PowellTransport ; var i , un ; begin
2484: LD_INT 0
2486: PPUSH
2487: PPUSH
2488: PPUSH
// uc_side := 4 ;
2489: LD_ADDR_OWVAR 20
2493: PUSH
2494: LD_INT 4
2496: ST_TO_ADDR
// uc_nation := 1 ;
2497: LD_ADDR_OWVAR 21
2501: PUSH
2502: LD_INT 1
2504: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2505: LD_INT 1
2507: PPUSH
2508: LD_INT 3
2510: PPUSH
2511: LD_INT 6
2513: PPUSH
2514: CALL_OW 380
// hc_name :=  ;
2518: LD_ADDR_OWVAR 26
2522: PUSH
2523: LD_STRING 
2525: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2526: LD_ADDR_OWVAR 33
2530: PUSH
2531: LD_STRING SecondCharsGal
2533: ST_TO_ADDR
// hc_face_number := 30 ;
2534: LD_ADDR_OWVAR 34
2538: PUSH
2539: LD_INT 30
2541: ST_TO_ADDR
// powell_trans := CreateHuman ;
2542: LD_ADDR_EXP 24
2546: PUSH
2547: CALL_OW 44
2551: ST_TO_ADDR
// hc_face_number := 31 ;
2552: LD_ADDR_OWVAR 34
2556: PUSH
2557: LD_INT 31
2559: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2560: LD_ADDR_EXP 24
2564: PUSH
2565: LD_EXP 24
2569: PUSH
2570: CALL_OW 44
2574: ADD
2575: ST_TO_ADDR
// for i = 1 to 2 do
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: DOUBLE
2582: LD_INT 1
2584: DEC
2585: ST_TO_ADDR
2586: LD_INT 2
2588: PUSH
2589: FOR_TO
2590: IFFALSE 2641
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2592: LD_ADDR_VAR 0 3
2596: PUSH
2597: LD_INT 4
2599: PPUSH
2600: LD_INT 1
2602: PPUSH
2603: LD_INT 3
2605: PPUSH
2606: LD_INT 1
2608: PPUSH
2609: LD_INT 1
2611: PPUSH
2612: LD_INT 12
2614: PPUSH
2615: LD_INT 66
2617: PPUSH
2618: CALL 264 0 7
2622: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2623: LD_ADDR_EXP 24
2627: PUSH
2628: LD_EXP 24
2632: PUSH
2633: LD_VAR 0 3
2637: ADD
2638: ST_TO_ADDR
// end ;
2639: GO 2589
2641: POP
2642: POP
// end ; end_of_file
2643: LD_VAR 0 1
2647: RET
// export function Action ; var i , veh ; begin
2648: LD_INT 0
2650: PPUSH
2651: PPUSH
2652: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2653: LD_EXP 23
2657: PPUSH
2658: LD_INT 0
2660: PPUSH
2661: LD_INT 50
2663: PPUSH
2664: LD_INT 38
2666: PPUSH
2667: LD_INT 2
2669: PPUSH
2670: CALL_OW 145
// InGameOn ;
2674: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2678: LD_INT 43
2680: PPUSH
2681: LD_INT 9
2683: PPUSH
2684: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2688: LD_EXP 18
2692: PPUSH
2693: LD_INT 54
2695: PPUSH
2696: LD_INT 34
2698: PPUSH
2699: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2703: LD_EXP 18
2707: PPUSH
2708: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2712: LD_EXP 18
2716: PPUSH
2717: LD_EXP 23
2721: PUSH
2722: LD_INT 1
2724: ARRAY
2725: PPUSH
2726: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2730: LD_INT 35
2732: PPUSH
2733: CALL_OW 67
// until See ( 4 , JMM ) ;
2737: LD_INT 4
2739: PPUSH
2740: LD_EXP 18
2744: PPUSH
2745: CALL_OW 292
2749: IFFALSE 2730
// CenterNowOnUnits ( JMM ) ;
2751: LD_EXP 18
2755: PPUSH
2756: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2760: LD_EXP 18
2764: PPUSH
2765: LD_STRING D2-JMM-1
2767: PPUSH
2768: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2772: LD_EXP 23
2776: PUSH
2777: LD_INT 3
2779: ARRAY
2780: PPUSH
2781: LD_EXP 18
2785: PPUSH
2786: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2790: LD_EXP 23
2794: PUSH
2795: LD_INT 3
2797: ARRAY
2798: PPUSH
2799: LD_STRING D2-Eng1-1
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2806: LD_EXP 18
2810: PPUSH
2811: LD_STRING D2-JMM-2
2813: PPUSH
2814: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2818: LD_EXP 23
2822: PUSH
2823: LD_INT 3
2825: ARRAY
2826: PPUSH
2827: LD_STRING D2-Eng1-2
2829: PPUSH
2830: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2834: LD_EXP 18
2838: PPUSH
2839: LD_STRING D2-JMM-3
2841: PPUSH
2842: CALL_OW 88
// if Houten then
2846: LD_EXP 22
2850: IFFALSE 3048
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2852: LD_ADDR_VAR 0 3
2856: PUSH
2857: LD_INT 4
2859: PPUSH
2860: LD_INT 1
2862: PPUSH
2863: LD_INT 3
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: LD_INT 1
2871: PPUSH
2872: LD_INT 4
2874: PPUSH
2875: LD_INT 55
2877: PPUSH
2878: CALL 264 0 7
2882: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2883: LD_VAR 0 3
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2895: LD_VAR 0 3
2899: PPUSH
2900: LD_INT 46
2902: PPUSH
2903: LD_INT 19
2905: PPUSH
2906: LD_INT 0
2908: PPUSH
2909: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2913: LD_EXP 22
2917: PPUSH
2918: LD_VAR 0 3
2922: PPUSH
2923: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2927: LD_EXP 22
2931: PPUSH
2932: LD_INT 49
2934: PPUSH
2935: LD_INT 33
2937: PPUSH
2938: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2942: LD_EXP 22
2946: PPUSH
2947: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2951: LD_EXP 22
2955: PPUSH
2956: LD_EXP 18
2960: PPUSH
2961: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2965: LD_INT 35
2967: PPUSH
2968: CALL_OW 67
// until See ( 1 , Houten ) ;
2972: LD_INT 1
2974: PPUSH
2975: LD_EXP 22
2979: PPUSH
2980: CALL_OW 292
2984: IFFALSE 2965
// ComTurnUnit ( JMM , Houten ) ;
2986: LD_EXP 18
2990: PPUSH
2991: LD_EXP 22
2995: PPUSH
2996: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3000: LD_EXP 18
3004: PPUSH
3005: LD_STRING D1d-JMM-1
3007: PPUSH
3008: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3012: LD_EXP 22
3016: PPUSH
3017: LD_STRING D1-VanH-1
3019: PPUSH
3020: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3024: LD_EXP 18
3028: PPUSH
3029: LD_STRING D1-JMM-1v
3031: PPUSH
3032: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3036: LD_EXP 18
3040: PPUSH
3041: LD_STRING D1-JMM-2v
3043: PPUSH
3044: CALL_OW 88
// end ; InGameOff ;
3048: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3052: LD_STRING M1
3054: PPUSH
3055: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3059: LD_INT 22
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 92
3071: PUSH
3072: LD_EXP 18
3076: PPUSH
3077: CALL_OW 250
3081: PUSH
3082: LD_EXP 18
3086: PPUSH
3087: CALL_OW 251
3091: PUSH
3092: LD_INT 15
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PPUSH
3110: LD_INT 1
3112: PPUSH
3113: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3117: LD_EXP 23
3121: PUSH
3122: LD_EXP 18
3126: ADD
3127: PUSH
3128: LD_EXP 22
3132: ADD
3133: PPUSH
3134: CALL_OW 141
// end ;
3138: LD_VAR 0 1
3142: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3143: LD_INT 1
3145: PPUSH
3146: LD_EXP 19
3150: PPUSH
3151: CALL_OW 292
3155: PUSH
3156: LD_EXP 18
3160: PPUSH
3161: LD_EXP 19
3165: PPUSH
3166: CALL_OW 296
3170: PUSH
3171: LD_INT 6
3173: LESS
3174: AND
3175: IFFALSE 3938
3177: GO 3179
3179: DISABLE
3180: LD_INT 0
3182: PPUSH
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
// begin InGameOn ;
3187: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3191: LD_INT 22
3193: PUSH
3194: LD_INT 4
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: PPUSH
3201: CALL_OW 69
3205: PPUSH
3206: LD_INT 1
3208: PPUSH
3209: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3213: LD_ADDR_VAR 0 4
3217: PUSH
3218: LD_INT 22
3220: PUSH
3221: LD_INT 1
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: LD_INT 2
3230: PUSH
3231: LD_INT 25
3233: PUSH
3234: LD_INT 1
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: PUSH
3241: LD_INT 25
3243: PUSH
3244: LD_INT 2
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 25
3253: PUSH
3254: LD_INT 3
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 25
3263: PUSH
3264: LD_INT 4
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 69
3286: ST_TO_ADDR
// ComHold ( tmp ) ;
3287: LD_VAR 0 4
3291: PPUSH
3292: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3296: LD_EXP 18
3300: PPUSH
3301: LD_STRING D2-JMM-3a
3303: PPUSH
3304: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3308: LD_EXP 19
3312: PPUSH
3313: LD_EXP 18
3317: PPUSH
3318: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3322: LD_EXP 19
3326: PPUSH
3327: LD_STRING D2-Gary-3
3329: PPUSH
3330: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3334: LD_EXP 18
3338: PPUSH
3339: LD_EXP 19
3343: PPUSH
3344: CALL_OW 119
// for i in tmp do
3348: LD_ADDR_VAR 0 5
3352: PUSH
3353: LD_VAR 0 4
3357: PUSH
3358: FOR_IN
3359: IFFALSE 3404
// begin if IsInUnit ( i ) then
3361: LD_VAR 0 5
3365: PPUSH
3366: CALL_OW 310
3370: IFFALSE 3381
// ComExitBuilding ( i ) ;
3372: LD_VAR 0 5
3376: PPUSH
3377: CALL_OW 122
// wait ( 1 ) ;
3381: LD_INT 1
3383: PPUSH
3384: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3388: LD_VAR 0 5
3392: PPUSH
3393: LD_EXP 18
3397: PPUSH
3398: CALL_OW 119
// end ;
3402: GO 3358
3404: POP
3405: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3406: LD_ADDR_VAR 0 4
3410: PUSH
3411: LD_VAR 0 4
3415: PUSH
3416: LD_EXP 18
3420: PUSH
3421: LD_EXP 22
3425: PUSH
3426: LD_EXP 19
3430: PUSH
3431: LD_EXP 21
3435: PUSH
3436: LD_EXP 20
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: PUSH
3448: LD_EXP 23
3452: ADD
3453: DIFF
3454: ST_TO_ADDR
// if Bobby then
3455: LD_EXP 20
3459: IFFALSE 3473
// Say ( Bobby , D2-Bobby-3 ) ;
3461: LD_EXP 20
3465: PPUSH
3466: LD_STRING D2-Bobby-3
3468: PPUSH
3469: CALL_OW 88
// if Cyrus then
3473: LD_EXP 21
3477: IFFALSE 3491
// Say ( Cyrus , D2-Cyrus-3 ) ;
3479: LD_EXP 21
3483: PPUSH
3484: LD_STRING D2-Cyrus-3
3486: PPUSH
3487: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3491: LD_EXP 18
3495: PPUSH
3496: LD_STRING D2-JMM-4
3498: PPUSH
3499: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3503: LD_EXP 19
3507: PPUSH
3508: LD_STRING D2-Gary-4
3510: PPUSH
3511: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3515: LD_ADDR_VAR 0 1
3519: PUSH
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 26
3527: PUSH
3528: LD_INT 1
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: PUSH
3540: LD_INT 1
3542: ARRAY
3543: ST_TO_ADDR
// if Cyrus then
3544: LD_EXP 21
3548: IFFALSE 3564
// Say ( Cyrus , D2-Cyrus-4 ) else
3550: LD_EXP 21
3554: PPUSH
3555: LD_STRING D2-Cyrus-4
3557: PPUSH
3558: CALL_OW 88
3562: GO 3576
// Say ( un1 , D2-Sol1-4 ) ;
3564: LD_VAR 0 1
3568: PPUSH
3569: LD_STRING D2-Sol1-4
3571: PPUSH
3572: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3576: LD_EXP 18
3580: PPUSH
3581: LD_STRING D2-JMM-5
3583: PPUSH
3584: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_EXP 23
3597: PPUSH
3598: LD_INT 91
3600: PUSH
3601: LD_EXP 18
3605: PUSH
3606: LD_INT 10
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 26
3616: PUSH
3617: LD_INT 2
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PPUSH
3628: CALL_OW 72
3632: ST_TO_ADDR
// if un2 then
3633: LD_VAR 0 2
3637: IFFALSE 3691
// begin un2 := un2 [ un2 ] ;
3639: LD_ADDR_VAR 0 2
3643: PUSH
3644: LD_VAR 0 2
3648: PUSH
3649: LD_VAR 0 2
3653: ARRAY
3654: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3655: LD_VAR 0 2
3659: PPUSH
3660: LD_STRING D2-FEng1-5
3662: PPUSH
3663: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3667: LD_EXP 18
3671: PPUSH
3672: LD_STRING D2-JMM-6
3674: PPUSH
3675: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3679: LD_VAR 0 2
3683: PPUSH
3684: LD_STRING D2-FEng1-6
3686: PPUSH
3687: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3691: LD_ADDR_VAR 0 3
3695: PUSH
3696: LD_EXP 23
3700: PPUSH
3701: LD_INT 91
3703: PUSH
3704: LD_EXP 18
3708: PUSH
3709: LD_INT 10
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 26
3719: PUSH
3720: LD_INT 1
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PPUSH
3731: CALL_OW 72
3735: ST_TO_ADDR
// if un3 then
3736: LD_VAR 0 3
3740: IFFALSE 3795
// begin un3 := un3 [ 1 ] ;
3742: LD_ADDR_VAR 0 3
3746: PUSH
3747: LD_VAR 0 3
3751: PUSH
3752: LD_INT 1
3754: ARRAY
3755: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3756: LD_VAR 0 3
3760: PPUSH
3761: LD_INT 114
3763: PPUSH
3764: LD_INT 122
3766: PPUSH
3767: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3771: LD_VAR 0 3
3775: PPUSH
3776: LD_STRING D2-Eng1-6
3778: PPUSH
3779: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3783: LD_EXP 18
3787: PPUSH
3788: LD_STRING D2-JMM-7
3790: PPUSH
3791: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3795: LD_EXP 19
3799: PPUSH
3800: LD_STRING D2-Gary-7
3802: PPUSH
3803: CALL_OW 88
// if un2 then
3807: LD_VAR 0 2
3811: IFFALSE 3825
// Say ( un2 , D2-FEng1-7 ) ;
3813: LD_VAR 0 2
3817: PPUSH
3818: LD_STRING D2-FEng1-7
3820: PPUSH
3821: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3825: LD_VAR 0 1
3829: PPUSH
3830: LD_STRING D2-Sol1-7
3832: PPUSH
3833: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3837: LD_EXP 18
3841: PPUSH
3842: LD_STRING D2-JMM-8
3844: PPUSH
3845: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3849: LD_INT 22
3851: PUSH
3852: LD_INT 1
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PPUSH
3859: CALL_OW 69
3863: PPUSH
3864: CALL_OW 141
// InGameOff ;
3868: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3872: LD_STRING M1a
3874: PPUSH
3875: CALL_OW 337
// jmm_in_ovsyenko := true ;
3879: LD_ADDR_EXP 4
3883: PUSH
3884: LD_INT 1
3886: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3887: LD_INT 1050
3889: PPUSH
3890: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: LD_INT 25
3901: PUSH
3902: LD_INT 14
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PPUSH
3909: CALL_OW 69
3913: ST_TO_ADDR
// if not tmp then
3914: LD_VAR 0 4
3918: NOT
3919: IFFALSE 3923
// exit ;
3921: GO 3938
// ComMoveXY ( tmp , 75 , 75 ) ;
3923: LD_VAR 0 4
3927: PPUSH
3928: LD_INT 75
3930: PPUSH
3931: LD_INT 75
3933: PPUSH
3934: CALL_OW 111
// end ;
3938: PPOPN 5
3940: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3941: LD_INT 22
3943: PUSH
3944: LD_INT 1
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: PUSH
3951: LD_INT 30
3953: PUSH
3954: LD_INT 30
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PUSH
3961: LD_INT 3
3963: PUSH
3964: LD_INT 57
3966: PUSH
3967: EMPTY
3968: LIST
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: PPUSH
3979: CALL_OW 69
3983: IFFALSE 4025
3985: GO 3987
3987: DISABLE
3988: LD_INT 0
3990: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3991: LD_ADDR_VAR 0 1
3995: PUSH
3996: LD_STRING M2easy
3998: PUSH
3999: LD_STRING M2
4001: PUSH
4002: LD_STRING M2hard
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4010: LD_VAR 0 1
4014: PUSH
4015: LD_OWVAR 67
4019: ARRAY
4020: PPUSH
4021: CALL_OW 337
// end ;
4025: PPOPN 1
4027: END
// every 3 3$00 do
4028: GO 4030
4030: DISABLE
// begin DialogueOn ;
4031: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4035: LD_EXP 25
4039: PPUSH
4040: LD_STRING D3-Pow-1
4042: PPUSH
4043: CALL_OW 94
// if jmm_in_ovsyenko then
4047: LD_EXP 4
4051: IFFALSE 4079
// begin Say ( JMM , D3-JMM-1 ) ;
4053: LD_EXP 18
4057: PPUSH
4058: LD_STRING D3-JMM-1
4060: PPUSH
4061: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4065: LD_EXP 18
4069: PPUSH
4070: LD_STRING D3-JMM-1b
4072: PPUSH
4073: CALL_OW 88
// end else
4077: GO 4091
// Say ( JMM , D3-JMM-1a ) ;
4079: LD_EXP 18
4083: PPUSH
4084: LD_STRING D3-JMM-1a
4086: PPUSH
4087: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4091: LD_EXP 25
4095: PPUSH
4096: LD_STRING D3-Pow-2
4098: PPUSH
4099: CALL_OW 94
// DialogueOff ;
4103: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4107: LD_STRING M3
4109: PPUSH
4110: CALL_OW 337
// powell_want_sib := true ;
4114: LD_ADDR_EXP 5
4118: PUSH
4119: LD_INT 1
4121: ST_TO_ADDR
// end ;
4122: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4123: LD_EXP 6
4127: PUSH
4128: LD_INT 0
4130: EQUAL
4131: IFFALSE 5578
4133: GO 4135
4135: DISABLE
4136: LD_INT 0
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
4145: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4146: LD_INT 4
4148: PPUSH
4149: LD_INT 1
4151: PPUSH
4152: CALL_OW 343
// PowellTransport ;
4156: CALL 2484 0 0
// for i = 1 to 3 do
4160: LD_ADDR_VAR 0 4
4164: PUSH
4165: DOUBLE
4166: LD_INT 1
4168: DEC
4169: ST_TO_ADDR
4170: LD_INT 3
4172: PUSH
4173: FOR_TO
4174: IFFALSE 4241
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4176: LD_ADDR_VAR 0 1
4180: PUSH
4181: LD_INT 6
4183: PPUSH
4184: LD_VAR 0 4
4188: PPUSH
4189: CALL_OW 287
4193: ST_TO_ADDR
// if not tmp then
4194: LD_VAR 0 1
4198: NOT
4199: IFFALSE 4203
// continue ;
4201: GO 4173
// EraseResourceArea ( terminalArea , i ) ;
4203: LD_INT 6
4205: PPUSH
4206: LD_VAR 0 4
4210: PPUSH
4211: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4215: LD_EXP 3
4219: PPUSH
4220: CALL_OW 274
4224: PPUSH
4225: LD_VAR 0 4
4229: PPUSH
4230: LD_VAR 0 1
4234: PPUSH
4235: CALL_OW 276
// end ;
4239: GO 4173
4241: POP
4242: POP
// x := 43 ;
4243: LD_ADDR_VAR 0 2
4247: PUSH
4248: LD_INT 43
4250: ST_TO_ADDR
// y := 3 ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: LD_INT 3
4258: ST_TO_ADDR
// for i = 3 to 4 do
4259: LD_ADDR_VAR 0 4
4263: PUSH
4264: DOUBLE
4265: LD_INT 3
4267: DEC
4268: ST_TO_ADDR
4269: LD_INT 4
4271: PUSH
4272: FOR_TO
4273: IFFALSE 4464
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4275: LD_EXP 24
4279: PUSH
4280: LD_VAR 0 4
4284: ARRAY
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4293: LD_EXP 24
4297: PUSH
4298: LD_VAR 0 4
4302: ARRAY
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: LD_VAR 0 3
4313: PPUSH
4314: LD_INT 0
4316: PPUSH
4317: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4321: LD_EXP 24
4325: PUSH
4326: LD_VAR 0 4
4330: PUSH
4331: LD_INT 2
4333: MINUS
4334: ARRAY
4335: PPUSH
4336: LD_EXP 24
4340: PUSH
4341: LD_VAR 0 4
4345: ARRAY
4346: PPUSH
4347: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4351: LD_EXP 24
4355: PUSH
4356: LD_VAR 0 4
4360: ARRAY
4361: PPUSH
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 100
4367: PPUSH
4368: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4372: LD_EXP 24
4376: PUSH
4377: LD_VAR 0 4
4381: PUSH
4382: LD_INT 2
4384: MINUS
4385: ARRAY
4386: PPUSH
4387: LD_INT 54
4389: PPUSH
4390: LD_INT 42
4392: PPUSH
4393: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4397: LD_EXP 24
4401: PUSH
4402: LD_VAR 0 4
4406: PUSH
4407: LD_INT 2
4409: MINUS
4410: ARRAY
4411: PPUSH
4412: LD_EXP 3
4416: PPUSH
4417: CALL_OW 250
4421: PPUSH
4422: LD_EXP 3
4426: PPUSH
4427: CALL_OW 251
4431: PPUSH
4432: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4436: LD_EXP 24
4440: PUSH
4441: LD_VAR 0 4
4445: PUSH
4446: LD_INT 2
4448: MINUS
4449: ARRAY
4450: PPUSH
4451: CALL_OW 200
// Wait ( 0 0$02 ) ;
4455: LD_INT 70
4457: PPUSH
4458: CALL_OW 67
// end ;
4462: GO 4272
4464: POP
4465: POP
// time := 0 0$20 ;
4466: LD_ADDR_VAR 0 8
4470: PUSH
4471: LD_INT 700
4473: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4474: LD_INT 35
4476: PPUSH
4477: CALL_OW 67
// time := time - 0 0$01 ;
4481: LD_ADDR_VAR 0 8
4485: PUSH
4486: LD_VAR 0 8
4490: PUSH
4491: LD_INT 35
4493: MINUS
4494: ST_TO_ADDR
// for i = 3 to 4 do
4495: LD_ADDR_VAR 0 4
4499: PUSH
4500: DOUBLE
4501: LD_INT 3
4503: DEC
4504: ST_TO_ADDR
4505: LD_INT 4
4507: PUSH
4508: FOR_TO
4509: IFFALSE 4644
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4511: LD_EXP 24
4515: PUSH
4516: LD_VAR 0 4
4520: ARRAY
4521: PPUSH
4522: LD_INT 1
4524: PPUSH
4525: CALL_OW 289
4529: PUSH
4530: LD_INT 0
4532: GREATER
4533: PUSH
4534: LD_EXP 24
4538: PUSH
4539: LD_VAR 0 4
4543: ARRAY
4544: PPUSH
4545: CALL_OW 314
4549: NOT
4550: AND
4551: IFFALSE 4642
// begin x := rand ( 0 , 5 ) ;
4553: LD_ADDR_VAR 0 2
4557: PUSH
4558: LD_INT 0
4560: PPUSH
4561: LD_INT 5
4563: PPUSH
4564: CALL_OW 12
4568: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4569: LD_EXP 24
4573: PUSH
4574: LD_VAR 0 4
4578: ARRAY
4579: PPUSH
4580: LD_EXP 24
4584: PUSH
4585: LD_VAR 0 4
4589: ARRAY
4590: PPUSH
4591: CALL_OW 250
4595: PPUSH
4596: LD_VAR 0 2
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: CALL_OW 272
4608: PPUSH
4609: LD_EXP 24
4613: PUSH
4614: LD_VAR 0 4
4618: ARRAY
4619: PPUSH
4620: CALL_OW 251
4624: PPUSH
4625: LD_VAR 0 2
4629: PPUSH
4630: LD_INT 3
4632: PPUSH
4633: CALL_OW 273
4637: PPUSH
4638: CALL_OW 171
// end ;
4642: GO 4508
4644: POP
4645: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4646: LD_EXP 24
4650: PUSH
4651: LD_INT 1
4653: ARRAY
4654: PPUSH
4655: LD_INT 54
4657: PPUSH
4658: LD_INT 42
4660: PPUSH
4661: CALL_OW 297
4665: PUSH
4666: LD_INT 4
4668: LESS
4669: PUSH
4670: LD_VAR 0 8
4674: PUSH
4675: LD_INT 0
4677: EQUAL
4678: OR
4679: IFFALSE 4474
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4681: LD_EXP 24
4685: PUSH
4686: LD_INT 3
4688: ARRAY
4689: PPUSH
4690: LD_INT 1
4692: PPUSH
4693: LD_INT 0
4695: PPUSH
4696: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4700: LD_EXP 24
4704: PUSH
4705: LD_INT 4
4707: ARRAY
4708: PPUSH
4709: LD_INT 1
4711: PPUSH
4712: LD_INT 0
4714: PPUSH
4715: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4719: LD_EXP 3
4723: PPUSH
4724: CALL_OW 274
4728: PPUSH
4729: LD_INT 1
4731: PPUSH
4732: LD_INT 200
4734: PPUSH
4735: CALL_OW 276
// DialogueOn ;
4739: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4743: LD_INT 53
4745: PPUSH
4746: LD_INT 35
4748: PPUSH
4749: CALL_OW 86
// un := powell_trans [ 1 ] ;
4753: LD_ADDR_VAR 0 5
4757: PUSH
4758: LD_EXP 24
4762: PUSH
4763: LD_INT 1
4765: ARRAY
4766: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4767: LD_VAR 0 5
4771: PPUSH
4772: LD_STRING D4-Mech1-1
4774: PPUSH
4775: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4779: LD_EXP 18
4783: PPUSH
4784: LD_STRING D4-JMM-1
4786: PPUSH
4787: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4791: LD_VAR 0 5
4795: PPUSH
4796: LD_STRING D4-Mech1-2
4798: PPUSH
4799: CALL_OW 88
// powell_happy := false ;
4803: LD_ADDR_VAR 0 6
4807: PUSH
4808: LD_INT 0
4810: ST_TO_ADDR
// take_cargo := false ;
4811: LD_ADDR_VAR 0 7
4815: PUSH
4816: LD_INT 0
4818: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4819: CALL 784 0 0
4823: PUSH
4824: LD_INT 60
4826: GREATEREQUAL
4827: IFFALSE 4875
// begin Say ( JMM , D5-JMM-1 ) ;
4829: LD_EXP 18
4833: PPUSH
4834: LD_STRING D5-JMM-1
4836: PPUSH
4837: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4841: LD_VAR 0 5
4845: PPUSH
4846: LD_STRING D6-Mech1-1
4848: PPUSH
4849: CALL_OW 88
// powell_happy := true ;
4853: LD_ADDR_VAR 0 6
4857: PUSH
4858: LD_INT 1
4860: ST_TO_ADDR
// take_cargo := true ;
4861: LD_ADDR_VAR 0 7
4865: PUSH
4866: LD_INT 1
4868: ST_TO_ADDR
// DialogueOff ;
4869: CALL_OW 7
// end else
4873: GO 5109
// if GetTerminalCargo > 0 then
4875: CALL 784 0 0
4879: PUSH
4880: LD_INT 0
4882: GREATER
4883: IFFALSE 5081
// begin case Query ( QWait ) of 1 :
4885: LD_STRING QWait
4887: PPUSH
4888: CALL_OW 97
4892: PUSH
4893: LD_INT 1
4895: DOUBLE
4896: EQUAL
4897: IFTRUE 4901
4899: GO 4992
4901: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4902: LD_EXP 18
4906: PPUSH
4907: LD_STRING D5b-JMM-1
4909: PPUSH
4910: CALL_OW 88
// DialogueOff ;
4914: CALL_OW 7
// wait ( 5 5$00 ) ;
4918: LD_INT 10500
4920: PPUSH
4921: CALL_OW 67
// if GetTerminalCargo < 60 then
4925: CALL 784 0 0
4929: PUSH
4930: LD_INT 60
4932: LESS
4933: IFFALSE 4974
// begin DialogueOn ;
4935: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4939: LD_EXP 3
4943: PPUSH
4944: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_STRING D6-Mech1-1a
4955: PPUSH
4956: CALL_OW 88
// DialogueOff ;
4960: CALL_OW 7
// powell_happy := false ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_INT 0
4971: ST_TO_ADDR
// end else
4972: GO 4990
// begin powell_happy := true ;
4974: LD_ADDR_VAR 0 6
4978: PUSH
4979: LD_INT 1
4981: ST_TO_ADDR
// take_cargo := true ;
4982: LD_ADDR_VAR 0 7
4986: PUSH
4987: LD_INT 1
4989: ST_TO_ADDR
// end ; end ; 2 :
4990: GO 5079
4992: LD_INT 2
4994: DOUBLE
4995: EQUAL
4996: IFTRUE 5000
4998: GO 5039
5000: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5001: LD_EXP 18
5005: PPUSH
5006: LD_STRING D5b-JMM-1
5008: PPUSH
5009: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5013: LD_VAR 0 5
5017: PPUSH
5018: LD_STRING D6-Mech1-1a
5020: PPUSH
5021: CALL_OW 88
// DialogueOff ;
5025: CALL_OW 7
// take_cargo := true ;
5029: LD_ADDR_VAR 0 7
5033: PUSH
5034: LD_INT 1
5036: ST_TO_ADDR
// end ; 3 :
5037: GO 5079
5039: LD_INT 3
5041: DOUBLE
5042: EQUAL
5043: IFTRUE 5047
5045: GO 5078
5047: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5048: LD_EXP 18
5052: PPUSH
5053: LD_STRING D5c-JMM-1
5055: PPUSH
5056: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5060: LD_VAR 0 5
5064: PPUSH
5065: LD_STRING D6-Mech1-1b
5067: PPUSH
5068: CALL_OW 88
// DialogueOff ;
5072: CALL_OW 7
// end ; end ;
5076: GO 5079
5078: POP
// end else
5079: GO 5109
// begin Say ( JMM , D5c-JMM-1 ) ;
5081: LD_EXP 18
5085: PPUSH
5086: LD_STRING D5c-JMM-1
5088: PPUSH
5089: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5093: LD_VAR 0 5
5097: PPUSH
5098: LD_STRING D6-Mech1-1b
5100: PPUSH
5101: CALL_OW 88
// DialogueOff ;
5105: CALL_OW 7
// end ; if take_cargo then
5109: LD_VAR 0 7
5113: IFFALSE 5192
// begin x := GetTerminalCargo ;
5115: LD_ADDR_VAR 0 2
5119: PUSH
5120: CALL 784 0 0
5124: ST_TO_ADDR
// if x > 60 then
5125: LD_VAR 0 2
5129: PUSH
5130: LD_INT 60
5132: GREATER
5133: IFFALSE 5143
// x := 60 ;
5135: LD_ADDR_VAR 0 2
5139: PUSH
5140: LD_INT 60
5142: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5143: LD_EXP 3
5147: PPUSH
5148: CALL_OW 274
5152: PPUSH
5153: LD_INT 3
5155: PPUSH
5156: CALL 784 0 0
5160: PUSH
5161: LD_VAR 0 2
5165: MINUS
5166: PPUSH
5167: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5171: LD_EXP 24
5175: PUSH
5176: LD_INT 3
5178: ARRAY
5179: PPUSH
5180: LD_INT 3
5182: PPUSH
5183: LD_VAR 0 2
5187: PPUSH
5188: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5192: LD_EXP 24
5196: PPUSH
5197: LD_INT 43
5199: PPUSH
5200: LD_INT 3
5202: PPUSH
5203: CALL_OW 171
// x := 0 0$20 ;
5207: LD_ADDR_VAR 0 2
5211: PUSH
5212: LD_INT 700
5214: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5215: LD_INT 35
5217: PPUSH
5218: CALL_OW 67
// x := x - 0 0$01 ;
5222: LD_ADDR_VAR 0 2
5226: PUSH
5227: LD_VAR 0 2
5231: PUSH
5232: LD_INT 35
5234: MINUS
5235: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5236: LD_VAR 0 2
5240: PUSH
5241: LD_INT 0
5243: EQUAL
5244: PUSH
5245: LD_EXP 24
5249: PUSH
5250: LD_INT 3
5252: ARRAY
5253: PPUSH
5254: LD_INT 43
5256: PPUSH
5257: LD_INT 3
5259: PPUSH
5260: CALL_OW 297
5264: PUSH
5265: LD_INT 4
5267: LESS
5268: PUSH
5269: LD_EXP 24
5273: PUSH
5274: LD_INT 3
5276: ARRAY
5277: PPUSH
5278: LD_INT 43
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: CALL_OW 297
5288: PUSH
5289: LD_INT 4
5291: LESS
5292: AND
5293: OR
5294: IFFALSE 5215
// for i in powell_trans do
5296: LD_ADDR_VAR 0 4
5300: PUSH
5301: LD_EXP 24
5305: PUSH
5306: FOR_IN
5307: IFFALSE 5320
// RemoveUnit ( i ) ;
5309: LD_VAR 0 4
5313: PPUSH
5314: CALL_OW 64
5318: GO 5306
5320: POP
5321: POP
// if not powell_happy then
5322: LD_VAR 0 6
5326: NOT
5327: IFFALSE 5338
// powell_happy := - 1 ;
5329: LD_ADDR_VAR 0 6
5333: PUSH
5334: LD_INT 1
5336: NEG
5337: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5338: LD_STRING EarlySiberite
5340: PPUSH
5341: LD_VAR 0 6
5345: PPUSH
5346: CALL_OW 101
// if powell_happy then
5350: LD_VAR 0 6
5354: IFFALSE 5365
// ChangeMissionObjectives ( M3a ) else
5356: LD_STRING M3a
5358: PPUSH
5359: CALL_OW 337
5363: GO 5372
// ChangeMissionObjectives ( M3b ) ;
5365: LD_STRING M3b
5367: PPUSH
5368: CALL_OW 337
// ru_can_attack_terminal := true ;
5372: LD_ADDR_EXP 9
5376: PUSH
5377: LD_INT 1
5379: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5380: LD_INT 25200
5382: PPUSH
5383: CALL_OW 67
// time := 2 2$00 ;
5387: LD_ADDR_VAR 0 8
5391: PUSH
5392: LD_INT 4200
5394: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5395: LD_INT 35
5397: PPUSH
5398: CALL_OW 67
// time := time - 0 0$1 ;
5402: LD_ADDR_VAR 0 8
5406: PUSH
5407: LD_VAR 0 8
5411: PUSH
5412: LD_INT 35
5414: MINUS
5415: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5416: LD_EXP 8
5420: NOT
5421: PUSH
5422: LD_EXP 35
5426: PUSH
5427: LD_INT 0
5429: EQUAL
5430: OR
5431: PUSH
5432: LD_VAR 0 8
5436: PUSH
5437: LD_INT 0
5439: EQUAL
5440: OR
5441: IFFALSE 5395
// if ru_force then
5443: LD_EXP 35
5447: IFFALSE 5546
// for i in ru_force do
5449: LD_ADDR_VAR 0 4
5453: PUSH
5454: LD_EXP 35
5458: PUSH
5459: FOR_IN
5460: IFFALSE 5544
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5462: LD_INT 1
5464: PPUSH
5465: LD_VAR 0 4
5469: PPUSH
5470: CALL_OW 292
5474: NOT
5475: PUSH
5476: LD_VAR 0 4
5480: PPUSH
5481: LD_INT 81
5483: PUSH
5484: LD_INT 3
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PPUSH
5491: CALL_OW 69
5495: PPUSH
5496: LD_VAR 0 4
5500: PPUSH
5501: CALL_OW 74
5505: PPUSH
5506: CALL_OW 296
5510: PUSH
5511: LD_INT 10
5513: GREATER
5514: AND
5515: IFFALSE 5542
// begin RemoveUnit ( i ) ;
5517: LD_VAR 0 4
5521: PPUSH
5522: CALL_OW 64
// ru_force := ru_force diff i ;
5526: LD_ADDR_EXP 35
5530: PUSH
5531: LD_EXP 35
5535: PUSH
5536: LD_VAR 0 4
5540: DIFF
5541: ST_TO_ADDR
// end ;
5542: GO 5459
5544: POP
5545: POP
// repeat wait ( 0 0$03 ) ;
5546: LD_INT 105
5548: PPUSH
5549: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5553: LD_EXP 8
5557: NOT
5558: PUSH
5559: LD_EXP 35
5563: PUSH
5564: LD_INT 3
5566: LESS
5567: OR
5568: IFFALSE 5546
// ar_can_arrive := true ;
5570: LD_ADDR_EXP 10
5574: PUSH
5575: LD_INT 1
5577: ST_TO_ADDR
// end ;
5578: PPOPN 8
5580: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5581: LD_INT 1
5583: PPUSH
5584: LD_INT 20
5586: PPUSH
5587: CALL_OW 325
5591: IFFALSE 5732
5593: GO 5595
5595: DISABLE
5596: LD_INT 0
5598: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5599: LD_ADDR_VAR 0 1
5603: PUSH
5604: LD_INT 22
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 26
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 25
5626: PUSH
5627: LD_INT 4
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: PUSH
5644: LD_EXP 18
5648: PUSH
5649: LD_EXP 21
5653: PUSH
5654: LD_EXP 20
5658: PUSH
5659: LD_EXP 22
5663: PUSH
5664: EMPTY
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: DIFF
5670: ST_TO_ADDR
// if not un then
5671: LD_VAR 0 1
5675: NOT
5676: IFFALSE 5680
// exit ;
5678: GO 5732
// DialogueOn ;
5680: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5684: LD_VAR 0 1
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PPUSH
5693: LD_STRING D13-Sci1-1
5695: PPUSH
5696: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5700: LD_EXP 18
5704: PPUSH
5705: LD_STRING D13-JMM-1
5707: PPUSH
5708: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5712: LD_VAR 0 1
5716: PUSH
5717: LD_INT 1
5719: ARRAY
5720: PPUSH
5721: LD_STRING D13-Sci1-2
5723: PPUSH
5724: CALL_OW 88
// DialogueOff ;
5728: CALL_OW 7
// end ;
5732: PPOPN 1
5734: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5735: LD_INT 1
5737: PPUSH
5738: CALL 815 0 1
5742: PUSH
5743: LD_INT 77
5745: GREATER
5746: PUSH
5747: LD_EXP 8
5751: NOT
5752: AND
5753: PUSH
5754: LD_INT 22
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PUSH
5774: LD_INT 26
5776: PUSH
5777: LD_INT 1
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: PPUSH
5789: CALL_OW 69
5793: PUSH
5794: LD_EXP 18
5798: PUSH
5799: LD_EXP 20
5803: PUSH
5804: LD_EXP 21
5808: PUSH
5809: LD_EXP 19
5813: PUSH
5814: LD_EXP 22
5818: PUSH
5819: EMPTY
5820: LIST
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: DIFF
5826: AND
5827: IFFALSE 6005
5829: GO 5831
5831: DISABLE
5832: LD_INT 0
5834: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5835: LD_ADDR_VAR 0 1
5839: PUSH
5840: LD_INT 22
5842: PUSH
5843: LD_INT 1
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 25
5852: PUSH
5853: LD_INT 4
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 26
5862: PUSH
5863: LD_INT 1
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: LIST
5874: PPUSH
5875: CALL_OW 69
5879: PUSH
5880: LD_EXP 18
5884: PUSH
5885: LD_EXP 20
5889: PUSH
5890: LD_EXP 21
5894: PUSH
5895: LD_EXP 19
5899: PUSH
5900: LD_EXP 22
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: DIFF
5912: ST_TO_ADDR
// DialogueOn ;
5913: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5917: LD_VAR 0 1
5921: PUSH
5922: LD_INT 1
5924: ARRAY
5925: PPUSH
5926: LD_STRING D7-Sci1-1
5928: PPUSH
5929: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5933: LD_EXP 18
5937: PPUSH
5938: LD_STRING D7-JMM-1
5940: PPUSH
5941: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5945: LD_VAR 0 1
5949: PUSH
5950: LD_INT 1
5952: ARRAY
5953: PPUSH
5954: LD_STRING D7-Sci1-2
5956: PPUSH
5957: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5961: LD_EXP 18
5965: PPUSH
5966: LD_STRING D7-JMM-2
5968: PPUSH
5969: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5973: LD_VAR 0 1
5977: PUSH
5978: LD_INT 1
5980: ARRAY
5981: PPUSH
5982: LD_STRING D7-Sci1-3
5984: PPUSH
5985: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5989: LD_EXP 18
5993: PPUSH
5994: LD_STRING D7-JMM-3
5996: PPUSH
5997: CALL_OW 88
// DialogueOff ;
6001: CALL_OW 7
// end ;
6005: PPOPN 1
6007: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates ;
6008: LD_EXP 10
6012: IFFALSE 9360
6014: GO 6016
6016: DISABLE
6017: LD_INT 0
6019: PPUSH
6020: PPUSH
6021: PPUSH
6022: PPUSH
6023: PPUSH
6024: PPUSH
6025: PPUSH
6026: PPUSH
6027: PPUSH
// begin PrepareArabian ;
6028: CALL 11781 0 0
// repeat wait ( 0 0$01 ) ;
6032: LD_INT 35
6034: PPUSH
6035: CALL_OW 67
// until ar_spawned ;
6039: LD_EXP 11
6043: IFFALSE 6032
// have_crates := true ;
6045: LD_ADDR_VAR 0 9
6049: PUSH
6050: LD_INT 1
6052: ST_TO_ADDR
// DialogueOn ;
6053: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6057: LD_EXP 26
6061: PPUSH
6062: LD_STRING D8-Ar1-1
6064: PPUSH
6065: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6069: LD_EXP 18
6073: PPUSH
6074: LD_STRING D8-JMM-1
6076: PPUSH
6077: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6081: LD_EXP 26
6085: PPUSH
6086: LD_STRING D8-Ar1-2
6088: PPUSH
6089: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6093: LD_EXP 18
6097: PPUSH
6098: LD_STRING D8-JMM-2
6100: PPUSH
6101: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6105: LD_EXP 26
6109: PPUSH
6110: LD_STRING D8-Ar1-3
6112: PPUSH
6113: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6117: LD_EXP 18
6121: PPUSH
6122: LD_STRING D8-JMM-3
6124: PPUSH
6125: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6129: LD_EXP 26
6133: PPUSH
6134: LD_STRING D8-Ar1-4
6136: PPUSH
6137: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6141: LD_EXP 18
6145: PPUSH
6146: LD_STRING D8-JMM-4
6148: PPUSH
6149: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6153: LD_EXP 26
6157: PPUSH
6158: LD_STRING D8-Ar1-5
6160: PPUSH
6161: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6165: LD_EXP 18
6169: PPUSH
6170: LD_STRING D8-JMM-5
6172: PPUSH
6173: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6177: LD_EXP 26
6181: PPUSH
6182: LD_STRING D8-Ar1-6
6184: PPUSH
6185: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6189: LD_EXP 27
6193: PPUSH
6194: LD_STRING D8-Ar2-6
6196: PPUSH
6197: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6201: LD_EXP 18
6205: PPUSH
6206: LD_STRING D8-JMM-6
6208: PPUSH
6209: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6213: LD_EXP 27
6217: PPUSH
6218: LD_STRING D8-Ar2-7
6220: PPUSH
6221: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6225: LD_STRING QBarracks
6227: PPUSH
6228: CALL_OW 97
6232: PUSH
6233: LD_INT 1
6235: DOUBLE
6236: EQUAL
6237: IFTRUE 6241
6239: GO 6276
6241: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6242: LD_EXP 18
6246: PPUSH
6247: LD_STRING D8a-JMM-1
6249: PPUSH
6250: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6254: LD_EXP 26
6258: PPUSH
6259: LD_STRING D8a-Ar1-1
6261: PPUSH
6262: CALL_OW 94
// player_want_mortar := true ;
6266: LD_ADDR_EXP 12
6270: PUSH
6271: LD_INT 1
6273: ST_TO_ADDR
// end ; 2 :
6274: GO 6434
6276: LD_INT 2
6278: DOUBLE
6279: EQUAL
6280: IFTRUE 6284
6282: GO 6398
6284: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6285: LD_EXP 18
6289: PPUSH
6290: LD_STRING D8b-JMM-1
6292: PPUSH
6293: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6297: LD_EXP 26
6301: PPUSH
6302: LD_STRING D8b-Ar1-1
6304: PPUSH
6305: CALL_OW 94
// case Query ( QInfo ) of 1 :
6309: LD_STRING QInfo
6311: PPUSH
6312: CALL_OW 97
6316: PUSH
6317: LD_INT 1
6319: DOUBLE
6320: EQUAL
6321: IFTRUE 6325
6323: GO 6360
6325: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6326: LD_EXP 18
6330: PPUSH
6331: LD_STRING D8b1-JMM-1
6333: PPUSH
6334: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6338: LD_EXP 26
6342: PPUSH
6343: LD_STRING D8b1-Ar1-1
6345: PPUSH
6346: CALL_OW 94
// player_want_info := 2 ;
6350: LD_ADDR_EXP 13
6354: PUSH
6355: LD_INT 2
6357: ST_TO_ADDR
// end ; 2 :
6358: GO 6396
6360: LD_INT 2
6362: DOUBLE
6363: EQUAL
6364: IFTRUE 6368
6366: GO 6395
6368: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6369: LD_EXP 18
6373: PPUSH
6374: LD_STRING D8b2-JMM-1
6376: PPUSH
6377: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6381: LD_EXP 26
6385: PPUSH
6386: LD_STRING D8b2-Ar1-1
6388: PPUSH
6389: CALL_OW 94
// end ; end ;
6393: GO 6396
6395: POP
// end ; 3 :
6396: GO 6434
6398: LD_INT 3
6400: DOUBLE
6401: EQUAL
6402: IFTRUE 6406
6404: GO 6433
6406: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6407: LD_EXP 18
6411: PPUSH
6412: LD_STRING D8c-JMM-1
6414: PPUSH
6415: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6419: LD_EXP 26
6423: PPUSH
6424: LD_STRING D8c-Ar1-1
6426: PPUSH
6427: CALL_OW 94
// end ; end ;
6431: GO 6434
6433: POP
// DialogueOff ;
6434: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6438: LD_ADDR_VAR 0 4
6442: PUSH
6443: LD_INT 9
6445: PPUSH
6446: LD_INT 2
6448: PUSH
6449: LD_INT 30
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 30
6461: PUSH
6462: LD_INT 1
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: LIST
6473: PPUSH
6474: CALL_OW 70
6478: ST_TO_ADDR
// if dep then
6479: LD_VAR 0 4
6483: IFFALSE 6499
// dep := dep [ 1 ] ;
6485: LD_ADDR_VAR 0 4
6489: PUSH
6490: LD_VAR 0 4
6494: PUSH
6495: LD_INT 1
6497: ARRAY
6498: ST_TO_ADDR
// if not dep then
6499: LD_VAR 0 4
6503: NOT
6504: IFFALSE 6542
// begin case Query ( QInfoNothing ) of 1 :
6506: LD_STRING QInfoNothing
6508: PPUSH
6509: CALL_OW 97
6513: PUSH
6514: LD_INT 1
6516: DOUBLE
6517: EQUAL
6518: IFTRUE 6522
6520: GO 6525
6522: POP
// ; end ;
6523: GO 6526
6525: POP
// player_want_info := false ;
6526: LD_ADDR_EXP 13
6530: PUSH
6531: LD_INT 0
6533: ST_TO_ADDR
// player_want_mortar := false ;
6534: LD_ADDR_EXP 12
6538: PUSH
6539: LD_INT 0
6541: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: LD_INT 22
6549: PUSH
6550: LD_INT 2
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 21
6559: PUSH
6560: LD_INT 2
6562: PUSH
6563: EMPTY
6564: LIST
6565: LIST
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PPUSH
6571: CALL_OW 69
6575: ST_TO_ADDR
// time := 1 1$35 ;
6576: LD_ADDR_VAR 0 5
6580: PUSH
6581: LD_INT 3325
6583: ST_TO_ADDR
// no_oil_gain := false ;
6584: LD_ADDR_VAR 0 6
6588: PUSH
6589: LD_INT 0
6591: ST_TO_ADDR
// first_warn := false ;
6592: LD_ADDR_VAR 0 7
6596: PUSH
6597: LD_INT 0
6599: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6600: LD_EXP 12
6604: PUSH
6605: LD_EXP 13
6609: OR
6610: IFFALSE 6715
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6612: LD_EXP 33
6616: PPUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 1
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PPUSH
6627: CALL_OW 72
6631: PPUSH
6632: LD_VAR 0 4
6636: PPUSH
6637: CALL_OW 250
6641: PPUSH
6642: LD_VAR 0 4
6646: PPUSH
6647: CALL_OW 251
6651: PPUSH
6652: LD_VAR 0 4
6656: PPUSH
6657: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6661: LD_EXP 33
6665: PPUSH
6666: LD_INT 25
6668: PUSH
6669: LD_INT 1
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PPUSH
6676: CALL_OW 72
6680: PPUSH
6681: LD_INT 86
6683: PPUSH
6684: LD_INT 121
6686: PPUSH
6687: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6691: LD_EXP 33
6695: PPUSH
6696: LD_INT 25
6698: PUSH
6699: LD_INT 1
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: PPUSH
6706: CALL_OW 72
6710: PPUSH
6711: CALL_OW 200
// end ; if player_attacked_ar then
6715: LD_EXP 16
6719: IFFALSE 6723
// exit ;
6721: GO 9360
// if player_want_mortar then
6723: LD_EXP 12
6727: IFFALSE 8155
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6729: LD_EXP 27
6733: PPUSH
6734: LD_VAR 0 4
6738: PPUSH
6739: CALL_OW 250
6743: PUSH
6744: LD_INT 1
6746: PLUS
6747: PPUSH
6748: LD_VAR 0 4
6752: PPUSH
6753: CALL_OW 251
6757: PUSH
6758: LD_INT 1
6760: PLUS
6761: PPUSH
6762: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6766: LD_INT 35
6768: PPUSH
6769: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6773: LD_EXP 27
6777: PPUSH
6778: LD_VAR 0 4
6782: PPUSH
6783: CALL_OW 296
6787: PUSH
6788: LD_INT 4
6790: LESS
6791: IFFALSE 6766
// for i = 1 to 6 do
6793: LD_ADDR_VAR 0 1
6797: PUSH
6798: DOUBLE
6799: LD_INT 1
6801: DEC
6802: ST_TO_ADDR
6803: LD_INT 6
6805: PUSH
6806: FOR_TO
6807: IFFALSE 7011
// begin if player_attacked_ar then
6809: LD_EXP 16
6813: IFFALSE 6819
// exit ;
6815: POP
6816: POP
6817: GO 9360
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6819: LD_VAR 0 4
6823: PPUSH
6824: CALL_OW 274
6828: PPUSH
6829: LD_INT 2
6831: PPUSH
6832: CALL_OW 275
6836: PUSH
6837: LD_INT 10
6839: LESS
6840: PUSH
6841: LD_VAR 0 7
6845: NOT
6846: AND
6847: IFFALSE 6910
// begin first_warn := true ;
6849: LD_ADDR_VAR 0 7
6853: PUSH
6854: LD_INT 1
6856: ST_TO_ADDR
// DialogueOn ;
6857: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6861: LD_EXP 28
6865: PPUSH
6866: LD_STRING D9a-FAr1-1
6868: PPUSH
6869: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6873: LD_EXP 18
6877: PPUSH
6878: LD_STRING D9a-JMM-1
6880: PPUSH
6881: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6885: LD_EXP 26
6889: PPUSH
6890: LD_STRING D9a2-Ar1-1
6892: PPUSH
6893: CALL_OW 88
// DialogueOff ;
6897: CALL_OW 7
// wait ( time ) ;
6901: LD_VAR 0 5
6905: PPUSH
6906: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6910: LD_VAR 0 4
6914: PPUSH
6915: CALL_OW 274
6919: PPUSH
6920: LD_INT 2
6922: PPUSH
6923: CALL_OW 275
6927: PUSH
6928: LD_INT 10
6930: LESS
6931: IFFALSE 6957
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6933: LD_EXP 26
6937: PPUSH
6938: LD_STRING D9a3-Ar1-1
6940: PPUSH
6941: CALL_OW 88
// no_oil_gain := true ;
6945: LD_ADDR_VAR 0 6
6949: PUSH
6950: LD_INT 1
6952: ST_TO_ADDR
// break ;
6953: GO 7011
// end else
6955: GO 7009
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6957: LD_EXP 27
6961: PPUSH
6962: LD_VAR 0 4
6966: PPUSH
6967: LD_INT 2
6969: PPUSH
6970: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6974: LD_EXP 27
6978: PPUSH
6979: LD_VAR 0 3
6983: PUSH
6984: LD_VAR 0 1
6988: PUSH
6989: LD_INT 3
6991: MOD
6992: PUSH
6993: LD_INT 1
6995: PLUS
6996: ARRAY
6997: PPUSH
6998: CALL_OW 210
// wait ( 0 0$10 ) ;
7002: LD_INT 350
7004: PPUSH
7005: CALL_OW 67
// end ; end ;
7009: GO 6806
7011: POP
7012: POP
// if not no_oil_gain then
7013: LD_VAR 0 6
7017: NOT
7018: IFFALSE 8155
// begin repeat wait ( 0 0$01 ) ;
7020: LD_INT 35
7022: PPUSH
7023: CALL_OW 67
// if player_attacked_ar then
7027: LD_EXP 16
7031: IFFALSE 7035
// exit ;
7033: GO 9360
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7035: LD_VAR 0 3
7039: PUSH
7040: LD_INT 1
7042: ARRAY
7043: PPUSH
7044: CALL_OW 261
7048: PUSH
7049: LD_INT 80
7051: GREATER
7052: PUSH
7053: LD_VAR 0 3
7057: PUSH
7058: LD_INT 2
7060: ARRAY
7061: PPUSH
7062: CALL_OW 261
7066: PUSH
7067: LD_INT 80
7069: GREATER
7070: AND
7071: PUSH
7072: LD_VAR 0 3
7076: PUSH
7077: LD_INT 3
7079: ARRAY
7080: PPUSH
7081: CALL_OW 261
7085: PUSH
7086: LD_INT 80
7088: GREATER
7089: AND
7090: IFFALSE 7020
// ComMoveXY ( Gali , 105 , 127 ) ;
7092: LD_EXP 27
7096: PPUSH
7097: LD_INT 105
7099: PPUSH
7100: LD_INT 127
7102: PPUSH
7103: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7107: LD_EXP 27
7111: PPUSH
7112: LD_INT 2
7114: PPUSH
7115: CALL_OW 173
// AddComHold ( Gali ) ;
7119: LD_EXP 27
7123: PPUSH
7124: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7128: LD_INT 35
7130: PPUSH
7131: CALL_OW 67
// if player_attacked_ar then
7135: LD_EXP 16
7139: IFFALSE 7143
// exit ;
7141: GO 9360
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7143: LD_EXP 27
7147: PPUSH
7148: LD_INT 105
7150: PPUSH
7151: LD_INT 127
7153: PPUSH
7154: CALL_OW 297
7158: PUSH
7159: LD_INT 4
7161: LESS
7162: IFFALSE 7128
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7164: LD_VAR 0 4
7168: PPUSH
7169: CALL_OW 274
7173: PPUSH
7174: LD_INT 1
7176: PPUSH
7177: CALL_OW 275
7181: PUSH
7182: LD_INT 50
7184: LESS
7185: IFFALSE 7487
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7187: LD_VAR 0 4
7191: PPUSH
7192: CALL_OW 274
7196: PPUSH
7197: LD_INT 1
7199: PPUSH
7200: CALL_OW 275
7204: PUSH
7205: LD_INT 0
7207: DOUBLE
7208: GREATEREQUAL
7209: IFFALSE 7217
7211: LD_INT 24
7213: DOUBLE
7214: LESSEQUAL
7215: IFTRUE 7219
7217: GO 7234
7219: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7220: LD_EXP 27
7224: PPUSH
7225: LD_STRING D9b-Ar2-1
7227: PPUSH
7228: CALL_OW 88
7232: GO 7264
7234: LD_INT 25
7236: DOUBLE
7237: GREATEREQUAL
7238: IFFALSE 7246
7240: LD_INT 49
7242: DOUBLE
7243: LESSEQUAL
7244: IFTRUE 7248
7246: GO 7263
7248: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7249: LD_EXP 27
7253: PPUSH
7254: LD_STRING D9b-Ar2-1a
7256: PPUSH
7257: CALL_OW 88
7261: GO 7264
7263: POP
// Say ( JMM , D9b-JMM-1 ) ;
7264: LD_EXP 18
7268: PPUSH
7269: LD_STRING D9b-JMM-1
7271: PPUSH
7272: CALL_OW 88
// x := 0 0$0 ;
7276: LD_ADDR_VAR 0 2
7280: PUSH
7281: LD_INT 0
7283: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7284: LD_INT 35
7286: PPUSH
7287: CALL_OW 67
// x := x + 0 0$1 ;
7291: LD_ADDR_VAR 0 2
7295: PUSH
7296: LD_VAR 0 2
7300: PUSH
7301: LD_INT 35
7303: PLUS
7304: ST_TO_ADDR
// if player_attacked_ar then
7305: LD_EXP 16
7309: IFFALSE 7313
// exit ;
7311: GO 9360
// until x >= time ;
7313: LD_VAR 0 2
7317: PUSH
7318: LD_VAR 0 5
7322: GREATEREQUAL
7323: IFFALSE 7284
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7325: LD_VAR 0 4
7329: PPUSH
7330: CALL_OW 274
7334: PPUSH
7335: LD_INT 1
7337: PPUSH
7338: CALL_OW 275
7342: PUSH
7343: LD_INT 50
7345: LESS
7346: IFFALSE 7487
// begin have_crates := false ;
7348: LD_ADDR_VAR 0 9
7352: PUSH
7353: LD_INT 0
7355: ST_TO_ADDR
// DialogueOn ;
7356: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7360: LD_EXP 26
7364: PPUSH
7365: LD_STRING D9c-Ar1-1
7367: PPUSH
7368: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7372: LD_EXP 18
7376: PPUSH
7377: LD_STRING D9c-JMM-1
7379: PPUSH
7380: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7384: LD_EXP 26
7388: PPUSH
7389: LD_STRING D9c-Ar1-2
7391: PPUSH
7392: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7396: LD_EXP 28
7400: PPUSH
7401: LD_STRING D9c-FAr1-2
7403: PPUSH
7404: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7408: LD_EXP 26
7412: PPUSH
7413: LD_STRING D9c-Ar1-3
7415: PPUSH
7416: CALL_OW 88
// case Query ( QInfo ) of 1 :
7420: LD_STRING QInfo
7422: PPUSH
7423: CALL_OW 97
7427: PUSH
7428: LD_INT 1
7430: DOUBLE
7431: EQUAL
7432: IFTRUE 7436
7434: GO 7459
7436: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7437: LD_EXP 18
7441: PPUSH
7442: LD_STRING D8b1-JMM-1
7444: PPUSH
7445: CALL_OW 88
// player_want_info := 2 ;
7449: LD_ADDR_EXP 13
7453: PUSH
7454: LD_INT 2
7456: ST_TO_ADDR
// end ; 2 :
7457: GO 7483
7459: LD_INT 2
7461: DOUBLE
7462: EQUAL
7463: IFTRUE 7467
7465: GO 7482
7467: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7468: LD_EXP 26
7472: PPUSH
7473: LD_STRING D8b2-Ar1-1
7475: PPUSH
7476: CALL_OW 88
// end ; end ;
7480: GO 7483
7482: POP
// DialogueOff ;
7483: CALL_OW 7
// end ; end ; if have_crates then
7487: LD_VAR 0 9
7491: IFFALSE 8155
// begin RemoveEnvironmentArea ( mortarArea ) ;
7493: LD_INT 2
7495: PPUSH
7496: CALL_OW 355
// wait ( 1 ) ;
7500: LD_INT 1
7502: PPUSH
7503: CALL_OW 67
// InGameOn ;
7507: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7511: LD_EXP 27
7515: PPUSH
7516: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7520: LD_EXP 27
7524: PPUSH
7525: LD_INT 1
7527: PPUSH
7528: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7532: LD_EXP 27
7536: PPUSH
7537: LD_INT 4
7539: PPUSH
7540: LD_INT 107
7542: PPUSH
7543: LD_INT 131
7545: PPUSH
7546: LD_INT 0
7548: PPUSH
7549: CALL_OW 145
// repeat wait ( 1 ) ;
7553: LD_INT 1
7555: PPUSH
7556: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7560: LD_INT 30
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: LD_INT 23
7572: PUSH
7573: LD_INT 2
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: IFFALSE 7553
// SetSide ( Gali , 2 ) ;
7590: LD_EXP 27
7594: PPUSH
7595: LD_INT 2
7597: PPUSH
7598: CALL_OW 235
// InGameOff ;
7602: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7606: LD_ADDR_VAR 0 8
7610: PUSH
7611: LD_INT 30
7613: PUSH
7614: LD_INT 4
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 23
7623: PUSH
7624: LD_INT 2
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: PPUSH
7635: CALL_OW 69
7639: PUSH
7640: LD_INT 1
7642: ARRAY
7643: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7644: LD_INT 35
7646: PPUSH
7647: CALL_OW 67
// if player_attacked_ar then
7651: LD_EXP 16
7655: IFFALSE 7659
// exit ;
7657: GO 9360
// until BuildingStatus ( b ) <> bs_build ;
7659: LD_VAR 0 8
7663: PPUSH
7664: CALL_OW 461
7668: PUSH
7669: LD_INT 1
7671: NONEQUAL
7672: IFFALSE 7644
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7674: LD_VAR 0 8
7678: PPUSH
7679: CALL_OW 302
7683: PUSH
7684: LD_VAR 0 4
7688: PPUSH
7689: CALL_OW 274
7693: PPUSH
7694: LD_INT 1
7696: PPUSH
7697: CALL_OW 275
7701: PUSH
7702: LD_INT 25
7704: GREATEREQUAL
7705: AND
7706: IFFALSE 7805
// begin ComUpgrade ( b ) ;
7708: LD_VAR 0 8
7712: PPUSH
7713: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7717: LD_EXP 27
7721: PPUSH
7722: LD_STRING h
7724: PUSH
7725: LD_VAR 0 8
7729: PPUSH
7730: CALL_OW 250
7734: PUSH
7735: LD_VAR 0 8
7739: PPUSH
7740: CALL_OW 251
7744: PUSH
7745: LD_VAR 0 8
7749: PUSH
7750: LD_INT 0
7752: PUSH
7753: LD_INT 0
7755: PUSH
7756: LD_INT 0
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: PUSH
7768: EMPTY
7769: LIST
7770: PPUSH
7771: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7775: LD_INT 35
7777: PPUSH
7778: CALL_OW 67
// if player_attacked_ar then
7782: LD_EXP 16
7786: IFFALSE 7790
// exit ;
7788: GO 9360
// until BuildingStatus ( b ) <> bs_build ;
7790: LD_VAR 0 8
7794: PPUSH
7795: CALL_OW 461
7799: PUSH
7800: LD_INT 1
7802: NONEQUAL
7803: IFFALSE 7775
// end ; if b then
7805: LD_VAR 0 8
7809: IFFALSE 7820
// CenterNowOnUnits ( b ) ;
7811: LD_VAR 0 8
7815: PPUSH
7816: CALL_OW 87
// DialogueOn ;
7820: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7824: LD_EXP 27
7828: PPUSH
7829: LD_STRING D9d-Ar2-1
7831: PPUSH
7832: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7836: LD_EXP 26
7840: PPUSH
7841: LD_STRING D9d-Ar1-1
7843: PPUSH
7844: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7848: LD_EXP 18
7852: PPUSH
7853: LD_STRING D9d-JMM-1
7855: PPUSH
7856: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7860: LD_EXP 26
7864: PPUSH
7865: LD_STRING D9d-Ar1-2
7867: PPUSH
7868: CALL_OW 88
// DialogueOff ;
7872: CALL_OW 7
// i := [ ] ;
7876: LD_ADDR_VAR 0 1
7880: PUSH
7881: EMPTY
7882: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7883: LD_VAR 0 4
7887: PPUSH
7888: CALL_OW 274
7892: PPUSH
7893: LD_INT 3
7895: PPUSH
7896: CALL_OW 275
7900: PUSH
7901: LD_INT 20
7903: GREATEREQUAL
7904: IFFALSE 7923
// i := i ^ [ 1 ] ;
7906: LD_ADDR_VAR 0 1
7910: PUSH
7911: LD_VAR 0 1
7915: PUSH
7916: LD_INT 1
7918: PUSH
7919: EMPTY
7920: LIST
7921: ADD
7922: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7923: LD_VAR 0 4
7927: PPUSH
7928: CALL_OW 274
7932: PPUSH
7933: LD_INT 1
7935: PPUSH
7936: CALL_OW 275
7940: PUSH
7941: LD_INT 50
7943: GREATEREQUAL
7944: IFFALSE 7963
// i := i ^ [ 2 ] ;
7946: LD_ADDR_VAR 0 1
7950: PUSH
7951: LD_VAR 0 1
7955: PUSH
7956: LD_INT 2
7958: PUSH
7959: EMPTY
7960: LIST
7961: ADD
7962: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7963: LD_VAR 0 4
7967: PPUSH
7968: CALL_OW 274
7972: PPUSH
7973: LD_INT 2
7975: PPUSH
7976: CALL_OW 275
7980: PUSH
7981: LD_INT 80
7983: GREATEREQUAL
7984: IFFALSE 8003
// i := i ^ [ 3 ] ;
7986: LD_ADDR_VAR 0 1
7990: PUSH
7991: LD_VAR 0 1
7995: PUSH
7996: LD_INT 3
7998: PUSH
7999: EMPTY
8000: LIST
8001: ADD
8002: ST_TO_ADDR
// i := i diff 0 ;
8003: LD_ADDR_VAR 0 1
8007: PUSH
8008: LD_VAR 0 1
8012: PUSH
8013: LD_INT 0
8015: DIFF
8016: ST_TO_ADDR
// if i then
8017: LD_VAR 0 1
8021: IFFALSE 8127
// begin i := i ^ [ 4 ] ;
8023: LD_ADDR_VAR 0 1
8027: PUSH
8028: LD_VAR 0 1
8032: PUSH
8033: LD_INT 4
8035: PUSH
8036: EMPTY
8037: LIST
8038: ADD
8039: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8040: LD_STRING QInfo2
8042: PPUSH
8043: CALL_OW 97
8047: PUSH
8048: LD_INT 1
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8067
8056: POP
// player_want_info := 3 ; 2 :
8057: LD_ADDR_EXP 13
8061: PUSH
8062: LD_INT 3
8064: ST_TO_ADDR
8065: GO 8125
8067: LD_INT 2
8069: DOUBLE
8070: EQUAL
8071: IFTRUE 8075
8073: GO 8086
8075: POP
// player_want_info := 1 ; 3 :
8076: LD_ADDR_EXP 13
8080: PUSH
8081: LD_INT 1
8083: ST_TO_ADDR
8084: GO 8125
8086: LD_INT 3
8088: DOUBLE
8089: EQUAL
8090: IFTRUE 8094
8092: GO 8105
8094: POP
// player_want_info := 2 ; 4 :
8095: LD_ADDR_EXP 13
8099: PUSH
8100: LD_INT 2
8102: ST_TO_ADDR
8103: GO 8125
8105: LD_INT 4
8107: DOUBLE
8108: EQUAL
8109: IFTRUE 8113
8111: GO 8124
8113: POP
// player_want_info := 0 ; end ;
8114: LD_ADDR_EXP 13
8118: PUSH
8119: LD_INT 0
8121: ST_TO_ADDR
8122: GO 8125
8124: POP
// end else
8125: GO 8155
// case Query ( QInfoNothing ) of 1 :
8127: LD_STRING QInfoNothing
8129: PPUSH
8130: CALL_OW 97
8134: PUSH
8135: LD_INT 1
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8154
8143: POP
// player_want_info := 0 ; end ;
8144: LD_ADDR_EXP 13
8148: PUSH
8149: LD_INT 0
8151: ST_TO_ADDR
8152: GO 8155
8154: POP
// end ; end ; end ; if player_want_info then
8155: LD_EXP 13
8159: IFFALSE 9180
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8161: LD_ADDR_VAR 0 3
8165: PUSH
8166: LD_VAR 0 3
8170: PPUSH
8171: LD_INT 34
8173: PUSH
8174: LD_INT 32
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PPUSH
8181: CALL_OW 72
8185: ST_TO_ADDR
// if player_want_mortar then
8186: LD_EXP 12
8190: IFFALSE 8512
// begin case player_want_info of 1 :
8192: LD_EXP 13
8196: PUSH
8197: LD_INT 1
8199: DOUBLE
8200: EQUAL
8201: IFTRUE 8205
8203: GO 8216
8205: POP
// x := 5 ; 2 :
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_INT 5
8213: ST_TO_ADDR
8214: GO 8255
8216: LD_INT 2
8218: DOUBLE
8219: EQUAL
8220: IFTRUE 8224
8222: GO 8235
8224: POP
// x := 8 ; 3 :
8225: LD_ADDR_VAR 0 2
8229: PUSH
8230: LD_INT 8
8232: ST_TO_ADDR
8233: GO 8255
8235: LD_INT 3
8237: DOUBLE
8238: EQUAL
8239: IFTRUE 8243
8241: GO 8254
8243: POP
// x := 2 ; end ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_INT 2
8251: ST_TO_ADDR
8252: GO 8255
8254: POP
// repeat wait ( 0 0$1 ) ;
8255: LD_INT 35
8257: PPUSH
8258: CALL_OW 67
// until not HasTask ( Gali ) ;
8262: LD_EXP 27
8266: PPUSH
8267: CALL_OW 314
8271: NOT
8272: IFFALSE 8255
// for i = 1 to x do
8274: LD_ADDR_VAR 0 1
8278: PUSH
8279: DOUBLE
8280: LD_INT 1
8282: DEC
8283: ST_TO_ADDR
8284: LD_VAR 0 2
8288: PUSH
8289: FOR_TO
8290: IFFALSE 8455
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8292: LD_EXP 27
8296: PPUSH
8297: LD_VAR 0 4
8301: PPUSH
8302: LD_EXP 13
8306: PPUSH
8307: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8311: LD_EXP 27
8315: PPUSH
8316: LD_VAR 0 3
8320: PUSH
8321: LD_INT 1
8323: ARRAY
8324: PPUSH
8325: CALL_OW 172
// AddComHold ( Gali ) ;
8329: LD_EXP 27
8333: PPUSH
8334: CALL_OW 200
// repeat wait ( 3 ) ;
8338: LD_INT 3
8340: PPUSH
8341: CALL_OW 67
// if player_attacked_ar then
8345: LD_EXP 16
8349: IFFALSE 8355
// exit ;
8351: POP
8352: POP
8353: GO 9360
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8355: LD_EXP 27
8359: PPUSH
8360: LD_VAR 0 3
8364: PUSH
8365: LD_INT 1
8367: ARRAY
8368: PPUSH
8369: CALL_OW 296
8373: PUSH
8374: LD_INT 4
8376: LESS
8377: PUSH
8378: LD_EXP 27
8382: PPUSH
8383: LD_EXP 13
8387: PPUSH
8388: CALL_OW 289
8392: AND
8393: IFFALSE 8338
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8395: LD_VAR 0 3
8399: PUSH
8400: LD_INT 1
8402: ARRAY
8403: PPUSH
8404: LD_EXP 13
8408: PPUSH
8409: LD_VAR 0 3
8413: PUSH
8414: LD_INT 1
8416: ARRAY
8417: PPUSH
8418: LD_EXP 13
8422: PPUSH
8423: CALL_OW 289
8427: PUSH
8428: LD_INT 10
8430: PLUS
8431: PPUSH
8432: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8436: LD_EXP 27
8440: PPUSH
8441: LD_EXP 13
8445: PPUSH
8446: LD_INT 0
8448: PPUSH
8449: CALL_OW 290
// end ;
8453: GO 8289
8455: POP
8456: POP
// repeat wait ( 0 0$1 ) ;
8457: LD_INT 35
8459: PPUSH
8460: CALL_OW 67
// if player_attacked_ar then
8464: LD_EXP 16
8468: IFFALSE 8472
// exit ;
8470: GO 9360
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8472: LD_VAR 0 3
8476: PUSH
8477: LD_INT 1
8479: ARRAY
8480: PPUSH
8481: LD_EXP 13
8485: PPUSH
8486: CALL_OW 289
8490: PUSH
8491: LD_VAR 0 2
8495: PUSH
8496: LD_INT 10
8498: MUL
8499: EQUAL
8500: IFFALSE 8457
// no_oil_gain := false ;
8502: LD_ADDR_VAR 0 6
8506: PUSH
8507: LD_INT 0
8509: ST_TO_ADDR
// end else
8510: GO 9001
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8512: LD_ADDR_VAR 0 3
8516: PUSH
8517: LD_INT 22
8519: PUSH
8520: LD_INT 2
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: PUSH
8527: LD_INT 21
8529: PUSH
8530: LD_INT 2
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: PPUSH
8541: CALL_OW 69
8545: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8546: LD_EXP 27
8550: PPUSH
8551: LD_VAR 0 4
8555: PPUSH
8556: CALL_OW 250
8560: PUSH
8561: LD_INT 1
8563: PLUS
8564: PPUSH
8565: LD_VAR 0 4
8569: PPUSH
8570: CALL_OW 251
8574: PUSH
8575: LD_INT 1
8577: PLUS
8578: PPUSH
8579: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8583: LD_INT 35
8585: PPUSH
8586: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8590: LD_EXP 27
8594: PPUSH
8595: LD_VAR 0 4
8599: PPUSH
8600: CALL_OW 296
8604: PUSH
8605: LD_INT 4
8607: LESS
8608: IFFALSE 8583
// for i = 1 to 6 do
8610: LD_ADDR_VAR 0 1
8614: PUSH
8615: DOUBLE
8616: LD_INT 1
8618: DEC
8619: ST_TO_ADDR
8620: LD_INT 6
8622: PUSH
8623: FOR_TO
8624: IFFALSE 8828
// begin if player_attacked_ar then
8626: LD_EXP 16
8630: IFFALSE 8636
// exit ;
8632: POP
8633: POP
8634: GO 9360
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8636: LD_VAR 0 4
8640: PPUSH
8641: CALL_OW 274
8645: PPUSH
8646: LD_INT 2
8648: PPUSH
8649: CALL_OW 275
8653: PUSH
8654: LD_INT 10
8656: LESS
8657: PUSH
8658: LD_VAR 0 7
8662: NOT
8663: AND
8664: IFFALSE 8727
// begin first_warn := true ;
8666: LD_ADDR_VAR 0 7
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
// DialogueOn ;
8674: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8678: LD_EXP 28
8682: PPUSH
8683: LD_STRING D9a-FAr1-1
8685: PPUSH
8686: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8690: LD_EXP 18
8694: PPUSH
8695: LD_STRING D9a-JMM-1
8697: PPUSH
8698: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8702: LD_EXP 26
8706: PPUSH
8707: LD_STRING D9a2-Ar1-1
8709: PPUSH
8710: CALL_OW 88
// DialogueOff ;
8714: CALL_OW 7
// wait ( time ) ;
8718: LD_VAR 0 5
8722: PPUSH
8723: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8727: LD_VAR 0 4
8731: PPUSH
8732: CALL_OW 274
8736: PPUSH
8737: LD_INT 2
8739: PPUSH
8740: CALL_OW 275
8744: PUSH
8745: LD_INT 10
8747: LESS
8748: IFFALSE 8774
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8750: LD_EXP 26
8754: PPUSH
8755: LD_STRING D9a3-Ar1-1
8757: PPUSH
8758: CALL_OW 88
// no_oil_gain := true ;
8762: LD_ADDR_VAR 0 6
8766: PUSH
8767: LD_INT 1
8769: ST_TO_ADDR
// break ;
8770: GO 8828
// end else
8772: GO 8826
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8774: LD_EXP 27
8778: PPUSH
8779: LD_VAR 0 4
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8791: LD_EXP 27
8795: PPUSH
8796: LD_VAR 0 3
8800: PUSH
8801: LD_VAR 0 1
8805: PUSH
8806: LD_INT 3
8808: MOD
8809: PUSH
8810: LD_INT 1
8812: PLUS
8813: ARRAY
8814: PPUSH
8815: CALL_OW 210
// wait ( 0 0$10 ) ;
8819: LD_INT 350
8821: PPUSH
8822: CALL_OW 67
// end ; end ;
8826: GO 8623
8828: POP
8829: POP
// repeat wait ( 0 0$1 ) ;
8830: LD_INT 35
8832: PPUSH
8833: CALL_OW 67
// if player_attacked_ar then
8837: LD_EXP 16
8841: IFFALSE 8845
// exit ;
8843: GO 9360
// for i in tmp do
8845: LD_ADDR_VAR 0 1
8849: PUSH
8850: LD_VAR 0 3
8854: PUSH
8855: FOR_IN
8856: IFFALSE 8887
// if GetFuel ( i ) < 100 then
8858: LD_VAR 0 1
8862: PPUSH
8863: CALL_OW 261
8867: PUSH
8868: LD_INT 100
8870: LESS
8871: IFFALSE 8885
// begin x := i ;
8873: LD_ADDR_VAR 0 2
8877: PUSH
8878: LD_VAR 0 1
8882: ST_TO_ADDR
// break ;
8883: GO 8887
// end ;
8885: GO 8855
8887: POP
8888: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8889: LD_EXP 27
8893: PPUSH
8894: CALL_OW 314
8898: NOT
8899: PUSH
8900: LD_EXP 27
8904: PPUSH
8905: CALL_OW 281
8909: NOT
8910: AND
8911: IFFALSE 8944
// begin ComTransport ( Gali , dep , mat_oil ) ;
8913: LD_EXP 27
8917: PPUSH
8918: LD_VAR 0 4
8922: PPUSH
8923: LD_INT 2
8925: PPUSH
8926: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8930: LD_EXP 27
8934: PPUSH
8935: LD_VAR 0 2
8939: PPUSH
8940: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 1
8951: ARRAY
8952: PPUSH
8953: CALL_OW 261
8957: PUSH
8958: LD_INT 80
8960: GREATER
8961: PUSH
8962: LD_VAR 0 3
8966: PUSH
8967: LD_INT 2
8969: ARRAY
8970: PPUSH
8971: CALL_OW 261
8975: PUSH
8976: LD_INT 80
8978: GREATER
8979: AND
8980: PUSH
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 3
8988: ARRAY
8989: PPUSH
8990: CALL_OW 261
8994: PUSH
8995: LD_INT 80
8997: GREATER
8998: AND
8999: IFFALSE 8830
// end ; ComHold ( Gali ) ;
9001: LD_EXP 27
9005: PPUSH
9006: CALL_OW 140
// if not no_oil_gain then
9010: LD_VAR 0 6
9014: NOT
9015: IFFALSE 9180
// begin DialogueOn ;
9017: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9021: LD_EXP 26
9025: PPUSH
9026: CALL_OW 87
// if player_want_mortar then
9030: LD_EXP 12
9034: IFFALSE 9060
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9036: LD_EXP 26
9040: PPUSH
9041: LD_STRING D9e-Ar1-1
9043: PPUSH
9044: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9048: LD_EXP 18
9052: PPUSH
9053: LD_STRING D10a-JMM-1
9055: PPUSH
9056: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9060: LD_EXP 26
9064: PPUSH
9065: LD_STRING D10a-Ar1-1
9067: PPUSH
9068: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9072: LD_EXP 27
9076: PPUSH
9077: LD_STRING D10a-Ar2-1
9079: PPUSH
9080: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9084: LD_EXP 28
9088: PPUSH
9089: LD_STRING D10a-FAr1-1
9091: PPUSH
9092: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9096: LD_EXP 27
9100: PPUSH
9101: LD_STRING D10a-Ar2-2
9103: PPUSH
9104: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9108: LD_EXP 28
9112: PPUSH
9113: LD_STRING D10a-FAr1-2
9115: PPUSH
9116: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9120: LD_EXP 26
9124: PPUSH
9125: LD_STRING D10a-Ar1-2
9127: PPUSH
9128: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9132: LD_EXP 18
9136: PPUSH
9137: LD_STRING D10a-JMM-2
9139: PPUSH
9140: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9144: LD_EXP 26
9148: PPUSH
9149: LD_STRING D10a-Ar1-3
9151: PPUSH
9152: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9156: LD_EXP 18
9160: PPUSH
9161: LD_STRING D10a-JMM-3
9163: PPUSH
9164: CALL_OW 88
// player_get_info := true ;
9168: LD_ADDR_EXP 15
9172: PUSH
9173: LD_INT 1
9175: ST_TO_ADDR
// DialogueOff ;
9176: CALL_OW 7
// end ; end ; if player_attacked_ar then
9180: LD_EXP 16
9184: IFFALSE 9188
// exit ;
9186: GO 9360
// if player_want_mortar or player_want_info then
9188: LD_EXP 12
9192: PUSH
9193: LD_EXP 13
9197: OR
9198: IFFALSE 9212
// Say ( Vervecken , D9f-Ar1-1 ) ;
9200: LD_EXP 26
9204: PPUSH
9205: LD_STRING D9f-Ar1-1
9207: PPUSH
9208: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9212: LD_INT 22
9214: PUSH
9215: LD_INT 2
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PPUSH
9222: CALL_OW 69
9226: PPUSH
9227: LD_INT 51
9229: PPUSH
9230: LD_INT 99
9232: PPUSH
9233: CALL_OW 111
// wait ( 0 0$1 ) ;
9237: LD_INT 35
9239: PPUSH
9240: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9244: LD_INT 22
9246: PUSH
9247: LD_INT 2
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: LD_INT 92
9256: PUSH
9257: LD_INT 51
9259: PUSH
9260: LD_INT 99
9262: PUSH
9263: LD_INT 2
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: LIST
9270: LIST
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PPUSH
9276: CALL_OW 69
9280: IFFALSE 9340
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9282: LD_ADDR_VAR 0 1
9286: PUSH
9287: LD_INT 22
9289: PUSH
9290: LD_INT 2
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: PUSH
9297: LD_INT 92
9299: PUSH
9300: LD_INT 51
9302: PUSH
9303: LD_INT 99
9305: PUSH
9306: LD_INT 2
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: LIST
9313: LIST
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PPUSH
9319: CALL_OW 69
9323: PUSH
9324: FOR_IN
9325: IFFALSE 9338
// RemoveUnit ( i ) ;
9327: LD_VAR 0 1
9331: PPUSH
9332: CALL_OW 64
9336: GO 9324
9338: POP
9339: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9340: LD_INT 22
9342: PUSH
9343: LD_INT 2
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 69
9354: PUSH
9355: LD_INT 0
9357: EQUAL
9358: IFFALSE 9212
// end ;
9360: PPOPN 9
9362: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9363: LD_EXP 16
9367: IFFALSE 9720
9369: GO 9371
9371: DISABLE
9372: LD_INT 0
9374: PPUSH
9375: PPUSH
9376: PPUSH
9377: PPUSH
// begin ru_can_attack := true ;
9378: LD_ADDR_EXP 8
9382: PUSH
9383: LD_INT 1
9385: ST_TO_ADDR
// mine_launched := false ;
9386: LD_ADDR_VAR 0 3
9390: PUSH
9391: LD_INT 0
9393: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9394: LD_INT 22
9396: PUSH
9397: LD_INT 2
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PPUSH
9404: CALL_OW 69
9408: PPUSH
9409: LD_INT 51
9411: PPUSH
9412: LD_INT 99
9414: PPUSH
9415: CALL_OW 111
// if IsOk ( Vervecken ) then
9419: LD_EXP 26
9423: PPUSH
9424: CALL_OW 302
9428: IFFALSE 9442
// Say ( Vervecken , D11a-Ar1-1 ) ;
9430: LD_EXP 26
9434: PPUSH
9435: LD_STRING D11a-Ar1-1
9437: PPUSH
9438: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9442: LD_ADDR_VAR 0 2
9446: PUSH
9447: LD_EXP 33
9451: PPUSH
9452: LD_INT 25
9454: PUSH
9455: LD_INT 1
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PPUSH
9462: CALL_OW 72
9466: ST_TO_ADDR
// for i in tmp do
9467: LD_ADDR_VAR 0 1
9471: PUSH
9472: LD_VAR 0 2
9476: PUSH
9477: FOR_IN
9478: IFFALSE 9541
// if MineOfUnit ( i ) then
9480: LD_VAR 0 1
9484: PPUSH
9485: CALL_OW 459
9489: IFFALSE 9539
// begin x := MineOfUnit ( i ) ;
9491: LD_ADDR_VAR 0 4
9495: PUSH
9496: LD_VAR 0 1
9500: PPUSH
9501: CALL_OW 459
9505: ST_TO_ADDR
// mine_launched := true ;
9506: LD_ADDR_VAR 0 3
9510: PUSH
9511: LD_INT 1
9513: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9514: LD_VAR 0 4
9518: PUSH
9519: LD_INT 1
9521: ARRAY
9522: PPUSH
9523: LD_VAR 0 4
9527: PUSH
9528: LD_INT 2
9530: ARRAY
9531: PPUSH
9532: LD_INT 2
9534: PPUSH
9535: CALL_OW 456
// end ;
9539: GO 9477
9541: POP
9542: POP
// if mine_launched and IsOk ( Vervecken ) then
9543: LD_VAR 0 3
9547: PUSH
9548: LD_EXP 26
9552: PPUSH
9553: CALL_OW 302
9557: AND
9558: IFFALSE 9572
// Say ( Vervecken , D11b-Ar1-1 ) ;
9560: LD_EXP 26
9564: PPUSH
9565: LD_STRING D11b-Ar1-1
9567: PPUSH
9568: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9572: LD_INT 22
9574: PUSH
9575: LD_INT 2
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PPUSH
9582: CALL_OW 69
9586: PPUSH
9587: LD_INT 51
9589: PPUSH
9590: LD_INT 99
9592: PPUSH
9593: CALL_OW 111
// wait ( 0 0$1 ) ;
9597: LD_INT 35
9599: PPUSH
9600: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9604: LD_INT 22
9606: PUSH
9607: LD_INT 2
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 92
9616: PUSH
9617: LD_INT 51
9619: PUSH
9620: LD_INT 99
9622: PUSH
9623: LD_INT 2
9625: PUSH
9626: EMPTY
9627: LIST
9628: LIST
9629: LIST
9630: LIST
9631: PUSH
9632: EMPTY
9633: LIST
9634: LIST
9635: PPUSH
9636: CALL_OW 69
9640: IFFALSE 9700
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9642: LD_ADDR_VAR 0 1
9646: PUSH
9647: LD_INT 22
9649: PUSH
9650: LD_INT 2
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 92
9659: PUSH
9660: LD_INT 51
9662: PUSH
9663: LD_INT 99
9665: PUSH
9666: LD_INT 2
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: PPUSH
9679: CALL_OW 69
9683: PUSH
9684: FOR_IN
9685: IFFALSE 9698
// RemoveUnit ( i ) ;
9687: LD_VAR 0 1
9691: PPUSH
9692: CALL_OW 64
9696: GO 9684
9698: POP
9699: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9700: LD_INT 22
9702: PUSH
9703: LD_INT 2
9705: PUSH
9706: EMPTY
9707: LIST
9708: LIST
9709: PPUSH
9710: CALL_OW 69
9714: PUSH
9715: LD_INT 0
9717: EQUAL
9718: IFFALSE 9572
// end ;
9720: PPOPN 4
9722: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9723: LD_EXP 10
9727: IFFALSE 9906
9729: GO 9731
9731: DISABLE
9732: LD_INT 0
9734: PPUSH
// begin Wait ( 10 10$00 ) ;
9735: LD_INT 21000
9737: PPUSH
9738: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9742: LD_INT 22
9744: PUSH
9745: LD_INT 2
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: PPUSH
9752: CALL_OW 69
9756: IFFALSE 9906
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9758: LD_INT 22
9760: PUSH
9761: LD_INT 2
9763: PUSH
9764: EMPTY
9765: LIST
9766: LIST
9767: PPUSH
9768: CALL_OW 69
9772: PPUSH
9773: LD_INT 51
9775: PPUSH
9776: LD_INT 99
9778: PPUSH
9779: CALL_OW 114
// wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9790: LD_INT 22
9792: PUSH
9793: LD_INT 2
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PUSH
9800: LD_INT 92
9802: PUSH
9803: LD_INT 51
9805: PUSH
9806: LD_INT 99
9808: PUSH
9809: LD_INT 2
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: PPUSH
9822: CALL_OW 69
9826: IFFALSE 9886
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9828: LD_ADDR_VAR 0 1
9832: PUSH
9833: LD_INT 22
9835: PUSH
9836: LD_INT 2
9838: PUSH
9839: EMPTY
9840: LIST
9841: LIST
9842: PUSH
9843: LD_INT 92
9845: PUSH
9846: LD_INT 51
9848: PUSH
9849: LD_INT 99
9851: PUSH
9852: LD_INT 2
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PPUSH
9865: CALL_OW 69
9869: PUSH
9870: FOR_IN
9871: IFFALSE 9884
// RemoveUnit ( i ) ;
9873: LD_VAR 0 1
9877: PPUSH
9878: CALL_OW 64
9882: GO 9870
9884: POP
9885: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9886: LD_INT 22
9888: PUSH
9889: LD_INT 2
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: PPUSH
9896: CALL_OW 69
9900: PUSH
9901: LD_INT 0
9903: EQUAL
9904: IFFALSE 9758
// end ; end ;
9906: PPOPN 1
9908: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9909: LD_EXP 4
9913: IFFALSE 10841
9915: GO 9917
9917: DISABLE
9918: LD_INT 0
9920: PPUSH
9921: PPUSH
9922: PPUSH
// begin Wait ( game_time ) ;
9923: LD_EXP 7
9927: PPUSH
9928: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9932: LD_INT 35
9934: PPUSH
9935: CALL_OW 67
// until ( not ru_can_attack ) ;
9939: LD_EXP 8
9943: NOT
9944: IFFALSE 9932
// Wait ( 0 0$35 ) ;
9946: LD_INT 1225
9948: PPUSH
9949: CALL_OW 67
// DialogueOn ;
9953: CALL_OW 6
// InGameOn ;
9957: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9961: LD_EXP 25
9965: PPUSH
9966: LD_STRING D12-Pow-1
9968: PPUSH
9969: CALL_OW 94
// InGameOff ;
9973: CALL_OW 9
// DialogueOff ;
9977: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9981: LD_STRING M4
9983: PPUSH
9984: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9988: LD_INT 5
9990: PPUSH
9991: LD_INT 1
9993: PPUSH
9994: CALL_OW 424
// can_end := true ;
9998: LD_ADDR_EXP 17
10002: PUSH
10003: LD_INT 1
10005: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10006: LD_INT 35
10008: PPUSH
10009: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10013: CALL 784 0 0
10017: PUSH
10018: LD_INT 20
10020: GREATEREQUAL
10021: PUSH
10022: LD_INT 22
10024: PUSH
10025: LD_INT 1
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PUSH
10032: LD_INT 21
10034: PUSH
10035: LD_INT 1
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PUSH
10042: EMPTY
10043: LIST
10044: LIST
10045: PPUSH
10046: CALL_OW 69
10050: PUSH
10051: LD_INT 5
10053: PPUSH
10054: LD_INT 22
10056: PUSH
10057: LD_INT 1
10059: PUSH
10060: EMPTY
10061: LIST
10062: LIST
10063: PUSH
10064: LD_INT 21
10066: PUSH
10067: LD_INT 1
10069: PUSH
10070: EMPTY
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PPUSH
10078: CALL_OW 70
10082: PUSH
10083: LD_INT 22
10085: PUSH
10086: LD_INT 1
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 55
10095: PUSH
10096: EMPTY
10097: LIST
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PPUSH
10103: CALL_OW 69
10107: PLUS
10108: LESSEQUAL
10109: AND
10110: IFFALSE 10006
// if not player_get_info then
10112: LD_EXP 15
10116: NOT
10117: IFFALSE 10128
// player_get_info := - 1 ;
10119: LD_ADDR_EXP 15
10123: PUSH
10124: LD_INT 1
10126: NEG
10127: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10128: LD_STRING Information
10130: PPUSH
10131: LD_EXP 15
10135: PPUSH
10136: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10140: LD_ADDR_VAR 0 2
10144: PUSH
10145: LD_INT 22
10147: PUSH
10148: LD_INT 1
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 2
10157: PUSH
10158: LD_INT 25
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: LD_INT 25
10170: PUSH
10171: LD_INT 16
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: PUSH
10178: LD_INT 34
10180: PUSH
10181: LD_INT 12
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PPUSH
10198: CALL_OW 69
10202: ST_TO_ADDR
// sib := GetTerminalCargo ;
10203: LD_ADDR_VAR 0 3
10207: PUSH
10208: CALL 784 0 0
10212: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10213: LD_ADDR_VAR 0 3
10217: PUSH
10218: LD_VAR 0 3
10222: PUSH
10223: LD_INT 6
10225: PPUSH
10226: LD_INT 3
10228: PPUSH
10229: CALL_OW 287
10233: PLUS
10234: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10235: LD_ADDR_VAR 0 3
10239: PUSH
10240: LD_VAR 0 3
10244: PUSH
10245: LD_VAR 0 2
10249: PPUSH
10250: LD_INT 3
10252: PPUSH
10253: CALL_OW 289
10257: PLUS
10258: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10259: LD_VAR 0 3
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_OWVAR 67
10271: PLUS
10272: PUSH
10273: LD_INT 50
10275: MUL
10276: LESS
10277: IFFALSE 10302
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10279: LD_STRING MuchSiberite
10281: PPUSH
10282: LD_INT 2
10284: NEG
10285: PUSH
10286: LD_OWVAR 67
10290: MUL
10291: PUSH
10292: LD_INT 1
10294: PLUS
10295: PPUSH
10296: CALL_OW 101
10300: GO 10312
// AddMedal ( MuchSiberite , 1 ) ;
10302: LD_STRING MuchSiberite
10304: PPUSH
10305: LD_INT 1
10307: PPUSH
10308: CALL_OW 101
// GiveMedals ( MAIN ) ;
10312: LD_STRING MAIN
10314: PPUSH
10315: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10319: LD_INT 22
10321: PUSH
10322: LD_INT 1
10324: PUSH
10325: EMPTY
10326: LIST
10327: LIST
10328: PUSH
10329: LD_INT 2
10331: PUSH
10332: LD_INT 25
10334: PUSH
10335: LD_INT 1
10337: PUSH
10338: EMPTY
10339: LIST
10340: LIST
10341: PUSH
10342: LD_INT 25
10344: PUSH
10345: LD_INT 2
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: PUSH
10352: LD_INT 25
10354: PUSH
10355: LD_INT 3
10357: PUSH
10358: EMPTY
10359: LIST
10360: LIST
10361: PUSH
10362: LD_INT 25
10364: PUSH
10365: LD_INT 4
10367: PUSH
10368: EMPTY
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 25
10374: PUSH
10375: LD_INT 8
10377: PUSH
10378: EMPTY
10379: LIST
10380: LIST
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: PPUSH
10394: CALL_OW 69
10398: PPUSH
10399: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10403: LD_ADDR_VAR 0 2
10407: PUSH
10408: LD_INT 22
10410: PUSH
10411: LD_INT 1
10413: PUSH
10414: EMPTY
10415: LIST
10416: LIST
10417: PUSH
10418: LD_INT 25
10420: PUSH
10421: LD_INT 8
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: PPUSH
10432: CALL_OW 69
10436: ST_TO_ADDR
// if tmp then
10437: LD_VAR 0 2
10441: IFFALSE 10472
// for i in tmp do
10443: LD_ADDR_VAR 0 1
10447: PUSH
10448: LD_VAR 0 2
10452: PUSH
10453: FOR_IN
10454: IFFALSE 10470
// SetClass ( i , 1 ) ;
10456: LD_VAR 0 1
10460: PPUSH
10461: LD_INT 1
10463: PPUSH
10464: CALL_OW 336
10468: GO 10453
10470: POP
10471: POP
// SaveVariable ( sib , 09_sibRes ) ;
10472: LD_VAR 0 3
10476: PPUSH
10477: LD_STRING 09_sibRes
10479: PPUSH
10480: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10484: LD_EXP 15
10488: PPUSH
10489: LD_STRING 09_arInfo
10491: PPUSH
10492: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10496: LD_EXP 18
10500: PPUSH
10501: LD_EXP 1
10505: PUSH
10506: LD_STRING JMM
10508: STR
10509: PPUSH
10510: CALL_OW 38
// if IsLive ( Gary ) then
10514: LD_EXP 19
10518: PPUSH
10519: CALL_OW 300
10523: IFFALSE 10543
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10525: LD_EXP 19
10529: PPUSH
10530: LD_EXP 1
10534: PUSH
10535: LD_STRING Gary
10537: STR
10538: PPUSH
10539: CALL_OW 38
// if IsLive ( Bobby ) then
10543: LD_EXP 20
10547: PPUSH
10548: CALL_OW 300
10552: IFFALSE 10572
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10554: LD_EXP 20
10558: PPUSH
10559: LD_EXP 1
10563: PUSH
10564: LD_STRING Bobby
10566: STR
10567: PPUSH
10568: CALL_OW 38
// if IsLive ( Cyrus ) then
10572: LD_EXP 21
10576: PPUSH
10577: CALL_OW 300
10581: IFFALSE 10601
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10583: LD_EXP 21
10587: PPUSH
10588: LD_EXP 1
10592: PUSH
10593: LD_STRING Cyrus
10595: STR
10596: PPUSH
10597: CALL_OW 38
// if IsLive ( Houten ) then
10601: LD_EXP 22
10605: PPUSH
10606: CALL_OW 300
10610: IFFALSE 10630
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10612: LD_EXP 22
10616: PPUSH
10617: LD_EXP 1
10621: PUSH
10622: LD_STRING Houten
10624: STR
10625: PPUSH
10626: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_INT 22
10637: PUSH
10638: LD_INT 1
10640: PUSH
10641: EMPTY
10642: LIST
10643: LIST
10644: PUSH
10645: LD_INT 2
10647: PUSH
10648: LD_INT 25
10650: PUSH
10651: LD_INT 1
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: PUSH
10658: LD_INT 25
10660: PUSH
10661: LD_INT 2
10663: PUSH
10664: EMPTY
10665: LIST
10666: LIST
10667: PUSH
10668: LD_INT 25
10670: PUSH
10671: LD_INT 3
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PUSH
10678: LD_INT 25
10680: PUSH
10681: LD_INT 4
10683: PUSH
10684: EMPTY
10685: LIST
10686: LIST
10687: PUSH
10688: EMPTY
10689: LIST
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PPUSH
10699: CALL_OW 69
10703: PUSH
10704: LD_EXP 18
10708: PUSH
10709: LD_EXP 21
10713: PUSH
10714: LD_EXP 20
10718: PUSH
10719: LD_EXP 22
10723: PUSH
10724: LD_EXP 19
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: DIFF
10736: ST_TO_ADDR
// if tmp then
10737: LD_VAR 0 2
10741: IFFALSE 10761
// SaveCharacters ( tmp , mission_prefix & others ) ;
10743: LD_VAR 0 2
10747: PPUSH
10748: LD_EXP 1
10752: PUSH
10753: LD_STRING others
10755: STR
10756: PPUSH
10757: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10761: LD_ADDR_VAR 0 2
10765: PUSH
10766: LD_INT 22
10768: PUSH
10769: LD_INT 1
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: LD_INT 2
10778: PUSH
10779: LD_INT 25
10781: PUSH
10782: LD_INT 12
10784: PUSH
10785: EMPTY
10786: LIST
10787: LIST
10788: PUSH
10789: LD_INT 25
10791: PUSH
10792: LD_INT 16
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: LIST
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: PPUSH
10808: CALL_OW 69
10812: ST_TO_ADDR
// if tmp then
10813: LD_VAR 0 2
10817: IFFALSE 10837
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: LD_EXP 1
10828: PUSH
10829: LD_STRING apes
10831: STR
10832: PPUSH
10833: CALL_OW 38
// YouWin ;
10837: CALL_OW 103
// end ; end_of_file
10841: PPOPN 3
10843: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10844: LD_VAR 0 1
10848: PPUSH
10849: CALL_OW 266
10853: PUSH
10854: LD_INT 0
10856: EQUAL
10857: PUSH
10858: LD_EXP 3
10862: NOT
10863: AND
10864: IFFALSE 10888
// begin terminal := b ;
10866: LD_ADDR_EXP 3
10870: PUSH
10871: LD_VAR 0 1
10875: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10876: LD_EXP 3
10880: PPUSH
10881: LD_STRING terminal
10883: PPUSH
10884: CALL_OW 500
// end ; end ;
10888: PPOPN 2
10890: END
// on BuildingComplete ( b ) do var i ;
10891: LD_INT 0
10893: PPUSH
// begin if GetSide ( b ) = 3 then
10894: LD_VAR 0 1
10898: PPUSH
10899: CALL_OW 255
10903: PUSH
10904: LD_INT 3
10906: EQUAL
10907: IFFALSE 10947
// for i = 1 to 4 do
10909: LD_ADDR_VAR 0 2
10913: PUSH
10914: DOUBLE
10915: LD_INT 1
10917: DEC
10918: ST_TO_ADDR
10919: LD_INT 4
10921: PUSH
10922: FOR_TO
10923: IFFALSE 10945
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10925: LD_ADDR_EXP 36
10929: PUSH
10930: LD_EXP 36
10934: PPUSH
10935: LD_INT 1
10937: PPUSH
10938: CALL_OW 3
10942: ST_TO_ADDR
10943: GO 10922
10945: POP
10946: POP
// end ;
10947: PPOPN 2
10949: END
// on VehicleConstructed ( veh , fac ) do var i ;
10950: LD_INT 0
10952: PPUSH
// begin if GetSide ( veh ) = 3 then
10953: LD_VAR 0 1
10957: PPUSH
10958: CALL_OW 255
10962: PUSH
10963: LD_INT 3
10965: EQUAL
10966: IFFALSE 11091
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10968: LD_VAR 0 1
10972: PPUSH
10973: CALL_OW 264
10977: PUSH
10978: LD_INT 53
10980: PUSH
10981: LD_INT 52
10983: PUSH
10984: LD_INT 51
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: LIST
10991: IN
10992: NOT
10993: IFFALSE 11011
// ru_force := ru_force ^ veh ;
10995: LD_ADDR_EXP 35
10999: PUSH
11000: LD_EXP 35
11004: PUSH
11005: LD_VAR 0 1
11009: ADD
11010: ST_TO_ADDR
// for i = 1 to 4 do
11011: LD_ADDR_VAR 0 3
11015: PUSH
11016: DOUBLE
11017: LD_INT 1
11019: DEC
11020: ST_TO_ADDR
11021: LD_INT 4
11023: PUSH
11024: FOR_TO
11025: IFFALSE 11047
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11027: LD_ADDR_EXP 37
11031: PUSH
11032: LD_EXP 37
11036: PPUSH
11037: LD_INT 1
11039: PPUSH
11040: CALL_OW 3
11044: ST_TO_ADDR
11045: GO 11024
11047: POP
11048: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11049: LD_VAR 0 1
11053: PPUSH
11054: CALL_OW 264
11058: PUSH
11059: LD_INT 53
11061: EQUAL
11062: IFFALSE 11091
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11064: LD_VAR 0 1
11068: PPUSH
11069: LD_INT 7
11071: PPUSH
11072: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11076: LD_VAR 0 1
11080: PPUSH
11081: LD_INT 170
11083: PPUSH
11084: LD_INT 235
11086: PPUSH
11087: CALL_OW 171
// end ; end ; end ;
11091: PPOPN 3
11093: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11094: LD_VAR 0 1
11098: PUSH
11099: LD_INT 1
11101: EQUAL
11102: PUSH
11103: LD_VAR 0 2
11107: PUSH
11108: LD_INT 2
11110: EQUAL
11111: AND
11112: PUSH
11113: LD_VAR 0 1
11117: PUSH
11118: LD_INT 2
11120: EQUAL
11121: PUSH
11122: LD_VAR 0 2
11126: PUSH
11127: LD_INT 1
11129: EQUAL
11130: AND
11131: OR
11132: IFFALSE 11142
// player_attacked_ar := true ;
11134: LD_ADDR_EXP 16
11138: PUSH
11139: LD_INT 1
11141: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11142: LD_VAR 0 1
11146: PUSH
11147: LD_INT 1
11149: EQUAL
11150: PUSH
11151: LD_VAR 0 2
11155: PUSH
11156: LD_INT 4
11158: EQUAL
11159: AND
11160: PUSH
11161: LD_VAR 0 1
11165: PUSH
11166: LD_INT 4
11168: EQUAL
11169: PUSH
11170: LD_VAR 0 2
11174: PUSH
11175: LD_INT 1
11177: EQUAL
11178: AND
11179: OR
11180: IFFALSE 11189
// YouLost ( Traitor ) ;
11182: LD_STRING Traitor
11184: PPUSH
11185: CALL_OW 104
// end ;
11189: PPOPN 2
11191: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11192: LD_VAR 0 1
11196: PUSH
11197: LD_EXP 18
11201: EQUAL
11202: IFFALSE 11211
// YouLost ( JMM ) ;
11204: LD_STRING JMM
11206: PPUSH
11207: CALL_OW 104
// if un = terminal then
11211: LD_VAR 0 1
11215: PUSH
11216: LD_EXP 3
11220: EQUAL
11221: IFFALSE 11230
// YouLost ( Terminal ) ;
11223: LD_STRING Terminal
11225: PPUSH
11226: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11230: LD_VAR 0 1
11234: PUSH
11235: LD_INT 22
11237: PUSH
11238: LD_INT 3
11240: PUSH
11241: EMPTY
11242: LIST
11243: LIST
11244: PUSH
11245: LD_INT 21
11247: PUSH
11248: LD_INT 3
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PPUSH
11259: CALL_OW 69
11263: IN
11264: IFFALSE 11410
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11266: LD_VAR 0 1
11270: PPUSH
11271: CALL_OW 266
11275: PUSH
11276: LD_INT 33
11278: PUSH
11279: LD_INT 26
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: IN
11286: IFFALSE 11345
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11288: LD_ADDR_EXP 36
11292: PUSH
11293: LD_EXP 36
11297: PUSH
11298: LD_VAR 0 1
11302: PPUSH
11303: CALL_OW 266
11307: PUSH
11308: LD_VAR 0 1
11312: PPUSH
11313: CALL_OW 250
11317: PUSH
11318: LD_VAR 0 1
11322: PPUSH
11323: CALL_OW 251
11327: PUSH
11328: LD_VAR 0 1
11332: PPUSH
11333: CALL_OW 254
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: ADD
11344: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11345: LD_VAR 0 1
11349: PPUSH
11350: CALL_OW 266
11354: PUSH
11355: LD_INT 5
11357: EQUAL
11358: IFFALSE 11410
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11360: LD_ADDR_EXP 36
11364: PUSH
11365: LD_EXP 36
11369: PUSH
11370: LD_INT 4
11372: PUSH
11373: LD_VAR 0 1
11377: PPUSH
11378: CALL_OW 250
11382: PUSH
11383: LD_VAR 0 1
11387: PPUSH
11388: CALL_OW 251
11392: PUSH
11393: LD_VAR 0 1
11397: PPUSH
11398: CALL_OW 254
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: ADD
11409: ST_TO_ADDR
// end ; if un in ru_force then
11410: LD_VAR 0 1
11414: PUSH
11415: LD_EXP 35
11419: IN
11420: IFFALSE 11456
// begin ru_force := ru_force diff un ;
11422: LD_ADDR_EXP 35
11426: PUSH
11427: LD_EXP 35
11431: PUSH
11432: LD_VAR 0 1
11436: DIFF
11437: ST_TO_ADDR
// if ru_force = 0 then
11438: LD_EXP 35
11442: PUSH
11443: LD_INT 0
11445: EQUAL
11446: IFFALSE 11456
// ru_can_attack := false ;
11448: LD_ADDR_EXP 8
11452: PUSH
11453: LD_INT 0
11455: ST_TO_ADDR
// end ; end ; end_of_file
11456: PPOPN 1
11458: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11459: LD_EXP 5
11463: PUSH
11464: LD_EXP 6
11468: AND
11469: IFFALSE 11547
11471: GO 11473
11473: DISABLE
11474: LD_INT 0
11476: PPUSH
// begin enable ;
11477: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11478: LD_ADDR_VAR 0 1
11482: PUSH
11483: LD_INT 60
11485: PUSH
11486: CALL 784 0 0
11490: MINUS
11491: ST_TO_ADDR
// if sib < 0 then
11492: LD_VAR 0 1
11496: PUSH
11497: LD_INT 0
11499: LESS
11500: IFFALSE 11510
// sib := 0 ;
11502: LD_ADDR_VAR 0 1
11506: PUSH
11507: LD_INT 0
11509: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11510: LD_ADDR_OWVAR 47
11514: PUSH
11515: LD_STRING #Am09-1
11517: PUSH
11518: LD_VAR 0 1
11522: PUSH
11523: LD_EXP 6
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: LIST
11532: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11533: LD_ADDR_EXP 6
11537: PUSH
11538: LD_EXP 6
11542: PUSH
11543: LD_INT 35
11545: MINUS
11546: ST_TO_ADDR
// end ;
11547: PPOPN 1
11549: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11550: LD_EXP 6
11554: PUSH
11555: LD_INT 0
11557: EQUAL
11558: IFFALSE 11570
11560: GO 11562
11562: DISABLE
// display_strings := [ ] ;
11563: LD_ADDR_OWVAR 47
11567: PUSH
11568: EMPTY
11569: ST_TO_ADDR
11570: END
// every 0 0$01 trigger ru_force and debug do
11571: LD_EXP 35
11575: PUSH
11576: LD_EXP 2
11580: AND
11581: IFFALSE 11597
11583: GO 11585
11585: DISABLE
// begin enable ;
11586: ENABLE
// display_strings := ru_force ;
11587: LD_ADDR_OWVAR 47
11591: PUSH
11592: LD_EXP 35
11596: ST_TO_ADDR
// end ;
11597: END
// every 1 1$35 do var i , tmp ;
11598: GO 11600
11600: DISABLE
11601: LD_INT 0
11603: PPUSH
11604: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11605: LD_ADDR_VAR 0 2
11609: PUSH
11610: LD_INT 1155
11612: PUSH
11613: LD_INT 1225
11615: PUSH
11616: LD_INT 1435
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: LIST
11623: PUSH
11624: LD_OWVAR 67
11628: ARRAY
11629: ST_TO_ADDR
// i := 0 ;
11630: LD_ADDR_VAR 0 1
11634: PUSH
11635: LD_INT 0
11637: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11638: LD_INT 1
11640: PPUSH
11641: LD_INT 5
11643: PPUSH
11644: CALL_OW 12
11648: PPUSH
11649: LD_INT 75
11651: PPUSH
11652: LD_INT 75
11654: PPUSH
11655: LD_INT 20
11657: PPUSH
11658: LD_INT 1
11660: PPUSH
11661: CALL_OW 56
// wait ( tmp ) ;
11665: LD_VAR 0 2
11669: PPUSH
11670: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11674: LD_ADDR_VAR 0 2
11678: PUSH
11679: LD_VAR 0 2
11683: PUSH
11684: LD_INT 105
11686: PPUSH
11687: LD_INT 315
11689: PPUSH
11690: CALL_OW 12
11694: PLUS
11695: ST_TO_ADDR
// i := i + 1 ;
11696: LD_ADDR_VAR 0 1
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: LD_INT 1
11708: PLUS
11709: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11710: LD_VAR 0 1
11714: PUSH
11715: LD_INT 3
11717: MOD
11718: PUSH
11719: LD_INT 0
11721: EQUAL
11722: PUSH
11723: LD_EXP 4
11727: AND
11728: IFFALSE 11766
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11730: LD_INT 2
11732: PPUSH
11733: LD_INT 5
11735: PPUSH
11736: CALL_OW 12
11740: PPUSH
11741: LD_INT 8
11743: PPUSH
11744: LD_INT 1
11746: PPUSH
11747: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11751: LD_INT 665
11753: PPUSH
11754: LD_INT 735
11756: PPUSH
11757: CALL_OW 12
11761: PPUSH
11762: CALL_OW 67
// end ; until tick > game_time ;
11766: LD_OWVAR 1
11770: PUSH
11771: LD_EXP 7
11775: GREATER
11776: IFFALSE 11638
// end ; end_of_file
11778: PPOPN 2
11780: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11781: LD_INT 0
11783: PPUSH
11784: PPUSH
11785: PPUSH
11786: PPUSH
11787: PPUSH
11788: PPUSH
// x := 76 ;
11789: LD_ADDR_VAR 0 5
11793: PUSH
11794: LD_INT 76
11796: ST_TO_ADDR
// y := 147 ;
11797: LD_ADDR_VAR 0 6
11801: PUSH
11802: LD_INT 147
11804: ST_TO_ADDR
// uc_side := 2 ;
11805: LD_ADDR_OWVAR 20
11809: PUSH
11810: LD_INT 2
11812: ST_TO_ADDR
// uc_nation := 2 ;
11813: LD_ADDR_OWVAR 21
11817: PUSH
11818: LD_INT 2
11820: ST_TO_ADDR
// InitHc ;
11821: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11825: LD_INT 1
11827: PPUSH
11828: LD_INT 1
11830: PPUSH
11831: LD_INT 6
11833: PPUSH
11834: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11838: LD_ADDR_OWVAR 26
11842: PUSH
11843: LD_STRING Nicolas Vervecken
11845: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11846: LD_ADDR_OWVAR 33
11850: PUSH
11851: LD_STRING SecondCharsGal
11853: ST_TO_ADDR
// hc_face_number := 3 ;
11854: LD_ADDR_OWVAR 34
11858: PUSH
11859: LD_INT 3
11861: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11862: LD_ADDR_OWVAR 29
11866: PUSH
11867: LD_INT 11
11869: PUSH
11870: LD_INT 10
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: ST_TO_ADDR
// Vervecken := CreateHuman ;
11877: LD_ADDR_EXP 26
11881: PUSH
11882: CALL_OW 44
11886: ST_TO_ADDR
// ar_force := Vervecken ;
11887: LD_ADDR_EXP 33
11891: PUSH
11892: LD_EXP 26
11896: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: LD_INT 6
11905: PPUSH
11906: CALL_OW 380
// hc_name := Louis Gali ;
11910: LD_ADDR_OWVAR 26
11914: PUSH
11915: LD_STRING Louis Gali
11917: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11918: LD_ADDR_OWVAR 33
11922: PUSH
11923: LD_STRING SecondCharsGal
11925: ST_TO_ADDR
// hc_face_number := 2 ;
11926: LD_ADDR_OWVAR 34
11930: PUSH
11931: LD_INT 2
11933: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11934: LD_ADDR_OWVAR 29
11938: PUSH
11939: LD_INT 10
11941: PUSH
11942: LD_INT 11
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: ST_TO_ADDR
// Gali := CreateHuman ;
11949: LD_ADDR_EXP 27
11953: PUSH
11954: CALL_OW 44
11958: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11959: LD_ADDR_EXP 33
11963: PUSH
11964: LD_EXP 33
11968: PUSH
11969: LD_EXP 27
11973: ADD
11974: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11975: LD_INT 2
11977: PPUSH
11978: LD_INT 1
11980: PPUSH
11981: LD_INT 6
11983: PPUSH
11984: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11988: LD_ADDR_OWVAR 26
11992: PUSH
11993: LD_STRING Maria Bogdanovic
11995: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11996: LD_ADDR_OWVAR 33
12000: PUSH
12001: LD_STRING SecondCharsGal
12003: ST_TO_ADDR
// hc_face_number := 14 ;
12004: LD_ADDR_OWVAR 34
12008: PUSH
12009: LD_INT 14
12011: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12012: LD_ADDR_OWVAR 29
12016: PUSH
12017: LD_INT 12
12019: PUSH
12020: LD_INT 9
12022: PUSH
12023: EMPTY
12024: LIST
12025: LIST
12026: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12027: LD_ADDR_EXP 28
12031: PUSH
12032: CALL_OW 44
12036: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12037: LD_ADDR_EXP 33
12041: PUSH
12042: LD_EXP 33
12046: PUSH
12047: LD_EXP 28
12051: ADD
12052: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12053: LD_INT 1
12055: PPUSH
12056: LD_INT 3
12058: PPUSH
12059: LD_INT 6
12061: PPUSH
12062: CALL_OW 380
// hc_name = Kntor Radomr ;
12066: LD_ADDR_OWVAR 26
12070: PUSH
12071: LD_STRING Kntor Radomr
12073: ST_TO_ADDR
// hc_gallery = sandar ;
12074: LD_ADDR_OWVAR 33
12078: PUSH
12079: LD_STRING sandar
12081: ST_TO_ADDR
// hc_face_number = 12 ;
12082: LD_ADDR_OWVAR 34
12086: PUSH
12087: LD_INT 12
12089: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12090: LD_ADDR_OWVAR 29
12094: PUSH
12095: LD_INT 9
12097: PUSH
12098: LD_INT 9
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: ST_TO_ADDR
// Kantor = CreateHuman ;
12105: LD_ADDR_EXP 29
12109: PUSH
12110: CALL_OW 44
12114: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12115: LD_ADDR_EXP 33
12119: PUSH
12120: LD_EXP 33
12124: PUSH
12125: LD_EXP 29
12129: ADD
12130: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12131: LD_INT 1
12133: PPUSH
12134: LD_INT 3
12136: PPUSH
12137: LD_INT 6
12139: PPUSH
12140: CALL_OW 380
// hc_name = Herczeg Farkas ;
12144: LD_ADDR_OWVAR 26
12148: PUSH
12149: LD_STRING Herczeg Farkas
12151: ST_TO_ADDR
// hc_gallery = sandar ;
12152: LD_ADDR_OWVAR 33
12156: PUSH
12157: LD_STRING sandar
12159: ST_TO_ADDR
// hc_face_number = 28 ;
12160: LD_ADDR_OWVAR 34
12164: PUSH
12165: LD_INT 28
12167: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12168: LD_ADDR_OWVAR 29
12172: PUSH
12173: LD_INT 10
12175: PUSH
12176: LD_INT 9
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: ST_TO_ADDR
// Herczeg = CreateHuman ;
12183: LD_ADDR_EXP 30
12187: PUSH
12188: CALL_OW 44
12192: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12193: LD_ADDR_EXP 33
12197: PUSH
12198: LD_EXP 33
12202: PUSH
12203: LD_EXP 30
12207: ADD
12208: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12209: LD_INT 1
12211: PPUSH
12212: LD_INT 1
12214: PPUSH
12215: LD_INT 6
12217: PPUSH
12218: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12222: LD_ADDR_OWVAR 26
12226: PUSH
12227: LD_STRING Ronn Horntvedt
12229: ST_TO_ADDR
// hc_gallery = sandar ;
12230: LD_ADDR_OWVAR 33
12234: PUSH
12235: LD_STRING sandar
12237: ST_TO_ADDR
// hc_face_number = 29 ;
12238: LD_ADDR_OWVAR 34
12242: PUSH
12243: LD_INT 29
12245: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12246: LD_ADDR_OWVAR 29
12250: PUSH
12251: LD_INT 11
12253: PUSH
12254: LD_INT 11
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: ST_TO_ADDR
// Ronn = CreateHuman ;
12261: LD_ADDR_EXP 31
12265: PUSH
12266: CALL_OW 44
12270: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12271: LD_ADDR_EXP 33
12275: PUSH
12276: LD_EXP 33
12280: PUSH
12281: LD_EXP 31
12285: ADD
12286: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12287: LD_INT 2
12289: PPUSH
12290: LD_INT 3
12292: PPUSH
12293: LD_INT 6
12295: PPUSH
12296: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12300: LD_ADDR_OWVAR 26
12304: PUSH
12305: LD_STRING Mia D. Mathiasen
12307: ST_TO_ADDR
// hc_gallery = sandar ;
12308: LD_ADDR_OWVAR 33
12312: PUSH
12313: LD_STRING sandar
12315: ST_TO_ADDR
// hc_face_number = 31 ;
12316: LD_ADDR_OWVAR 34
12320: PUSH
12321: LD_INT 31
12323: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12324: LD_ADDR_OWVAR 29
12328: PUSH
12329: LD_INT 10
12331: PUSH
12332: LD_INT 10
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: ST_TO_ADDR
// Mia = CreateHuman ;
12339: LD_ADDR_EXP 32
12343: PUSH
12344: CALL_OW 44
12348: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12349: LD_ADDR_EXP 33
12353: PUSH
12354: LD_EXP 33
12358: PUSH
12359: LD_EXP 32
12363: ADD
12364: ST_TO_ADDR
// for i = 1 to 2 do
12365: LD_ADDR_VAR 0 4
12369: PUSH
12370: DOUBLE
12371: LD_INT 1
12373: DEC
12374: ST_TO_ADDR
12375: LD_INT 2
12377: PUSH
12378: FOR_TO
12379: IFFALSE 12420
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12381: LD_ADDR_VAR 0 3
12385: PUSH
12386: LD_VAR 0 3
12390: PUSH
12391: LD_INT 2
12393: PPUSH
12394: LD_INT 2
12396: PPUSH
12397: LD_INT 14
12399: PPUSH
12400: LD_INT 1
12402: PPUSH
12403: LD_INT 1
12405: PPUSH
12406: LD_INT 32
12408: PPUSH
12409: LD_INT 30
12411: PPUSH
12412: CALL 264 0 7
12416: ADD
12417: ST_TO_ADDR
12418: GO 12378
12420: POP
12421: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12422: LD_ADDR_VAR 0 3
12426: PUSH
12427: LD_VAR 0 3
12431: PUSH
12432: LD_INT 2
12434: PPUSH
12435: LD_INT 2
12437: PPUSH
12438: LD_INT 14
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: LD_INT 1
12446: PPUSH
12447: LD_INT 26
12449: PPUSH
12450: LD_INT 33
12452: PPUSH
12453: CALL 264 0 7
12457: ADD
12458: ST_TO_ADDR
// tmp := tmp diff 0 ;
12459: LD_ADDR_VAR 0 3
12463: PUSH
12464: LD_VAR 0 3
12468: PUSH
12469: LD_INT 0
12471: DIFF
12472: ST_TO_ADDR
// for i in ar_force do
12473: LD_ADDR_VAR 0 4
12477: PUSH
12478: LD_EXP 33
12482: PUSH
12483: FOR_IN
12484: IFFALSE 12627
// begin if GetClass ( i ) = 3 then
12486: LD_VAR 0 4
12490: PPUSH
12491: CALL_OW 257
12495: PUSH
12496: LD_INT 3
12498: EQUAL
12499: IFFALSE 12581
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12501: LD_VAR 0 3
12505: PUSH
12506: LD_INT 1
12508: ARRAY
12509: PPUSH
12510: LD_INT 1
12512: PPUSH
12513: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12517: LD_VAR 0 3
12521: PUSH
12522: LD_INT 1
12524: ARRAY
12525: PPUSH
12526: LD_VAR 0 5
12530: PPUSH
12531: LD_VAR 0 6
12535: PPUSH
12536: LD_INT 0
12538: PPUSH
12539: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12543: LD_VAR 0 4
12547: PPUSH
12548: LD_VAR 0 3
12552: PUSH
12553: LD_INT 1
12555: ARRAY
12556: PPUSH
12557: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12561: LD_ADDR_VAR 0 3
12565: PUSH
12566: LD_VAR 0 3
12570: PPUSH
12571: LD_INT 1
12573: PPUSH
12574: CALL_OW 3
12578: ST_TO_ADDR
// end else
12579: GO 12603
// PlaceUnitXY ( i , x , y , false ) ;
12581: LD_VAR 0 4
12585: PPUSH
12586: LD_VAR 0 5
12590: PPUSH
12591: LD_VAR 0 6
12595: PPUSH
12596: LD_INT 0
12598: PPUSH
12599: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12603: LD_VAR 0 4
12607: PPUSH
12608: LD_INT 86
12610: PPUSH
12611: LD_INT 121
12613: PPUSH
12614: CALL_OW 111
// wait ( 0 0$2 ) ;
12618: LD_INT 70
12620: PPUSH
12621: CALL_OW 67
// end ;
12625: GO 12483
12627: POP
12628: POP
// ar_force := ar_force ^ tmp ;
12629: LD_ADDR_EXP 33
12633: PUSH
12634: LD_EXP 33
12638: PUSH
12639: LD_VAR 0 3
12643: ADD
12644: ST_TO_ADDR
// ar_spawned := true ;
12645: LD_ADDR_EXP 11
12649: PUSH
12650: LD_INT 1
12652: ST_TO_ADDR
// end ; end_of_file
12653: LD_VAR 0 1
12657: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12658: LD_INT 0
12660: PPUSH
12661: PPUSH
12662: PPUSH
12663: PPUSH
12664: PPUSH
12665: PPUSH
12666: PPUSH
// InitHc ;
12667: CALL_OW 19
// uc_side := 3 ;
12671: LD_ADDR_OWVAR 20
12675: PUSH
12676: LD_INT 3
12678: ST_TO_ADDR
// uc_nation := 3 ;
12679: LD_ADDR_OWVAR 21
12683: PUSH
12684: LD_INT 3
12686: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12687: LD_ADDR_VAR 0 5
12691: PUSH
12692: LD_INT 5
12694: PUSH
12695: LD_INT 6
12697: PUSH
12698: LD_INT 7
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: ST_TO_ADDR
// ru_force := [ ] ;
12712: LD_ADDR_EXP 35
12716: PUSH
12717: EMPTY
12718: ST_TO_ADDR
// ru_rebuild := [ ] ;
12719: LD_ADDR_EXP 36
12723: PUSH
12724: EMPTY
12725: ST_TO_ADDR
// ru_produce_list := [ ] ;
12726: LD_ADDR_EXP 37
12730: PUSH
12731: EMPTY
12732: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12733: LD_ADDR_VAR 0 6
12737: PUSH
12738: LD_INT 22
12740: PUSH
12741: LD_INT 3
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 30
12750: PUSH
12751: LD_INT 8
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PPUSH
12762: CALL_OW 69
12766: PUSH
12767: LD_INT 1
12769: ARRAY
12770: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12771: LD_ADDR_VAR 0 4
12775: PUSH
12776: LD_INT 43
12778: PUSH
12779: LD_INT 46
12781: PUSH
12782: LD_INT 45
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: LIST
12789: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12790: LD_ADDR_VAR 0 7
12794: PUSH
12795: LD_INT 22
12797: PUSH
12798: LD_INT 3
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 30
12807: PUSH
12808: LD_INT 1
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: PUSH
12824: LD_INT 1
12826: ARRAY
12827: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12828: LD_VAR 0 7
12832: PPUSH
12833: CALL_OW 274
12837: PPUSH
12838: LD_INT 1
12840: PPUSH
12841: LD_INT 5000
12843: PPUSH
12844: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12848: LD_VAR 0 7
12852: PPUSH
12853: CALL_OW 274
12857: PPUSH
12858: LD_INT 2
12860: PPUSH
12861: LD_INT 1000
12863: PPUSH
12864: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12868: LD_VAR 0 7
12872: PPUSH
12873: CALL_OW 274
12877: PPUSH
12878: LD_INT 3
12880: PPUSH
12881: LD_INT 30
12883: PPUSH
12884: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12888: LD_ADDR_VAR 0 2
12892: PUSH
12893: LD_INT 22
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 30
12905: PUSH
12906: LD_INT 33
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PPUSH
12917: CALL_OW 69
12921: PUSH
12922: FOR_IN
12923: IFFALSE 12955
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12925: LD_VAR 0 2
12929: PPUSH
12930: LD_VAR 0 4
12934: PUSH
12935: LD_VAR 0 2
12939: PUSH
12940: LD_INT 3
12942: MOD
12943: PUSH
12944: LD_INT 1
12946: PLUS
12947: ARRAY
12948: PPUSH
12949: CALL_OW 431
// end ;
12953: GO 12922
12955: POP
12956: POP
// for i = 1 to 4 do
12957: LD_ADDR_VAR 0 2
12961: PUSH
12962: DOUBLE
12963: LD_INT 1
12965: DEC
12966: ST_TO_ADDR
12967: LD_INT 4
12969: PUSH
12970: FOR_TO
12971: IFFALSE 13032
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12973: LD_INT 0
12975: PPUSH
12976: LD_INT 9
12978: PPUSH
12979: LD_VAR 0 5
12983: PPUSH
12984: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12988: CALL_OW 44
12992: PPUSH
12993: LD_INT 22
12995: PUSH
12996: LD_INT 3
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: LD_INT 30
13005: PUSH
13006: LD_INT 5
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: EMPTY
13014: LIST
13015: LIST
13016: PPUSH
13017: CALL_OW 69
13021: PUSH
13022: LD_INT 1
13024: ARRAY
13025: PPUSH
13026: CALL_OW 52
// end ;
13030: GO 12970
13032: POP
13033: POP
// for i = 1 to 5 do
13034: LD_ADDR_VAR 0 2
13038: PUSH
13039: DOUBLE
13040: LD_INT 1
13042: DEC
13043: ST_TO_ADDR
13044: LD_INT 5
13046: PUSH
13047: FOR_TO
13048: IFFALSE 13109
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13050: LD_INT 0
13052: PPUSH
13053: LD_INT 3
13055: PPUSH
13056: LD_VAR 0 5
13060: PPUSH
13061: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13065: CALL_OW 44
13069: PPUSH
13070: LD_INT 22
13072: PUSH
13073: LD_INT 3
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: PUSH
13080: LD_INT 30
13082: PUSH
13083: LD_INT 3
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: PPUSH
13094: CALL_OW 69
13098: PUSH
13099: LD_INT 1
13101: ARRAY
13102: PPUSH
13103: CALL_OW 52
// end ;
13107: GO 13047
13109: POP
13110: POP
// for i = 1 to 4 do
13111: LD_ADDR_VAR 0 2
13115: PUSH
13116: DOUBLE
13117: LD_INT 1
13119: DEC
13120: ST_TO_ADDR
13121: LD_INT 4
13123: PUSH
13124: FOR_TO
13125: IFFALSE 13186
// begin PrepareHuman ( false , class_engineer , skill ) ;
13127: LD_INT 0
13129: PPUSH
13130: LD_INT 2
13132: PPUSH
13133: LD_VAR 0 5
13137: PPUSH
13138: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13142: CALL_OW 44
13146: PPUSH
13147: LD_INT 22
13149: PUSH
13150: LD_INT 3
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: PUSH
13157: LD_INT 30
13159: PUSH
13160: LD_INT 1
13162: PUSH
13163: EMPTY
13164: LIST
13165: LIST
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PPUSH
13171: CALL_OW 69
13175: PUSH
13176: LD_INT 1
13178: ARRAY
13179: PPUSH
13180: CALL_OW 52
// end ;
13184: GO 13124
13186: POP
13187: POP
// for i = 1 to 3 do
13188: LD_ADDR_VAR 0 2
13192: PUSH
13193: DOUBLE
13194: LD_INT 1
13196: DEC
13197: ST_TO_ADDR
13198: LD_INT 3
13200: PUSH
13201: FOR_TO
13202: IFFALSE 13235
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13204: LD_INT 0
13206: PPUSH
13207: LD_INT 4
13209: PPUSH
13210: LD_VAR 0 5
13214: PPUSH
13215: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13219: CALL_OW 44
13223: PPUSH
13224: LD_VAR 0 6
13228: PPUSH
13229: CALL_OW 52
// end ;
13233: GO 13201
13235: POP
13236: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13237: LD_ADDR_EXP 34
13241: PUSH
13242: LD_STRING Yakotich
13244: PPUSH
13245: LD_EXP 2
13249: NOT
13250: PPUSH
13251: LD_STRING 
13253: PPUSH
13254: CALL 201 0 3
13258: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13259: LD_EXP 34
13263: PPUSH
13264: LD_INT 74
13266: PPUSH
13267: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13271: LD_VAR 0 6
13275: PPUSH
13276: LD_INT 49
13278: PPUSH
13279: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13283: LD_VAR 0 6
13287: PPUSH
13288: LD_INT 50
13290: PPUSH
13291: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13295: LD_VAR 0 6
13299: PPUSH
13300: LD_INT 51
13302: PPUSH
13303: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13307: LD_VAR 0 6
13311: PPUSH
13312: LD_INT 52
13314: PPUSH
13315: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13319: LD_VAR 0 6
13323: PPUSH
13324: LD_INT 69
13326: PPUSH
13327: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13331: LD_VAR 0 6
13335: PPUSH
13336: LD_INT 39
13338: PPUSH
13339: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13343: LD_VAR 0 6
13347: PPUSH
13348: LD_INT 34
13350: PPUSH
13351: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13355: LD_VAR 0 6
13359: PPUSH
13360: LD_INT 40
13362: PPUSH
13363: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13367: LD_VAR 0 6
13371: PPUSH
13372: LD_INT 57
13374: PPUSH
13375: CALL_OW 184
// if Difficulty > 1 then
13379: LD_OWVAR 67
13383: PUSH
13384: LD_INT 1
13386: GREATER
13387: IFFALSE 13401
// AddComResearch ( lab , tech_comp2 ) ;
13389: LD_VAR 0 6
13393: PPUSH
13394: LD_INT 58
13396: PPUSH
13397: CALL_OW 184
// end ;
13401: LD_VAR 0 1
13405: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13406: LD_INT 7
13408: PPUSH
13409: CALL_OW 353
13413: PUSH
13414: LD_INT 3
13416: GREATER
13417: PUSH
13418: LD_INT 22
13420: PUSH
13421: LD_INT 3
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PUSH
13428: LD_INT 34
13430: PUSH
13431: LD_INT 53
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PPUSH
13442: CALL_OW 69
13446: NOT
13447: AND
13448: IFFALSE 13483
13450: GO 13452
13452: DISABLE
// begin enable ;
13453: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13454: LD_ADDR_EXP 37
13458: PUSH
13459: LD_EXP 37
13463: PUSH
13464: LD_INT 24
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: LD_INT 3
13472: PUSH
13473: LD_INT 53
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: LIST
13480: LIST
13481: ADD
13482: ST_TO_ADDR
// end ;
13483: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13484: LD_INT 22
13486: PUSH
13487: LD_INT 3
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PUSH
13494: LD_INT 21
13496: PUSH
13497: LD_INT 3
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PPUSH
13508: CALL_OW 69
13512: IFFALSE 14290
13514: GO 13516
13516: DISABLE
13517: LD_INT 0
13519: PPUSH
13520: PPUSH
13521: PPUSH
13522: PPUSH
13523: PPUSH
13524: PPUSH
13525: PPUSH
13526: PPUSH
// begin enable ;
13527: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13528: LD_ADDR_VAR 0 3
13532: PUSH
13533: LD_INT 22
13535: PUSH
13536: LD_INT 3
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: LD_INT 21
13545: PUSH
13546: LD_INT 3
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 3
13555: PUSH
13556: LD_INT 24
13558: PUSH
13559: LD_INT 1000
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13580: LD_ADDR_VAR 0 4
13584: PUSH
13585: LD_INT 22
13587: PUSH
13588: LD_INT 3
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PUSH
13595: LD_INT 25
13597: PUSH
13598: LD_INT 2
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: EMPTY
13606: LIST
13607: LIST
13608: PPUSH
13609: CALL_OW 69
13613: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13614: LD_ADDR_VAR 0 5
13618: PUSH
13619: LD_INT 22
13621: PUSH
13622: LD_INT 3
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: PUSH
13629: LD_INT 30
13631: PUSH
13632: LD_INT 1
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: PPUSH
13643: CALL_OW 69
13647: PUSH
13648: LD_INT 1
13650: ARRAY
13651: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13652: LD_ADDR_VAR 0 8
13656: PUSH
13657: LD_INT 22
13659: PUSH
13660: LD_INT 3
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: PUSH
13667: LD_INT 2
13669: PUSH
13670: LD_INT 30
13672: PUSH
13673: LD_INT 6
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PUSH
13680: LD_INT 30
13682: PUSH
13683: LD_INT 7
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 30
13692: PUSH
13693: LD_INT 8
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PPUSH
13710: CALL_OW 69
13714: PUSH
13715: LD_INT 1
13717: ARRAY
13718: ST_TO_ADDR
// if not engs then
13719: LD_VAR 0 4
13723: NOT
13724: IFFALSE 13728
// exit ;
13726: GO 14290
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13728: LD_ADDR_VAR 0 6
13732: PUSH
13733: LD_VAR 0 4
13737: PPUSH
13738: LD_INT 3
13740: PUSH
13741: LD_INT 24
13743: PUSH
13744: LD_INT 600
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: EMPTY
13752: LIST
13753: LIST
13754: PPUSH
13755: CALL_OW 72
13759: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13760: LD_ADDR_VAR 0 7
13764: PUSH
13765: LD_INT 22
13767: PUSH
13768: LD_INT 3
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: PUSH
13775: LD_INT 25
13777: PUSH
13778: LD_INT 4
13780: PUSH
13781: EMPTY
13782: LIST
13783: LIST
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: PPUSH
13789: CALL_OW 69
13793: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13794: LD_VAR 0 3
13798: NOT
13799: PUSH
13800: LD_EXP 36
13804: NOT
13805: AND
13806: IFFALSE 13866
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13808: LD_VAR 0 4
13812: PPUSH
13813: LD_INT 3
13815: PUSH
13816: LD_INT 54
13818: PUSH
13819: EMPTY
13820: LIST
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PPUSH
13826: CALL_OW 72
13830: IFFALSE 13864
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13832: LD_VAR 0 4
13836: PPUSH
13837: LD_INT 3
13839: PUSH
13840: LD_INT 54
13842: PUSH
13843: EMPTY
13844: LIST
13845: PUSH
13846: EMPTY
13847: LIST
13848: LIST
13849: PPUSH
13850: CALL_OW 72
13854: PPUSH
13855: LD_VAR 0 5
13859: PPUSH
13860: CALL_OW 120
// exit ;
13864: GO 14290
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13866: LD_VAR 0 4
13870: PPUSH
13871: LD_INT 54
13873: PUSH
13874: EMPTY
13875: LIST
13876: PPUSH
13877: CALL_OW 72
13881: IFFALSE 13903
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13883: LD_VAR 0 4
13887: PPUSH
13888: LD_INT 54
13890: PUSH
13891: EMPTY
13892: LIST
13893: PPUSH
13894: CALL_OW 72
13898: PPUSH
13899: CALL_OW 122
// if not tmp then
13903: LD_VAR 0 3
13907: NOT
13908: IFFALSE 14040
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13910: LD_INT 81
13912: PUSH
13913: LD_INT 3
13915: PUSH
13916: EMPTY
13917: LIST
13918: LIST
13919: PUSH
13920: LD_INT 92
13922: PUSH
13923: LD_INT 147
13925: PUSH
13926: LD_INT 212
13928: PUSH
13929: LD_INT 30
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: PPUSH
13942: CALL_OW 69
13946: NOT
13947: IFFALSE 14040
// begin if not HasTask ( engs [ 1 ] ) then
13949: LD_VAR 0 4
13953: PUSH
13954: LD_INT 1
13956: ARRAY
13957: PPUSH
13958: CALL_OW 314
13962: NOT
13963: IFFALSE 14040
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13965: LD_ADDR_VAR 0 2
13969: PUSH
13970: LD_VAR 0 4
13974: PPUSH
13975: LD_EXP 36
13979: PUSH
13980: LD_INT 1
13982: ARRAY
13983: PPUSH
13984: LD_EXP 36
13988: PUSH
13989: LD_INT 2
13991: ARRAY
13992: PPUSH
13993: LD_EXP 36
13997: PUSH
13998: LD_INT 3
14000: ARRAY
14001: PPUSH
14002: LD_EXP 36
14006: PUSH
14007: LD_INT 4
14009: ARRAY
14010: PPUSH
14011: CALL_OW 145
14015: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14016: LD_VAR 0 2
14020: PPUSH
14021: CALL_OW 266
14025: PUSH
14026: LD_INT 4
14028: EQUAL
14029: IFFALSE 14040
// AddComUpgrade ( i ) ;
14031: LD_VAR 0 2
14035: PPUSH
14036: CALL_OW 206
// end ; end ; end ; for i in engs do
14040: LD_ADDR_VAR 0 2
14044: PUSH
14045: LD_VAR 0 4
14049: PUSH
14050: FOR_IN
14051: IFFALSE 14169
// begin if i in to_heal and sci then
14053: LD_VAR 0 2
14057: PUSH
14058: LD_VAR 0 6
14062: IN
14063: PUSH
14064: LD_VAR 0 7
14068: AND
14069: IFFALSE 14120
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14071: LD_VAR 0 2
14075: PPUSH
14076: LD_INT 149
14078: PPUSH
14079: LD_INT 220
14081: PPUSH
14082: CALL_OW 297
14086: PUSH
14087: LD_INT 5
14089: LESS
14090: IFFALSE 14094
// continue ;
14092: GO 14050
// ComMoveXY ( i , 149 , 220 ) ;
14094: LD_VAR 0 2
14098: PPUSH
14099: LD_INT 149
14101: PPUSH
14102: LD_INT 220
14104: PPUSH
14105: CALL_OW 111
// AddComHold ( i ) ;
14109: LD_VAR 0 2
14113: PPUSH
14114: CALL_OW 200
// end else
14118: GO 14167
// if not HasTask ( i ) or WantsToAttack ( i ) then
14120: LD_VAR 0 2
14124: PPUSH
14125: CALL_OW 314
14129: NOT
14130: PUSH
14131: LD_VAR 0 2
14135: PPUSH
14136: CALL_OW 319
14140: OR
14141: IFFALSE 14167
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14143: LD_VAR 0 2
14147: PPUSH
14148: LD_VAR 0 3
14152: PPUSH
14153: LD_VAR 0 2
14157: PPUSH
14158: CALL_OW 74
14162: PPUSH
14163: CALL_OW 130
// end ;
14167: GO 14050
14169: POP
14170: POP
// if to_heal and sci then
14171: LD_VAR 0 6
14175: PUSH
14176: LD_VAR 0 7
14180: AND
14181: IFFALSE 14242
// begin if UnitFilter ( sci , [ f_inside ] ) then
14183: LD_VAR 0 7
14187: PPUSH
14188: LD_INT 54
14190: PUSH
14191: EMPTY
14192: LIST
14193: PPUSH
14194: CALL_OW 72
14198: IFFALSE 14222
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14200: LD_VAR 0 7
14204: PPUSH
14205: LD_INT 54
14207: PUSH
14208: EMPTY
14209: LIST
14210: PPUSH
14211: CALL_OW 72
14215: PPUSH
14216: CALL_OW 122
14220: GO 14240
// ComHeal ( sci , to_heal [ 1 ] ) ;
14222: LD_VAR 0 7
14226: PPUSH
14227: LD_VAR 0 6
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: PPUSH
14236: CALL_OW 128
// end else
14240: GO 14290
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14242: LD_VAR 0 7
14246: PPUSH
14247: LD_INT 56
14249: PUSH
14250: EMPTY
14251: LIST
14252: PPUSH
14253: CALL_OW 72
14257: PUSH
14258: LD_VAR 0 8
14262: AND
14263: IFFALSE 14290
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14265: LD_VAR 0 7
14269: PPUSH
14270: LD_INT 56
14272: PUSH
14273: EMPTY
14274: LIST
14275: PPUSH
14276: CALL_OW 72
14280: PPUSH
14281: LD_VAR 0 8
14285: PPUSH
14286: CALL_OW 120
// end ;
14290: PPOPN 8
14292: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14293: LD_INT 22
14295: PUSH
14296: LD_INT 3
14298: PUSH
14299: EMPTY
14300: LIST
14301: LIST
14302: PUSH
14303: LD_INT 30
14305: PUSH
14306: LD_INT 3
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PPUSH
14317: CALL_OW 69
14321: PUSH
14322: LD_EXP 37
14326: AND
14327: IFFALSE 14453
14329: GO 14331
14331: DISABLE
14332: LD_INT 0
14334: PPUSH
14335: PPUSH
14336: PPUSH
// begin enable ;
14337: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14338: LD_ADDR_VAR 0 3
14342: PUSH
14343: LD_INT 22
14345: PUSH
14346: LD_INT 3
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: LD_INT 30
14355: PUSH
14356: LD_INT 3
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PPUSH
14367: CALL_OW 69
14371: PUSH
14372: LD_INT 1
14374: ARRAY
14375: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14376: LD_VAR 0 3
14380: PPUSH
14381: CALL_OW 313
14385: PUSH
14386: LD_INT 0
14388: EQUAL
14389: IFFALSE 14393
// exit ;
14391: GO 14453
// if BuildingStatus ( fac ) = bs_idle then
14393: LD_VAR 0 3
14397: PPUSH
14398: CALL_OW 461
14402: PUSH
14403: LD_INT 2
14405: EQUAL
14406: IFFALSE 14453
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14408: LD_VAR 0 3
14412: PPUSH
14413: LD_EXP 37
14417: PUSH
14418: LD_INT 1
14420: ARRAY
14421: PPUSH
14422: LD_EXP 37
14426: PUSH
14427: LD_INT 2
14429: ARRAY
14430: PPUSH
14431: LD_EXP 37
14435: PUSH
14436: LD_INT 3
14438: ARRAY
14439: PPUSH
14440: LD_EXP 37
14444: PUSH
14445: LD_INT 4
14447: ARRAY
14448: PPUSH
14449: CALL_OW 125
// end ;
14453: PPOPN 3
14455: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14456: LD_INT 0
14458: PPUSH
14459: PPUSH
14460: PPUSH
14461: PPUSH
14462: PPUSH
// uc_side := 3 ;
14463: LD_ADDR_OWVAR 20
14467: PUSH
14468: LD_INT 3
14470: ST_TO_ADDR
// uc_nation := 3 ;
14471: LD_ADDR_OWVAR 21
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// ru_can_attack := false ;
14479: LD_ADDR_EXP 8
14483: PUSH
14484: LD_INT 0
14486: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14487: LD_ADDR_VAR 0 6
14491: PUSH
14492: LD_INT 22
14494: PUSH
14495: LD_INT 3
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PUSH
14502: LD_INT 30
14504: PUSH
14505: LD_INT 3
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 69
14520: ST_TO_ADDR
// if fac then
14521: LD_VAR 0 6
14525: IFFALSE 14677
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14527: LD_ADDR_EXP 37
14531: PUSH
14532: LD_INT 24
14534: PUSH
14535: LD_INT 1
14537: PUSH
14538: LD_INT 3
14540: PUSH
14541: LD_INT 43
14543: PUSH
14544: EMPTY
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: ST_TO_ADDR
// if wave > 1 then
14550: LD_VAR 0 1
14554: PUSH
14555: LD_INT 1
14557: GREATER
14558: IFFALSE 14611
// for i = 1 to Difficulty do
14560: LD_ADDR_VAR 0 3
14564: PUSH
14565: DOUBLE
14566: LD_INT 1
14568: DEC
14569: ST_TO_ADDR
14570: LD_OWVAR 67
14574: PUSH
14575: FOR_TO
14576: IFFALSE 14609
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14578: LD_ADDR_EXP 37
14582: PUSH
14583: LD_EXP 37
14587: PUSH
14588: LD_INT 24
14590: PUSH
14591: LD_INT 1
14593: PUSH
14594: LD_INT 3
14596: PUSH
14597: LD_INT 45
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: ADD
14606: ST_TO_ADDR
14607: GO 14575
14609: POP
14610: POP
// repeat wait ( 0 0$1 ) ;
14611: LD_INT 35
14613: PPUSH
14614: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14618: LD_EXP 37
14622: PUSH
14623: LD_INT 4
14625: LESS
14626: PUSH
14627: LD_VAR 0 6
14631: PUSH
14632: LD_INT 1
14634: ARRAY
14635: PPUSH
14636: CALL_OW 313
14640: PUSH
14641: LD_INT 0
14643: EQUAL
14644: OR
14645: PUSH
14646: LD_VAR 0 6
14650: PUSH
14651: LD_INT 1
14653: ARRAY
14654: PPUSH
14655: CALL_OW 461
14659: PUSH
14660: LD_INT 8
14662: PUSH
14663: LD_INT 6
14665: PUSH
14666: LD_INT 7
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: LIST
14673: IN
14674: OR
14675: IFFALSE 14611
// end ; case wave of 1 :
14677: LD_VAR 0 1
14681: PUSH
14682: LD_INT 1
14684: DOUBLE
14685: EQUAL
14686: IFTRUE 14690
14688: GO 14775
14690: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14691: LD_ADDR_VAR 0 3
14695: PUSH
14696: DOUBLE
14697: LD_INT 1
14699: DEC
14700: ST_TO_ADDR
14701: LD_INT 4
14703: PUSH
14704: LD_INT 5
14706: PUSH
14707: LD_INT 6
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: LIST
14714: PUSH
14715: LD_OWVAR 67
14719: ARRAY
14720: PUSH
14721: FOR_TO
14722: IFFALSE 14730
// Sold ;
14724: CALL 15001 0 0
14728: GO 14721
14730: POP
14731: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14732: LD_ADDR_VAR 0 3
14736: PUSH
14737: DOUBLE
14738: LD_INT 1
14740: DEC
14741: ST_TO_ADDR
14742: LD_INT 2
14744: PUSH
14745: LD_INT 3
14747: PUSH
14748: LD_INT 3
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: LIST
14755: PUSH
14756: LD_OWVAR 67
14760: ARRAY
14761: PUSH
14762: FOR_TO
14763: IFFALSE 14771
// Tank ;
14765: CALL 15131 0 0
14769: GO 14762
14771: POP
14772: POP
// end ; 2 .. 9 :
14773: GO 14988
14775: LD_INT 2
14777: DOUBLE
14778: GREATEREQUAL
14779: IFFALSE 14787
14781: LD_INT 9
14783: DOUBLE
14784: LESSEQUAL
14785: IFTRUE 14789
14787: GO 14894
14789: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14790: LD_ADDR_VAR 0 3
14794: PUSH
14795: DOUBLE
14796: LD_INT 1
14798: DEC
14799: ST_TO_ADDR
14800: LD_INT 4
14802: PUSH
14803: LD_INT 5
14805: PUSH
14806: LD_INT 6
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: LIST
14813: PUSH
14814: LD_OWVAR 67
14818: ARRAY
14819: PUSH
14820: LD_VAR 0 1
14824: PUSH
14825: LD_INT 2
14827: DIV
14828: PLUS
14829: PUSH
14830: FOR_TO
14831: IFFALSE 14839
// Sold ;
14833: CALL 15001 0 0
14837: GO 14830
14839: POP
14840: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: DOUBLE
14847: LD_INT 1
14849: DEC
14850: ST_TO_ADDR
14851: LD_INT 2
14853: PUSH
14854: LD_INT 3
14856: PUSH
14857: LD_INT 3
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: LIST
14864: PUSH
14865: LD_OWVAR 67
14869: ARRAY
14870: PUSH
14871: LD_VAR 0 1
14875: PUSH
14876: LD_INT 2
14878: DIV
14879: PLUS
14880: PUSH
14881: FOR_TO
14882: IFFALSE 14890
// Tank ;
14884: CALL 15131 0 0
14888: GO 14881
14890: POP
14891: POP
// end ; 10 :
14892: GO 14988
14894: LD_INT 10
14896: DOUBLE
14897: EQUAL
14898: IFTRUE 14902
14900: GO 14987
14902: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14903: LD_ADDR_VAR 0 3
14907: PUSH
14908: DOUBLE
14909: LD_INT 1
14911: DEC
14912: ST_TO_ADDR
14913: LD_INT 10
14915: PUSH
14916: LD_INT 12
14918: PUSH
14919: LD_INT 14
14921: PUSH
14922: EMPTY
14923: LIST
14924: LIST
14925: LIST
14926: PUSH
14927: LD_OWVAR 67
14931: ARRAY
14932: PUSH
14933: FOR_TO
14934: IFFALSE 14942
// Sold ;
14936: CALL 15001 0 0
14940: GO 14933
14942: POP
14943: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
14944: LD_ADDR_VAR 0 3
14948: PUSH
14949: DOUBLE
14950: LD_INT 1
14952: DEC
14953: ST_TO_ADDR
14954: LD_INT 11
14956: PUSH
14957: LD_INT 13
14959: PUSH
14960: LD_INT 15
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: LIST
14967: PUSH
14968: LD_OWVAR 67
14972: ARRAY
14973: PUSH
14974: FOR_TO
14975: IFFALSE 14983
// Tank ;
14977: CALL 15131 0 0
14981: GO 14974
14983: POP
14984: POP
// end ; end ;
14985: GO 14988
14987: POP
// ru_can_attack := true ;
14988: LD_ADDR_EXP 8
14992: PUSH
14993: LD_INT 1
14995: ST_TO_ADDR
// end ;
14996: LD_VAR 0 2
15000: RET
// function Sold ( ) ; var un , skill ; begin
15001: LD_INT 0
15003: PPUSH
15004: PPUSH
15005: PPUSH
// uc_side := 3 ;
15006: LD_ADDR_OWVAR 20
15010: PUSH
15011: LD_INT 3
15013: ST_TO_ADDR
// uc_nation := 3 ;
15014: LD_ADDR_OWVAR 21
15018: PUSH
15019: LD_INT 3
15021: ST_TO_ADDR
// InitHc ;
15022: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15026: LD_ADDR_VAR 0 3
15030: PUSH
15031: LD_INT 6
15033: PUSH
15034: LD_INT 7
15036: PUSH
15037: LD_INT 7
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: LIST
15044: PUSH
15045: LD_OWVAR 67
15049: ARRAY
15050: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15051: LD_INT 0
15053: PPUSH
15054: LD_INT 1
15056: PUSH
15057: LD_INT 9
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: LD_INT 1
15066: PPUSH
15067: LD_INT 2
15069: PPUSH
15070: CALL_OW 12
15074: ARRAY
15075: PPUSH
15076: LD_VAR 0 3
15080: PPUSH
15081: CALL_OW 380
// un := CreateHuman ;
15085: LD_ADDR_VAR 0 2
15089: PUSH
15090: CALL_OW 44
15094: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15095: LD_VAR 0 2
15099: PPUSH
15100: LD_INT 4
15102: PPUSH
15103: LD_INT 0
15105: PPUSH
15106: CALL_OW 49
// ru_force := ru_force ^ un ;
15110: LD_ADDR_EXP 35
15114: PUSH
15115: LD_EXP 35
15119: PUSH
15120: LD_VAR 0 2
15124: ADD
15125: ST_TO_ADDR
// end ;
15126: LD_VAR 0 1
15130: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15131: LD_INT 0
15133: PPUSH
15134: PPUSH
15135: PPUSH
15136: PPUSH
15137: PPUSH
// uc_side := 3 ;
15138: LD_ADDR_OWVAR 20
15142: PUSH
15143: LD_INT 3
15145: ST_TO_ADDR
// uc_nation := 3 ;
15146: LD_ADDR_OWVAR 21
15150: PUSH
15151: LD_INT 3
15153: ST_TO_ADDR
// InitHc ;
15154: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15158: LD_ADDR_VAR 0 5
15162: PUSH
15163: LD_INT 5
15165: PUSH
15166: LD_INT 6
15168: PUSH
15169: LD_INT 7
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: LIST
15176: PUSH
15177: LD_OWVAR 67
15181: ARRAY
15182: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15183: LD_ADDR_VAR 0 3
15187: PUSH
15188: LD_INT 22
15190: PUSH
15191: LD_INT 24
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: LD_INT 1
15200: PPUSH
15201: LD_INT 2
15203: PPUSH
15204: CALL_OW 12
15208: ARRAY
15209: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15210: LD_VAR 0 3
15214: PUSH
15215: LD_INT 22
15217: EQUAL
15218: IFFALSE 15253
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15220: LD_ADDR_VAR 0 4
15224: PUSH
15225: LD_INT 45
15227: PUSH
15228: LD_INT 43
15230: PUSH
15231: LD_INT 44
15233: PUSH
15234: EMPTY
15235: LIST
15236: LIST
15237: LIST
15238: PUSH
15239: LD_INT 1
15241: PPUSH
15242: LD_INT 3
15244: PPUSH
15245: CALL_OW 12
15249: ARRAY
15250: ST_TO_ADDR
15251: GO 15284
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15253: LD_ADDR_VAR 0 4
15257: PUSH
15258: LD_INT 46
15260: PUSH
15261: LD_INT 44
15263: PUSH
15264: LD_INT 45
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: LIST
15271: PUSH
15272: LD_INT 1
15274: PPUSH
15275: LD_INT 3
15277: PPUSH
15278: CALL_OW 12
15282: ARRAY
15283: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15284: LD_ADDR_VAR 0 2
15288: PUSH
15289: LD_INT 3
15291: PPUSH
15292: LD_INT 3
15294: PPUSH
15295: LD_VAR 0 3
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: LD_INT 3
15305: PUSH
15306: LD_INT 3
15308: PUSH
15309: LD_INT 3
15311: PUSH
15312: LD_INT 1
15314: PUSH
15315: EMPTY
15316: LIST
15317: LIST
15318: LIST
15319: LIST
15320: PUSH
15321: LD_INT 1
15323: PPUSH
15324: LD_INT 4
15326: PPUSH
15327: CALL_OW 12
15331: ARRAY
15332: PPUSH
15333: LD_VAR 0 4
15337: PPUSH
15338: LD_INT 99
15340: PPUSH
15341: CALL 264 0 7
15345: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15346: LD_VAR 0 2
15350: PPUSH
15351: CALL_OW 263
15355: PUSH
15356: LD_INT 1
15358: EQUAL
15359: IFFALSE 15390
// begin PrepareHuman ( false , 3 , skill ) ;
15361: LD_INT 0
15363: PPUSH
15364: LD_INT 3
15366: PPUSH
15367: LD_VAR 0 5
15371: PPUSH
15372: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15376: CALL_OW 44
15380: PPUSH
15381: LD_VAR 0 2
15385: PPUSH
15386: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15390: LD_VAR 0 2
15394: PPUSH
15395: LD_INT 3
15397: PPUSH
15398: LD_INT 0
15400: PPUSH
15401: CALL_OW 49
// ru_force := ru_force ^ un ;
15405: LD_ADDR_EXP 35
15409: PUSH
15410: LD_EXP 35
15414: PUSH
15415: LD_VAR 0 2
15419: ADD
15420: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15421: LD_VAR 0 2
15425: PPUSH
15426: LD_INT 126
15428: PPUSH
15429: LD_INT 158
15431: PPUSH
15432: CALL_OW 111
// Wait ( 0 0$3 ) ;
15436: LD_INT 105
15438: PPUSH
15439: CALL_OW 67
// ComStop ( un ) ;
15443: LD_VAR 0 2
15447: PPUSH
15448: CALL_OW 141
// end ;
15452: LD_VAR 0 1
15456: RET
// every 0 0$1 do var i , time , wave ;
15457: GO 15459
15459: DISABLE
15460: LD_INT 0
15462: PPUSH
15463: PPUSH
15464: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_INT 25200
15472: PUSH
15473: LD_INT 24150
15475: PUSH
15476: LD_INT 23100
15478: PUSH
15479: EMPTY
15480: LIST
15481: LIST
15482: LIST
15483: PUSH
15484: LD_OWVAR 67
15488: ARRAY
15489: ST_TO_ADDR
// wait ( time ) ;
15490: LD_VAR 0 2
15494: PPUSH
15495: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15499: LD_ADDR_VAR 0 2
15503: PUSH
15504: LD_INT 15750
15506: PUSH
15507: LD_INT 15050
15509: PUSH
15510: LD_INT 14350
15512: PUSH
15513: EMPTY
15514: LIST
15515: LIST
15516: LIST
15517: PUSH
15518: LD_OWVAR 67
15522: ARRAY
15523: ST_TO_ADDR
// wave := 0 ;
15524: LD_ADDR_VAR 0 3
15528: PUSH
15529: LD_INT 0
15531: ST_TO_ADDR
// while true do
15532: LD_INT 1
15534: IFFALSE 15631
// begin wave := wave + 1 ;
15536: LD_ADDR_VAR 0 3
15540: PUSH
15541: LD_VAR 0 3
15545: PUSH
15546: LD_INT 1
15548: PLUS
15549: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15550: LD_INT 22
15552: PUSH
15553: LD_INT 2
15555: PUSH
15556: EMPTY
15557: LIST
15558: LIST
15559: PPUSH
15560: CALL_OW 69
15564: IFFALSE 15593
// repeat wait ( 0 0$1 ) ;
15566: LD_INT 35
15568: PPUSH
15569: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15573: LD_INT 22
15575: PUSH
15576: LD_INT 2
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: PPUSH
15583: CALL_OW 69
15587: PUSH
15588: LD_INT 0
15590: EQUAL
15591: IFFALSE 15566
// if ru_force < 20 then
15593: LD_EXP 35
15597: PUSH
15598: LD_INT 20
15600: LESS
15601: IFFALSE 15612
// PrepareAttack ( wave ) ;
15603: LD_VAR 0 3
15607: PPUSH
15608: CALL 14456 0 1
// ru_can_attack := true ;
15612: LD_ADDR_EXP 8
15616: PUSH
15617: LD_INT 1
15619: ST_TO_ADDR
// wait ( time ) ;
15620: LD_VAR 0 2
15624: PPUSH
15625: CALL_OW 67
// end ;
15629: GO 15532
// end ;
15631: PPOPN 3
15633: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15634: LD_EXP 8
15638: PUSH
15639: LD_EXP 35
15643: AND
15644: IFFALSE 16478
15646: GO 15648
15648: DISABLE
15649: LD_INT 0
15651: PPUSH
15652: PPUSH
15653: PPUSH
15654: PPUSH
15655: PPUSH
15656: PPUSH
15657: PPUSH
15658: PPUSH
15659: PPUSH
// begin enable ;
15660: ENABLE
// points1 := [ 107 , 123 ] ;
15661: LD_ADDR_VAR 0 4
15665: PUSH
15666: LD_INT 107
15668: PUSH
15669: LD_INT 123
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15676: LD_ADDR_VAR 0 5
15680: PUSH
15681: LD_INT 55
15683: PUSH
15684: LD_INT 42
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15691: LD_ADDR_VAR 0 6
15695: PUSH
15696: LD_INT 102
15698: PUSH
15699: LD_INT 140
15701: PUSH
15702: EMPTY
15703: LIST
15704: LIST
15705: PUSH
15706: LD_INT 105
15708: PUSH
15709: LD_INT 142
15711: PUSH
15712: EMPTY
15713: LIST
15714: LIST
15715: PUSH
15716: LD_INT 129
15718: PUSH
15719: LD_INT 131
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: LIST
15730: ST_TO_ADDR
// for i in ru_force do
15731: LD_ADDR_VAR 0 1
15735: PUSH
15736: LD_EXP 35
15740: PUSH
15741: FOR_IN
15742: IFFALSE 16476
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15744: LD_ADDR_VAR 0 3
15748: PUSH
15749: LD_INT 81
15751: PUSH
15752: LD_INT 3
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PPUSH
15759: CALL_OW 69
15763: PPUSH
15764: LD_VAR 0 1
15768: PPUSH
15769: CALL_OW 74
15773: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15774: LD_VAR 0 1
15778: PPUSH
15779: LD_VAR 0 3
15783: PPUSH
15784: CALL_OW 296
15788: PUSH
15789: LD_INT 12
15791: LESS
15792: IFFALSE 15937
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15794: LD_VAR 0 1
15798: PPUSH
15799: CALL_OW 247
15803: PUSH
15804: LD_INT 1
15806: EQUAL
15807: PUSH
15808: LD_VAR 0 1
15812: PPUSH
15813: CALL_OW 257
15817: PUSH
15818: LD_INT 1
15820: EQUAL
15821: AND
15822: PUSH
15823: LD_VAR 0 3
15827: PUSH
15828: LD_INT 21
15830: PUSH
15831: LD_INT 2
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 58
15840: PUSH
15841: EMPTY
15842: LIST
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PPUSH
15848: CALL_OW 69
15852: IN
15853: AND
15854: IFFALSE 15872
// ComEnterUnit ( i , un ) else
15856: LD_VAR 0 1
15860: PPUSH
15861: LD_VAR 0 3
15865: PPUSH
15866: CALL_OW 120
15870: GO 15935
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15872: LD_VAR 0 3
15876: PUSH
15877: LD_INT 21
15879: PUSH
15880: LD_INT 2
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: PUSH
15887: LD_INT 58
15889: PUSH
15890: EMPTY
15891: LIST
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PPUSH
15897: CALL_OW 69
15901: IN
15902: NOT
15903: IFFALSE 15921
// ComAttackUnit ( i , un ) else
15905: LD_VAR 0 1
15909: PPUSH
15910: LD_VAR 0 3
15914: PPUSH
15915: CALL_OW 115
15919: GO 15935
// ComAttackUnit ( i , JMM ) ;
15921: LD_VAR 0 1
15925: PPUSH
15926: LD_EXP 18
15930: PPUSH
15931: CALL_OW 115
// end else
15935: GO 16474
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15937: LD_VAR 0 1
15941: PPUSH
15942: LD_VAR 0 4
15946: PUSH
15947: LD_INT 1
15949: ARRAY
15950: PPUSH
15951: LD_VAR 0 4
15955: PUSH
15956: LD_INT 2
15958: ARRAY
15959: PPUSH
15960: CALL_OW 297
15964: PUSH
15965: LD_VAR 0 1
15969: PPUSH
15970: LD_VAR 0 5
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_VAR 0 5
15983: PUSH
15984: LD_INT 2
15986: ARRAY
15987: PPUSH
15988: CALL_OW 297
15992: GREATER
15993: PUSH
15994: LD_EXP 9
15998: AND
15999: PUSH
16000: LD_INT 9
16002: PPUSH
16003: LD_INT 81
16005: PUSH
16006: LD_INT 3
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PPUSH
16013: CALL_OW 70
16017: PUSH
16018: LD_INT 0
16020: EQUAL
16021: OR
16022: IFFALSE 16060
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16024: LD_VAR 0 1
16028: PPUSH
16029: LD_INT 81
16031: PUSH
16032: LD_INT 3
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: PPUSH
16039: CALL_OW 69
16043: PPUSH
16044: LD_VAR 0 1
16048: PPUSH
16049: CALL_OW 74
16053: PPUSH
16054: CALL_OW 115
16058: GO 16474
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16060: LD_VAR 0 1
16064: PPUSH
16065: CALL_OW 264
16069: PUSH
16070: LD_INT 45
16072: EQUAL
16073: PUSH
16074: LD_EXP 35
16078: PPUSH
16079: LD_INT 3
16081: PUSH
16082: LD_INT 34
16084: PUSH
16085: LD_INT 45
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PPUSH
16096: CALL_OW 72
16100: PUSH
16101: LD_INT 6
16103: GREATER
16104: AND
16105: IFFALSE 16286
// begin dist := 9999 ;
16107: LD_ADDR_VAR 0 8
16111: PUSH
16112: LD_INT 9999
16114: ST_TO_ADDR
// xy := 0 ;
16115: LD_ADDR_VAR 0 9
16119: PUSH
16120: LD_INT 0
16122: ST_TO_ADDR
// for x in pointsr do
16123: LD_ADDR_VAR 0 7
16127: PUSH
16128: LD_VAR 0 6
16132: PUSH
16133: FOR_IN
16134: IFFALSE 16282
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16136: LD_VAR 0 1
16140: PPUSH
16141: LD_VAR 0 7
16145: PUSH
16146: LD_INT 1
16148: ARRAY
16149: PPUSH
16150: LD_VAR 0 7
16154: PUSH
16155: LD_INT 2
16157: ARRAY
16158: PPUSH
16159: CALL_OW 297
16163: PUSH
16164: LD_VAR 0 8
16168: LESS
16169: IFFALSE 16214
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16171: LD_ADDR_VAR 0 8
16175: PUSH
16176: LD_VAR 0 1
16180: PPUSH
16181: LD_VAR 0 7
16185: PUSH
16186: LD_INT 1
16188: ARRAY
16189: PPUSH
16190: LD_VAR 0 7
16194: PUSH
16195: LD_INT 2
16197: ARRAY
16198: PPUSH
16199: CALL_OW 297
16203: ST_TO_ADDR
// xy := x ;
16204: LD_ADDR_VAR 0 9
16208: PUSH
16209: LD_VAR 0 7
16213: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16214: LD_VAR 0 9
16218: PUSH
16219: LD_VAR 0 1
16223: PPUSH
16224: LD_VAR 0 9
16228: PUSH
16229: LD_INT 1
16231: ARRAY
16232: PPUSH
16233: LD_VAR 0 9
16237: PUSH
16238: LD_INT 2
16240: ARRAY
16241: PPUSH
16242: CALL_OW 297
16246: PUSH
16247: LD_INT 9
16249: GREATER
16250: AND
16251: IFFALSE 16280
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16253: LD_VAR 0 1
16257: PPUSH
16258: LD_VAR 0 9
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PPUSH
16267: LD_VAR 0 9
16271: PUSH
16272: LD_INT 2
16274: ARRAY
16275: PPUSH
16276: CALL_OW 114
// end ;
16280: GO 16133
16282: POP
16283: POP
// end else
16284: GO 16474
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16286: LD_ADDR_VAR 0 3
16290: PUSH
16291: LD_OWVAR 3
16295: PUSH
16296: LD_VAR 0 1
16300: DIFF
16301: PPUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 74
16311: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16312: LD_VAR 0 1
16316: PPUSH
16317: CALL_OW 320
16321: NOT
16322: PUSH
16323: LD_VAR 0 3
16327: PUSH
16328: LD_INT 21
16330: PUSH
16331: LD_INT 2
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PUSH
16338: LD_INT 33
16340: PUSH
16341: LD_INT 1
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: PUSH
16348: LD_INT 58
16350: PUSH
16351: EMPTY
16352: LIST
16353: PUSH
16354: EMPTY
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL_OW 69
16363: IN
16364: PUSH
16365: LD_VAR 0 3
16369: PUSH
16370: LD_INT 22
16372: PUSH
16373: LD_INT 3
16375: PUSH
16376: EMPTY
16377: LIST
16378: LIST
16379: PUSH
16380: LD_INT 21
16382: PUSH
16383: LD_INT 2
16385: PUSH
16386: EMPTY
16387: LIST
16388: LIST
16389: PUSH
16390: LD_INT 3
16392: PUSH
16393: LD_INT 24
16395: PUSH
16396: LD_INT 249
16398: PUSH
16399: EMPTY
16400: LIST
16401: LIST
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: LIST
16411: PPUSH
16412: CALL_OW 69
16416: IN
16417: OR
16418: AND
16419: IFFALSE 16437
// ComAttackUnit ( i , un ) else
16421: LD_VAR 0 1
16425: PPUSH
16426: LD_VAR 0 3
16430: PPUSH
16431: CALL_OW 115
16435: GO 16474
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16437: LD_VAR 0 1
16441: PPUSH
16442: LD_INT 9
16444: PPUSH
16445: LD_INT 81
16447: PUSH
16448: LD_INT 3
16450: PUSH
16451: EMPTY
16452: LIST
16453: LIST
16454: PPUSH
16455: CALL_OW 70
16459: PPUSH
16460: LD_VAR 0 1
16464: PPUSH
16465: CALL_OW 74
16469: PPUSH
16470: CALL_OW 115
// end ; end ; end ; end ;
16474: GO 15741
16476: POP
16477: POP
// end ;
16478: PPOPN 9
16480: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16481: LD_INT 22
16483: PUSH
16484: LD_INT 3
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PUSH
16491: LD_INT 32
16493: PUSH
16494: LD_INT 1
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: PUSH
16501: EMPTY
16502: LIST
16503: LIST
16504: PPUSH
16505: CALL_OW 69
16509: IFFALSE 16597
16511: GO 16513
16513: DISABLE
16514: LD_INT 0
16516: PPUSH
16517: PPUSH
// begin enable ;
16518: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16519: LD_ADDR_VAR 0 2
16523: PUSH
16524: LD_INT 22
16526: PUSH
16527: LD_INT 3
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PUSH
16534: LD_INT 32
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: PPUSH
16548: CALL_OW 69
16552: ST_TO_ADDR
// for i in tmp do
16553: LD_ADDR_VAR 0 1
16557: PUSH
16558: LD_VAR 0 2
16562: PUSH
16563: FOR_IN
16564: IFFALSE 16595
// if GetFuel ( i ) < 12 then
16566: LD_VAR 0 1
16570: PPUSH
16571: CALL_OW 261
16575: PUSH
16576: LD_INT 12
16578: LESS
16579: IFFALSE 16593
// SetFuel ( i , 12 ) ;
16581: LD_VAR 0 1
16585: PPUSH
16586: LD_INT 12
16588: PPUSH
16589: CALL_OW 240
16593: GO 16563
16595: POP
16596: POP
// end ;
16597: PPOPN 2
16599: END
// every 0 0$1 trigger can_end do
16600: LD_EXP 17
16604: IFFALSE 16623
16606: GO 16608
16608: DISABLE
// begin Wait ( 1 1$35 ) ;
16609: LD_INT 3325
16611: PPUSH
16612: CALL_OW 67
// PrepareAttack ( 10 ) ;
16616: LD_INT 10
16618: PPUSH
16619: CALL 14456 0 1
// end ;
16623: END
