// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 202 0 0
// PrepareNature ;
  16: CALL 377 0 0
// PrepareRussian ;
  20: CALL 13125 0 0
// PrepareAmerican ;
  24: CALL 1110 0 0
// PrepareOvsyenko ;
  28: CALL 1733 0 0
// Action ;
  32: CALL 2673 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: PUSH
  92: LD_INT 105000
  94: PUSH
  95: LD_INT 111300
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: LIST
 102: PUSH
 103: LD_OWVAR 67
 107: ARRAY
 108: ST_TO_ADDR
// ru_can_attack := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// ar_can_arrive := false ;
 125: LD_ADDR_EXP 10
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// ar_spawned := false ;
 133: LD_ADDR_EXP 11
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// player_want_mortar := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// player_want_info := false ;
 149: LD_ADDR_EXP 13
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// player_get_mortar := false ;
 157: LD_ADDR_EXP 14
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// player_get_info := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// player_attacked_ar := false ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// can_end := false ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// blocked := false ;
 189: LD_ADDR_EXP 18
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// end ;
 197: LD_VAR 0 1
 201: RET
// function DebugMode ; begin
 202: LD_INT 0
 204: PPUSH
// if not debug then
 205: LD_EXP 2
 209: NOT
 210: IFFALSE 214
// exit ;
 212: GO 221
// FogOff ( 1 ) ;
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 344
// end ; end_of_file
 221: LD_VAR 0 1
 225: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
// if exist_mode then
 230: LD_VAR 0 2
 234: IFFALSE 259
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_VAR 0 3
 245: PUSH
 246: LD_VAR 0 1
 250: STR
 251: PPUSH
 252: CALL_OW 34
 256: ST_TO_ADDR
 257: GO 274
// unit := NewCharacter ( ident ) ;
 259: LD_ADDR_VAR 0 5
 263: PUSH
 264: LD_VAR 0 1
 268: PPUSH
 269: CALL_OW 25
 273: ST_TO_ADDR
// result := unit ;
 274: LD_ADDR_VAR 0 4
 278: PUSH
 279: LD_VAR 0 5
 283: ST_TO_ADDR
// end ;
 284: LD_VAR 0 4
 288: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 289: LD_INT 0
 291: PPUSH
// uc_side := side ;
 292: LD_ADDR_OWVAR 20
 296: PUSH
 297: LD_VAR 0 1
 301: ST_TO_ADDR
// uc_nation := nation ;
 302: LD_ADDR_OWVAR 21
 306: PUSH
 307: LD_VAR 0 2
 311: ST_TO_ADDR
// vc_chassis := chassis ;
 312: LD_ADDR_OWVAR 37
 316: PUSH
 317: LD_VAR 0 3
 321: ST_TO_ADDR
// vc_engine := engine ;
 322: LD_ADDR_OWVAR 39
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// vc_control := control ;
 332: LD_ADDR_OWVAR 38
 336: PUSH
 337: LD_VAR 0 5
 341: ST_TO_ADDR
// vc_weapon := weapon ;
 342: LD_ADDR_OWVAR 40
 346: PUSH
 347: LD_VAR 0 6
 351: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 352: LD_ADDR_OWVAR 41
 356: PUSH
 357: LD_VAR 0 7
 361: ST_TO_ADDR
// result := CreateVehicle ;
 362: LD_ADDR_VAR 0 8
 366: PUSH
 367: CALL_OW 45
 371: ST_TO_ADDR
// end ;
 372: LD_VAR 0 8
 376: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 377: LD_INT 0
 379: PPUSH
 380: PPUSH
 381: PPUSH
 382: PPUSH
// uc_side = 0 ;
 383: LD_ADDR_OWVAR 20
 387: PUSH
 388: LD_INT 0
 390: ST_TO_ADDR
// uc_nation = 0 ;
 391: LD_ADDR_OWVAR 21
 395: PUSH
 396: LD_INT 0
 398: ST_TO_ADDR
// nat_area := natureArea ;
 399: LD_ADDR_VAR 0 4
 403: PUSH
 404: LD_INT 1
 406: ST_TO_ADDR
// InitHc ;
 407: CALL_OW 19
// for i = 1 to 4 do
 411: LD_ADDR_VAR 0 2
 415: PUSH
 416: DOUBLE
 417: LD_INT 1
 419: DEC
 420: ST_TO_ADDR
 421: LD_INT 4
 423: PUSH
 424: FOR_TO
 425: IFFALSE 480
// begin hc_class = 18 ;
 427: LD_ADDR_OWVAR 28
 431: PUSH
 432: LD_INT 18
 434: ST_TO_ADDR
// hc_gallery =  ;
 435: LD_ADDR_OWVAR 33
 439: PUSH
 440: LD_STRING 
 442: ST_TO_ADDR
// hc_face_number = 1 ;
 443: LD_ADDR_OWVAR 34
 447: PUSH
 448: LD_INT 1
 450: ST_TO_ADDR
// animal := CreateHuman ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: CALL_OW 44
 460: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 461: LD_VAR 0 3
 465: PPUSH
 466: LD_VAR 0 4
 470: PPUSH
 471: LD_INT 0
 473: PPUSH
 474: CALL_OW 49
// end ;
 478: GO 424
 480: POP
 481: POP
// for i = 1 to 4 do
 482: LD_ADDR_VAR 0 2
 486: PUSH
 487: DOUBLE
 488: LD_INT 1
 490: DEC
 491: ST_TO_ADDR
 492: LD_INT 4
 494: PUSH
 495: FOR_TO
 496: IFFALSE 568
// begin hc_class = class_tiger ;
 498: LD_ADDR_OWVAR 28
 502: PUSH
 503: LD_INT 14
 505: ST_TO_ADDR
// hc_gallery =  ;
 506: LD_ADDR_OWVAR 33
 510: PUSH
 511: LD_STRING 
 513: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 514: LD_ADDR_OWVAR 35
 518: PUSH
 519: LD_INT 5
 521: NEG
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL_OW 12
 530: ST_TO_ADDR
// hc_face_number = 3 ;
 531: LD_ADDR_OWVAR 34
 535: PUSH
 536: LD_INT 3
 538: ST_TO_ADDR
// animal := CreateHuman ;
 539: LD_ADDR_VAR 0 3
 543: PUSH
 544: CALL_OW 44
 548: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 549: LD_VAR 0 3
 553: PPUSH
 554: LD_VAR 0 4
 558: PPUSH
 559: LD_INT 0
 561: PPUSH
 562: CALL_OW 49
// end ;
 566: GO 495
 568: POP
 569: POP
// for i = 1 to 8 do
 570: LD_ADDR_VAR 0 2
 574: PUSH
 575: DOUBLE
 576: LD_INT 1
 578: DEC
 579: ST_TO_ADDR
 580: LD_INT 8
 582: PUSH
 583: FOR_TO
 584: IFFALSE 687
// begin hc_class = class_apeman ;
 586: LD_ADDR_OWVAR 28
 590: PUSH
 591: LD_INT 12
 593: ST_TO_ADDR
// hc_gallery =  ;
 594: LD_ADDR_OWVAR 33
 598: PUSH
 599: LD_STRING 
 601: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 602: LD_ADDR_OWVAR 35
 606: PUSH
 607: LD_INT 2
 609: NEG
 610: PPUSH
 611: LD_INT 2
 613: PPUSH
 614: CALL_OW 12
 618: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 619: LD_ADDR_OWVAR 31
 623: PUSH
 624: LD_INT 1
 626: PPUSH
 627: LD_INT 3
 629: PPUSH
 630: CALL_OW 12
 634: PUSH
 635: LD_INT 1
 637: PPUSH
 638: LD_INT 3
 640: PPUSH
 641: CALL_OW 12
 645: PUSH
 646: LD_INT 0
 648: PUSH
 649: LD_INT 0
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: LIST
 657: ST_TO_ADDR
// animal := CreateHuman ;
 658: LD_ADDR_VAR 0 3
 662: PUSH
 663: CALL_OW 44
 667: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 668: LD_VAR 0 3
 672: PPUSH
 673: LD_VAR 0 4
 677: PPUSH
 678: LD_INT 0
 680: PPUSH
 681: CALL_OW 49
// end ;
 685: GO 583
 687: POP
 688: POP
// for i = 1 to 6 do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: DOUBLE
 695: LD_INT 1
 697: DEC
 698: ST_TO_ADDR
 699: LD_INT 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 758
// begin hc_class = 13 ;
 705: LD_ADDR_OWVAR 28
 709: PUSH
 710: LD_INT 13
 712: ST_TO_ADDR
// hc_gallery =  ;
 713: LD_ADDR_OWVAR 33
 717: PUSH
 718: LD_STRING 
 720: ST_TO_ADDR
// hc_face_number = 4 ;
 721: LD_ADDR_OWVAR 34
 725: PUSH
 726: LD_INT 4
 728: ST_TO_ADDR
// animal := CreateHuman ;
 729: LD_ADDR_VAR 0 3
 733: PUSH
 734: CALL_OW 44
 738: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 739: LD_VAR 0 3
 743: PPUSH
 744: LD_VAR 0 4
 748: PPUSH
 749: LD_INT 0
 751: PPUSH
 752: CALL_OW 49
// end ;
 756: GO 702
 758: POP
 759: POP
// vc_chassis := 31 ;
 760: LD_ADDR_OWVAR 37
 764: PUSH
 765: LD_INT 31
 767: ST_TO_ADDR
// vc_control := control_rider ;
 768: LD_ADDR_OWVAR 38
 772: PUSH
 773: LD_INT 4
 775: ST_TO_ADDR
// animal := CreateVehicle ;
 776: LD_ADDR_VAR 0 3
 780: PUSH
 781: CALL_OW 45
 785: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 786: LD_VAR 0 3
 790: PPUSH
 791: LD_INT 21
 793: PPUSH
 794: LD_INT 22
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 48
// end ;
 804: LD_VAR 0 1
 808: RET
// export function GetTerminalCargo ; begin
 809: LD_INT 0
 811: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 812: LD_ADDR_VAR 0 1
 816: PUSH
 817: LD_EXP 3
 821: PPUSH
 822: CALL_OW 274
 826: PPUSH
 827: LD_INT 3
 829: PPUSH
 830: CALL_OW 275
 834: ST_TO_ADDR
// end ;
 835: LD_VAR 0 1
 839: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 840: LD_INT 0
 842: PPUSH
 843: PPUSH
 844: PPUSH
// result := 0 ;
 845: LD_ADDR_VAR 0 2
 849: PUSH
 850: LD_INT 0
 852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 853: LD_ADDR_VAR 0 4
 857: PUSH
 858: LD_INT 22
 860: PUSH
 861: LD_VAR 0 1
 865: PUSH
 866: EMPTY
 867: LIST
 868: LIST
 869: PUSH
 870: LD_INT 2
 872: PUSH
 873: LD_INT 30
 875: PUSH
 876: LD_INT 0
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 30
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PPUSH
 902: CALL_OW 69
 906: ST_TO_ADDR
// if not tmp then
 907: LD_VAR 0 4
 911: NOT
 912: IFFALSE 916
// exit ;
 914: GO 962
// for i in tmp do
 916: LD_ADDR_VAR 0 3
 920: PUSH
 921: LD_VAR 0 4
 925: PUSH
 926: FOR_IN
 927: IFFALSE 960
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 929: LD_ADDR_VAR 0 2
 933: PUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_VAR 0 3
 943: PPUSH
 944: CALL_OW 274
 948: PPUSH
 949: LD_INT 3
 951: PPUSH
 952: CALL_OW 275
 956: PLUS
 957: ST_TO_ADDR
 958: GO 926
 960: POP
 961: POP
// end ;
 962: LD_VAR 0 2
 966: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 967: LD_INT 0
 969: PPUSH
 970: PPUSH
// area = ListEnvironmentArea ( area ) ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_VAR 0 2
 980: PPUSH
 981: CALL_OW 353
 985: ST_TO_ADDR
// if bulldozer > 0 then
 986: LD_VAR 0 1
 990: PUSH
 991: LD_INT 0
 993: GREATER
 994: IFFALSE 1105
// for i = area downto 1 do
 996: LD_ADDR_VAR 0 4
1000: PUSH
1001: DOUBLE
1002: LD_VAR 0 2
1006: INC
1007: ST_TO_ADDR
1008: LD_INT 1
1010: PUSH
1011: FOR_DOWNTO
1012: IFFALSE 1103
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1014: LD_VAR 0 2
1018: PUSH
1019: LD_VAR 0 4
1023: ARRAY
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: LD_VAR 0 2
1033: PUSH
1034: LD_VAR 0 4
1038: ARRAY
1039: PUSH
1040: LD_INT 2
1042: ARRAY
1043: PPUSH
1044: CALL_OW 351
1048: IFFALSE 1101
// if not HasTask ( bulldozer ) then
1050: LD_VAR 0 1
1054: PPUSH
1055: CALL_OW 314
1059: NOT
1060: IFFALSE 1101
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1062: LD_VAR 0 1
1066: PPUSH
1067: LD_VAR 0 2
1071: PUSH
1072: LD_VAR 0 4
1076: ARRAY
1077: PUSH
1078: LD_INT 1
1080: ARRAY
1081: PPUSH
1082: LD_VAR 0 2
1086: PUSH
1087: LD_VAR 0 4
1091: ARRAY
1092: PUSH
1093: LD_INT 2
1095: ARRAY
1096: PPUSH
1097: CALL_OW 171
1101: GO 1011
1103: POP
1104: POP
// end ; end_of_file
1105: LD_VAR 0 3
1109: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1110: LD_INT 0
1112: PPUSH
1113: PPUSH
1114: PPUSH
1115: PPUSH
1116: PPUSH
// uc_side := 1 ;
1117: LD_ADDR_OWVAR 20
1121: PUSH
1122: LD_INT 1
1124: ST_TO_ADDR
// uc_nation := 1 ;
1125: LD_ADDR_OWVAR 21
1129: PUSH
1130: LD_INT 1
1132: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1133: LD_ADDR_EXP 19
1137: PUSH
1138: LD_STRING JMM
1140: PPUSH
1141: LD_EXP 2
1145: NOT
1146: PPUSH
1147: LD_STRING 08_
1149: PPUSH
1150: CALL 226 0 3
1154: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1155: LD_ADDR_VAR 0 4
1159: PUSH
1160: LD_INT 1
1162: PPUSH
1163: LD_INT 1
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: LD_INT 2
1171: PPUSH
1172: LD_INT 1
1174: PPUSH
1175: LD_INT 5
1177: PPUSH
1178: LD_INT 55
1180: PPUSH
1181: CALL 289 0 7
1185: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1186: LD_VAR 0 4
1190: PPUSH
1191: LD_INT 3
1193: PPUSH
1194: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1198: LD_VAR 0 4
1202: PPUSH
1203: LD_INT 43
1205: PPUSH
1206: LD_INT 3
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1216: LD_EXP 19
1220: PPUSH
1221: LD_VAR 0 4
1225: PPUSH
1226: CALL_OW 52
// tmp := [ ] ;
1230: LD_ADDR_VAR 0 2
1234: PUSH
1235: EMPTY
1236: ST_TO_ADDR
// uc_side := 4 ;
1237: LD_ADDR_OWVAR 20
1241: PUSH
1242: LD_INT 4
1244: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1245: LD_ADDR_OWVAR 33
1249: PUSH
1250: LD_STRING SecondCharsGal
1252: ST_TO_ADDR
// hc_class := 2 ;
1253: LD_ADDR_OWVAR 28
1257: PUSH
1258: LD_INT 2
1260: ST_TO_ADDR
// hc_sex := sex_female ;
1261: LD_ADDR_OWVAR 27
1265: PUSH
1266: LD_INT 2
1268: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1269: LD_ADDR_OWVAR 30
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: LD_INT 1
1279: PUSH
1280: LD_INT 1
1282: PUSH
1283: LD_INT 0
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1292: LD_ADDR_OWVAR 31
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: LD_INT 4
1302: PUSH
1303: LD_INT 2
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1315: LD_ADDR_OWVAR 29
1319: PUSH
1320: LD_INT 10
1322: PUSH
1323: LD_INT 11
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1330: LD_ADDR_OWVAR 26
1334: PUSH
1335: LD_STRING Naoma Goichman
1337: ST_TO_ADDR
// hc_face_number := 43 ;
1338: LD_ADDR_OWVAR 34
1342: PUSH
1343: LD_INT 43
1345: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1346: LD_ADDR_VAR 0 2
1350: PUSH
1351: LD_VAR 0 2
1355: PUSH
1356: CALL_OW 44
1360: ADD
1361: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1362: LD_ADDR_OWVAR 30
1366: PUSH
1367: LD_INT 0
1369: PUSH
1370: LD_INT 2
1372: PUSH
1373: LD_INT 0
1375: PUSH
1376: LD_INT 1
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1385: LD_ADDR_OWVAR 31
1389: PUSH
1390: LD_INT 0
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: LD_INT 3
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1408: LD_ADDR_OWVAR 29
1412: PUSH
1413: LD_INT 10
1415: PUSH
1416: LD_INT 10
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1423: LD_ADDR_OWVAR 26
1427: PUSH
1428: LD_STRING Magdalene Glance
1430: ST_TO_ADDR
// hc_face_number := 44 ;
1431: LD_ADDR_OWVAR 34
1435: PUSH
1436: LD_INT 44
1438: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1439: LD_ADDR_VAR 0 2
1443: PUSH
1444: LD_VAR 0 2
1448: PUSH
1449: CALL_OW 44
1453: ADD
1454: ST_TO_ADDR
// hc_sex := sex_male ;
1455: LD_ADDR_OWVAR 27
1459: PUSH
1460: LD_INT 1
1462: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1463: LD_ADDR_OWVAR 30
1467: PUSH
1468: LD_INT 2
1470: PUSH
1471: LD_INT 2
1473: PUSH
1474: LD_INT 0
1476: PUSH
1477: LD_INT 0
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1486: LD_ADDR_OWVAR 31
1490: PUSH
1491: LD_INT 3
1493: PUSH
1494: LD_INT 4
1496: PUSH
1497: LD_INT 1
1499: PUSH
1500: LD_INT 0
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: LIST
1508: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1509: LD_ADDR_OWVAR 29
1513: PUSH
1514: LD_INT 12
1516: PUSH
1517: LD_INT 10
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: ST_TO_ADDR
// hc_name := Steve Holland ;
1524: LD_ADDR_OWVAR 26
1528: PUSH
1529: LD_STRING Steve Holland
1531: ST_TO_ADDR
// hc_face_number := 60 ;
1532: LD_ADDR_OWVAR 34
1536: PUSH
1537: LD_INT 60
1539: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_VAR 0 2
1549: PUSH
1550: CALL_OW 44
1554: ADD
1555: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1556: LD_ADDR_EXP 24
1560: PUSH
1561: LD_VAR 0 2
1565: PUSH
1566: LD_INT 0
1568: DIFF
1569: ST_TO_ADDR
// for un in alpha_engs do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: LD_EXP 24
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1606
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1583: LD_VAR 0 3
1587: PPUSH
1588: LD_INT 52
1590: PPUSH
1591: LD_INT 35
1593: PPUSH
1594: LD_INT 3
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 50
1604: GO 1580
1606: POP
1607: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1608: LD_ADDR_VAR 0 2
1612: PUSH
1613: DOUBLE
1614: LD_INT 1
1616: DEC
1617: ST_TO_ADDR
1618: LD_INT 1
1620: PUSH
1621: LD_STRING 06_crates_1
1623: PPUSH
1624: LD_INT 0
1626: PPUSH
1627: CALL_OW 30
1631: PLUS
1632: PUSH
1633: LD_INT 2
1635: MUL
1636: PUSH
1637: FOR_TO
1638: IFFALSE 1664
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 5
1645: PPUSH
1646: LD_INT 56
1648: PPUSH
1649: LD_INT 40
1651: PPUSH
1652: LD_INT 2
1654: PPUSH
1655: LD_INT 0
1657: PPUSH
1658: CALL_OW 60
1662: GO 1637
1664: POP
1665: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1666: LD_STRING GammaCommander
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 30
1676: PUSH
1677: LD_INT 3
1679: LESS
1680: IFFALSE 1701
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1682: LD_ADDR_EXP 23
1686: PUSH
1687: LD_STRING VanHouten
1689: PPUSH
1690: LD_INT 0
1692: PPUSH
1693: LD_STRING 
1695: PPUSH
1696: CALL 226 0 3
1700: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1701: LD_ADDR_EXP 26
1705: PUSH
1706: LD_STRING Powell
1708: PPUSH
1709: LD_INT 0
1711: PPUSH
1712: LD_STRING 
1714: PPUSH
1715: CALL 226 0 3
1719: ST_TO_ADDR
// InitHc ;
1720: CALL_OW 19
// InitUc ;
1724: CALL_OW 18
// end ;
1728: LD_VAR 0 1
1732: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1733: LD_INT 0
1735: PPUSH
1736: PPUSH
1737: PPUSH
1738: PPUSH
1739: PPUSH
// uc_side := 4 ;
1740: LD_ADDR_OWVAR 20
1744: PUSH
1745: LD_INT 4
1747: ST_TO_ADDR
// uc_nation := 3 ;
1748: LD_ADDR_OWVAR 21
1752: PUSH
1753: LD_INT 3
1755: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1756: LD_ADDR_VAR 0 4
1760: PUSH
1761: LD_STRING 09_ovsyenko_base
1763: PPUSH
1764: LD_INT 0
1766: PUSH
1767: LD_INT 101
1769: PUSH
1770: LD_INT 118
1772: PUSH
1773: LD_INT 2
1775: PUSH
1776: LD_INT 500
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 31
1788: PUSH
1789: LD_INT 109
1791: PUSH
1792: LD_INT 114
1794: PUSH
1795: LD_INT 4
1797: PUSH
1798: LD_INT 500
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: PUSH
1808: LD_INT 31
1810: PUSH
1811: LD_INT 115
1813: PUSH
1814: LD_INT 132
1816: PUSH
1817: LD_INT 5
1819: PUSH
1820: LD_INT 500
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: LD_INT 31
1832: PUSH
1833: LD_INT 98
1835: PUSH
1836: LD_INT 120
1838: PUSH
1839: LD_INT 1
1841: PUSH
1842: LD_INT 500
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 30
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 2
1867: PUSH
1868: LD_VAR 0 4
1872: PUSH
1873: FOR_IN
1874: IFFALSE 2030
// begin bc_type := i [ 1 ] ;
1876: LD_ADDR_OWVAR 42
1880: PUSH
1881: LD_VAR 0 2
1885: PUSH
1886: LD_INT 1
1888: ARRAY
1889: ST_TO_ADDR
// bc_level := 3 ;
1890: LD_ADDR_OWVAR 43
1894: PUSH
1895: LD_INT 3
1897: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1898: LD_ADDR_VAR 0 3
1902: PUSH
1903: LD_VAR 0 2
1907: PUSH
1908: LD_INT 2
1910: ARRAY
1911: PPUSH
1912: LD_VAR 0 2
1916: PUSH
1917: LD_INT 3
1919: ARRAY
1920: PPUSH
1921: LD_VAR 0 2
1925: PUSH
1926: LD_INT 4
1928: ARRAY
1929: PPUSH
1930: CALL_OW 47
1934: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1935: LD_VAR 0 3
1939: PPUSH
1940: CALL_OW 266
1944: PUSH
1945: LD_INT 0
1947: EQUAL
1948: IFFALSE 1982
// begin SetBName ( b , ovsyenko ) ;
1950: LD_VAR 0 3
1954: PPUSH
1955: LD_STRING ovsyenko
1957: PPUSH
1958: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: CALL_OW 274
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: LD_INT 50
1977: PPUSH
1978: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1982: LD_VAR 0 2
1986: PUSH
1987: LD_INT 5
1989: ARRAY
1990: PUSH
1991: LD_INT 250
1993: LESS
1994: IFFALSE 2010
// SetLives ( b , 333 ) else
1996: LD_VAR 0 3
2000: PPUSH
2001: LD_INT 333
2003: PPUSH
2004: CALL_OW 234
2008: GO 2028
// SetLives ( b , i [ 5 ] ) ;
2010: LD_VAR 0 3
2014: PPUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 5
2022: ARRAY
2023: PPUSH
2024: CALL_OW 234
// end ;
2028: GO 1873
2030: POP
2031: POP
// uc_nation := 1 ;
2032: LD_ADDR_OWVAR 21
2036: PUSH
2037: LD_INT 1
2039: ST_TO_ADDR
// tmp := [ ] ;
2040: LD_ADDR_VAR 0 4
2044: PUSH
2045: EMPTY
2046: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2047: LD_ADDR_EXP 20
2051: PUSH
2052: LD_STRING Gary
2054: PPUSH
2055: LD_EXP 2
2059: NOT
2060: PPUSH
2061: LD_STRING 
2063: PPUSH
2064: CALL 226 0 3
2068: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: LD_VAR 0 4
2078: PUSH
2079: LD_EXP 20
2083: ADD
2084: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2085: LD_ADDR_EXP 21
2089: PUSH
2090: LD_STRING Bobby
2092: PPUSH
2093: LD_EXP 2
2097: NOT
2098: PPUSH
2099: LD_STRING 08_
2101: PPUSH
2102: CALL 226 0 3
2106: ST_TO_ADDR
// if not Bobby then
2107: LD_EXP 21
2111: NOT
2112: IFFALSE 2136
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2114: LD_ADDR_EXP 21
2118: PUSH
2119: LD_STRING Bobby
2121: PPUSH
2122: LD_EXP 2
2126: NOT
2127: PPUSH
2128: LD_STRING 03_
2130: PPUSH
2131: CALL 226 0 3
2135: ST_TO_ADDR
// if Bobby then
2136: LD_EXP 21
2140: IFFALSE 2158
// tmp := tmp ^ Bobby ;
2142: LD_ADDR_VAR 0 4
2146: PUSH
2147: LD_VAR 0 4
2151: PUSH
2152: LD_EXP 21
2156: ADD
2157: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2158: LD_ADDR_EXP 22
2162: PUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: LD_EXP 2
2170: NOT
2171: PPUSH
2172: LD_STRING 08_
2174: PPUSH
2175: CALL 226 0 3
2179: ST_TO_ADDR
// if not Cyrus then
2180: LD_EXP 22
2184: NOT
2185: IFFALSE 2209
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2187: LD_ADDR_EXP 22
2191: PUSH
2192: LD_STRING Cyrus
2194: PPUSH
2195: LD_EXP 2
2199: NOT
2200: PPUSH
2201: LD_STRING 03_
2203: PPUSH
2204: CALL 226 0 3
2208: ST_TO_ADDR
// if Cyrus then
2209: LD_EXP 22
2213: IFFALSE 2231
// tmp := tmp ^ Cyrus ;
2215: LD_ADDR_VAR 0 4
2219: PUSH
2220: LD_VAR 0 4
2224: PUSH
2225: LD_EXP 22
2229: ADD
2230: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2231: LD_ADDR_VAR 0 4
2235: PUSH
2236: LD_VAR 0 4
2240: PUSH
2241: LD_STRING 09_prev_squad
2243: PPUSH
2244: CALL_OW 31
2248: ADD
2249: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2250: LD_STRING 09_prev_squad
2252: PPUSH
2253: CALL_OW 40
// tmp := tmp diff 0 ;
2257: LD_ADDR_VAR 0 4
2261: PUSH
2262: LD_VAR 0 4
2266: PUSH
2267: LD_INT 0
2269: DIFF
2270: ST_TO_ADDR
// if debug then
2271: LD_EXP 2
2275: IFFALSE 2326
// begin for i = 1 to 6 do
2277: LD_ADDR_VAR 0 2
2281: PUSH
2282: DOUBLE
2283: LD_INT 1
2285: DEC
2286: ST_TO_ADDR
2287: LD_INT 6
2289: PUSH
2290: FOR_TO
2291: IFFALSE 2324
// begin PrepareHuman ( false , 1 , 6 ) ;
2293: LD_INT 0
2295: PPUSH
2296: LD_INT 1
2298: PPUSH
2299: LD_INT 6
2301: PPUSH
2302: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2306: LD_ADDR_VAR 0 4
2310: PUSH
2311: LD_VAR 0 4
2315: PUSH
2316: CALL_OW 44
2320: ADD
2321: ST_TO_ADDR
// end ;
2322: GO 2290
2324: POP
2325: POP
// end ; for i in tmp do
2326: LD_ADDR_VAR 0 2
2330: PUSH
2331: LD_VAR 0 4
2335: PUSH
2336: FOR_IN
2337: IFFALSE 2396
// begin if GetClass ( i ) in [ 2 , 3 ] then
2339: LD_VAR 0 2
2343: PPUSH
2344: CALL_OW 257
2348: PUSH
2349: LD_INT 2
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: EMPTY
2356: LIST
2357: LIST
2358: IN
2359: IFFALSE 2373
// SetClass ( i , 1 ) ;
2361: LD_VAR 0 2
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2373: LD_VAR 0 2
2377: PPUSH
2378: LD_INT 106
2380: PPUSH
2381: LD_INT 122
2383: PPUSH
2384: LD_INT 5
2386: PPUSH
2387: LD_INT 0
2389: PPUSH
2390: CALL_OW 50
// end ;
2394: GO 2336
2396: POP
2397: POP
// tmp := tmp diff Gary ;
2398: LD_ADDR_VAR 0 4
2402: PUSH
2403: LD_VAR 0 4
2407: PUSH
2408: LD_EXP 20
2412: DIFF
2413: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2414: LD_ADDR_VAR 0 3
2418: PUSH
2419: LD_INT 22
2421: PUSH
2422: LD_INT 4
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: LD_INT 30
2431: PUSH
2432: LD_INT 31
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PPUSH
2443: CALL_OW 69
2447: ST_TO_ADDR
// for i = 1 to b do
2448: LD_ADDR_VAR 0 2
2452: PUSH
2453: DOUBLE
2454: LD_INT 1
2456: DEC
2457: ST_TO_ADDR
2458: LD_VAR 0 3
2462: PUSH
2463: FOR_TO
2464: IFFALSE 2494
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2466: LD_VAR 0 4
2470: PUSH
2471: LD_VAR 0 2
2475: ARRAY
2476: PPUSH
2477: LD_VAR 0 3
2481: PUSH
2482: LD_VAR 0 2
2486: ARRAY
2487: PPUSH
2488: CALL_OW 120
// end ;
2492: GO 2463
2494: POP
2495: POP
// InitHc ;
2496: CALL_OW 19
// InitUc ;
2500: CALL_OW 18
// end ;
2504: LD_VAR 0 1
2508: RET
// export function PowellTransport ; var i , un ; begin
2509: LD_INT 0
2511: PPUSH
2512: PPUSH
2513: PPUSH
// uc_side := 4 ;
2514: LD_ADDR_OWVAR 20
2518: PUSH
2519: LD_INT 4
2521: ST_TO_ADDR
// uc_nation := 1 ;
2522: LD_ADDR_OWVAR 21
2526: PUSH
2527: LD_INT 1
2529: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2530: LD_INT 1
2532: PPUSH
2533: LD_INT 3
2535: PPUSH
2536: LD_INT 6
2538: PPUSH
2539: CALL_OW 380
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2551: LD_ADDR_OWVAR 33
2555: PUSH
2556: LD_STRING SecondCharsGal
2558: ST_TO_ADDR
// hc_face_number := 30 ;
2559: LD_ADDR_OWVAR 34
2563: PUSH
2564: LD_INT 30
2566: ST_TO_ADDR
// powell_trans := CreateHuman ;
2567: LD_ADDR_EXP 25
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// hc_face_number := 31 ;
2577: LD_ADDR_OWVAR 34
2581: PUSH
2582: LD_INT 31
2584: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2585: LD_ADDR_EXP 25
2589: PUSH
2590: LD_EXP 25
2594: PUSH
2595: CALL_OW 44
2599: ADD
2600: ST_TO_ADDR
// for i = 1 to 2 do
2601: LD_ADDR_VAR 0 2
2605: PUSH
2606: DOUBLE
2607: LD_INT 1
2609: DEC
2610: ST_TO_ADDR
2611: LD_INT 2
2613: PUSH
2614: FOR_TO
2615: IFFALSE 2666
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_INT 4
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 1
2633: PPUSH
2634: LD_INT 1
2636: PPUSH
2637: LD_INT 12
2639: PPUSH
2640: LD_INT 66
2642: PPUSH
2643: CALL 289 0 7
2647: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2648: LD_ADDR_EXP 25
2652: PUSH
2653: LD_EXP 25
2657: PUSH
2658: LD_VAR 0 3
2662: ADD
2663: ST_TO_ADDR
// end ;
2664: GO 2614
2666: POP
2667: POP
// end ; end_of_file
2668: LD_VAR 0 1
2672: RET
// export function Action ; var i , veh ; begin
2673: LD_INT 0
2675: PPUSH
2676: PPUSH
2677: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2678: LD_EXP 24
2682: PPUSH
2683: LD_INT 0
2685: PPUSH
2686: LD_INT 50
2688: PPUSH
2689: LD_INT 38
2691: PPUSH
2692: LD_INT 2
2694: PPUSH
2695: CALL_OW 145
// InGameOn ;
2699: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2703: LD_INT 43
2705: PPUSH
2706: LD_INT 9
2708: PPUSH
2709: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2713: LD_EXP 19
2717: PPUSH
2718: LD_INT 54
2720: PPUSH
2721: LD_INT 34
2723: PPUSH
2724: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2728: LD_EXP 19
2732: PPUSH
2733: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_EXP 24
2746: PUSH
2747: LD_INT 1
2749: ARRAY
2750: PPUSH
2751: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2755: LD_INT 35
2757: PPUSH
2758: CALL_OW 67
// until See ( 4 , JMM ) ;
2762: LD_INT 4
2764: PPUSH
2765: LD_EXP 19
2769: PPUSH
2770: CALL_OW 292
2774: IFFALSE 2755
// CenterNowOnUnits ( JMM ) ;
2776: LD_EXP 19
2780: PPUSH
2781: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2785: LD_EXP 19
2789: PPUSH
2790: LD_STRING D2-JMM-1
2792: PPUSH
2793: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2797: LD_EXP 24
2801: PUSH
2802: LD_INT 3
2804: ARRAY
2805: PPUSH
2806: LD_EXP 19
2810: PPUSH
2811: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2815: LD_EXP 24
2819: PUSH
2820: LD_INT 3
2822: ARRAY
2823: PPUSH
2824: LD_STRING D2-Eng1-1
2826: PPUSH
2827: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2831: LD_EXP 19
2835: PPUSH
2836: LD_STRING D2-JMM-2
2838: PPUSH
2839: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2843: LD_EXP 24
2847: PUSH
2848: LD_INT 3
2850: ARRAY
2851: PPUSH
2852: LD_STRING D2-Eng1-2
2854: PPUSH
2855: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2859: LD_EXP 19
2863: PPUSH
2864: LD_STRING D2-JMM-3
2866: PPUSH
2867: CALL_OW 88
// if Houten then
2871: LD_EXP 23
2875: IFFALSE 3073
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2877: LD_ADDR_VAR 0 3
2881: PUSH
2882: LD_INT 4
2884: PPUSH
2885: LD_INT 1
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: LD_INT 2
2893: PPUSH
2894: LD_INT 1
2896: PPUSH
2897: LD_INT 4
2899: PPUSH
2900: LD_INT 55
2902: PPUSH
2903: CALL 289 0 7
2907: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2908: LD_VAR 0 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2920: LD_VAR 0 3
2924: PPUSH
2925: LD_INT 46
2927: PPUSH
2928: LD_INT 19
2930: PPUSH
2931: LD_INT 0
2933: PPUSH
2934: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2938: LD_EXP 23
2942: PPUSH
2943: LD_VAR 0 3
2947: PPUSH
2948: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2952: LD_EXP 23
2956: PPUSH
2957: LD_INT 49
2959: PPUSH
2960: LD_INT 33
2962: PPUSH
2963: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2967: LD_EXP 23
2971: PPUSH
2972: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2976: LD_EXP 23
2980: PPUSH
2981: LD_EXP 19
2985: PPUSH
2986: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2990: LD_INT 35
2992: PPUSH
2993: CALL_OW 67
// until See ( 1 , Houten ) ;
2997: LD_INT 1
2999: PPUSH
3000: LD_EXP 23
3004: PPUSH
3005: CALL_OW 292
3009: IFFALSE 2990
// ComTurnUnit ( JMM , Houten ) ;
3011: LD_EXP 19
3015: PPUSH
3016: LD_EXP 23
3020: PPUSH
3021: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3025: LD_EXP 19
3029: PPUSH
3030: LD_STRING D1d-JMM-1
3032: PPUSH
3033: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3037: LD_EXP 23
3041: PPUSH
3042: LD_STRING D1-VanH-1
3044: PPUSH
3045: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3049: LD_EXP 19
3053: PPUSH
3054: LD_STRING D1-JMM-1v
3056: PPUSH
3057: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3061: LD_EXP 19
3065: PPUSH
3066: LD_STRING D1-JMM-2v
3068: PPUSH
3069: CALL_OW 88
// end ; InGameOff ;
3073: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3077: LD_STRING M1
3079: PPUSH
3080: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3084: LD_INT 22
3086: PUSH
3087: LD_INT 4
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 92
3096: PUSH
3097: LD_EXP 19
3101: PPUSH
3102: CALL_OW 250
3106: PUSH
3107: LD_EXP 19
3111: PPUSH
3112: CALL_OW 251
3116: PUSH
3117: LD_INT 15
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PPUSH
3130: CALL_OW 69
3134: PPUSH
3135: LD_INT 1
3137: PPUSH
3138: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3142: LD_EXP 24
3146: PUSH
3147: LD_EXP 19
3151: ADD
3152: PUSH
3153: LD_EXP 23
3157: ADD
3158: PPUSH
3159: CALL_OW 141
// end ;
3163: LD_VAR 0 1
3167: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3168: LD_INT 1
3170: PPUSH
3171: LD_EXP 20
3175: PPUSH
3176: CALL_OW 292
3180: PUSH
3181: LD_EXP 19
3185: PPUSH
3186: LD_EXP 20
3190: PPUSH
3191: CALL_OW 296
3195: PUSH
3196: LD_INT 6
3198: LESS
3199: AND
3200: IFFALSE 4073
3202: GO 3204
3204: DISABLE
3205: LD_INT 0
3207: PPUSH
3208: PPUSH
3209: PPUSH
3210: PPUSH
3211: PPUSH
// begin InGameOn ;
3212: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3216: LD_INT 22
3218: PUSH
3219: LD_INT 4
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PPUSH
3226: CALL_OW 69
3230: PPUSH
3231: LD_INT 1
3233: PPUSH
3234: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3238: LD_ADDR_VAR 0 4
3242: PUSH
3243: LD_INT 22
3245: PUSH
3246: LD_INT 1
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 2
3255: PUSH
3256: LD_INT 25
3258: PUSH
3259: LD_INT 1
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 25
3268: PUSH
3269: LD_INT 2
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 25
3278: PUSH
3279: LD_INT 3
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: PUSH
3286: LD_INT 25
3288: PUSH
3289: LD_INT 4
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: ST_TO_ADDR
// ComHold ( tmp ) ;
3312: LD_VAR 0 4
3316: PPUSH
3317: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3321: LD_EXP 19
3325: PPUSH
3326: LD_STRING D2-JMM-3a
3328: PPUSH
3329: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3333: LD_EXP 20
3337: PPUSH
3338: LD_EXP 19
3342: PPUSH
3343: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3347: LD_EXP 20
3351: PPUSH
3352: LD_STRING D2-Gary-3
3354: PPUSH
3355: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3359: LD_EXP 19
3363: PPUSH
3364: LD_EXP 20
3368: PPUSH
3369: CALL_OW 119
// for i in tmp do
3373: LD_ADDR_VAR 0 5
3377: PUSH
3378: LD_VAR 0 4
3382: PUSH
3383: FOR_IN
3384: IFFALSE 3429
// begin if IsInUnit ( i ) then
3386: LD_VAR 0 5
3390: PPUSH
3391: CALL_OW 310
3395: IFFALSE 3406
// ComExitBuilding ( i ) ;
3397: LD_VAR 0 5
3401: PPUSH
3402: CALL_OW 122
// wait ( 1 ) ;
3406: LD_INT 1
3408: PPUSH
3409: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3413: LD_VAR 0 5
3417: PPUSH
3418: LD_EXP 19
3422: PPUSH
3423: CALL_OW 119
// end ;
3427: GO 3383
3429: POP
3430: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3431: LD_ADDR_VAR 0 4
3435: PUSH
3436: LD_VAR 0 4
3440: PUSH
3441: LD_EXP 19
3445: PUSH
3446: LD_EXP 23
3450: PUSH
3451: LD_EXP 20
3455: PUSH
3456: LD_EXP 22
3460: PUSH
3461: LD_EXP 21
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_EXP 24
3477: ADD
3478: DIFF
3479: ST_TO_ADDR
// if Bobby then
3480: LD_EXP 21
3484: IFFALSE 3498
// Say ( Bobby , D2-Bobby-3 ) ;
3486: LD_EXP 21
3490: PPUSH
3491: LD_STRING D2-Bobby-3
3493: PPUSH
3494: CALL_OW 88
// if Cyrus then
3498: LD_EXP 22
3502: IFFALSE 3516
// Say ( Cyrus , D2-Cyrus-3 ) ;
3504: LD_EXP 22
3508: PPUSH
3509: LD_STRING D2-Cyrus-3
3511: PPUSH
3512: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3516: LD_EXP 19
3520: PPUSH
3521: LD_STRING D2-JMM-4
3523: PPUSH
3524: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3528: LD_EXP 20
3532: PPUSH
3533: LD_STRING D2-Gary-4
3535: PPUSH
3536: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3540: LD_ADDR_VAR 0 1
3544: PUSH
3545: LD_VAR 0 4
3549: PPUSH
3550: LD_INT 26
3552: PUSH
3553: LD_INT 1
3555: PUSH
3556: EMPTY
3557: LIST
3558: LIST
3559: PPUSH
3560: CALL_OW 72
3564: PUSH
3565: LD_INT 1
3567: ARRAY
3568: ST_TO_ADDR
// if Cyrus then
3569: LD_EXP 22
3573: IFFALSE 3589
// Say ( Cyrus , D2-Cyrus-4 ) else
3575: LD_EXP 22
3579: PPUSH
3580: LD_STRING D2-Cyrus-4
3582: PPUSH
3583: CALL_OW 88
3587: GO 3601
// Say ( un1 , D2-Sol1-4 ) ;
3589: LD_VAR 0 1
3593: PPUSH
3594: LD_STRING D2-Sol1-4
3596: PPUSH
3597: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3601: LD_EXP 19
3605: PPUSH
3606: LD_STRING D2-JMM-5
3608: PPUSH
3609: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_EXP 24
3622: PPUSH
3623: LD_INT 91
3625: PUSH
3626: LD_EXP 19
3630: PUSH
3631: LD_INT 10
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 26
3641: PUSH
3642: LD_INT 2
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 72
3657: ST_TO_ADDR
// if un2 then
3658: LD_VAR 0 2
3662: IFFALSE 3716
// begin un2 := un2 [ un2 ] ;
3664: LD_ADDR_VAR 0 2
3668: PUSH
3669: LD_VAR 0 2
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3680: LD_VAR 0 2
3684: PPUSH
3685: LD_STRING D2-FEng1-5
3687: PPUSH
3688: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3692: LD_EXP 19
3696: PPUSH
3697: LD_STRING D2-JMM-6
3699: PPUSH
3700: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3704: LD_VAR 0 2
3708: PPUSH
3709: LD_STRING D2-FEng1-6
3711: PPUSH
3712: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3716: LD_ADDR_VAR 0 3
3720: PUSH
3721: LD_EXP 24
3725: PPUSH
3726: LD_INT 91
3728: PUSH
3729: LD_EXP 19
3733: PUSH
3734: LD_INT 10
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 26
3744: PUSH
3745: LD_INT 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 72
3760: ST_TO_ADDR
// if un3 then
3761: LD_VAR 0 3
3765: IFFALSE 3820
// begin un3 := un3 [ 1 ] ;
3767: LD_ADDR_VAR 0 3
3771: PUSH
3772: LD_VAR 0 3
3776: PUSH
3777: LD_INT 1
3779: ARRAY
3780: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3781: LD_VAR 0 3
3785: PPUSH
3786: LD_INT 114
3788: PPUSH
3789: LD_INT 122
3791: PPUSH
3792: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3796: LD_VAR 0 3
3800: PPUSH
3801: LD_STRING D2-Eng1-6
3803: PPUSH
3804: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3808: LD_EXP 19
3812: PPUSH
3813: LD_STRING D2-JMM-7
3815: PPUSH
3816: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3820: LD_EXP 20
3824: PPUSH
3825: LD_STRING D2-Gary-7
3827: PPUSH
3828: CALL_OW 88
// if un2 then
3832: LD_VAR 0 2
3836: IFFALSE 3850
// Say ( un2 , D2-FEng1-7 ) ;
3838: LD_VAR 0 2
3842: PPUSH
3843: LD_STRING D2-FEng1-7
3845: PPUSH
3846: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3850: LD_VAR 0 1
3854: PPUSH
3855: LD_STRING D2-Sol1-7
3857: PPUSH
3858: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3862: LD_EXP 19
3866: PPUSH
3867: LD_STRING D2-JMM-8
3869: PPUSH
3870: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3874: LD_INT 22
3876: PUSH
3877: LD_INT 1
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 69
3888: PPUSH
3889: CALL_OW 141
// InGameOff ;
3893: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3897: LD_STRING M1a
3899: PPUSH
3900: CALL_OW 337
// jmm_in_ovsyenko := true ;
3904: LD_ADDR_EXP 4
3908: PUSH
3909: LD_INT 1
3911: ST_TO_ADDR
// if debug then
3912: LD_EXP 2
3916: IFFALSE 4022
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
3918: LD_INT 22
3920: PUSH
3921: LD_INT 1
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PUSH
3928: LD_INT 30
3930: PUSH
3931: LD_INT 0
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PPUSH
3942: CALL_OW 69
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PPUSH
3951: CALL_OW 274
3955: PPUSH
3956: LD_INT 2
3958: PPUSH
3959: LD_INT 1000
3961: PPUSH
3962: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 30
3978: PUSH
3979: LD_INT 0
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PPUSH
3990: CALL_OW 69
3994: PUSH
3995: LD_INT 1
3997: ARRAY
3998: PPUSH
3999: CALL_OW 274
4003: PPUSH
4004: LD_INT 1
4006: PPUSH
4007: LD_INT 1000
4009: PPUSH
4010: CALL_OW 277
// ar_can_arrive := true ;
4014: LD_ADDR_EXP 10
4018: PUSH
4019: LD_INT 1
4021: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4022: LD_INT 1050
4024: PPUSH
4025: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4029: LD_ADDR_VAR 0 4
4033: PUSH
4034: LD_INT 25
4036: PUSH
4037: LD_INT 14
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: PPUSH
4044: CALL_OW 69
4048: ST_TO_ADDR
// if not tmp then
4049: LD_VAR 0 4
4053: NOT
4054: IFFALSE 4058
// exit ;
4056: GO 4073
// ComMoveXY ( tmp , 75 , 75 ) ;
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_INT 75
4065: PPUSH
4066: LD_INT 75
4068: PPUSH
4069: CALL_OW 111
// end ;
4073: PPOPN 5
4075: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4076: LD_INT 22
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 30
4088: PUSH
4089: LD_INT 30
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 3
4098: PUSH
4099: LD_INT 57
4101: PUSH
4102: EMPTY
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: IFFALSE 4160
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4126: LD_ADDR_VAR 0 1
4130: PUSH
4131: LD_STRING M2easy
4133: PUSH
4134: LD_STRING M2
4136: PUSH
4137: LD_STRING M2hard
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4145: LD_VAR 0 1
4149: PUSH
4150: LD_OWVAR 67
4154: ARRAY
4155: PPUSH
4156: CALL_OW 337
// end ;
4160: PPOPN 1
4162: END
// every 3 3$00 do
4163: GO 4165
4165: DISABLE
// begin DialogueOn ;
4166: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4170: LD_EXP 26
4174: PPUSH
4175: LD_STRING D3-Pow-1
4177: PPUSH
4178: CALL_OW 94
// if jmm_in_ovsyenko then
4182: LD_EXP 4
4186: IFFALSE 4214
// begin Say ( JMM , D3-JMM-1 ) ;
4188: LD_EXP 19
4192: PPUSH
4193: LD_STRING D3-JMM-1
4195: PPUSH
4196: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4200: LD_EXP 19
4204: PPUSH
4205: LD_STRING D3-JMM-1b
4207: PPUSH
4208: CALL_OW 88
// end else
4212: GO 4226
// Say ( JMM , D3-JMM-1a ) ;
4214: LD_EXP 19
4218: PPUSH
4219: LD_STRING D3-JMM-1a
4221: PPUSH
4222: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4226: LD_EXP 26
4230: PPUSH
4231: LD_STRING D3-Pow-2
4233: PPUSH
4234: CALL_OW 94
// DialogueOff ;
4238: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4242: LD_STRING M3
4244: PPUSH
4245: CALL_OW 337
// powell_want_sib := true ;
4249: LD_ADDR_EXP 5
4253: PUSH
4254: LD_INT 1
4256: ST_TO_ADDR
// end ;
4257: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4258: LD_EXP 6
4262: PUSH
4263: LD_INT 0
4265: EQUAL
4266: IFFALSE 5713
4268: GO 4270
4270: DISABLE
4271: LD_INT 0
4273: PPUSH
4274: PPUSH
4275: PPUSH
4276: PPUSH
4277: PPUSH
4278: PPUSH
4279: PPUSH
4280: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4281: LD_INT 4
4283: PPUSH
4284: LD_INT 1
4286: PPUSH
4287: CALL_OW 343
// PowellTransport ;
4291: CALL 2509 0 0
// for i = 1 to 3 do
4295: LD_ADDR_VAR 0 4
4299: PUSH
4300: DOUBLE
4301: LD_INT 1
4303: DEC
4304: ST_TO_ADDR
4305: LD_INT 3
4307: PUSH
4308: FOR_TO
4309: IFFALSE 4376
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4311: LD_ADDR_VAR 0 1
4315: PUSH
4316: LD_INT 6
4318: PPUSH
4319: LD_VAR 0 4
4323: PPUSH
4324: CALL_OW 287
4328: ST_TO_ADDR
// if not tmp then
4329: LD_VAR 0 1
4333: NOT
4334: IFFALSE 4338
// continue ;
4336: GO 4308
// EraseResourceArea ( terminalArea , i ) ;
4338: LD_INT 6
4340: PPUSH
4341: LD_VAR 0 4
4345: PPUSH
4346: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4350: LD_EXP 3
4354: PPUSH
4355: CALL_OW 274
4359: PPUSH
4360: LD_VAR 0 4
4364: PPUSH
4365: LD_VAR 0 1
4369: PPUSH
4370: CALL_OW 276
// end ;
4374: GO 4308
4376: POP
4377: POP
// x := 43 ;
4378: LD_ADDR_VAR 0 2
4382: PUSH
4383: LD_INT 43
4385: ST_TO_ADDR
// y := 3 ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_INT 3
4393: ST_TO_ADDR
// for i = 3 to 4 do
4394: LD_ADDR_VAR 0 4
4398: PUSH
4399: DOUBLE
4400: LD_INT 3
4402: DEC
4403: ST_TO_ADDR
4404: LD_INT 4
4406: PUSH
4407: FOR_TO
4408: IFFALSE 4599
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4410: LD_EXP 25
4414: PUSH
4415: LD_VAR 0 4
4419: ARRAY
4420: PPUSH
4421: LD_INT 4
4423: PPUSH
4424: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4428: LD_EXP 25
4432: PUSH
4433: LD_VAR 0 4
4437: ARRAY
4438: PPUSH
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_VAR 0 3
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4456: LD_EXP 25
4460: PUSH
4461: LD_VAR 0 4
4465: PUSH
4466: LD_INT 2
4468: MINUS
4469: ARRAY
4470: PPUSH
4471: LD_EXP 25
4475: PUSH
4476: LD_VAR 0 4
4480: ARRAY
4481: PPUSH
4482: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4486: LD_EXP 25
4490: PUSH
4491: LD_VAR 0 4
4495: ARRAY
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 100
4502: PPUSH
4503: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4507: LD_EXP 25
4511: PUSH
4512: LD_VAR 0 4
4516: PUSH
4517: LD_INT 2
4519: MINUS
4520: ARRAY
4521: PPUSH
4522: LD_INT 54
4524: PPUSH
4525: LD_INT 42
4527: PPUSH
4528: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4532: LD_EXP 25
4536: PUSH
4537: LD_VAR 0 4
4541: PUSH
4542: LD_INT 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: LD_EXP 3
4551: PPUSH
4552: CALL_OW 250
4556: PPUSH
4557: LD_EXP 3
4561: PPUSH
4562: CALL_OW 251
4566: PPUSH
4567: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4571: LD_EXP 25
4575: PUSH
4576: LD_VAR 0 4
4580: PUSH
4581: LD_INT 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 200
// Wait ( 0 0$02 ) ;
4590: LD_INT 70
4592: PPUSH
4593: CALL_OW 67
// end ;
4597: GO 4407
4599: POP
4600: POP
// time := 0 0$20 ;
4601: LD_ADDR_VAR 0 8
4605: PUSH
4606: LD_INT 700
4608: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4609: LD_INT 35
4611: PPUSH
4612: CALL_OW 67
// time := time - 0 0$01 ;
4616: LD_ADDR_VAR 0 8
4620: PUSH
4621: LD_VAR 0 8
4625: PUSH
4626: LD_INT 35
4628: MINUS
4629: ST_TO_ADDR
// for i = 3 to 4 do
4630: LD_ADDR_VAR 0 4
4634: PUSH
4635: DOUBLE
4636: LD_INT 3
4638: DEC
4639: ST_TO_ADDR
4640: LD_INT 4
4642: PUSH
4643: FOR_TO
4644: IFFALSE 4779
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4646: LD_EXP 25
4650: PUSH
4651: LD_VAR 0 4
4655: ARRAY
4656: PPUSH
4657: LD_INT 1
4659: PPUSH
4660: CALL_OW 289
4664: PUSH
4665: LD_INT 0
4667: GREATER
4668: PUSH
4669: LD_EXP 25
4673: PUSH
4674: LD_VAR 0 4
4678: ARRAY
4679: PPUSH
4680: CALL_OW 314
4684: NOT
4685: AND
4686: IFFALSE 4777
// begin x := rand ( 0 , 5 ) ;
4688: LD_ADDR_VAR 0 2
4692: PUSH
4693: LD_INT 0
4695: PPUSH
4696: LD_INT 5
4698: PPUSH
4699: CALL_OW 12
4703: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4704: LD_EXP 25
4708: PUSH
4709: LD_VAR 0 4
4713: ARRAY
4714: PPUSH
4715: LD_EXP 25
4719: PUSH
4720: LD_VAR 0 4
4724: ARRAY
4725: PPUSH
4726: CALL_OW 250
4730: PPUSH
4731: LD_VAR 0 2
4735: PPUSH
4736: LD_INT 3
4738: PPUSH
4739: CALL_OW 272
4743: PPUSH
4744: LD_EXP 25
4748: PUSH
4749: LD_VAR 0 4
4753: ARRAY
4754: PPUSH
4755: CALL_OW 251
4759: PPUSH
4760: LD_VAR 0 2
4764: PPUSH
4765: LD_INT 3
4767: PPUSH
4768: CALL_OW 273
4772: PPUSH
4773: CALL_OW 171
// end ;
4777: GO 4643
4779: POP
4780: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4781: LD_EXP 25
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_INT 54
4792: PPUSH
4793: LD_INT 42
4795: PPUSH
4796: CALL_OW 297
4800: PUSH
4801: LD_INT 4
4803: LESS
4804: PUSH
4805: LD_VAR 0 8
4809: PUSH
4810: LD_INT 0
4812: EQUAL
4813: OR
4814: IFFALSE 4609
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4816: LD_EXP 25
4820: PUSH
4821: LD_INT 3
4823: ARRAY
4824: PPUSH
4825: LD_INT 1
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4835: LD_EXP 25
4839: PUSH
4840: LD_INT 4
4842: ARRAY
4843: PPUSH
4844: LD_INT 1
4846: PPUSH
4847: LD_INT 0
4849: PPUSH
4850: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4854: LD_EXP 3
4858: PPUSH
4859: CALL_OW 274
4863: PPUSH
4864: LD_INT 1
4866: PPUSH
4867: LD_INT 200
4869: PPUSH
4870: CALL_OW 276
// DialogueOn ;
4874: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4878: LD_INT 53
4880: PPUSH
4881: LD_INT 35
4883: PPUSH
4884: CALL_OW 86
// un := powell_trans [ 1 ] ;
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_EXP 25
4897: PUSH
4898: LD_INT 1
4900: ARRAY
4901: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4902: LD_VAR 0 5
4906: PPUSH
4907: LD_STRING D4-Mech1-1
4909: PPUSH
4910: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4914: LD_EXP 19
4918: PPUSH
4919: LD_STRING D4-JMM-1
4921: PPUSH
4922: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4926: LD_VAR 0 5
4930: PPUSH
4931: LD_STRING D4-Mech1-2
4933: PPUSH
4934: CALL_OW 88
// powell_happy := false ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_INT 0
4945: ST_TO_ADDR
// take_cargo := false ;
4946: LD_ADDR_VAR 0 7
4950: PUSH
4951: LD_INT 0
4953: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4954: CALL 809 0 0
4958: PUSH
4959: LD_INT 60
4961: GREATEREQUAL
4962: IFFALSE 5010
// begin Say ( JMM , D5-JMM-1 ) ;
4964: LD_EXP 19
4968: PPUSH
4969: LD_STRING D5-JMM-1
4971: PPUSH
4972: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4976: LD_VAR 0 5
4980: PPUSH
4981: LD_STRING D6-Mech1-1
4983: PPUSH
4984: CALL_OW 88
// powell_happy := true ;
4988: LD_ADDR_VAR 0 6
4992: PUSH
4993: LD_INT 1
4995: ST_TO_ADDR
// take_cargo := true ;
4996: LD_ADDR_VAR 0 7
5000: PUSH
5001: LD_INT 1
5003: ST_TO_ADDR
// DialogueOff ;
5004: CALL_OW 7
// end else
5008: GO 5244
// if GetTerminalCargo > 0 then
5010: CALL 809 0 0
5014: PUSH
5015: LD_INT 0
5017: GREATER
5018: IFFALSE 5216
// begin case Query ( QWait ) of 1 :
5020: LD_STRING QWait
5022: PPUSH
5023: CALL_OW 97
5027: PUSH
5028: LD_INT 1
5030: DOUBLE
5031: EQUAL
5032: IFTRUE 5036
5034: GO 5127
5036: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5037: LD_EXP 19
5041: PPUSH
5042: LD_STRING D5b-JMM-1
5044: PPUSH
5045: CALL_OW 88
// DialogueOff ;
5049: CALL_OW 7
// wait ( 5 5$00 ) ;
5053: LD_INT 10500
5055: PPUSH
5056: CALL_OW 67
// if GetTerminalCargo < 60 then
5060: CALL 809 0 0
5064: PUSH
5065: LD_INT 60
5067: LESS
5068: IFFALSE 5109
// begin DialogueOn ;
5070: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5074: LD_EXP 3
5078: PPUSH
5079: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5083: LD_VAR 0 5
5087: PPUSH
5088: LD_STRING D6-Mech1-1a
5090: PPUSH
5091: CALL_OW 88
// DialogueOff ;
5095: CALL_OW 7
// powell_happy := false ;
5099: LD_ADDR_VAR 0 6
5103: PUSH
5104: LD_INT 0
5106: ST_TO_ADDR
// end else
5107: GO 5125
// begin powell_happy := true ;
5109: LD_ADDR_VAR 0 6
5113: PUSH
5114: LD_INT 1
5116: ST_TO_ADDR
// take_cargo := true ;
5117: LD_ADDR_VAR 0 7
5121: PUSH
5122: LD_INT 1
5124: ST_TO_ADDR
// end ; end ; 2 :
5125: GO 5214
5127: LD_INT 2
5129: DOUBLE
5130: EQUAL
5131: IFTRUE 5135
5133: GO 5174
5135: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5136: LD_EXP 19
5140: PPUSH
5141: LD_STRING D5b-JMM-1
5143: PPUSH
5144: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5148: LD_VAR 0 5
5152: PPUSH
5153: LD_STRING D6-Mech1-1a
5155: PPUSH
5156: CALL_OW 88
// DialogueOff ;
5160: CALL_OW 7
// take_cargo := true ;
5164: LD_ADDR_VAR 0 7
5168: PUSH
5169: LD_INT 1
5171: ST_TO_ADDR
// end ; 3 :
5172: GO 5214
5174: LD_INT 3
5176: DOUBLE
5177: EQUAL
5178: IFTRUE 5182
5180: GO 5213
5182: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5183: LD_EXP 19
5187: PPUSH
5188: LD_STRING D5c-JMM-1
5190: PPUSH
5191: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D6-Mech1-1b
5202: PPUSH
5203: CALL_OW 88
// DialogueOff ;
5207: CALL_OW 7
// end ; end ;
5211: GO 5214
5213: POP
// end else
5214: GO 5244
// begin Say ( JMM , D5c-JMM-1 ) ;
5216: LD_EXP 19
5220: PPUSH
5221: LD_STRING D5c-JMM-1
5223: PPUSH
5224: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5228: LD_VAR 0 5
5232: PPUSH
5233: LD_STRING D6-Mech1-1b
5235: PPUSH
5236: CALL_OW 88
// DialogueOff ;
5240: CALL_OW 7
// end ; if take_cargo then
5244: LD_VAR 0 7
5248: IFFALSE 5327
// begin x := GetTerminalCargo ;
5250: LD_ADDR_VAR 0 2
5254: PUSH
5255: CALL 809 0 0
5259: ST_TO_ADDR
// if x > 60 then
5260: LD_VAR 0 2
5264: PUSH
5265: LD_INT 60
5267: GREATER
5268: IFFALSE 5278
// x := 60 ;
5270: LD_ADDR_VAR 0 2
5274: PUSH
5275: LD_INT 60
5277: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5278: LD_EXP 3
5282: PPUSH
5283: CALL_OW 274
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 809 0 0
5295: PUSH
5296: LD_VAR 0 2
5300: MINUS
5301: PPUSH
5302: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5306: LD_EXP 25
5310: PUSH
5311: LD_INT 3
5313: ARRAY
5314: PPUSH
5315: LD_INT 3
5317: PPUSH
5318: LD_VAR 0 2
5322: PPUSH
5323: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5327: LD_EXP 25
5331: PPUSH
5332: LD_INT 43
5334: PPUSH
5335: LD_INT 3
5337: PPUSH
5338: CALL_OW 171
// x := 0 0$20 ;
5342: LD_ADDR_VAR 0 2
5346: PUSH
5347: LD_INT 700
5349: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5350: LD_INT 35
5352: PPUSH
5353: CALL_OW 67
// x := x - 0 0$01 ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_VAR 0 2
5366: PUSH
5367: LD_INT 35
5369: MINUS
5370: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5371: LD_VAR 0 2
5375: PUSH
5376: LD_INT 0
5378: EQUAL
5379: PUSH
5380: LD_EXP 25
5384: PUSH
5385: LD_INT 3
5387: ARRAY
5388: PPUSH
5389: LD_INT 43
5391: PPUSH
5392: LD_INT 3
5394: PPUSH
5395: CALL_OW 297
5399: PUSH
5400: LD_INT 4
5402: LESS
5403: PUSH
5404: LD_EXP 25
5408: PUSH
5409: LD_INT 3
5411: ARRAY
5412: PPUSH
5413: LD_INT 43
5415: PPUSH
5416: LD_INT 3
5418: PPUSH
5419: CALL_OW 297
5423: PUSH
5424: LD_INT 4
5426: LESS
5427: AND
5428: OR
5429: IFFALSE 5350
// for i in powell_trans do
5431: LD_ADDR_VAR 0 4
5435: PUSH
5436: LD_EXP 25
5440: PUSH
5441: FOR_IN
5442: IFFALSE 5455
// RemoveUnit ( i ) ;
5444: LD_VAR 0 4
5448: PPUSH
5449: CALL_OW 64
5453: GO 5441
5455: POP
5456: POP
// if not powell_happy then
5457: LD_VAR 0 6
5461: NOT
5462: IFFALSE 5473
// powell_happy := - 1 ;
5464: LD_ADDR_VAR 0 6
5468: PUSH
5469: LD_INT 1
5471: NEG
5472: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5473: LD_STRING EarlySiberite
5475: PPUSH
5476: LD_VAR 0 6
5480: PPUSH
5481: CALL_OW 101
// if powell_happy then
5485: LD_VAR 0 6
5489: IFFALSE 5500
// ChangeMissionObjectives ( M3a ) else
5491: LD_STRING M3a
5493: PPUSH
5494: CALL_OW 337
5498: GO 5507
// ChangeMissionObjectives ( M3b ) ;
5500: LD_STRING M3b
5502: PPUSH
5503: CALL_OW 337
// ru_can_attack_terminal := true ;
5507: LD_ADDR_EXP 9
5511: PUSH
5512: LD_INT 1
5514: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5515: LD_INT 25200
5517: PPUSH
5518: CALL_OW 67
// time := 2 2$00 ;
5522: LD_ADDR_VAR 0 8
5526: PUSH
5527: LD_INT 4200
5529: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5530: LD_INT 35
5532: PPUSH
5533: CALL_OW 67
// time := time - 0 0$1 ;
5537: LD_ADDR_VAR 0 8
5541: PUSH
5542: LD_VAR 0 8
5546: PUSH
5547: LD_INT 35
5549: MINUS
5550: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5551: LD_EXP 8
5555: NOT
5556: PUSH
5557: LD_EXP 36
5561: PUSH
5562: LD_INT 0
5564: EQUAL
5565: OR
5566: PUSH
5567: LD_VAR 0 8
5571: PUSH
5572: LD_INT 0
5574: EQUAL
5575: OR
5576: IFFALSE 5530
// if ru_force then
5578: LD_EXP 36
5582: IFFALSE 5681
// for i in ru_force do
5584: LD_ADDR_VAR 0 4
5588: PUSH
5589: LD_EXP 36
5593: PUSH
5594: FOR_IN
5595: IFFALSE 5679
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5597: LD_INT 1
5599: PPUSH
5600: LD_VAR 0 4
5604: PPUSH
5605: CALL_OW 292
5609: NOT
5610: PUSH
5611: LD_VAR 0 4
5615: PPUSH
5616: LD_INT 81
5618: PUSH
5619: LD_INT 3
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: PPUSH
5631: LD_VAR 0 4
5635: PPUSH
5636: CALL_OW 74
5640: PPUSH
5641: CALL_OW 296
5645: PUSH
5646: LD_INT 10
5648: GREATER
5649: AND
5650: IFFALSE 5677
// begin RemoveUnit ( i ) ;
5652: LD_VAR 0 4
5656: PPUSH
5657: CALL_OW 64
// ru_force := ru_force diff i ;
5661: LD_ADDR_EXP 36
5665: PUSH
5666: LD_EXP 36
5670: PUSH
5671: LD_VAR 0 4
5675: DIFF
5676: ST_TO_ADDR
// end ;
5677: GO 5594
5679: POP
5680: POP
// repeat wait ( 0 0$03 ) ;
5681: LD_INT 105
5683: PPUSH
5684: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5688: LD_EXP 8
5692: NOT
5693: PUSH
5694: LD_EXP 36
5698: PUSH
5699: LD_INT 3
5701: LESS
5702: OR
5703: IFFALSE 5681
// ar_can_arrive := true ;
5705: LD_ADDR_EXP 10
5709: PUSH
5710: LD_INT 1
5712: ST_TO_ADDR
// end ;
5713: PPOPN 8
5715: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5716: LD_INT 1
5718: PPUSH
5719: LD_INT 20
5721: PPUSH
5722: CALL_OW 325
5726: IFFALSE 5867
5728: GO 5730
5730: DISABLE
5731: LD_INT 0
5733: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: LD_INT 22
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: LD_INT 1
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 25
5761: PUSH
5762: LD_INT 4
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 69
5778: PUSH
5779: LD_EXP 19
5783: PUSH
5784: LD_EXP 22
5788: PUSH
5789: LD_EXP 21
5793: PUSH
5794: LD_EXP 23
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: DIFF
5805: ST_TO_ADDR
// if not un then
5806: LD_VAR 0 1
5810: NOT
5811: IFFALSE 5815
// exit ;
5813: GO 5867
// DialogueOn ;
5815: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5819: LD_VAR 0 1
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: LD_STRING D13-Sci1-1
5830: PPUSH
5831: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5835: LD_EXP 19
5839: PPUSH
5840: LD_STRING D13-JMM-1
5842: PPUSH
5843: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5847: LD_VAR 0 1
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PPUSH
5856: LD_STRING D13-Sci1-2
5858: PPUSH
5859: CALL_OW 88
// DialogueOff ;
5863: CALL_OW 7
// end ;
5867: PPOPN 1
5869: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5870: LD_INT 1
5872: PPUSH
5873: CALL 840 0 1
5877: PUSH
5878: LD_INT 77
5880: GREATER
5881: PUSH
5882: LD_EXP 8
5886: NOT
5887: AND
5888: PUSH
5889: LD_INT 22
5891: PUSH
5892: LD_INT 1
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 25
5901: PUSH
5902: LD_INT 4
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: LD_INT 26
5911: PUSH
5912: LD_INT 1
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: PPUSH
5924: CALL_OW 69
5928: PUSH
5929: LD_EXP 19
5933: PUSH
5934: LD_EXP 21
5938: PUSH
5939: LD_EXP 22
5943: PUSH
5944: LD_EXP 20
5948: PUSH
5949: LD_EXP 23
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: DIFF
5961: AND
5962: IFFALSE 6140
5964: GO 5966
5966: DISABLE
5967: LD_INT 0
5969: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5970: LD_ADDR_VAR 0 1
5974: PUSH
5975: LD_INT 22
5977: PUSH
5978: LD_INT 1
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 25
5987: PUSH
5988: LD_INT 4
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: PUSH
6015: LD_EXP 19
6019: PUSH
6020: LD_EXP 21
6024: PUSH
6025: LD_EXP 22
6029: PUSH
6030: LD_EXP 20
6034: PUSH
6035: LD_EXP 23
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: DIFF
6047: ST_TO_ADDR
// DialogueOn ;
6048: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6052: LD_VAR 0 1
6056: PUSH
6057: LD_INT 1
6059: ARRAY
6060: PPUSH
6061: LD_STRING D7-Sci1-1
6063: PPUSH
6064: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6068: LD_EXP 19
6072: PPUSH
6073: LD_STRING D7-JMM-1
6075: PPUSH
6076: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6080: LD_VAR 0 1
6084: PUSH
6085: LD_INT 1
6087: ARRAY
6088: PPUSH
6089: LD_STRING D7-Sci1-2
6091: PPUSH
6092: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6096: LD_EXP 19
6100: PPUSH
6101: LD_STRING D7-JMM-2
6103: PPUSH
6104: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6108: LD_VAR 0 1
6112: PUSH
6113: LD_INT 1
6115: ARRAY
6116: PPUSH
6117: LD_STRING D7-Sci1-3
6119: PPUSH
6120: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6124: LD_EXP 19
6128: PPUSH
6129: LD_STRING D7-JMM-3
6131: PPUSH
6132: CALL_OW 88
// DialogueOff ;
6136: CALL_OW 7
// end ;
6140: PPOPN 1
6142: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates ;
6143: LD_EXP 10
6147: IFFALSE 9652
6149: GO 6151
6151: DISABLE
6152: LD_INT 0
6154: PPUSH
6155: PPUSH
6156: PPUSH
6157: PPUSH
6158: PPUSH
6159: PPUSH
6160: PPUSH
6161: PPUSH
6162: PPUSH
// begin PrepareArabian ;
6163: CALL 12248 0 0
// blocked := false ;
6167: LD_ADDR_EXP 18
6171: PUSH
6172: LD_INT 0
6174: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6175: LD_INT 35
6177: PPUSH
6178: CALL_OW 67
// until ar_spawned ;
6182: LD_EXP 11
6186: IFFALSE 6175
// have_crates := true ;
6188: LD_ADDR_VAR 0 9
6192: PUSH
6193: LD_INT 1
6195: ST_TO_ADDR
// DialogueOn ;
6196: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6200: LD_EXP 27
6204: PPUSH
6205: LD_STRING D8-Ar1-1
6207: PPUSH
6208: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6212: LD_EXP 19
6216: PPUSH
6217: LD_STRING D8-JMM-1
6219: PPUSH
6220: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6224: LD_EXP 27
6228: PPUSH
6229: LD_STRING D8-Ar1-2
6231: PPUSH
6232: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6236: LD_EXP 19
6240: PPUSH
6241: LD_STRING D8-JMM-2
6243: PPUSH
6244: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6248: LD_EXP 27
6252: PPUSH
6253: LD_STRING D8-Ar1-3
6255: PPUSH
6256: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6260: LD_EXP 19
6264: PPUSH
6265: LD_STRING D8-JMM-3
6267: PPUSH
6268: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6272: LD_EXP 27
6276: PPUSH
6277: LD_STRING D8-Ar1-4
6279: PPUSH
6280: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6284: LD_EXP 19
6288: PPUSH
6289: LD_STRING D8-JMM-4
6291: PPUSH
6292: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6296: LD_EXP 27
6300: PPUSH
6301: LD_STRING D8-Ar1-5
6303: PPUSH
6304: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6308: LD_EXP 19
6312: PPUSH
6313: LD_STRING D8-JMM-5
6315: PPUSH
6316: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6320: LD_EXP 27
6324: PPUSH
6325: LD_STRING D8-Ar1-6
6327: PPUSH
6328: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6332: LD_EXP 28
6336: PPUSH
6337: LD_STRING D8-Ar2-6
6339: PPUSH
6340: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6344: LD_EXP 19
6348: PPUSH
6349: LD_STRING D8-JMM-6
6351: PPUSH
6352: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6356: LD_EXP 28
6360: PPUSH
6361: LD_STRING D8-Ar2-7
6363: PPUSH
6364: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6368: LD_STRING QBarracks
6370: PPUSH
6371: CALL_OW 97
6375: PUSH
6376: LD_INT 1
6378: DOUBLE
6379: EQUAL
6380: IFTRUE 6384
6382: GO 6419
6384: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6385: LD_EXP 19
6389: PPUSH
6390: LD_STRING D8a-JMM-1
6392: PPUSH
6393: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6397: LD_EXP 27
6401: PPUSH
6402: LD_STRING D8a-Ar1-1
6404: PPUSH
6405: CALL_OW 94
// player_want_mortar := true ;
6409: LD_ADDR_EXP 12
6413: PUSH
6414: LD_INT 1
6416: ST_TO_ADDR
// end ; 2 :
6417: GO 6577
6419: LD_INT 2
6421: DOUBLE
6422: EQUAL
6423: IFTRUE 6427
6425: GO 6541
6427: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6428: LD_EXP 19
6432: PPUSH
6433: LD_STRING D8b-JMM-1
6435: PPUSH
6436: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6440: LD_EXP 27
6444: PPUSH
6445: LD_STRING D8b-Ar1-1
6447: PPUSH
6448: CALL_OW 94
// case Query ( QInfo ) of 1 :
6452: LD_STRING QInfo
6454: PPUSH
6455: CALL_OW 97
6459: PUSH
6460: LD_INT 1
6462: DOUBLE
6463: EQUAL
6464: IFTRUE 6468
6466: GO 6503
6468: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6469: LD_EXP 19
6473: PPUSH
6474: LD_STRING D8b1-JMM-1
6476: PPUSH
6477: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6481: LD_EXP 27
6485: PPUSH
6486: LD_STRING D8b1-Ar1-1
6488: PPUSH
6489: CALL_OW 94
// player_want_info := 2 ;
6493: LD_ADDR_EXP 13
6497: PUSH
6498: LD_INT 2
6500: ST_TO_ADDR
// end ; 2 :
6501: GO 6539
6503: LD_INT 2
6505: DOUBLE
6506: EQUAL
6507: IFTRUE 6511
6509: GO 6538
6511: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6512: LD_EXP 19
6516: PPUSH
6517: LD_STRING D8b2-JMM-1
6519: PPUSH
6520: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6524: LD_EXP 27
6528: PPUSH
6529: LD_STRING D8b2-Ar1-1
6531: PPUSH
6532: CALL_OW 94
// end ; end ;
6536: GO 6539
6538: POP
// end ; 3 :
6539: GO 6577
6541: LD_INT 3
6543: DOUBLE
6544: EQUAL
6545: IFTRUE 6549
6547: GO 6576
6549: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6550: LD_EXP 19
6554: PPUSH
6555: LD_STRING D8c-JMM-1
6557: PPUSH
6558: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6562: LD_EXP 27
6566: PPUSH
6567: LD_STRING D8c-Ar1-1
6569: PPUSH
6570: CALL_OW 94
// end ; end ;
6574: GO 6577
6576: POP
// DialogueOff ;
6577: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6581: LD_ADDR_VAR 0 4
6585: PUSH
6586: LD_INT 9
6588: PPUSH
6589: LD_INT 2
6591: PUSH
6592: LD_INT 30
6594: PUSH
6595: LD_INT 0
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 30
6604: PUSH
6605: LD_INT 1
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: PPUSH
6617: CALL_OW 70
6621: ST_TO_ADDR
// if dep then
6622: LD_VAR 0 4
6626: IFFALSE 6642
// dep := dep [ 1 ] ;
6628: LD_ADDR_VAR 0 4
6632: PUSH
6633: LD_VAR 0 4
6637: PUSH
6638: LD_INT 1
6640: ARRAY
6641: ST_TO_ADDR
// if not dep then
6642: LD_VAR 0 4
6646: NOT
6647: IFFALSE 6685
// begin case Query ( QInfoNothing ) of 1 :
6649: LD_STRING QInfoNothing
6651: PPUSH
6652: CALL_OW 97
6656: PUSH
6657: LD_INT 1
6659: DOUBLE
6660: EQUAL
6661: IFTRUE 6665
6663: GO 6668
6665: POP
// ; end ;
6666: GO 6669
6668: POP
// player_want_info := false ;
6669: LD_ADDR_EXP 13
6673: PUSH
6674: LD_INT 0
6676: ST_TO_ADDR
// player_want_mortar := false ;
6677: LD_ADDR_EXP 12
6681: PUSH
6682: LD_INT 0
6684: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: LD_INT 22
6692: PUSH
6693: LD_INT 2
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: PUSH
6700: LD_INT 21
6702: PUSH
6703: LD_INT 2
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PPUSH
6714: CALL_OW 69
6718: ST_TO_ADDR
// time := 1 1$35 ;
6719: LD_ADDR_VAR 0 5
6723: PUSH
6724: LD_INT 3325
6726: ST_TO_ADDR
// no_oil_gain := false ;
6727: LD_ADDR_VAR 0 6
6731: PUSH
6732: LD_INT 0
6734: ST_TO_ADDR
// first_warn := false ;
6735: LD_ADDR_VAR 0 7
6739: PUSH
6740: LD_INT 0
6742: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6743: LD_EXP 12
6747: PUSH
6748: LD_EXP 13
6752: OR
6753: IFFALSE 6858
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6755: LD_EXP 34
6759: PPUSH
6760: LD_INT 25
6762: PUSH
6763: LD_INT 1
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: PPUSH
6770: CALL_OW 72
6774: PPUSH
6775: LD_VAR 0 4
6779: PPUSH
6780: CALL_OW 250
6784: PPUSH
6785: LD_VAR 0 4
6789: PPUSH
6790: CALL_OW 251
6794: PPUSH
6795: LD_VAR 0 4
6799: PPUSH
6800: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6804: LD_EXP 34
6808: PPUSH
6809: LD_INT 25
6811: PUSH
6812: LD_INT 1
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: PPUSH
6824: LD_INT 86
6826: PPUSH
6827: LD_INT 121
6829: PPUSH
6830: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6834: LD_EXP 34
6838: PPUSH
6839: LD_INT 25
6841: PUSH
6842: LD_INT 1
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PPUSH
6849: CALL_OW 72
6853: PPUSH
6854: CALL_OW 200
// end ; if player_attacked_ar then
6858: LD_EXP 16
6862: IFFALSE 6866
// exit ;
6864: GO 9652
// if player_want_mortar then
6866: LD_EXP 12
6870: IFFALSE 8298
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6872: LD_EXP 28
6876: PPUSH
6877: LD_VAR 0 4
6881: PPUSH
6882: CALL_OW 250
6886: PUSH
6887: LD_INT 1
6889: PLUS
6890: PPUSH
6891: LD_VAR 0 4
6895: PPUSH
6896: CALL_OW 251
6900: PUSH
6901: LD_INT 1
6903: PLUS
6904: PPUSH
6905: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6909: LD_INT 35
6911: PPUSH
6912: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6916: LD_EXP 28
6920: PPUSH
6921: LD_VAR 0 4
6925: PPUSH
6926: CALL_OW 296
6930: PUSH
6931: LD_INT 4
6933: LESS
6934: IFFALSE 6909
// for i = 1 to 6 do
6936: LD_ADDR_VAR 0 1
6940: PUSH
6941: DOUBLE
6942: LD_INT 1
6944: DEC
6945: ST_TO_ADDR
6946: LD_INT 6
6948: PUSH
6949: FOR_TO
6950: IFFALSE 7154
// begin if player_attacked_ar then
6952: LD_EXP 16
6956: IFFALSE 6962
// exit ;
6958: POP
6959: POP
6960: GO 9652
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6962: LD_VAR 0 4
6966: PPUSH
6967: CALL_OW 274
6971: PPUSH
6972: LD_INT 2
6974: PPUSH
6975: CALL_OW 275
6979: PUSH
6980: LD_INT 10
6982: LESS
6983: PUSH
6984: LD_VAR 0 7
6988: NOT
6989: AND
6990: IFFALSE 7053
// begin first_warn := true ;
6992: LD_ADDR_VAR 0 7
6996: PUSH
6997: LD_INT 1
6999: ST_TO_ADDR
// DialogueOn ;
7000: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7004: LD_EXP 29
7008: PPUSH
7009: LD_STRING D9a-FAr1-1
7011: PPUSH
7012: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7016: LD_EXP 19
7020: PPUSH
7021: LD_STRING D9a-JMM-1
7023: PPUSH
7024: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7028: LD_EXP 27
7032: PPUSH
7033: LD_STRING D9a2-Ar1-1
7035: PPUSH
7036: CALL_OW 88
// DialogueOff ;
7040: CALL_OW 7
// wait ( time ) ;
7044: LD_VAR 0 5
7048: PPUSH
7049: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7053: LD_VAR 0 4
7057: PPUSH
7058: CALL_OW 274
7062: PPUSH
7063: LD_INT 2
7065: PPUSH
7066: CALL_OW 275
7070: PUSH
7071: LD_INT 10
7073: LESS
7074: IFFALSE 7100
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7076: LD_EXP 27
7080: PPUSH
7081: LD_STRING D9a3-Ar1-1
7083: PPUSH
7084: CALL_OW 88
// no_oil_gain := true ;
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 1
7095: ST_TO_ADDR
// break ;
7096: GO 7154
// end else
7098: GO 7152
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7100: LD_EXP 28
7104: PPUSH
7105: LD_VAR 0 4
7109: PPUSH
7110: LD_INT 2
7112: PPUSH
7113: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7117: LD_EXP 28
7121: PPUSH
7122: LD_VAR 0 3
7126: PUSH
7127: LD_VAR 0 1
7131: PUSH
7132: LD_INT 3
7134: MOD
7135: PUSH
7136: LD_INT 1
7138: PLUS
7139: ARRAY
7140: PPUSH
7141: CALL_OW 210
// wait ( 0 0$10 ) ;
7145: LD_INT 350
7147: PPUSH
7148: CALL_OW 67
// end ; end ;
7152: GO 6949
7154: POP
7155: POP
// if not no_oil_gain then
7156: LD_VAR 0 6
7160: NOT
7161: IFFALSE 8298
// begin repeat wait ( 0 0$01 ) ;
7163: LD_INT 35
7165: PPUSH
7166: CALL_OW 67
// if player_attacked_ar then
7170: LD_EXP 16
7174: IFFALSE 7178
// exit ;
7176: GO 9652
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7178: LD_VAR 0 3
7182: PUSH
7183: LD_INT 1
7185: ARRAY
7186: PPUSH
7187: CALL_OW 261
7191: PUSH
7192: LD_INT 80
7194: GREATER
7195: PUSH
7196: LD_VAR 0 3
7200: PUSH
7201: LD_INT 2
7203: ARRAY
7204: PPUSH
7205: CALL_OW 261
7209: PUSH
7210: LD_INT 80
7212: GREATER
7213: AND
7214: PUSH
7215: LD_VAR 0 3
7219: PUSH
7220: LD_INT 3
7222: ARRAY
7223: PPUSH
7224: CALL_OW 261
7228: PUSH
7229: LD_INT 80
7231: GREATER
7232: AND
7233: IFFALSE 7163
// ComMoveXY ( Gali , 105 , 127 ) ;
7235: LD_EXP 28
7239: PPUSH
7240: LD_INT 105
7242: PPUSH
7243: LD_INT 127
7245: PPUSH
7246: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7250: LD_EXP 28
7254: PPUSH
7255: LD_INT 2
7257: PPUSH
7258: CALL_OW 173
// AddComHold ( Gali ) ;
7262: LD_EXP 28
7266: PPUSH
7267: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7271: LD_INT 35
7273: PPUSH
7274: CALL_OW 67
// if player_attacked_ar then
7278: LD_EXP 16
7282: IFFALSE 7286
// exit ;
7284: GO 9652
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7286: LD_EXP 28
7290: PPUSH
7291: LD_INT 105
7293: PPUSH
7294: LD_INT 127
7296: PPUSH
7297: CALL_OW 297
7301: PUSH
7302: LD_INT 4
7304: LESS
7305: IFFALSE 7271
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7307: LD_VAR 0 4
7311: PPUSH
7312: CALL_OW 274
7316: PPUSH
7317: LD_INT 1
7319: PPUSH
7320: CALL_OW 275
7324: PUSH
7325: LD_INT 50
7327: LESS
7328: IFFALSE 7630
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7330: LD_VAR 0 4
7334: PPUSH
7335: CALL_OW 274
7339: PPUSH
7340: LD_INT 1
7342: PPUSH
7343: CALL_OW 275
7347: PUSH
7348: LD_INT 0
7350: DOUBLE
7351: GREATEREQUAL
7352: IFFALSE 7360
7354: LD_INT 24
7356: DOUBLE
7357: LESSEQUAL
7358: IFTRUE 7362
7360: GO 7377
7362: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7363: LD_EXP 28
7367: PPUSH
7368: LD_STRING D9b-Ar2-1
7370: PPUSH
7371: CALL_OW 88
7375: GO 7407
7377: LD_INT 25
7379: DOUBLE
7380: GREATEREQUAL
7381: IFFALSE 7389
7383: LD_INT 49
7385: DOUBLE
7386: LESSEQUAL
7387: IFTRUE 7391
7389: GO 7406
7391: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7392: LD_EXP 28
7396: PPUSH
7397: LD_STRING D9b-Ar2-1a
7399: PPUSH
7400: CALL_OW 88
7404: GO 7407
7406: POP
// Say ( JMM , D9b-JMM-1 ) ;
7407: LD_EXP 19
7411: PPUSH
7412: LD_STRING D9b-JMM-1
7414: PPUSH
7415: CALL_OW 88
// x := 0 0$0 ;
7419: LD_ADDR_VAR 0 2
7423: PUSH
7424: LD_INT 0
7426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7427: LD_INT 35
7429: PPUSH
7430: CALL_OW 67
// x := x + 0 0$1 ;
7434: LD_ADDR_VAR 0 2
7438: PUSH
7439: LD_VAR 0 2
7443: PUSH
7444: LD_INT 35
7446: PLUS
7447: ST_TO_ADDR
// if player_attacked_ar then
7448: LD_EXP 16
7452: IFFALSE 7456
// exit ;
7454: GO 9652
// until x >= time ;
7456: LD_VAR 0 2
7460: PUSH
7461: LD_VAR 0 5
7465: GREATEREQUAL
7466: IFFALSE 7427
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7468: LD_VAR 0 4
7472: PPUSH
7473: CALL_OW 274
7477: PPUSH
7478: LD_INT 1
7480: PPUSH
7481: CALL_OW 275
7485: PUSH
7486: LD_INT 50
7488: LESS
7489: IFFALSE 7630
// begin have_crates := false ;
7491: LD_ADDR_VAR 0 9
7495: PUSH
7496: LD_INT 0
7498: ST_TO_ADDR
// DialogueOn ;
7499: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7503: LD_EXP 27
7507: PPUSH
7508: LD_STRING D9c-Ar1-1
7510: PPUSH
7511: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7515: LD_EXP 19
7519: PPUSH
7520: LD_STRING D9c-JMM-1
7522: PPUSH
7523: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7527: LD_EXP 27
7531: PPUSH
7532: LD_STRING D9c-Ar1-2
7534: PPUSH
7535: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7539: LD_EXP 29
7543: PPUSH
7544: LD_STRING D9c-FAr1-2
7546: PPUSH
7547: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7551: LD_EXP 27
7555: PPUSH
7556: LD_STRING D9c-Ar1-3
7558: PPUSH
7559: CALL_OW 88
// case Query ( QInfo ) of 1 :
7563: LD_STRING QInfo
7565: PPUSH
7566: CALL_OW 97
7570: PUSH
7571: LD_INT 1
7573: DOUBLE
7574: EQUAL
7575: IFTRUE 7579
7577: GO 7602
7579: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7580: LD_EXP 19
7584: PPUSH
7585: LD_STRING D8b1-JMM-1
7587: PPUSH
7588: CALL_OW 88
// player_want_info := 2 ;
7592: LD_ADDR_EXP 13
7596: PUSH
7597: LD_INT 2
7599: ST_TO_ADDR
// end ; 2 :
7600: GO 7626
7602: LD_INT 2
7604: DOUBLE
7605: EQUAL
7606: IFTRUE 7610
7608: GO 7625
7610: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7611: LD_EXP 27
7615: PPUSH
7616: LD_STRING D8b2-Ar1-1
7618: PPUSH
7619: CALL_OW 88
// end ; end ;
7623: GO 7626
7625: POP
// DialogueOff ;
7626: CALL_OW 7
// end ; end ; if have_crates then
7630: LD_VAR 0 9
7634: IFFALSE 8298
// begin RemoveEnvironmentArea ( mortarArea ) ;
7636: LD_INT 2
7638: PPUSH
7639: CALL_OW 355
// wait ( 1 ) ;
7643: LD_INT 1
7645: PPUSH
7646: CALL_OW 67
// InGameOn ;
7650: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7654: LD_EXP 28
7658: PPUSH
7659: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7663: LD_EXP 28
7667: PPUSH
7668: LD_INT 1
7670: PPUSH
7671: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7675: LD_EXP 28
7679: PPUSH
7680: LD_INT 4
7682: PPUSH
7683: LD_INT 107
7685: PPUSH
7686: LD_INT 131
7688: PPUSH
7689: LD_INT 0
7691: PPUSH
7692: CALL_OW 145
// repeat wait ( 1 ) ;
7696: LD_INT 1
7698: PPUSH
7699: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7703: LD_INT 30
7705: PUSH
7706: LD_INT 4
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 23
7715: PUSH
7716: LD_INT 2
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PPUSH
7727: CALL_OW 69
7731: IFFALSE 7696
// SetSide ( Gali , 2 ) ;
7733: LD_EXP 28
7737: PPUSH
7738: LD_INT 2
7740: PPUSH
7741: CALL_OW 235
// InGameOff ;
7745: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7749: LD_ADDR_VAR 0 8
7753: PUSH
7754: LD_INT 30
7756: PUSH
7757: LD_INT 4
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 23
7766: PUSH
7767: LD_INT 2
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: PPUSH
7778: CALL_OW 69
7782: PUSH
7783: LD_INT 1
7785: ARRAY
7786: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7787: LD_INT 35
7789: PPUSH
7790: CALL_OW 67
// if player_attacked_ar then
7794: LD_EXP 16
7798: IFFALSE 7802
// exit ;
7800: GO 9652
// until BuildingStatus ( b ) <> bs_build ;
7802: LD_VAR 0 8
7806: PPUSH
7807: CALL_OW 461
7811: PUSH
7812: LD_INT 1
7814: NONEQUAL
7815: IFFALSE 7787
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7817: LD_VAR 0 8
7821: PPUSH
7822: CALL_OW 302
7826: PUSH
7827: LD_VAR 0 4
7831: PPUSH
7832: CALL_OW 274
7836: PPUSH
7837: LD_INT 1
7839: PPUSH
7840: CALL_OW 275
7844: PUSH
7845: LD_INT 25
7847: GREATEREQUAL
7848: AND
7849: IFFALSE 7948
// begin ComUpgrade ( b ) ;
7851: LD_VAR 0 8
7855: PPUSH
7856: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7860: LD_EXP 28
7864: PPUSH
7865: LD_STRING h
7867: PUSH
7868: LD_VAR 0 8
7872: PPUSH
7873: CALL_OW 250
7877: PUSH
7878: LD_VAR 0 8
7882: PPUSH
7883: CALL_OW 251
7887: PUSH
7888: LD_VAR 0 8
7892: PUSH
7893: LD_INT 0
7895: PUSH
7896: LD_INT 0
7898: PUSH
7899: LD_INT 0
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: LIST
7907: LIST
7908: LIST
7909: LIST
7910: PUSH
7911: EMPTY
7912: LIST
7913: PPUSH
7914: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7918: LD_INT 35
7920: PPUSH
7921: CALL_OW 67
// if player_attacked_ar then
7925: LD_EXP 16
7929: IFFALSE 7933
// exit ;
7931: GO 9652
// until BuildingStatus ( b ) <> bs_build ;
7933: LD_VAR 0 8
7937: PPUSH
7938: CALL_OW 461
7942: PUSH
7943: LD_INT 1
7945: NONEQUAL
7946: IFFALSE 7918
// end ; if b then
7948: LD_VAR 0 8
7952: IFFALSE 7963
// CenterNowOnUnits ( b ) ;
7954: LD_VAR 0 8
7958: PPUSH
7959: CALL_OW 87
// DialogueOn ;
7963: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7967: LD_EXP 28
7971: PPUSH
7972: LD_STRING D9d-Ar2-1
7974: PPUSH
7975: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7979: LD_EXP 27
7983: PPUSH
7984: LD_STRING D9d-Ar1-1
7986: PPUSH
7987: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7991: LD_EXP 19
7995: PPUSH
7996: LD_STRING D9d-JMM-1
7998: PPUSH
7999: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8003: LD_EXP 27
8007: PPUSH
8008: LD_STRING D9d-Ar1-2
8010: PPUSH
8011: CALL_OW 88
// DialogueOff ;
8015: CALL_OW 7
// i := [ ] ;
8019: LD_ADDR_VAR 0 1
8023: PUSH
8024: EMPTY
8025: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8026: LD_VAR 0 4
8030: PPUSH
8031: CALL_OW 274
8035: PPUSH
8036: LD_INT 3
8038: PPUSH
8039: CALL_OW 275
8043: PUSH
8044: LD_INT 20
8046: GREATEREQUAL
8047: IFFALSE 8066
// i := i ^ [ 1 ] ;
8049: LD_ADDR_VAR 0 1
8053: PUSH
8054: LD_VAR 0 1
8058: PUSH
8059: LD_INT 1
8061: PUSH
8062: EMPTY
8063: LIST
8064: ADD
8065: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8066: LD_VAR 0 4
8070: PPUSH
8071: CALL_OW 274
8075: PPUSH
8076: LD_INT 1
8078: PPUSH
8079: CALL_OW 275
8083: PUSH
8084: LD_INT 50
8086: GREATEREQUAL
8087: IFFALSE 8106
// i := i ^ [ 2 ] ;
8089: LD_ADDR_VAR 0 1
8093: PUSH
8094: LD_VAR 0 1
8098: PUSH
8099: LD_INT 2
8101: PUSH
8102: EMPTY
8103: LIST
8104: ADD
8105: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8106: LD_VAR 0 4
8110: PPUSH
8111: CALL_OW 274
8115: PPUSH
8116: LD_INT 2
8118: PPUSH
8119: CALL_OW 275
8123: PUSH
8124: LD_INT 80
8126: GREATEREQUAL
8127: IFFALSE 8146
// i := i ^ [ 3 ] ;
8129: LD_ADDR_VAR 0 1
8133: PUSH
8134: LD_VAR 0 1
8138: PUSH
8139: LD_INT 3
8141: PUSH
8142: EMPTY
8143: LIST
8144: ADD
8145: ST_TO_ADDR
// i := i diff 0 ;
8146: LD_ADDR_VAR 0 1
8150: PUSH
8151: LD_VAR 0 1
8155: PUSH
8156: LD_INT 0
8158: DIFF
8159: ST_TO_ADDR
// if i then
8160: LD_VAR 0 1
8164: IFFALSE 8270
// begin i := i ^ [ 4 ] ;
8166: LD_ADDR_VAR 0 1
8170: PUSH
8171: LD_VAR 0 1
8175: PUSH
8176: LD_INT 4
8178: PUSH
8179: EMPTY
8180: LIST
8181: ADD
8182: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8183: LD_STRING QInfo2
8185: PPUSH
8186: CALL_OW 97
8190: PUSH
8191: LD_INT 1
8193: DOUBLE
8194: EQUAL
8195: IFTRUE 8199
8197: GO 8210
8199: POP
// player_want_info := 3 ; 2 :
8200: LD_ADDR_EXP 13
8204: PUSH
8205: LD_INT 3
8207: ST_TO_ADDR
8208: GO 8268
8210: LD_INT 2
8212: DOUBLE
8213: EQUAL
8214: IFTRUE 8218
8216: GO 8229
8218: POP
// player_want_info := 1 ; 3 :
8219: LD_ADDR_EXP 13
8223: PUSH
8224: LD_INT 1
8226: ST_TO_ADDR
8227: GO 8268
8229: LD_INT 3
8231: DOUBLE
8232: EQUAL
8233: IFTRUE 8237
8235: GO 8248
8237: POP
// player_want_info := 2 ; 4 :
8238: LD_ADDR_EXP 13
8242: PUSH
8243: LD_INT 2
8245: ST_TO_ADDR
8246: GO 8268
8248: LD_INT 4
8250: DOUBLE
8251: EQUAL
8252: IFTRUE 8256
8254: GO 8267
8256: POP
// player_want_info := 0 ; end ;
8257: LD_ADDR_EXP 13
8261: PUSH
8262: LD_INT 0
8264: ST_TO_ADDR
8265: GO 8268
8267: POP
// end else
8268: GO 8298
// case Query ( QInfoNothing ) of 1 :
8270: LD_STRING QInfoNothing
8272: PPUSH
8273: CALL_OW 97
8277: PUSH
8278: LD_INT 1
8280: DOUBLE
8281: EQUAL
8282: IFTRUE 8286
8284: GO 8297
8286: POP
// player_want_info := 0 ; end ;
8287: LD_ADDR_EXP 13
8291: PUSH
8292: LD_INT 0
8294: ST_TO_ADDR
8295: GO 8298
8297: POP
// end ; end ; end ; if player_want_info then
8298: LD_EXP 13
8302: IFFALSE 9472
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8304: LD_ADDR_VAR 0 3
8308: PUSH
8309: LD_VAR 0 3
8313: PPUSH
8314: LD_INT 34
8316: PUSH
8317: LD_INT 32
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: PPUSH
8324: CALL_OW 72
8328: ST_TO_ADDR
// if player_want_mortar then
8329: LD_EXP 12
8333: IFFALSE 8704
// begin case player_want_info of 1 :
8335: LD_EXP 13
8339: PUSH
8340: LD_INT 1
8342: DOUBLE
8343: EQUAL
8344: IFTRUE 8348
8346: GO 8359
8348: POP
// x := 5 ; 2 :
8349: LD_ADDR_VAR 0 2
8353: PUSH
8354: LD_INT 5
8356: ST_TO_ADDR
8357: GO 8398
8359: LD_INT 2
8361: DOUBLE
8362: EQUAL
8363: IFTRUE 8367
8365: GO 8378
8367: POP
// x := 8 ; 3 :
8368: LD_ADDR_VAR 0 2
8372: PUSH
8373: LD_INT 8
8375: ST_TO_ADDR
8376: GO 8398
8378: LD_INT 3
8380: DOUBLE
8381: EQUAL
8382: IFTRUE 8386
8384: GO 8397
8386: POP
// x := 2 ; end ;
8387: LD_ADDR_VAR 0 2
8391: PUSH
8392: LD_INT 2
8394: ST_TO_ADDR
8395: GO 8398
8397: POP
// repeat wait ( 0 0$1 ) ;
8398: LD_INT 35
8400: PPUSH
8401: CALL_OW 67
// until not HasTask ( Gali ) ;
8405: LD_EXP 28
8409: PPUSH
8410: CALL_OW 314
8414: NOT
8415: IFFALSE 8398
// for i = 1 to x do
8417: LD_ADDR_VAR 0 1
8421: PUSH
8422: DOUBLE
8423: LD_INT 1
8425: DEC
8426: ST_TO_ADDR
8427: LD_VAR 0 2
8431: PUSH
8432: FOR_TO
8433: IFFALSE 8647
// begin time := 0 0$00 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_INT 0
8442: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8443: LD_INT 35
8445: PPUSH
8446: CALL_OW 67
// time := time + 0 0$1 ;
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: LD_VAR 0 5
8459: PUSH
8460: LD_INT 35
8462: PLUS
8463: ST_TO_ADDR
// if time > 1 1$00 then
8464: LD_VAR 0 5
8468: PUSH
8469: LD_INT 2100
8471: GREATER
8472: IFFALSE 8486
// begin blocked := true ;
8474: LD_ADDR_EXP 18
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// exit ;
8482: POP
8483: POP
8484: GO 9652
// end ; if not Carry ( Gali ) then
8486: LD_EXP 28
8490: PPUSH
8491: CALL_OW 281
8495: NOT
8496: IFFALSE 8519
// ComTransport ( Gali , dep , player_want_info ) else
8498: LD_EXP 28
8502: PPUSH
8503: LD_VAR 0 4
8507: PPUSH
8508: LD_EXP 13
8512: PPUSH
8513: CALL_OW 151
8517: GO 8537
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8519: LD_EXP 28
8523: PPUSH
8524: LD_VAR 0 3
8528: PUSH
8529: LD_INT 1
8531: ARRAY
8532: PPUSH
8533: CALL_OW 112
// if player_attacked_ar then
8537: LD_EXP 16
8541: IFFALSE 8547
// exit ;
8543: POP
8544: POP
8545: GO 9652
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8547: LD_EXP 28
8551: PPUSH
8552: LD_VAR 0 3
8556: PUSH
8557: LD_INT 1
8559: ARRAY
8560: PPUSH
8561: CALL_OW 296
8565: PUSH
8566: LD_INT 4
8568: LESS
8569: PUSH
8570: LD_EXP 28
8574: PPUSH
8575: LD_EXP 13
8579: PPUSH
8580: CALL_OW 289
8584: AND
8585: IFFALSE 8443
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8587: LD_VAR 0 3
8591: PUSH
8592: LD_INT 1
8594: ARRAY
8595: PPUSH
8596: LD_EXP 13
8600: PPUSH
8601: LD_VAR 0 3
8605: PUSH
8606: LD_INT 1
8608: ARRAY
8609: PPUSH
8610: LD_EXP 13
8614: PPUSH
8615: CALL_OW 289
8619: PUSH
8620: LD_INT 10
8622: PLUS
8623: PPUSH
8624: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8628: LD_EXP 28
8632: PPUSH
8633: LD_EXP 13
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 290
// end ;
8645: GO 8432
8647: POP
8648: POP
// repeat wait ( 0 0$1 ) ;
8649: LD_INT 35
8651: PPUSH
8652: CALL_OW 67
// if player_attacked_ar then
8656: LD_EXP 16
8660: IFFALSE 8664
// exit ;
8662: GO 9652
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8664: LD_VAR 0 3
8668: PUSH
8669: LD_INT 1
8671: ARRAY
8672: PPUSH
8673: LD_EXP 13
8677: PPUSH
8678: CALL_OW 289
8682: PUSH
8683: LD_VAR 0 2
8687: PUSH
8688: LD_INT 10
8690: MUL
8691: EQUAL
8692: IFFALSE 8649
// no_oil_gain := false ;
8694: LD_ADDR_VAR 0 6
8698: PUSH
8699: LD_INT 0
8701: ST_TO_ADDR
// end else
8702: GO 9293
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_INT 22
8711: PUSH
8712: LD_INT 2
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: PUSH
8719: LD_INT 21
8721: PUSH
8722: LD_INT 2
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: PPUSH
8733: CALL_OW 69
8737: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8738: LD_EXP 28
8742: PPUSH
8743: LD_VAR 0 4
8747: PPUSH
8748: CALL_OW 250
8752: PUSH
8753: LD_INT 1
8755: PLUS
8756: PPUSH
8757: LD_VAR 0 4
8761: PPUSH
8762: CALL_OW 251
8766: PUSH
8767: LD_INT 1
8769: PLUS
8770: PPUSH
8771: CALL_OW 111
// time := 0 0$00 ;
8775: LD_ADDR_VAR 0 5
8779: PUSH
8780: LD_INT 0
8782: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8783: LD_INT 35
8785: PPUSH
8786: CALL_OW 67
// time := time + 0 0$1 ;
8790: LD_ADDR_VAR 0 5
8794: PUSH
8795: LD_VAR 0 5
8799: PUSH
8800: LD_INT 35
8802: PLUS
8803: ST_TO_ADDR
// if time > 0 0$45 then
8804: LD_VAR 0 5
8808: PUSH
8809: LD_INT 1575
8811: GREATER
8812: IFFALSE 8816
// break ;
8814: GO 8836
// until GetDistUnits ( Gali , dep ) < 4 ;
8816: LD_EXP 28
8820: PPUSH
8821: LD_VAR 0 4
8825: PPUSH
8826: CALL_OW 296
8830: PUSH
8831: LD_INT 4
8833: LESS
8834: IFFALSE 8783
// for i = 1 to 6 do
8836: LD_ADDR_VAR 0 1
8840: PUSH
8841: DOUBLE
8842: LD_INT 1
8844: DEC
8845: ST_TO_ADDR
8846: LD_INT 6
8848: PUSH
8849: FOR_TO
8850: IFFALSE 9054
// begin if player_attacked_ar then
8852: LD_EXP 16
8856: IFFALSE 8862
// exit ;
8858: POP
8859: POP
8860: GO 9652
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8862: LD_VAR 0 4
8866: PPUSH
8867: CALL_OW 274
8871: PPUSH
8872: LD_INT 2
8874: PPUSH
8875: CALL_OW 275
8879: PUSH
8880: LD_INT 10
8882: LESS
8883: PUSH
8884: LD_VAR 0 7
8888: NOT
8889: AND
8890: IFFALSE 8953
// begin first_warn := true ;
8892: LD_ADDR_VAR 0 7
8896: PUSH
8897: LD_INT 1
8899: ST_TO_ADDR
// DialogueOn ;
8900: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8904: LD_EXP 29
8908: PPUSH
8909: LD_STRING D9a-FAr1-1
8911: PPUSH
8912: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8916: LD_EXP 19
8920: PPUSH
8921: LD_STRING D9a-JMM-1
8923: PPUSH
8924: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8928: LD_EXP 27
8932: PPUSH
8933: LD_STRING D9a2-Ar1-1
8935: PPUSH
8936: CALL_OW 88
// DialogueOff ;
8940: CALL_OW 7
// wait ( time ) ;
8944: LD_VAR 0 5
8948: PPUSH
8949: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8953: LD_VAR 0 4
8957: PPUSH
8958: CALL_OW 274
8962: PPUSH
8963: LD_INT 2
8965: PPUSH
8966: CALL_OW 275
8970: PUSH
8971: LD_INT 10
8973: LESS
8974: IFFALSE 9000
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8976: LD_EXP 27
8980: PPUSH
8981: LD_STRING D9a3-Ar1-1
8983: PPUSH
8984: CALL_OW 88
// no_oil_gain := true ;
8988: LD_ADDR_VAR 0 6
8992: PUSH
8993: LD_INT 1
8995: ST_TO_ADDR
// break ;
8996: GO 9054
// end else
8998: GO 9052
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9000: LD_EXP 28
9004: PPUSH
9005: LD_VAR 0 4
9009: PPUSH
9010: LD_INT 2
9012: PPUSH
9013: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9017: LD_EXP 28
9021: PPUSH
9022: LD_VAR 0 3
9026: PUSH
9027: LD_VAR 0 1
9031: PUSH
9032: LD_INT 3
9034: MOD
9035: PUSH
9036: LD_INT 1
9038: PLUS
9039: ARRAY
9040: PPUSH
9041: CALL_OW 210
// wait ( 0 0$10 ) ;
9045: LD_INT 350
9047: PPUSH
9048: CALL_OW 67
// end ; end ;
9052: GO 8849
9054: POP
9055: POP
// time := 0 0$00 ;
9056: LD_ADDR_VAR 0 5
9060: PUSH
9061: LD_INT 0
9063: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9064: LD_INT 35
9066: PPUSH
9067: CALL_OW 67
// if not HasTask ( Gali ) then
9071: LD_EXP 28
9075: PPUSH
9076: CALL_OW 314
9080: NOT
9081: IFFALSE 9097
// time := time + 0 0$1 ;
9083: LD_ADDR_VAR 0 5
9087: PUSH
9088: LD_VAR 0 5
9092: PUSH
9093: LD_INT 35
9095: PLUS
9096: ST_TO_ADDR
// if time > 1 1$25 then
9097: LD_VAR 0 5
9101: PUSH
9102: LD_INT 2975
9104: GREATER
9105: IFFALSE 9129
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9107: LD_EXP 27
9111: PPUSH
9112: LD_STRING D9a3-Ar1-1
9114: PPUSH
9115: CALL_OW 88
// no_oil_gain := true ;
9119: LD_ADDR_VAR 0 6
9123: PUSH
9124: LD_INT 1
9126: ST_TO_ADDR
// break ;
9127: GO 9293
// end ; if player_attacked_ar then
9129: LD_EXP 16
9133: IFFALSE 9137
// exit ;
9135: GO 9652
// for i in tmp do
9137: LD_ADDR_VAR 0 1
9141: PUSH
9142: LD_VAR 0 3
9146: PUSH
9147: FOR_IN
9148: IFFALSE 9179
// if GetFuel ( i ) < 100 then
9150: LD_VAR 0 1
9154: PPUSH
9155: CALL_OW 261
9159: PUSH
9160: LD_INT 100
9162: LESS
9163: IFFALSE 9177
// begin x := i ;
9165: LD_ADDR_VAR 0 2
9169: PUSH
9170: LD_VAR 0 1
9174: ST_TO_ADDR
// break ;
9175: GO 9179
// end ;
9177: GO 9147
9179: POP
9180: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9181: LD_EXP 28
9185: PPUSH
9186: CALL_OW 314
9190: NOT
9191: PUSH
9192: LD_EXP 28
9196: PPUSH
9197: CALL_OW 281
9201: NOT
9202: AND
9203: IFFALSE 9236
// begin ComTransport ( Gali , dep , mat_oil ) ;
9205: LD_EXP 28
9209: PPUSH
9210: LD_VAR 0 4
9214: PPUSH
9215: LD_INT 2
9217: PPUSH
9218: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9222: LD_EXP 28
9226: PPUSH
9227: LD_VAR 0 2
9231: PPUSH
9232: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9236: LD_VAR 0 3
9240: PUSH
9241: LD_INT 1
9243: ARRAY
9244: PPUSH
9245: CALL_OW 261
9249: PUSH
9250: LD_INT 80
9252: GREATER
9253: PUSH
9254: LD_VAR 0 3
9258: PUSH
9259: LD_INT 2
9261: ARRAY
9262: PPUSH
9263: CALL_OW 261
9267: PUSH
9268: LD_INT 80
9270: GREATER
9271: AND
9272: PUSH
9273: LD_VAR 0 3
9277: PUSH
9278: LD_INT 3
9280: ARRAY
9281: PPUSH
9282: CALL_OW 261
9286: PUSH
9287: LD_INT 80
9289: GREATER
9290: AND
9291: IFFALSE 9064
// end ; ComHold ( Gali ) ;
9293: LD_EXP 28
9297: PPUSH
9298: CALL_OW 140
// if not no_oil_gain then
9302: LD_VAR 0 6
9306: NOT
9307: IFFALSE 9472
// begin DialogueOn ;
9309: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9313: LD_EXP 27
9317: PPUSH
9318: CALL_OW 87
// if player_want_mortar then
9322: LD_EXP 12
9326: IFFALSE 9352
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9328: LD_EXP 27
9332: PPUSH
9333: LD_STRING D9e-Ar1-1
9335: PPUSH
9336: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9340: LD_EXP 19
9344: PPUSH
9345: LD_STRING D10a-JMM-1
9347: PPUSH
9348: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9352: LD_EXP 27
9356: PPUSH
9357: LD_STRING D10a-Ar1-1
9359: PPUSH
9360: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9364: LD_EXP 28
9368: PPUSH
9369: LD_STRING D10a-Ar2-1
9371: PPUSH
9372: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9376: LD_EXP 29
9380: PPUSH
9381: LD_STRING D10a-FAr1-1
9383: PPUSH
9384: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9388: LD_EXP 28
9392: PPUSH
9393: LD_STRING D10a-Ar2-2
9395: PPUSH
9396: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9400: LD_EXP 29
9404: PPUSH
9405: LD_STRING D10a-FAr1-2
9407: PPUSH
9408: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9412: LD_EXP 27
9416: PPUSH
9417: LD_STRING D10a-Ar1-2
9419: PPUSH
9420: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9424: LD_EXP 19
9428: PPUSH
9429: LD_STRING D10a-JMM-2
9431: PPUSH
9432: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9436: LD_EXP 27
9440: PPUSH
9441: LD_STRING D10a-Ar1-3
9443: PPUSH
9444: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9448: LD_EXP 19
9452: PPUSH
9453: LD_STRING D10a-JMM-3
9455: PPUSH
9456: CALL_OW 88
// player_get_info := true ;
9460: LD_ADDR_EXP 15
9464: PUSH
9465: LD_INT 1
9467: ST_TO_ADDR
// DialogueOff ;
9468: CALL_OW 7
// end ; end ; if player_attacked_ar then
9472: LD_EXP 16
9476: IFFALSE 9480
// exit ;
9478: GO 9652
// if player_want_mortar or player_want_info then
9480: LD_EXP 12
9484: PUSH
9485: LD_EXP 13
9489: OR
9490: IFFALSE 9504
// Say ( Vervecken , D9f-Ar1-1 ) ;
9492: LD_EXP 27
9496: PPUSH
9497: LD_STRING D9f-Ar1-1
9499: PPUSH
9500: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9504: LD_INT 22
9506: PUSH
9507: LD_INT 2
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: PPUSH
9514: CALL_OW 69
9518: PPUSH
9519: LD_INT 51
9521: PPUSH
9522: LD_INT 99
9524: PPUSH
9525: CALL_OW 111
// wait ( 0 0$1 ) ;
9529: LD_INT 35
9531: PPUSH
9532: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9536: LD_INT 22
9538: PUSH
9539: LD_INT 2
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: PUSH
9546: LD_INT 92
9548: PUSH
9549: LD_INT 51
9551: PUSH
9552: LD_INT 99
9554: PUSH
9555: LD_INT 2
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PPUSH
9568: CALL_OW 69
9572: IFFALSE 9632
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9574: LD_ADDR_VAR 0 1
9578: PUSH
9579: LD_INT 22
9581: PUSH
9582: LD_INT 2
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: PUSH
9589: LD_INT 92
9591: PUSH
9592: LD_INT 51
9594: PUSH
9595: LD_INT 99
9597: PUSH
9598: LD_INT 2
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: PPUSH
9611: CALL_OW 69
9615: PUSH
9616: FOR_IN
9617: IFFALSE 9630
// RemoveUnit ( i ) ;
9619: LD_VAR 0 1
9623: PPUSH
9624: CALL_OW 64
9628: GO 9616
9630: POP
9631: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9632: LD_INT 22
9634: PUSH
9635: LD_INT 2
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: PPUSH
9642: CALL_OW 69
9646: PUSH
9647: LD_INT 0
9649: EQUAL
9650: IFFALSE 9504
// end ;
9652: PPOPN 9
9654: END
// every 0 0$01 trigger blocked do var i ;
9655: LD_EXP 18
9659: IFFALSE 9827
9661: GO 9663
9663: DISABLE
9664: LD_INT 0
9666: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9667: LD_EXP 27
9671: PPUSH
9672: LD_STRING D9f-Ar1-1
9674: PPUSH
9675: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9679: LD_INT 22
9681: PUSH
9682: LD_INT 2
9684: PUSH
9685: EMPTY
9686: LIST
9687: LIST
9688: PPUSH
9689: CALL_OW 69
9693: PPUSH
9694: LD_INT 51
9696: PPUSH
9697: LD_INT 99
9699: PPUSH
9700: CALL_OW 111
// wait ( 0 0$1 ) ;
9704: LD_INT 35
9706: PPUSH
9707: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9711: LD_INT 22
9713: PUSH
9714: LD_INT 2
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: PUSH
9721: LD_INT 92
9723: PUSH
9724: LD_INT 51
9726: PUSH
9727: LD_INT 99
9729: PUSH
9730: LD_INT 2
9732: PUSH
9733: EMPTY
9734: LIST
9735: LIST
9736: LIST
9737: LIST
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: PPUSH
9743: CALL_OW 69
9747: IFFALSE 9807
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9749: LD_ADDR_VAR 0 1
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 2
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 92
9766: PUSH
9767: LD_INT 51
9769: PUSH
9770: LD_INT 99
9772: PUSH
9773: LD_INT 2
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 69
9790: PUSH
9791: FOR_IN
9792: IFFALSE 9805
// RemoveUnit ( i ) ;
9794: LD_VAR 0 1
9798: PPUSH
9799: CALL_OW 64
9803: GO 9791
9805: POP
9806: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9807: LD_INT 22
9809: PUSH
9810: LD_INT 2
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PPUSH
9817: CALL_OW 69
9821: PUSH
9822: LD_INT 0
9824: EQUAL
9825: IFFALSE 9679
// end ;
9827: PPOPN 1
9829: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9830: LD_EXP 16
9834: IFFALSE 10187
9836: GO 9838
9838: DISABLE
9839: LD_INT 0
9841: PPUSH
9842: PPUSH
9843: PPUSH
9844: PPUSH
// begin ru_can_attack := true ;
9845: LD_ADDR_EXP 8
9849: PUSH
9850: LD_INT 1
9852: ST_TO_ADDR
// mine_launched := false ;
9853: LD_ADDR_VAR 0 3
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9861: LD_INT 22
9863: PUSH
9864: LD_INT 2
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: PPUSH
9871: CALL_OW 69
9875: PPUSH
9876: LD_INT 51
9878: PPUSH
9879: LD_INT 99
9881: PPUSH
9882: CALL_OW 111
// if IsOk ( Vervecken ) then
9886: LD_EXP 27
9890: PPUSH
9891: CALL_OW 302
9895: IFFALSE 9909
// Say ( Vervecken , D11a-Ar1-1 ) ;
9897: LD_EXP 27
9901: PPUSH
9902: LD_STRING D11a-Ar1-1
9904: PPUSH
9905: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9909: LD_ADDR_VAR 0 2
9913: PUSH
9914: LD_EXP 34
9918: PPUSH
9919: LD_INT 25
9921: PUSH
9922: LD_INT 1
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PPUSH
9929: CALL_OW 72
9933: ST_TO_ADDR
// for i in tmp do
9934: LD_ADDR_VAR 0 1
9938: PUSH
9939: LD_VAR 0 2
9943: PUSH
9944: FOR_IN
9945: IFFALSE 10008
// if MineOfUnit ( i ) then
9947: LD_VAR 0 1
9951: PPUSH
9952: CALL_OW 459
9956: IFFALSE 10006
// begin x := MineOfUnit ( i ) ;
9958: LD_ADDR_VAR 0 4
9962: PUSH
9963: LD_VAR 0 1
9967: PPUSH
9968: CALL_OW 459
9972: ST_TO_ADDR
// mine_launched := true ;
9973: LD_ADDR_VAR 0 3
9977: PUSH
9978: LD_INT 1
9980: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9981: LD_VAR 0 4
9985: PUSH
9986: LD_INT 1
9988: ARRAY
9989: PPUSH
9990: LD_VAR 0 4
9994: PUSH
9995: LD_INT 2
9997: ARRAY
9998: PPUSH
9999: LD_INT 2
10001: PPUSH
10002: CALL_OW 456
// end ;
10006: GO 9944
10008: POP
10009: POP
// if mine_launched and IsOk ( Vervecken ) then
10010: LD_VAR 0 3
10014: PUSH
10015: LD_EXP 27
10019: PPUSH
10020: CALL_OW 302
10024: AND
10025: IFFALSE 10039
// Say ( Vervecken , D11b-Ar1-1 ) ;
10027: LD_EXP 27
10031: PPUSH
10032: LD_STRING D11b-Ar1-1
10034: PPUSH
10035: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10039: LD_INT 22
10041: PUSH
10042: LD_INT 2
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: PPUSH
10054: LD_INT 51
10056: PPUSH
10057: LD_INT 99
10059: PPUSH
10060: CALL_OW 111
// wait ( 0 0$1 ) ;
10064: LD_INT 35
10066: PPUSH
10067: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10071: LD_INT 22
10073: PUSH
10074: LD_INT 2
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: PUSH
10081: LD_INT 92
10083: PUSH
10084: LD_INT 51
10086: PUSH
10087: LD_INT 99
10089: PUSH
10090: LD_INT 2
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PPUSH
10103: CALL_OW 69
10107: IFFALSE 10167
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10109: LD_ADDR_VAR 0 1
10113: PUSH
10114: LD_INT 22
10116: PUSH
10117: LD_INT 2
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: PUSH
10124: LD_INT 92
10126: PUSH
10127: LD_INT 51
10129: PUSH
10130: LD_INT 99
10132: PUSH
10133: LD_INT 2
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: PPUSH
10146: CALL_OW 69
10150: PUSH
10151: FOR_IN
10152: IFFALSE 10165
// RemoveUnit ( i ) ;
10154: LD_VAR 0 1
10158: PPUSH
10159: CALL_OW 64
10163: GO 10151
10165: POP
10166: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10167: LD_INT 22
10169: PUSH
10170: LD_INT 2
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: PPUSH
10177: CALL_OW 69
10181: PUSH
10182: LD_INT 0
10184: EQUAL
10185: IFFALSE 10039
// end ;
10187: PPOPN 4
10189: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10190: LD_EXP 10
10194: IFFALSE 10373
10196: GO 10198
10198: DISABLE
10199: LD_INT 0
10201: PPUSH
// begin Wait ( 10 10$00 ) ;
10202: LD_INT 21000
10204: PPUSH
10205: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10209: LD_INT 22
10211: PUSH
10212: LD_INT 2
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: IFFALSE 10373
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10225: LD_INT 22
10227: PUSH
10228: LD_INT 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_INT 51
10242: PPUSH
10243: LD_INT 99
10245: PPUSH
10246: CALL_OW 114
// wait ( 0 0$1 ) ;
10250: LD_INT 35
10252: PPUSH
10253: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10257: LD_INT 22
10259: PUSH
10260: LD_INT 2
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: PUSH
10267: LD_INT 92
10269: PUSH
10270: LD_INT 51
10272: PUSH
10273: LD_INT 99
10275: PUSH
10276: LD_INT 2
10278: PUSH
10279: EMPTY
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: IFFALSE 10353
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10295: LD_ADDR_VAR 0 1
10299: PUSH
10300: LD_INT 22
10302: PUSH
10303: LD_INT 2
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 92
10312: PUSH
10313: LD_INT 51
10315: PUSH
10316: LD_INT 99
10318: PUSH
10319: LD_INT 2
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: PUSH
10328: EMPTY
10329: LIST
10330: LIST
10331: PPUSH
10332: CALL_OW 69
10336: PUSH
10337: FOR_IN
10338: IFFALSE 10351
// RemoveUnit ( i ) ;
10340: LD_VAR 0 1
10344: PPUSH
10345: CALL_OW 64
10349: GO 10337
10351: POP
10352: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10353: LD_INT 22
10355: PUSH
10356: LD_INT 2
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: PPUSH
10363: CALL_OW 69
10367: PUSH
10368: LD_INT 0
10370: EQUAL
10371: IFFALSE 10225
// end ; end ;
10373: PPOPN 1
10375: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
10376: LD_EXP 4
10380: IFFALSE 11308
10382: GO 10384
10384: DISABLE
10385: LD_INT 0
10387: PPUSH
10388: PPUSH
10389: PPUSH
// begin Wait ( game_time ) ;
10390: LD_EXP 7
10394: PPUSH
10395: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10399: LD_INT 35
10401: PPUSH
10402: CALL_OW 67
// until ( not ru_can_attack ) ;
10406: LD_EXP 8
10410: NOT
10411: IFFALSE 10399
// Wait ( 0 0$35 ) ;
10413: LD_INT 1225
10415: PPUSH
10416: CALL_OW 67
// DialogueOn ;
10420: CALL_OW 6
// InGameOn ;
10424: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10428: LD_EXP 26
10432: PPUSH
10433: LD_STRING D12-Pow-1
10435: PPUSH
10436: CALL_OW 94
// InGameOff ;
10440: CALL_OW 9
// DialogueOff ;
10444: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10448: LD_STRING M4
10450: PPUSH
10451: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10455: LD_INT 5
10457: PPUSH
10458: LD_INT 1
10460: PPUSH
10461: CALL_OW 424
// can_end := true ;
10465: LD_ADDR_EXP 17
10469: PUSH
10470: LD_INT 1
10472: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10473: LD_INT 35
10475: PPUSH
10476: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10480: CALL 809 0 0
10484: PUSH
10485: LD_INT 20
10487: GREATEREQUAL
10488: PUSH
10489: LD_INT 22
10491: PUSH
10492: LD_INT 1
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PUSH
10499: LD_INT 21
10501: PUSH
10502: LD_INT 1
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PUSH
10509: EMPTY
10510: LIST
10511: LIST
10512: PPUSH
10513: CALL_OW 69
10517: PUSH
10518: LD_INT 5
10520: PPUSH
10521: LD_INT 22
10523: PUSH
10524: LD_INT 1
10526: PUSH
10527: EMPTY
10528: LIST
10529: LIST
10530: PUSH
10531: LD_INT 21
10533: PUSH
10534: LD_INT 1
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: PPUSH
10545: CALL_OW 70
10549: PUSH
10550: LD_INT 22
10552: PUSH
10553: LD_INT 1
10555: PUSH
10556: EMPTY
10557: LIST
10558: LIST
10559: PUSH
10560: LD_INT 55
10562: PUSH
10563: EMPTY
10564: LIST
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: PPUSH
10570: CALL_OW 69
10574: PLUS
10575: LESSEQUAL
10576: AND
10577: IFFALSE 10473
// if not player_get_info then
10579: LD_EXP 15
10583: NOT
10584: IFFALSE 10595
// player_get_info := - 1 ;
10586: LD_ADDR_EXP 15
10590: PUSH
10591: LD_INT 1
10593: NEG
10594: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10595: LD_STRING Information
10597: PPUSH
10598: LD_EXP 15
10602: PPUSH
10603: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10607: LD_ADDR_VAR 0 2
10611: PUSH
10612: LD_INT 22
10614: PUSH
10615: LD_INT 1
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PUSH
10622: LD_INT 2
10624: PUSH
10625: LD_INT 25
10627: PUSH
10628: LD_INT 2
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PUSH
10635: LD_INT 25
10637: PUSH
10638: LD_INT 16
10640: PUSH
10641: EMPTY
10642: LIST
10643: LIST
10644: PUSH
10645: LD_INT 34
10647: PUSH
10648: LD_INT 12
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PPUSH
10665: CALL_OW 69
10669: ST_TO_ADDR
// sib := GetTerminalCargo ;
10670: LD_ADDR_VAR 0 3
10674: PUSH
10675: CALL 809 0 0
10679: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: LD_VAR 0 3
10689: PUSH
10690: LD_INT 6
10692: PPUSH
10693: LD_INT 3
10695: PPUSH
10696: CALL_OW 287
10700: PLUS
10701: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10702: LD_ADDR_VAR 0 3
10706: PUSH
10707: LD_VAR 0 3
10711: PUSH
10712: LD_VAR 0 2
10716: PPUSH
10717: LD_INT 3
10719: PPUSH
10720: CALL_OW 289
10724: PLUS
10725: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10726: LD_VAR 0 3
10730: PUSH
10731: LD_INT 2
10733: PUSH
10734: LD_OWVAR 67
10738: PLUS
10739: PUSH
10740: LD_INT 50
10742: MUL
10743: LESS
10744: IFFALSE 10769
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10746: LD_STRING MuchSiberite
10748: PPUSH
10749: LD_INT 2
10751: NEG
10752: PUSH
10753: LD_OWVAR 67
10757: MUL
10758: PUSH
10759: LD_INT 1
10761: PLUS
10762: PPUSH
10763: CALL_OW 101
10767: GO 10779
// AddMedal ( MuchSiberite , 1 ) ;
10769: LD_STRING MuchSiberite
10771: PPUSH
10772: LD_INT 1
10774: PPUSH
10775: CALL_OW 101
// GiveMedals ( MAIN ) ;
10779: LD_STRING MAIN
10781: PPUSH
10782: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: LD_INT 2
10798: PUSH
10799: LD_INT 25
10801: PUSH
10802: LD_INT 1
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: PUSH
10809: LD_INT 25
10811: PUSH
10812: LD_INT 2
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: PUSH
10819: LD_INT 25
10821: PUSH
10822: LD_INT 3
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: LD_INT 25
10831: PUSH
10832: LD_INT 4
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: PUSH
10839: LD_INT 25
10841: PUSH
10842: LD_INT 8
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PUSH
10857: EMPTY
10858: LIST
10859: LIST
10860: PPUSH
10861: CALL_OW 69
10865: PPUSH
10866: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10870: LD_ADDR_VAR 0 2
10874: PUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PUSH
10885: LD_INT 25
10887: PUSH
10888: LD_INT 8
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PPUSH
10899: CALL_OW 69
10903: ST_TO_ADDR
// if tmp then
10904: LD_VAR 0 2
10908: IFFALSE 10939
// for i in tmp do
10910: LD_ADDR_VAR 0 1
10914: PUSH
10915: LD_VAR 0 2
10919: PUSH
10920: FOR_IN
10921: IFFALSE 10937
// SetClass ( i , 1 ) ;
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 1
10930: PPUSH
10931: CALL_OW 336
10935: GO 10920
10937: POP
10938: POP
// SaveVariable ( sib , 09_sibRes ) ;
10939: LD_VAR 0 3
10943: PPUSH
10944: LD_STRING 09_sibRes
10946: PPUSH
10947: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10951: LD_EXP 15
10955: PPUSH
10956: LD_STRING 09_arInfo
10958: PPUSH
10959: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10963: LD_EXP 19
10967: PPUSH
10968: LD_EXP 1
10972: PUSH
10973: LD_STRING JMM
10975: STR
10976: PPUSH
10977: CALL_OW 38
// if IsLive ( Gary ) then
10981: LD_EXP 20
10985: PPUSH
10986: CALL_OW 300
10990: IFFALSE 11010
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10992: LD_EXP 20
10996: PPUSH
10997: LD_EXP 1
11001: PUSH
11002: LD_STRING Gary
11004: STR
11005: PPUSH
11006: CALL_OW 38
// if IsLive ( Bobby ) then
11010: LD_EXP 21
11014: PPUSH
11015: CALL_OW 300
11019: IFFALSE 11039
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11021: LD_EXP 21
11025: PPUSH
11026: LD_EXP 1
11030: PUSH
11031: LD_STRING Bobby
11033: STR
11034: PPUSH
11035: CALL_OW 38
// if IsLive ( Cyrus ) then
11039: LD_EXP 22
11043: PPUSH
11044: CALL_OW 300
11048: IFFALSE 11068
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11050: LD_EXP 22
11054: PPUSH
11055: LD_EXP 1
11059: PUSH
11060: LD_STRING Cyrus
11062: STR
11063: PPUSH
11064: CALL_OW 38
// if IsLive ( Houten ) then
11068: LD_EXP 23
11072: PPUSH
11073: CALL_OW 300
11077: IFFALSE 11097
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11079: LD_EXP 23
11083: PPUSH
11084: LD_EXP 1
11088: PUSH
11089: LD_STRING Houten
11091: STR
11092: PPUSH
11093: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11097: LD_ADDR_VAR 0 2
11101: PUSH
11102: LD_INT 22
11104: PUSH
11105: LD_INT 1
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PUSH
11112: LD_INT 2
11114: PUSH
11115: LD_INT 25
11117: PUSH
11118: LD_INT 1
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: PUSH
11125: LD_INT 25
11127: PUSH
11128: LD_INT 2
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 25
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 25
11147: PUSH
11148: LD_INT 4
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: PUSH
11171: LD_EXP 19
11175: PUSH
11176: LD_EXP 22
11180: PUSH
11181: LD_EXP 21
11185: PUSH
11186: LD_EXP 23
11190: PUSH
11191: LD_EXP 20
11195: PUSH
11196: EMPTY
11197: LIST
11198: LIST
11199: LIST
11200: LIST
11201: LIST
11202: DIFF
11203: ST_TO_ADDR
// if tmp then
11204: LD_VAR 0 2
11208: IFFALSE 11228
// SaveCharacters ( tmp , mission_prefix & others ) ;
11210: LD_VAR 0 2
11214: PPUSH
11215: LD_EXP 1
11219: PUSH
11220: LD_STRING others
11222: STR
11223: PPUSH
11224: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11228: LD_ADDR_VAR 0 2
11232: PUSH
11233: LD_INT 22
11235: PUSH
11236: LD_INT 1
11238: PUSH
11239: EMPTY
11240: LIST
11241: LIST
11242: PUSH
11243: LD_INT 2
11245: PUSH
11246: LD_INT 25
11248: PUSH
11249: LD_INT 12
11251: PUSH
11252: EMPTY
11253: LIST
11254: LIST
11255: PUSH
11256: LD_INT 25
11258: PUSH
11259: LD_INT 16
11261: PUSH
11262: EMPTY
11263: LIST
11264: LIST
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: LIST
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: PPUSH
11275: CALL_OW 69
11279: ST_TO_ADDR
// if tmp then
11280: LD_VAR 0 2
11284: IFFALSE 11304
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_EXP 1
11295: PUSH
11296: LD_STRING apes
11298: STR
11299: PPUSH
11300: CALL_OW 38
// YouWin ;
11304: CALL_OW 103
// end ; end_of_file
11308: PPOPN 3
11310: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11311: LD_VAR 0 1
11315: PPUSH
11316: CALL_OW 266
11320: PUSH
11321: LD_INT 0
11323: EQUAL
11324: PUSH
11325: LD_EXP 3
11329: NOT
11330: AND
11331: IFFALSE 11355
// begin terminal := b ;
11333: LD_ADDR_EXP 3
11337: PUSH
11338: LD_VAR 0 1
11342: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11343: LD_EXP 3
11347: PPUSH
11348: LD_STRING terminal
11350: PPUSH
11351: CALL_OW 500
// end ; end ;
11355: PPOPN 2
11357: END
// on BuildingComplete ( b ) do var i ;
11358: LD_INT 0
11360: PPUSH
// begin if GetSide ( b ) = 3 then
11361: LD_VAR 0 1
11365: PPUSH
11366: CALL_OW 255
11370: PUSH
11371: LD_INT 3
11373: EQUAL
11374: IFFALSE 11414
// for i = 1 to 4 do
11376: LD_ADDR_VAR 0 2
11380: PUSH
11381: DOUBLE
11382: LD_INT 1
11384: DEC
11385: ST_TO_ADDR
11386: LD_INT 4
11388: PUSH
11389: FOR_TO
11390: IFFALSE 11412
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11392: LD_ADDR_EXP 37
11396: PUSH
11397: LD_EXP 37
11401: PPUSH
11402: LD_INT 1
11404: PPUSH
11405: CALL_OW 3
11409: ST_TO_ADDR
11410: GO 11389
11412: POP
11413: POP
// end ;
11414: PPOPN 2
11416: END
// on VehicleConstructed ( veh , fac ) do var i ;
11417: LD_INT 0
11419: PPUSH
// begin if GetSide ( veh ) = 3 then
11420: LD_VAR 0 1
11424: PPUSH
11425: CALL_OW 255
11429: PUSH
11430: LD_INT 3
11432: EQUAL
11433: IFFALSE 11558
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11435: LD_VAR 0 1
11439: PPUSH
11440: CALL_OW 264
11444: PUSH
11445: LD_INT 53
11447: PUSH
11448: LD_INT 52
11450: PUSH
11451: LD_INT 51
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: LIST
11458: IN
11459: NOT
11460: IFFALSE 11478
// ru_force := ru_force ^ veh ;
11462: LD_ADDR_EXP 36
11466: PUSH
11467: LD_EXP 36
11471: PUSH
11472: LD_VAR 0 1
11476: ADD
11477: ST_TO_ADDR
// for i = 1 to 4 do
11478: LD_ADDR_VAR 0 3
11482: PUSH
11483: DOUBLE
11484: LD_INT 1
11486: DEC
11487: ST_TO_ADDR
11488: LD_INT 4
11490: PUSH
11491: FOR_TO
11492: IFFALSE 11514
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11494: LD_ADDR_EXP 38
11498: PUSH
11499: LD_EXP 38
11503: PPUSH
11504: LD_INT 1
11506: PPUSH
11507: CALL_OW 3
11511: ST_TO_ADDR
11512: GO 11491
11514: POP
11515: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11516: LD_VAR 0 1
11520: PPUSH
11521: CALL_OW 264
11525: PUSH
11526: LD_INT 53
11528: EQUAL
11529: IFFALSE 11558
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11531: LD_VAR 0 1
11535: PPUSH
11536: LD_INT 7
11538: PPUSH
11539: CALL 967 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11543: LD_VAR 0 1
11547: PPUSH
11548: LD_INT 170
11550: PPUSH
11551: LD_INT 235
11553: PPUSH
11554: CALL_OW 171
// end ; end ; end ;
11558: PPOPN 3
11560: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11561: LD_VAR 0 1
11565: PUSH
11566: LD_INT 1
11568: EQUAL
11569: PUSH
11570: LD_VAR 0 2
11574: PUSH
11575: LD_INT 2
11577: EQUAL
11578: AND
11579: PUSH
11580: LD_VAR 0 1
11584: PUSH
11585: LD_INT 2
11587: EQUAL
11588: PUSH
11589: LD_VAR 0 2
11593: PUSH
11594: LD_INT 1
11596: EQUAL
11597: AND
11598: OR
11599: IFFALSE 11609
// player_attacked_ar := true ;
11601: LD_ADDR_EXP 16
11605: PUSH
11606: LD_INT 1
11608: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11609: LD_VAR 0 1
11613: PUSH
11614: LD_INT 1
11616: EQUAL
11617: PUSH
11618: LD_VAR 0 2
11622: PUSH
11623: LD_INT 4
11625: EQUAL
11626: AND
11627: PUSH
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 4
11635: EQUAL
11636: PUSH
11637: LD_VAR 0 2
11641: PUSH
11642: LD_INT 1
11644: EQUAL
11645: AND
11646: OR
11647: IFFALSE 11656
// YouLost ( Traitor ) ;
11649: LD_STRING Traitor
11651: PPUSH
11652: CALL_OW 104
// end ;
11656: PPOPN 2
11658: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11659: LD_VAR 0 1
11663: PUSH
11664: LD_EXP 19
11668: EQUAL
11669: IFFALSE 11678
// YouLost ( JMM ) ;
11671: LD_STRING JMM
11673: PPUSH
11674: CALL_OW 104
// if un = terminal then
11678: LD_VAR 0 1
11682: PUSH
11683: LD_EXP 3
11687: EQUAL
11688: IFFALSE 11697
// YouLost ( Terminal ) ;
11690: LD_STRING Terminal
11692: PPUSH
11693: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11697: LD_VAR 0 1
11701: PUSH
11702: LD_INT 22
11704: PUSH
11705: LD_INT 3
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: PUSH
11712: LD_INT 21
11714: PUSH
11715: LD_INT 3
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PPUSH
11726: CALL_OW 69
11730: IN
11731: IFFALSE 11877
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11733: LD_VAR 0 1
11737: PPUSH
11738: CALL_OW 266
11742: PUSH
11743: LD_INT 33
11745: PUSH
11746: LD_INT 26
11748: PUSH
11749: EMPTY
11750: LIST
11751: LIST
11752: IN
11753: IFFALSE 11812
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11755: LD_ADDR_EXP 37
11759: PUSH
11760: LD_EXP 37
11764: PUSH
11765: LD_VAR 0 1
11769: PPUSH
11770: CALL_OW 266
11774: PUSH
11775: LD_VAR 0 1
11779: PPUSH
11780: CALL_OW 250
11784: PUSH
11785: LD_VAR 0 1
11789: PPUSH
11790: CALL_OW 251
11794: PUSH
11795: LD_VAR 0 1
11799: PPUSH
11800: CALL_OW 254
11804: PUSH
11805: EMPTY
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: ADD
11811: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11812: LD_VAR 0 1
11816: PPUSH
11817: CALL_OW 266
11821: PUSH
11822: LD_INT 5
11824: EQUAL
11825: IFFALSE 11877
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11827: LD_ADDR_EXP 37
11831: PUSH
11832: LD_EXP 37
11836: PUSH
11837: LD_INT 4
11839: PUSH
11840: LD_VAR 0 1
11844: PPUSH
11845: CALL_OW 250
11849: PUSH
11850: LD_VAR 0 1
11854: PPUSH
11855: CALL_OW 251
11859: PUSH
11860: LD_VAR 0 1
11864: PPUSH
11865: CALL_OW 254
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: ADD
11876: ST_TO_ADDR
// end ; if un in ru_force then
11877: LD_VAR 0 1
11881: PUSH
11882: LD_EXP 36
11886: IN
11887: IFFALSE 11923
// begin ru_force := ru_force diff un ;
11889: LD_ADDR_EXP 36
11893: PUSH
11894: LD_EXP 36
11898: PUSH
11899: LD_VAR 0 1
11903: DIFF
11904: ST_TO_ADDR
// if ru_force = 0 then
11905: LD_EXP 36
11909: PUSH
11910: LD_INT 0
11912: EQUAL
11913: IFFALSE 11923
// ru_can_attack := false ;
11915: LD_ADDR_EXP 8
11919: PUSH
11920: LD_INT 0
11922: ST_TO_ADDR
// end ; end ; end_of_file
11923: PPOPN 1
11925: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11926: LD_EXP 5
11930: PUSH
11931: LD_EXP 6
11935: AND
11936: IFFALSE 12014
11938: GO 11940
11940: DISABLE
11941: LD_INT 0
11943: PPUSH
// begin enable ;
11944: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11945: LD_ADDR_VAR 0 1
11949: PUSH
11950: LD_INT 60
11952: PUSH
11953: CALL 809 0 0
11957: MINUS
11958: ST_TO_ADDR
// if sib < 0 then
11959: LD_VAR 0 1
11963: PUSH
11964: LD_INT 0
11966: LESS
11967: IFFALSE 11977
// sib := 0 ;
11969: LD_ADDR_VAR 0 1
11973: PUSH
11974: LD_INT 0
11976: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11977: LD_ADDR_OWVAR 47
11981: PUSH
11982: LD_STRING #Am09-1
11984: PUSH
11985: LD_VAR 0 1
11989: PUSH
11990: LD_EXP 6
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: LIST
11999: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12000: LD_ADDR_EXP 6
12004: PUSH
12005: LD_EXP 6
12009: PUSH
12010: LD_INT 35
12012: MINUS
12013: ST_TO_ADDR
// end ;
12014: PPOPN 1
12016: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12017: LD_EXP 6
12021: PUSH
12022: LD_INT 0
12024: EQUAL
12025: IFFALSE 12037
12027: GO 12029
12029: DISABLE
// display_strings := [ ] ;
12030: LD_ADDR_OWVAR 47
12034: PUSH
12035: EMPTY
12036: ST_TO_ADDR
12037: END
// every 0 0$01 trigger ru_force and debug do
12038: LD_EXP 36
12042: PUSH
12043: LD_EXP 2
12047: AND
12048: IFFALSE 12064
12050: GO 12052
12052: DISABLE
// begin enable ;
12053: ENABLE
// display_strings := ru_force ;
12054: LD_ADDR_OWVAR 47
12058: PUSH
12059: LD_EXP 36
12063: ST_TO_ADDR
// end ;
12064: END
// every 1 1$35 do var i , tmp ;
12065: GO 12067
12067: DISABLE
12068: LD_INT 0
12070: PPUSH
12071: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12072: LD_ADDR_VAR 0 2
12076: PUSH
12077: LD_INT 1155
12079: PUSH
12080: LD_INT 1225
12082: PUSH
12083: LD_INT 1435
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: LIST
12090: PUSH
12091: LD_OWVAR 67
12095: ARRAY
12096: ST_TO_ADDR
// i := 0 ;
12097: LD_ADDR_VAR 0 1
12101: PUSH
12102: LD_INT 0
12104: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12105: LD_INT 1
12107: PPUSH
12108: LD_INT 5
12110: PPUSH
12111: CALL_OW 12
12115: PPUSH
12116: LD_INT 75
12118: PPUSH
12119: LD_INT 75
12121: PPUSH
12122: LD_INT 20
12124: PPUSH
12125: LD_INT 1
12127: PPUSH
12128: CALL_OW 56
// wait ( tmp ) ;
12132: LD_VAR 0 2
12136: PPUSH
12137: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12141: LD_ADDR_VAR 0 2
12145: PUSH
12146: LD_VAR 0 2
12150: PUSH
12151: LD_INT 105
12153: PPUSH
12154: LD_INT 315
12156: PPUSH
12157: CALL_OW 12
12161: PLUS
12162: ST_TO_ADDR
// i := i + 1 ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_INT 1
12175: PLUS
12176: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12177: LD_VAR 0 1
12181: PUSH
12182: LD_INT 3
12184: MOD
12185: PUSH
12186: LD_INT 0
12188: EQUAL
12189: PUSH
12190: LD_EXP 4
12194: AND
12195: IFFALSE 12233
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12197: LD_INT 2
12199: PPUSH
12200: LD_INT 5
12202: PPUSH
12203: CALL_OW 12
12207: PPUSH
12208: LD_INT 8
12210: PPUSH
12211: LD_INT 1
12213: PPUSH
12214: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12218: LD_INT 665
12220: PPUSH
12221: LD_INT 735
12223: PPUSH
12224: CALL_OW 12
12228: PPUSH
12229: CALL_OW 67
// end ; until tick > game_time ;
12233: LD_OWVAR 1
12237: PUSH
12238: LD_EXP 7
12242: GREATER
12243: IFFALSE 12105
// end ; end_of_file
12245: PPOPN 2
12247: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12248: LD_INT 0
12250: PPUSH
12251: PPUSH
12252: PPUSH
12253: PPUSH
12254: PPUSH
12255: PPUSH
// x := 76 ;
12256: LD_ADDR_VAR 0 5
12260: PUSH
12261: LD_INT 76
12263: ST_TO_ADDR
// y := 147 ;
12264: LD_ADDR_VAR 0 6
12268: PUSH
12269: LD_INT 147
12271: ST_TO_ADDR
// uc_side := 2 ;
12272: LD_ADDR_OWVAR 20
12276: PUSH
12277: LD_INT 2
12279: ST_TO_ADDR
// uc_nation := 2 ;
12280: LD_ADDR_OWVAR 21
12284: PUSH
12285: LD_INT 2
12287: ST_TO_ADDR
// InitHc ;
12288: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12292: LD_INT 1
12294: PPUSH
12295: LD_INT 1
12297: PPUSH
12298: LD_INT 6
12300: PPUSH
12301: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12305: LD_ADDR_OWVAR 26
12309: PUSH
12310: LD_STRING Nicolas Vervecken
12312: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12313: LD_ADDR_OWVAR 33
12317: PUSH
12318: LD_STRING SecondCharsGal
12320: ST_TO_ADDR
// hc_face_number := 3 ;
12321: LD_ADDR_OWVAR 34
12325: PUSH
12326: LD_INT 3
12328: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12329: LD_ADDR_OWVAR 29
12333: PUSH
12334: LD_INT 11
12336: PUSH
12337: LD_INT 10
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: ST_TO_ADDR
// Vervecken := CreateHuman ;
12344: LD_ADDR_EXP 27
12348: PUSH
12349: CALL_OW 44
12353: ST_TO_ADDR
// ar_force := Vervecken ;
12354: LD_ADDR_EXP 34
12358: PUSH
12359: LD_EXP 27
12363: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12364: LD_INT 1
12366: PPUSH
12367: LD_INT 2
12369: PPUSH
12370: LD_INT 6
12372: PPUSH
12373: CALL_OW 380
// hc_name := Louis Gali ;
12377: LD_ADDR_OWVAR 26
12381: PUSH
12382: LD_STRING Louis Gali
12384: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12385: LD_ADDR_OWVAR 33
12389: PUSH
12390: LD_STRING SecondCharsGal
12392: ST_TO_ADDR
// hc_face_number := 2 ;
12393: LD_ADDR_OWVAR 34
12397: PUSH
12398: LD_INT 2
12400: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12401: LD_ADDR_OWVAR 29
12405: PUSH
12406: LD_INT 10
12408: PUSH
12409: LD_INT 11
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: ST_TO_ADDR
// Gali := CreateHuman ;
12416: LD_ADDR_EXP 28
12420: PUSH
12421: CALL_OW 44
12425: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12426: LD_ADDR_EXP 34
12430: PUSH
12431: LD_EXP 34
12435: PUSH
12436: LD_EXP 28
12440: ADD
12441: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12442: LD_INT 2
12444: PPUSH
12445: LD_INT 1
12447: PPUSH
12448: LD_INT 6
12450: PPUSH
12451: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12455: LD_ADDR_OWVAR 26
12459: PUSH
12460: LD_STRING Maria Bogdanovic
12462: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12463: LD_ADDR_OWVAR 33
12467: PUSH
12468: LD_STRING SecondCharsGal
12470: ST_TO_ADDR
// hc_face_number := 14 ;
12471: LD_ADDR_OWVAR 34
12475: PUSH
12476: LD_INT 14
12478: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12479: LD_ADDR_OWVAR 29
12483: PUSH
12484: LD_INT 12
12486: PUSH
12487: LD_INT 9
12489: PUSH
12490: EMPTY
12491: LIST
12492: LIST
12493: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12494: LD_ADDR_EXP 29
12498: PUSH
12499: CALL_OW 44
12503: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12504: LD_ADDR_EXP 34
12508: PUSH
12509: LD_EXP 34
12513: PUSH
12514: LD_EXP 29
12518: ADD
12519: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12520: LD_INT 1
12522: PPUSH
12523: LD_INT 3
12525: PPUSH
12526: LD_INT 6
12528: PPUSH
12529: CALL_OW 380
// hc_name = Kntor Radomr ;
12533: LD_ADDR_OWVAR 26
12537: PUSH
12538: LD_STRING Kntor Radomr
12540: ST_TO_ADDR
// hc_gallery = sandar ;
12541: LD_ADDR_OWVAR 33
12545: PUSH
12546: LD_STRING sandar
12548: ST_TO_ADDR
// hc_face_number = 12 ;
12549: LD_ADDR_OWVAR 34
12553: PUSH
12554: LD_INT 12
12556: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12557: LD_ADDR_OWVAR 29
12561: PUSH
12562: LD_INT 9
12564: PUSH
12565: LD_INT 9
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: ST_TO_ADDR
// Kantor = CreateHuman ;
12572: LD_ADDR_EXP 30
12576: PUSH
12577: CALL_OW 44
12581: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12582: LD_ADDR_EXP 34
12586: PUSH
12587: LD_EXP 34
12591: PUSH
12592: LD_EXP 30
12596: ADD
12597: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12598: LD_INT 1
12600: PPUSH
12601: LD_INT 3
12603: PPUSH
12604: LD_INT 6
12606: PPUSH
12607: CALL_OW 380
// hc_name = Herczeg Farkas ;
12611: LD_ADDR_OWVAR 26
12615: PUSH
12616: LD_STRING Herczeg Farkas
12618: ST_TO_ADDR
// hc_gallery = sandar ;
12619: LD_ADDR_OWVAR 33
12623: PUSH
12624: LD_STRING sandar
12626: ST_TO_ADDR
// hc_face_number = 28 ;
12627: LD_ADDR_OWVAR 34
12631: PUSH
12632: LD_INT 28
12634: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12635: LD_ADDR_OWVAR 29
12639: PUSH
12640: LD_INT 10
12642: PUSH
12643: LD_INT 9
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: ST_TO_ADDR
// Herczeg = CreateHuman ;
12650: LD_ADDR_EXP 31
12654: PUSH
12655: CALL_OW 44
12659: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12660: LD_ADDR_EXP 34
12664: PUSH
12665: LD_EXP 34
12669: PUSH
12670: LD_EXP 31
12674: ADD
12675: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12676: LD_INT 1
12678: PPUSH
12679: LD_INT 1
12681: PPUSH
12682: LD_INT 6
12684: PPUSH
12685: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12689: LD_ADDR_OWVAR 26
12693: PUSH
12694: LD_STRING Ronn Horntvedt
12696: ST_TO_ADDR
// hc_gallery = sandar ;
12697: LD_ADDR_OWVAR 33
12701: PUSH
12702: LD_STRING sandar
12704: ST_TO_ADDR
// hc_face_number = 29 ;
12705: LD_ADDR_OWVAR 34
12709: PUSH
12710: LD_INT 29
12712: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12713: LD_ADDR_OWVAR 29
12717: PUSH
12718: LD_INT 11
12720: PUSH
12721: LD_INT 11
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: ST_TO_ADDR
// Ronn = CreateHuman ;
12728: LD_ADDR_EXP 32
12732: PUSH
12733: CALL_OW 44
12737: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12738: LD_ADDR_EXP 34
12742: PUSH
12743: LD_EXP 34
12747: PUSH
12748: LD_EXP 32
12752: ADD
12753: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12754: LD_INT 2
12756: PPUSH
12757: LD_INT 3
12759: PPUSH
12760: LD_INT 6
12762: PPUSH
12763: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12767: LD_ADDR_OWVAR 26
12771: PUSH
12772: LD_STRING Mia D. Mathiasen
12774: ST_TO_ADDR
// hc_gallery = sandar ;
12775: LD_ADDR_OWVAR 33
12779: PUSH
12780: LD_STRING sandar
12782: ST_TO_ADDR
// hc_face_number = 31 ;
12783: LD_ADDR_OWVAR 34
12787: PUSH
12788: LD_INT 31
12790: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12791: LD_ADDR_OWVAR 29
12795: PUSH
12796: LD_INT 10
12798: PUSH
12799: LD_INT 10
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: ST_TO_ADDR
// Mia = CreateHuman ;
12806: LD_ADDR_EXP 33
12810: PUSH
12811: CALL_OW 44
12815: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12816: LD_ADDR_EXP 34
12820: PUSH
12821: LD_EXP 34
12825: PUSH
12826: LD_EXP 33
12830: ADD
12831: ST_TO_ADDR
// for i = 1 to 2 do
12832: LD_ADDR_VAR 0 4
12836: PUSH
12837: DOUBLE
12838: LD_INT 1
12840: DEC
12841: ST_TO_ADDR
12842: LD_INT 2
12844: PUSH
12845: FOR_TO
12846: IFFALSE 12887
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12848: LD_ADDR_VAR 0 3
12852: PUSH
12853: LD_VAR 0 3
12857: PUSH
12858: LD_INT 2
12860: PPUSH
12861: LD_INT 2
12863: PPUSH
12864: LD_INT 14
12866: PPUSH
12867: LD_INT 1
12869: PPUSH
12870: LD_INT 1
12872: PPUSH
12873: LD_INT 32
12875: PPUSH
12876: LD_INT 30
12878: PPUSH
12879: CALL 289 0 7
12883: ADD
12884: ST_TO_ADDR
12885: GO 12845
12887: POP
12888: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12889: LD_ADDR_VAR 0 3
12893: PUSH
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 2
12901: PPUSH
12902: LD_INT 2
12904: PPUSH
12905: LD_INT 14
12907: PPUSH
12908: LD_INT 1
12910: PPUSH
12911: LD_INT 1
12913: PPUSH
12914: LD_INT 26
12916: PPUSH
12917: LD_INT 33
12919: PPUSH
12920: CALL 289 0 7
12924: ADD
12925: ST_TO_ADDR
// tmp := tmp diff 0 ;
12926: LD_ADDR_VAR 0 3
12930: PUSH
12931: LD_VAR 0 3
12935: PUSH
12936: LD_INT 0
12938: DIFF
12939: ST_TO_ADDR
// for i in ar_force do
12940: LD_ADDR_VAR 0 4
12944: PUSH
12945: LD_EXP 34
12949: PUSH
12950: FOR_IN
12951: IFFALSE 13094
// begin if GetClass ( i ) = 3 then
12953: LD_VAR 0 4
12957: PPUSH
12958: CALL_OW 257
12962: PUSH
12963: LD_INT 3
12965: EQUAL
12966: IFFALSE 13048
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12968: LD_VAR 0 3
12972: PUSH
12973: LD_INT 1
12975: ARRAY
12976: PPUSH
12977: LD_INT 1
12979: PPUSH
12980: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12984: LD_VAR 0 3
12988: PUSH
12989: LD_INT 1
12991: ARRAY
12992: PPUSH
12993: LD_VAR 0 5
12997: PPUSH
12998: LD_VAR 0 6
13002: PPUSH
13003: LD_INT 0
13005: PPUSH
13006: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13010: LD_VAR 0 4
13014: PPUSH
13015: LD_VAR 0 3
13019: PUSH
13020: LD_INT 1
13022: ARRAY
13023: PPUSH
13024: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13028: LD_ADDR_VAR 0 3
13032: PUSH
13033: LD_VAR 0 3
13037: PPUSH
13038: LD_INT 1
13040: PPUSH
13041: CALL_OW 3
13045: ST_TO_ADDR
// end else
13046: GO 13070
// PlaceUnitXY ( i , x , y , false ) ;
13048: LD_VAR 0 4
13052: PPUSH
13053: LD_VAR 0 5
13057: PPUSH
13058: LD_VAR 0 6
13062: PPUSH
13063: LD_INT 0
13065: PPUSH
13066: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13070: LD_VAR 0 4
13074: PPUSH
13075: LD_INT 86
13077: PPUSH
13078: LD_INT 121
13080: PPUSH
13081: CALL_OW 111
// wait ( 0 0$2 ) ;
13085: LD_INT 70
13087: PPUSH
13088: CALL_OW 67
// end ;
13092: GO 12950
13094: POP
13095: POP
// ar_force := ar_force ^ tmp ;
13096: LD_ADDR_EXP 34
13100: PUSH
13101: LD_EXP 34
13105: PUSH
13106: LD_VAR 0 3
13110: ADD
13111: ST_TO_ADDR
// ar_spawned := true ;
13112: LD_ADDR_EXP 11
13116: PUSH
13117: LD_INT 1
13119: ST_TO_ADDR
// end ; end_of_file
13120: LD_VAR 0 1
13124: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
13133: PPUSH
// InitHc ;
13134: CALL_OW 19
// uc_side := 3 ;
13138: LD_ADDR_OWVAR 20
13142: PUSH
13143: LD_INT 3
13145: ST_TO_ADDR
// uc_nation := 3 ;
13146: LD_ADDR_OWVAR 21
13150: PUSH
13151: LD_INT 3
13153: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13154: LD_ADDR_VAR 0 5
13158: PUSH
13159: LD_INT 5
13161: PUSH
13162: LD_INT 6
13164: PUSH
13165: LD_INT 7
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: LIST
13172: PUSH
13173: LD_OWVAR 67
13177: ARRAY
13178: ST_TO_ADDR
// ru_force := [ ] ;
13179: LD_ADDR_EXP 36
13183: PUSH
13184: EMPTY
13185: ST_TO_ADDR
// ru_rebuild := [ ] ;
13186: LD_ADDR_EXP 37
13190: PUSH
13191: EMPTY
13192: ST_TO_ADDR
// ru_produce_list := [ ] ;
13193: LD_ADDR_EXP 38
13197: PUSH
13198: EMPTY
13199: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13200: LD_ADDR_VAR 0 6
13204: PUSH
13205: LD_INT 22
13207: PUSH
13208: LD_INT 3
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: PUSH
13215: LD_INT 30
13217: PUSH
13218: LD_INT 8
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: PPUSH
13229: CALL_OW 69
13233: PUSH
13234: LD_INT 1
13236: ARRAY
13237: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13238: LD_ADDR_VAR 0 4
13242: PUSH
13243: LD_INT 43
13245: PUSH
13246: LD_INT 46
13248: PUSH
13249: LD_INT 45
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: LIST
13256: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13257: LD_ADDR_VAR 0 7
13261: PUSH
13262: LD_INT 22
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: LD_INT 30
13274: PUSH
13275: LD_INT 1
13277: PUSH
13278: EMPTY
13279: LIST
13280: LIST
13281: PUSH
13282: EMPTY
13283: LIST
13284: LIST
13285: PPUSH
13286: CALL_OW 69
13290: PUSH
13291: LD_INT 1
13293: ARRAY
13294: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13295: LD_VAR 0 7
13299: PPUSH
13300: CALL_OW 274
13304: PPUSH
13305: LD_INT 1
13307: PPUSH
13308: LD_INT 5000
13310: PPUSH
13311: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13315: LD_VAR 0 7
13319: PPUSH
13320: CALL_OW 274
13324: PPUSH
13325: LD_INT 2
13327: PPUSH
13328: LD_INT 1000
13330: PPUSH
13331: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13335: LD_VAR 0 7
13339: PPUSH
13340: CALL_OW 274
13344: PPUSH
13345: LD_INT 3
13347: PPUSH
13348: LD_INT 30
13350: PPUSH
13351: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13355: LD_ADDR_VAR 0 2
13359: PUSH
13360: LD_INT 22
13362: PUSH
13363: LD_INT 3
13365: PUSH
13366: EMPTY
13367: LIST
13368: LIST
13369: PUSH
13370: LD_INT 30
13372: PUSH
13373: LD_INT 33
13375: PUSH
13376: EMPTY
13377: LIST
13378: LIST
13379: PUSH
13380: EMPTY
13381: LIST
13382: LIST
13383: PPUSH
13384: CALL_OW 69
13388: PUSH
13389: FOR_IN
13390: IFFALSE 13422
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13392: LD_VAR 0 2
13396: PPUSH
13397: LD_VAR 0 4
13401: PUSH
13402: LD_VAR 0 2
13406: PUSH
13407: LD_INT 3
13409: MOD
13410: PUSH
13411: LD_INT 1
13413: PLUS
13414: ARRAY
13415: PPUSH
13416: CALL_OW 431
// end ;
13420: GO 13389
13422: POP
13423: POP
// for i = 1 to 4 do
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: DOUBLE
13430: LD_INT 1
13432: DEC
13433: ST_TO_ADDR
13434: LD_INT 4
13436: PUSH
13437: FOR_TO
13438: IFFALSE 13499
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13440: LD_INT 0
13442: PPUSH
13443: LD_INT 9
13445: PPUSH
13446: LD_VAR 0 5
13450: PPUSH
13451: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13455: CALL_OW 44
13459: PPUSH
13460: LD_INT 22
13462: PUSH
13463: LD_INT 3
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 30
13472: PUSH
13473: LD_INT 5
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PPUSH
13484: CALL_OW 69
13488: PUSH
13489: LD_INT 1
13491: ARRAY
13492: PPUSH
13493: CALL_OW 52
// end ;
13497: GO 13437
13499: POP
13500: POP
// for i = 1 to 5 do
13501: LD_ADDR_VAR 0 2
13505: PUSH
13506: DOUBLE
13507: LD_INT 1
13509: DEC
13510: ST_TO_ADDR
13511: LD_INT 5
13513: PUSH
13514: FOR_TO
13515: IFFALSE 13576
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13517: LD_INT 0
13519: PPUSH
13520: LD_INT 3
13522: PPUSH
13523: LD_VAR 0 5
13527: PPUSH
13528: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13532: CALL_OW 44
13536: PPUSH
13537: LD_INT 22
13539: PUSH
13540: LD_INT 3
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 30
13549: PUSH
13550: LD_INT 3
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PPUSH
13561: CALL_OW 69
13565: PUSH
13566: LD_INT 1
13568: ARRAY
13569: PPUSH
13570: CALL_OW 52
// end ;
13574: GO 13514
13576: POP
13577: POP
// for i = 1 to 4 do
13578: LD_ADDR_VAR 0 2
13582: PUSH
13583: DOUBLE
13584: LD_INT 1
13586: DEC
13587: ST_TO_ADDR
13588: LD_INT 4
13590: PUSH
13591: FOR_TO
13592: IFFALSE 13653
// begin PrepareHuman ( false , class_engineer , skill ) ;
13594: LD_INT 0
13596: PPUSH
13597: LD_INT 2
13599: PPUSH
13600: LD_VAR 0 5
13604: PPUSH
13605: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13609: CALL_OW 44
13613: PPUSH
13614: LD_INT 22
13616: PUSH
13617: LD_INT 3
13619: PUSH
13620: EMPTY
13621: LIST
13622: LIST
13623: PUSH
13624: LD_INT 30
13626: PUSH
13627: LD_INT 1
13629: PUSH
13630: EMPTY
13631: LIST
13632: LIST
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PPUSH
13638: CALL_OW 69
13642: PUSH
13643: LD_INT 1
13645: ARRAY
13646: PPUSH
13647: CALL_OW 52
// end ;
13651: GO 13591
13653: POP
13654: POP
// for i = 1 to 3 do
13655: LD_ADDR_VAR 0 2
13659: PUSH
13660: DOUBLE
13661: LD_INT 1
13663: DEC
13664: ST_TO_ADDR
13665: LD_INT 3
13667: PUSH
13668: FOR_TO
13669: IFFALSE 13702
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13671: LD_INT 0
13673: PPUSH
13674: LD_INT 4
13676: PPUSH
13677: LD_VAR 0 5
13681: PPUSH
13682: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13686: CALL_OW 44
13690: PPUSH
13691: LD_VAR 0 6
13695: PPUSH
13696: CALL_OW 52
// end ;
13700: GO 13668
13702: POP
13703: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13704: LD_ADDR_EXP 35
13708: PUSH
13709: LD_STRING Yakotich
13711: PPUSH
13712: LD_EXP 2
13716: NOT
13717: PPUSH
13718: LD_STRING 
13720: PPUSH
13721: CALL 226 0 3
13725: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13726: LD_EXP 35
13730: PPUSH
13731: LD_INT 74
13733: PPUSH
13734: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13738: LD_VAR 0 6
13742: PPUSH
13743: LD_INT 49
13745: PPUSH
13746: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13750: LD_VAR 0 6
13754: PPUSH
13755: LD_INT 50
13757: PPUSH
13758: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13762: LD_VAR 0 6
13766: PPUSH
13767: LD_INT 51
13769: PPUSH
13770: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13774: LD_VAR 0 6
13778: PPUSH
13779: LD_INT 52
13781: PPUSH
13782: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13786: LD_VAR 0 6
13790: PPUSH
13791: LD_INT 69
13793: PPUSH
13794: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13798: LD_VAR 0 6
13802: PPUSH
13803: LD_INT 39
13805: PPUSH
13806: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13810: LD_VAR 0 6
13814: PPUSH
13815: LD_INT 34
13817: PPUSH
13818: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13822: LD_VAR 0 6
13826: PPUSH
13827: LD_INT 40
13829: PPUSH
13830: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13834: LD_VAR 0 6
13838: PPUSH
13839: LD_INT 57
13841: PPUSH
13842: CALL_OW 184
// if Difficulty > 1 then
13846: LD_OWVAR 67
13850: PUSH
13851: LD_INT 1
13853: GREATER
13854: IFFALSE 13868
// AddComResearch ( lab , tech_comp2 ) ;
13856: LD_VAR 0 6
13860: PPUSH
13861: LD_INT 58
13863: PPUSH
13864: CALL_OW 184
// end ;
13868: LD_VAR 0 1
13872: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13873: LD_INT 7
13875: PPUSH
13876: CALL_OW 353
13880: PUSH
13881: LD_INT 3
13883: GREATER
13884: PUSH
13885: LD_INT 22
13887: PUSH
13888: LD_INT 3
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: PUSH
13895: LD_INT 34
13897: PUSH
13898: LD_INT 53
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: PUSH
13905: EMPTY
13906: LIST
13907: LIST
13908: PPUSH
13909: CALL_OW 69
13913: NOT
13914: AND
13915: IFFALSE 13950
13917: GO 13919
13919: DISABLE
// begin enable ;
13920: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13921: LD_ADDR_EXP 38
13925: PUSH
13926: LD_EXP 38
13930: PUSH
13931: LD_INT 24
13933: PUSH
13934: LD_INT 1
13936: PUSH
13937: LD_INT 3
13939: PUSH
13940: LD_INT 53
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: ADD
13949: ST_TO_ADDR
// end ;
13950: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13951: LD_INT 22
13953: PUSH
13954: LD_INT 3
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: PUSH
13961: LD_INT 21
13963: PUSH
13964: LD_INT 3
13966: PUSH
13967: EMPTY
13968: LIST
13969: LIST
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PPUSH
13975: CALL_OW 69
13979: IFFALSE 14757
13981: GO 13983
13983: DISABLE
13984: LD_INT 0
13986: PPUSH
13987: PPUSH
13988: PPUSH
13989: PPUSH
13990: PPUSH
13991: PPUSH
13992: PPUSH
13993: PPUSH
// begin enable ;
13994: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13995: LD_ADDR_VAR 0 3
13999: PUSH
14000: LD_INT 22
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 21
14012: PUSH
14013: LD_INT 3
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: LD_INT 3
14022: PUSH
14023: LD_INT 24
14025: PUSH
14026: LD_INT 1000
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: LIST
14041: PPUSH
14042: CALL_OW 69
14046: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14047: LD_ADDR_VAR 0 4
14051: PUSH
14052: LD_INT 22
14054: PUSH
14055: LD_INT 3
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PUSH
14062: LD_INT 25
14064: PUSH
14065: LD_INT 2
14067: PUSH
14068: EMPTY
14069: LIST
14070: LIST
14071: PUSH
14072: EMPTY
14073: LIST
14074: LIST
14075: PPUSH
14076: CALL_OW 69
14080: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14081: LD_ADDR_VAR 0 5
14085: PUSH
14086: LD_INT 22
14088: PUSH
14089: LD_INT 3
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: PUSH
14096: LD_INT 30
14098: PUSH
14099: LD_INT 1
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: PPUSH
14110: CALL_OW 69
14114: PUSH
14115: LD_INT 1
14117: ARRAY
14118: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14119: LD_ADDR_VAR 0 8
14123: PUSH
14124: LD_INT 22
14126: PUSH
14127: LD_INT 3
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: PUSH
14134: LD_INT 2
14136: PUSH
14137: LD_INT 30
14139: PUSH
14140: LD_INT 6
14142: PUSH
14143: EMPTY
14144: LIST
14145: LIST
14146: PUSH
14147: LD_INT 30
14149: PUSH
14150: LD_INT 7
14152: PUSH
14153: EMPTY
14154: LIST
14155: LIST
14156: PUSH
14157: LD_INT 30
14159: PUSH
14160: LD_INT 8
14162: PUSH
14163: EMPTY
14164: LIST
14165: LIST
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: PUSH
14173: EMPTY
14174: LIST
14175: LIST
14176: PPUSH
14177: CALL_OW 69
14181: PUSH
14182: LD_INT 1
14184: ARRAY
14185: ST_TO_ADDR
// if not engs then
14186: LD_VAR 0 4
14190: NOT
14191: IFFALSE 14195
// exit ;
14193: GO 14757
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14195: LD_ADDR_VAR 0 6
14199: PUSH
14200: LD_VAR 0 4
14204: PPUSH
14205: LD_INT 3
14207: PUSH
14208: LD_INT 24
14210: PUSH
14211: LD_INT 600
14213: PUSH
14214: EMPTY
14215: LIST
14216: LIST
14217: PUSH
14218: EMPTY
14219: LIST
14220: LIST
14221: PPUSH
14222: CALL_OW 72
14226: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14227: LD_ADDR_VAR 0 7
14231: PUSH
14232: LD_INT 22
14234: PUSH
14235: LD_INT 3
14237: PUSH
14238: EMPTY
14239: LIST
14240: LIST
14241: PUSH
14242: LD_INT 25
14244: PUSH
14245: LD_INT 4
14247: PUSH
14248: EMPTY
14249: LIST
14250: LIST
14251: PUSH
14252: EMPTY
14253: LIST
14254: LIST
14255: PPUSH
14256: CALL_OW 69
14260: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14261: LD_VAR 0 3
14265: NOT
14266: PUSH
14267: LD_EXP 37
14271: NOT
14272: AND
14273: IFFALSE 14333
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14275: LD_VAR 0 4
14279: PPUSH
14280: LD_INT 3
14282: PUSH
14283: LD_INT 54
14285: PUSH
14286: EMPTY
14287: LIST
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: PPUSH
14293: CALL_OW 72
14297: IFFALSE 14331
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14299: LD_VAR 0 4
14303: PPUSH
14304: LD_INT 3
14306: PUSH
14307: LD_INT 54
14309: PUSH
14310: EMPTY
14311: LIST
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PPUSH
14317: CALL_OW 72
14321: PPUSH
14322: LD_VAR 0 5
14326: PPUSH
14327: CALL_OW 120
// exit ;
14331: GO 14757
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14333: LD_VAR 0 4
14337: PPUSH
14338: LD_INT 54
14340: PUSH
14341: EMPTY
14342: LIST
14343: PPUSH
14344: CALL_OW 72
14348: IFFALSE 14370
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14350: LD_VAR 0 4
14354: PPUSH
14355: LD_INT 54
14357: PUSH
14358: EMPTY
14359: LIST
14360: PPUSH
14361: CALL_OW 72
14365: PPUSH
14366: CALL_OW 122
// if not tmp then
14370: LD_VAR 0 3
14374: NOT
14375: IFFALSE 14507
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14377: LD_INT 81
14379: PUSH
14380: LD_INT 3
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PUSH
14387: LD_INT 92
14389: PUSH
14390: LD_INT 147
14392: PUSH
14393: LD_INT 212
14395: PUSH
14396: LD_INT 30
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PPUSH
14409: CALL_OW 69
14413: NOT
14414: IFFALSE 14507
// begin if not HasTask ( engs [ 1 ] ) then
14416: LD_VAR 0 4
14420: PUSH
14421: LD_INT 1
14423: ARRAY
14424: PPUSH
14425: CALL_OW 314
14429: NOT
14430: IFFALSE 14507
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14432: LD_ADDR_VAR 0 2
14436: PUSH
14437: LD_VAR 0 4
14441: PPUSH
14442: LD_EXP 37
14446: PUSH
14447: LD_INT 1
14449: ARRAY
14450: PPUSH
14451: LD_EXP 37
14455: PUSH
14456: LD_INT 2
14458: ARRAY
14459: PPUSH
14460: LD_EXP 37
14464: PUSH
14465: LD_INT 3
14467: ARRAY
14468: PPUSH
14469: LD_EXP 37
14473: PUSH
14474: LD_INT 4
14476: ARRAY
14477: PPUSH
14478: CALL_OW 145
14482: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14483: LD_VAR 0 2
14487: PPUSH
14488: CALL_OW 266
14492: PUSH
14493: LD_INT 4
14495: EQUAL
14496: IFFALSE 14507
// AddComUpgrade ( i ) ;
14498: LD_VAR 0 2
14502: PPUSH
14503: CALL_OW 206
// end ; end ; end ; for i in engs do
14507: LD_ADDR_VAR 0 2
14511: PUSH
14512: LD_VAR 0 4
14516: PUSH
14517: FOR_IN
14518: IFFALSE 14636
// begin if i in to_heal and sci then
14520: LD_VAR 0 2
14524: PUSH
14525: LD_VAR 0 6
14529: IN
14530: PUSH
14531: LD_VAR 0 7
14535: AND
14536: IFFALSE 14587
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14538: LD_VAR 0 2
14542: PPUSH
14543: LD_INT 149
14545: PPUSH
14546: LD_INT 220
14548: PPUSH
14549: CALL_OW 297
14553: PUSH
14554: LD_INT 5
14556: LESS
14557: IFFALSE 14561
// continue ;
14559: GO 14517
// ComMoveXY ( i , 149 , 220 ) ;
14561: LD_VAR 0 2
14565: PPUSH
14566: LD_INT 149
14568: PPUSH
14569: LD_INT 220
14571: PPUSH
14572: CALL_OW 111
// AddComHold ( i ) ;
14576: LD_VAR 0 2
14580: PPUSH
14581: CALL_OW 200
// end else
14585: GO 14634
// if not HasTask ( i ) or WantsToAttack ( i ) then
14587: LD_VAR 0 2
14591: PPUSH
14592: CALL_OW 314
14596: NOT
14597: PUSH
14598: LD_VAR 0 2
14602: PPUSH
14603: CALL_OW 319
14607: OR
14608: IFFALSE 14634
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14610: LD_VAR 0 2
14614: PPUSH
14615: LD_VAR 0 3
14619: PPUSH
14620: LD_VAR 0 2
14624: PPUSH
14625: CALL_OW 74
14629: PPUSH
14630: CALL_OW 130
// end ;
14634: GO 14517
14636: POP
14637: POP
// if to_heal and sci then
14638: LD_VAR 0 6
14642: PUSH
14643: LD_VAR 0 7
14647: AND
14648: IFFALSE 14709
// begin if UnitFilter ( sci , [ f_inside ] ) then
14650: LD_VAR 0 7
14654: PPUSH
14655: LD_INT 54
14657: PUSH
14658: EMPTY
14659: LIST
14660: PPUSH
14661: CALL_OW 72
14665: IFFALSE 14689
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14667: LD_VAR 0 7
14671: PPUSH
14672: LD_INT 54
14674: PUSH
14675: EMPTY
14676: LIST
14677: PPUSH
14678: CALL_OW 72
14682: PPUSH
14683: CALL_OW 122
14687: GO 14707
// ComHeal ( sci , to_heal [ 1 ] ) ;
14689: LD_VAR 0 7
14693: PPUSH
14694: LD_VAR 0 6
14698: PUSH
14699: LD_INT 1
14701: ARRAY
14702: PPUSH
14703: CALL_OW 128
// end else
14707: GO 14757
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14709: LD_VAR 0 7
14713: PPUSH
14714: LD_INT 56
14716: PUSH
14717: EMPTY
14718: LIST
14719: PPUSH
14720: CALL_OW 72
14724: PUSH
14725: LD_VAR 0 8
14729: AND
14730: IFFALSE 14757
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14732: LD_VAR 0 7
14736: PPUSH
14737: LD_INT 56
14739: PUSH
14740: EMPTY
14741: LIST
14742: PPUSH
14743: CALL_OW 72
14747: PPUSH
14748: LD_VAR 0 8
14752: PPUSH
14753: CALL_OW 120
// end ;
14757: PPOPN 8
14759: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14760: LD_INT 22
14762: PUSH
14763: LD_INT 3
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: PUSH
14770: LD_INT 30
14772: PUSH
14773: LD_INT 3
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: PPUSH
14784: CALL_OW 69
14788: PUSH
14789: LD_EXP 38
14793: AND
14794: IFFALSE 14920
14796: GO 14798
14798: DISABLE
14799: LD_INT 0
14801: PPUSH
14802: PPUSH
14803: PPUSH
// begin enable ;
14804: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14805: LD_ADDR_VAR 0 3
14809: PUSH
14810: LD_INT 22
14812: PUSH
14813: LD_INT 3
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: PUSH
14820: LD_INT 30
14822: PUSH
14823: LD_INT 3
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PPUSH
14834: CALL_OW 69
14838: PUSH
14839: LD_INT 1
14841: ARRAY
14842: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14843: LD_VAR 0 3
14847: PPUSH
14848: CALL_OW 313
14852: PUSH
14853: LD_INT 0
14855: EQUAL
14856: IFFALSE 14860
// exit ;
14858: GO 14920
// if BuildingStatus ( fac ) = bs_idle then
14860: LD_VAR 0 3
14864: PPUSH
14865: CALL_OW 461
14869: PUSH
14870: LD_INT 2
14872: EQUAL
14873: IFFALSE 14920
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14875: LD_VAR 0 3
14879: PPUSH
14880: LD_EXP 38
14884: PUSH
14885: LD_INT 1
14887: ARRAY
14888: PPUSH
14889: LD_EXP 38
14893: PUSH
14894: LD_INT 2
14896: ARRAY
14897: PPUSH
14898: LD_EXP 38
14902: PUSH
14903: LD_INT 3
14905: ARRAY
14906: PPUSH
14907: LD_EXP 38
14911: PUSH
14912: LD_INT 4
14914: ARRAY
14915: PPUSH
14916: CALL_OW 125
// end ;
14920: PPOPN 3
14922: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14923: LD_INT 0
14925: PPUSH
14926: PPUSH
14927: PPUSH
14928: PPUSH
14929: PPUSH
// uc_side := 3 ;
14930: LD_ADDR_OWVAR 20
14934: PUSH
14935: LD_INT 3
14937: ST_TO_ADDR
// uc_nation := 3 ;
14938: LD_ADDR_OWVAR 21
14942: PUSH
14943: LD_INT 3
14945: ST_TO_ADDR
// ru_can_attack := false ;
14946: LD_ADDR_EXP 8
14950: PUSH
14951: LD_INT 0
14953: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14954: LD_ADDR_VAR 0 6
14958: PUSH
14959: LD_INT 22
14961: PUSH
14962: LD_INT 3
14964: PUSH
14965: EMPTY
14966: LIST
14967: LIST
14968: PUSH
14969: LD_INT 30
14971: PUSH
14972: LD_INT 3
14974: PUSH
14975: EMPTY
14976: LIST
14977: LIST
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: CALL_OW 69
14987: ST_TO_ADDR
// if fac then
14988: LD_VAR 0 6
14992: IFFALSE 15144
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14994: LD_ADDR_EXP 38
14998: PUSH
14999: LD_INT 24
15001: PUSH
15002: LD_INT 1
15004: PUSH
15005: LD_INT 3
15007: PUSH
15008: LD_INT 43
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: ST_TO_ADDR
// if wave > 1 then
15017: LD_VAR 0 1
15021: PUSH
15022: LD_INT 1
15024: GREATER
15025: IFFALSE 15078
// for i = 1 to Difficulty do
15027: LD_ADDR_VAR 0 3
15031: PUSH
15032: DOUBLE
15033: LD_INT 1
15035: DEC
15036: ST_TO_ADDR
15037: LD_OWVAR 67
15041: PUSH
15042: FOR_TO
15043: IFFALSE 15076
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15045: LD_ADDR_EXP 38
15049: PUSH
15050: LD_EXP 38
15054: PUSH
15055: LD_INT 24
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: LD_INT 3
15063: PUSH
15064: LD_INT 45
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: LIST
15071: LIST
15072: ADD
15073: ST_TO_ADDR
15074: GO 15042
15076: POP
15077: POP
// repeat wait ( 0 0$1 ) ;
15078: LD_INT 35
15080: PPUSH
15081: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15085: LD_EXP 38
15089: PUSH
15090: LD_INT 4
15092: LESS
15093: PUSH
15094: LD_VAR 0 6
15098: PUSH
15099: LD_INT 1
15101: ARRAY
15102: PPUSH
15103: CALL_OW 313
15107: PUSH
15108: LD_INT 0
15110: EQUAL
15111: OR
15112: PUSH
15113: LD_VAR 0 6
15117: PUSH
15118: LD_INT 1
15120: ARRAY
15121: PPUSH
15122: CALL_OW 461
15126: PUSH
15127: LD_INT 8
15129: PUSH
15130: LD_INT 6
15132: PUSH
15133: LD_INT 7
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: LIST
15140: IN
15141: OR
15142: IFFALSE 15078
// end ; case wave of 1 :
15144: LD_VAR 0 1
15148: PUSH
15149: LD_INT 1
15151: DOUBLE
15152: EQUAL
15153: IFTRUE 15157
15155: GO 15242
15157: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
15158: LD_ADDR_VAR 0 3
15162: PUSH
15163: DOUBLE
15164: LD_INT 1
15166: DEC
15167: ST_TO_ADDR
15168: LD_INT 4
15170: PUSH
15171: LD_INT 5
15173: PUSH
15174: LD_INT 5
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: LIST
15181: PUSH
15182: LD_OWVAR 67
15186: ARRAY
15187: PUSH
15188: FOR_TO
15189: IFFALSE 15197
// Sold ;
15191: CALL 15468 0 0
15195: GO 15188
15197: POP
15198: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15199: LD_ADDR_VAR 0 3
15203: PUSH
15204: DOUBLE
15205: LD_INT 1
15207: DEC
15208: ST_TO_ADDR
15209: LD_INT 2
15211: PUSH
15212: LD_INT 3
15214: PUSH
15215: LD_INT 3
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: LIST
15222: PUSH
15223: LD_OWVAR 67
15227: ARRAY
15228: PUSH
15229: FOR_TO
15230: IFFALSE 15238
// Tank ;
15232: CALL 15598 0 0
15236: GO 15229
15238: POP
15239: POP
// end ; 2 .. 9 :
15240: GO 15455
15242: LD_INT 2
15244: DOUBLE
15245: GREATEREQUAL
15246: IFFALSE 15254
15248: LD_INT 9
15250: DOUBLE
15251: LESSEQUAL
15252: IFTRUE 15256
15254: GO 15361
15256: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
15257: LD_ADDR_VAR 0 3
15261: PUSH
15262: DOUBLE
15263: LD_INT 1
15265: DEC
15266: ST_TO_ADDR
15267: LD_INT 4
15269: PUSH
15270: LD_INT 5
15272: PUSH
15273: LD_INT 6
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: LIST
15280: PUSH
15281: LD_OWVAR 67
15285: ARRAY
15286: PUSH
15287: LD_VAR 0 1
15291: PUSH
15292: LD_INT 2
15294: DIV
15295: PLUS
15296: PUSH
15297: FOR_TO
15298: IFFALSE 15306
// Sold ;
15300: CALL 15468 0 0
15304: GO 15297
15306: POP
15307: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15308: LD_ADDR_VAR 0 3
15312: PUSH
15313: DOUBLE
15314: LD_INT 1
15316: DEC
15317: ST_TO_ADDR
15318: LD_INT 2
15320: PUSH
15321: LD_INT 3
15323: PUSH
15324: LD_INT 3
15326: PUSH
15327: EMPTY
15328: LIST
15329: LIST
15330: LIST
15331: PUSH
15332: LD_OWVAR 67
15336: ARRAY
15337: PUSH
15338: LD_VAR 0 1
15342: PUSH
15343: LD_INT 2
15345: DIV
15346: PLUS
15347: PUSH
15348: FOR_TO
15349: IFFALSE 15357
// Tank ;
15351: CALL 15598 0 0
15355: GO 15348
15357: POP
15358: POP
// end ; 10 :
15359: GO 15455
15361: LD_INT 10
15363: DOUBLE
15364: EQUAL
15365: IFTRUE 15369
15367: GO 15454
15369: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15370: LD_ADDR_VAR 0 3
15374: PUSH
15375: DOUBLE
15376: LD_INT 1
15378: DEC
15379: ST_TO_ADDR
15380: LD_INT 10
15382: PUSH
15383: LD_INT 12
15385: PUSH
15386: LD_INT 14
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: LIST
15393: PUSH
15394: LD_OWVAR 67
15398: ARRAY
15399: PUSH
15400: FOR_TO
15401: IFFALSE 15409
// Sold ;
15403: CALL 15468 0 0
15407: GO 15400
15409: POP
15410: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: DOUBLE
15417: LD_INT 1
15419: DEC
15420: ST_TO_ADDR
15421: LD_INT 11
15423: PUSH
15424: LD_INT 13
15426: PUSH
15427: LD_INT 15
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: LIST
15434: PUSH
15435: LD_OWVAR 67
15439: ARRAY
15440: PUSH
15441: FOR_TO
15442: IFFALSE 15450
// Tank ;
15444: CALL 15598 0 0
15448: GO 15441
15450: POP
15451: POP
// end ; end ;
15452: GO 15455
15454: POP
// ru_can_attack := true ;
15455: LD_ADDR_EXP 8
15459: PUSH
15460: LD_INT 1
15462: ST_TO_ADDR
// end ;
15463: LD_VAR 0 2
15467: RET
// function Sold ( ) ; var un , skill ; begin
15468: LD_INT 0
15470: PPUSH
15471: PPUSH
15472: PPUSH
// uc_side := 3 ;
15473: LD_ADDR_OWVAR 20
15477: PUSH
15478: LD_INT 3
15480: ST_TO_ADDR
// uc_nation := 3 ;
15481: LD_ADDR_OWVAR 21
15485: PUSH
15486: LD_INT 3
15488: ST_TO_ADDR
// InitHc ;
15489: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15493: LD_ADDR_VAR 0 3
15497: PUSH
15498: LD_INT 6
15500: PUSH
15501: LD_INT 7
15503: PUSH
15504: LD_INT 7
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: LIST
15511: PUSH
15512: LD_OWVAR 67
15516: ARRAY
15517: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15518: LD_INT 0
15520: PPUSH
15521: LD_INT 1
15523: PUSH
15524: LD_INT 9
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: PUSH
15531: LD_INT 1
15533: PPUSH
15534: LD_INT 2
15536: PPUSH
15537: CALL_OW 12
15541: ARRAY
15542: PPUSH
15543: LD_VAR 0 3
15547: PPUSH
15548: CALL_OW 380
// un := CreateHuman ;
15552: LD_ADDR_VAR 0 2
15556: PUSH
15557: CALL_OW 44
15561: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15562: LD_VAR 0 2
15566: PPUSH
15567: LD_INT 4
15569: PPUSH
15570: LD_INT 0
15572: PPUSH
15573: CALL_OW 49
// ru_force := ru_force ^ un ;
15577: LD_ADDR_EXP 36
15581: PUSH
15582: LD_EXP 36
15586: PUSH
15587: LD_VAR 0 2
15591: ADD
15592: ST_TO_ADDR
// end ;
15593: LD_VAR 0 1
15597: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15598: LD_INT 0
15600: PPUSH
15601: PPUSH
15602: PPUSH
15603: PPUSH
15604: PPUSH
// uc_side := 3 ;
15605: LD_ADDR_OWVAR 20
15609: PUSH
15610: LD_INT 3
15612: ST_TO_ADDR
// uc_nation := 3 ;
15613: LD_ADDR_OWVAR 21
15617: PUSH
15618: LD_INT 3
15620: ST_TO_ADDR
// InitHc ;
15621: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15625: LD_ADDR_VAR 0 5
15629: PUSH
15630: LD_INT 5
15632: PUSH
15633: LD_INT 6
15635: PUSH
15636: LD_INT 7
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: LIST
15643: PUSH
15644: LD_OWVAR 67
15648: ARRAY
15649: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15650: LD_ADDR_VAR 0 3
15654: PUSH
15655: LD_INT 22
15657: PUSH
15658: LD_INT 24
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: PUSH
15665: LD_INT 1
15667: PPUSH
15668: LD_INT 2
15670: PPUSH
15671: CALL_OW 12
15675: ARRAY
15676: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15677: LD_VAR 0 3
15681: PUSH
15682: LD_INT 22
15684: EQUAL
15685: IFFALSE 15720
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15687: LD_ADDR_VAR 0 4
15691: PUSH
15692: LD_INT 45
15694: PUSH
15695: LD_INT 43
15697: PUSH
15698: LD_INT 44
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: LIST
15705: PUSH
15706: LD_INT 1
15708: PPUSH
15709: LD_INT 3
15711: PPUSH
15712: CALL_OW 12
15716: ARRAY
15717: ST_TO_ADDR
15718: GO 15751
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15720: LD_ADDR_VAR 0 4
15724: PUSH
15725: LD_INT 46
15727: PUSH
15728: LD_INT 44
15730: PUSH
15731: LD_INT 45
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: LIST
15738: PUSH
15739: LD_INT 1
15741: PPUSH
15742: LD_INT 3
15744: PPUSH
15745: CALL_OW 12
15749: ARRAY
15750: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15751: LD_ADDR_VAR 0 2
15755: PUSH
15756: LD_INT 3
15758: PPUSH
15759: LD_INT 3
15761: PPUSH
15762: LD_VAR 0 3
15766: PPUSH
15767: LD_INT 1
15769: PPUSH
15770: LD_INT 3
15772: PUSH
15773: LD_INT 3
15775: PUSH
15776: LD_INT 3
15778: PUSH
15779: LD_INT 1
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: LIST
15786: LIST
15787: PUSH
15788: LD_INT 1
15790: PPUSH
15791: LD_INT 4
15793: PPUSH
15794: CALL_OW 12
15798: ARRAY
15799: PPUSH
15800: LD_VAR 0 4
15804: PPUSH
15805: LD_INT 99
15807: PPUSH
15808: CALL 289 0 7
15812: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15813: LD_VAR 0 2
15817: PPUSH
15818: CALL_OW 263
15822: PUSH
15823: LD_INT 1
15825: EQUAL
15826: IFFALSE 15857
// begin PrepareHuman ( false , 3 , skill ) ;
15828: LD_INT 0
15830: PPUSH
15831: LD_INT 3
15833: PPUSH
15834: LD_VAR 0 5
15838: PPUSH
15839: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15843: CALL_OW 44
15847: PPUSH
15848: LD_VAR 0 2
15852: PPUSH
15853: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15857: LD_VAR 0 2
15861: PPUSH
15862: LD_INT 3
15864: PPUSH
15865: LD_INT 0
15867: PPUSH
15868: CALL_OW 49
// ru_force := ru_force ^ un ;
15872: LD_ADDR_EXP 36
15876: PUSH
15877: LD_EXP 36
15881: PUSH
15882: LD_VAR 0 2
15886: ADD
15887: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15888: LD_VAR 0 2
15892: PPUSH
15893: LD_INT 126
15895: PPUSH
15896: LD_INT 158
15898: PPUSH
15899: CALL_OW 111
// Wait ( 0 0$3 ) ;
15903: LD_INT 105
15905: PPUSH
15906: CALL_OW 67
// ComStop ( un ) ;
15910: LD_VAR 0 2
15914: PPUSH
15915: CALL_OW 141
// end ;
15919: LD_VAR 0 1
15923: RET
// every 0 0$1 do var i , time , wave ;
15924: GO 15926
15926: DISABLE
15927: LD_INT 0
15929: PPUSH
15930: PPUSH
15931: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15932: LD_ADDR_VAR 0 2
15936: PUSH
15937: LD_INT 25200
15939: PUSH
15940: LD_INT 24150
15942: PUSH
15943: LD_INT 23100
15945: PUSH
15946: EMPTY
15947: LIST
15948: LIST
15949: LIST
15950: PUSH
15951: LD_OWVAR 67
15955: ARRAY
15956: ST_TO_ADDR
// wait ( time ) ;
15957: LD_VAR 0 2
15961: PPUSH
15962: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15966: LD_ADDR_VAR 0 2
15970: PUSH
15971: LD_INT 15750
15973: PUSH
15974: LD_INT 15050
15976: PUSH
15977: LD_INT 14350
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: LIST
15984: PUSH
15985: LD_OWVAR 67
15989: ARRAY
15990: ST_TO_ADDR
// wave := 0 ;
15991: LD_ADDR_VAR 0 3
15995: PUSH
15996: LD_INT 0
15998: ST_TO_ADDR
// while true do
15999: LD_INT 1
16001: IFFALSE 16098
// begin wave := wave + 1 ;
16003: LD_ADDR_VAR 0 3
16007: PUSH
16008: LD_VAR 0 3
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16017: LD_INT 22
16019: PUSH
16020: LD_INT 2
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PPUSH
16027: CALL_OW 69
16031: IFFALSE 16060
// repeat wait ( 0 0$1 ) ;
16033: LD_INT 35
16035: PPUSH
16036: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16040: LD_INT 22
16042: PUSH
16043: LD_INT 2
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: PPUSH
16050: CALL_OW 69
16054: PUSH
16055: LD_INT 0
16057: EQUAL
16058: IFFALSE 16033
// if ru_force < 20 then
16060: LD_EXP 36
16064: PUSH
16065: LD_INT 20
16067: LESS
16068: IFFALSE 16079
// PrepareAttack ( wave ) ;
16070: LD_VAR 0 3
16074: PPUSH
16075: CALL 14923 0 1
// ru_can_attack := true ;
16079: LD_ADDR_EXP 8
16083: PUSH
16084: LD_INT 1
16086: ST_TO_ADDR
// wait ( time ) ;
16087: LD_VAR 0 2
16091: PPUSH
16092: CALL_OW 67
// end ;
16096: GO 15999
// end ;
16098: PPOPN 3
16100: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16101: LD_EXP 8
16105: PUSH
16106: LD_EXP 36
16110: AND
16111: IFFALSE 16945
16113: GO 16115
16115: DISABLE
16116: LD_INT 0
16118: PPUSH
16119: PPUSH
16120: PPUSH
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
16126: PPUSH
// begin enable ;
16127: ENABLE
// points1 := [ 107 , 123 ] ;
16128: LD_ADDR_VAR 0 4
16132: PUSH
16133: LD_INT 107
16135: PUSH
16136: LD_INT 123
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16143: LD_ADDR_VAR 0 5
16147: PUSH
16148: LD_INT 55
16150: PUSH
16151: LD_INT 42
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16158: LD_ADDR_VAR 0 6
16162: PUSH
16163: LD_INT 102
16165: PUSH
16166: LD_INT 140
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PUSH
16173: LD_INT 105
16175: PUSH
16176: LD_INT 142
16178: PUSH
16179: EMPTY
16180: LIST
16181: LIST
16182: PUSH
16183: LD_INT 129
16185: PUSH
16186: LD_INT 131
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: LIST
16197: ST_TO_ADDR
// for i in ru_force do
16198: LD_ADDR_VAR 0 1
16202: PUSH
16203: LD_EXP 36
16207: PUSH
16208: FOR_IN
16209: IFFALSE 16943
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16211: LD_ADDR_VAR 0 3
16215: PUSH
16216: LD_INT 81
16218: PUSH
16219: LD_INT 3
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: PPUSH
16226: CALL_OW 69
16230: PPUSH
16231: LD_VAR 0 1
16235: PPUSH
16236: CALL_OW 74
16240: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16241: LD_VAR 0 1
16245: PPUSH
16246: LD_VAR 0 3
16250: PPUSH
16251: CALL_OW 296
16255: PUSH
16256: LD_INT 12
16258: LESS
16259: IFFALSE 16404
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16261: LD_VAR 0 1
16265: PPUSH
16266: CALL_OW 247
16270: PUSH
16271: LD_INT 1
16273: EQUAL
16274: PUSH
16275: LD_VAR 0 1
16279: PPUSH
16280: CALL_OW 257
16284: PUSH
16285: LD_INT 1
16287: EQUAL
16288: AND
16289: PUSH
16290: LD_VAR 0 3
16294: PUSH
16295: LD_INT 21
16297: PUSH
16298: LD_INT 2
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PUSH
16305: LD_INT 58
16307: PUSH
16308: EMPTY
16309: LIST
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: PPUSH
16315: CALL_OW 69
16319: IN
16320: AND
16321: IFFALSE 16339
// ComEnterUnit ( i , un ) else
16323: LD_VAR 0 1
16327: PPUSH
16328: LD_VAR 0 3
16332: PPUSH
16333: CALL_OW 120
16337: GO 16402
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16339: LD_VAR 0 3
16343: PUSH
16344: LD_INT 21
16346: PUSH
16347: LD_INT 2
16349: PUSH
16350: EMPTY
16351: LIST
16352: LIST
16353: PUSH
16354: LD_INT 58
16356: PUSH
16357: EMPTY
16358: LIST
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PPUSH
16364: CALL_OW 69
16368: IN
16369: NOT
16370: IFFALSE 16388
// ComAttackUnit ( i , un ) else
16372: LD_VAR 0 1
16376: PPUSH
16377: LD_VAR 0 3
16381: PPUSH
16382: CALL_OW 115
16386: GO 16402
// ComAttackUnit ( i , JMM ) ;
16388: LD_VAR 0 1
16392: PPUSH
16393: LD_EXP 19
16397: PPUSH
16398: CALL_OW 115
// end else
16402: GO 16941
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16404: LD_VAR 0 1
16408: PPUSH
16409: LD_VAR 0 4
16413: PUSH
16414: LD_INT 1
16416: ARRAY
16417: PPUSH
16418: LD_VAR 0 4
16422: PUSH
16423: LD_INT 2
16425: ARRAY
16426: PPUSH
16427: CALL_OW 297
16431: PUSH
16432: LD_VAR 0 1
16436: PPUSH
16437: LD_VAR 0 5
16441: PUSH
16442: LD_INT 1
16444: ARRAY
16445: PPUSH
16446: LD_VAR 0 5
16450: PUSH
16451: LD_INT 2
16453: ARRAY
16454: PPUSH
16455: CALL_OW 297
16459: GREATER
16460: PUSH
16461: LD_EXP 9
16465: AND
16466: PUSH
16467: LD_INT 9
16469: PPUSH
16470: LD_INT 81
16472: PUSH
16473: LD_INT 3
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: PPUSH
16480: CALL_OW 70
16484: PUSH
16485: LD_INT 0
16487: EQUAL
16488: OR
16489: IFFALSE 16527
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16491: LD_VAR 0 1
16495: PPUSH
16496: LD_INT 81
16498: PUSH
16499: LD_INT 3
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PPUSH
16506: CALL_OW 69
16510: PPUSH
16511: LD_VAR 0 1
16515: PPUSH
16516: CALL_OW 74
16520: PPUSH
16521: CALL_OW 115
16525: GO 16941
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16527: LD_VAR 0 1
16531: PPUSH
16532: CALL_OW 264
16536: PUSH
16537: LD_INT 45
16539: EQUAL
16540: PUSH
16541: LD_EXP 36
16545: PPUSH
16546: LD_INT 3
16548: PUSH
16549: LD_INT 34
16551: PUSH
16552: LD_INT 45
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: PPUSH
16563: CALL_OW 72
16567: PUSH
16568: LD_INT 6
16570: GREATER
16571: AND
16572: IFFALSE 16753
// begin dist := 9999 ;
16574: LD_ADDR_VAR 0 8
16578: PUSH
16579: LD_INT 9999
16581: ST_TO_ADDR
// xy := 0 ;
16582: LD_ADDR_VAR 0 9
16586: PUSH
16587: LD_INT 0
16589: ST_TO_ADDR
// for x in pointsr do
16590: LD_ADDR_VAR 0 7
16594: PUSH
16595: LD_VAR 0 6
16599: PUSH
16600: FOR_IN
16601: IFFALSE 16749
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16603: LD_VAR 0 1
16607: PPUSH
16608: LD_VAR 0 7
16612: PUSH
16613: LD_INT 1
16615: ARRAY
16616: PPUSH
16617: LD_VAR 0 7
16621: PUSH
16622: LD_INT 2
16624: ARRAY
16625: PPUSH
16626: CALL_OW 297
16630: PUSH
16631: LD_VAR 0 8
16635: LESS
16636: IFFALSE 16681
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16638: LD_ADDR_VAR 0 8
16642: PUSH
16643: LD_VAR 0 1
16647: PPUSH
16648: LD_VAR 0 7
16652: PUSH
16653: LD_INT 1
16655: ARRAY
16656: PPUSH
16657: LD_VAR 0 7
16661: PUSH
16662: LD_INT 2
16664: ARRAY
16665: PPUSH
16666: CALL_OW 297
16670: ST_TO_ADDR
// xy := x ;
16671: LD_ADDR_VAR 0 9
16675: PUSH
16676: LD_VAR 0 7
16680: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16681: LD_VAR 0 9
16685: PUSH
16686: LD_VAR 0 1
16690: PPUSH
16691: LD_VAR 0 9
16695: PUSH
16696: LD_INT 1
16698: ARRAY
16699: PPUSH
16700: LD_VAR 0 9
16704: PUSH
16705: LD_INT 2
16707: ARRAY
16708: PPUSH
16709: CALL_OW 297
16713: PUSH
16714: LD_INT 9
16716: GREATER
16717: AND
16718: IFFALSE 16747
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16720: LD_VAR 0 1
16724: PPUSH
16725: LD_VAR 0 9
16729: PUSH
16730: LD_INT 1
16732: ARRAY
16733: PPUSH
16734: LD_VAR 0 9
16738: PUSH
16739: LD_INT 2
16741: ARRAY
16742: PPUSH
16743: CALL_OW 114
// end ;
16747: GO 16600
16749: POP
16750: POP
// end else
16751: GO 16941
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16753: LD_ADDR_VAR 0 3
16757: PUSH
16758: LD_OWVAR 3
16762: PUSH
16763: LD_VAR 0 1
16767: DIFF
16768: PPUSH
16769: LD_VAR 0 1
16773: PPUSH
16774: CALL_OW 74
16778: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16779: LD_VAR 0 1
16783: PPUSH
16784: CALL_OW 320
16788: NOT
16789: PUSH
16790: LD_VAR 0 3
16794: PUSH
16795: LD_INT 21
16797: PUSH
16798: LD_INT 2
16800: PUSH
16801: EMPTY
16802: LIST
16803: LIST
16804: PUSH
16805: LD_INT 33
16807: PUSH
16808: LD_INT 1
16810: PUSH
16811: EMPTY
16812: LIST
16813: LIST
16814: PUSH
16815: LD_INT 58
16817: PUSH
16818: EMPTY
16819: LIST
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: LIST
16825: PPUSH
16826: CALL_OW 69
16830: IN
16831: PUSH
16832: LD_VAR 0 3
16836: PUSH
16837: LD_INT 22
16839: PUSH
16840: LD_INT 3
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 21
16849: PUSH
16850: LD_INT 2
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: LD_INT 3
16859: PUSH
16860: LD_INT 24
16862: PUSH
16863: LD_INT 249
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: LIST
16878: PPUSH
16879: CALL_OW 69
16883: IN
16884: OR
16885: AND
16886: IFFALSE 16904
// ComAttackUnit ( i , un ) else
16888: LD_VAR 0 1
16892: PPUSH
16893: LD_VAR 0 3
16897: PPUSH
16898: CALL_OW 115
16902: GO 16941
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16904: LD_VAR 0 1
16908: PPUSH
16909: LD_INT 9
16911: PPUSH
16912: LD_INT 81
16914: PUSH
16915: LD_INT 3
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 70
16926: PPUSH
16927: LD_VAR 0 1
16931: PPUSH
16932: CALL_OW 74
16936: PPUSH
16937: CALL_OW 115
// end ; end ; end ; end ;
16941: GO 16208
16943: POP
16944: POP
// end ;
16945: PPOPN 9
16947: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16948: LD_INT 22
16950: PUSH
16951: LD_INT 3
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: PUSH
16958: LD_INT 32
16960: PUSH
16961: LD_INT 1
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PPUSH
16972: CALL_OW 69
16976: IFFALSE 17064
16978: GO 16980
16980: DISABLE
16981: LD_INT 0
16983: PPUSH
16984: PPUSH
// begin enable ;
16985: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16986: LD_ADDR_VAR 0 2
16990: PUSH
16991: LD_INT 22
16993: PUSH
16994: LD_INT 3
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: PUSH
17001: LD_INT 32
17003: PUSH
17004: LD_INT 1
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PPUSH
17015: CALL_OW 69
17019: ST_TO_ADDR
// for i in tmp do
17020: LD_ADDR_VAR 0 1
17024: PUSH
17025: LD_VAR 0 2
17029: PUSH
17030: FOR_IN
17031: IFFALSE 17062
// if GetFuel ( i ) < 12 then
17033: LD_VAR 0 1
17037: PPUSH
17038: CALL_OW 261
17042: PUSH
17043: LD_INT 12
17045: LESS
17046: IFFALSE 17060
// SetFuel ( i , 12 ) ;
17048: LD_VAR 0 1
17052: PPUSH
17053: LD_INT 12
17055: PPUSH
17056: CALL_OW 240
17060: GO 17030
17062: POP
17063: POP
// end ;
17064: PPOPN 2
17066: END
// every 0 0$1 trigger can_end do
17067: LD_EXP 17
17071: IFFALSE 17090
17073: GO 17075
17075: DISABLE
// begin Wait ( 1 1$35 ) ;
17076: LD_INT 3325
17078: PPUSH
17079: CALL_OW 67
// PrepareAttack ( 10 ) ;
17083: LD_INT 10
17085: PPUSH
17086: CALL 14923 0 1
// end ;
17090: END
