// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12644 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1708 0 0
// Action ;
  32: CALL 2648 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1641: LD_STRING GammaCommander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1676
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1676: LD_ADDR_EXP 25
1680: PUSH
1681: LD_STRING Powell
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_STRING 
1689: PPUSH
1690: CALL 201 0 3
1694: ST_TO_ADDR
// InitHc ;
1695: CALL_OW 19
// InitUc ;
1699: CALL_OW 18
// end ;
1703: LD_VAR 0 1
1707: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1708: LD_INT 0
1710: PPUSH
1711: PPUSH
1712: PPUSH
1713: PPUSH
1714: PPUSH
// uc_side := 4 ;
1715: LD_ADDR_OWVAR 20
1719: PUSH
1720: LD_INT 4
1722: ST_TO_ADDR
// uc_nation := 3 ;
1723: LD_ADDR_OWVAR 21
1727: PUSH
1728: LD_INT 3
1730: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_STRING 09_ovsyenko_base
1738: PPUSH
1739: LD_INT 0
1741: PUSH
1742: LD_INT 101
1744: PUSH
1745: LD_INT 118
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 500
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: LD_INT 31
1763: PUSH
1764: LD_INT 109
1766: PUSH
1767: LD_INT 114
1769: PUSH
1770: LD_INT 4
1772: PUSH
1773: LD_INT 500
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 31
1785: PUSH
1786: LD_INT 115
1788: PUSH
1789: LD_INT 132
1791: PUSH
1792: LD_INT 5
1794: PUSH
1795: LD_INT 500
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 31
1807: PUSH
1808: LD_INT 98
1810: PUSH
1811: LD_INT 120
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 500
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL_OW 30
1837: ST_TO_ADDR
// for i in tmp do
1838: LD_ADDR_VAR 0 2
1842: PUSH
1843: LD_VAR 0 4
1847: PUSH
1848: FOR_IN
1849: IFFALSE 2005
// begin bc_type := i [ 1 ] ;
1851: LD_ADDR_OWVAR 42
1855: PUSH
1856: LD_VAR 0 2
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: ST_TO_ADDR
// bc_level := 3 ;
1865: LD_ADDR_OWVAR 43
1869: PUSH
1870: LD_INT 3
1872: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_VAR 0 2
1882: PUSH
1883: LD_INT 2
1885: ARRAY
1886: PPUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_INT 3
1894: ARRAY
1895: PPUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 4
1903: ARRAY
1904: PPUSH
1905: CALL_OW 47
1909: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1910: LD_VAR 0 3
1914: PPUSH
1915: CALL_OW 266
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: IFFALSE 1957
// begin SetBName ( b , ovsyenko ) ;
1925: LD_VAR 0 3
1929: PPUSH
1930: LD_STRING ovsyenko
1932: PPUSH
1933: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1937: LD_VAR 0 3
1941: PPUSH
1942: CALL_OW 274
1946: PPUSH
1947: LD_INT 1
1949: PPUSH
1950: LD_INT 50
1952: PPUSH
1953: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 5
1964: ARRAY
1965: PUSH
1966: LD_INT 250
1968: LESS
1969: IFFALSE 1985
// SetLives ( b , 333 ) else
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_INT 333
1978: PPUSH
1979: CALL_OW 234
1983: GO 2003
// SetLives ( b , i [ 5 ] ) ;
1985: LD_VAR 0 3
1989: PPUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 5
1997: ARRAY
1998: PPUSH
1999: CALL_OW 234
// end ;
2003: GO 1848
2005: POP
2006: POP
// uc_nation := 1 ;
2007: LD_ADDR_OWVAR 21
2011: PUSH
2012: LD_INT 1
2014: ST_TO_ADDR
// tmp := [ ] ;
2015: LD_ADDR_VAR 0 4
2019: PUSH
2020: EMPTY
2021: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2022: LD_ADDR_EXP 19
2026: PUSH
2027: LD_STRING Gary
2029: PPUSH
2030: LD_EXP 2
2034: NOT
2035: PPUSH
2036: LD_STRING 
2038: PPUSH
2039: CALL 201 0 3
2043: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2044: LD_ADDR_VAR 0 4
2048: PUSH
2049: LD_VAR 0 4
2053: PUSH
2054: LD_EXP 19
2058: ADD
2059: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2060: LD_ADDR_EXP 20
2064: PUSH
2065: LD_STRING Bobby
2067: PPUSH
2068: LD_EXP 2
2072: NOT
2073: PPUSH
2074: LD_STRING 08_
2076: PPUSH
2077: CALL 201 0 3
2081: ST_TO_ADDR
// if not Bobby then
2082: LD_EXP 20
2086: NOT
2087: IFFALSE 2111
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2089: LD_ADDR_EXP 20
2093: PUSH
2094: LD_STRING Bobby
2096: PPUSH
2097: LD_EXP 2
2101: NOT
2102: PPUSH
2103: LD_STRING 03_
2105: PPUSH
2106: CALL 201 0 3
2110: ST_TO_ADDR
// if Bobby then
2111: LD_EXP 20
2115: IFFALSE 2133
// tmp := tmp ^ Bobby ;
2117: LD_ADDR_VAR 0 4
2121: PUSH
2122: LD_VAR 0 4
2126: PUSH
2127: LD_EXP 20
2131: ADD
2132: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2133: LD_ADDR_EXP 21
2137: PUSH
2138: LD_STRING Cyrus
2140: PPUSH
2141: LD_EXP 2
2145: NOT
2146: PPUSH
2147: LD_STRING 08_
2149: PPUSH
2150: CALL 201 0 3
2154: ST_TO_ADDR
// if not Cyrus then
2155: LD_EXP 21
2159: NOT
2160: IFFALSE 2184
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2162: LD_ADDR_EXP 21
2166: PUSH
2167: LD_STRING Cyrus
2169: PPUSH
2170: LD_EXP 2
2174: NOT
2175: PPUSH
2176: LD_STRING 03_
2178: PPUSH
2179: CALL 201 0 3
2183: ST_TO_ADDR
// if Cyrus then
2184: LD_EXP 21
2188: IFFALSE 2206
// tmp := tmp ^ Cyrus ;
2190: LD_ADDR_VAR 0 4
2194: PUSH
2195: LD_VAR 0 4
2199: PUSH
2200: LD_EXP 21
2204: ADD
2205: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2206: LD_ADDR_VAR 0 4
2210: PUSH
2211: LD_VAR 0 4
2215: PUSH
2216: LD_STRING 09_prev_squad
2218: PPUSH
2219: CALL_OW 31
2223: ADD
2224: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2225: LD_STRING 09_prev_squad
2227: PPUSH
2228: CALL_OW 40
// tmp := tmp diff 0 ;
2232: LD_ADDR_VAR 0 4
2236: PUSH
2237: LD_VAR 0 4
2241: PUSH
2242: LD_INT 0
2244: DIFF
2245: ST_TO_ADDR
// if debug then
2246: LD_EXP 2
2250: IFFALSE 2301
// begin for i = 1 to 6 do
2252: LD_ADDR_VAR 0 2
2256: PUSH
2257: DOUBLE
2258: LD_INT 1
2260: DEC
2261: ST_TO_ADDR
2262: LD_INT 6
2264: PUSH
2265: FOR_TO
2266: IFFALSE 2299
// begin PrepareHuman ( false , 1 , 6 ) ;
2268: LD_INT 0
2270: PPUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 6
2276: PPUSH
2277: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: CALL_OW 44
2295: ADD
2296: ST_TO_ADDR
// end ;
2297: GO 2265
2299: POP
2300: POP
// end ; for i in tmp do
2301: LD_ADDR_VAR 0 2
2305: PUSH
2306: LD_VAR 0 4
2310: PUSH
2311: FOR_IN
2312: IFFALSE 2371
// begin if GetClass ( i ) in [ 2 , 3 ] then
2314: LD_VAR 0 2
2318: PPUSH
2319: CALL_OW 257
2323: PUSH
2324: LD_INT 2
2326: PUSH
2327: LD_INT 3
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: IN
2334: IFFALSE 2348
// SetClass ( i , 1 ) ;
2336: LD_VAR 0 2
2340: PPUSH
2341: LD_INT 1
2343: PPUSH
2344: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2348: LD_VAR 0 2
2352: PPUSH
2353: LD_INT 106
2355: PPUSH
2356: LD_INT 122
2358: PPUSH
2359: LD_INT 5
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 50
// end ;
2369: GO 2311
2371: POP
2372: POP
// tmp := tmp diff Gary ;
2373: LD_ADDR_VAR 0 4
2377: PUSH
2378: LD_VAR 0 4
2382: PUSH
2383: LD_EXP 19
2387: DIFF
2388: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2389: LD_ADDR_VAR 0 3
2393: PUSH
2394: LD_INT 22
2396: PUSH
2397: LD_INT 4
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PUSH
2404: LD_INT 30
2406: PUSH
2407: LD_INT 31
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: PPUSH
2418: CALL_OW 69
2422: ST_TO_ADDR
// for i = 1 to b do
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: DOUBLE
2429: LD_INT 1
2431: DEC
2432: ST_TO_ADDR
2433: LD_VAR 0 3
2437: PUSH
2438: FOR_TO
2439: IFFALSE 2469
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2441: LD_VAR 0 4
2445: PUSH
2446: LD_VAR 0 2
2450: ARRAY
2451: PPUSH
2452: LD_VAR 0 3
2456: PUSH
2457: LD_VAR 0 2
2461: ARRAY
2462: PPUSH
2463: CALL_OW 120
// end ;
2467: GO 2438
2469: POP
2470: POP
// InitHc ;
2471: CALL_OW 19
// InitUc ;
2475: CALL_OW 18
// end ;
2479: LD_VAR 0 1
2483: RET
// export function PowellTransport ; var i , un ; begin
2484: LD_INT 0
2486: PPUSH
2487: PPUSH
2488: PPUSH
// uc_side := 4 ;
2489: LD_ADDR_OWVAR 20
2493: PUSH
2494: LD_INT 4
2496: ST_TO_ADDR
// uc_nation := 1 ;
2497: LD_ADDR_OWVAR 21
2501: PUSH
2502: LD_INT 1
2504: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2505: LD_INT 1
2507: PPUSH
2508: LD_INT 3
2510: PPUSH
2511: LD_INT 6
2513: PPUSH
2514: CALL_OW 380
// hc_name :=  ;
2518: LD_ADDR_OWVAR 26
2522: PUSH
2523: LD_STRING 
2525: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2526: LD_ADDR_OWVAR 33
2530: PUSH
2531: LD_STRING SecondCharsGal
2533: ST_TO_ADDR
// hc_face_number := 30 ;
2534: LD_ADDR_OWVAR 34
2538: PUSH
2539: LD_INT 30
2541: ST_TO_ADDR
// powell_trans := CreateHuman ;
2542: LD_ADDR_EXP 24
2546: PUSH
2547: CALL_OW 44
2551: ST_TO_ADDR
// hc_face_number := 31 ;
2552: LD_ADDR_OWVAR 34
2556: PUSH
2557: LD_INT 31
2559: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2560: LD_ADDR_EXP 24
2564: PUSH
2565: LD_EXP 24
2569: PUSH
2570: CALL_OW 44
2574: ADD
2575: ST_TO_ADDR
// for i = 1 to 2 do
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: DOUBLE
2582: LD_INT 1
2584: DEC
2585: ST_TO_ADDR
2586: LD_INT 2
2588: PUSH
2589: FOR_TO
2590: IFFALSE 2641
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2592: LD_ADDR_VAR 0 3
2596: PUSH
2597: LD_INT 4
2599: PPUSH
2600: LD_INT 1
2602: PPUSH
2603: LD_INT 3
2605: PPUSH
2606: LD_INT 1
2608: PPUSH
2609: LD_INT 1
2611: PPUSH
2612: LD_INT 12
2614: PPUSH
2615: LD_INT 66
2617: PPUSH
2618: CALL 264 0 7
2622: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2623: LD_ADDR_EXP 24
2627: PUSH
2628: LD_EXP 24
2632: PUSH
2633: LD_VAR 0 3
2637: ADD
2638: ST_TO_ADDR
// end ;
2639: GO 2589
2641: POP
2642: POP
// end ; end_of_file
2643: LD_VAR 0 1
2647: RET
// export function Action ; var i , veh ; begin
2648: LD_INT 0
2650: PPUSH
2651: PPUSH
2652: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2653: LD_EXP 23
2657: PPUSH
2658: LD_INT 0
2660: PPUSH
2661: LD_INT 50
2663: PPUSH
2664: LD_INT 38
2666: PPUSH
2667: LD_INT 2
2669: PPUSH
2670: CALL_OW 145
// InGameOn ;
2674: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2678: LD_INT 43
2680: PPUSH
2681: LD_INT 9
2683: PPUSH
2684: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2688: LD_EXP 18
2692: PPUSH
2693: LD_INT 54
2695: PPUSH
2696: LD_INT 34
2698: PPUSH
2699: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2703: LD_EXP 18
2707: PPUSH
2708: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2712: LD_EXP 18
2716: PPUSH
2717: LD_EXP 23
2721: PUSH
2722: LD_INT 1
2724: ARRAY
2725: PPUSH
2726: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2730: LD_INT 35
2732: PPUSH
2733: CALL_OW 67
// until See ( 4 , JMM ) ;
2737: LD_INT 4
2739: PPUSH
2740: LD_EXP 18
2744: PPUSH
2745: CALL_OW 292
2749: IFFALSE 2730
// CenterNowOnUnits ( JMM ) ;
2751: LD_EXP 18
2755: PPUSH
2756: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2760: LD_EXP 18
2764: PPUSH
2765: LD_STRING D2-JMM-1
2767: PPUSH
2768: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2772: LD_EXP 23
2776: PUSH
2777: LD_INT 3
2779: ARRAY
2780: PPUSH
2781: LD_EXP 18
2785: PPUSH
2786: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2790: LD_EXP 23
2794: PUSH
2795: LD_INT 3
2797: ARRAY
2798: PPUSH
2799: LD_STRING D2-Eng1-1
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2806: LD_EXP 18
2810: PPUSH
2811: LD_STRING D2-JMM-2
2813: PPUSH
2814: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2818: LD_EXP 23
2822: PUSH
2823: LD_INT 3
2825: ARRAY
2826: PPUSH
2827: LD_STRING D2-Eng1-2
2829: PPUSH
2830: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2834: LD_EXP 18
2838: PPUSH
2839: LD_STRING D2-JMM-3
2841: PPUSH
2842: CALL_OW 88
// if Houten then
2846: LD_EXP 22
2850: IFFALSE 3048
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2852: LD_ADDR_VAR 0 3
2856: PUSH
2857: LD_INT 4
2859: PPUSH
2860: LD_INT 1
2862: PPUSH
2863: LD_INT 3
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: LD_INT 1
2871: PPUSH
2872: LD_INT 4
2874: PPUSH
2875: LD_INT 55
2877: PPUSH
2878: CALL 264 0 7
2882: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2883: LD_VAR 0 3
2887: PPUSH
2888: LD_INT 3
2890: PPUSH
2891: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2895: LD_VAR 0 3
2899: PPUSH
2900: LD_INT 46
2902: PPUSH
2903: LD_INT 19
2905: PPUSH
2906: LD_INT 0
2908: PPUSH
2909: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2913: LD_EXP 22
2917: PPUSH
2918: LD_VAR 0 3
2922: PPUSH
2923: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2927: LD_EXP 22
2931: PPUSH
2932: LD_INT 49
2934: PPUSH
2935: LD_INT 33
2937: PPUSH
2938: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2942: LD_EXP 22
2946: PPUSH
2947: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2951: LD_EXP 22
2955: PPUSH
2956: LD_EXP 18
2960: PPUSH
2961: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2965: LD_INT 35
2967: PPUSH
2968: CALL_OW 67
// until See ( 1 , Houten ) ;
2972: LD_INT 1
2974: PPUSH
2975: LD_EXP 22
2979: PPUSH
2980: CALL_OW 292
2984: IFFALSE 2965
// ComTurnUnit ( JMM , Houten ) ;
2986: LD_EXP 18
2990: PPUSH
2991: LD_EXP 22
2995: PPUSH
2996: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3000: LD_EXP 18
3004: PPUSH
3005: LD_STRING D1d-JMM-1
3007: PPUSH
3008: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3012: LD_EXP 22
3016: PPUSH
3017: LD_STRING D1-VanH-1
3019: PPUSH
3020: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3024: LD_EXP 18
3028: PPUSH
3029: LD_STRING D1-JMM-1v
3031: PPUSH
3032: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3036: LD_EXP 18
3040: PPUSH
3041: LD_STRING D1-JMM-2v
3043: PPUSH
3044: CALL_OW 88
// end ; InGameOff ;
3048: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3052: LD_STRING M1
3054: PPUSH
3055: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3059: LD_INT 22
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 92
3071: PUSH
3072: LD_EXP 18
3076: PPUSH
3077: CALL_OW 250
3081: PUSH
3082: LD_EXP 18
3086: PPUSH
3087: CALL_OW 251
3091: PUSH
3092: LD_INT 15
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PPUSH
3110: LD_INT 1
3112: PPUSH
3113: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3117: LD_EXP 23
3121: PUSH
3122: LD_EXP 18
3126: ADD
3127: PUSH
3128: LD_EXP 22
3132: ADD
3133: PPUSH
3134: CALL_OW 141
// end ;
3138: LD_VAR 0 1
3142: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3143: LD_INT 1
3145: PPUSH
3146: LD_EXP 19
3150: PPUSH
3151: CALL_OW 292
3155: PUSH
3156: LD_EXP 18
3160: PPUSH
3161: LD_EXP 19
3165: PPUSH
3166: CALL_OW 296
3170: PUSH
3171: LD_INT 6
3173: LESS
3174: AND
3175: IFFALSE 3938
3177: GO 3179
3179: DISABLE
3180: LD_INT 0
3182: PPUSH
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
// begin InGameOn ;
3187: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3191: LD_INT 22
3193: PUSH
3194: LD_INT 4
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: PPUSH
3201: CALL_OW 69
3205: PPUSH
3206: LD_INT 1
3208: PPUSH
3209: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3213: LD_ADDR_VAR 0 4
3217: PUSH
3218: LD_INT 22
3220: PUSH
3221: LD_INT 1
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: LD_INT 2
3230: PUSH
3231: LD_INT 25
3233: PUSH
3234: LD_INT 1
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: PUSH
3241: LD_INT 25
3243: PUSH
3244: LD_INT 2
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 25
3253: PUSH
3254: LD_INT 3
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 25
3263: PUSH
3264: LD_INT 4
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 69
3286: ST_TO_ADDR
// ComHold ( tmp ) ;
3287: LD_VAR 0 4
3291: PPUSH
3292: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3296: LD_EXP 18
3300: PPUSH
3301: LD_STRING D2-JMM-3a
3303: PPUSH
3304: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3308: LD_EXP 19
3312: PPUSH
3313: LD_EXP 18
3317: PPUSH
3318: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3322: LD_EXP 19
3326: PPUSH
3327: LD_STRING D2-Gary-3
3329: PPUSH
3330: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3334: LD_EXP 18
3338: PPUSH
3339: LD_EXP 19
3343: PPUSH
3344: CALL_OW 119
// for i in tmp do
3348: LD_ADDR_VAR 0 5
3352: PUSH
3353: LD_VAR 0 4
3357: PUSH
3358: FOR_IN
3359: IFFALSE 3404
// begin if IsInUnit ( i ) then
3361: LD_VAR 0 5
3365: PPUSH
3366: CALL_OW 310
3370: IFFALSE 3381
// ComExitBuilding ( i ) ;
3372: LD_VAR 0 5
3376: PPUSH
3377: CALL_OW 122
// wait ( 1 ) ;
3381: LD_INT 1
3383: PPUSH
3384: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3388: LD_VAR 0 5
3392: PPUSH
3393: LD_EXP 18
3397: PPUSH
3398: CALL_OW 119
// end ;
3402: GO 3358
3404: POP
3405: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3406: LD_ADDR_VAR 0 4
3410: PUSH
3411: LD_VAR 0 4
3415: PUSH
3416: LD_EXP 18
3420: PUSH
3421: LD_EXP 22
3425: PUSH
3426: LD_EXP 19
3430: PUSH
3431: LD_EXP 21
3435: PUSH
3436: LD_EXP 20
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: PUSH
3448: LD_EXP 23
3452: ADD
3453: DIFF
3454: ST_TO_ADDR
// if Bobby then
3455: LD_EXP 20
3459: IFFALSE 3473
// Say ( Bobby , D2-Bobby-3 ) ;
3461: LD_EXP 20
3465: PPUSH
3466: LD_STRING D2-Bobby-3
3468: PPUSH
3469: CALL_OW 88
// if Cyrus then
3473: LD_EXP 21
3477: IFFALSE 3491
// Say ( Cyrus , D2-Cyrus-3 ) ;
3479: LD_EXP 21
3483: PPUSH
3484: LD_STRING D2-Cyrus-3
3486: PPUSH
3487: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3491: LD_EXP 18
3495: PPUSH
3496: LD_STRING D2-JMM-4
3498: PPUSH
3499: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3503: LD_EXP 19
3507: PPUSH
3508: LD_STRING D2-Gary-4
3510: PPUSH
3511: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3515: LD_ADDR_VAR 0 1
3519: PUSH
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 26
3527: PUSH
3528: LD_INT 1
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: PUSH
3540: LD_INT 1
3542: ARRAY
3543: ST_TO_ADDR
// if Cyrus then
3544: LD_EXP 21
3548: IFFALSE 3564
// Say ( Cyrus , D2-Cyrus-4 ) else
3550: LD_EXP 21
3554: PPUSH
3555: LD_STRING D2-Cyrus-4
3557: PPUSH
3558: CALL_OW 88
3562: GO 3576
// Say ( un1 , D2-Sol1-4 ) ;
3564: LD_VAR 0 1
3568: PPUSH
3569: LD_STRING D2-Sol1-4
3571: PPUSH
3572: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3576: LD_EXP 18
3580: PPUSH
3581: LD_STRING D2-JMM-5
3583: PPUSH
3584: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_EXP 23
3597: PPUSH
3598: LD_INT 91
3600: PUSH
3601: LD_EXP 18
3605: PUSH
3606: LD_INT 10
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 26
3616: PUSH
3617: LD_INT 2
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PPUSH
3628: CALL_OW 72
3632: ST_TO_ADDR
// if un2 then
3633: LD_VAR 0 2
3637: IFFALSE 3691
// begin un2 := un2 [ un2 ] ;
3639: LD_ADDR_VAR 0 2
3643: PUSH
3644: LD_VAR 0 2
3648: PUSH
3649: LD_VAR 0 2
3653: ARRAY
3654: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3655: LD_VAR 0 2
3659: PPUSH
3660: LD_STRING D2-FEng1-5
3662: PPUSH
3663: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3667: LD_EXP 18
3671: PPUSH
3672: LD_STRING D2-JMM-6
3674: PPUSH
3675: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3679: LD_VAR 0 2
3683: PPUSH
3684: LD_STRING D2-FEng1-6
3686: PPUSH
3687: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3691: LD_ADDR_VAR 0 3
3695: PUSH
3696: LD_EXP 23
3700: PPUSH
3701: LD_INT 91
3703: PUSH
3704: LD_EXP 18
3708: PUSH
3709: LD_INT 10
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 26
3719: PUSH
3720: LD_INT 1
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PPUSH
3731: CALL_OW 72
3735: ST_TO_ADDR
// if un3 then
3736: LD_VAR 0 3
3740: IFFALSE 3795
// begin un3 := un3 [ 1 ] ;
3742: LD_ADDR_VAR 0 3
3746: PUSH
3747: LD_VAR 0 3
3751: PUSH
3752: LD_INT 1
3754: ARRAY
3755: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3756: LD_VAR 0 3
3760: PPUSH
3761: LD_INT 114
3763: PPUSH
3764: LD_INT 122
3766: PPUSH
3767: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3771: LD_VAR 0 3
3775: PPUSH
3776: LD_STRING D2-Eng1-6
3778: PPUSH
3779: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3783: LD_EXP 18
3787: PPUSH
3788: LD_STRING D2-JMM-7
3790: PPUSH
3791: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3795: LD_EXP 19
3799: PPUSH
3800: LD_STRING D2-Gary-7
3802: PPUSH
3803: CALL_OW 88
// if un2 then
3807: LD_VAR 0 2
3811: IFFALSE 3825
// Say ( un2 , D2-FEng1-7 ) ;
3813: LD_VAR 0 2
3817: PPUSH
3818: LD_STRING D2-FEng1-7
3820: PPUSH
3821: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3825: LD_VAR 0 1
3829: PPUSH
3830: LD_STRING D2-Sol1-7
3832: PPUSH
3833: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3837: LD_EXP 18
3841: PPUSH
3842: LD_STRING D2-JMM-8
3844: PPUSH
3845: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3849: LD_INT 22
3851: PUSH
3852: LD_INT 1
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PPUSH
3859: CALL_OW 69
3863: PPUSH
3864: CALL_OW 141
// InGameOff ;
3868: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3872: LD_STRING M1a
3874: PPUSH
3875: CALL_OW 337
// jmm_in_ovsyenko := true ;
3879: LD_ADDR_EXP 4
3883: PUSH
3884: LD_INT 1
3886: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3887: LD_INT 1050
3889: PPUSH
3890: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: LD_INT 25
3901: PUSH
3902: LD_INT 14
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PPUSH
3909: CALL_OW 69
3913: ST_TO_ADDR
// if not tmp then
3914: LD_VAR 0 4
3918: NOT
3919: IFFALSE 3923
// exit ;
3921: GO 3938
// ComMoveXY ( tmp , 75 , 75 ) ;
3923: LD_VAR 0 4
3927: PPUSH
3928: LD_INT 75
3930: PPUSH
3931: LD_INT 75
3933: PPUSH
3934: CALL_OW 111
// end ;
3938: PPOPN 5
3940: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3941: LD_INT 22
3943: PUSH
3944: LD_INT 1
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: PUSH
3951: LD_INT 30
3953: PUSH
3954: LD_INT 30
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PUSH
3961: LD_INT 3
3963: PUSH
3964: LD_INT 57
3966: PUSH
3967: EMPTY
3968: LIST
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: PPUSH
3979: CALL_OW 69
3983: IFFALSE 4025
3985: GO 3987
3987: DISABLE
3988: LD_INT 0
3990: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3991: LD_ADDR_VAR 0 1
3995: PUSH
3996: LD_STRING M2easy
3998: PUSH
3999: LD_STRING M2
4001: PUSH
4002: LD_STRING M2hard
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4010: LD_VAR 0 1
4014: PUSH
4015: LD_OWVAR 67
4019: ARRAY
4020: PPUSH
4021: CALL_OW 337
// end ;
4025: PPOPN 1
4027: END
// every 3 3$00 do
4028: GO 4030
4030: DISABLE
// begin DialogueOn ;
4031: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4035: LD_EXP 25
4039: PPUSH
4040: LD_STRING D3-Pow-1
4042: PPUSH
4043: CALL_OW 94
// if jmm_in_ovsyenko then
4047: LD_EXP 4
4051: IFFALSE 4079
// begin Say ( JMM , D3-JMM-1 ) ;
4053: LD_EXP 18
4057: PPUSH
4058: LD_STRING D3-JMM-1
4060: PPUSH
4061: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4065: LD_EXP 18
4069: PPUSH
4070: LD_STRING D3-JMM-1b
4072: PPUSH
4073: CALL_OW 88
// end else
4077: GO 4091
// Say ( JMM , D3-JMM-1a ) ;
4079: LD_EXP 18
4083: PPUSH
4084: LD_STRING D3-JMM-1a
4086: PPUSH
4087: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4091: LD_EXP 25
4095: PPUSH
4096: LD_STRING D3-Pow-2
4098: PPUSH
4099: CALL_OW 94
// DialogueOff ;
4103: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4107: LD_STRING M3
4109: PPUSH
4110: CALL_OW 337
// powell_want_sib := true ;
4114: LD_ADDR_EXP 5
4118: PUSH
4119: LD_INT 1
4121: ST_TO_ADDR
// end ;
4122: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4123: LD_EXP 6
4127: PUSH
4128: LD_INT 0
4130: EQUAL
4131: IFFALSE 5578
4133: GO 4135
4135: DISABLE
4136: LD_INT 0
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
4145: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4146: LD_INT 4
4148: PPUSH
4149: LD_INT 1
4151: PPUSH
4152: CALL_OW 343
// PowellTransport ;
4156: CALL 2484 0 0
// for i = 1 to 3 do
4160: LD_ADDR_VAR 0 4
4164: PUSH
4165: DOUBLE
4166: LD_INT 1
4168: DEC
4169: ST_TO_ADDR
4170: LD_INT 3
4172: PUSH
4173: FOR_TO
4174: IFFALSE 4241
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4176: LD_ADDR_VAR 0 1
4180: PUSH
4181: LD_INT 6
4183: PPUSH
4184: LD_VAR 0 4
4188: PPUSH
4189: CALL_OW 287
4193: ST_TO_ADDR
// if not tmp then
4194: LD_VAR 0 1
4198: NOT
4199: IFFALSE 4203
// continue ;
4201: GO 4173
// EraseResourceArea ( terminalArea , i ) ;
4203: LD_INT 6
4205: PPUSH
4206: LD_VAR 0 4
4210: PPUSH
4211: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4215: LD_EXP 3
4219: PPUSH
4220: CALL_OW 274
4224: PPUSH
4225: LD_VAR 0 4
4229: PPUSH
4230: LD_VAR 0 1
4234: PPUSH
4235: CALL_OW 276
// end ;
4239: GO 4173
4241: POP
4242: POP
// x := 43 ;
4243: LD_ADDR_VAR 0 2
4247: PUSH
4248: LD_INT 43
4250: ST_TO_ADDR
// y := 3 ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: LD_INT 3
4258: ST_TO_ADDR
// for i = 3 to 4 do
4259: LD_ADDR_VAR 0 4
4263: PUSH
4264: DOUBLE
4265: LD_INT 3
4267: DEC
4268: ST_TO_ADDR
4269: LD_INT 4
4271: PUSH
4272: FOR_TO
4273: IFFALSE 4464
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4275: LD_EXP 24
4279: PUSH
4280: LD_VAR 0 4
4284: ARRAY
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4293: LD_EXP 24
4297: PUSH
4298: LD_VAR 0 4
4302: ARRAY
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: LD_VAR 0 3
4313: PPUSH
4314: LD_INT 0
4316: PPUSH
4317: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4321: LD_EXP 24
4325: PUSH
4326: LD_VAR 0 4
4330: PUSH
4331: LD_INT 2
4333: MINUS
4334: ARRAY
4335: PPUSH
4336: LD_EXP 24
4340: PUSH
4341: LD_VAR 0 4
4345: ARRAY
4346: PPUSH
4347: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4351: LD_EXP 24
4355: PUSH
4356: LD_VAR 0 4
4360: ARRAY
4361: PPUSH
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 100
4367: PPUSH
4368: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4372: LD_EXP 24
4376: PUSH
4377: LD_VAR 0 4
4381: PUSH
4382: LD_INT 2
4384: MINUS
4385: ARRAY
4386: PPUSH
4387: LD_INT 54
4389: PPUSH
4390: LD_INT 42
4392: PPUSH
4393: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4397: LD_EXP 24
4401: PUSH
4402: LD_VAR 0 4
4406: PUSH
4407: LD_INT 2
4409: MINUS
4410: ARRAY
4411: PPUSH
4412: LD_EXP 3
4416: PPUSH
4417: CALL_OW 250
4421: PPUSH
4422: LD_EXP 3
4426: PPUSH
4427: CALL_OW 251
4431: PPUSH
4432: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4436: LD_EXP 24
4440: PUSH
4441: LD_VAR 0 4
4445: PUSH
4446: LD_INT 2
4448: MINUS
4449: ARRAY
4450: PPUSH
4451: CALL_OW 200
// Wait ( 0 0$02 ) ;
4455: LD_INT 70
4457: PPUSH
4458: CALL_OW 67
// end ;
4462: GO 4272
4464: POP
4465: POP
// time := 0 0$20 ;
4466: LD_ADDR_VAR 0 8
4470: PUSH
4471: LD_INT 700
4473: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4474: LD_INT 35
4476: PPUSH
4477: CALL_OW 67
// time := time - 0 0$01 ;
4481: LD_ADDR_VAR 0 8
4485: PUSH
4486: LD_VAR 0 8
4490: PUSH
4491: LD_INT 35
4493: MINUS
4494: ST_TO_ADDR
// for i = 3 to 4 do
4495: LD_ADDR_VAR 0 4
4499: PUSH
4500: DOUBLE
4501: LD_INT 3
4503: DEC
4504: ST_TO_ADDR
4505: LD_INT 4
4507: PUSH
4508: FOR_TO
4509: IFFALSE 4644
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4511: LD_EXP 24
4515: PUSH
4516: LD_VAR 0 4
4520: ARRAY
4521: PPUSH
4522: LD_INT 1
4524: PPUSH
4525: CALL_OW 289
4529: PUSH
4530: LD_INT 0
4532: GREATER
4533: PUSH
4534: LD_EXP 24
4538: PUSH
4539: LD_VAR 0 4
4543: ARRAY
4544: PPUSH
4545: CALL_OW 314
4549: NOT
4550: AND
4551: IFFALSE 4642
// begin x := rand ( 0 , 5 ) ;
4553: LD_ADDR_VAR 0 2
4557: PUSH
4558: LD_INT 0
4560: PPUSH
4561: LD_INT 5
4563: PPUSH
4564: CALL_OW 12
4568: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4569: LD_EXP 24
4573: PUSH
4574: LD_VAR 0 4
4578: ARRAY
4579: PPUSH
4580: LD_EXP 24
4584: PUSH
4585: LD_VAR 0 4
4589: ARRAY
4590: PPUSH
4591: CALL_OW 250
4595: PPUSH
4596: LD_VAR 0 2
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: CALL_OW 272
4608: PPUSH
4609: LD_EXP 24
4613: PUSH
4614: LD_VAR 0 4
4618: ARRAY
4619: PPUSH
4620: CALL_OW 251
4624: PPUSH
4625: LD_VAR 0 2
4629: PPUSH
4630: LD_INT 3
4632: PPUSH
4633: CALL_OW 273
4637: PPUSH
4638: CALL_OW 171
// end ;
4642: GO 4508
4644: POP
4645: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4646: LD_EXP 24
4650: PUSH
4651: LD_INT 1
4653: ARRAY
4654: PPUSH
4655: LD_INT 54
4657: PPUSH
4658: LD_INT 42
4660: PPUSH
4661: CALL_OW 297
4665: PUSH
4666: LD_INT 4
4668: LESS
4669: PUSH
4670: LD_VAR 0 8
4674: PUSH
4675: LD_INT 0
4677: EQUAL
4678: OR
4679: IFFALSE 4474
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4681: LD_EXP 24
4685: PUSH
4686: LD_INT 3
4688: ARRAY
4689: PPUSH
4690: LD_INT 1
4692: PPUSH
4693: LD_INT 0
4695: PPUSH
4696: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4700: LD_EXP 24
4704: PUSH
4705: LD_INT 4
4707: ARRAY
4708: PPUSH
4709: LD_INT 1
4711: PPUSH
4712: LD_INT 0
4714: PPUSH
4715: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4719: LD_EXP 3
4723: PPUSH
4724: CALL_OW 274
4728: PPUSH
4729: LD_INT 1
4731: PPUSH
4732: LD_INT 200
4734: PPUSH
4735: CALL_OW 276
// DialogueOn ;
4739: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4743: LD_INT 53
4745: PPUSH
4746: LD_INT 35
4748: PPUSH
4749: CALL_OW 86
// un := powell_trans [ 1 ] ;
4753: LD_ADDR_VAR 0 5
4757: PUSH
4758: LD_EXP 24
4762: PUSH
4763: LD_INT 1
4765: ARRAY
4766: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4767: LD_VAR 0 5
4771: PPUSH
4772: LD_STRING D4-Mech1-1
4774: PPUSH
4775: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4779: LD_EXP 18
4783: PPUSH
4784: LD_STRING D4-JMM-1
4786: PPUSH
4787: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4791: LD_VAR 0 5
4795: PPUSH
4796: LD_STRING D4-Mech1-2
4798: PPUSH
4799: CALL_OW 88
// powell_happy := false ;
4803: LD_ADDR_VAR 0 6
4807: PUSH
4808: LD_INT 0
4810: ST_TO_ADDR
// take_cargo := false ;
4811: LD_ADDR_VAR 0 7
4815: PUSH
4816: LD_INT 0
4818: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4819: CALL 784 0 0
4823: PUSH
4824: LD_INT 60
4826: GREATEREQUAL
4827: IFFALSE 4875
// begin Say ( JMM , D5-JMM-1 ) ;
4829: LD_EXP 18
4833: PPUSH
4834: LD_STRING D5-JMM-1
4836: PPUSH
4837: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4841: LD_VAR 0 5
4845: PPUSH
4846: LD_STRING D6-Mech1-1
4848: PPUSH
4849: CALL_OW 88
// powell_happy := true ;
4853: LD_ADDR_VAR 0 6
4857: PUSH
4858: LD_INT 1
4860: ST_TO_ADDR
// take_cargo := true ;
4861: LD_ADDR_VAR 0 7
4865: PUSH
4866: LD_INT 1
4868: ST_TO_ADDR
// DialogueOff ;
4869: CALL_OW 7
// end else
4873: GO 5109
// if GetTerminalCargo > 0 then
4875: CALL 784 0 0
4879: PUSH
4880: LD_INT 0
4882: GREATER
4883: IFFALSE 5081
// begin case Query ( QWait ) of 1 :
4885: LD_STRING QWait
4887: PPUSH
4888: CALL_OW 97
4892: PUSH
4893: LD_INT 1
4895: DOUBLE
4896: EQUAL
4897: IFTRUE 4901
4899: GO 4992
4901: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4902: LD_EXP 18
4906: PPUSH
4907: LD_STRING D5b-JMM-1
4909: PPUSH
4910: CALL_OW 88
// DialogueOff ;
4914: CALL_OW 7
// wait ( 5 5$00 ) ;
4918: LD_INT 10500
4920: PPUSH
4921: CALL_OW 67
// if GetTerminalCargo < 60 then
4925: CALL 784 0 0
4929: PUSH
4930: LD_INT 60
4932: LESS
4933: IFFALSE 4974
// begin DialogueOn ;
4935: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4939: LD_EXP 3
4943: PPUSH
4944: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_STRING D6-Mech1-1a
4955: PPUSH
4956: CALL_OW 88
// DialogueOff ;
4960: CALL_OW 7
// powell_happy := false ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_INT 0
4971: ST_TO_ADDR
// end else
4972: GO 4990
// begin powell_happy := true ;
4974: LD_ADDR_VAR 0 6
4978: PUSH
4979: LD_INT 1
4981: ST_TO_ADDR
// take_cargo := true ;
4982: LD_ADDR_VAR 0 7
4986: PUSH
4987: LD_INT 1
4989: ST_TO_ADDR
// end ; end ; 2 :
4990: GO 5079
4992: LD_INT 2
4994: DOUBLE
4995: EQUAL
4996: IFTRUE 5000
4998: GO 5039
5000: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5001: LD_EXP 18
5005: PPUSH
5006: LD_STRING D5b-JMM-1
5008: PPUSH
5009: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5013: LD_VAR 0 5
5017: PPUSH
5018: LD_STRING D6-Mech1-1a
5020: PPUSH
5021: CALL_OW 88
// DialogueOff ;
5025: CALL_OW 7
// take_cargo := true ;
5029: LD_ADDR_VAR 0 7
5033: PUSH
5034: LD_INT 1
5036: ST_TO_ADDR
// end ; 3 :
5037: GO 5079
5039: LD_INT 3
5041: DOUBLE
5042: EQUAL
5043: IFTRUE 5047
5045: GO 5078
5047: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5048: LD_EXP 18
5052: PPUSH
5053: LD_STRING D5c-JMM-1
5055: PPUSH
5056: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5060: LD_VAR 0 5
5064: PPUSH
5065: LD_STRING D6-Mech1-1b
5067: PPUSH
5068: CALL_OW 88
// DialogueOff ;
5072: CALL_OW 7
// end ; end ;
5076: GO 5079
5078: POP
// end else
5079: GO 5109
// begin Say ( JMM , D5c-JMM-1 ) ;
5081: LD_EXP 18
5085: PPUSH
5086: LD_STRING D5c-JMM-1
5088: PPUSH
5089: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5093: LD_VAR 0 5
5097: PPUSH
5098: LD_STRING D6-Mech1-1b
5100: PPUSH
5101: CALL_OW 88
// DialogueOff ;
5105: CALL_OW 7
// end ; if take_cargo then
5109: LD_VAR 0 7
5113: IFFALSE 5192
// begin x := GetTerminalCargo ;
5115: LD_ADDR_VAR 0 2
5119: PUSH
5120: CALL 784 0 0
5124: ST_TO_ADDR
// if x > 60 then
5125: LD_VAR 0 2
5129: PUSH
5130: LD_INT 60
5132: GREATER
5133: IFFALSE 5143
// x := 60 ;
5135: LD_ADDR_VAR 0 2
5139: PUSH
5140: LD_INT 60
5142: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5143: LD_EXP 3
5147: PPUSH
5148: CALL_OW 274
5152: PPUSH
5153: LD_INT 3
5155: PPUSH
5156: CALL 784 0 0
5160: PUSH
5161: LD_VAR 0 2
5165: MINUS
5166: PPUSH
5167: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5171: LD_EXP 24
5175: PUSH
5176: LD_INT 3
5178: ARRAY
5179: PPUSH
5180: LD_INT 3
5182: PPUSH
5183: LD_VAR 0 2
5187: PPUSH
5188: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5192: LD_EXP 24
5196: PPUSH
5197: LD_INT 43
5199: PPUSH
5200: LD_INT 3
5202: PPUSH
5203: CALL_OW 171
// x := 0 0$20 ;
5207: LD_ADDR_VAR 0 2
5211: PUSH
5212: LD_INT 700
5214: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5215: LD_INT 35
5217: PPUSH
5218: CALL_OW 67
// x := x - 0 0$01 ;
5222: LD_ADDR_VAR 0 2
5226: PUSH
5227: LD_VAR 0 2
5231: PUSH
5232: LD_INT 35
5234: MINUS
5235: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5236: LD_VAR 0 2
5240: PUSH
5241: LD_INT 0
5243: EQUAL
5244: PUSH
5245: LD_EXP 24
5249: PUSH
5250: LD_INT 3
5252: ARRAY
5253: PPUSH
5254: LD_INT 43
5256: PPUSH
5257: LD_INT 3
5259: PPUSH
5260: CALL_OW 297
5264: PUSH
5265: LD_INT 4
5267: LESS
5268: PUSH
5269: LD_EXP 24
5273: PUSH
5274: LD_INT 3
5276: ARRAY
5277: PPUSH
5278: LD_INT 43
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: CALL_OW 297
5288: PUSH
5289: LD_INT 4
5291: LESS
5292: AND
5293: OR
5294: IFFALSE 5215
// for i in powell_trans do
5296: LD_ADDR_VAR 0 4
5300: PUSH
5301: LD_EXP 24
5305: PUSH
5306: FOR_IN
5307: IFFALSE 5320
// RemoveUnit ( i ) ;
5309: LD_VAR 0 4
5313: PPUSH
5314: CALL_OW 64
5318: GO 5306
5320: POP
5321: POP
// if not powell_happy then
5322: LD_VAR 0 6
5326: NOT
5327: IFFALSE 5338
// powell_happy := - 1 ;
5329: LD_ADDR_VAR 0 6
5333: PUSH
5334: LD_INT 1
5336: NEG
5337: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5338: LD_STRING EarlySiberite
5340: PPUSH
5341: LD_VAR 0 6
5345: PPUSH
5346: CALL_OW 101
// if powell_happy then
5350: LD_VAR 0 6
5354: IFFALSE 5365
// ChangeMissionObjectives ( M3a ) else
5356: LD_STRING M3a
5358: PPUSH
5359: CALL_OW 337
5363: GO 5372
// ChangeMissionObjectives ( M3b ) ;
5365: LD_STRING M3b
5367: PPUSH
5368: CALL_OW 337
// ru_can_attack_terminal := true ;
5372: LD_ADDR_EXP 9
5376: PUSH
5377: LD_INT 1
5379: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5380: LD_INT 25200
5382: PPUSH
5383: CALL_OW 67
// time := 2 2$00 ;
5387: LD_ADDR_VAR 0 8
5391: PUSH
5392: LD_INT 4200
5394: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5395: LD_INT 35
5397: PPUSH
5398: CALL_OW 67
// time := time - 0 0$1 ;
5402: LD_ADDR_VAR 0 8
5406: PUSH
5407: LD_VAR 0 8
5411: PUSH
5412: LD_INT 35
5414: MINUS
5415: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5416: LD_EXP 8
5420: NOT
5421: PUSH
5422: LD_EXP 35
5426: PUSH
5427: LD_INT 0
5429: EQUAL
5430: OR
5431: PUSH
5432: LD_VAR 0 8
5436: PUSH
5437: LD_INT 0
5439: EQUAL
5440: OR
5441: IFFALSE 5395
// if ru_force then
5443: LD_EXP 35
5447: IFFALSE 5546
// for i in ru_force do
5449: LD_ADDR_VAR 0 4
5453: PUSH
5454: LD_EXP 35
5458: PUSH
5459: FOR_IN
5460: IFFALSE 5544
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5462: LD_INT 1
5464: PPUSH
5465: LD_VAR 0 4
5469: PPUSH
5470: CALL_OW 292
5474: NOT
5475: PUSH
5476: LD_VAR 0 4
5480: PPUSH
5481: LD_INT 81
5483: PUSH
5484: LD_INT 3
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PPUSH
5491: CALL_OW 69
5495: PPUSH
5496: LD_VAR 0 4
5500: PPUSH
5501: CALL_OW 74
5505: PPUSH
5506: CALL_OW 296
5510: PUSH
5511: LD_INT 10
5513: GREATER
5514: AND
5515: IFFALSE 5542
// begin RemoveUnit ( i ) ;
5517: LD_VAR 0 4
5521: PPUSH
5522: CALL_OW 64
// ru_force := ru_force diff i ;
5526: LD_ADDR_EXP 35
5530: PUSH
5531: LD_EXP 35
5535: PUSH
5536: LD_VAR 0 4
5540: DIFF
5541: ST_TO_ADDR
// end ;
5542: GO 5459
5544: POP
5545: POP
// repeat wait ( 0 0$03 ) ;
5546: LD_INT 105
5548: PPUSH
5549: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5553: LD_EXP 8
5557: NOT
5558: PUSH
5559: LD_EXP 35
5563: PUSH
5564: LD_INT 3
5566: LESS
5567: OR
5568: IFFALSE 5546
// ar_can_arrive := true ;
5570: LD_ADDR_EXP 10
5574: PUSH
5575: LD_INT 1
5577: ST_TO_ADDR
// end ;
5578: PPOPN 8
5580: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5581: LD_INT 1
5583: PPUSH
5584: LD_INT 20
5586: PPUSH
5587: CALL_OW 325
5591: IFFALSE 5732
5593: GO 5595
5595: DISABLE
5596: LD_INT 0
5598: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5599: LD_ADDR_VAR 0 1
5603: PUSH
5604: LD_INT 22
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 26
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 25
5626: PUSH
5627: LD_INT 4
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: PUSH
5644: LD_EXP 18
5648: PUSH
5649: LD_EXP 21
5653: PUSH
5654: LD_EXP 20
5658: PUSH
5659: LD_EXP 22
5663: PUSH
5664: EMPTY
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: DIFF
5670: ST_TO_ADDR
// if not un then
5671: LD_VAR 0 1
5675: NOT
5676: IFFALSE 5680
// exit ;
5678: GO 5732
// DialogueOn ;
5680: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5684: LD_VAR 0 1
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PPUSH
5693: LD_STRING D13-Sci1-1
5695: PPUSH
5696: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5700: LD_EXP 18
5704: PPUSH
5705: LD_STRING D13-JMM-1
5707: PPUSH
5708: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5712: LD_VAR 0 1
5716: PUSH
5717: LD_INT 1
5719: ARRAY
5720: PPUSH
5721: LD_STRING D13-Sci1-2
5723: PPUSH
5724: CALL_OW 88
// DialogueOff ;
5728: CALL_OW 7
// end ;
5732: PPOPN 1
5734: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5735: LD_INT 1
5737: PPUSH
5738: CALL 815 0 1
5742: PUSH
5743: LD_INT 77
5745: GREATER
5746: PUSH
5747: LD_EXP 8
5751: NOT
5752: AND
5753: PUSH
5754: LD_INT 22
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PUSH
5774: LD_INT 26
5776: PUSH
5777: LD_INT 1
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: PPUSH
5789: CALL_OW 69
5793: PUSH
5794: LD_EXP 18
5798: PUSH
5799: LD_EXP 20
5803: PUSH
5804: LD_EXP 21
5808: PUSH
5809: LD_EXP 19
5813: PUSH
5814: LD_EXP 22
5818: PUSH
5819: EMPTY
5820: LIST
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: DIFF
5826: AND
5827: IFFALSE 6005
5829: GO 5831
5831: DISABLE
5832: LD_INT 0
5834: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5835: LD_ADDR_VAR 0 1
5839: PUSH
5840: LD_INT 22
5842: PUSH
5843: LD_INT 1
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 25
5852: PUSH
5853: LD_INT 4
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 26
5862: PUSH
5863: LD_INT 1
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: LIST
5874: PPUSH
5875: CALL_OW 69
5879: PUSH
5880: LD_EXP 18
5884: PUSH
5885: LD_EXP 20
5889: PUSH
5890: LD_EXP 21
5894: PUSH
5895: LD_EXP 19
5899: PUSH
5900: LD_EXP 22
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: DIFF
5912: ST_TO_ADDR
// DialogueOn ;
5913: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5917: LD_VAR 0 1
5921: PUSH
5922: LD_INT 1
5924: ARRAY
5925: PPUSH
5926: LD_STRING D7-Sci1-1
5928: PPUSH
5929: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5933: LD_EXP 18
5937: PPUSH
5938: LD_STRING D7-JMM-1
5940: PPUSH
5941: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5945: LD_VAR 0 1
5949: PUSH
5950: LD_INT 1
5952: ARRAY
5953: PPUSH
5954: LD_STRING D7-Sci1-2
5956: PPUSH
5957: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5961: LD_EXP 18
5965: PPUSH
5966: LD_STRING D7-JMM-2
5968: PPUSH
5969: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5973: LD_VAR 0 1
5977: PUSH
5978: LD_INT 1
5980: ARRAY
5981: PPUSH
5982: LD_STRING D7-Sci1-3
5984: PPUSH
5985: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5989: LD_EXP 18
5993: PPUSH
5994: LD_STRING D7-JMM-3
5996: PPUSH
5997: CALL_OW 88
// DialogueOff ;
6001: CALL_OW 7
// end ;
6005: PPOPN 1
6007: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates ;
6008: LD_EXP 10
6012: IFFALSE 9346
6014: GO 6016
6016: DISABLE
6017: LD_INT 0
6019: PPUSH
6020: PPUSH
6021: PPUSH
6022: PPUSH
6023: PPUSH
6024: PPUSH
6025: PPUSH
6026: PPUSH
6027: PPUSH
// begin PrepareArabian ;
6028: CALL 11767 0 0
// repeat wait ( 0 0$01 ) ;
6032: LD_INT 35
6034: PPUSH
6035: CALL_OW 67
// until ar_spawned ;
6039: LD_EXP 11
6043: IFFALSE 6032
// have_crates := true ;
6045: LD_ADDR_VAR 0 9
6049: PUSH
6050: LD_INT 1
6052: ST_TO_ADDR
// DialogueOn ;
6053: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6057: LD_EXP 26
6061: PPUSH
6062: LD_STRING D8-Ar1-1
6064: PPUSH
6065: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6069: LD_EXP 18
6073: PPUSH
6074: LD_STRING D8-JMM-1
6076: PPUSH
6077: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6081: LD_EXP 26
6085: PPUSH
6086: LD_STRING D8-Ar1-2
6088: PPUSH
6089: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6093: LD_EXP 18
6097: PPUSH
6098: LD_STRING D8-JMM-2
6100: PPUSH
6101: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6105: LD_EXP 26
6109: PPUSH
6110: LD_STRING D8-Ar1-3
6112: PPUSH
6113: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6117: LD_EXP 18
6121: PPUSH
6122: LD_STRING D8-JMM-3
6124: PPUSH
6125: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6129: LD_EXP 26
6133: PPUSH
6134: LD_STRING D8-Ar1-4
6136: PPUSH
6137: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6141: LD_EXP 18
6145: PPUSH
6146: LD_STRING D8-JMM-4
6148: PPUSH
6149: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6153: LD_EXP 26
6157: PPUSH
6158: LD_STRING D8-Ar1-5
6160: PPUSH
6161: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6165: LD_EXP 18
6169: PPUSH
6170: LD_STRING D8-JMM-5
6172: PPUSH
6173: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6177: LD_EXP 26
6181: PPUSH
6182: LD_STRING D8-Ar1-6
6184: PPUSH
6185: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6189: LD_EXP 27
6193: PPUSH
6194: LD_STRING D8-Ar2-6
6196: PPUSH
6197: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6201: LD_EXP 18
6205: PPUSH
6206: LD_STRING D8-JMM-6
6208: PPUSH
6209: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6213: LD_EXP 27
6217: PPUSH
6218: LD_STRING D8-Ar2-7
6220: PPUSH
6221: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6225: LD_STRING QBarracks
6227: PPUSH
6228: CALL_OW 97
6232: PUSH
6233: LD_INT 1
6235: DOUBLE
6236: EQUAL
6237: IFTRUE 6241
6239: GO 6276
6241: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6242: LD_EXP 18
6246: PPUSH
6247: LD_STRING D8a-JMM-1
6249: PPUSH
6250: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6254: LD_EXP 26
6258: PPUSH
6259: LD_STRING D8a-Ar1-1
6261: PPUSH
6262: CALL_OW 94
// player_want_mortar := true ;
6266: LD_ADDR_EXP 12
6270: PUSH
6271: LD_INT 1
6273: ST_TO_ADDR
// end ; 2 :
6274: GO 6434
6276: LD_INT 2
6278: DOUBLE
6279: EQUAL
6280: IFTRUE 6284
6282: GO 6398
6284: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6285: LD_EXP 18
6289: PPUSH
6290: LD_STRING D8b-JMM-1
6292: PPUSH
6293: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6297: LD_EXP 26
6301: PPUSH
6302: LD_STRING D8b-Ar1-1
6304: PPUSH
6305: CALL_OW 94
// case Query ( QInfo ) of 1 :
6309: LD_STRING QInfo
6311: PPUSH
6312: CALL_OW 97
6316: PUSH
6317: LD_INT 1
6319: DOUBLE
6320: EQUAL
6321: IFTRUE 6325
6323: GO 6360
6325: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6326: LD_EXP 18
6330: PPUSH
6331: LD_STRING D8b1-JMM-1
6333: PPUSH
6334: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6338: LD_EXP 26
6342: PPUSH
6343: LD_STRING D8b1-Ar1-1
6345: PPUSH
6346: CALL_OW 94
// player_want_info := 2 ;
6350: LD_ADDR_EXP 13
6354: PUSH
6355: LD_INT 2
6357: ST_TO_ADDR
// end ; 2 :
6358: GO 6396
6360: LD_INT 2
6362: DOUBLE
6363: EQUAL
6364: IFTRUE 6368
6366: GO 6395
6368: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6369: LD_EXP 18
6373: PPUSH
6374: LD_STRING D8b2-JMM-1
6376: PPUSH
6377: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6381: LD_EXP 26
6385: PPUSH
6386: LD_STRING D8b2-Ar1-1
6388: PPUSH
6389: CALL_OW 94
// end ; end ;
6393: GO 6396
6395: POP
// end ; 3 :
6396: GO 6434
6398: LD_INT 3
6400: DOUBLE
6401: EQUAL
6402: IFTRUE 6406
6404: GO 6433
6406: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6407: LD_EXP 18
6411: PPUSH
6412: LD_STRING D8c-JMM-1
6414: PPUSH
6415: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6419: LD_EXP 26
6423: PPUSH
6424: LD_STRING D8c-Ar1-1
6426: PPUSH
6427: CALL_OW 94
// end ; end ;
6431: GO 6434
6433: POP
// DialogueOff ;
6434: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6438: LD_ADDR_VAR 0 4
6442: PUSH
6443: LD_INT 9
6445: PPUSH
6446: LD_INT 2
6448: PUSH
6449: LD_INT 30
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 30
6461: PUSH
6462: LD_INT 1
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: LIST
6473: PPUSH
6474: CALL_OW 70
6478: ST_TO_ADDR
// if dep then
6479: LD_VAR 0 4
6483: IFFALSE 6499
// dep := dep [ 1 ] ;
6485: LD_ADDR_VAR 0 4
6489: PUSH
6490: LD_VAR 0 4
6494: PUSH
6495: LD_INT 1
6497: ARRAY
6498: ST_TO_ADDR
// if not dep then
6499: LD_VAR 0 4
6503: NOT
6504: IFFALSE 6542
// begin case Query ( QInfoNothing ) of 1 :
6506: LD_STRING QInfoNothing
6508: PPUSH
6509: CALL_OW 97
6513: PUSH
6514: LD_INT 1
6516: DOUBLE
6517: EQUAL
6518: IFTRUE 6522
6520: GO 6525
6522: POP
// ; end ;
6523: GO 6526
6525: POP
// player_want_info := false ;
6526: LD_ADDR_EXP 13
6530: PUSH
6531: LD_INT 0
6533: ST_TO_ADDR
// player_want_mortar := false ;
6534: LD_ADDR_EXP 12
6538: PUSH
6539: LD_INT 0
6541: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: LD_INT 22
6549: PUSH
6550: LD_INT 2
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 21
6559: PUSH
6560: LD_INT 2
6562: PUSH
6563: EMPTY
6564: LIST
6565: LIST
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PPUSH
6571: CALL_OW 69
6575: ST_TO_ADDR
// time := 1 1$35 ;
6576: LD_ADDR_VAR 0 5
6580: PUSH
6581: LD_INT 3325
6583: ST_TO_ADDR
// no_oil_gain := false ;
6584: LD_ADDR_VAR 0 6
6588: PUSH
6589: LD_INT 0
6591: ST_TO_ADDR
// first_warn := false ;
6592: LD_ADDR_VAR 0 7
6596: PUSH
6597: LD_INT 0
6599: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6600: LD_EXP 12
6604: PUSH
6605: LD_EXP 13
6609: OR
6610: IFFALSE 6715
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6612: LD_EXP 33
6616: PPUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 1
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PPUSH
6627: CALL_OW 72
6631: PPUSH
6632: LD_VAR 0 4
6636: PPUSH
6637: CALL_OW 250
6641: PPUSH
6642: LD_VAR 0 4
6646: PPUSH
6647: CALL_OW 251
6651: PPUSH
6652: LD_VAR 0 4
6656: PPUSH
6657: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6661: LD_EXP 33
6665: PPUSH
6666: LD_INT 25
6668: PUSH
6669: LD_INT 1
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PPUSH
6676: CALL_OW 72
6680: PPUSH
6681: LD_INT 86
6683: PPUSH
6684: LD_INT 121
6686: PPUSH
6687: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6691: LD_EXP 33
6695: PPUSH
6696: LD_INT 25
6698: PUSH
6699: LD_INT 1
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: PPUSH
6706: CALL_OW 72
6710: PPUSH
6711: CALL_OW 200
// end ; if player_attacked_ar then
6715: LD_EXP 16
6719: IFFALSE 6723
// exit ;
6721: GO 9346
// if player_want_mortar then
6723: LD_EXP 12
6727: IFFALSE 8148
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6729: LD_EXP 27
6733: PPUSH
6734: LD_VAR 0 4
6738: PPUSH
6739: CALL_OW 250
6743: PUSH
6744: LD_INT 1
6746: PLUS
6747: PPUSH
6748: LD_VAR 0 4
6752: PPUSH
6753: CALL_OW 251
6757: PUSH
6758: LD_INT 1
6760: PLUS
6761: PPUSH
6762: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6766: LD_INT 35
6768: PPUSH
6769: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6773: LD_EXP 27
6777: PPUSH
6778: LD_VAR 0 4
6782: PPUSH
6783: CALL_OW 296
6787: PUSH
6788: LD_INT 4
6790: LESS
6791: IFFALSE 6766
// for i = 1 to 6 do
6793: LD_ADDR_VAR 0 1
6797: PUSH
6798: DOUBLE
6799: LD_INT 1
6801: DEC
6802: ST_TO_ADDR
6803: LD_INT 6
6805: PUSH
6806: FOR_TO
6807: IFFALSE 7004
// begin if player_attacked_ar then
6809: LD_EXP 16
6813: IFFALSE 6819
// exit ;
6815: POP
6816: POP
6817: GO 9346
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6819: LD_VAR 0 4
6823: PPUSH
6824: CALL_OW 274
6828: PPUSH
6829: LD_INT 2
6831: PPUSH
6832: CALL_OW 275
6836: PUSH
6837: LD_INT 10
6839: LESS
6840: PUSH
6841: LD_VAR 0 7
6845: NOT
6846: AND
6847: IFFALSE 6910
// begin first_warn := true ;
6849: LD_ADDR_VAR 0 7
6853: PUSH
6854: LD_INT 1
6856: ST_TO_ADDR
// DialogueOn ;
6857: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6861: LD_EXP 28
6865: PPUSH
6866: LD_STRING D9a-FAr1-1
6868: PPUSH
6869: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6873: LD_EXP 18
6877: PPUSH
6878: LD_STRING D9a-JMM-1
6880: PPUSH
6881: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6885: LD_EXP 26
6889: PPUSH
6890: LD_STRING D9a2-Ar1-1
6892: PPUSH
6893: CALL_OW 88
// DialogueOff ;
6897: CALL_OW 7
// wait ( time ) ;
6901: LD_VAR 0 5
6905: PPUSH
6906: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6910: LD_VAR 0 4
6914: PPUSH
6915: CALL_OW 274
6919: PPUSH
6920: LD_INT 2
6922: PPUSH
6923: CALL_OW 275
6927: PUSH
6928: LD_INT 10
6930: LESS
6931: IFFALSE 6957
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6933: LD_EXP 26
6937: PPUSH
6938: LD_STRING D9a3-Ar1-1
6940: PPUSH
6941: CALL_OW 88
// no_oil_gain := true ;
6945: LD_ADDR_VAR 0 6
6949: PUSH
6950: LD_INT 1
6952: ST_TO_ADDR
// break ;
6953: GO 7004
// end else
6955: GO 7002
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6957: LD_EXP 27
6961: PPUSH
6962: LD_VAR 0 4
6966: PPUSH
6967: LD_INT 2
6969: PPUSH
6970: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6974: LD_EXP 27
6978: PPUSH
6979: LD_VAR 0 3
6983: PUSH
6984: LD_VAR 0 1
6988: PUSH
6989: LD_INT 3
6991: MOD
6992: PUSH
6993: LD_INT 1
6995: PLUS
6996: ARRAY
6997: PPUSH
6998: CALL_OW 210
// end ; end ;
7002: GO 6806
7004: POP
7005: POP
// if not no_oil_gain then
7006: LD_VAR 0 6
7010: NOT
7011: IFFALSE 8148
// begin repeat wait ( 0 0$01 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
// if player_attacked_ar then
7020: LD_EXP 16
7024: IFFALSE 7028
// exit ;
7026: GO 9346
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7028: LD_VAR 0 3
7032: PUSH
7033: LD_INT 1
7035: ARRAY
7036: PPUSH
7037: CALL_OW 261
7041: PUSH
7042: LD_INT 80
7044: GREATER
7045: PUSH
7046: LD_VAR 0 3
7050: PUSH
7051: LD_INT 2
7053: ARRAY
7054: PPUSH
7055: CALL_OW 261
7059: PUSH
7060: LD_INT 80
7062: GREATER
7063: AND
7064: PUSH
7065: LD_VAR 0 3
7069: PUSH
7070: LD_INT 3
7072: ARRAY
7073: PPUSH
7074: CALL_OW 261
7078: PUSH
7079: LD_INT 80
7081: GREATER
7082: AND
7083: IFFALSE 7013
// ComMoveXY ( Gali , 105 , 127 ) ;
7085: LD_EXP 27
7089: PPUSH
7090: LD_INT 105
7092: PPUSH
7093: LD_INT 127
7095: PPUSH
7096: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7100: LD_EXP 27
7104: PPUSH
7105: LD_INT 2
7107: PPUSH
7108: CALL_OW 173
// AddComHold ( Gali ) ;
7112: LD_EXP 27
7116: PPUSH
7117: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7121: LD_INT 35
7123: PPUSH
7124: CALL_OW 67
// if player_attacked_ar then
7128: LD_EXP 16
7132: IFFALSE 7136
// exit ;
7134: GO 9346
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7136: LD_EXP 27
7140: PPUSH
7141: LD_INT 105
7143: PPUSH
7144: LD_INT 127
7146: PPUSH
7147: CALL_OW 297
7151: PUSH
7152: LD_INT 4
7154: LESS
7155: IFFALSE 7121
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7157: LD_VAR 0 4
7161: PPUSH
7162: CALL_OW 274
7166: PPUSH
7167: LD_INT 1
7169: PPUSH
7170: CALL_OW 275
7174: PUSH
7175: LD_INT 50
7177: LESS
7178: IFFALSE 7480
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7180: LD_VAR 0 4
7184: PPUSH
7185: CALL_OW 274
7189: PPUSH
7190: LD_INT 1
7192: PPUSH
7193: CALL_OW 275
7197: PUSH
7198: LD_INT 0
7200: DOUBLE
7201: GREATEREQUAL
7202: IFFALSE 7210
7204: LD_INT 24
7206: DOUBLE
7207: LESSEQUAL
7208: IFTRUE 7212
7210: GO 7227
7212: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7213: LD_EXP 27
7217: PPUSH
7218: LD_STRING D9b-Ar2-1
7220: PPUSH
7221: CALL_OW 88
7225: GO 7257
7227: LD_INT 25
7229: DOUBLE
7230: GREATEREQUAL
7231: IFFALSE 7239
7233: LD_INT 49
7235: DOUBLE
7236: LESSEQUAL
7237: IFTRUE 7241
7239: GO 7256
7241: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7242: LD_EXP 27
7246: PPUSH
7247: LD_STRING D9b-Ar2-1a
7249: PPUSH
7250: CALL_OW 88
7254: GO 7257
7256: POP
// Say ( JMM , D9b-JMM-1 ) ;
7257: LD_EXP 18
7261: PPUSH
7262: LD_STRING D9b-JMM-1
7264: PPUSH
7265: CALL_OW 88
// x := 0 0$0 ;
7269: LD_ADDR_VAR 0 2
7273: PUSH
7274: LD_INT 0
7276: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7277: LD_INT 35
7279: PPUSH
7280: CALL_OW 67
// x := x + 0 0$1 ;
7284: LD_ADDR_VAR 0 2
7288: PUSH
7289: LD_VAR 0 2
7293: PUSH
7294: LD_INT 35
7296: PLUS
7297: ST_TO_ADDR
// if player_attacked_ar then
7298: LD_EXP 16
7302: IFFALSE 7306
// exit ;
7304: GO 9346
// until x >= time ;
7306: LD_VAR 0 2
7310: PUSH
7311: LD_VAR 0 5
7315: GREATEREQUAL
7316: IFFALSE 7277
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7318: LD_VAR 0 4
7322: PPUSH
7323: CALL_OW 274
7327: PPUSH
7328: LD_INT 1
7330: PPUSH
7331: CALL_OW 275
7335: PUSH
7336: LD_INT 50
7338: LESS
7339: IFFALSE 7480
// begin have_crates := false ;
7341: LD_ADDR_VAR 0 9
7345: PUSH
7346: LD_INT 0
7348: ST_TO_ADDR
// DialogueOn ;
7349: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7353: LD_EXP 26
7357: PPUSH
7358: LD_STRING D9c-Ar1-1
7360: PPUSH
7361: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7365: LD_EXP 18
7369: PPUSH
7370: LD_STRING D9c-JMM-1
7372: PPUSH
7373: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7377: LD_EXP 26
7381: PPUSH
7382: LD_STRING D9c-Ar1-2
7384: PPUSH
7385: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7389: LD_EXP 28
7393: PPUSH
7394: LD_STRING D9c-FAr1-2
7396: PPUSH
7397: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7401: LD_EXP 26
7405: PPUSH
7406: LD_STRING D9c-Ar1-3
7408: PPUSH
7409: CALL_OW 88
// case Query ( QInfo ) of 1 :
7413: LD_STRING QInfo
7415: PPUSH
7416: CALL_OW 97
7420: PUSH
7421: LD_INT 1
7423: DOUBLE
7424: EQUAL
7425: IFTRUE 7429
7427: GO 7452
7429: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7430: LD_EXP 18
7434: PPUSH
7435: LD_STRING D8b1-JMM-1
7437: PPUSH
7438: CALL_OW 88
// player_want_info := 2 ;
7442: LD_ADDR_EXP 13
7446: PUSH
7447: LD_INT 2
7449: ST_TO_ADDR
// end ; 2 :
7450: GO 7476
7452: LD_INT 2
7454: DOUBLE
7455: EQUAL
7456: IFTRUE 7460
7458: GO 7475
7460: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7461: LD_EXP 26
7465: PPUSH
7466: LD_STRING D8b2-Ar1-1
7468: PPUSH
7469: CALL_OW 88
// end ; end ;
7473: GO 7476
7475: POP
// DialogueOff ;
7476: CALL_OW 7
// end ; end ; if have_crates then
7480: LD_VAR 0 9
7484: IFFALSE 8148
// begin RemoveEnvironmentArea ( mortarArea ) ;
7486: LD_INT 2
7488: PPUSH
7489: CALL_OW 355
// wait ( 1 ) ;
7493: LD_INT 1
7495: PPUSH
7496: CALL_OW 67
// InGameOn ;
7500: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7504: LD_EXP 27
7508: PPUSH
7509: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7513: LD_EXP 27
7517: PPUSH
7518: LD_INT 1
7520: PPUSH
7521: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7525: LD_EXP 27
7529: PPUSH
7530: LD_INT 4
7532: PPUSH
7533: LD_INT 107
7535: PPUSH
7536: LD_INT 131
7538: PPUSH
7539: LD_INT 0
7541: PPUSH
7542: CALL_OW 145
// repeat wait ( 1 ) ;
7546: LD_INT 1
7548: PPUSH
7549: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7553: LD_INT 30
7555: PUSH
7556: LD_INT 4
7558: PUSH
7559: EMPTY
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 23
7565: PUSH
7566: LD_INT 2
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PPUSH
7577: CALL_OW 69
7581: IFFALSE 7546
// SetSide ( Gali , 2 ) ;
7583: LD_EXP 27
7587: PPUSH
7588: LD_INT 2
7590: PPUSH
7591: CALL_OW 235
// InGameOff ;
7595: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7599: LD_ADDR_VAR 0 8
7603: PUSH
7604: LD_INT 30
7606: PUSH
7607: LD_INT 4
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 23
7616: PUSH
7617: LD_INT 2
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PPUSH
7628: CALL_OW 69
7632: PUSH
7633: LD_INT 1
7635: ARRAY
7636: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7637: LD_INT 35
7639: PPUSH
7640: CALL_OW 67
// if player_attacked_ar then
7644: LD_EXP 16
7648: IFFALSE 7652
// exit ;
7650: GO 9346
// until BuildingStatus ( b ) <> bs_build ;
7652: LD_VAR 0 8
7656: PPUSH
7657: CALL_OW 461
7661: PUSH
7662: LD_INT 1
7664: NONEQUAL
7665: IFFALSE 7637
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7667: LD_VAR 0 8
7671: PPUSH
7672: CALL_OW 302
7676: PUSH
7677: LD_VAR 0 4
7681: PPUSH
7682: CALL_OW 274
7686: PPUSH
7687: LD_INT 1
7689: PPUSH
7690: CALL_OW 275
7694: PUSH
7695: LD_INT 25
7697: GREATEREQUAL
7698: AND
7699: IFFALSE 7798
// begin ComUpgrade ( b ) ;
7701: LD_VAR 0 8
7705: PPUSH
7706: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7710: LD_EXP 27
7714: PPUSH
7715: LD_STRING h
7717: PUSH
7718: LD_VAR 0 8
7722: PPUSH
7723: CALL_OW 250
7727: PUSH
7728: LD_VAR 0 8
7732: PPUSH
7733: CALL_OW 251
7737: PUSH
7738: LD_VAR 0 8
7742: PUSH
7743: LD_INT 0
7745: PUSH
7746: LD_INT 0
7748: PUSH
7749: LD_INT 0
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: PUSH
7761: EMPTY
7762: LIST
7763: PPUSH
7764: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7768: LD_INT 35
7770: PPUSH
7771: CALL_OW 67
// if player_attacked_ar then
7775: LD_EXP 16
7779: IFFALSE 7783
// exit ;
7781: GO 9346
// until BuildingStatus ( b ) <> bs_build ;
7783: LD_VAR 0 8
7787: PPUSH
7788: CALL_OW 461
7792: PUSH
7793: LD_INT 1
7795: NONEQUAL
7796: IFFALSE 7768
// end ; if b then
7798: LD_VAR 0 8
7802: IFFALSE 7813
// CenterNowOnUnits ( b ) ;
7804: LD_VAR 0 8
7808: PPUSH
7809: CALL_OW 87
// DialogueOn ;
7813: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7817: LD_EXP 27
7821: PPUSH
7822: LD_STRING D9d-Ar2-1
7824: PPUSH
7825: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7829: LD_EXP 26
7833: PPUSH
7834: LD_STRING D9d-Ar1-1
7836: PPUSH
7837: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7841: LD_EXP 18
7845: PPUSH
7846: LD_STRING D9d-JMM-1
7848: PPUSH
7849: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7853: LD_EXP 26
7857: PPUSH
7858: LD_STRING D9d-Ar1-2
7860: PPUSH
7861: CALL_OW 88
// DialogueOff ;
7865: CALL_OW 7
// i := [ ] ;
7869: LD_ADDR_VAR 0 1
7873: PUSH
7874: EMPTY
7875: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7876: LD_VAR 0 4
7880: PPUSH
7881: CALL_OW 274
7885: PPUSH
7886: LD_INT 3
7888: PPUSH
7889: CALL_OW 275
7893: PUSH
7894: LD_INT 20
7896: GREATEREQUAL
7897: IFFALSE 7916
// i := i ^ [ 1 ] ;
7899: LD_ADDR_VAR 0 1
7903: PUSH
7904: LD_VAR 0 1
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: EMPTY
7913: LIST
7914: ADD
7915: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7916: LD_VAR 0 4
7920: PPUSH
7921: CALL_OW 274
7925: PPUSH
7926: LD_INT 1
7928: PPUSH
7929: CALL_OW 275
7933: PUSH
7934: LD_INT 50
7936: GREATEREQUAL
7937: IFFALSE 7956
// i := i ^ [ 2 ] ;
7939: LD_ADDR_VAR 0 1
7943: PUSH
7944: LD_VAR 0 1
7948: PUSH
7949: LD_INT 2
7951: PUSH
7952: EMPTY
7953: LIST
7954: ADD
7955: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7956: LD_VAR 0 4
7960: PPUSH
7961: CALL_OW 274
7965: PPUSH
7966: LD_INT 2
7968: PPUSH
7969: CALL_OW 275
7973: PUSH
7974: LD_INT 80
7976: GREATEREQUAL
7977: IFFALSE 7996
// i := i ^ [ 3 ] ;
7979: LD_ADDR_VAR 0 1
7983: PUSH
7984: LD_VAR 0 1
7988: PUSH
7989: LD_INT 3
7991: PUSH
7992: EMPTY
7993: LIST
7994: ADD
7995: ST_TO_ADDR
// i := i diff 0 ;
7996: LD_ADDR_VAR 0 1
8000: PUSH
8001: LD_VAR 0 1
8005: PUSH
8006: LD_INT 0
8008: DIFF
8009: ST_TO_ADDR
// if i then
8010: LD_VAR 0 1
8014: IFFALSE 8120
// begin i := i ^ [ 4 ] ;
8016: LD_ADDR_VAR 0 1
8020: PUSH
8021: LD_VAR 0 1
8025: PUSH
8026: LD_INT 4
8028: PUSH
8029: EMPTY
8030: LIST
8031: ADD
8032: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8033: LD_STRING QInfo2
8035: PPUSH
8036: CALL_OW 97
8040: PUSH
8041: LD_INT 1
8043: DOUBLE
8044: EQUAL
8045: IFTRUE 8049
8047: GO 8060
8049: POP
// player_want_info := 3 ; 2 :
8050: LD_ADDR_EXP 13
8054: PUSH
8055: LD_INT 3
8057: ST_TO_ADDR
8058: GO 8118
8060: LD_INT 2
8062: DOUBLE
8063: EQUAL
8064: IFTRUE 8068
8066: GO 8079
8068: POP
// player_want_info := 1 ; 3 :
8069: LD_ADDR_EXP 13
8073: PUSH
8074: LD_INT 1
8076: ST_TO_ADDR
8077: GO 8118
8079: LD_INT 3
8081: DOUBLE
8082: EQUAL
8083: IFTRUE 8087
8085: GO 8098
8087: POP
// player_want_info := 2 ; 4 :
8088: LD_ADDR_EXP 13
8092: PUSH
8093: LD_INT 2
8095: ST_TO_ADDR
8096: GO 8118
8098: LD_INT 4
8100: DOUBLE
8101: EQUAL
8102: IFTRUE 8106
8104: GO 8117
8106: POP
// player_want_info := 0 ; end ;
8107: LD_ADDR_EXP 13
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
8115: GO 8118
8117: POP
// end else
8118: GO 8148
// case Query ( QInfoNothing ) of 1 :
8120: LD_STRING QInfoNothing
8122: PPUSH
8123: CALL_OW 97
8127: PUSH
8128: LD_INT 1
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8147
8136: POP
// player_want_info := 0 ; end ;
8137: LD_ADDR_EXP 13
8141: PUSH
8142: LD_INT 0
8144: ST_TO_ADDR
8145: GO 8148
8147: POP
// end ; end ; end ; if player_want_info then
8148: LD_EXP 13
8152: IFFALSE 9166
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8154: LD_ADDR_VAR 0 3
8158: PUSH
8159: LD_VAR 0 3
8163: PPUSH
8164: LD_INT 34
8166: PUSH
8167: LD_INT 32
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 72
8178: ST_TO_ADDR
// if player_want_mortar then
8179: LD_EXP 12
8183: IFFALSE 8505
// begin case player_want_info of 1 :
8185: LD_EXP 13
8189: PUSH
8190: LD_INT 1
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8209
8198: POP
// x := 5 ; 2 :
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_INT 5
8206: ST_TO_ADDR
8207: GO 8248
8209: LD_INT 2
8211: DOUBLE
8212: EQUAL
8213: IFTRUE 8217
8215: GO 8228
8217: POP
// x := 8 ; 3 :
8218: LD_ADDR_VAR 0 2
8222: PUSH
8223: LD_INT 8
8225: ST_TO_ADDR
8226: GO 8248
8228: LD_INT 3
8230: DOUBLE
8231: EQUAL
8232: IFTRUE 8236
8234: GO 8247
8236: POP
// x := 2 ; end ;
8237: LD_ADDR_VAR 0 2
8241: PUSH
8242: LD_INT 2
8244: ST_TO_ADDR
8245: GO 8248
8247: POP
// repeat wait ( 0 0$1 ) ;
8248: LD_INT 35
8250: PPUSH
8251: CALL_OW 67
// until not HasTask ( Gali ) ;
8255: LD_EXP 27
8259: PPUSH
8260: CALL_OW 314
8264: NOT
8265: IFFALSE 8248
// for i = 1 to x do
8267: LD_ADDR_VAR 0 1
8271: PUSH
8272: DOUBLE
8273: LD_INT 1
8275: DEC
8276: ST_TO_ADDR
8277: LD_VAR 0 2
8281: PUSH
8282: FOR_TO
8283: IFFALSE 8448
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8285: LD_EXP 27
8289: PPUSH
8290: LD_VAR 0 4
8294: PPUSH
8295: LD_EXP 13
8299: PPUSH
8300: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8304: LD_EXP 27
8308: PPUSH
8309: LD_VAR 0 3
8313: PUSH
8314: LD_INT 1
8316: ARRAY
8317: PPUSH
8318: CALL_OW 172
// AddComHold ( Gali ) ;
8322: LD_EXP 27
8326: PPUSH
8327: CALL_OW 200
// repeat wait ( 3 ) ;
8331: LD_INT 3
8333: PPUSH
8334: CALL_OW 67
// if player_attacked_ar then
8338: LD_EXP 16
8342: IFFALSE 8348
// exit ;
8344: POP
8345: POP
8346: GO 9346
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8348: LD_EXP 27
8352: PPUSH
8353: LD_VAR 0 3
8357: PUSH
8358: LD_INT 1
8360: ARRAY
8361: PPUSH
8362: CALL_OW 296
8366: PUSH
8367: LD_INT 4
8369: LESS
8370: PUSH
8371: LD_EXP 27
8375: PPUSH
8376: LD_EXP 13
8380: PPUSH
8381: CALL_OW 289
8385: AND
8386: IFFALSE 8331
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8388: LD_VAR 0 3
8392: PUSH
8393: LD_INT 1
8395: ARRAY
8396: PPUSH
8397: LD_EXP 13
8401: PPUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PPUSH
8411: LD_EXP 13
8415: PPUSH
8416: CALL_OW 289
8420: PUSH
8421: LD_INT 10
8423: PLUS
8424: PPUSH
8425: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8429: LD_EXP 27
8433: PPUSH
8434: LD_EXP 13
8438: PPUSH
8439: LD_INT 0
8441: PPUSH
8442: CALL_OW 290
// end ;
8446: GO 8282
8448: POP
8449: POP
// repeat wait ( 0 0$1 ) ;
8450: LD_INT 35
8452: PPUSH
8453: CALL_OW 67
// if player_attacked_ar then
8457: LD_EXP 16
8461: IFFALSE 8465
// exit ;
8463: GO 9346
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8465: LD_VAR 0 3
8469: PUSH
8470: LD_INT 1
8472: ARRAY
8473: PPUSH
8474: LD_EXP 13
8478: PPUSH
8479: CALL_OW 289
8483: PUSH
8484: LD_VAR 0 2
8488: PUSH
8489: LD_INT 10
8491: MUL
8492: EQUAL
8493: IFFALSE 8450
// no_oil_gain := false ;
8495: LD_ADDR_VAR 0 6
8499: PUSH
8500: LD_INT 0
8502: ST_TO_ADDR
// end else
8503: GO 8987
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 22
8512: PUSH
8513: LD_INT 2
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: PUSH
8520: LD_INT 21
8522: PUSH
8523: LD_INT 2
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8539: LD_EXP 27
8543: PPUSH
8544: LD_VAR 0 4
8548: PPUSH
8549: CALL_OW 250
8553: PUSH
8554: LD_INT 1
8556: PLUS
8557: PPUSH
8558: LD_VAR 0 4
8562: PPUSH
8563: CALL_OW 251
8567: PUSH
8568: LD_INT 1
8570: PLUS
8571: PPUSH
8572: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8576: LD_INT 35
8578: PPUSH
8579: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8583: LD_EXP 27
8587: PPUSH
8588: LD_VAR 0 4
8592: PPUSH
8593: CALL_OW 296
8597: PUSH
8598: LD_INT 4
8600: LESS
8601: IFFALSE 8576
// for i = 1 to 6 do
8603: LD_ADDR_VAR 0 1
8607: PUSH
8608: DOUBLE
8609: LD_INT 1
8611: DEC
8612: ST_TO_ADDR
8613: LD_INT 6
8615: PUSH
8616: FOR_TO
8617: IFFALSE 8814
// begin if player_attacked_ar then
8619: LD_EXP 16
8623: IFFALSE 8629
// exit ;
8625: POP
8626: POP
8627: GO 9346
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8629: LD_VAR 0 4
8633: PPUSH
8634: CALL_OW 274
8638: PPUSH
8639: LD_INT 2
8641: PPUSH
8642: CALL_OW 275
8646: PUSH
8647: LD_INT 10
8649: LESS
8650: PUSH
8651: LD_VAR 0 7
8655: NOT
8656: AND
8657: IFFALSE 8720
// begin first_warn := true ;
8659: LD_ADDR_VAR 0 7
8663: PUSH
8664: LD_INT 1
8666: ST_TO_ADDR
// DialogueOn ;
8667: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8671: LD_EXP 28
8675: PPUSH
8676: LD_STRING D9a-FAr1-1
8678: PPUSH
8679: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8683: LD_EXP 18
8687: PPUSH
8688: LD_STRING D9a-JMM-1
8690: PPUSH
8691: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8695: LD_EXP 26
8699: PPUSH
8700: LD_STRING D9a2-Ar1-1
8702: PPUSH
8703: CALL_OW 88
// DialogueOff ;
8707: CALL_OW 7
// wait ( time ) ;
8711: LD_VAR 0 5
8715: PPUSH
8716: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8720: LD_VAR 0 4
8724: PPUSH
8725: CALL_OW 274
8729: PPUSH
8730: LD_INT 2
8732: PPUSH
8733: CALL_OW 275
8737: PUSH
8738: LD_INT 10
8740: LESS
8741: IFFALSE 8767
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8743: LD_EXP 26
8747: PPUSH
8748: LD_STRING D9a3-Ar1-1
8750: PPUSH
8751: CALL_OW 88
// no_oil_gain := true ;
8755: LD_ADDR_VAR 0 6
8759: PUSH
8760: LD_INT 1
8762: ST_TO_ADDR
// break ;
8763: GO 8814
// end else
8765: GO 8812
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8767: LD_EXP 27
8771: PPUSH
8772: LD_VAR 0 4
8776: PPUSH
8777: LD_INT 2
8779: PPUSH
8780: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8784: LD_EXP 27
8788: PPUSH
8789: LD_VAR 0 3
8793: PUSH
8794: LD_VAR 0 1
8798: PUSH
8799: LD_INT 3
8801: MOD
8802: PUSH
8803: LD_INT 1
8805: PLUS
8806: ARRAY
8807: PPUSH
8808: CALL_OW 210
// end ; end ;
8812: GO 8616
8814: POP
8815: POP
// repeat wait ( 0 0$1 ) ;
8816: LD_INT 35
8818: PPUSH
8819: CALL_OW 67
// if player_attacked_ar then
8823: LD_EXP 16
8827: IFFALSE 8831
// exit ;
8829: GO 9346
// for i in tmp do
8831: LD_ADDR_VAR 0 1
8835: PUSH
8836: LD_VAR 0 3
8840: PUSH
8841: FOR_IN
8842: IFFALSE 8873
// if GetFuel ( i ) < 100 then
8844: LD_VAR 0 1
8848: PPUSH
8849: CALL_OW 261
8853: PUSH
8854: LD_INT 100
8856: LESS
8857: IFFALSE 8871
// begin x := i ;
8859: LD_ADDR_VAR 0 2
8863: PUSH
8864: LD_VAR 0 1
8868: ST_TO_ADDR
// break ;
8869: GO 8873
// end ;
8871: GO 8841
8873: POP
8874: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8875: LD_EXP 27
8879: PPUSH
8880: CALL_OW 314
8884: NOT
8885: PUSH
8886: LD_EXP 27
8890: PPUSH
8891: CALL_OW 281
8895: NOT
8896: AND
8897: IFFALSE 8930
// begin ComTransport ( Gali , dep , mat_oil ) ;
8899: LD_EXP 27
8903: PPUSH
8904: LD_VAR 0 4
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8916: LD_EXP 27
8920: PPUSH
8921: LD_VAR 0 2
8925: PPUSH
8926: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8930: LD_VAR 0 3
8934: PUSH
8935: LD_INT 1
8937: ARRAY
8938: PPUSH
8939: CALL_OW 261
8943: PUSH
8944: LD_INT 80
8946: GREATER
8947: PUSH
8948: LD_VAR 0 3
8952: PUSH
8953: LD_INT 2
8955: ARRAY
8956: PPUSH
8957: CALL_OW 261
8961: PUSH
8962: LD_INT 80
8964: GREATER
8965: AND
8966: PUSH
8967: LD_VAR 0 3
8971: PUSH
8972: LD_INT 3
8974: ARRAY
8975: PPUSH
8976: CALL_OW 261
8980: PUSH
8981: LD_INT 80
8983: GREATER
8984: AND
8985: IFFALSE 8816
// end ; ComHold ( Gali ) ;
8987: LD_EXP 27
8991: PPUSH
8992: CALL_OW 140
// if not no_oil_gain then
8996: LD_VAR 0 6
9000: NOT
9001: IFFALSE 9166
// begin DialogueOn ;
9003: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9007: LD_EXP 26
9011: PPUSH
9012: CALL_OW 87
// if player_want_mortar then
9016: LD_EXP 12
9020: IFFALSE 9046
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9022: LD_EXP 26
9026: PPUSH
9027: LD_STRING D9e-Ar1-1
9029: PPUSH
9030: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9034: LD_EXP 18
9038: PPUSH
9039: LD_STRING D10a-JMM-1
9041: PPUSH
9042: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9046: LD_EXP 26
9050: PPUSH
9051: LD_STRING D10a-Ar1-1
9053: PPUSH
9054: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9058: LD_EXP 27
9062: PPUSH
9063: LD_STRING D10a-Ar2-1
9065: PPUSH
9066: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9070: LD_EXP 28
9074: PPUSH
9075: LD_STRING D10a-FAr1-1
9077: PPUSH
9078: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9082: LD_EXP 27
9086: PPUSH
9087: LD_STRING D10a-Ar2-2
9089: PPUSH
9090: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9094: LD_EXP 28
9098: PPUSH
9099: LD_STRING D10a-FAr1-2
9101: PPUSH
9102: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9106: LD_EXP 26
9110: PPUSH
9111: LD_STRING D10a-Ar1-2
9113: PPUSH
9114: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9118: LD_EXP 18
9122: PPUSH
9123: LD_STRING D10a-JMM-2
9125: PPUSH
9126: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9130: LD_EXP 26
9134: PPUSH
9135: LD_STRING D10a-Ar1-3
9137: PPUSH
9138: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9142: LD_EXP 18
9146: PPUSH
9147: LD_STRING D10a-JMM-3
9149: PPUSH
9150: CALL_OW 88
// player_get_info := true ;
9154: LD_ADDR_EXP 15
9158: PUSH
9159: LD_INT 1
9161: ST_TO_ADDR
// DialogueOff ;
9162: CALL_OW 7
// end ; end ; if player_attacked_ar then
9166: LD_EXP 16
9170: IFFALSE 9174
// exit ;
9172: GO 9346
// if player_want_mortar or player_want_info then
9174: LD_EXP 12
9178: PUSH
9179: LD_EXP 13
9183: OR
9184: IFFALSE 9198
// Say ( Vervecken , D9f-Ar1-1 ) ;
9186: LD_EXP 26
9190: PPUSH
9191: LD_STRING D9f-Ar1-1
9193: PPUSH
9194: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9198: LD_INT 22
9200: PUSH
9201: LD_INT 2
9203: PUSH
9204: EMPTY
9205: LIST
9206: LIST
9207: PPUSH
9208: CALL_OW 69
9212: PPUSH
9213: LD_INT 51
9215: PPUSH
9216: LD_INT 99
9218: PPUSH
9219: CALL_OW 111
// wait ( 0 0$1 ) ;
9223: LD_INT 35
9225: PPUSH
9226: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9230: LD_INT 22
9232: PUSH
9233: LD_INT 2
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: PUSH
9240: LD_INT 92
9242: PUSH
9243: LD_INT 51
9245: PUSH
9246: LD_INT 99
9248: PUSH
9249: LD_INT 2
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: LIST
9256: LIST
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: PPUSH
9262: CALL_OW 69
9266: IFFALSE 9326
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9268: LD_ADDR_VAR 0 1
9272: PUSH
9273: LD_INT 22
9275: PUSH
9276: LD_INT 2
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: PUSH
9283: LD_INT 92
9285: PUSH
9286: LD_INT 51
9288: PUSH
9289: LD_INT 99
9291: PUSH
9292: LD_INT 2
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: LIST
9299: LIST
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PPUSH
9305: CALL_OW 69
9309: PUSH
9310: FOR_IN
9311: IFFALSE 9324
// RemoveUnit ( i ) ;
9313: LD_VAR 0 1
9317: PPUSH
9318: CALL_OW 64
9322: GO 9310
9324: POP
9325: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9326: LD_INT 22
9328: PUSH
9329: LD_INT 2
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL_OW 69
9340: PUSH
9341: LD_INT 0
9343: EQUAL
9344: IFFALSE 9198
// end ;
9346: PPOPN 9
9348: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9349: LD_EXP 16
9353: IFFALSE 9706
9355: GO 9357
9357: DISABLE
9358: LD_INT 0
9360: PPUSH
9361: PPUSH
9362: PPUSH
9363: PPUSH
// begin ru_can_attack := true ;
9364: LD_ADDR_EXP 8
9368: PUSH
9369: LD_INT 1
9371: ST_TO_ADDR
// mine_launched := false ;
9372: LD_ADDR_VAR 0 3
9376: PUSH
9377: LD_INT 0
9379: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9380: LD_INT 22
9382: PUSH
9383: LD_INT 2
9385: PUSH
9386: EMPTY
9387: LIST
9388: LIST
9389: PPUSH
9390: CALL_OW 69
9394: PPUSH
9395: LD_INT 51
9397: PPUSH
9398: LD_INT 99
9400: PPUSH
9401: CALL_OW 111
// if IsOk ( Vervecken ) then
9405: LD_EXP 26
9409: PPUSH
9410: CALL_OW 302
9414: IFFALSE 9428
// Say ( Vervecken , D11a-Ar1-1 ) ;
9416: LD_EXP 26
9420: PPUSH
9421: LD_STRING D11a-Ar1-1
9423: PPUSH
9424: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9428: LD_ADDR_VAR 0 2
9432: PUSH
9433: LD_EXP 33
9437: PPUSH
9438: LD_INT 25
9440: PUSH
9441: LD_INT 1
9443: PUSH
9444: EMPTY
9445: LIST
9446: LIST
9447: PPUSH
9448: CALL_OW 72
9452: ST_TO_ADDR
// for i in tmp do
9453: LD_ADDR_VAR 0 1
9457: PUSH
9458: LD_VAR 0 2
9462: PUSH
9463: FOR_IN
9464: IFFALSE 9527
// if MineOfUnit ( i ) then
9466: LD_VAR 0 1
9470: PPUSH
9471: CALL_OW 459
9475: IFFALSE 9525
// begin x := MineOfUnit ( i ) ;
9477: LD_ADDR_VAR 0 4
9481: PUSH
9482: LD_VAR 0 1
9486: PPUSH
9487: CALL_OW 459
9491: ST_TO_ADDR
// mine_launched := true ;
9492: LD_ADDR_VAR 0 3
9496: PUSH
9497: LD_INT 1
9499: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9500: LD_VAR 0 4
9504: PUSH
9505: LD_INT 1
9507: ARRAY
9508: PPUSH
9509: LD_VAR 0 4
9513: PUSH
9514: LD_INT 2
9516: ARRAY
9517: PPUSH
9518: LD_INT 2
9520: PPUSH
9521: CALL_OW 456
// end ;
9525: GO 9463
9527: POP
9528: POP
// if mine_launched and IsOk ( Vervecken ) then
9529: LD_VAR 0 3
9533: PUSH
9534: LD_EXP 26
9538: PPUSH
9539: CALL_OW 302
9543: AND
9544: IFFALSE 9558
// Say ( Vervecken , D11b-Ar1-1 ) ;
9546: LD_EXP 26
9550: PPUSH
9551: LD_STRING D11b-Ar1-1
9553: PPUSH
9554: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9558: LD_INT 22
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PPUSH
9568: CALL_OW 69
9572: PPUSH
9573: LD_INT 51
9575: PPUSH
9576: LD_INT 99
9578: PPUSH
9579: CALL_OW 111
// wait ( 0 0$1 ) ;
9583: LD_INT 35
9585: PPUSH
9586: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9590: LD_INT 22
9592: PUSH
9593: LD_INT 2
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 92
9602: PUSH
9603: LD_INT 51
9605: PUSH
9606: LD_INT 99
9608: PUSH
9609: LD_INT 2
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: PPUSH
9622: CALL_OW 69
9626: IFFALSE 9686
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9628: LD_ADDR_VAR 0 1
9632: PUSH
9633: LD_INT 22
9635: PUSH
9636: LD_INT 2
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: PUSH
9643: LD_INT 92
9645: PUSH
9646: LD_INT 51
9648: PUSH
9649: LD_INT 99
9651: PUSH
9652: LD_INT 2
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 69
9669: PUSH
9670: FOR_IN
9671: IFFALSE 9684
// RemoveUnit ( i ) ;
9673: LD_VAR 0 1
9677: PPUSH
9678: CALL_OW 64
9682: GO 9670
9684: POP
9685: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9686: LD_INT 22
9688: PUSH
9689: LD_INT 2
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: PPUSH
9696: CALL_OW 69
9700: PUSH
9701: LD_INT 0
9703: EQUAL
9704: IFFALSE 9558
// end ;
9706: PPOPN 4
9708: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9709: LD_EXP 10
9713: IFFALSE 9892
9715: GO 9717
9717: DISABLE
9718: LD_INT 0
9720: PPUSH
// begin Wait ( 10 10$00 ) ;
9721: LD_INT 21000
9723: PPUSH
9724: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9728: LD_INT 22
9730: PUSH
9731: LD_INT 2
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 69
9742: IFFALSE 9892
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9744: LD_INT 22
9746: PUSH
9747: LD_INT 2
9749: PUSH
9750: EMPTY
9751: LIST
9752: LIST
9753: PPUSH
9754: CALL_OW 69
9758: PPUSH
9759: LD_INT 51
9761: PPUSH
9762: LD_INT 99
9764: PPUSH
9765: CALL_OW 114
// wait ( 0 0$1 ) ;
9769: LD_INT 35
9771: PPUSH
9772: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9776: LD_INT 22
9778: PUSH
9779: LD_INT 2
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PUSH
9786: LD_INT 92
9788: PUSH
9789: LD_INT 51
9791: PUSH
9792: LD_INT 99
9794: PUSH
9795: LD_INT 2
9797: PUSH
9798: EMPTY
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 69
9812: IFFALSE 9872
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9814: LD_ADDR_VAR 0 1
9818: PUSH
9819: LD_INT 22
9821: PUSH
9822: LD_INT 2
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: LD_INT 92
9831: PUSH
9832: LD_INT 51
9834: PUSH
9835: LD_INT 99
9837: PUSH
9838: LD_INT 2
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: PPUSH
9851: CALL_OW 69
9855: PUSH
9856: FOR_IN
9857: IFFALSE 9870
// RemoveUnit ( i ) ;
9859: LD_VAR 0 1
9863: PPUSH
9864: CALL_OW 64
9868: GO 9856
9870: POP
9871: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9872: LD_INT 22
9874: PUSH
9875: LD_INT 2
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: PPUSH
9882: CALL_OW 69
9886: PUSH
9887: LD_INT 0
9889: EQUAL
9890: IFFALSE 9744
// end ; end ;
9892: PPOPN 1
9894: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9895: LD_EXP 4
9899: IFFALSE 10827
9901: GO 9903
9903: DISABLE
9904: LD_INT 0
9906: PPUSH
9907: PPUSH
9908: PPUSH
// begin Wait ( game_time ) ;
9909: LD_EXP 7
9913: PPUSH
9914: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9918: LD_INT 35
9920: PPUSH
9921: CALL_OW 67
// until ( not ru_can_attack ) ;
9925: LD_EXP 8
9929: NOT
9930: IFFALSE 9918
// Wait ( 0 0$35 ) ;
9932: LD_INT 1225
9934: PPUSH
9935: CALL_OW 67
// DialogueOn ;
9939: CALL_OW 6
// InGameOn ;
9943: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9947: LD_EXP 25
9951: PPUSH
9952: LD_STRING D12-Pow-1
9954: PPUSH
9955: CALL_OW 94
// InGameOff ;
9959: CALL_OW 9
// DialogueOff ;
9963: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9967: LD_STRING M4
9969: PPUSH
9970: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9974: LD_INT 5
9976: PPUSH
9977: LD_INT 1
9979: PPUSH
9980: CALL_OW 424
// can_end := true ;
9984: LD_ADDR_EXP 17
9988: PUSH
9989: LD_INT 1
9991: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9999: CALL 784 0 0
10003: PUSH
10004: LD_INT 20
10006: GREATEREQUAL
10007: PUSH
10008: LD_INT 22
10010: PUSH
10011: LD_INT 1
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: PUSH
10018: LD_INT 21
10020: PUSH
10021: LD_INT 1
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PPUSH
10032: CALL_OW 69
10036: PUSH
10037: LD_INT 5
10039: PPUSH
10040: LD_INT 22
10042: PUSH
10043: LD_INT 1
10045: PUSH
10046: EMPTY
10047: LIST
10048: LIST
10049: PUSH
10050: LD_INT 21
10052: PUSH
10053: LD_INT 1
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: PUSH
10060: EMPTY
10061: LIST
10062: LIST
10063: PPUSH
10064: CALL_OW 70
10068: PUSH
10069: LD_INT 22
10071: PUSH
10072: LD_INT 1
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PUSH
10079: LD_INT 55
10081: PUSH
10082: EMPTY
10083: LIST
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: PPUSH
10089: CALL_OW 69
10093: PLUS
10094: LESSEQUAL
10095: AND
10096: IFFALSE 9992
// if not player_get_info then
10098: LD_EXP 15
10102: NOT
10103: IFFALSE 10114
// player_get_info := - 1 ;
10105: LD_ADDR_EXP 15
10109: PUSH
10110: LD_INT 1
10112: NEG
10113: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10114: LD_STRING Information
10116: PPUSH
10117: LD_EXP 15
10121: PPUSH
10122: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10126: LD_ADDR_VAR 0 2
10130: PUSH
10131: LD_INT 22
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: PUSH
10141: LD_INT 2
10143: PUSH
10144: LD_INT 25
10146: PUSH
10147: LD_INT 2
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 25
10156: PUSH
10157: LD_INT 16
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 34
10166: PUSH
10167: LD_INT 12
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PPUSH
10184: CALL_OW 69
10188: ST_TO_ADDR
// sib := GetTerminalCargo ;
10189: LD_ADDR_VAR 0 3
10193: PUSH
10194: CALL 784 0 0
10198: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10199: LD_ADDR_VAR 0 3
10203: PUSH
10204: LD_VAR 0 3
10208: PUSH
10209: LD_INT 6
10211: PPUSH
10212: LD_INT 3
10214: PPUSH
10215: CALL_OW 287
10219: PLUS
10220: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10221: LD_ADDR_VAR 0 3
10225: PUSH
10226: LD_VAR 0 3
10230: PUSH
10231: LD_VAR 0 2
10235: PPUSH
10236: LD_INT 3
10238: PPUSH
10239: CALL_OW 289
10243: PLUS
10244: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10245: LD_VAR 0 3
10249: PUSH
10250: LD_INT 2
10252: PUSH
10253: LD_OWVAR 67
10257: PLUS
10258: PUSH
10259: LD_INT 50
10261: MUL
10262: LESS
10263: IFFALSE 10288
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10265: LD_STRING MuchSiberite
10267: PPUSH
10268: LD_INT 2
10270: NEG
10271: PUSH
10272: LD_OWVAR 67
10276: MUL
10277: PUSH
10278: LD_INT 1
10280: PLUS
10281: PPUSH
10282: CALL_OW 101
10286: GO 10298
// AddMedal ( MuchSiberite , 1 ) ;
10288: LD_STRING MuchSiberite
10290: PPUSH
10291: LD_INT 1
10293: PPUSH
10294: CALL_OW 101
// GiveMedals ( MAIN ) ;
10298: LD_STRING MAIN
10300: PPUSH
10301: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10305: LD_INT 22
10307: PUSH
10308: LD_INT 1
10310: PUSH
10311: EMPTY
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 2
10317: PUSH
10318: LD_INT 25
10320: PUSH
10321: LD_INT 1
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: PUSH
10328: LD_INT 25
10330: PUSH
10331: LD_INT 2
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: PUSH
10338: LD_INT 25
10340: PUSH
10341: LD_INT 3
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: PUSH
10348: LD_INT 25
10350: PUSH
10351: LD_INT 4
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: PUSH
10358: LD_INT 25
10360: PUSH
10361: LD_INT 8
10363: PUSH
10364: EMPTY
10365: LIST
10366: LIST
10367: PUSH
10368: EMPTY
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 69
10384: PPUSH
10385: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10389: LD_ADDR_VAR 0 2
10393: PUSH
10394: LD_INT 22
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 25
10406: PUSH
10407: LD_INT 8
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: PUSH
10414: EMPTY
10415: LIST
10416: LIST
10417: PPUSH
10418: CALL_OW 69
10422: ST_TO_ADDR
// if tmp then
10423: LD_VAR 0 2
10427: IFFALSE 10458
// for i in tmp do
10429: LD_ADDR_VAR 0 1
10433: PUSH
10434: LD_VAR 0 2
10438: PUSH
10439: FOR_IN
10440: IFFALSE 10456
// SetClass ( i , 1 ) ;
10442: LD_VAR 0 1
10446: PPUSH
10447: LD_INT 1
10449: PPUSH
10450: CALL_OW 336
10454: GO 10439
10456: POP
10457: POP
// SaveVariable ( sib , 09_sibRes ) ;
10458: LD_VAR 0 3
10462: PPUSH
10463: LD_STRING 09_sibRes
10465: PPUSH
10466: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10470: LD_EXP 15
10474: PPUSH
10475: LD_STRING 09_arInfo
10477: PPUSH
10478: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10482: LD_EXP 18
10486: PPUSH
10487: LD_EXP 1
10491: PUSH
10492: LD_STRING JMM
10494: STR
10495: PPUSH
10496: CALL_OW 38
// if IsLive ( Gary ) then
10500: LD_EXP 19
10504: PPUSH
10505: CALL_OW 300
10509: IFFALSE 10529
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10511: LD_EXP 19
10515: PPUSH
10516: LD_EXP 1
10520: PUSH
10521: LD_STRING Gary
10523: STR
10524: PPUSH
10525: CALL_OW 38
// if IsLive ( Bobby ) then
10529: LD_EXP 20
10533: PPUSH
10534: CALL_OW 300
10538: IFFALSE 10558
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10540: LD_EXP 20
10544: PPUSH
10545: LD_EXP 1
10549: PUSH
10550: LD_STRING Bobby
10552: STR
10553: PPUSH
10554: CALL_OW 38
// if IsLive ( Cyrus ) then
10558: LD_EXP 21
10562: PPUSH
10563: CALL_OW 300
10567: IFFALSE 10587
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10569: LD_EXP 21
10573: PPUSH
10574: LD_EXP 1
10578: PUSH
10579: LD_STRING Cyrus
10581: STR
10582: PPUSH
10583: CALL_OW 38
// if IsLive ( Houten ) then
10587: LD_EXP 22
10591: PPUSH
10592: CALL_OW 300
10596: IFFALSE 10616
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10598: LD_EXP 22
10602: PPUSH
10603: LD_EXP 1
10607: PUSH
10608: LD_STRING Houten
10610: STR
10611: PPUSH
10612: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10616: LD_ADDR_VAR 0 2
10620: PUSH
10621: LD_INT 22
10623: PUSH
10624: LD_INT 1
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: LD_INT 2
10633: PUSH
10634: LD_INT 25
10636: PUSH
10637: LD_INT 1
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PUSH
10644: LD_INT 25
10646: PUSH
10647: LD_INT 2
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: LD_INT 25
10656: PUSH
10657: LD_INT 3
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 25
10666: PUSH
10667: LD_INT 4
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: LIST
10678: LIST
10679: LIST
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PPUSH
10685: CALL_OW 69
10689: PUSH
10690: LD_EXP 18
10694: PUSH
10695: LD_EXP 21
10699: PUSH
10700: LD_EXP 20
10704: PUSH
10705: LD_EXP 22
10709: PUSH
10710: LD_EXP 19
10714: PUSH
10715: EMPTY
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: DIFF
10722: ST_TO_ADDR
// if tmp then
10723: LD_VAR 0 2
10727: IFFALSE 10747
// SaveCharacters ( tmp , mission_prefix & others ) ;
10729: LD_VAR 0 2
10733: PPUSH
10734: LD_EXP 1
10738: PUSH
10739: LD_STRING others
10741: STR
10742: PPUSH
10743: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10747: LD_ADDR_VAR 0 2
10751: PUSH
10752: LD_INT 22
10754: PUSH
10755: LD_INT 1
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: PUSH
10762: LD_INT 2
10764: PUSH
10765: LD_INT 25
10767: PUSH
10768: LD_INT 12
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: PUSH
10775: LD_INT 25
10777: PUSH
10778: LD_INT 16
10780: PUSH
10781: EMPTY
10782: LIST
10783: LIST
10784: PUSH
10785: EMPTY
10786: LIST
10787: LIST
10788: LIST
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: ST_TO_ADDR
// if tmp then
10799: LD_VAR 0 2
10803: IFFALSE 10823
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10805: LD_VAR 0 2
10809: PPUSH
10810: LD_EXP 1
10814: PUSH
10815: LD_STRING apes
10817: STR
10818: PPUSH
10819: CALL_OW 38
// YouWin ;
10823: CALL_OW 103
// end ; end_of_file
10827: PPOPN 3
10829: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10830: LD_VAR 0 1
10834: PPUSH
10835: CALL_OW 266
10839: PUSH
10840: LD_INT 0
10842: EQUAL
10843: PUSH
10844: LD_EXP 3
10848: NOT
10849: AND
10850: IFFALSE 10874
// begin terminal := b ;
10852: LD_ADDR_EXP 3
10856: PUSH
10857: LD_VAR 0 1
10861: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10862: LD_EXP 3
10866: PPUSH
10867: LD_STRING terminal
10869: PPUSH
10870: CALL_OW 500
// end ; end ;
10874: PPOPN 2
10876: END
// on BuildingComplete ( b ) do var i ;
10877: LD_INT 0
10879: PPUSH
// begin if GetSide ( b ) = 3 then
10880: LD_VAR 0 1
10884: PPUSH
10885: CALL_OW 255
10889: PUSH
10890: LD_INT 3
10892: EQUAL
10893: IFFALSE 10933
// for i = 1 to 4 do
10895: LD_ADDR_VAR 0 2
10899: PUSH
10900: DOUBLE
10901: LD_INT 1
10903: DEC
10904: ST_TO_ADDR
10905: LD_INT 4
10907: PUSH
10908: FOR_TO
10909: IFFALSE 10931
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10911: LD_ADDR_EXP 36
10915: PUSH
10916: LD_EXP 36
10920: PPUSH
10921: LD_INT 1
10923: PPUSH
10924: CALL_OW 3
10928: ST_TO_ADDR
10929: GO 10908
10931: POP
10932: POP
// end ;
10933: PPOPN 2
10935: END
// on VehicleConstructed ( veh , fac ) do var i ;
10936: LD_INT 0
10938: PPUSH
// begin if GetSide ( veh ) = 3 then
10939: LD_VAR 0 1
10943: PPUSH
10944: CALL_OW 255
10948: PUSH
10949: LD_INT 3
10951: EQUAL
10952: IFFALSE 11077
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10954: LD_VAR 0 1
10958: PPUSH
10959: CALL_OW 264
10963: PUSH
10964: LD_INT 53
10966: PUSH
10967: LD_INT 52
10969: PUSH
10970: LD_INT 51
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: LIST
10977: IN
10978: NOT
10979: IFFALSE 10997
// ru_force := ru_force ^ veh ;
10981: LD_ADDR_EXP 35
10985: PUSH
10986: LD_EXP 35
10990: PUSH
10991: LD_VAR 0 1
10995: ADD
10996: ST_TO_ADDR
// for i = 1 to 4 do
10997: LD_ADDR_VAR 0 3
11001: PUSH
11002: DOUBLE
11003: LD_INT 1
11005: DEC
11006: ST_TO_ADDR
11007: LD_INT 4
11009: PUSH
11010: FOR_TO
11011: IFFALSE 11033
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11013: LD_ADDR_EXP 37
11017: PUSH
11018: LD_EXP 37
11022: PPUSH
11023: LD_INT 1
11025: PPUSH
11026: CALL_OW 3
11030: ST_TO_ADDR
11031: GO 11010
11033: POP
11034: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11035: LD_VAR 0 1
11039: PPUSH
11040: CALL_OW 264
11044: PUSH
11045: LD_INT 53
11047: EQUAL
11048: IFFALSE 11077
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11050: LD_VAR 0 1
11054: PPUSH
11055: LD_INT 7
11057: PPUSH
11058: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11062: LD_VAR 0 1
11066: PPUSH
11067: LD_INT 170
11069: PPUSH
11070: LD_INT 235
11072: PPUSH
11073: CALL_OW 171
// end ; end ; end ;
11077: PPOPN 3
11079: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11080: LD_VAR 0 1
11084: PUSH
11085: LD_INT 1
11087: EQUAL
11088: PUSH
11089: LD_VAR 0 2
11093: PUSH
11094: LD_INT 2
11096: EQUAL
11097: AND
11098: PUSH
11099: LD_VAR 0 1
11103: PUSH
11104: LD_INT 2
11106: EQUAL
11107: PUSH
11108: LD_VAR 0 2
11112: PUSH
11113: LD_INT 1
11115: EQUAL
11116: AND
11117: OR
11118: IFFALSE 11128
// player_attacked_ar := true ;
11120: LD_ADDR_EXP 16
11124: PUSH
11125: LD_INT 1
11127: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11128: LD_VAR 0 1
11132: PUSH
11133: LD_INT 1
11135: EQUAL
11136: PUSH
11137: LD_VAR 0 2
11141: PUSH
11142: LD_INT 4
11144: EQUAL
11145: AND
11146: PUSH
11147: LD_VAR 0 1
11151: PUSH
11152: LD_INT 4
11154: EQUAL
11155: PUSH
11156: LD_VAR 0 2
11160: PUSH
11161: LD_INT 1
11163: EQUAL
11164: AND
11165: OR
11166: IFFALSE 11175
// YouLost ( Traitor ) ;
11168: LD_STRING Traitor
11170: PPUSH
11171: CALL_OW 104
// end ;
11175: PPOPN 2
11177: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11178: LD_VAR 0 1
11182: PUSH
11183: LD_EXP 18
11187: EQUAL
11188: IFFALSE 11197
// YouLost ( JMM ) ;
11190: LD_STRING JMM
11192: PPUSH
11193: CALL_OW 104
// if un = terminal then
11197: LD_VAR 0 1
11201: PUSH
11202: LD_EXP 3
11206: EQUAL
11207: IFFALSE 11216
// YouLost ( Terminal ) ;
11209: LD_STRING Terminal
11211: PPUSH
11212: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11216: LD_VAR 0 1
11220: PUSH
11221: LD_INT 22
11223: PUSH
11224: LD_INT 3
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: PUSH
11231: LD_INT 21
11233: PUSH
11234: LD_INT 3
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: EMPTY
11242: LIST
11243: LIST
11244: PPUSH
11245: CALL_OW 69
11249: IN
11250: IFFALSE 11396
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11252: LD_VAR 0 1
11256: PPUSH
11257: CALL_OW 266
11261: PUSH
11262: LD_INT 33
11264: PUSH
11265: LD_INT 26
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: IN
11272: IFFALSE 11331
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11274: LD_ADDR_EXP 36
11278: PUSH
11279: LD_EXP 36
11283: PUSH
11284: LD_VAR 0 1
11288: PPUSH
11289: CALL_OW 266
11293: PUSH
11294: LD_VAR 0 1
11298: PPUSH
11299: CALL_OW 250
11303: PUSH
11304: LD_VAR 0 1
11308: PPUSH
11309: CALL_OW 251
11313: PUSH
11314: LD_VAR 0 1
11318: PPUSH
11319: CALL_OW 254
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: ADD
11330: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11331: LD_VAR 0 1
11335: PPUSH
11336: CALL_OW 266
11340: PUSH
11341: LD_INT 5
11343: EQUAL
11344: IFFALSE 11396
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11346: LD_ADDR_EXP 36
11350: PUSH
11351: LD_EXP 36
11355: PUSH
11356: LD_INT 4
11358: PUSH
11359: LD_VAR 0 1
11363: PPUSH
11364: CALL_OW 250
11368: PUSH
11369: LD_VAR 0 1
11373: PPUSH
11374: CALL_OW 251
11378: PUSH
11379: LD_VAR 0 1
11383: PPUSH
11384: CALL_OW 254
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: ADD
11395: ST_TO_ADDR
// end ; if un in ru_force then
11396: LD_VAR 0 1
11400: PUSH
11401: LD_EXP 35
11405: IN
11406: IFFALSE 11442
// begin ru_force := ru_force diff un ;
11408: LD_ADDR_EXP 35
11412: PUSH
11413: LD_EXP 35
11417: PUSH
11418: LD_VAR 0 1
11422: DIFF
11423: ST_TO_ADDR
// if ru_force = 0 then
11424: LD_EXP 35
11428: PUSH
11429: LD_INT 0
11431: EQUAL
11432: IFFALSE 11442
// ru_can_attack := false ;
11434: LD_ADDR_EXP 8
11438: PUSH
11439: LD_INT 0
11441: ST_TO_ADDR
// end ; end ; end_of_file
11442: PPOPN 1
11444: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11445: LD_EXP 5
11449: PUSH
11450: LD_EXP 6
11454: AND
11455: IFFALSE 11533
11457: GO 11459
11459: DISABLE
11460: LD_INT 0
11462: PPUSH
// begin enable ;
11463: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11464: LD_ADDR_VAR 0 1
11468: PUSH
11469: LD_INT 60
11471: PUSH
11472: CALL 784 0 0
11476: MINUS
11477: ST_TO_ADDR
// if sib < 0 then
11478: LD_VAR 0 1
11482: PUSH
11483: LD_INT 0
11485: LESS
11486: IFFALSE 11496
// sib := 0 ;
11488: LD_ADDR_VAR 0 1
11492: PUSH
11493: LD_INT 0
11495: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11496: LD_ADDR_OWVAR 47
11500: PUSH
11501: LD_STRING #Am09-1
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 6
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: LIST
11518: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11519: LD_ADDR_EXP 6
11523: PUSH
11524: LD_EXP 6
11528: PUSH
11529: LD_INT 35
11531: MINUS
11532: ST_TO_ADDR
// end ;
11533: PPOPN 1
11535: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11536: LD_EXP 6
11540: PUSH
11541: LD_INT 0
11543: EQUAL
11544: IFFALSE 11556
11546: GO 11548
11548: DISABLE
// display_strings := [ ] ;
11549: LD_ADDR_OWVAR 47
11553: PUSH
11554: EMPTY
11555: ST_TO_ADDR
11556: END
// every 0 0$01 trigger ru_force and debug do
11557: LD_EXP 35
11561: PUSH
11562: LD_EXP 2
11566: AND
11567: IFFALSE 11583
11569: GO 11571
11571: DISABLE
// begin enable ;
11572: ENABLE
// display_strings := ru_force ;
11573: LD_ADDR_OWVAR 47
11577: PUSH
11578: LD_EXP 35
11582: ST_TO_ADDR
// end ;
11583: END
// every 1 1$35 do var i , tmp ;
11584: GO 11586
11586: DISABLE
11587: LD_INT 0
11589: PPUSH
11590: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11591: LD_ADDR_VAR 0 2
11595: PUSH
11596: LD_INT 1155
11598: PUSH
11599: LD_INT 1225
11601: PUSH
11602: LD_INT 1435
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: LIST
11609: PUSH
11610: LD_OWVAR 67
11614: ARRAY
11615: ST_TO_ADDR
// i := 0 ;
11616: LD_ADDR_VAR 0 1
11620: PUSH
11621: LD_INT 0
11623: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11624: LD_INT 1
11626: PPUSH
11627: LD_INT 5
11629: PPUSH
11630: CALL_OW 12
11634: PPUSH
11635: LD_INT 75
11637: PPUSH
11638: LD_INT 75
11640: PPUSH
11641: LD_INT 20
11643: PPUSH
11644: LD_INT 1
11646: PPUSH
11647: CALL_OW 56
// wait ( tmp ) ;
11651: LD_VAR 0 2
11655: PPUSH
11656: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11660: LD_ADDR_VAR 0 2
11664: PUSH
11665: LD_VAR 0 2
11669: PUSH
11670: LD_INT 105
11672: PPUSH
11673: LD_INT 315
11675: PPUSH
11676: CALL_OW 12
11680: PLUS
11681: ST_TO_ADDR
// i := i + 1 ;
11682: LD_ADDR_VAR 0 1
11686: PUSH
11687: LD_VAR 0 1
11691: PUSH
11692: LD_INT 1
11694: PLUS
11695: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11696: LD_VAR 0 1
11700: PUSH
11701: LD_INT 3
11703: MOD
11704: PUSH
11705: LD_INT 0
11707: EQUAL
11708: PUSH
11709: LD_EXP 4
11713: AND
11714: IFFALSE 11752
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11716: LD_INT 2
11718: PPUSH
11719: LD_INT 5
11721: PPUSH
11722: CALL_OW 12
11726: PPUSH
11727: LD_INT 8
11729: PPUSH
11730: LD_INT 1
11732: PPUSH
11733: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11737: LD_INT 665
11739: PPUSH
11740: LD_INT 735
11742: PPUSH
11743: CALL_OW 12
11747: PPUSH
11748: CALL_OW 67
// end ; until tick > game_time ;
11752: LD_OWVAR 1
11756: PUSH
11757: LD_EXP 7
11761: GREATER
11762: IFFALSE 11624
// end ; end_of_file
11764: PPOPN 2
11766: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11767: LD_INT 0
11769: PPUSH
11770: PPUSH
11771: PPUSH
11772: PPUSH
11773: PPUSH
11774: PPUSH
// x := 76 ;
11775: LD_ADDR_VAR 0 5
11779: PUSH
11780: LD_INT 76
11782: ST_TO_ADDR
// y := 147 ;
11783: LD_ADDR_VAR 0 6
11787: PUSH
11788: LD_INT 147
11790: ST_TO_ADDR
// uc_side := 2 ;
11791: LD_ADDR_OWVAR 20
11795: PUSH
11796: LD_INT 2
11798: ST_TO_ADDR
// uc_nation := 2 ;
11799: LD_ADDR_OWVAR 21
11803: PUSH
11804: LD_INT 2
11806: ST_TO_ADDR
// InitHc ;
11807: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11811: LD_INT 1
11813: PPUSH
11814: LD_INT 1
11816: PPUSH
11817: LD_INT 6
11819: PPUSH
11820: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11824: LD_ADDR_OWVAR 26
11828: PUSH
11829: LD_STRING Nicolas Vervecken
11831: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11832: LD_ADDR_OWVAR 33
11836: PUSH
11837: LD_STRING SecondCharsGal
11839: ST_TO_ADDR
// hc_face_number := 3 ;
11840: LD_ADDR_OWVAR 34
11844: PUSH
11845: LD_INT 3
11847: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11848: LD_ADDR_OWVAR 29
11852: PUSH
11853: LD_INT 11
11855: PUSH
11856: LD_INT 10
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: ST_TO_ADDR
// Vervecken := CreateHuman ;
11863: LD_ADDR_EXP 26
11867: PUSH
11868: CALL_OW 44
11872: ST_TO_ADDR
// ar_force := Vervecken ;
11873: LD_ADDR_EXP 33
11877: PUSH
11878: LD_EXP 26
11882: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11883: LD_INT 1
11885: PPUSH
11886: LD_INT 2
11888: PPUSH
11889: LD_INT 6
11891: PPUSH
11892: CALL_OW 380
// hc_name := Louis Gali ;
11896: LD_ADDR_OWVAR 26
11900: PUSH
11901: LD_STRING Louis Gali
11903: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11904: LD_ADDR_OWVAR 33
11908: PUSH
11909: LD_STRING SecondCharsGal
11911: ST_TO_ADDR
// hc_face_number := 2 ;
11912: LD_ADDR_OWVAR 34
11916: PUSH
11917: LD_INT 2
11919: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11920: LD_ADDR_OWVAR 29
11924: PUSH
11925: LD_INT 10
11927: PUSH
11928: LD_INT 11
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: ST_TO_ADDR
// Gali := CreateHuman ;
11935: LD_ADDR_EXP 27
11939: PUSH
11940: CALL_OW 44
11944: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11945: LD_ADDR_EXP 33
11949: PUSH
11950: LD_EXP 33
11954: PUSH
11955: LD_EXP 27
11959: ADD
11960: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11961: LD_INT 2
11963: PPUSH
11964: LD_INT 1
11966: PPUSH
11967: LD_INT 6
11969: PPUSH
11970: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11974: LD_ADDR_OWVAR 26
11978: PUSH
11979: LD_STRING Maria Bogdanovic
11981: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11982: LD_ADDR_OWVAR 33
11986: PUSH
11987: LD_STRING SecondCharsGal
11989: ST_TO_ADDR
// hc_face_number := 14 ;
11990: LD_ADDR_OWVAR 34
11994: PUSH
11995: LD_INT 14
11997: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11998: LD_ADDR_OWVAR 29
12002: PUSH
12003: LD_INT 12
12005: PUSH
12006: LD_INT 9
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12013: LD_ADDR_EXP 28
12017: PUSH
12018: CALL_OW 44
12022: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12023: LD_ADDR_EXP 33
12027: PUSH
12028: LD_EXP 33
12032: PUSH
12033: LD_EXP 28
12037: ADD
12038: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12039: LD_INT 1
12041: PPUSH
12042: LD_INT 3
12044: PPUSH
12045: LD_INT 6
12047: PPUSH
12048: CALL_OW 380
// hc_name = Kntor Radomr ;
12052: LD_ADDR_OWVAR 26
12056: PUSH
12057: LD_STRING Kntor Radomr
12059: ST_TO_ADDR
// hc_gallery = sandar ;
12060: LD_ADDR_OWVAR 33
12064: PUSH
12065: LD_STRING sandar
12067: ST_TO_ADDR
// hc_face_number = 12 ;
12068: LD_ADDR_OWVAR 34
12072: PUSH
12073: LD_INT 12
12075: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12076: LD_ADDR_OWVAR 29
12080: PUSH
12081: LD_INT 9
12083: PUSH
12084: LD_INT 9
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: ST_TO_ADDR
// Kantor = CreateHuman ;
12091: LD_ADDR_EXP 29
12095: PUSH
12096: CALL_OW 44
12100: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12101: LD_ADDR_EXP 33
12105: PUSH
12106: LD_EXP 33
12110: PUSH
12111: LD_EXP 29
12115: ADD
12116: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12117: LD_INT 1
12119: PPUSH
12120: LD_INT 3
12122: PPUSH
12123: LD_INT 6
12125: PPUSH
12126: CALL_OW 380
// hc_name = Herczeg Farkas ;
12130: LD_ADDR_OWVAR 26
12134: PUSH
12135: LD_STRING Herczeg Farkas
12137: ST_TO_ADDR
// hc_gallery = sandar ;
12138: LD_ADDR_OWVAR 33
12142: PUSH
12143: LD_STRING sandar
12145: ST_TO_ADDR
// hc_face_number = 28 ;
12146: LD_ADDR_OWVAR 34
12150: PUSH
12151: LD_INT 28
12153: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12154: LD_ADDR_OWVAR 29
12158: PUSH
12159: LD_INT 10
12161: PUSH
12162: LD_INT 9
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: ST_TO_ADDR
// Herczeg = CreateHuman ;
12169: LD_ADDR_EXP 30
12173: PUSH
12174: CALL_OW 44
12178: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12179: LD_ADDR_EXP 33
12183: PUSH
12184: LD_EXP 33
12188: PUSH
12189: LD_EXP 30
12193: ADD
12194: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12195: LD_INT 1
12197: PPUSH
12198: LD_INT 1
12200: PPUSH
12201: LD_INT 6
12203: PPUSH
12204: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12208: LD_ADDR_OWVAR 26
12212: PUSH
12213: LD_STRING Ronn Horntvedt
12215: ST_TO_ADDR
// hc_gallery = sandar ;
12216: LD_ADDR_OWVAR 33
12220: PUSH
12221: LD_STRING sandar
12223: ST_TO_ADDR
// hc_face_number = 29 ;
12224: LD_ADDR_OWVAR 34
12228: PUSH
12229: LD_INT 29
12231: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12232: LD_ADDR_OWVAR 29
12236: PUSH
12237: LD_INT 11
12239: PUSH
12240: LD_INT 11
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: ST_TO_ADDR
// Ronn = CreateHuman ;
12247: LD_ADDR_EXP 31
12251: PUSH
12252: CALL_OW 44
12256: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12257: LD_ADDR_EXP 33
12261: PUSH
12262: LD_EXP 33
12266: PUSH
12267: LD_EXP 31
12271: ADD
12272: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12273: LD_INT 2
12275: PPUSH
12276: LD_INT 3
12278: PPUSH
12279: LD_INT 6
12281: PPUSH
12282: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12286: LD_ADDR_OWVAR 26
12290: PUSH
12291: LD_STRING Mia D. Mathiasen
12293: ST_TO_ADDR
// hc_gallery = sandar ;
12294: LD_ADDR_OWVAR 33
12298: PUSH
12299: LD_STRING sandar
12301: ST_TO_ADDR
// hc_face_number = 31 ;
12302: LD_ADDR_OWVAR 34
12306: PUSH
12307: LD_INT 31
12309: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12310: LD_ADDR_OWVAR 29
12314: PUSH
12315: LD_INT 10
12317: PUSH
12318: LD_INT 10
12320: PUSH
12321: EMPTY
12322: LIST
12323: LIST
12324: ST_TO_ADDR
// Mia = CreateHuman ;
12325: LD_ADDR_EXP 32
12329: PUSH
12330: CALL_OW 44
12334: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12335: LD_ADDR_EXP 33
12339: PUSH
12340: LD_EXP 33
12344: PUSH
12345: LD_EXP 32
12349: ADD
12350: ST_TO_ADDR
// for i = 1 to 2 do
12351: LD_ADDR_VAR 0 4
12355: PUSH
12356: DOUBLE
12357: LD_INT 1
12359: DEC
12360: ST_TO_ADDR
12361: LD_INT 2
12363: PUSH
12364: FOR_TO
12365: IFFALSE 12406
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12367: LD_ADDR_VAR 0 3
12371: PUSH
12372: LD_VAR 0 3
12376: PUSH
12377: LD_INT 2
12379: PPUSH
12380: LD_INT 2
12382: PPUSH
12383: LD_INT 14
12385: PPUSH
12386: LD_INT 1
12388: PPUSH
12389: LD_INT 1
12391: PPUSH
12392: LD_INT 32
12394: PPUSH
12395: LD_INT 30
12397: PPUSH
12398: CALL 264 0 7
12402: ADD
12403: ST_TO_ADDR
12404: GO 12364
12406: POP
12407: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12408: LD_ADDR_VAR 0 3
12412: PUSH
12413: LD_VAR 0 3
12417: PUSH
12418: LD_INT 2
12420: PPUSH
12421: LD_INT 2
12423: PPUSH
12424: LD_INT 14
12426: PPUSH
12427: LD_INT 1
12429: PPUSH
12430: LD_INT 1
12432: PPUSH
12433: LD_INT 26
12435: PPUSH
12436: LD_INT 33
12438: PPUSH
12439: CALL 264 0 7
12443: ADD
12444: ST_TO_ADDR
// tmp := tmp diff 0 ;
12445: LD_ADDR_VAR 0 3
12449: PUSH
12450: LD_VAR 0 3
12454: PUSH
12455: LD_INT 0
12457: DIFF
12458: ST_TO_ADDR
// for i in ar_force do
12459: LD_ADDR_VAR 0 4
12463: PUSH
12464: LD_EXP 33
12468: PUSH
12469: FOR_IN
12470: IFFALSE 12613
// begin if GetClass ( i ) = 3 then
12472: LD_VAR 0 4
12476: PPUSH
12477: CALL_OW 257
12481: PUSH
12482: LD_INT 3
12484: EQUAL
12485: IFFALSE 12567
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12487: LD_VAR 0 3
12491: PUSH
12492: LD_INT 1
12494: ARRAY
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12503: LD_VAR 0 3
12507: PUSH
12508: LD_INT 1
12510: ARRAY
12511: PPUSH
12512: LD_VAR 0 5
12516: PPUSH
12517: LD_VAR 0 6
12521: PPUSH
12522: LD_INT 0
12524: PPUSH
12525: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12529: LD_VAR 0 4
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_INT 1
12541: ARRAY
12542: PPUSH
12543: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12547: LD_ADDR_VAR 0 3
12551: PUSH
12552: LD_VAR 0 3
12556: PPUSH
12557: LD_INT 1
12559: PPUSH
12560: CALL_OW 3
12564: ST_TO_ADDR
// end else
12565: GO 12589
// PlaceUnitXY ( i , x , y , false ) ;
12567: LD_VAR 0 4
12571: PPUSH
12572: LD_VAR 0 5
12576: PPUSH
12577: LD_VAR 0 6
12581: PPUSH
12582: LD_INT 0
12584: PPUSH
12585: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12589: LD_VAR 0 4
12593: PPUSH
12594: LD_INT 86
12596: PPUSH
12597: LD_INT 121
12599: PPUSH
12600: CALL_OW 111
// wait ( 0 0$2 ) ;
12604: LD_INT 70
12606: PPUSH
12607: CALL_OW 67
// end ;
12611: GO 12469
12613: POP
12614: POP
// ar_force := ar_force ^ tmp ;
12615: LD_ADDR_EXP 33
12619: PUSH
12620: LD_EXP 33
12624: PUSH
12625: LD_VAR 0 3
12629: ADD
12630: ST_TO_ADDR
// ar_spawned := true ;
12631: LD_ADDR_EXP 11
12635: PUSH
12636: LD_INT 1
12638: ST_TO_ADDR
// end ; end_of_file
12639: LD_VAR 0 1
12643: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12644: LD_INT 0
12646: PPUSH
12647: PPUSH
12648: PPUSH
12649: PPUSH
12650: PPUSH
12651: PPUSH
12652: PPUSH
// InitHc ;
12653: CALL_OW 19
// uc_side := 3 ;
12657: LD_ADDR_OWVAR 20
12661: PUSH
12662: LD_INT 3
12664: ST_TO_ADDR
// uc_nation := 3 ;
12665: LD_ADDR_OWVAR 21
12669: PUSH
12670: LD_INT 3
12672: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12673: LD_ADDR_VAR 0 5
12677: PUSH
12678: LD_INT 5
12680: PUSH
12681: LD_INT 6
12683: PUSH
12684: LD_INT 7
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: LIST
12691: PUSH
12692: LD_OWVAR 67
12696: ARRAY
12697: ST_TO_ADDR
// ru_force := [ ] ;
12698: LD_ADDR_EXP 35
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// ru_rebuild := [ ] ;
12705: LD_ADDR_EXP 36
12709: PUSH
12710: EMPTY
12711: ST_TO_ADDR
// ru_produce_list := [ ] ;
12712: LD_ADDR_EXP 37
12716: PUSH
12717: EMPTY
12718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12719: LD_ADDR_VAR 0 6
12723: PUSH
12724: LD_INT 22
12726: PUSH
12727: LD_INT 3
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 30
12736: PUSH
12737: LD_INT 8
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PPUSH
12748: CALL_OW 69
12752: PUSH
12753: LD_INT 1
12755: ARRAY
12756: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: LD_INT 43
12764: PUSH
12765: LD_INT 46
12767: PUSH
12768: LD_INT 45
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: LIST
12775: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12776: LD_ADDR_VAR 0 7
12780: PUSH
12781: LD_INT 22
12783: PUSH
12784: LD_INT 3
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 30
12793: PUSH
12794: LD_INT 1
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PPUSH
12805: CALL_OW 69
12809: PUSH
12810: LD_INT 1
12812: ARRAY
12813: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12814: LD_VAR 0 7
12818: PPUSH
12819: CALL_OW 274
12823: PPUSH
12824: LD_INT 1
12826: PPUSH
12827: LD_INT 5000
12829: PPUSH
12830: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12834: LD_VAR 0 7
12838: PPUSH
12839: CALL_OW 274
12843: PPUSH
12844: LD_INT 2
12846: PPUSH
12847: LD_INT 1000
12849: PPUSH
12850: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12854: LD_VAR 0 7
12858: PPUSH
12859: CALL_OW 274
12863: PPUSH
12864: LD_INT 3
12866: PPUSH
12867: LD_INT 30
12869: PPUSH
12870: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12874: LD_ADDR_VAR 0 2
12878: PUSH
12879: LD_INT 22
12881: PUSH
12882: LD_INT 3
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: PUSH
12889: LD_INT 30
12891: PUSH
12892: LD_INT 33
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PPUSH
12903: CALL_OW 69
12907: PUSH
12908: FOR_IN
12909: IFFALSE 12941
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12911: LD_VAR 0 2
12915: PPUSH
12916: LD_VAR 0 4
12920: PUSH
12921: LD_VAR 0 2
12925: PUSH
12926: LD_INT 3
12928: MOD
12929: PUSH
12930: LD_INT 1
12932: PLUS
12933: ARRAY
12934: PPUSH
12935: CALL_OW 431
// end ;
12939: GO 12908
12941: POP
12942: POP
// for i = 1 to 4 do
12943: LD_ADDR_VAR 0 2
12947: PUSH
12948: DOUBLE
12949: LD_INT 1
12951: DEC
12952: ST_TO_ADDR
12953: LD_INT 4
12955: PUSH
12956: FOR_TO
12957: IFFALSE 13018
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12959: LD_INT 0
12961: PPUSH
12962: LD_INT 9
12964: PPUSH
12965: LD_VAR 0 5
12969: PPUSH
12970: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12974: CALL_OW 44
12978: PPUSH
12979: LD_INT 22
12981: PUSH
12982: LD_INT 3
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 30
12991: PUSH
12992: LD_INT 5
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PPUSH
13003: CALL_OW 69
13007: PUSH
13008: LD_INT 1
13010: ARRAY
13011: PPUSH
13012: CALL_OW 52
// end ;
13016: GO 12956
13018: POP
13019: POP
// for i = 1 to 5 do
13020: LD_ADDR_VAR 0 2
13024: PUSH
13025: DOUBLE
13026: LD_INT 1
13028: DEC
13029: ST_TO_ADDR
13030: LD_INT 5
13032: PUSH
13033: FOR_TO
13034: IFFALSE 13095
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13036: LD_INT 0
13038: PPUSH
13039: LD_INT 3
13041: PPUSH
13042: LD_VAR 0 5
13046: PPUSH
13047: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13051: CALL_OW 44
13055: PPUSH
13056: LD_INT 22
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: PUSH
13066: LD_INT 30
13068: PUSH
13069: LD_INT 3
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: PPUSH
13080: CALL_OW 69
13084: PUSH
13085: LD_INT 1
13087: ARRAY
13088: PPUSH
13089: CALL_OW 52
// end ;
13093: GO 13033
13095: POP
13096: POP
// for i = 1 to 4 do
13097: LD_ADDR_VAR 0 2
13101: PUSH
13102: DOUBLE
13103: LD_INT 1
13105: DEC
13106: ST_TO_ADDR
13107: LD_INT 4
13109: PUSH
13110: FOR_TO
13111: IFFALSE 13172
// begin PrepareHuman ( false , class_engineer , skill ) ;
13113: LD_INT 0
13115: PPUSH
13116: LD_INT 2
13118: PPUSH
13119: LD_VAR 0 5
13123: PPUSH
13124: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13128: CALL_OW 44
13132: PPUSH
13133: LD_INT 22
13135: PUSH
13136: LD_INT 3
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 30
13145: PUSH
13146: LD_INT 1
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: PPUSH
13157: CALL_OW 69
13161: PUSH
13162: LD_INT 1
13164: ARRAY
13165: PPUSH
13166: CALL_OW 52
// end ;
13170: GO 13110
13172: POP
13173: POP
// for i = 1 to 3 do
13174: LD_ADDR_VAR 0 2
13178: PUSH
13179: DOUBLE
13180: LD_INT 1
13182: DEC
13183: ST_TO_ADDR
13184: LD_INT 3
13186: PUSH
13187: FOR_TO
13188: IFFALSE 13221
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13190: LD_INT 0
13192: PPUSH
13193: LD_INT 4
13195: PPUSH
13196: LD_VAR 0 5
13200: PPUSH
13201: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13205: CALL_OW 44
13209: PPUSH
13210: LD_VAR 0 6
13214: PPUSH
13215: CALL_OW 52
// end ;
13219: GO 13187
13221: POP
13222: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13223: LD_ADDR_EXP 34
13227: PUSH
13228: LD_STRING Yakotich
13230: PPUSH
13231: LD_EXP 2
13235: NOT
13236: PPUSH
13237: LD_STRING 
13239: PPUSH
13240: CALL 201 0 3
13244: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13245: LD_EXP 34
13249: PPUSH
13250: LD_INT 74
13252: PPUSH
13253: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13257: LD_VAR 0 6
13261: PPUSH
13262: LD_INT 49
13264: PPUSH
13265: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13269: LD_VAR 0 6
13273: PPUSH
13274: LD_INT 50
13276: PPUSH
13277: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13281: LD_VAR 0 6
13285: PPUSH
13286: LD_INT 51
13288: PPUSH
13289: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13293: LD_VAR 0 6
13297: PPUSH
13298: LD_INT 52
13300: PPUSH
13301: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13305: LD_VAR 0 6
13309: PPUSH
13310: LD_INT 69
13312: PPUSH
13313: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13317: LD_VAR 0 6
13321: PPUSH
13322: LD_INT 39
13324: PPUSH
13325: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13329: LD_VAR 0 6
13333: PPUSH
13334: LD_INT 34
13336: PPUSH
13337: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13341: LD_VAR 0 6
13345: PPUSH
13346: LD_INT 40
13348: PPUSH
13349: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13353: LD_VAR 0 6
13357: PPUSH
13358: LD_INT 57
13360: PPUSH
13361: CALL_OW 184
// if Difficulty > 1 then
13365: LD_OWVAR 67
13369: PUSH
13370: LD_INT 1
13372: GREATER
13373: IFFALSE 13387
// AddComResearch ( lab , tech_comp2 ) ;
13375: LD_VAR 0 6
13379: PPUSH
13380: LD_INT 58
13382: PPUSH
13383: CALL_OW 184
// end ;
13387: LD_VAR 0 1
13391: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13392: LD_INT 7
13394: PPUSH
13395: CALL_OW 353
13399: PUSH
13400: LD_INT 3
13402: GREATER
13403: PUSH
13404: LD_INT 22
13406: PUSH
13407: LD_INT 3
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PUSH
13414: LD_INT 34
13416: PUSH
13417: LD_INT 53
13419: PUSH
13420: EMPTY
13421: LIST
13422: LIST
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PPUSH
13428: CALL_OW 69
13432: NOT
13433: AND
13434: IFFALSE 13469
13436: GO 13438
13438: DISABLE
// begin enable ;
13439: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13440: LD_ADDR_EXP 37
13444: PUSH
13445: LD_EXP 37
13449: PUSH
13450: LD_INT 24
13452: PUSH
13453: LD_INT 1
13455: PUSH
13456: LD_INT 3
13458: PUSH
13459: LD_INT 53
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: LIST
13466: LIST
13467: ADD
13468: ST_TO_ADDR
// end ;
13469: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13470: LD_INT 22
13472: PUSH
13473: LD_INT 3
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 21
13482: PUSH
13483: LD_INT 3
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PPUSH
13494: CALL_OW 69
13498: IFFALSE 14276
13500: GO 13502
13502: DISABLE
13503: LD_INT 0
13505: PPUSH
13506: PPUSH
13507: PPUSH
13508: PPUSH
13509: PPUSH
13510: PPUSH
13511: PPUSH
13512: PPUSH
// begin enable ;
13513: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13514: LD_ADDR_VAR 0 3
13518: PUSH
13519: LD_INT 22
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 21
13531: PUSH
13532: LD_INT 3
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: PUSH
13539: LD_INT 3
13541: PUSH
13542: LD_INT 24
13544: PUSH
13545: LD_INT 1000
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: LIST
13560: PPUSH
13561: CALL_OW 69
13565: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13566: LD_ADDR_VAR 0 4
13570: PUSH
13571: LD_INT 22
13573: PUSH
13574: LD_INT 3
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: PUSH
13581: LD_INT 25
13583: PUSH
13584: LD_INT 2
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PPUSH
13595: CALL_OW 69
13599: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13600: LD_ADDR_VAR 0 5
13604: PUSH
13605: LD_INT 22
13607: PUSH
13608: LD_INT 3
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 30
13617: PUSH
13618: LD_INT 1
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: PPUSH
13629: CALL_OW 69
13633: PUSH
13634: LD_INT 1
13636: ARRAY
13637: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13638: LD_ADDR_VAR 0 8
13642: PUSH
13643: LD_INT 22
13645: PUSH
13646: LD_INT 3
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: PUSH
13653: LD_INT 2
13655: PUSH
13656: LD_INT 30
13658: PUSH
13659: LD_INT 6
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PUSH
13666: LD_INT 30
13668: PUSH
13669: LD_INT 7
13671: PUSH
13672: EMPTY
13673: LIST
13674: LIST
13675: PUSH
13676: LD_INT 30
13678: PUSH
13679: LD_INT 8
13681: PUSH
13682: EMPTY
13683: LIST
13684: LIST
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: PUSH
13692: EMPTY
13693: LIST
13694: LIST
13695: PPUSH
13696: CALL_OW 69
13700: PUSH
13701: LD_INT 1
13703: ARRAY
13704: ST_TO_ADDR
// if not engs then
13705: LD_VAR 0 4
13709: NOT
13710: IFFALSE 13714
// exit ;
13712: GO 14276
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13714: LD_ADDR_VAR 0 6
13718: PUSH
13719: LD_VAR 0 4
13723: PPUSH
13724: LD_INT 3
13726: PUSH
13727: LD_INT 24
13729: PUSH
13730: LD_INT 600
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PPUSH
13741: CALL_OW 72
13745: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13746: LD_ADDR_VAR 0 7
13750: PUSH
13751: LD_INT 22
13753: PUSH
13754: LD_INT 3
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PUSH
13761: LD_INT 25
13763: PUSH
13764: LD_INT 4
13766: PUSH
13767: EMPTY
13768: LIST
13769: LIST
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: PPUSH
13775: CALL_OW 69
13779: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13780: LD_VAR 0 3
13784: NOT
13785: PUSH
13786: LD_EXP 36
13790: NOT
13791: AND
13792: IFFALSE 13852
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13794: LD_VAR 0 4
13798: PPUSH
13799: LD_INT 3
13801: PUSH
13802: LD_INT 54
13804: PUSH
13805: EMPTY
13806: LIST
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 72
13816: IFFALSE 13850
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13818: LD_VAR 0 4
13822: PPUSH
13823: LD_INT 3
13825: PUSH
13826: LD_INT 54
13828: PUSH
13829: EMPTY
13830: LIST
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PPUSH
13836: CALL_OW 72
13840: PPUSH
13841: LD_VAR 0 5
13845: PPUSH
13846: CALL_OW 120
// exit ;
13850: GO 14276
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13852: LD_VAR 0 4
13856: PPUSH
13857: LD_INT 54
13859: PUSH
13860: EMPTY
13861: LIST
13862: PPUSH
13863: CALL_OW 72
13867: IFFALSE 13889
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13869: LD_VAR 0 4
13873: PPUSH
13874: LD_INT 54
13876: PUSH
13877: EMPTY
13878: LIST
13879: PPUSH
13880: CALL_OW 72
13884: PPUSH
13885: CALL_OW 122
// if not tmp then
13889: LD_VAR 0 3
13893: NOT
13894: IFFALSE 14026
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13896: LD_INT 81
13898: PUSH
13899: LD_INT 3
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PUSH
13906: LD_INT 92
13908: PUSH
13909: LD_INT 147
13911: PUSH
13912: LD_INT 212
13914: PUSH
13915: LD_INT 30
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: PPUSH
13928: CALL_OW 69
13932: NOT
13933: IFFALSE 14026
// begin if not HasTask ( engs [ 1 ] ) then
13935: LD_VAR 0 4
13939: PUSH
13940: LD_INT 1
13942: ARRAY
13943: PPUSH
13944: CALL_OW 314
13948: NOT
13949: IFFALSE 14026
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_VAR 0 4
13960: PPUSH
13961: LD_EXP 36
13965: PUSH
13966: LD_INT 1
13968: ARRAY
13969: PPUSH
13970: LD_EXP 36
13974: PUSH
13975: LD_INT 2
13977: ARRAY
13978: PPUSH
13979: LD_EXP 36
13983: PUSH
13984: LD_INT 3
13986: ARRAY
13987: PPUSH
13988: LD_EXP 36
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: PPUSH
13997: CALL_OW 145
14001: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14002: LD_VAR 0 2
14006: PPUSH
14007: CALL_OW 266
14011: PUSH
14012: LD_INT 4
14014: EQUAL
14015: IFFALSE 14026
// AddComUpgrade ( i ) ;
14017: LD_VAR 0 2
14021: PPUSH
14022: CALL_OW 206
// end ; end ; end ; for i in engs do
14026: LD_ADDR_VAR 0 2
14030: PUSH
14031: LD_VAR 0 4
14035: PUSH
14036: FOR_IN
14037: IFFALSE 14155
// begin if i in to_heal and sci then
14039: LD_VAR 0 2
14043: PUSH
14044: LD_VAR 0 6
14048: IN
14049: PUSH
14050: LD_VAR 0 7
14054: AND
14055: IFFALSE 14106
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14057: LD_VAR 0 2
14061: PPUSH
14062: LD_INT 149
14064: PPUSH
14065: LD_INT 220
14067: PPUSH
14068: CALL_OW 297
14072: PUSH
14073: LD_INT 5
14075: LESS
14076: IFFALSE 14080
// continue ;
14078: GO 14036
// ComMoveXY ( i , 149 , 220 ) ;
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 149
14087: PPUSH
14088: LD_INT 220
14090: PPUSH
14091: CALL_OW 111
// AddComHold ( i ) ;
14095: LD_VAR 0 2
14099: PPUSH
14100: CALL_OW 200
// end else
14104: GO 14153
// if not HasTask ( i ) or WantsToAttack ( i ) then
14106: LD_VAR 0 2
14110: PPUSH
14111: CALL_OW 314
14115: NOT
14116: PUSH
14117: LD_VAR 0 2
14121: PPUSH
14122: CALL_OW 319
14126: OR
14127: IFFALSE 14153
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14129: LD_VAR 0 2
14133: PPUSH
14134: LD_VAR 0 3
14138: PPUSH
14139: LD_VAR 0 2
14143: PPUSH
14144: CALL_OW 74
14148: PPUSH
14149: CALL_OW 130
// end ;
14153: GO 14036
14155: POP
14156: POP
// if to_heal and sci then
14157: LD_VAR 0 6
14161: PUSH
14162: LD_VAR 0 7
14166: AND
14167: IFFALSE 14228
// begin if UnitFilter ( sci , [ f_inside ] ) then
14169: LD_VAR 0 7
14173: PPUSH
14174: LD_INT 54
14176: PUSH
14177: EMPTY
14178: LIST
14179: PPUSH
14180: CALL_OW 72
14184: IFFALSE 14208
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14186: LD_VAR 0 7
14190: PPUSH
14191: LD_INT 54
14193: PUSH
14194: EMPTY
14195: LIST
14196: PPUSH
14197: CALL_OW 72
14201: PPUSH
14202: CALL_OW 122
14206: GO 14226
// ComHeal ( sci , to_heal [ 1 ] ) ;
14208: LD_VAR 0 7
14212: PPUSH
14213: LD_VAR 0 6
14217: PUSH
14218: LD_INT 1
14220: ARRAY
14221: PPUSH
14222: CALL_OW 128
// end else
14226: GO 14276
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14228: LD_VAR 0 7
14232: PPUSH
14233: LD_INT 56
14235: PUSH
14236: EMPTY
14237: LIST
14238: PPUSH
14239: CALL_OW 72
14243: PUSH
14244: LD_VAR 0 8
14248: AND
14249: IFFALSE 14276
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14251: LD_VAR 0 7
14255: PPUSH
14256: LD_INT 56
14258: PUSH
14259: EMPTY
14260: LIST
14261: PPUSH
14262: CALL_OW 72
14266: PPUSH
14267: LD_VAR 0 8
14271: PPUSH
14272: CALL_OW 120
// end ;
14276: PPOPN 8
14278: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14279: LD_INT 22
14281: PUSH
14282: LD_INT 3
14284: PUSH
14285: EMPTY
14286: LIST
14287: LIST
14288: PUSH
14289: LD_INT 30
14291: PUSH
14292: LD_INT 3
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: EMPTY
14300: LIST
14301: LIST
14302: PPUSH
14303: CALL_OW 69
14307: PUSH
14308: LD_EXP 37
14312: AND
14313: IFFALSE 14439
14315: GO 14317
14317: DISABLE
14318: LD_INT 0
14320: PPUSH
14321: PPUSH
14322: PPUSH
// begin enable ;
14323: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14324: LD_ADDR_VAR 0 3
14328: PUSH
14329: LD_INT 22
14331: PUSH
14332: LD_INT 3
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: PUSH
14339: LD_INT 30
14341: PUSH
14342: LD_INT 3
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PPUSH
14353: CALL_OW 69
14357: PUSH
14358: LD_INT 1
14360: ARRAY
14361: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14362: LD_VAR 0 3
14366: PPUSH
14367: CALL_OW 313
14371: PUSH
14372: LD_INT 0
14374: EQUAL
14375: IFFALSE 14379
// exit ;
14377: GO 14439
// if BuildingStatus ( fac ) = bs_idle then
14379: LD_VAR 0 3
14383: PPUSH
14384: CALL_OW 461
14388: PUSH
14389: LD_INT 2
14391: EQUAL
14392: IFFALSE 14439
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14394: LD_VAR 0 3
14398: PPUSH
14399: LD_EXP 37
14403: PUSH
14404: LD_INT 1
14406: ARRAY
14407: PPUSH
14408: LD_EXP 37
14412: PUSH
14413: LD_INT 2
14415: ARRAY
14416: PPUSH
14417: LD_EXP 37
14421: PUSH
14422: LD_INT 3
14424: ARRAY
14425: PPUSH
14426: LD_EXP 37
14430: PUSH
14431: LD_INT 4
14433: ARRAY
14434: PPUSH
14435: CALL_OW 125
// end ;
14439: PPOPN 3
14441: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14442: LD_INT 0
14444: PPUSH
14445: PPUSH
14446: PPUSH
14447: PPUSH
14448: PPUSH
// uc_side := 3 ;
14449: LD_ADDR_OWVAR 20
14453: PUSH
14454: LD_INT 3
14456: ST_TO_ADDR
// uc_nation := 3 ;
14457: LD_ADDR_OWVAR 21
14461: PUSH
14462: LD_INT 3
14464: ST_TO_ADDR
// ru_can_attack := false ;
14465: LD_ADDR_EXP 8
14469: PUSH
14470: LD_INT 0
14472: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14473: LD_ADDR_VAR 0 6
14477: PUSH
14478: LD_INT 22
14480: PUSH
14481: LD_INT 3
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: PUSH
14488: LD_INT 30
14490: PUSH
14491: LD_INT 3
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PPUSH
14502: CALL_OW 69
14506: ST_TO_ADDR
// if fac then
14507: LD_VAR 0 6
14511: IFFALSE 14663
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14513: LD_ADDR_EXP 37
14517: PUSH
14518: LD_INT 24
14520: PUSH
14521: LD_INT 1
14523: PUSH
14524: LD_INT 3
14526: PUSH
14527: LD_INT 43
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: ST_TO_ADDR
// if wave > 1 then
14536: LD_VAR 0 1
14540: PUSH
14541: LD_INT 1
14543: GREATER
14544: IFFALSE 14597
// for i = 1 to Difficulty do
14546: LD_ADDR_VAR 0 3
14550: PUSH
14551: DOUBLE
14552: LD_INT 1
14554: DEC
14555: ST_TO_ADDR
14556: LD_OWVAR 67
14560: PUSH
14561: FOR_TO
14562: IFFALSE 14595
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14564: LD_ADDR_EXP 37
14568: PUSH
14569: LD_EXP 37
14573: PUSH
14574: LD_INT 24
14576: PUSH
14577: LD_INT 1
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: LD_INT 45
14585: PUSH
14586: EMPTY
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: ADD
14592: ST_TO_ADDR
14593: GO 14561
14595: POP
14596: POP
// repeat wait ( 0 0$1 ) ;
14597: LD_INT 35
14599: PPUSH
14600: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14604: LD_EXP 37
14608: PUSH
14609: LD_INT 4
14611: LESS
14612: PUSH
14613: LD_VAR 0 6
14617: PUSH
14618: LD_INT 1
14620: ARRAY
14621: PPUSH
14622: CALL_OW 313
14626: PUSH
14627: LD_INT 0
14629: EQUAL
14630: OR
14631: PUSH
14632: LD_VAR 0 6
14636: PUSH
14637: LD_INT 1
14639: ARRAY
14640: PPUSH
14641: CALL_OW 461
14645: PUSH
14646: LD_INT 8
14648: PUSH
14649: LD_INT 6
14651: PUSH
14652: LD_INT 7
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: LIST
14659: IN
14660: OR
14661: IFFALSE 14597
// end ; case wave of 1 :
14663: LD_VAR 0 1
14667: PUSH
14668: LD_INT 1
14670: DOUBLE
14671: EQUAL
14672: IFTRUE 14676
14674: GO 14761
14676: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14677: LD_ADDR_VAR 0 3
14681: PUSH
14682: DOUBLE
14683: LD_INT 1
14685: DEC
14686: ST_TO_ADDR
14687: LD_INT 4
14689: PUSH
14690: LD_INT 5
14692: PUSH
14693: LD_INT 6
14695: PUSH
14696: EMPTY
14697: LIST
14698: LIST
14699: LIST
14700: PUSH
14701: LD_OWVAR 67
14705: ARRAY
14706: PUSH
14707: FOR_TO
14708: IFFALSE 14716
// Sold ;
14710: CALL 14987 0 0
14714: GO 14707
14716: POP
14717: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14718: LD_ADDR_VAR 0 3
14722: PUSH
14723: DOUBLE
14724: LD_INT 1
14726: DEC
14727: ST_TO_ADDR
14728: LD_INT 2
14730: PUSH
14731: LD_INT 3
14733: PUSH
14734: LD_INT 3
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: PUSH
14742: LD_OWVAR 67
14746: ARRAY
14747: PUSH
14748: FOR_TO
14749: IFFALSE 14757
// Tank ;
14751: CALL 15117 0 0
14755: GO 14748
14757: POP
14758: POP
// end ; 2 .. 9 :
14759: GO 14974
14761: LD_INT 2
14763: DOUBLE
14764: GREATEREQUAL
14765: IFFALSE 14773
14767: LD_INT 9
14769: DOUBLE
14770: LESSEQUAL
14771: IFTRUE 14775
14773: GO 14880
14775: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14776: LD_ADDR_VAR 0 3
14780: PUSH
14781: DOUBLE
14782: LD_INT 1
14784: DEC
14785: ST_TO_ADDR
14786: LD_INT 4
14788: PUSH
14789: LD_INT 5
14791: PUSH
14792: LD_INT 6
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: LIST
14799: PUSH
14800: LD_OWVAR 67
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 1
14810: PUSH
14811: LD_INT 2
14813: DIV
14814: PLUS
14815: PUSH
14816: FOR_TO
14817: IFFALSE 14825
// Sold ;
14819: CALL 14987 0 0
14823: GO 14816
14825: POP
14826: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14827: LD_ADDR_VAR 0 3
14831: PUSH
14832: DOUBLE
14833: LD_INT 1
14835: DEC
14836: ST_TO_ADDR
14837: LD_INT 3
14839: PUSH
14840: LD_INT 4
14842: PUSH
14843: LD_INT 4
14845: PUSH
14846: EMPTY
14847: LIST
14848: LIST
14849: LIST
14850: PUSH
14851: LD_OWVAR 67
14855: ARRAY
14856: PUSH
14857: LD_VAR 0 1
14861: PUSH
14862: LD_INT 2
14864: DIV
14865: PLUS
14866: PUSH
14867: FOR_TO
14868: IFFALSE 14876
// Tank ;
14870: CALL 15117 0 0
14874: GO 14867
14876: POP
14877: POP
// end ; 10 :
14878: GO 14974
14880: LD_INT 10
14882: DOUBLE
14883: EQUAL
14884: IFTRUE 14888
14886: GO 14973
14888: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14889: LD_ADDR_VAR 0 3
14893: PUSH
14894: DOUBLE
14895: LD_INT 1
14897: DEC
14898: ST_TO_ADDR
14899: LD_INT 10
14901: PUSH
14902: LD_INT 12
14904: PUSH
14905: LD_INT 14
14907: PUSH
14908: EMPTY
14909: LIST
14910: LIST
14911: LIST
14912: PUSH
14913: LD_OWVAR 67
14917: ARRAY
14918: PUSH
14919: FOR_TO
14920: IFFALSE 14928
// Sold ;
14922: CALL 14987 0 0
14926: GO 14919
14928: POP
14929: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
14930: LD_ADDR_VAR 0 3
14934: PUSH
14935: DOUBLE
14936: LD_INT 1
14938: DEC
14939: ST_TO_ADDR
14940: LD_INT 11
14942: PUSH
14943: LD_INT 13
14945: PUSH
14946: LD_INT 15
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: LIST
14953: PUSH
14954: LD_OWVAR 67
14958: ARRAY
14959: PUSH
14960: FOR_TO
14961: IFFALSE 14969
// Tank ;
14963: CALL 15117 0 0
14967: GO 14960
14969: POP
14970: POP
// end ; end ;
14971: GO 14974
14973: POP
// ru_can_attack := true ;
14974: LD_ADDR_EXP 8
14978: PUSH
14979: LD_INT 1
14981: ST_TO_ADDR
// end ;
14982: LD_VAR 0 2
14986: RET
// function Sold ( ) ; var un , skill ; begin
14987: LD_INT 0
14989: PPUSH
14990: PPUSH
14991: PPUSH
// uc_side := 3 ;
14992: LD_ADDR_OWVAR 20
14996: PUSH
14997: LD_INT 3
14999: ST_TO_ADDR
// uc_nation := 3 ;
15000: LD_ADDR_OWVAR 21
15004: PUSH
15005: LD_INT 3
15007: ST_TO_ADDR
// InitHc ;
15008: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15012: LD_ADDR_VAR 0 3
15016: PUSH
15017: LD_INT 6
15019: PUSH
15020: LD_INT 7
15022: PUSH
15023: LD_INT 7
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: LIST
15030: PUSH
15031: LD_OWVAR 67
15035: ARRAY
15036: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15037: LD_INT 0
15039: PPUSH
15040: LD_INT 1
15042: PUSH
15043: LD_INT 9
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PUSH
15050: LD_INT 1
15052: PPUSH
15053: LD_INT 2
15055: PPUSH
15056: CALL_OW 12
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 3
15066: PPUSH
15067: CALL_OW 380
// un := CreateHuman ;
15071: LD_ADDR_VAR 0 2
15075: PUSH
15076: CALL_OW 44
15080: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15081: LD_VAR 0 2
15085: PPUSH
15086: LD_INT 4
15088: PPUSH
15089: LD_INT 0
15091: PPUSH
15092: CALL_OW 49
// ru_force := ru_force ^ un ;
15096: LD_ADDR_EXP 35
15100: PUSH
15101: LD_EXP 35
15105: PUSH
15106: LD_VAR 0 2
15110: ADD
15111: ST_TO_ADDR
// end ;
15112: LD_VAR 0 1
15116: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15117: LD_INT 0
15119: PPUSH
15120: PPUSH
15121: PPUSH
15122: PPUSH
15123: PPUSH
// uc_side := 3 ;
15124: LD_ADDR_OWVAR 20
15128: PUSH
15129: LD_INT 3
15131: ST_TO_ADDR
// uc_nation := 3 ;
15132: LD_ADDR_OWVAR 21
15136: PUSH
15137: LD_INT 3
15139: ST_TO_ADDR
// InitHc ;
15140: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15144: LD_ADDR_VAR 0 5
15148: PUSH
15149: LD_INT 5
15151: PUSH
15152: LD_INT 6
15154: PUSH
15155: LD_INT 7
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: LIST
15162: PUSH
15163: LD_OWVAR 67
15167: ARRAY
15168: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15169: LD_ADDR_VAR 0 3
15173: PUSH
15174: LD_INT 22
15176: PUSH
15177: LD_INT 24
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: PUSH
15184: LD_INT 1
15186: PPUSH
15187: LD_INT 2
15189: PPUSH
15190: CALL_OW 12
15194: ARRAY
15195: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15196: LD_VAR 0 3
15200: PUSH
15201: LD_INT 22
15203: EQUAL
15204: IFFALSE 15239
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15206: LD_ADDR_VAR 0 4
15210: PUSH
15211: LD_INT 45
15213: PUSH
15214: LD_INT 43
15216: PUSH
15217: LD_INT 44
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: LIST
15224: PUSH
15225: LD_INT 1
15227: PPUSH
15228: LD_INT 3
15230: PPUSH
15231: CALL_OW 12
15235: ARRAY
15236: ST_TO_ADDR
15237: GO 15270
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15239: LD_ADDR_VAR 0 4
15243: PUSH
15244: LD_INT 46
15246: PUSH
15247: LD_INT 44
15249: PUSH
15250: LD_INT 45
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: LIST
15257: PUSH
15258: LD_INT 1
15260: PPUSH
15261: LD_INT 3
15263: PPUSH
15264: CALL_OW 12
15268: ARRAY
15269: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15270: LD_ADDR_VAR 0 2
15274: PUSH
15275: LD_INT 3
15277: PPUSH
15278: LD_INT 3
15280: PPUSH
15281: LD_VAR 0 3
15285: PPUSH
15286: LD_INT 1
15288: PPUSH
15289: LD_INT 3
15291: PUSH
15292: LD_INT 3
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: LD_INT 1
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: PUSH
15307: LD_INT 1
15309: PPUSH
15310: LD_INT 4
15312: PPUSH
15313: CALL_OW 12
15317: ARRAY
15318: PPUSH
15319: LD_VAR 0 4
15323: PPUSH
15324: LD_INT 99
15326: PPUSH
15327: CALL 264 0 7
15331: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15332: LD_VAR 0 2
15336: PPUSH
15337: CALL_OW 263
15341: PUSH
15342: LD_INT 1
15344: EQUAL
15345: IFFALSE 15376
// begin PrepareHuman ( false , 3 , skill ) ;
15347: LD_INT 0
15349: PPUSH
15350: LD_INT 3
15352: PPUSH
15353: LD_VAR 0 5
15357: PPUSH
15358: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15362: CALL_OW 44
15366: PPUSH
15367: LD_VAR 0 2
15371: PPUSH
15372: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15376: LD_VAR 0 2
15380: PPUSH
15381: LD_INT 3
15383: PPUSH
15384: LD_INT 0
15386: PPUSH
15387: CALL_OW 49
// ru_force := ru_force ^ un ;
15391: LD_ADDR_EXP 35
15395: PUSH
15396: LD_EXP 35
15400: PUSH
15401: LD_VAR 0 2
15405: ADD
15406: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15407: LD_VAR 0 2
15411: PPUSH
15412: LD_INT 126
15414: PPUSH
15415: LD_INT 158
15417: PPUSH
15418: CALL_OW 111
// Wait ( 0 0$3 ) ;
15422: LD_INT 105
15424: PPUSH
15425: CALL_OW 67
// ComStop ( un ) ;
15429: LD_VAR 0 2
15433: PPUSH
15434: CALL_OW 141
// end ;
15438: LD_VAR 0 1
15442: RET
// every 0 0$1 do var i , time , wave ;
15443: GO 15445
15445: DISABLE
15446: LD_INT 0
15448: PPUSH
15449: PPUSH
15450: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15451: LD_ADDR_VAR 0 2
15455: PUSH
15456: LD_INT 25200
15458: PUSH
15459: LD_INT 24150
15461: PUSH
15462: LD_INT 23100
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: LIST
15469: PUSH
15470: LD_OWVAR 67
15474: ARRAY
15475: ST_TO_ADDR
// wait ( time ) ;
15476: LD_VAR 0 2
15480: PPUSH
15481: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15485: LD_ADDR_VAR 0 2
15489: PUSH
15490: LD_INT 15750
15492: PUSH
15493: LD_INT 15050
15495: PUSH
15496: LD_INT 14350
15498: PUSH
15499: EMPTY
15500: LIST
15501: LIST
15502: LIST
15503: PUSH
15504: LD_OWVAR 67
15508: ARRAY
15509: ST_TO_ADDR
// wave := 0 ;
15510: LD_ADDR_VAR 0 3
15514: PUSH
15515: LD_INT 0
15517: ST_TO_ADDR
// while true do
15518: LD_INT 1
15520: IFFALSE 15617
// begin wave := wave + 1 ;
15522: LD_ADDR_VAR 0 3
15526: PUSH
15527: LD_VAR 0 3
15531: PUSH
15532: LD_INT 1
15534: PLUS
15535: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15536: LD_INT 22
15538: PUSH
15539: LD_INT 2
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: PPUSH
15546: CALL_OW 69
15550: IFFALSE 15579
// repeat wait ( 0 0$1 ) ;
15552: LD_INT 35
15554: PPUSH
15555: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15559: LD_INT 22
15561: PUSH
15562: LD_INT 2
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PPUSH
15569: CALL_OW 69
15573: PUSH
15574: LD_INT 0
15576: EQUAL
15577: IFFALSE 15552
// if ru_force < 20 then
15579: LD_EXP 35
15583: PUSH
15584: LD_INT 20
15586: LESS
15587: IFFALSE 15598
// PrepareAttack ( wave ) ;
15589: LD_VAR 0 3
15593: PPUSH
15594: CALL 14442 0 1
// ru_can_attack := true ;
15598: LD_ADDR_EXP 8
15602: PUSH
15603: LD_INT 1
15605: ST_TO_ADDR
// wait ( time ) ;
15606: LD_VAR 0 2
15610: PPUSH
15611: CALL_OW 67
// end ;
15615: GO 15518
// end ;
15617: PPOPN 3
15619: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15620: LD_EXP 8
15624: PUSH
15625: LD_EXP 35
15629: AND
15630: IFFALSE 16464
15632: GO 15634
15634: DISABLE
15635: LD_INT 0
15637: PPUSH
15638: PPUSH
15639: PPUSH
15640: PPUSH
15641: PPUSH
15642: PPUSH
15643: PPUSH
15644: PPUSH
15645: PPUSH
// begin enable ;
15646: ENABLE
// points1 := [ 107 , 123 ] ;
15647: LD_ADDR_VAR 0 4
15651: PUSH
15652: LD_INT 107
15654: PUSH
15655: LD_INT 123
15657: PUSH
15658: EMPTY
15659: LIST
15660: LIST
15661: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15662: LD_ADDR_VAR 0 5
15666: PUSH
15667: LD_INT 55
15669: PUSH
15670: LD_INT 42
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15677: LD_ADDR_VAR 0 6
15681: PUSH
15682: LD_INT 102
15684: PUSH
15685: LD_INT 140
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: LD_INT 105
15694: PUSH
15695: LD_INT 142
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PUSH
15702: LD_INT 129
15704: PUSH
15705: LD_INT 131
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: PUSH
15712: EMPTY
15713: LIST
15714: LIST
15715: LIST
15716: ST_TO_ADDR
// for i in ru_force do
15717: LD_ADDR_VAR 0 1
15721: PUSH
15722: LD_EXP 35
15726: PUSH
15727: FOR_IN
15728: IFFALSE 16462
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15730: LD_ADDR_VAR 0 3
15734: PUSH
15735: LD_INT 81
15737: PUSH
15738: LD_INT 3
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PPUSH
15745: CALL_OW 69
15749: PPUSH
15750: LD_VAR 0 1
15754: PPUSH
15755: CALL_OW 74
15759: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15760: LD_VAR 0 1
15764: PPUSH
15765: LD_VAR 0 3
15769: PPUSH
15770: CALL_OW 296
15774: PUSH
15775: LD_INT 12
15777: LESS
15778: IFFALSE 15923
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15780: LD_VAR 0 1
15784: PPUSH
15785: CALL_OW 247
15789: PUSH
15790: LD_INT 1
15792: EQUAL
15793: PUSH
15794: LD_VAR 0 1
15798: PPUSH
15799: CALL_OW 257
15803: PUSH
15804: LD_INT 1
15806: EQUAL
15807: AND
15808: PUSH
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 21
15816: PUSH
15817: LD_INT 2
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: PUSH
15824: LD_INT 58
15826: PUSH
15827: EMPTY
15828: LIST
15829: PUSH
15830: EMPTY
15831: LIST
15832: LIST
15833: PPUSH
15834: CALL_OW 69
15838: IN
15839: AND
15840: IFFALSE 15858
// ComEnterUnit ( i , un ) else
15842: LD_VAR 0 1
15846: PPUSH
15847: LD_VAR 0 3
15851: PPUSH
15852: CALL_OW 120
15856: GO 15921
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15858: LD_VAR 0 3
15862: PUSH
15863: LD_INT 21
15865: PUSH
15866: LD_INT 2
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: PUSH
15873: LD_INT 58
15875: PUSH
15876: EMPTY
15877: LIST
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PPUSH
15883: CALL_OW 69
15887: IN
15888: NOT
15889: IFFALSE 15907
// ComAttackUnit ( i , un ) else
15891: LD_VAR 0 1
15895: PPUSH
15896: LD_VAR 0 3
15900: PPUSH
15901: CALL_OW 115
15905: GO 15921
// ComAttackUnit ( i , JMM ) ;
15907: LD_VAR 0 1
15911: PPUSH
15912: LD_EXP 18
15916: PPUSH
15917: CALL_OW 115
// end else
15921: GO 16460
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15923: LD_VAR 0 1
15927: PPUSH
15928: LD_VAR 0 4
15932: PUSH
15933: LD_INT 1
15935: ARRAY
15936: PPUSH
15937: LD_VAR 0 4
15941: PUSH
15942: LD_INT 2
15944: ARRAY
15945: PPUSH
15946: CALL_OW 297
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PUSH
15961: LD_INT 1
15963: ARRAY
15964: PPUSH
15965: LD_VAR 0 5
15969: PUSH
15970: LD_INT 2
15972: ARRAY
15973: PPUSH
15974: CALL_OW 297
15978: GREATER
15979: PUSH
15980: LD_EXP 9
15984: AND
15985: PUSH
15986: LD_INT 9
15988: PPUSH
15989: LD_INT 81
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PPUSH
15999: CALL_OW 70
16003: PUSH
16004: LD_INT 0
16006: EQUAL
16007: OR
16008: IFFALSE 16046
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16010: LD_VAR 0 1
16014: PPUSH
16015: LD_INT 81
16017: PUSH
16018: LD_INT 3
16020: PUSH
16021: EMPTY
16022: LIST
16023: LIST
16024: PPUSH
16025: CALL_OW 69
16029: PPUSH
16030: LD_VAR 0 1
16034: PPUSH
16035: CALL_OW 74
16039: PPUSH
16040: CALL_OW 115
16044: GO 16460
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16046: LD_VAR 0 1
16050: PPUSH
16051: CALL_OW 264
16055: PUSH
16056: LD_INT 45
16058: EQUAL
16059: PUSH
16060: LD_EXP 35
16064: PPUSH
16065: LD_INT 3
16067: PUSH
16068: LD_INT 34
16070: PUSH
16071: LD_INT 45
16073: PUSH
16074: EMPTY
16075: LIST
16076: LIST
16077: PUSH
16078: EMPTY
16079: LIST
16080: LIST
16081: PPUSH
16082: CALL_OW 72
16086: PUSH
16087: LD_INT 6
16089: GREATER
16090: AND
16091: IFFALSE 16272
// begin dist := 9999 ;
16093: LD_ADDR_VAR 0 8
16097: PUSH
16098: LD_INT 9999
16100: ST_TO_ADDR
// xy := 0 ;
16101: LD_ADDR_VAR 0 9
16105: PUSH
16106: LD_INT 0
16108: ST_TO_ADDR
// for x in pointsr do
16109: LD_ADDR_VAR 0 7
16113: PUSH
16114: LD_VAR 0 6
16118: PUSH
16119: FOR_IN
16120: IFFALSE 16268
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16122: LD_VAR 0 1
16126: PPUSH
16127: LD_VAR 0 7
16131: PUSH
16132: LD_INT 1
16134: ARRAY
16135: PPUSH
16136: LD_VAR 0 7
16140: PUSH
16141: LD_INT 2
16143: ARRAY
16144: PPUSH
16145: CALL_OW 297
16149: PUSH
16150: LD_VAR 0 8
16154: LESS
16155: IFFALSE 16200
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16157: LD_ADDR_VAR 0 8
16161: PUSH
16162: LD_VAR 0 1
16166: PPUSH
16167: LD_VAR 0 7
16171: PUSH
16172: LD_INT 1
16174: ARRAY
16175: PPUSH
16176: LD_VAR 0 7
16180: PUSH
16181: LD_INT 2
16183: ARRAY
16184: PPUSH
16185: CALL_OW 297
16189: ST_TO_ADDR
// xy := x ;
16190: LD_ADDR_VAR 0 9
16194: PUSH
16195: LD_VAR 0 7
16199: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16200: LD_VAR 0 9
16204: PUSH
16205: LD_VAR 0 1
16209: PPUSH
16210: LD_VAR 0 9
16214: PUSH
16215: LD_INT 1
16217: ARRAY
16218: PPUSH
16219: LD_VAR 0 9
16223: PUSH
16224: LD_INT 2
16226: ARRAY
16227: PPUSH
16228: CALL_OW 297
16232: PUSH
16233: LD_INT 9
16235: GREATER
16236: AND
16237: IFFALSE 16266
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16239: LD_VAR 0 1
16243: PPUSH
16244: LD_VAR 0 9
16248: PUSH
16249: LD_INT 1
16251: ARRAY
16252: PPUSH
16253: LD_VAR 0 9
16257: PUSH
16258: LD_INT 2
16260: ARRAY
16261: PPUSH
16262: CALL_OW 114
// end ;
16266: GO 16119
16268: POP
16269: POP
// end else
16270: GO 16460
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16272: LD_ADDR_VAR 0 3
16276: PUSH
16277: LD_OWVAR 3
16281: PUSH
16282: LD_VAR 0 1
16286: DIFF
16287: PPUSH
16288: LD_VAR 0 1
16292: PPUSH
16293: CALL_OW 74
16297: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16298: LD_VAR 0 1
16302: PPUSH
16303: CALL_OW 320
16307: NOT
16308: PUSH
16309: LD_VAR 0 3
16313: PUSH
16314: LD_INT 21
16316: PUSH
16317: LD_INT 2
16319: PUSH
16320: EMPTY
16321: LIST
16322: LIST
16323: PUSH
16324: LD_INT 33
16326: PUSH
16327: LD_INT 1
16329: PUSH
16330: EMPTY
16331: LIST
16332: LIST
16333: PUSH
16334: LD_INT 58
16336: PUSH
16337: EMPTY
16338: LIST
16339: PUSH
16340: EMPTY
16341: LIST
16342: LIST
16343: LIST
16344: PPUSH
16345: CALL_OW 69
16349: IN
16350: PUSH
16351: LD_VAR 0 3
16355: PUSH
16356: LD_INT 22
16358: PUSH
16359: LD_INT 3
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 21
16368: PUSH
16369: LD_INT 2
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: LD_INT 3
16378: PUSH
16379: LD_INT 24
16381: PUSH
16382: LD_INT 249
16384: PUSH
16385: EMPTY
16386: LIST
16387: LIST
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: LIST
16397: PPUSH
16398: CALL_OW 69
16402: IN
16403: OR
16404: AND
16405: IFFALSE 16423
// ComAttackUnit ( i , un ) else
16407: LD_VAR 0 1
16411: PPUSH
16412: LD_VAR 0 3
16416: PPUSH
16417: CALL_OW 115
16421: GO 16460
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16423: LD_VAR 0 1
16427: PPUSH
16428: LD_INT 9
16430: PPUSH
16431: LD_INT 81
16433: PUSH
16434: LD_INT 3
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: PPUSH
16441: CALL_OW 70
16445: PPUSH
16446: LD_VAR 0 1
16450: PPUSH
16451: CALL_OW 74
16455: PPUSH
16456: CALL_OW 115
// end ; end ; end ; end ;
16460: GO 15727
16462: POP
16463: POP
// end ;
16464: PPOPN 9
16466: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16467: LD_INT 22
16469: PUSH
16470: LD_INT 3
16472: PUSH
16473: EMPTY
16474: LIST
16475: LIST
16476: PUSH
16477: LD_INT 32
16479: PUSH
16480: LD_INT 1
16482: PUSH
16483: EMPTY
16484: LIST
16485: LIST
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PPUSH
16491: CALL_OW 69
16495: IFFALSE 16583
16497: GO 16499
16499: DISABLE
16500: LD_INT 0
16502: PPUSH
16503: PPUSH
// begin enable ;
16504: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16505: LD_ADDR_VAR 0 2
16509: PUSH
16510: LD_INT 22
16512: PUSH
16513: LD_INT 3
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: PUSH
16520: LD_INT 32
16522: PUSH
16523: LD_INT 1
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PPUSH
16534: CALL_OW 69
16538: ST_TO_ADDR
// for i in tmp do
16539: LD_ADDR_VAR 0 1
16543: PUSH
16544: LD_VAR 0 2
16548: PUSH
16549: FOR_IN
16550: IFFALSE 16581
// if GetFuel ( i ) < 12 then
16552: LD_VAR 0 1
16556: PPUSH
16557: CALL_OW 261
16561: PUSH
16562: LD_INT 12
16564: LESS
16565: IFFALSE 16579
// SetFuel ( i , 12 ) ;
16567: LD_VAR 0 1
16571: PPUSH
16572: LD_INT 12
16574: PPUSH
16575: CALL_OW 240
16579: GO 16549
16581: POP
16582: POP
// end ;
16583: PPOPN 2
16585: END
// every 0 0$1 trigger can_end do
16586: LD_EXP 17
16590: IFFALSE 16609
16592: GO 16594
16594: DISABLE
// begin Wait ( 1 1$35 ) ;
16595: LD_INT 3325
16597: PPUSH
16598: CALL_OW 67
// PrepareAttack ( 10 ) ;
16602: LD_INT 10
16604: PPUSH
16605: CALL 14442 0 1
// end ;
16609: END
