// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12353 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1745 0 0
// Action ;
  32: CALL 2620 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1713
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// for i = 1 to 4 do
1676: LD_ADDR_VAR 0 5
1680: PUSH
1681: DOUBLE
1682: LD_INT 1
1684: DEC
1685: ST_TO_ADDR
1686: LD_INT 4
1688: PUSH
1689: FOR_TO
1690: IFFALSE 1711
// AddExperience ( Houten , i , 10000 ) ;
1692: LD_EXP 22
1696: PPUSH
1697: LD_VAR 0 5
1701: PPUSH
1702: LD_INT 10000
1704: PPUSH
1705: CALL_OW 492
1709: GO 1689
1711: POP
1712: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1713: LD_ADDR_EXP 25
1717: PUSH
1718: LD_STRING Powell
1720: PPUSH
1721: LD_INT 0
1723: PPUSH
1724: LD_STRING 
1726: PPUSH
1727: CALL 201 0 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// InitUc ;
1736: CALL_OW 18
// end ;
1740: LD_VAR 0 1
1744: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1745: LD_INT 0
1747: PPUSH
1748: PPUSH
1749: PPUSH
1750: PPUSH
1751: PPUSH
// uc_side := 4 ;
1752: LD_ADDR_OWVAR 20
1756: PUSH
1757: LD_INT 4
1759: ST_TO_ADDR
// uc_nation := 3 ;
1760: LD_ADDR_OWVAR 21
1764: PUSH
1765: LD_INT 3
1767: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_STRING 09_ovsyenko_base
1775: PPUSH
1776: LD_INT 0
1778: PUSH
1779: LD_INT 101
1781: PUSH
1782: LD_INT 118
1784: PUSH
1785: LD_INT 2
1787: PUSH
1788: LD_INT 500
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 31
1800: PUSH
1801: LD_INT 109
1803: PUSH
1804: LD_INT 114
1806: PUSH
1807: LD_INT 4
1809: PUSH
1810: LD_INT 500
1812: PUSH
1813: EMPTY
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_INT 31
1822: PUSH
1823: LD_INT 115
1825: PUSH
1826: LD_INT 132
1828: PUSH
1829: LD_INT 5
1831: PUSH
1832: LD_INT 500
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 31
1844: PUSH
1845: LD_INT 98
1847: PUSH
1848: LD_INT 120
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 500
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: PPUSH
1870: CALL_OW 30
1874: ST_TO_ADDR
// for i in tmp do
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: LD_VAR 0 4
1884: PUSH
1885: FOR_IN
1886: IFFALSE 2042
// begin bc_type := i [ 1 ] ;
1888: LD_ADDR_OWVAR 42
1892: PUSH
1893: LD_VAR 0 2
1897: PUSH
1898: LD_INT 1
1900: ARRAY
1901: ST_TO_ADDR
// bc_level := 3 ;
1902: LD_ADDR_OWVAR 43
1906: PUSH
1907: LD_INT 3
1909: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1910: LD_ADDR_VAR 0 3
1914: PUSH
1915: LD_VAR 0 2
1919: PUSH
1920: LD_INT 2
1922: ARRAY
1923: PPUSH
1924: LD_VAR 0 2
1928: PUSH
1929: LD_INT 3
1931: ARRAY
1932: PPUSH
1933: LD_VAR 0 2
1937: PUSH
1938: LD_INT 4
1940: ARRAY
1941: PPUSH
1942: CALL_OW 47
1946: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1947: LD_VAR 0 3
1951: PPUSH
1952: CALL_OW 266
1956: PUSH
1957: LD_INT 0
1959: EQUAL
1960: IFFALSE 1994
// begin SetBName ( b , ovsyenko ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: LD_STRING ovsyenko
1969: PPUSH
1970: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1974: LD_VAR 0 3
1978: PPUSH
1979: CALL_OW 274
1983: PPUSH
1984: LD_INT 1
1986: PPUSH
1987: LD_INT 50
1989: PPUSH
1990: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1994: LD_VAR 0 2
1998: PUSH
1999: LD_INT 5
2001: ARRAY
2002: PUSH
2003: LD_INT 250
2005: LESS
2006: IFFALSE 2022
// SetLives ( b , 333 ) else
2008: LD_VAR 0 3
2012: PPUSH
2013: LD_INT 333
2015: PPUSH
2016: CALL_OW 234
2020: GO 2040
// SetLives ( b , i [ 5 ] ) ;
2022: LD_VAR 0 3
2026: PPUSH
2027: LD_VAR 0 2
2031: PUSH
2032: LD_INT 5
2034: ARRAY
2035: PPUSH
2036: CALL_OW 234
// end ;
2040: GO 1885
2042: POP
2043: POP
// uc_nation := 1 ;
2044: LD_ADDR_OWVAR 21
2048: PUSH
2049: LD_INT 1
2051: ST_TO_ADDR
// tmp := [ ] ;
2052: LD_ADDR_VAR 0 4
2056: PUSH
2057: EMPTY
2058: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2059: LD_ADDR_EXP 19
2063: PUSH
2064: LD_STRING Gary
2066: PPUSH
2067: LD_EXP 2
2071: NOT
2072: PPUSH
2073: LD_STRING 
2075: PPUSH
2076: CALL 201 0 3
2080: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 4
2090: PUSH
2091: LD_EXP 19
2095: ADD
2096: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2097: LD_ADDR_EXP 20
2101: PUSH
2102: LD_STRING Bobby
2104: PPUSH
2105: LD_EXP 2
2109: NOT
2110: PPUSH
2111: LD_STRING 03_
2113: PPUSH
2114: CALL 201 0 3
2118: ST_TO_ADDR
// if Bobby then
2119: LD_EXP 20
2123: IFFALSE 2141
// tmp := tmp ^ Bobby ;
2125: LD_ADDR_VAR 0 4
2129: PUSH
2130: LD_VAR 0 4
2134: PUSH
2135: LD_EXP 20
2139: ADD
2140: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2141: LD_ADDR_EXP 21
2145: PUSH
2146: LD_STRING Cyrus
2148: PPUSH
2149: LD_EXP 2
2153: NOT
2154: PPUSH
2155: LD_STRING 03_
2157: PPUSH
2158: CALL 201 0 3
2162: ST_TO_ADDR
// if Cyrus then
2163: LD_EXP 21
2167: IFFALSE 2185
// tmp := tmp ^ Cyrus ;
2169: LD_ADDR_VAR 0 4
2173: PUSH
2174: LD_VAR 0 4
2178: PUSH
2179: LD_EXP 21
2183: ADD
2184: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2185: LD_ADDR_VAR 0 4
2189: PUSH
2190: LD_VAR 0 4
2194: PUSH
2195: LD_STRING 09_prev_squad
2197: PPUSH
2198: CALL_OW 31
2202: ADD
2203: ST_TO_ADDR
// tmp := tmp diff 0 ;
2204: LD_ADDR_VAR 0 4
2208: PUSH
2209: LD_VAR 0 4
2213: PUSH
2214: LD_INT 0
2216: DIFF
2217: ST_TO_ADDR
// if debug then
2218: LD_EXP 2
2222: IFFALSE 2273
// begin for i = 1 to 6 do
2224: LD_ADDR_VAR 0 2
2228: PUSH
2229: DOUBLE
2230: LD_INT 1
2232: DEC
2233: ST_TO_ADDR
2234: LD_INT 6
2236: PUSH
2237: FOR_TO
2238: IFFALSE 2271
// begin PrepareHuman ( false , 1 , 6 ) ;
2240: LD_INT 0
2242: PPUSH
2243: LD_INT 1
2245: PPUSH
2246: LD_INT 6
2248: PPUSH
2249: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2253: LD_ADDR_VAR 0 4
2257: PUSH
2258: LD_VAR 0 4
2262: PUSH
2263: CALL_OW 44
2267: ADD
2268: ST_TO_ADDR
// end ;
2269: GO 2237
2271: POP
2272: POP
// end ; for i in tmp do
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_VAR 0 4
2282: PUSH
2283: FOR_IN
2284: IFFALSE 2343
// begin if GetClass ( i ) in [ 2 , 3 ] then
2286: LD_VAR 0 2
2290: PPUSH
2291: CALL_OW 257
2295: PUSH
2296: LD_INT 2
2298: PUSH
2299: LD_INT 3
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: IN
2306: IFFALSE 2320
// SetClass ( i , 1 ) ;
2308: LD_VAR 0 2
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: LD_INT 106
2327: PPUSH
2328: LD_INT 122
2330: PPUSH
2331: LD_INT 5
2333: PPUSH
2334: LD_INT 0
2336: PPUSH
2337: CALL_OW 50
// end ;
2341: GO 2283
2343: POP
2344: POP
// tmp := tmp diff Gary ;
2345: LD_ADDR_VAR 0 4
2349: PUSH
2350: LD_VAR 0 4
2354: PUSH
2355: LD_EXP 19
2359: DIFF
2360: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2361: LD_ADDR_VAR 0 3
2365: PUSH
2366: LD_INT 22
2368: PUSH
2369: LD_INT 4
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: LD_INT 30
2378: PUSH
2379: LD_INT 31
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: PPUSH
2390: CALL_OW 69
2394: ST_TO_ADDR
// for i = 1 to b do
2395: LD_ADDR_VAR 0 2
2399: PUSH
2400: DOUBLE
2401: LD_INT 1
2403: DEC
2404: ST_TO_ADDR
2405: LD_VAR 0 3
2409: PUSH
2410: FOR_TO
2411: IFFALSE 2441
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2413: LD_VAR 0 4
2417: PUSH
2418: LD_VAR 0 2
2422: ARRAY
2423: PPUSH
2424: LD_VAR 0 3
2428: PUSH
2429: LD_VAR 0 2
2433: ARRAY
2434: PPUSH
2435: CALL_OW 120
// end ;
2439: GO 2410
2441: POP
2442: POP
// InitHc ;
2443: CALL_OW 19
// InitUc ;
2447: CALL_OW 18
// end ;
2451: LD_VAR 0 1
2455: RET
// export function PowellTransport ; var i , un ; begin
2456: LD_INT 0
2458: PPUSH
2459: PPUSH
2460: PPUSH
// uc_side := 4 ;
2461: LD_ADDR_OWVAR 20
2465: PUSH
2466: LD_INT 4
2468: ST_TO_ADDR
// uc_nation := 1 ;
2469: LD_ADDR_OWVAR 21
2473: PUSH
2474: LD_INT 1
2476: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2477: LD_INT 1
2479: PPUSH
2480: LD_INT 3
2482: PPUSH
2483: LD_INT 6
2485: PPUSH
2486: CALL_OW 380
// hc_name :=  ;
2490: LD_ADDR_OWVAR 26
2494: PUSH
2495: LD_STRING 
2497: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2498: LD_ADDR_OWVAR 33
2502: PUSH
2503: LD_STRING SecondCharsGal
2505: ST_TO_ADDR
// hc_face_number := 30 ;
2506: LD_ADDR_OWVAR 34
2510: PUSH
2511: LD_INT 30
2513: ST_TO_ADDR
// powell_trans := CreateHuman ;
2514: LD_ADDR_EXP 24
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// hc_face_number := 31 ;
2524: LD_ADDR_OWVAR 34
2528: PUSH
2529: LD_INT 31
2531: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2532: LD_ADDR_EXP 24
2536: PUSH
2537: LD_EXP 24
2541: PUSH
2542: CALL_OW 44
2546: ADD
2547: ST_TO_ADDR
// for i = 1 to 2 do
2548: LD_ADDR_VAR 0 2
2552: PUSH
2553: DOUBLE
2554: LD_INT 1
2556: DEC
2557: ST_TO_ADDR
2558: LD_INT 2
2560: PUSH
2561: FOR_TO
2562: IFFALSE 2613
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2564: LD_ADDR_VAR 0 3
2568: PUSH
2569: LD_INT 4
2571: PPUSH
2572: LD_INT 1
2574: PPUSH
2575: LD_INT 3
2577: PPUSH
2578: LD_INT 1
2580: PPUSH
2581: LD_INT 1
2583: PPUSH
2584: LD_INT 12
2586: PPUSH
2587: LD_INT 66
2589: PPUSH
2590: CALL 264 0 7
2594: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2595: LD_ADDR_EXP 24
2599: PUSH
2600: LD_EXP 24
2604: PUSH
2605: LD_VAR 0 3
2609: ADD
2610: ST_TO_ADDR
// end ;
2611: GO 2561
2613: POP
2614: POP
// end ; end_of_file
2615: LD_VAR 0 1
2619: RET
// export function Action ; var i , veh ; begin
2620: LD_INT 0
2622: PPUSH
2623: PPUSH
2624: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2625: LD_EXP 23
2629: PPUSH
2630: LD_INT 0
2632: PPUSH
2633: LD_INT 50
2635: PPUSH
2636: LD_INT 38
2638: PPUSH
2639: LD_INT 2
2641: PPUSH
2642: CALL_OW 145
// InGameOn ;
2646: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 9
2655: PPUSH
2656: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2660: LD_EXP 18
2664: PPUSH
2665: LD_INT 54
2667: PPUSH
2668: LD_INT 34
2670: PPUSH
2671: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2675: LD_EXP 18
2679: PPUSH
2680: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2684: LD_EXP 18
2688: PPUSH
2689: LD_EXP 23
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2702: LD_INT 35
2704: PPUSH
2705: CALL_OW 67
// until See ( 4 , JMM ) ;
2709: LD_INT 4
2711: PPUSH
2712: LD_EXP 18
2716: PPUSH
2717: CALL_OW 292
2721: IFFALSE 2702
// CenterNowOnUnits ( JMM ) ;
2723: LD_EXP 18
2727: PPUSH
2728: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2732: LD_EXP 18
2736: PPUSH
2737: LD_STRING D2-JMM-1
2739: PPUSH
2740: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2744: LD_EXP 23
2748: PUSH
2749: LD_INT 3
2751: ARRAY
2752: PPUSH
2753: LD_EXP 18
2757: PPUSH
2758: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2762: LD_EXP 23
2766: PUSH
2767: LD_INT 3
2769: ARRAY
2770: PPUSH
2771: LD_STRING D2-Eng1-1
2773: PPUSH
2774: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2778: LD_EXP 18
2782: PPUSH
2783: LD_STRING D2-JMM-2
2785: PPUSH
2786: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2790: LD_EXP 23
2794: PUSH
2795: LD_INT 3
2797: ARRAY
2798: PPUSH
2799: LD_STRING D2-Eng1-2
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2806: LD_EXP 18
2810: PPUSH
2811: LD_STRING D2-JMM-3
2813: PPUSH
2814: CALL_OW 88
// if Houten then
2818: LD_EXP 22
2822: IFFALSE 3020
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2824: LD_ADDR_VAR 0 3
2828: PUSH
2829: LD_INT 4
2831: PPUSH
2832: LD_INT 1
2834: PPUSH
2835: LD_INT 3
2837: PPUSH
2838: LD_INT 2
2840: PPUSH
2841: LD_INT 1
2843: PPUSH
2844: LD_INT 4
2846: PPUSH
2847: LD_INT 55
2849: PPUSH
2850: CALL 264 0 7
2854: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2855: LD_VAR 0 3
2859: PPUSH
2860: LD_INT 3
2862: PPUSH
2863: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 46
2874: PPUSH
2875: LD_INT 19
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2885: LD_EXP 22
2889: PPUSH
2890: LD_VAR 0 3
2894: PPUSH
2895: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2899: LD_EXP 22
2903: PPUSH
2904: LD_INT 49
2906: PPUSH
2907: LD_INT 33
2909: PPUSH
2910: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2914: LD_EXP 22
2918: PPUSH
2919: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2923: LD_EXP 22
2927: PPUSH
2928: LD_EXP 18
2932: PPUSH
2933: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2937: LD_INT 35
2939: PPUSH
2940: CALL_OW 67
// until See ( 1 , Houten ) ;
2944: LD_INT 1
2946: PPUSH
2947: LD_EXP 22
2951: PPUSH
2952: CALL_OW 292
2956: IFFALSE 2937
// ComTurnUnit ( JMM , Houten ) ;
2958: LD_EXP 18
2962: PPUSH
2963: LD_EXP 22
2967: PPUSH
2968: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2972: LD_EXP 18
2976: PPUSH
2977: LD_STRING D1d-JMM-1
2979: PPUSH
2980: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2984: LD_EXP 22
2988: PPUSH
2989: LD_STRING D1-VanH-1
2991: PPUSH
2992: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2996: LD_EXP 18
3000: PPUSH
3001: LD_STRING D1-JMM-1v
3003: PPUSH
3004: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3008: LD_EXP 18
3012: PPUSH
3013: LD_STRING D1-JMM-2v
3015: PPUSH
3016: CALL_OW 88
// end ; InGameOff ;
3020: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3024: LD_STRING M1
3026: PPUSH
3027: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3031: LD_INT 22
3033: PUSH
3034: LD_INT 4
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: PUSH
3041: LD_INT 92
3043: PUSH
3044: LD_EXP 18
3048: PPUSH
3049: CALL_OW 250
3053: PUSH
3054: LD_EXP 18
3058: PPUSH
3059: CALL_OW 251
3063: PUSH
3064: LD_INT 15
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PPUSH
3077: CALL_OW 69
3081: PPUSH
3082: LD_INT 1
3084: PPUSH
3085: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3089: LD_EXP 23
3093: PUSH
3094: LD_EXP 18
3098: ADD
3099: PUSH
3100: LD_EXP 22
3104: ADD
3105: PPUSH
3106: CALL_OW 141
// end ;
3110: LD_VAR 0 1
3114: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3115: LD_INT 1
3117: PPUSH
3118: LD_EXP 19
3122: PPUSH
3123: CALL_OW 292
3127: PUSH
3128: LD_EXP 18
3132: PPUSH
3133: LD_EXP 19
3137: PPUSH
3138: CALL_OW 296
3142: PUSH
3143: LD_INT 6
3145: LESS
3146: AND
3147: IFFALSE 3910
3149: GO 3151
3151: DISABLE
3152: LD_INT 0
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
// begin InGameOn ;
3159: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3163: LD_INT 22
3165: PUSH
3166: LD_INT 4
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PPUSH
3173: CALL_OW 69
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3185: LD_ADDR_VAR 0 4
3189: PUSH
3190: LD_INT 22
3192: PUSH
3193: LD_INT 1
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 2
3202: PUSH
3203: LD_INT 25
3205: PUSH
3206: LD_INT 1
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 2
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PUSH
3223: LD_INT 25
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: PUSH
3233: LD_INT 25
3235: PUSH
3236: LD_INT 4
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: PPUSH
3254: CALL_OW 69
3258: ST_TO_ADDR
// ComHold ( tmp ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3268: LD_EXP 18
3272: PPUSH
3273: LD_STRING D2-JMM-3a
3275: PPUSH
3276: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3280: LD_EXP 19
3284: PPUSH
3285: LD_EXP 18
3289: PPUSH
3290: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_STRING D2-Gary-3
3301: PPUSH
3302: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3306: LD_EXP 18
3310: PPUSH
3311: LD_EXP 19
3315: PPUSH
3316: CALL_OW 119
// for i in tmp do
3320: LD_ADDR_VAR 0 5
3324: PUSH
3325: LD_VAR 0 4
3329: PUSH
3330: FOR_IN
3331: IFFALSE 3376
// begin if IsInUnit ( i ) then
3333: LD_VAR 0 5
3337: PPUSH
3338: CALL_OW 310
3342: IFFALSE 3353
// ComExitBuilding ( i ) ;
3344: LD_VAR 0 5
3348: PPUSH
3349: CALL_OW 122
// wait ( 1 ) ;
3353: LD_INT 1
3355: PPUSH
3356: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3360: LD_VAR 0 5
3364: PPUSH
3365: LD_EXP 18
3369: PPUSH
3370: CALL_OW 119
// end ;
3374: GO 3330
3376: POP
3377: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3378: LD_ADDR_VAR 0 4
3382: PUSH
3383: LD_VAR 0 4
3387: PUSH
3388: LD_EXP 18
3392: PUSH
3393: LD_EXP 22
3397: PUSH
3398: LD_EXP 19
3402: PUSH
3403: LD_EXP 21
3407: PUSH
3408: LD_EXP 20
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_EXP 23
3424: ADD
3425: DIFF
3426: ST_TO_ADDR
// if Bobby then
3427: LD_EXP 20
3431: IFFALSE 3445
// Say ( Bobby , D2-Bobby-3 ) ;
3433: LD_EXP 20
3437: PPUSH
3438: LD_STRING D2-Bobby-3
3440: PPUSH
3441: CALL_OW 88
// if Cyrus then
3445: LD_EXP 21
3449: IFFALSE 3463
// Say ( Cyrus , D2-Cyrus-3 ) ;
3451: LD_EXP 21
3455: PPUSH
3456: LD_STRING D2-Cyrus-3
3458: PPUSH
3459: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3463: LD_EXP 18
3467: PPUSH
3468: LD_STRING D2-JMM-4
3470: PPUSH
3471: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3475: LD_EXP 19
3479: PPUSH
3480: LD_STRING D2-Gary-4
3482: PPUSH
3483: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: LD_VAR 0 4
3496: PPUSH
3497: LD_INT 26
3499: PUSH
3500: LD_INT 1
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 72
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: ST_TO_ADDR
// if Cyrus then
3516: LD_EXP 21
3520: IFFALSE 3536
// Say ( Cyrus , D2-Cyrus-4 ) else
3522: LD_EXP 21
3526: PPUSH
3527: LD_STRING D2-Cyrus-4
3529: PPUSH
3530: CALL_OW 88
3534: GO 3548
// Say ( un1 , D2-Sol1-4 ) ;
3536: LD_VAR 0 1
3540: PPUSH
3541: LD_STRING D2-Sol1-4
3543: PPUSH
3544: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3548: LD_EXP 18
3552: PPUSH
3553: LD_STRING D2-JMM-5
3555: PPUSH
3556: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_EXP 23
3569: PPUSH
3570: LD_INT 91
3572: PUSH
3573: LD_EXP 18
3577: PUSH
3578: LD_INT 10
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 26
3588: PUSH
3589: LD_INT 2
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 72
3604: ST_TO_ADDR
// if un2 then
3605: LD_VAR 0 2
3609: IFFALSE 3663
// begin un2 := un2 [ un2 ] ;
3611: LD_ADDR_VAR 0 2
3615: PUSH
3616: LD_VAR 0 2
3620: PUSH
3621: LD_VAR 0 2
3625: ARRAY
3626: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_STRING D2-FEng1-5
3634: PPUSH
3635: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3639: LD_EXP 18
3643: PPUSH
3644: LD_STRING D2-JMM-6
3646: PPUSH
3647: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3651: LD_VAR 0 2
3655: PPUSH
3656: LD_STRING D2-FEng1-6
3658: PPUSH
3659: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_EXP 23
3672: PPUSH
3673: LD_INT 91
3675: PUSH
3676: LD_EXP 18
3680: PUSH
3681: LD_INT 10
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 26
3691: PUSH
3692: LD_INT 1
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PPUSH
3703: CALL_OW 72
3707: ST_TO_ADDR
// if un3 then
3708: LD_VAR 0 3
3712: IFFALSE 3767
// begin un3 := un3 [ 1 ] ;
3714: LD_ADDR_VAR 0 3
3718: PUSH
3719: LD_VAR 0 3
3723: PUSH
3724: LD_INT 1
3726: ARRAY
3727: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3728: LD_VAR 0 3
3732: PPUSH
3733: LD_INT 114
3735: PPUSH
3736: LD_INT 122
3738: PPUSH
3739: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3743: LD_VAR 0 3
3747: PPUSH
3748: LD_STRING D2-Eng1-6
3750: PPUSH
3751: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3755: LD_EXP 18
3759: PPUSH
3760: LD_STRING D2-JMM-7
3762: PPUSH
3763: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3767: LD_EXP 19
3771: PPUSH
3772: LD_STRING D2-Gary-7
3774: PPUSH
3775: CALL_OW 88
// if un2 then
3779: LD_VAR 0 2
3783: IFFALSE 3797
// Say ( un2 , D2-FEng1-7 ) ;
3785: LD_VAR 0 2
3789: PPUSH
3790: LD_STRING D2-FEng1-7
3792: PPUSH
3793: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3797: LD_VAR 0 1
3801: PPUSH
3802: LD_STRING D2-Sol1-7
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3809: LD_EXP 18
3813: PPUSH
3814: LD_STRING D2-JMM-8
3816: PPUSH
3817: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3821: LD_INT 22
3823: PUSH
3824: LD_INT 1
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: PPUSH
3831: CALL_OW 69
3835: PPUSH
3836: CALL_OW 141
// InGameOff ;
3840: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3844: LD_STRING M1a
3846: PPUSH
3847: CALL_OW 337
// jmm_in_ovsyenko := true ;
3851: LD_ADDR_EXP 4
3855: PUSH
3856: LD_INT 1
3858: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3859: LD_INT 1050
3861: PPUSH
3862: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3866: LD_ADDR_VAR 0 4
3870: PUSH
3871: LD_INT 25
3873: PUSH
3874: LD_INT 14
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: PPUSH
3881: CALL_OW 69
3885: ST_TO_ADDR
// if not tmp then
3886: LD_VAR 0 4
3890: NOT
3891: IFFALSE 3895
// exit ;
3893: GO 3910
// ComMoveXY ( tmp , 75 , 75 ) ;
3895: LD_VAR 0 4
3899: PPUSH
3900: LD_INT 75
3902: PPUSH
3903: LD_INT 75
3905: PPUSH
3906: CALL_OW 111
// end ;
3910: PPOPN 5
3912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3913: LD_INT 22
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: LD_INT 30
3925: PUSH
3926: LD_INT 30
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: PUSH
3933: LD_INT 3
3935: PUSH
3936: LD_INT 57
3938: PUSH
3939: EMPTY
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: LIST
3950: PPUSH
3951: CALL_OW 69
3955: IFFALSE 3997
3957: GO 3959
3959: DISABLE
3960: LD_INT 0
3962: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3963: LD_ADDR_VAR 0 1
3967: PUSH
3968: LD_STRING M2easy
3970: PUSH
3971: LD_STRING M2
3973: PUSH
3974: LD_STRING M2hard
3976: PUSH
3977: EMPTY
3978: LIST
3979: LIST
3980: LIST
3981: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3982: LD_VAR 0 1
3986: PUSH
3987: LD_OWVAR 67
3991: ARRAY
3992: PPUSH
3993: CALL_OW 337
// end ;
3997: PPOPN 1
3999: END
// every 3 3$00 do
4000: GO 4002
4002: DISABLE
// begin DialogueOn ;
4003: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4007: LD_EXP 25
4011: PPUSH
4012: LD_STRING D3-Pow-1
4014: PPUSH
4015: CALL_OW 94
// if jmm_in_ovsyenko then
4019: LD_EXP 4
4023: IFFALSE 4051
// begin Say ( JMM , D3-JMM-1 ) ;
4025: LD_EXP 18
4029: PPUSH
4030: LD_STRING D3-JMM-1
4032: PPUSH
4033: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4037: LD_EXP 18
4041: PPUSH
4042: LD_STRING D3-JMM-1b
4044: PPUSH
4045: CALL_OW 88
// end else
4049: GO 4063
// Say ( JMM , D3-JMM-1a ) ;
4051: LD_EXP 18
4055: PPUSH
4056: LD_STRING D3-JMM-1a
4058: PPUSH
4059: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4063: LD_EXP 25
4067: PPUSH
4068: LD_STRING D3-Pow-2
4070: PPUSH
4071: CALL_OW 94
// DialogueOff ;
4075: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4079: LD_STRING M3
4081: PPUSH
4082: CALL_OW 337
// powell_want_sib := true ;
4086: LD_ADDR_EXP 5
4090: PUSH
4091: LD_INT 1
4093: ST_TO_ADDR
// end ;
4094: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4095: LD_EXP 6
4099: PUSH
4100: LD_INT 0
4102: EQUAL
4103: IFFALSE 5494
4105: GO 4107
4107: DISABLE
4108: LD_INT 0
4110: PPUSH
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
4115: PPUSH
4116: PPUSH
4117: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4118: LD_INT 4
4120: PPUSH
4121: LD_INT 1
4123: PPUSH
4124: CALL_OW 343
// PowellTransport ;
4128: CALL 2456 0 0
// for i = 1 to 3 do
4132: LD_ADDR_VAR 0 4
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 3
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4213
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4148: LD_ADDR_VAR 0 1
4152: PUSH
4153: LD_INT 6
4155: PPUSH
4156: LD_VAR 0 4
4160: PPUSH
4161: CALL_OW 287
4165: ST_TO_ADDR
// if not tmp then
4166: LD_VAR 0 1
4170: NOT
4171: IFFALSE 4175
// continue ;
4173: GO 4145
// EraseResourceArea ( terminalArea , i ) ;
4175: LD_INT 6
4177: PPUSH
4178: LD_VAR 0 4
4182: PPUSH
4183: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4187: LD_EXP 3
4191: PPUSH
4192: CALL_OW 274
4196: PPUSH
4197: LD_VAR 0 4
4201: PPUSH
4202: LD_VAR 0 1
4206: PPUSH
4207: CALL_OW 276
// end ;
4211: GO 4145
4213: POP
4214: POP
// x := 43 ;
4215: LD_ADDR_VAR 0 2
4219: PUSH
4220: LD_INT 43
4222: ST_TO_ADDR
// y := 3 ;
4223: LD_ADDR_VAR 0 3
4227: PUSH
4228: LD_INT 3
4230: ST_TO_ADDR
// for i = 3 to 4 do
4231: LD_ADDR_VAR 0 4
4235: PUSH
4236: DOUBLE
4237: LD_INT 3
4239: DEC
4240: ST_TO_ADDR
4241: LD_INT 4
4243: PUSH
4244: FOR_TO
4245: IFFALSE 4436
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4247: LD_EXP 24
4251: PUSH
4252: LD_VAR 0 4
4256: ARRAY
4257: PPUSH
4258: LD_INT 4
4260: PPUSH
4261: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4265: LD_EXP 24
4269: PUSH
4270: LD_VAR 0 4
4274: ARRAY
4275: PPUSH
4276: LD_VAR 0 2
4280: PPUSH
4281: LD_VAR 0 3
4285: PPUSH
4286: LD_INT 0
4288: PPUSH
4289: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4293: LD_EXP 24
4297: PUSH
4298: LD_VAR 0 4
4302: PUSH
4303: LD_INT 2
4305: MINUS
4306: ARRAY
4307: PPUSH
4308: LD_EXP 24
4312: PUSH
4313: LD_VAR 0 4
4317: ARRAY
4318: PPUSH
4319: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4323: LD_EXP 24
4327: PUSH
4328: LD_VAR 0 4
4332: ARRAY
4333: PPUSH
4334: LD_INT 1
4336: PPUSH
4337: LD_INT 100
4339: PPUSH
4340: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4344: LD_EXP 24
4348: PUSH
4349: LD_VAR 0 4
4353: PUSH
4354: LD_INT 2
4356: MINUS
4357: ARRAY
4358: PPUSH
4359: LD_INT 54
4361: PPUSH
4362: LD_INT 42
4364: PPUSH
4365: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4369: LD_EXP 24
4373: PUSH
4374: LD_VAR 0 4
4378: PUSH
4379: LD_INT 2
4381: MINUS
4382: ARRAY
4383: PPUSH
4384: LD_EXP 3
4388: PPUSH
4389: CALL_OW 250
4393: PPUSH
4394: LD_EXP 3
4398: PPUSH
4399: CALL_OW 251
4403: PPUSH
4404: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4408: LD_EXP 24
4412: PUSH
4413: LD_VAR 0 4
4417: PUSH
4418: LD_INT 2
4420: MINUS
4421: ARRAY
4422: PPUSH
4423: CALL_OW 200
// Wait ( 0 0$02 ) ;
4427: LD_INT 70
4429: PPUSH
4430: CALL_OW 67
// end ;
4434: GO 4244
4436: POP
4437: POP
// time := 0 0$20 ;
4438: LD_ADDR_VAR 0 8
4442: PUSH
4443: LD_INT 700
4445: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4446: LD_INT 35
4448: PPUSH
4449: CALL_OW 67
// time := time - 0 0$01 ;
4453: LD_ADDR_VAR 0 8
4457: PUSH
4458: LD_VAR 0 8
4462: PUSH
4463: LD_INT 35
4465: MINUS
4466: ST_TO_ADDR
// for i = 3 to 4 do
4467: LD_ADDR_VAR 0 4
4471: PUSH
4472: DOUBLE
4473: LD_INT 3
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 4
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4616
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4483: LD_EXP 24
4487: PUSH
4488: LD_VAR 0 4
4492: ARRAY
4493: PPUSH
4494: LD_INT 1
4496: PPUSH
4497: CALL_OW 289
4501: PUSH
4502: LD_INT 0
4504: GREATER
4505: PUSH
4506: LD_EXP 24
4510: PUSH
4511: LD_VAR 0 4
4515: ARRAY
4516: PPUSH
4517: CALL_OW 314
4521: NOT
4522: AND
4523: IFFALSE 4614
// begin x := rand ( 0 , 5 ) ;
4525: LD_ADDR_VAR 0 2
4529: PUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_INT 5
4535: PPUSH
4536: CALL_OW 12
4540: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4541: LD_EXP 24
4545: PUSH
4546: LD_VAR 0 4
4550: ARRAY
4551: PPUSH
4552: LD_EXP 24
4556: PUSH
4557: LD_VAR 0 4
4561: ARRAY
4562: PPUSH
4563: CALL_OW 250
4567: PPUSH
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL_OW 272
4580: PPUSH
4581: LD_EXP 24
4585: PUSH
4586: LD_VAR 0 4
4590: ARRAY
4591: PPUSH
4592: CALL_OW 251
4596: PPUSH
4597: LD_VAR 0 2
4601: PPUSH
4602: LD_INT 3
4604: PPUSH
4605: CALL_OW 273
4609: PPUSH
4610: CALL_OW 171
// end ;
4614: GO 4480
4616: POP
4617: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4618: LD_EXP 24
4622: PUSH
4623: LD_INT 1
4625: ARRAY
4626: PPUSH
4627: LD_INT 54
4629: PPUSH
4630: LD_INT 42
4632: PPUSH
4633: CALL_OW 297
4637: PUSH
4638: LD_INT 4
4640: LESS
4641: PUSH
4642: LD_VAR 0 8
4646: PUSH
4647: LD_INT 0
4649: EQUAL
4650: OR
4651: IFFALSE 4446
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4653: LD_EXP 24
4657: PUSH
4658: LD_INT 3
4660: ARRAY
4661: PPUSH
4662: LD_INT 1
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4672: LD_EXP 24
4676: PUSH
4677: LD_INT 4
4679: ARRAY
4680: PPUSH
4681: LD_INT 1
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4691: LD_EXP 3
4695: PPUSH
4696: CALL_OW 274
4700: PPUSH
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 200
4706: PPUSH
4707: CALL_OW 276
// DialogueOn ;
4711: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4715: LD_INT 53
4717: PPUSH
4718: LD_INT 35
4720: PPUSH
4721: CALL_OW 86
// un := powell_trans [ 1 ] ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_EXP 24
4734: PUSH
4735: LD_INT 1
4737: ARRAY
4738: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_STRING D4-Mech1-1
4746: PPUSH
4747: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4751: LD_EXP 18
4755: PPUSH
4756: LD_STRING D4-JMM-1
4758: PPUSH
4759: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4763: LD_VAR 0 5
4767: PPUSH
4768: LD_STRING D4-Mech1-2
4770: PPUSH
4771: CALL_OW 88
// powell_happy := false ;
4775: LD_ADDR_VAR 0 6
4779: PUSH
4780: LD_INT 0
4782: ST_TO_ADDR
// take_cargo := false ;
4783: LD_ADDR_VAR 0 7
4787: PUSH
4788: LD_INT 0
4790: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4791: CALL 784 0 0
4795: PUSH
4796: LD_INT 60
4798: GREATEREQUAL
4799: IFFALSE 4847
// begin Say ( JMM , D5-JMM-1 ) ;
4801: LD_EXP 18
4805: PPUSH
4806: LD_STRING D5-JMM-1
4808: PPUSH
4809: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4813: LD_VAR 0 5
4817: PPUSH
4818: LD_STRING D6-Mech1-1
4820: PPUSH
4821: CALL_OW 88
// powell_happy := true ;
4825: LD_ADDR_VAR 0 6
4829: PUSH
4830: LD_INT 1
4832: ST_TO_ADDR
// take_cargo := true ;
4833: LD_ADDR_VAR 0 7
4837: PUSH
4838: LD_INT 1
4840: ST_TO_ADDR
// DialogueOff ;
4841: CALL_OW 7
// end else
4845: GO 5081
// if GetTerminalCargo > 0 then
4847: CALL 784 0 0
4851: PUSH
4852: LD_INT 0
4854: GREATER
4855: IFFALSE 5053
// begin case Query ( QWait ) of 1 :
4857: LD_STRING QWait
4859: PPUSH
4860: CALL_OW 97
4864: PUSH
4865: LD_INT 1
4867: DOUBLE
4868: EQUAL
4869: IFTRUE 4873
4871: GO 4964
4873: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4874: LD_EXP 18
4878: PPUSH
4879: LD_STRING D5b-JMM-1
4881: PPUSH
4882: CALL_OW 88
// DialogueOff ;
4886: CALL_OW 7
// wait ( 5 5$00 ) ;
4890: LD_INT 10500
4892: PPUSH
4893: CALL_OW 67
// if GetTerminalCargo < 60 then
4897: CALL 784 0 0
4901: PUSH
4902: LD_INT 60
4904: LESS
4905: IFFALSE 4946
// begin DialogueOn ;
4907: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4911: LD_EXP 3
4915: PPUSH
4916: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4920: LD_VAR 0 5
4924: PPUSH
4925: LD_STRING D6-Mech1-1a
4927: PPUSH
4928: CALL_OW 88
// DialogueOff ;
4932: CALL_OW 7
// powell_happy := false ;
4936: LD_ADDR_VAR 0 6
4940: PUSH
4941: LD_INT 0
4943: ST_TO_ADDR
// end else
4944: GO 4962
// begin powell_happy := true ;
4946: LD_ADDR_VAR 0 6
4950: PUSH
4951: LD_INT 1
4953: ST_TO_ADDR
// take_cargo := true ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: LD_INT 1
4961: ST_TO_ADDR
// end ; end ; 2 :
4962: GO 5051
4964: LD_INT 2
4966: DOUBLE
4967: EQUAL
4968: IFTRUE 4972
4970: GO 5011
4972: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4973: LD_EXP 18
4977: PPUSH
4978: LD_STRING D5b-JMM-1
4980: PPUSH
4981: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: LD_STRING D6-Mech1-1a
4992: PPUSH
4993: CALL_OW 88
// DialogueOff ;
4997: CALL_OW 7
// take_cargo := true ;
5001: LD_ADDR_VAR 0 7
5005: PUSH
5006: LD_INT 1
5008: ST_TO_ADDR
// end ; 3 :
5009: GO 5051
5011: LD_INT 3
5013: DOUBLE
5014: EQUAL
5015: IFTRUE 5019
5017: GO 5050
5019: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5020: LD_EXP 18
5024: PPUSH
5025: LD_STRING D5c-JMM-1
5027: PPUSH
5028: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5032: LD_VAR 0 5
5036: PPUSH
5037: LD_STRING D6-Mech1-1b
5039: PPUSH
5040: CALL_OW 88
// DialogueOff ;
5044: CALL_OW 7
// end ; end ;
5048: GO 5051
5050: POP
// end else
5051: GO 5081
// begin Say ( JMM , D5c-JMM-1 ) ;
5053: LD_EXP 18
5057: PPUSH
5058: LD_STRING D5c-JMM-1
5060: PPUSH
5061: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5065: LD_VAR 0 5
5069: PPUSH
5070: LD_STRING D6-Mech1-1b
5072: PPUSH
5073: CALL_OW 88
// DialogueOff ;
5077: CALL_OW 7
// end ; if take_cargo then
5081: LD_VAR 0 7
5085: IFFALSE 5164
// begin x := GetTerminalCargo ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: CALL 784 0 0
5096: ST_TO_ADDR
// if x > 60 then
5097: LD_VAR 0 2
5101: PUSH
5102: LD_INT 60
5104: GREATER
5105: IFFALSE 5115
// x := 60 ;
5107: LD_ADDR_VAR 0 2
5111: PUSH
5112: LD_INT 60
5114: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5115: LD_EXP 3
5119: PPUSH
5120: CALL_OW 274
5124: PPUSH
5125: LD_INT 3
5127: PPUSH
5128: CALL 784 0 0
5132: PUSH
5133: LD_VAR 0 2
5137: MINUS
5138: PPUSH
5139: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5143: LD_EXP 24
5147: PUSH
5148: LD_INT 3
5150: ARRAY
5151: PPUSH
5152: LD_INT 3
5154: PPUSH
5155: LD_VAR 0 2
5159: PPUSH
5160: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5164: LD_EXP 24
5168: PPUSH
5169: LD_INT 43
5171: PPUSH
5172: LD_INT 3
5174: PPUSH
5175: CALL_OW 171
// x := 0 0$20 ;
5179: LD_ADDR_VAR 0 2
5183: PUSH
5184: LD_INT 700
5186: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5187: LD_INT 35
5189: PPUSH
5190: CALL_OW 67
// x := x - 0 0$01 ;
5194: LD_ADDR_VAR 0 2
5198: PUSH
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 35
5206: MINUS
5207: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5208: LD_VAR 0 2
5212: PUSH
5213: LD_INT 0
5215: EQUAL
5216: PUSH
5217: LD_EXP 24
5221: PUSH
5222: LD_INT 3
5224: ARRAY
5225: PPUSH
5226: LD_INT 43
5228: PPUSH
5229: LD_INT 3
5231: PPUSH
5232: CALL_OW 297
5236: PUSH
5237: LD_INT 4
5239: LESS
5240: PUSH
5241: LD_EXP 24
5245: PUSH
5246: LD_INT 3
5248: ARRAY
5249: PPUSH
5250: LD_INT 43
5252: PPUSH
5253: LD_INT 3
5255: PPUSH
5256: CALL_OW 297
5260: PUSH
5261: LD_INT 4
5263: LESS
5264: AND
5265: OR
5266: IFFALSE 5187
// for i in powell_trans do
5268: LD_ADDR_VAR 0 4
5272: PUSH
5273: LD_EXP 24
5277: PUSH
5278: FOR_IN
5279: IFFALSE 5292
// RemoveUnit ( i ) ;
5281: LD_VAR 0 4
5285: PPUSH
5286: CALL_OW 64
5290: GO 5278
5292: POP
5293: POP
// if not powell_happy then
5294: LD_VAR 0 6
5298: NOT
5299: IFFALSE 5310
// powell_happy := - 1 ;
5301: LD_ADDR_VAR 0 6
5305: PUSH
5306: LD_INT 1
5308: NEG
5309: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5310: LD_VAR 0 6
5314: PPUSH
5315: LD_STRING EarlySiberite
5317: PPUSH
5318: CALL_OW 101
// if powell_happy then
5322: LD_VAR 0 6
5326: IFFALSE 5337
// ChangeMissionObjectives ( M3a ) else
5328: LD_STRING M3a
5330: PPUSH
5331: CALL_OW 337
5335: GO 5344
// ChangeMissionObjectives ( M3b ) ;
5337: LD_STRING M3b
5339: PPUSH
5340: CALL_OW 337
// ru_can_attack_terminal := true ;
5344: LD_ADDR_EXP 9
5348: PUSH
5349: LD_INT 1
5351: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5352: LD_INT 12600
5354: PPUSH
5355: CALL_OW 67
// if ru_force then
5359: LD_EXP 34
5363: IFFALSE 5462
// for i in ru_force do
5365: LD_ADDR_VAR 0 4
5369: PUSH
5370: LD_EXP 34
5374: PUSH
5375: FOR_IN
5376: IFFALSE 5460
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5378: LD_INT 1
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: CALL_OW 292
5390: NOT
5391: PUSH
5392: LD_VAR 0 4
5396: PPUSH
5397: LD_INT 81
5399: PUSH
5400: LD_INT 3
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PPUSH
5407: CALL_OW 69
5411: PPUSH
5412: LD_VAR 0 4
5416: PPUSH
5417: CALL_OW 74
5421: PPUSH
5422: CALL_OW 296
5426: PUSH
5427: LD_INT 10
5429: GREATER
5430: AND
5431: IFFALSE 5458
// begin RemoveUnit ( i ) ;
5433: LD_VAR 0 4
5437: PPUSH
5438: CALL_OW 64
// ru_force := ru_force diff i ;
5442: LD_ADDR_EXP 34
5446: PUSH
5447: LD_EXP 34
5451: PUSH
5452: LD_VAR 0 4
5456: DIFF
5457: ST_TO_ADDR
// end ;
5458: GO 5375
5460: POP
5461: POP
// repeat wait ( 0 0$03 ) ;
5462: LD_INT 105
5464: PPUSH
5465: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5469: LD_EXP 8
5473: NOT
5474: PUSH
5475: LD_EXP 34
5479: PUSH
5480: LD_INT 3
5482: LESS
5483: OR
5484: IFFALSE 5462
// ar_can_arrive := true ;
5486: LD_ADDR_EXP 10
5490: PUSH
5491: LD_INT 1
5493: ST_TO_ADDR
// end ;
5494: PPOPN 8
5496: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5497: LD_INT 1
5499: PPUSH
5500: LD_INT 20
5502: PPUSH
5503: CALL_OW 325
5507: IFFALSE 5648
5509: GO 5511
5511: DISABLE
5512: LD_INT 0
5514: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5515: LD_ADDR_VAR 0 1
5519: PUSH
5520: LD_INT 22
5522: PUSH
5523: LD_INT 1
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: PUSH
5530: LD_INT 26
5532: PUSH
5533: LD_INT 1
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: PUSH
5540: LD_INT 25
5542: PUSH
5543: LD_INT 4
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: LIST
5554: PPUSH
5555: CALL_OW 69
5559: PUSH
5560: LD_EXP 18
5564: PUSH
5565: LD_EXP 21
5569: PUSH
5570: LD_EXP 20
5574: PUSH
5575: LD_EXP 22
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: DIFF
5586: ST_TO_ADDR
// if not un then
5587: LD_VAR 0 1
5591: NOT
5592: IFFALSE 5596
// exit ;
5594: GO 5648
// DialogueOn ;
5596: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5600: LD_VAR 0 1
5604: PUSH
5605: LD_INT 1
5607: ARRAY
5608: PPUSH
5609: LD_STRING D13-Sci1-1
5611: PPUSH
5612: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5616: LD_EXP 18
5620: PPUSH
5621: LD_STRING D13-JMM-1
5623: PPUSH
5624: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5628: LD_VAR 0 1
5632: PUSH
5633: LD_INT 1
5635: ARRAY
5636: PPUSH
5637: LD_STRING D13-Sci1-2
5639: PPUSH
5640: CALL_OW 88
// DialogueOff ;
5644: CALL_OW 7
// end ;
5648: PPOPN 1
5650: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5651: LD_INT 1
5653: PPUSH
5654: CALL 815 0 1
5658: PUSH
5659: LD_INT 77
5661: GREATER
5662: PUSH
5663: LD_EXP 8
5667: NOT
5668: AND
5669: PUSH
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PUSH
5680: LD_INT 25
5682: PUSH
5683: LD_INT 4
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: PPUSH
5705: CALL_OW 69
5709: PUSH
5710: LD_EXP 18
5714: PUSH
5715: LD_EXP 20
5719: PUSH
5720: LD_EXP 21
5724: PUSH
5725: LD_EXP 19
5729: PUSH
5730: LD_EXP 22
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: DIFF
5742: AND
5743: IFFALSE 5921
5745: GO 5747
5747: DISABLE
5748: LD_INT 0
5750: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5751: LD_ADDR_VAR 0 1
5755: PUSH
5756: LD_INT 22
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: PUSH
5766: LD_INT 25
5768: PUSH
5769: LD_INT 4
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: PUSH
5776: LD_INT 26
5778: PUSH
5779: LD_INT 1
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 69
5795: PUSH
5796: LD_EXP 18
5800: PUSH
5801: LD_EXP 20
5805: PUSH
5806: LD_EXP 21
5810: PUSH
5811: LD_EXP 19
5815: PUSH
5816: LD_EXP 22
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: LIST
5827: DIFF
5828: ST_TO_ADDR
// DialogueOn ;
5829: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5833: LD_VAR 0 1
5837: PUSH
5838: LD_INT 1
5840: ARRAY
5841: PPUSH
5842: LD_STRING D7-Sci1-1
5844: PPUSH
5845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5849: LD_EXP 18
5853: PPUSH
5854: LD_STRING D7-JMM-1
5856: PPUSH
5857: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5861: LD_VAR 0 1
5865: PUSH
5866: LD_INT 1
5868: ARRAY
5869: PPUSH
5870: LD_STRING D7-Sci1-2
5872: PPUSH
5873: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5877: LD_EXP 18
5881: PPUSH
5882: LD_STRING D7-JMM-2
5884: PPUSH
5885: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5889: LD_VAR 0 1
5893: PUSH
5894: LD_INT 1
5896: ARRAY
5897: PPUSH
5898: LD_STRING D7-Sci1-3
5900: PPUSH
5901: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5905: LD_EXP 18
5909: PPUSH
5910: LD_STRING D7-JMM-3
5912: PPUSH
5913: CALL_OW 88
// DialogueOff ;
5917: CALL_OW 7
// end ;
5921: PPOPN 1
5923: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5924: LD_EXP 10
5928: IFFALSE 9182
5930: GO 5932
5932: DISABLE
5933: LD_INT 0
5935: PPUSH
5936: PPUSH
5937: PPUSH
5938: PPUSH
5939: PPUSH
5940: PPUSH
5941: PPUSH
5942: PPUSH
// begin PrepareArabian ;
5943: CALL 11476 0 0
// repeat wait ( 0 0$01 ) ;
5947: LD_INT 35
5949: PPUSH
5950: CALL_OW 67
// until ar_spawned ;
5954: LD_EXP 11
5958: IFFALSE 5947
// DialogueOn ;
5960: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5964: LD_EXP 26
5968: PPUSH
5969: LD_STRING D8-Ar1-1
5971: PPUSH
5972: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5976: LD_EXP 18
5980: PPUSH
5981: LD_STRING D8-JMM-1
5983: PPUSH
5984: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5988: LD_EXP 26
5992: PPUSH
5993: LD_STRING D8-Ar1-2
5995: PPUSH
5996: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6000: LD_EXP 18
6004: PPUSH
6005: LD_STRING D8-JMM-2
6007: PPUSH
6008: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6012: LD_EXP 26
6016: PPUSH
6017: LD_STRING D8-Ar1-3
6019: PPUSH
6020: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6024: LD_EXP 18
6028: PPUSH
6029: LD_STRING D8-JMM-3
6031: PPUSH
6032: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6036: LD_EXP 26
6040: PPUSH
6041: LD_STRING D8-Ar1-4
6043: PPUSH
6044: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6048: LD_EXP 18
6052: PPUSH
6053: LD_STRING D8-JMM-4
6055: PPUSH
6056: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6060: LD_EXP 26
6064: PPUSH
6065: LD_STRING D8-Ar1-5
6067: PPUSH
6068: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6072: LD_EXP 18
6076: PPUSH
6077: LD_STRING D8-JMM-5
6079: PPUSH
6080: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6084: LD_EXP 26
6088: PPUSH
6089: LD_STRING D8-Ar1-6
6091: PPUSH
6092: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6096: LD_EXP 27
6100: PPUSH
6101: LD_STRING D8-Ar2-6
6103: PPUSH
6104: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6108: LD_EXP 18
6112: PPUSH
6113: LD_STRING D8-JMM-6
6115: PPUSH
6116: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6120: LD_EXP 27
6124: PPUSH
6125: LD_STRING D8-Ar2-7
6127: PPUSH
6128: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6132: LD_STRING QBarracks
6134: PPUSH
6135: CALL_OW 97
6139: PUSH
6140: LD_INT 1
6142: DOUBLE
6143: EQUAL
6144: IFTRUE 6148
6146: GO 6183
6148: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6149: LD_EXP 18
6153: PPUSH
6154: LD_STRING D8a-JMM-1
6156: PPUSH
6157: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6161: LD_EXP 26
6165: PPUSH
6166: LD_STRING D8a-Ar1-1
6168: PPUSH
6169: CALL_OW 94
// player_want_mortar := true ;
6173: LD_ADDR_EXP 12
6177: PUSH
6178: LD_INT 1
6180: ST_TO_ADDR
// end ; 2 :
6181: GO 6341
6183: LD_INT 2
6185: DOUBLE
6186: EQUAL
6187: IFTRUE 6191
6189: GO 6305
6191: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6192: LD_EXP 18
6196: PPUSH
6197: LD_STRING D8b-JMM-1
6199: PPUSH
6200: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6204: LD_EXP 26
6208: PPUSH
6209: LD_STRING D8b-Ar1-1
6211: PPUSH
6212: CALL_OW 94
// case Query ( QInfo ) of 1 :
6216: LD_STRING QInfo
6218: PPUSH
6219: CALL_OW 97
6223: PUSH
6224: LD_INT 1
6226: DOUBLE
6227: EQUAL
6228: IFTRUE 6232
6230: GO 6267
6232: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6233: LD_EXP 18
6237: PPUSH
6238: LD_STRING D8b1-JMM-1
6240: PPUSH
6241: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6245: LD_EXP 26
6249: PPUSH
6250: LD_STRING D8b1-Ar1-1
6252: PPUSH
6253: CALL_OW 94
// player_want_info := 2 ;
6257: LD_ADDR_EXP 13
6261: PUSH
6262: LD_INT 2
6264: ST_TO_ADDR
// end ; 2 :
6265: GO 6303
6267: LD_INT 2
6269: DOUBLE
6270: EQUAL
6271: IFTRUE 6275
6273: GO 6302
6275: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6276: LD_EXP 18
6280: PPUSH
6281: LD_STRING D8b2-JMM-1
6283: PPUSH
6284: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6288: LD_EXP 26
6292: PPUSH
6293: LD_STRING D8b2-Ar1-1
6295: PPUSH
6296: CALL_OW 94
// end ; end ;
6300: GO 6303
6302: POP
// end ; 3 :
6303: GO 6341
6305: LD_INT 3
6307: DOUBLE
6308: EQUAL
6309: IFTRUE 6313
6311: GO 6340
6313: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6314: LD_EXP 18
6318: PPUSH
6319: LD_STRING D8c-JMM-1
6321: PPUSH
6322: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6326: LD_EXP 26
6330: PPUSH
6331: LD_STRING D8c-Ar1-1
6333: PPUSH
6334: CALL_OW 94
// end ; end ;
6338: GO 6341
6340: POP
// DialogueOff ;
6341: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6345: LD_ADDR_VAR 0 4
6349: PUSH
6350: LD_INT 22
6352: PUSH
6353: LD_INT 1
6355: PUSH
6356: EMPTY
6357: LIST
6358: LIST
6359: PUSH
6360: LD_INT 2
6362: PUSH
6363: LD_INT 30
6365: PUSH
6366: LD_INT 0
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 30
6375: PUSH
6376: LD_INT 1
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PPUSH
6392: CALL_OW 69
6396: PPUSH
6397: LD_EXP 27
6401: PPUSH
6402: CALL_OW 74
6406: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6407: LD_ADDR_VAR 0 3
6411: PUSH
6412: LD_INT 22
6414: PUSH
6415: LD_INT 2
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PUSH
6422: LD_INT 21
6424: PUSH
6425: LD_INT 2
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: PPUSH
6436: CALL_OW 69
6440: ST_TO_ADDR
// time := 1 1$35 ;
6441: LD_ADDR_VAR 0 5
6445: PUSH
6446: LD_INT 3325
6448: ST_TO_ADDR
// no_oil_gain := false ;
6449: LD_ADDR_VAR 0 6
6453: PUSH
6454: LD_INT 0
6456: ST_TO_ADDR
// first_warn := false ;
6457: LD_ADDR_VAR 0 7
6461: PUSH
6462: LD_INT 0
6464: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6465: LD_EXP 12
6469: PUSH
6470: LD_EXP 13
6474: OR
6475: IFFALSE 6580
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6477: LD_EXP 33
6481: PPUSH
6482: LD_INT 25
6484: PUSH
6485: LD_INT 1
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: PPUSH
6492: CALL_OW 72
6496: PPUSH
6497: LD_VAR 0 4
6501: PPUSH
6502: CALL_OW 250
6506: PPUSH
6507: LD_VAR 0 4
6511: PPUSH
6512: CALL_OW 251
6516: PPUSH
6517: LD_VAR 0 4
6521: PPUSH
6522: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6526: LD_EXP 33
6530: PPUSH
6531: LD_INT 25
6533: PUSH
6534: LD_INT 1
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PPUSH
6541: CALL_OW 72
6545: PPUSH
6546: LD_INT 86
6548: PPUSH
6549: LD_INT 121
6551: PPUSH
6552: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6556: LD_EXP 33
6560: PPUSH
6561: LD_INT 25
6563: PUSH
6564: LD_INT 1
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PPUSH
6571: CALL_OW 72
6575: PPUSH
6576: CALL_OW 200
// end ; if player_attacked_ar then
6580: LD_EXP 16
6584: IFFALSE 6588
// exit ;
6586: GO 9182
// if player_want_mortar then
6588: LD_EXP 12
6592: IFFALSE 7984
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6594: LD_EXP 27
6598: PPUSH
6599: LD_VAR 0 4
6603: PPUSH
6604: CALL_OW 250
6608: PUSH
6609: LD_INT 1
6611: PLUS
6612: PPUSH
6613: LD_VAR 0 4
6617: PPUSH
6618: CALL_OW 251
6622: PUSH
6623: LD_INT 1
6625: PLUS
6626: PPUSH
6627: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6631: LD_INT 35
6633: PPUSH
6634: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6638: LD_EXP 27
6642: PPUSH
6643: LD_VAR 0 4
6647: PPUSH
6648: CALL_OW 296
6652: PUSH
6653: LD_INT 4
6655: LESS
6656: IFFALSE 6631
// for i = 1 to 6 do
6658: LD_ADDR_VAR 0 1
6662: PUSH
6663: DOUBLE
6664: LD_INT 1
6666: DEC
6667: ST_TO_ADDR
6668: LD_INT 6
6670: PUSH
6671: FOR_TO
6672: IFFALSE 6869
// begin if player_attacked_ar then
6674: LD_EXP 16
6678: IFFALSE 6684
// exit ;
6680: POP
6681: POP
6682: GO 9182
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6684: LD_VAR 0 4
6688: PPUSH
6689: CALL_OW 274
6693: PPUSH
6694: LD_INT 2
6696: PPUSH
6697: CALL_OW 275
6701: PUSH
6702: LD_INT 10
6704: LESS
6705: PUSH
6706: LD_VAR 0 7
6710: NOT
6711: AND
6712: IFFALSE 6775
// begin first_warn := true ;
6714: LD_ADDR_VAR 0 7
6718: PUSH
6719: LD_INT 1
6721: ST_TO_ADDR
// DialogueOn ;
6722: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6726: LD_EXP 28
6730: PPUSH
6731: LD_STRING D9a-FAr1-1
6733: PPUSH
6734: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6738: LD_EXP 18
6742: PPUSH
6743: LD_STRING D9a-JMM-1
6745: PPUSH
6746: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6750: LD_EXP 26
6754: PPUSH
6755: LD_STRING D9a2-Ar1-1
6757: PPUSH
6758: CALL_OW 88
// DialogueOff ;
6762: CALL_OW 7
// wait ( time ) ;
6766: LD_VAR 0 5
6770: PPUSH
6771: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6775: LD_VAR 0 4
6779: PPUSH
6780: CALL_OW 274
6784: PPUSH
6785: LD_INT 2
6787: PPUSH
6788: CALL_OW 275
6792: PUSH
6793: LD_INT 10
6795: LESS
6796: IFFALSE 6822
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6798: LD_EXP 26
6802: PPUSH
6803: LD_STRING D9a3-Ar1-1
6805: PPUSH
6806: CALL_OW 88
// no_oil_gain := true ;
6810: LD_ADDR_VAR 0 6
6814: PUSH
6815: LD_INT 1
6817: ST_TO_ADDR
// break ;
6818: GO 6869
// end else
6820: GO 6867
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6822: LD_EXP 27
6826: PPUSH
6827: LD_VAR 0 4
6831: PPUSH
6832: LD_INT 2
6834: PPUSH
6835: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6839: LD_EXP 27
6843: PPUSH
6844: LD_VAR 0 3
6848: PUSH
6849: LD_VAR 0 1
6853: PUSH
6854: LD_INT 3
6856: MOD
6857: PUSH
6858: LD_INT 1
6860: PLUS
6861: ARRAY
6862: PPUSH
6863: CALL_OW 210
// end ; end ;
6867: GO 6671
6869: POP
6870: POP
// if not no_oil_gain then
6871: LD_VAR 0 6
6875: NOT
6876: IFFALSE 7984
// begin repeat wait ( 0 0$01 ) ;
6878: LD_INT 35
6880: PPUSH
6881: CALL_OW 67
// if player_attacked_ar then
6885: LD_EXP 16
6889: IFFALSE 6893
// exit ;
6891: GO 9182
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6893: LD_VAR 0 3
6897: PUSH
6898: LD_INT 1
6900: ARRAY
6901: PPUSH
6902: CALL_OW 261
6906: PUSH
6907: LD_INT 80
6909: GREATER
6910: PUSH
6911: LD_VAR 0 3
6915: PUSH
6916: LD_INT 2
6918: ARRAY
6919: PPUSH
6920: CALL_OW 261
6924: PUSH
6925: LD_INT 80
6927: GREATER
6928: AND
6929: PUSH
6930: LD_VAR 0 3
6934: PUSH
6935: LD_INT 3
6937: ARRAY
6938: PPUSH
6939: CALL_OW 261
6943: PUSH
6944: LD_INT 80
6946: GREATER
6947: AND
6948: IFFALSE 6878
// ComMoveXY ( Gali , 105 , 127 ) ;
6950: LD_EXP 27
6954: PPUSH
6955: LD_INT 105
6957: PPUSH
6958: LD_INT 127
6960: PPUSH
6961: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6965: LD_EXP 27
6969: PPUSH
6970: LD_INT 2
6972: PPUSH
6973: CALL_OW 173
// AddComHold ( Gali ) ;
6977: LD_EXP 27
6981: PPUSH
6982: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6986: LD_INT 35
6988: PPUSH
6989: CALL_OW 67
// if player_attacked_ar then
6993: LD_EXP 16
6997: IFFALSE 7001
// exit ;
6999: GO 9182
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7001: LD_EXP 27
7005: PPUSH
7006: LD_INT 105
7008: PPUSH
7009: LD_INT 127
7011: PPUSH
7012: CALL_OW 297
7016: PUSH
7017: LD_INT 4
7019: LESS
7020: IFFALSE 6986
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7022: LD_VAR 0 4
7026: PPUSH
7027: CALL_OW 274
7031: PPUSH
7032: LD_INT 1
7034: PPUSH
7035: CALL_OW 275
7039: PUSH
7040: LD_INT 50
7042: LESS
7043: IFFALSE 7339
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7045: LD_VAR 0 4
7049: PPUSH
7050: CALL_OW 274
7054: PPUSH
7055: LD_INT 1
7057: PPUSH
7058: CALL_OW 275
7062: PUSH
7063: LD_INT 0
7065: DOUBLE
7066: GREATEREQUAL
7067: IFFALSE 7075
7069: LD_INT 24
7071: DOUBLE
7072: LESSEQUAL
7073: IFTRUE 7077
7075: GO 7092
7077: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7078: LD_EXP 27
7082: PPUSH
7083: LD_STRING D9b-Ar2-1
7085: PPUSH
7086: CALL_OW 88
7090: GO 7122
7092: LD_INT 25
7094: DOUBLE
7095: GREATEREQUAL
7096: IFFALSE 7104
7098: LD_INT 49
7100: DOUBLE
7101: LESSEQUAL
7102: IFTRUE 7106
7104: GO 7121
7106: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7107: LD_EXP 27
7111: PPUSH
7112: LD_STRING D9b-Ar2-1a
7114: PPUSH
7115: CALL_OW 88
7119: GO 7122
7121: POP
// Say ( JMM , D9b-JMM-1 ) ;
7122: LD_EXP 18
7126: PPUSH
7127: LD_STRING D9b-JMM-1
7129: PPUSH
7130: CALL_OW 88
// x := 0 0$0 ;
7134: LD_ADDR_VAR 0 2
7138: PUSH
7139: LD_INT 0
7141: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7142: LD_INT 35
7144: PPUSH
7145: CALL_OW 67
// x := x + 0 0$1 ;
7149: LD_ADDR_VAR 0 2
7153: PUSH
7154: LD_VAR 0 2
7158: PUSH
7159: LD_INT 35
7161: PLUS
7162: ST_TO_ADDR
// if player_attacked_ar then
7163: LD_EXP 16
7167: IFFALSE 7171
// exit ;
7169: GO 9182
// until x >= time ;
7171: LD_VAR 0 2
7175: PUSH
7176: LD_VAR 0 5
7180: GREATEREQUAL
7181: IFFALSE 7142
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7183: LD_VAR 0 4
7187: PPUSH
7188: CALL_OW 274
7192: PPUSH
7193: LD_INT 1
7195: PPUSH
7196: CALL_OW 275
7200: PUSH
7201: LD_INT 50
7203: LESS
7204: IFFALSE 7337
// begin DialogueOn ;
7206: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7210: LD_EXP 26
7214: PPUSH
7215: LD_STRING D9c-Ar1-1
7217: PPUSH
7218: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7222: LD_EXP 18
7226: PPUSH
7227: LD_STRING D9c-JMM-1
7229: PPUSH
7230: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7234: LD_EXP 26
7238: PPUSH
7239: LD_STRING D9c-Ar1-2
7241: PPUSH
7242: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7246: LD_EXP 28
7250: PPUSH
7251: LD_STRING D9c-FAr1-2
7253: PPUSH
7254: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7258: LD_EXP 26
7262: PPUSH
7263: LD_STRING D9c-Ar1-3
7265: PPUSH
7266: CALL_OW 88
// case Query ( QInfo ) of 1 :
7270: LD_STRING QInfo
7272: PPUSH
7273: CALL_OW 97
7277: PUSH
7278: LD_INT 1
7280: DOUBLE
7281: EQUAL
7282: IFTRUE 7286
7284: GO 7309
7286: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7287: LD_EXP 18
7291: PPUSH
7292: LD_STRING D8b1-JMM-1
7294: PPUSH
7295: CALL_OW 88
// player_want_info := 2 ;
7299: LD_ADDR_EXP 13
7303: PUSH
7304: LD_INT 2
7306: ST_TO_ADDR
// end ; 2 :
7307: GO 7333
7309: LD_INT 2
7311: DOUBLE
7312: EQUAL
7313: IFTRUE 7317
7315: GO 7332
7317: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7318: LD_EXP 26
7322: PPUSH
7323: LD_STRING D8b2-Ar1-1
7325: PPUSH
7326: CALL_OW 88
// end ; end ;
7330: GO 7333
7332: POP
// DialogueOff ;
7333: CALL_OW 7
// end ; end else
7337: GO 7984
// begin RemoveEnvironmentArea ( mortarArea ) ;
7339: LD_INT 2
7341: PPUSH
7342: CALL_OW 355
// wait ( 1 ) ;
7346: LD_INT 1
7348: PPUSH
7349: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7353: LD_EXP 27
7357: PPUSH
7358: LD_INT 1
7360: PPUSH
7361: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7365: LD_EXP 27
7369: PPUSH
7370: LD_INT 4
7372: PPUSH
7373: LD_INT 107
7375: PPUSH
7376: LD_INT 131
7378: PPUSH
7379: LD_INT 0
7381: PPUSH
7382: CALL_OW 145
// repeat wait ( 1 ) ;
7386: LD_INT 1
7388: PPUSH
7389: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7393: LD_INT 30
7395: PUSH
7396: LD_INT 4
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: PUSH
7403: LD_INT 23
7405: PUSH
7406: LD_INT 2
7408: PUSH
7409: EMPTY
7410: LIST
7411: LIST
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PPUSH
7417: CALL_OW 69
7421: IFFALSE 7386
// SetSide ( Gali , 2 ) ;
7423: LD_EXP 27
7427: PPUSH
7428: LD_INT 2
7430: PPUSH
7431: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7435: LD_ADDR_VAR 0 8
7439: PUSH
7440: LD_INT 30
7442: PUSH
7443: LD_INT 4
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 23
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: PPUSH
7464: CALL_OW 69
7468: PUSH
7469: LD_INT 1
7471: ARRAY
7472: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7473: LD_INT 35
7475: PPUSH
7476: CALL_OW 67
// if player_attacked_ar then
7480: LD_EXP 16
7484: IFFALSE 7488
// exit ;
7486: GO 9182
// until BuildingStatus ( b ) <> bs_build ;
7488: LD_VAR 0 8
7492: PPUSH
7493: CALL_OW 461
7497: PUSH
7498: LD_INT 1
7500: NONEQUAL
7501: IFFALSE 7473
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7503: LD_VAR 0 8
7507: PPUSH
7508: CALL_OW 302
7512: PUSH
7513: LD_VAR 0 4
7517: PPUSH
7518: CALL_OW 274
7522: PPUSH
7523: LD_INT 1
7525: PPUSH
7526: CALL_OW 275
7530: PUSH
7531: LD_INT 25
7533: GREATEREQUAL
7534: AND
7535: IFFALSE 7634
// begin ComUpgrade ( b ) ;
7537: LD_VAR 0 8
7541: PPUSH
7542: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7546: LD_EXP 27
7550: PPUSH
7551: LD_STRING h
7553: PUSH
7554: LD_VAR 0 8
7558: PPUSH
7559: CALL_OW 250
7563: PUSH
7564: LD_VAR 0 8
7568: PPUSH
7569: CALL_OW 251
7573: PUSH
7574: LD_VAR 0 8
7578: PUSH
7579: LD_INT 0
7581: PUSH
7582: LD_INT 0
7584: PUSH
7585: LD_INT 0
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: PPUSH
7600: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7604: LD_INT 35
7606: PPUSH
7607: CALL_OW 67
// if player_attacked_ar then
7611: LD_EXP 16
7615: IFFALSE 7619
// exit ;
7617: GO 9182
// until BuildingStatus ( b ) <> bs_build ;
7619: LD_VAR 0 8
7623: PPUSH
7624: CALL_OW 461
7628: PUSH
7629: LD_INT 1
7631: NONEQUAL
7632: IFFALSE 7604
// end ; if b then
7634: LD_VAR 0 8
7638: IFFALSE 7649
// CenterNowOnUnits ( b ) ;
7640: LD_VAR 0 8
7644: PPUSH
7645: CALL_OW 87
// DialogueOn ;
7649: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7653: LD_EXP 27
7657: PPUSH
7658: LD_STRING D9d-Ar2-1
7660: PPUSH
7661: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7665: LD_EXP 26
7669: PPUSH
7670: LD_STRING D9d-Ar1-1
7672: PPUSH
7673: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7677: LD_EXP 18
7681: PPUSH
7682: LD_STRING D9d-JMM-1
7684: PPUSH
7685: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7689: LD_EXP 26
7693: PPUSH
7694: LD_STRING D9d-Ar1-2
7696: PPUSH
7697: CALL_OW 88
// DialogueOff ;
7701: CALL_OW 7
// i := [ ] ;
7705: LD_ADDR_VAR 0 1
7709: PUSH
7710: EMPTY
7711: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7712: LD_VAR 0 4
7716: PPUSH
7717: CALL_OW 274
7721: PPUSH
7722: LD_INT 3
7724: PPUSH
7725: CALL_OW 275
7729: PUSH
7730: LD_INT 20
7732: GREATEREQUAL
7733: IFFALSE 7752
// i := i ^ [ 1 ] ;
7735: LD_ADDR_VAR 0 1
7739: PUSH
7740: LD_VAR 0 1
7744: PUSH
7745: LD_INT 1
7747: PUSH
7748: EMPTY
7749: LIST
7750: ADD
7751: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7752: LD_VAR 0 4
7756: PPUSH
7757: CALL_OW 274
7761: PPUSH
7762: LD_INT 1
7764: PPUSH
7765: CALL_OW 275
7769: PUSH
7770: LD_INT 50
7772: GREATEREQUAL
7773: IFFALSE 7792
// i := i ^ [ 2 ] ;
7775: LD_ADDR_VAR 0 1
7779: PUSH
7780: LD_VAR 0 1
7784: PUSH
7785: LD_INT 2
7787: PUSH
7788: EMPTY
7789: LIST
7790: ADD
7791: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7792: LD_VAR 0 4
7796: PPUSH
7797: CALL_OW 274
7801: PPUSH
7802: LD_INT 2
7804: PPUSH
7805: CALL_OW 275
7809: PUSH
7810: LD_INT 80
7812: GREATEREQUAL
7813: IFFALSE 7832
// i := i ^ [ 3 ] ;
7815: LD_ADDR_VAR 0 1
7819: PUSH
7820: LD_VAR 0 1
7824: PUSH
7825: LD_INT 3
7827: PUSH
7828: EMPTY
7829: LIST
7830: ADD
7831: ST_TO_ADDR
// i := i diff 0 ;
7832: LD_ADDR_VAR 0 1
7836: PUSH
7837: LD_VAR 0 1
7841: PUSH
7842: LD_INT 0
7844: DIFF
7845: ST_TO_ADDR
// if i then
7846: LD_VAR 0 1
7850: IFFALSE 7956
// begin i := i ^ [ 4 ] ;
7852: LD_ADDR_VAR 0 1
7856: PUSH
7857: LD_VAR 0 1
7861: PUSH
7862: LD_INT 4
7864: PUSH
7865: EMPTY
7866: LIST
7867: ADD
7868: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7869: LD_STRING QInfo2
7871: PPUSH
7872: CALL_OW 97
7876: PUSH
7877: LD_INT 1
7879: DOUBLE
7880: EQUAL
7881: IFTRUE 7885
7883: GO 7896
7885: POP
// player_want_info := 3 ; 2 :
7886: LD_ADDR_EXP 13
7890: PUSH
7891: LD_INT 3
7893: ST_TO_ADDR
7894: GO 7954
7896: LD_INT 2
7898: DOUBLE
7899: EQUAL
7900: IFTRUE 7904
7902: GO 7915
7904: POP
// player_want_info := 1 ; 3 :
7905: LD_ADDR_EXP 13
7909: PUSH
7910: LD_INT 1
7912: ST_TO_ADDR
7913: GO 7954
7915: LD_INT 3
7917: DOUBLE
7918: EQUAL
7919: IFTRUE 7923
7921: GO 7934
7923: POP
// player_want_info := 2 ; 4 :
7924: LD_ADDR_EXP 13
7928: PUSH
7929: LD_INT 2
7931: ST_TO_ADDR
7932: GO 7954
7934: LD_INT 4
7936: DOUBLE
7937: EQUAL
7938: IFTRUE 7942
7940: GO 7953
7942: POP
// player_want_info := 0 ; end ;
7943: LD_ADDR_EXP 13
7947: PUSH
7948: LD_INT 0
7950: ST_TO_ADDR
7951: GO 7954
7953: POP
// end else
7954: GO 7984
// case Query ( QInfoNothing ) of 1 :
7956: LD_STRING QInfoNothing
7958: PPUSH
7959: CALL_OW 97
7963: PUSH
7964: LD_INT 1
7966: DOUBLE
7967: EQUAL
7968: IFTRUE 7972
7970: GO 7983
7972: POP
// player_want_info := 0 ; end ;
7973: LD_ADDR_EXP 13
7977: PUSH
7978: LD_INT 0
7980: ST_TO_ADDR
7981: GO 7984
7983: POP
// end ; end ; end ; if player_want_info then
7984: LD_EXP 13
7988: IFFALSE 9002
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7990: LD_ADDR_VAR 0 3
7994: PUSH
7995: LD_VAR 0 3
7999: PPUSH
8000: LD_INT 34
8002: PUSH
8003: LD_INT 32
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PPUSH
8010: CALL_OW 72
8014: ST_TO_ADDR
// if player_want_mortar then
8015: LD_EXP 12
8019: IFFALSE 8341
// begin case player_want_info of 1 :
8021: LD_EXP 13
8025: PUSH
8026: LD_INT 1
8028: DOUBLE
8029: EQUAL
8030: IFTRUE 8034
8032: GO 8045
8034: POP
// x := 5 ; 2 :
8035: LD_ADDR_VAR 0 2
8039: PUSH
8040: LD_INT 5
8042: ST_TO_ADDR
8043: GO 8084
8045: LD_INT 2
8047: DOUBLE
8048: EQUAL
8049: IFTRUE 8053
8051: GO 8064
8053: POP
// x := 8 ; 3 :
8054: LD_ADDR_VAR 0 2
8058: PUSH
8059: LD_INT 8
8061: ST_TO_ADDR
8062: GO 8084
8064: LD_INT 3
8066: DOUBLE
8067: EQUAL
8068: IFTRUE 8072
8070: GO 8083
8072: POP
// x := 2 ; end ;
8073: LD_ADDR_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ST_TO_ADDR
8081: GO 8084
8083: POP
// repeat wait ( 0 0$1 ) ;
8084: LD_INT 35
8086: PPUSH
8087: CALL_OW 67
// until not HasTask ( Gali ) ;
8091: LD_EXP 27
8095: PPUSH
8096: CALL_OW 314
8100: NOT
8101: IFFALSE 8084
// for i = 1 to x do
8103: LD_ADDR_VAR 0 1
8107: PUSH
8108: DOUBLE
8109: LD_INT 1
8111: DEC
8112: ST_TO_ADDR
8113: LD_VAR 0 2
8117: PUSH
8118: FOR_TO
8119: IFFALSE 8284
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8121: LD_EXP 27
8125: PPUSH
8126: LD_VAR 0 4
8130: PPUSH
8131: LD_EXP 13
8135: PPUSH
8136: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8140: LD_EXP 27
8144: PPUSH
8145: LD_VAR 0 3
8149: PUSH
8150: LD_INT 1
8152: ARRAY
8153: PPUSH
8154: CALL_OW 172
// AddComHold ( Gali ) ;
8158: LD_EXP 27
8162: PPUSH
8163: CALL_OW 200
// repeat wait ( 3 ) ;
8167: LD_INT 3
8169: PPUSH
8170: CALL_OW 67
// if player_attacked_ar then
8174: LD_EXP 16
8178: IFFALSE 8184
// exit ;
8180: POP
8181: POP
8182: GO 9182
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8184: LD_EXP 27
8188: PPUSH
8189: LD_VAR 0 3
8193: PUSH
8194: LD_INT 1
8196: ARRAY
8197: PPUSH
8198: CALL_OW 296
8202: PUSH
8203: LD_INT 4
8205: LESS
8206: PUSH
8207: LD_EXP 27
8211: PPUSH
8212: LD_EXP 13
8216: PPUSH
8217: CALL_OW 289
8221: AND
8222: IFFALSE 8167
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8224: LD_VAR 0 3
8228: PUSH
8229: LD_INT 1
8231: ARRAY
8232: PPUSH
8233: LD_EXP 13
8237: PPUSH
8238: LD_VAR 0 3
8242: PUSH
8243: LD_INT 1
8245: ARRAY
8246: PPUSH
8247: LD_EXP 13
8251: PPUSH
8252: CALL_OW 289
8256: PUSH
8257: LD_INT 10
8259: PLUS
8260: PPUSH
8261: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8265: LD_EXP 27
8269: PPUSH
8270: LD_EXP 13
8274: PPUSH
8275: LD_INT 0
8277: PPUSH
8278: CALL_OW 290
// end ;
8282: GO 8118
8284: POP
8285: POP
// repeat wait ( 0 0$1 ) ;
8286: LD_INT 35
8288: PPUSH
8289: CALL_OW 67
// if player_attacked_ar then
8293: LD_EXP 16
8297: IFFALSE 8301
// exit ;
8299: GO 9182
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8301: LD_VAR 0 3
8305: PUSH
8306: LD_INT 1
8308: ARRAY
8309: PPUSH
8310: LD_EXP 13
8314: PPUSH
8315: CALL_OW 289
8319: PUSH
8320: LD_VAR 0 2
8324: PUSH
8325: LD_INT 10
8327: MUL
8328: EQUAL
8329: IFFALSE 8286
// no_oil_gain := false ;
8331: LD_ADDR_VAR 0 6
8335: PUSH
8336: LD_INT 0
8338: ST_TO_ADDR
// end else
8339: GO 8823
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8341: LD_ADDR_VAR 0 3
8345: PUSH
8346: LD_INT 22
8348: PUSH
8349: LD_INT 2
8351: PUSH
8352: EMPTY
8353: LIST
8354: LIST
8355: PUSH
8356: LD_INT 21
8358: PUSH
8359: LD_INT 2
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: PPUSH
8370: CALL_OW 69
8374: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8375: LD_EXP 27
8379: PPUSH
8380: LD_VAR 0 4
8384: PPUSH
8385: CALL_OW 250
8389: PUSH
8390: LD_INT 1
8392: PLUS
8393: PPUSH
8394: LD_VAR 0 4
8398: PPUSH
8399: CALL_OW 251
8403: PUSH
8404: LD_INT 1
8406: PLUS
8407: PPUSH
8408: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8412: LD_INT 35
8414: PPUSH
8415: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8419: LD_EXP 27
8423: PPUSH
8424: LD_VAR 0 4
8428: PPUSH
8429: CALL_OW 296
8433: PUSH
8434: LD_INT 4
8436: LESS
8437: IFFALSE 8412
// for i = 1 to 6 do
8439: LD_ADDR_VAR 0 1
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 6
8451: PUSH
8452: FOR_TO
8453: IFFALSE 8650
// begin if player_attacked_ar then
8455: LD_EXP 16
8459: IFFALSE 8465
// exit ;
8461: POP
8462: POP
8463: GO 9182
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8465: LD_VAR 0 4
8469: PPUSH
8470: CALL_OW 274
8474: PPUSH
8475: LD_INT 2
8477: PPUSH
8478: CALL_OW 275
8482: PUSH
8483: LD_INT 10
8485: LESS
8486: PUSH
8487: LD_VAR 0 7
8491: NOT
8492: AND
8493: IFFALSE 8556
// begin first_warn := true ;
8495: LD_ADDR_VAR 0 7
8499: PUSH
8500: LD_INT 1
8502: ST_TO_ADDR
// DialogueOn ;
8503: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8507: LD_EXP 28
8511: PPUSH
8512: LD_STRING D9a-FAr1-1
8514: PPUSH
8515: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8519: LD_EXP 18
8523: PPUSH
8524: LD_STRING D9a-JMM-1
8526: PPUSH
8527: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8531: LD_EXP 26
8535: PPUSH
8536: LD_STRING D9a2-Ar1-1
8538: PPUSH
8539: CALL_OW 88
// DialogueOff ;
8543: CALL_OW 7
// wait ( time ) ;
8547: LD_VAR 0 5
8551: PPUSH
8552: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8556: LD_VAR 0 4
8560: PPUSH
8561: CALL_OW 274
8565: PPUSH
8566: LD_INT 2
8568: PPUSH
8569: CALL_OW 275
8573: PUSH
8574: LD_INT 10
8576: LESS
8577: IFFALSE 8603
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8579: LD_EXP 26
8583: PPUSH
8584: LD_STRING D9a3-Ar1-1
8586: PPUSH
8587: CALL_OW 88
// no_oil_gain := true ;
8591: LD_ADDR_VAR 0 6
8595: PUSH
8596: LD_INT 1
8598: ST_TO_ADDR
// break ;
8599: GO 8650
// end else
8601: GO 8648
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8603: LD_EXP 27
8607: PPUSH
8608: LD_VAR 0 4
8612: PPUSH
8613: LD_INT 2
8615: PPUSH
8616: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8620: LD_EXP 27
8624: PPUSH
8625: LD_VAR 0 3
8629: PUSH
8630: LD_VAR 0 1
8634: PUSH
8635: LD_INT 3
8637: MOD
8638: PUSH
8639: LD_INT 1
8641: PLUS
8642: ARRAY
8643: PPUSH
8644: CALL_OW 210
// end ; end ;
8648: GO 8452
8650: POP
8651: POP
// repeat wait ( 0 0$1 ) ;
8652: LD_INT 35
8654: PPUSH
8655: CALL_OW 67
// if player_attacked_ar then
8659: LD_EXP 16
8663: IFFALSE 8667
// exit ;
8665: GO 9182
// for i in tmp do
8667: LD_ADDR_VAR 0 1
8671: PUSH
8672: LD_VAR 0 3
8676: PUSH
8677: FOR_IN
8678: IFFALSE 8709
// if GetFuel ( i ) < 100 then
8680: LD_VAR 0 1
8684: PPUSH
8685: CALL_OW 261
8689: PUSH
8690: LD_INT 100
8692: LESS
8693: IFFALSE 8707
// begin x := i ;
8695: LD_ADDR_VAR 0 2
8699: PUSH
8700: LD_VAR 0 1
8704: ST_TO_ADDR
// break ;
8705: GO 8709
// end ;
8707: GO 8677
8709: POP
8710: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8711: LD_EXP 27
8715: PPUSH
8716: CALL_OW 314
8720: NOT
8721: PUSH
8722: LD_EXP 27
8726: PPUSH
8727: CALL_OW 281
8731: NOT
8732: AND
8733: IFFALSE 8766
// begin ComTransport ( Gali , dep , mat_oil ) ;
8735: LD_EXP 27
8739: PPUSH
8740: LD_VAR 0 4
8744: PPUSH
8745: LD_INT 2
8747: PPUSH
8748: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8752: LD_EXP 27
8756: PPUSH
8757: LD_VAR 0 2
8761: PPUSH
8762: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8766: LD_VAR 0 3
8770: PUSH
8771: LD_INT 1
8773: ARRAY
8774: PPUSH
8775: CALL_OW 261
8779: PUSH
8780: LD_INT 80
8782: GREATER
8783: PUSH
8784: LD_VAR 0 3
8788: PUSH
8789: LD_INT 2
8791: ARRAY
8792: PPUSH
8793: CALL_OW 261
8797: PUSH
8798: LD_INT 80
8800: GREATER
8801: AND
8802: PUSH
8803: LD_VAR 0 3
8807: PUSH
8808: LD_INT 3
8810: ARRAY
8811: PPUSH
8812: CALL_OW 261
8816: PUSH
8817: LD_INT 80
8819: GREATER
8820: AND
8821: IFFALSE 8652
// end ; ComHold ( Gali ) ;
8823: LD_EXP 27
8827: PPUSH
8828: CALL_OW 140
// if not no_oil_gain then
8832: LD_VAR 0 6
8836: NOT
8837: IFFALSE 9002
// begin DialogueOn ;
8839: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8843: LD_EXP 26
8847: PPUSH
8848: CALL_OW 87
// if player_want_mortar then
8852: LD_EXP 12
8856: IFFALSE 8882
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8858: LD_EXP 26
8862: PPUSH
8863: LD_STRING D9e-Ar1-1
8865: PPUSH
8866: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8870: LD_EXP 18
8874: PPUSH
8875: LD_STRING D10a-JMM-1
8877: PPUSH
8878: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8882: LD_EXP 26
8886: PPUSH
8887: LD_STRING D10a-Ar1-1
8889: PPUSH
8890: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8894: LD_EXP 27
8898: PPUSH
8899: LD_STRING D10a-Ar2-1
8901: PPUSH
8902: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8906: LD_EXP 28
8910: PPUSH
8911: LD_STRING D10a-FAr1-1
8913: PPUSH
8914: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8918: LD_EXP 27
8922: PPUSH
8923: LD_STRING D10a-Ar2-2
8925: PPUSH
8926: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8930: LD_EXP 28
8934: PPUSH
8935: LD_STRING D10a-FAr1-2
8937: PPUSH
8938: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8942: LD_EXP 26
8946: PPUSH
8947: LD_STRING D10a-Ar1-2
8949: PPUSH
8950: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8954: LD_EXP 18
8958: PPUSH
8959: LD_STRING D10a-JMM-2
8961: PPUSH
8962: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8966: LD_EXP 26
8970: PPUSH
8971: LD_STRING D10a-Ar1-3
8973: PPUSH
8974: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8978: LD_EXP 18
8982: PPUSH
8983: LD_STRING D10a-JMM-3
8985: PPUSH
8986: CALL_OW 88
// player_get_info := true ;
8990: LD_ADDR_EXP 15
8994: PUSH
8995: LD_INT 1
8997: ST_TO_ADDR
// DialogueOff ;
8998: CALL_OW 7
// end ; end ; if player_attacked_ar then
9002: LD_EXP 16
9006: IFFALSE 9010
// exit ;
9008: GO 9182
// if player_want_mortar or player_want_info then
9010: LD_EXP 12
9014: PUSH
9015: LD_EXP 13
9019: OR
9020: IFFALSE 9034
// Say ( Vervecken , D9f-Ar1-1 ) ;
9022: LD_EXP 26
9026: PPUSH
9027: LD_STRING D9f-Ar1-1
9029: PPUSH
9030: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9034: LD_INT 22
9036: PUSH
9037: LD_INT 2
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PPUSH
9044: CALL_OW 69
9048: PPUSH
9049: LD_INT 51
9051: PPUSH
9052: LD_INT 99
9054: PPUSH
9055: CALL_OW 111
// wait ( 0 0$1 ) ;
9059: LD_INT 35
9061: PPUSH
9062: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9066: LD_INT 22
9068: PUSH
9069: LD_INT 2
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: PUSH
9076: LD_INT 92
9078: PUSH
9079: LD_INT 51
9081: PUSH
9082: LD_INT 99
9084: PUSH
9085: LD_INT 2
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: LIST
9092: LIST
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PPUSH
9098: CALL_OW 69
9102: IFFALSE 9162
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9104: LD_ADDR_VAR 0 1
9108: PUSH
9109: LD_INT 22
9111: PUSH
9112: LD_INT 2
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: PUSH
9119: LD_INT 92
9121: PUSH
9122: LD_INT 51
9124: PUSH
9125: LD_INT 99
9127: PUSH
9128: LD_INT 2
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: PPUSH
9141: CALL_OW 69
9145: PUSH
9146: FOR_IN
9147: IFFALSE 9160
// RemoveUnit ( i ) ;
9149: LD_VAR 0 1
9153: PPUSH
9154: CALL_OW 64
9158: GO 9146
9160: POP
9161: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9162: LD_INT 22
9164: PUSH
9165: LD_INT 2
9167: PUSH
9168: EMPTY
9169: LIST
9170: LIST
9171: PPUSH
9172: CALL_OW 69
9176: PUSH
9177: LD_INT 0
9179: EQUAL
9180: IFFALSE 9034
// end ;
9182: PPOPN 8
9184: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9185: LD_EXP 16
9189: IFFALSE 9542
9191: GO 9193
9193: DISABLE
9194: LD_INT 0
9196: PPUSH
9197: PPUSH
9198: PPUSH
9199: PPUSH
// begin ru_can_attack := true ;
9200: LD_ADDR_EXP 8
9204: PUSH
9205: LD_INT 1
9207: ST_TO_ADDR
// mine_launched := false ;
9208: LD_ADDR_VAR 0 3
9212: PUSH
9213: LD_INT 0
9215: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9216: LD_INT 22
9218: PUSH
9219: LD_INT 2
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PPUSH
9226: CALL_OW 69
9230: PPUSH
9231: LD_INT 51
9233: PPUSH
9234: LD_INT 99
9236: PPUSH
9237: CALL_OW 111
// if IsOk ( Vervecken ) then
9241: LD_EXP 26
9245: PPUSH
9246: CALL_OW 302
9250: IFFALSE 9264
// Say ( Vervecken , D11a-Ar1-1 ) ;
9252: LD_EXP 26
9256: PPUSH
9257: LD_STRING D11a-Ar1-1
9259: PPUSH
9260: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9264: LD_ADDR_VAR 0 2
9268: PUSH
9269: LD_EXP 33
9273: PPUSH
9274: LD_INT 25
9276: PUSH
9277: LD_INT 1
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: PPUSH
9284: CALL_OW 72
9288: ST_TO_ADDR
// for i in tmp do
9289: LD_ADDR_VAR 0 1
9293: PUSH
9294: LD_VAR 0 2
9298: PUSH
9299: FOR_IN
9300: IFFALSE 9363
// if MineOfUnit ( i ) then
9302: LD_VAR 0 1
9306: PPUSH
9307: CALL_OW 459
9311: IFFALSE 9361
// begin x := MineOfUnit ( i ) ;
9313: LD_ADDR_VAR 0 4
9317: PUSH
9318: LD_VAR 0 1
9322: PPUSH
9323: CALL_OW 459
9327: ST_TO_ADDR
// mine_launched := true ;
9328: LD_ADDR_VAR 0 3
9332: PUSH
9333: LD_INT 1
9335: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9336: LD_VAR 0 4
9340: PUSH
9341: LD_INT 1
9343: ARRAY
9344: PPUSH
9345: LD_VAR 0 4
9349: PUSH
9350: LD_INT 2
9352: ARRAY
9353: PPUSH
9354: LD_INT 2
9356: PPUSH
9357: CALL_OW 456
// end ;
9361: GO 9299
9363: POP
9364: POP
// if mine_launched and IsOk ( Vervecken ) then
9365: LD_VAR 0 3
9369: PUSH
9370: LD_EXP 26
9374: PPUSH
9375: CALL_OW 302
9379: AND
9380: IFFALSE 9394
// Say ( Vervecken , D11b-Ar1-1 ) ;
9382: LD_EXP 26
9386: PPUSH
9387: LD_STRING D11b-Ar1-1
9389: PPUSH
9390: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9394: LD_INT 22
9396: PUSH
9397: LD_INT 2
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PPUSH
9404: CALL_OW 69
9408: PPUSH
9409: LD_INT 51
9411: PPUSH
9412: LD_INT 99
9414: PPUSH
9415: CALL_OW 111
// wait ( 0 0$1 ) ;
9419: LD_INT 35
9421: PPUSH
9422: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9426: LD_INT 22
9428: PUSH
9429: LD_INT 2
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: LD_INT 92
9438: PUSH
9439: LD_INT 51
9441: PUSH
9442: LD_INT 99
9444: PUSH
9445: LD_INT 2
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: PPUSH
9458: CALL_OW 69
9462: IFFALSE 9522
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 92
9481: PUSH
9482: LD_INT 51
9484: PUSH
9485: LD_INT 99
9487: PUSH
9488: LD_INT 2
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: LIST
9495: LIST
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PPUSH
9501: CALL_OW 69
9505: PUSH
9506: FOR_IN
9507: IFFALSE 9520
// RemoveUnit ( i ) ;
9509: LD_VAR 0 1
9513: PPUSH
9514: CALL_OW 64
9518: GO 9506
9520: POP
9521: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9522: LD_INT 22
9524: PUSH
9525: LD_INT 2
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: PPUSH
9532: CALL_OW 69
9536: PUSH
9537: LD_INT 0
9539: EQUAL
9540: IFFALSE 9394
// end ;
9542: PPOPN 4
9544: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9545: LD_EXP 10
9549: IFFALSE 9728
9551: GO 9553
9553: DISABLE
9554: LD_INT 0
9556: PPUSH
// begin Wait ( 10 10$00 ) ;
9557: LD_INT 21000
9559: PPUSH
9560: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9564: LD_INT 22
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: PPUSH
9574: CALL_OW 69
9578: IFFALSE 9728
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9580: LD_INT 22
9582: PUSH
9583: LD_INT 2
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: PPUSH
9590: CALL_OW 69
9594: PPUSH
9595: LD_INT 51
9597: PPUSH
9598: LD_INT 99
9600: PPUSH
9601: CALL_OW 114
// wait ( 0 0$1 ) ;
9605: LD_INT 35
9607: PPUSH
9608: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9612: LD_INT 22
9614: PUSH
9615: LD_INT 2
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: PUSH
9622: LD_INT 92
9624: PUSH
9625: LD_INT 51
9627: PUSH
9628: LD_INT 99
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PPUSH
9644: CALL_OW 69
9648: IFFALSE 9708
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9650: LD_ADDR_VAR 0 1
9654: PUSH
9655: LD_INT 22
9657: PUSH
9658: LD_INT 2
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 92
9667: PUSH
9668: LD_INT 51
9670: PUSH
9671: LD_INT 99
9673: PUSH
9674: LD_INT 2
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PPUSH
9687: CALL_OW 69
9691: PUSH
9692: FOR_IN
9693: IFFALSE 9706
// RemoveUnit ( i ) ;
9695: LD_VAR 0 1
9699: PPUSH
9700: CALL_OW 64
9704: GO 9692
9706: POP
9707: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9708: LD_INT 22
9710: PUSH
9711: LD_INT 2
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PPUSH
9718: CALL_OW 69
9722: PUSH
9723: LD_INT 0
9725: EQUAL
9726: IFFALSE 9580
// end ; end ;
9728: PPOPN 1
9730: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9731: LD_EXP 4
9735: IFFALSE 10537
9737: GO 9739
9739: DISABLE
9740: LD_INT 0
9742: PPUSH
9743: PPUSH
9744: PPUSH
// begin Wait ( game_time ) ;
9745: LD_EXP 7
9749: PPUSH
9750: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9754: LD_INT 35
9756: PPUSH
9757: CALL_OW 67
// until ( not ru_can_attack ) ;
9761: LD_EXP 8
9765: NOT
9766: IFFALSE 9754
// Wait ( 0 0$35 ) ;
9768: LD_INT 1225
9770: PPUSH
9771: CALL_OW 67
// DialogueOn ;
9775: CALL_OW 6
// InGameOn ;
9779: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9783: LD_EXP 25
9787: PPUSH
9788: LD_STRING D12-Pow-1
9790: PPUSH
9791: CALL_OW 94
// InGameOff ;
9795: CALL_OW 9
// DialogueOff ;
9799: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9803: LD_STRING M4
9805: PPUSH
9806: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9810: LD_INT 5
9812: PPUSH
9813: LD_INT 1
9815: PPUSH
9816: CALL_OW 424
// can_end := true ;
9820: LD_ADDR_EXP 17
9824: PUSH
9825: LD_INT 1
9827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9828: LD_INT 35
9830: PPUSH
9831: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9835: LD_INT 22
9837: PUSH
9838: LD_INT 1
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: PUSH
9845: LD_INT 21
9847: PUSH
9848: LD_INT 1
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: PPUSH
9859: CALL_OW 69
9863: PUSH
9864: LD_INT 5
9866: PPUSH
9867: LD_INT 22
9869: PUSH
9870: LD_INT 1
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: LD_INT 21
9879: PUSH
9880: LD_INT 1
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: PUSH
9887: EMPTY
9888: LIST
9889: LIST
9890: PPUSH
9891: CALL_OW 70
9895: PUSH
9896: LD_INT 22
9898: PUSH
9899: LD_INT 1
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: LD_INT 55
9908: PUSH
9909: EMPTY
9910: LIST
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PPUSH
9916: CALL_OW 69
9920: PLUS
9921: LESSEQUAL
9922: IFFALSE 9828
// if not player_get_info then
9924: LD_EXP 15
9928: NOT
9929: IFFALSE 9940
// player_get_info := - 1 ;
9931: LD_ADDR_EXP 15
9935: PUSH
9936: LD_INT 1
9938: NEG
9939: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
9940: LD_STRING Information
9942: PPUSH
9943: LD_EXP 15
9947: PPUSH
9948: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9952: LD_ADDR_VAR 0 2
9956: PUSH
9957: LD_INT 22
9959: PUSH
9960: LD_INT 1
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: LD_INT 2
9969: PUSH
9970: LD_INT 25
9972: PUSH
9973: LD_INT 2
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 16
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 34
9992: PUSH
9993: LD_INT 12
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PPUSH
10010: CALL_OW 69
10014: ST_TO_ADDR
// sib := GetTerminalCargo ;
10015: LD_ADDR_VAR 0 3
10019: PUSH
10020: CALL 784 0 0
10024: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10025: LD_ADDR_VAR 0 3
10029: PUSH
10030: LD_VAR 0 3
10034: PUSH
10035: LD_INT 6
10037: PPUSH
10038: LD_INT 3
10040: PPUSH
10041: CALL_OW 287
10045: PLUS
10046: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10047: LD_ADDR_VAR 0 3
10051: PUSH
10052: LD_VAR 0 3
10056: PUSH
10057: LD_VAR 0 2
10061: PPUSH
10062: LD_INT 3
10064: PPUSH
10065: CALL_OW 289
10069: PLUS
10070: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10071: LD_VAR 0 3
10075: PUSH
10076: LD_INT 2
10078: PUSH
10079: LD_OWVAR 67
10083: PLUS
10084: PUSH
10085: LD_INT 50
10087: MUL
10088: LESS
10089: IFFALSE 10114
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10091: LD_STRING MuchSiberite
10093: PPUSH
10094: LD_INT 2
10096: NEG
10097: PUSH
10098: LD_OWVAR 67
10102: MUL
10103: PUSH
10104: LD_INT 1
10106: PLUS
10107: PPUSH
10108: CALL_OW 101
10112: GO 10124
// AddMedal ( MuchSiberite , 1 ) ;
10114: LD_STRING MuchSiberite
10116: PPUSH
10117: LD_INT 1
10119: PPUSH
10120: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10124: LD_INT 22
10126: PUSH
10127: LD_INT 1
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PUSH
10134: LD_INT 2
10136: PUSH
10137: LD_INT 25
10139: PUSH
10140: LD_INT 1
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: PUSH
10147: LD_INT 25
10149: PUSH
10150: LD_INT 2
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: PUSH
10157: LD_INT 25
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 25
10169: PUSH
10170: LD_INT 4
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: PUSH
10177: LD_INT 25
10179: PUSH
10180: LD_INT 8
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PPUSH
10199: CALL_OW 69
10203: PPUSH
10204: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10208: LD_ADDR_VAR 0 2
10212: PUSH
10213: LD_INT 22
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 25
10225: PUSH
10226: LD_INT 8
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: PPUSH
10237: CALL_OW 69
10241: ST_TO_ADDR
// if tmp then
10242: LD_VAR 0 2
10246: IFFALSE 10277
// for i in tmp do
10248: LD_ADDR_VAR 0 1
10252: PUSH
10253: LD_VAR 0 2
10257: PUSH
10258: FOR_IN
10259: IFFALSE 10275
// SetClass ( i , 1 ) ;
10261: LD_VAR 0 1
10265: PPUSH
10266: LD_INT 1
10268: PPUSH
10269: CALL_OW 336
10273: GO 10258
10275: POP
10276: POP
// SaveVariable ( sib , 09_sibRes ) ;
10277: LD_VAR 0 3
10281: PPUSH
10282: LD_STRING 09_sibRes
10284: PPUSH
10285: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10289: LD_EXP 15
10293: PPUSH
10294: LD_STRING 09_arInfo
10296: PPUSH
10297: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10301: LD_EXP 18
10305: PPUSH
10306: LD_EXP 1
10310: PUSH
10311: LD_STRING JMM
10313: STR
10314: PPUSH
10315: CALL_OW 38
// if IsLive ( Gary ) then
10319: LD_EXP 19
10323: PPUSH
10324: CALL_OW 300
10328: IFFALSE 10348
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10330: LD_EXP 19
10334: PPUSH
10335: LD_EXP 1
10339: PUSH
10340: LD_STRING Gary
10342: STR
10343: PPUSH
10344: CALL_OW 38
// if IsLive ( Bobby ) then
10348: LD_EXP 20
10352: PPUSH
10353: CALL_OW 300
10357: IFFALSE 10377
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10359: LD_EXP 20
10363: PPUSH
10364: LD_EXP 1
10368: PUSH
10369: LD_STRING Bobby
10371: STR
10372: PPUSH
10373: CALL_OW 38
// if IsLive ( Cyrus ) then
10377: LD_EXP 21
10381: PPUSH
10382: CALL_OW 300
10386: IFFALSE 10406
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10388: LD_EXP 21
10392: PPUSH
10393: LD_EXP 1
10397: PUSH
10398: LD_STRING Cyrus
10400: STR
10401: PPUSH
10402: CALL_OW 38
// if IsLive ( Houten ) then
10406: LD_EXP 22
10410: PPUSH
10411: CALL_OW 300
10415: IFFALSE 10435
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10417: LD_EXP 22
10421: PPUSH
10422: LD_EXP 1
10426: PUSH
10427: LD_STRING Houten
10429: STR
10430: PPUSH
10431: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10435: LD_ADDR_VAR 0 2
10439: PUSH
10440: LD_INT 22
10442: PUSH
10443: LD_INT 1
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 2
10452: PUSH
10453: LD_INT 25
10455: PUSH
10456: LD_INT 1
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PUSH
10463: LD_INT 25
10465: PUSH
10466: LD_INT 2
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: PUSH
10473: LD_INT 25
10475: PUSH
10476: LD_INT 3
10478: PUSH
10479: EMPTY
10480: LIST
10481: LIST
10482: PUSH
10483: LD_INT 25
10485: PUSH
10486: LD_INT 4
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: PUSH
10493: EMPTY
10494: LIST
10495: LIST
10496: LIST
10497: LIST
10498: LIST
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PPUSH
10504: CALL_OW 69
10508: ST_TO_ADDR
// if tmp then
10509: LD_VAR 0 2
10513: IFFALSE 10533
// SaveCharacters ( tmp , mission_prefix & others ) ;
10515: LD_VAR 0 2
10519: PPUSH
10520: LD_EXP 1
10524: PUSH
10525: LD_STRING others
10527: STR
10528: PPUSH
10529: CALL_OW 38
// YouWin ;
10533: CALL_OW 103
// end ; end_of_file
10537: PPOPN 3
10539: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10540: LD_VAR 0 1
10544: PPUSH
10545: CALL_OW 266
10549: PUSH
10550: LD_INT 0
10552: EQUAL
10553: PUSH
10554: LD_EXP 3
10558: NOT
10559: AND
10560: IFFALSE 10584
// begin terminal := b ;
10562: LD_ADDR_EXP 3
10566: PUSH
10567: LD_VAR 0 1
10571: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10572: LD_EXP 3
10576: PPUSH
10577: LD_STRING terminal
10579: PPUSH
10580: CALL_OW 500
// end ; end ;
10584: PPOPN 2
10586: END
// on BuildingComplete ( b ) do var i ;
10587: LD_INT 0
10589: PPUSH
// begin if GetSide ( b ) = 3 then
10590: LD_VAR 0 1
10594: PPUSH
10595: CALL_OW 255
10599: PUSH
10600: LD_INT 3
10602: EQUAL
10603: IFFALSE 10643
// for i = 1 to 4 do
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: DOUBLE
10611: LD_INT 1
10613: DEC
10614: ST_TO_ADDR
10615: LD_INT 4
10617: PUSH
10618: FOR_TO
10619: IFFALSE 10641
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10621: LD_ADDR_EXP 35
10625: PUSH
10626: LD_EXP 35
10630: PPUSH
10631: LD_INT 1
10633: PPUSH
10634: CALL_OW 3
10638: ST_TO_ADDR
10639: GO 10618
10641: POP
10642: POP
// end ;
10643: PPOPN 2
10645: END
// on VehicleConstructed ( veh , fac ) do var i ;
10646: LD_INT 0
10648: PPUSH
// begin if GetSide ( veh ) = 3 then
10649: LD_VAR 0 1
10653: PPUSH
10654: CALL_OW 255
10658: PUSH
10659: LD_INT 3
10661: EQUAL
10662: IFFALSE 10787
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 264
10673: PUSH
10674: LD_INT 53
10676: PUSH
10677: LD_INT 52
10679: PUSH
10680: LD_INT 51
10682: PUSH
10683: EMPTY
10684: LIST
10685: LIST
10686: LIST
10687: IN
10688: NOT
10689: IFFALSE 10707
// ru_force := ru_force ^ veh ;
10691: LD_ADDR_EXP 34
10695: PUSH
10696: LD_EXP 34
10700: PUSH
10701: LD_VAR 0 1
10705: ADD
10706: ST_TO_ADDR
// for i = 1 to 4 do
10707: LD_ADDR_VAR 0 3
10711: PUSH
10712: DOUBLE
10713: LD_INT 1
10715: DEC
10716: ST_TO_ADDR
10717: LD_INT 4
10719: PUSH
10720: FOR_TO
10721: IFFALSE 10743
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10723: LD_ADDR_EXP 36
10727: PUSH
10728: LD_EXP 36
10732: PPUSH
10733: LD_INT 1
10735: PPUSH
10736: CALL_OW 3
10740: ST_TO_ADDR
10741: GO 10720
10743: POP
10744: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10745: LD_VAR 0 1
10749: PPUSH
10750: CALL_OW 264
10754: PUSH
10755: LD_INT 53
10757: EQUAL
10758: IFFALSE 10787
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10760: LD_VAR 0 1
10764: PPUSH
10765: LD_INT 7
10767: PPUSH
10768: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_INT 170
10779: PPUSH
10780: LD_INT 235
10782: PPUSH
10783: CALL_OW 171
// end ; end ; end ;
10787: PPOPN 3
10789: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10790: LD_VAR 0 1
10794: PUSH
10795: LD_INT 1
10797: EQUAL
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_INT 2
10806: EQUAL
10807: AND
10808: PUSH
10809: LD_VAR 0 1
10813: PUSH
10814: LD_INT 2
10816: EQUAL
10817: PUSH
10818: LD_VAR 0 2
10822: PUSH
10823: LD_INT 1
10825: EQUAL
10826: AND
10827: OR
10828: IFFALSE 10838
// player_attacked_ar := true ;
10830: LD_ADDR_EXP 16
10834: PUSH
10835: LD_INT 1
10837: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
10838: LD_VAR 0 1
10842: PUSH
10843: LD_INT 1
10845: EQUAL
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 4
10854: EQUAL
10855: AND
10856: PUSH
10857: LD_VAR 0 1
10861: PUSH
10862: LD_INT 4
10864: EQUAL
10865: PUSH
10866: LD_VAR 0 2
10870: PUSH
10871: LD_INT 1
10873: EQUAL
10874: AND
10875: OR
10876: IFFALSE 10885
// YouLost ( Traitor ) ;
10878: LD_STRING Traitor
10880: PPUSH
10881: CALL_OW 104
// end ;
10885: PPOPN 2
10887: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10888: LD_VAR 0 1
10892: PUSH
10893: LD_EXP 18
10897: EQUAL
10898: IFFALSE 10907
// YouLost ( JMM ) ;
10900: LD_STRING JMM
10902: PPUSH
10903: CALL_OW 104
// if un = terminal then
10907: LD_VAR 0 1
10911: PUSH
10912: LD_EXP 3
10916: EQUAL
10917: IFFALSE 10926
// YouLost ( Terminal ) ;
10919: LD_STRING Terminal
10921: PPUSH
10922: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10926: LD_VAR 0 1
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 3
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PUSH
10941: LD_INT 21
10943: PUSH
10944: LD_INT 3
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: PPUSH
10955: CALL_OW 69
10959: IN
10960: IFFALSE 11106
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10962: LD_VAR 0 1
10966: PPUSH
10967: CALL_OW 266
10971: PUSH
10972: LD_INT 33
10974: PUSH
10975: LD_INT 26
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: IN
10982: IFFALSE 11041
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10984: LD_ADDR_EXP 35
10988: PUSH
10989: LD_EXP 35
10993: PUSH
10994: LD_VAR 0 1
10998: PPUSH
10999: CALL_OW 266
11003: PUSH
11004: LD_VAR 0 1
11008: PPUSH
11009: CALL_OW 250
11013: PUSH
11014: LD_VAR 0 1
11018: PPUSH
11019: CALL_OW 251
11023: PUSH
11024: LD_VAR 0 1
11028: PPUSH
11029: CALL_OW 254
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: ADD
11040: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11041: LD_VAR 0 1
11045: PPUSH
11046: CALL_OW 266
11050: PUSH
11051: LD_INT 5
11053: EQUAL
11054: IFFALSE 11106
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11056: LD_ADDR_EXP 35
11060: PUSH
11061: LD_EXP 35
11065: PUSH
11066: LD_INT 4
11068: PUSH
11069: LD_VAR 0 1
11073: PPUSH
11074: CALL_OW 250
11078: PUSH
11079: LD_VAR 0 1
11083: PPUSH
11084: CALL_OW 251
11088: PUSH
11089: LD_VAR 0 1
11093: PPUSH
11094: CALL_OW 254
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: ADD
11105: ST_TO_ADDR
// end ; if un in ru_force then
11106: LD_VAR 0 1
11110: PUSH
11111: LD_EXP 34
11115: IN
11116: IFFALSE 11151
// begin ru_force := ru_force diff un ;
11118: LD_ADDR_EXP 34
11122: PUSH
11123: LD_EXP 34
11127: PUSH
11128: LD_VAR 0 1
11132: DIFF
11133: ST_TO_ADDR
// if ru_force = [ ] then
11134: LD_EXP 34
11138: PUSH
11139: EMPTY
11140: EQUAL
11141: IFFALSE 11151
// ru_can_attack := false ;
11143: LD_ADDR_EXP 8
11147: PUSH
11148: LD_INT 0
11150: ST_TO_ADDR
// end ; end ; end_of_file
11151: PPOPN 1
11153: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11154: LD_EXP 5
11158: PUSH
11159: LD_EXP 6
11163: AND
11164: IFFALSE 11242
11166: GO 11168
11168: DISABLE
11169: LD_INT 0
11171: PPUSH
// begin enable ;
11172: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11173: LD_ADDR_VAR 0 1
11177: PUSH
11178: LD_INT 60
11180: PUSH
11181: CALL 784 0 0
11185: MINUS
11186: ST_TO_ADDR
// if sib < 0 then
11187: LD_VAR 0 1
11191: PUSH
11192: LD_INT 0
11194: LESS
11195: IFFALSE 11205
// sib := 0 ;
11197: LD_ADDR_VAR 0 1
11201: PUSH
11202: LD_INT 0
11204: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11205: LD_ADDR_OWVAR 47
11209: PUSH
11210: LD_STRING #Am09-1
11212: PUSH
11213: LD_VAR 0 1
11217: PUSH
11218: LD_EXP 6
11222: PUSH
11223: EMPTY
11224: LIST
11225: LIST
11226: LIST
11227: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11228: LD_ADDR_EXP 6
11232: PUSH
11233: LD_EXP 6
11237: PUSH
11238: LD_INT 35
11240: MINUS
11241: ST_TO_ADDR
// end ;
11242: PPOPN 1
11244: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11245: LD_EXP 6
11249: PUSH
11250: LD_INT 0
11252: EQUAL
11253: IFFALSE 11265
11255: GO 11257
11257: DISABLE
// display_strings := [ ] ;
11258: LD_ADDR_OWVAR 47
11262: PUSH
11263: EMPTY
11264: ST_TO_ADDR
11265: END
// every 0 0$01 trigger ru_force and debug do
11266: LD_EXP 34
11270: PUSH
11271: LD_EXP 2
11275: AND
11276: IFFALSE 11292
11278: GO 11280
11280: DISABLE
// begin enable ;
11281: ENABLE
// display_strings := ru_force ;
11282: LD_ADDR_OWVAR 47
11286: PUSH
11287: LD_EXP 34
11291: ST_TO_ADDR
// end ;
11292: END
// every 1 1$35 do var i , tmp ;
11293: GO 11295
11295: DISABLE
11296: LD_INT 0
11298: PPUSH
11299: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11300: LD_ADDR_VAR 0 2
11304: PUSH
11305: LD_INT 1155
11307: PUSH
11308: LD_INT 1225
11310: PUSH
11311: LD_INT 1435
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: LIST
11318: PUSH
11319: LD_OWVAR 67
11323: ARRAY
11324: ST_TO_ADDR
// i := 0 ;
11325: LD_ADDR_VAR 0 1
11329: PUSH
11330: LD_INT 0
11332: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11333: LD_INT 1
11335: PPUSH
11336: LD_INT 5
11338: PPUSH
11339: CALL_OW 12
11343: PPUSH
11344: LD_INT 75
11346: PPUSH
11347: LD_INT 75
11349: PPUSH
11350: LD_INT 20
11352: PPUSH
11353: LD_INT 1
11355: PPUSH
11356: CALL_OW 56
// wait ( tmp ) ;
11360: LD_VAR 0 2
11364: PPUSH
11365: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11369: LD_ADDR_VAR 0 2
11373: PUSH
11374: LD_VAR 0 2
11378: PUSH
11379: LD_INT 105
11381: PPUSH
11382: LD_INT 315
11384: PPUSH
11385: CALL_OW 12
11389: PLUS
11390: ST_TO_ADDR
// i := i + 1 ;
11391: LD_ADDR_VAR 0 1
11395: PUSH
11396: LD_VAR 0 1
11400: PUSH
11401: LD_INT 1
11403: PLUS
11404: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11405: LD_VAR 0 1
11409: PUSH
11410: LD_INT 3
11412: MOD
11413: PUSH
11414: LD_INT 0
11416: EQUAL
11417: PUSH
11418: LD_EXP 4
11422: AND
11423: IFFALSE 11461
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11425: LD_INT 2
11427: PPUSH
11428: LD_INT 5
11430: PPUSH
11431: CALL_OW 12
11435: PPUSH
11436: LD_INT 8
11438: PPUSH
11439: LD_INT 1
11441: PPUSH
11442: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11446: LD_INT 665
11448: PPUSH
11449: LD_INT 735
11451: PPUSH
11452: CALL_OW 12
11456: PPUSH
11457: CALL_OW 67
// end ; until tick > game_time ;
11461: LD_OWVAR 1
11465: PUSH
11466: LD_EXP 7
11470: GREATER
11471: IFFALSE 11333
// end ; end_of_file
11473: PPOPN 2
11475: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11476: LD_INT 0
11478: PPUSH
11479: PPUSH
11480: PPUSH
11481: PPUSH
11482: PPUSH
11483: PPUSH
// x := 76 ;
11484: LD_ADDR_VAR 0 5
11488: PUSH
11489: LD_INT 76
11491: ST_TO_ADDR
// y := 147 ;
11492: LD_ADDR_VAR 0 6
11496: PUSH
11497: LD_INT 147
11499: ST_TO_ADDR
// uc_side := 2 ;
11500: LD_ADDR_OWVAR 20
11504: PUSH
11505: LD_INT 2
11507: ST_TO_ADDR
// uc_nation := 2 ;
11508: LD_ADDR_OWVAR 21
11512: PUSH
11513: LD_INT 2
11515: ST_TO_ADDR
// InitHc ;
11516: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11520: LD_INT 1
11522: PPUSH
11523: LD_INT 1
11525: PPUSH
11526: LD_INT 6
11528: PPUSH
11529: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11533: LD_ADDR_OWVAR 26
11537: PUSH
11538: LD_STRING Nicolas Vervecken
11540: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11541: LD_ADDR_OWVAR 33
11545: PUSH
11546: LD_STRING SecondCharsGal
11548: ST_TO_ADDR
// hc_face_number := 3 ;
11549: LD_ADDR_OWVAR 34
11553: PUSH
11554: LD_INT 3
11556: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11557: LD_ADDR_OWVAR 29
11561: PUSH
11562: LD_INT 11
11564: PUSH
11565: LD_INT 10
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: ST_TO_ADDR
// Vervecken := CreateHuman ;
11572: LD_ADDR_EXP 26
11576: PUSH
11577: CALL_OW 44
11581: ST_TO_ADDR
// ar_force := Vervecken ;
11582: LD_ADDR_EXP 33
11586: PUSH
11587: LD_EXP 26
11591: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11592: LD_INT 1
11594: PPUSH
11595: LD_INT 2
11597: PPUSH
11598: LD_INT 6
11600: PPUSH
11601: CALL_OW 380
// hc_name := Louis Gali ;
11605: LD_ADDR_OWVAR 26
11609: PUSH
11610: LD_STRING Louis Gali
11612: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11613: LD_ADDR_OWVAR 33
11617: PUSH
11618: LD_STRING SecondCharsGal
11620: ST_TO_ADDR
// hc_face_number := 2 ;
11621: LD_ADDR_OWVAR 34
11625: PUSH
11626: LD_INT 2
11628: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11629: LD_ADDR_OWVAR 29
11633: PUSH
11634: LD_INT 10
11636: PUSH
11637: LD_INT 11
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: ST_TO_ADDR
// Gali := CreateHuman ;
11644: LD_ADDR_EXP 27
11648: PUSH
11649: CALL_OW 44
11653: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11654: LD_ADDR_EXP 33
11658: PUSH
11659: LD_EXP 33
11663: PUSH
11664: LD_EXP 27
11668: ADD
11669: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11670: LD_INT 2
11672: PPUSH
11673: LD_INT 1
11675: PPUSH
11676: LD_INT 6
11678: PPUSH
11679: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11683: LD_ADDR_OWVAR 26
11687: PUSH
11688: LD_STRING Maria Bogdanovic
11690: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11691: LD_ADDR_OWVAR 33
11695: PUSH
11696: LD_STRING SecondCharsGal
11698: ST_TO_ADDR
// hc_face_number := 14 ;
11699: LD_ADDR_OWVAR 34
11703: PUSH
11704: LD_INT 14
11706: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11707: LD_ADDR_OWVAR 29
11711: PUSH
11712: LD_INT 12
11714: PUSH
11715: LD_INT 9
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11722: LD_ADDR_EXP 28
11726: PUSH
11727: CALL_OW 44
11731: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11732: LD_ADDR_EXP 33
11736: PUSH
11737: LD_EXP 33
11741: PUSH
11742: LD_EXP 28
11746: ADD
11747: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11748: LD_INT 1
11750: PPUSH
11751: LD_INT 3
11753: PPUSH
11754: LD_INT 6
11756: PPUSH
11757: CALL_OW 380
// hc_name = Kntor Radomr ;
11761: LD_ADDR_OWVAR 26
11765: PUSH
11766: LD_STRING Kntor Radomr
11768: ST_TO_ADDR
// hc_gallery = sandar ;
11769: LD_ADDR_OWVAR 33
11773: PUSH
11774: LD_STRING sandar
11776: ST_TO_ADDR
// hc_face_number = 12 ;
11777: LD_ADDR_OWVAR 34
11781: PUSH
11782: LD_INT 12
11784: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11785: LD_ADDR_OWVAR 29
11789: PUSH
11790: LD_INT 9
11792: PUSH
11793: LD_INT 9
11795: PUSH
11796: EMPTY
11797: LIST
11798: LIST
11799: ST_TO_ADDR
// Kantor = CreateHuman ;
11800: LD_ADDR_EXP 29
11804: PUSH
11805: CALL_OW 44
11809: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11810: LD_ADDR_EXP 33
11814: PUSH
11815: LD_EXP 33
11819: PUSH
11820: LD_EXP 29
11824: ADD
11825: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11826: LD_INT 1
11828: PPUSH
11829: LD_INT 3
11831: PPUSH
11832: LD_INT 6
11834: PPUSH
11835: CALL_OW 380
// hc_name = Herczeg Farkas ;
11839: LD_ADDR_OWVAR 26
11843: PUSH
11844: LD_STRING Herczeg Farkas
11846: ST_TO_ADDR
// hc_gallery = sandar ;
11847: LD_ADDR_OWVAR 33
11851: PUSH
11852: LD_STRING sandar
11854: ST_TO_ADDR
// hc_face_number = 28 ;
11855: LD_ADDR_OWVAR 34
11859: PUSH
11860: LD_INT 28
11862: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11863: LD_ADDR_OWVAR 29
11867: PUSH
11868: LD_INT 10
11870: PUSH
11871: LD_INT 9
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: ST_TO_ADDR
// Herczeg = CreateHuman ;
11878: LD_ADDR_EXP 30
11882: PUSH
11883: CALL_OW 44
11887: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11888: LD_ADDR_EXP 33
11892: PUSH
11893: LD_EXP 33
11897: PUSH
11898: LD_EXP 30
11902: ADD
11903: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11904: LD_INT 1
11906: PPUSH
11907: LD_INT 1
11909: PPUSH
11910: LD_INT 6
11912: PPUSH
11913: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11917: LD_ADDR_OWVAR 26
11921: PUSH
11922: LD_STRING Ronn Horntvedt
11924: ST_TO_ADDR
// hc_gallery = sandar ;
11925: LD_ADDR_OWVAR 33
11929: PUSH
11930: LD_STRING sandar
11932: ST_TO_ADDR
// hc_face_number = 29 ;
11933: LD_ADDR_OWVAR 34
11937: PUSH
11938: LD_INT 29
11940: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11941: LD_ADDR_OWVAR 29
11945: PUSH
11946: LD_INT 11
11948: PUSH
11949: LD_INT 11
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: ST_TO_ADDR
// Ronn = CreateHuman ;
11956: LD_ADDR_EXP 31
11960: PUSH
11961: CALL_OW 44
11965: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11966: LD_ADDR_EXP 33
11970: PUSH
11971: LD_EXP 33
11975: PUSH
11976: LD_EXP 31
11980: ADD
11981: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11982: LD_INT 2
11984: PPUSH
11985: LD_INT 3
11987: PPUSH
11988: LD_INT 6
11990: PPUSH
11991: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11995: LD_ADDR_OWVAR 26
11999: PUSH
12000: LD_STRING Mia D. Mathiasen
12002: ST_TO_ADDR
// hc_gallery = sandar ;
12003: LD_ADDR_OWVAR 33
12007: PUSH
12008: LD_STRING sandar
12010: ST_TO_ADDR
// hc_face_number = 31 ;
12011: LD_ADDR_OWVAR 34
12015: PUSH
12016: LD_INT 31
12018: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12019: LD_ADDR_OWVAR 29
12023: PUSH
12024: LD_INT 10
12026: PUSH
12027: LD_INT 10
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: ST_TO_ADDR
// Mia = CreateHuman ;
12034: LD_ADDR_EXP 32
12038: PUSH
12039: CALL_OW 44
12043: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12044: LD_ADDR_EXP 33
12048: PUSH
12049: LD_EXP 33
12053: PUSH
12054: LD_EXP 32
12058: ADD
12059: ST_TO_ADDR
// for i = 1 to 2 do
12060: LD_ADDR_VAR 0 4
12064: PUSH
12065: DOUBLE
12066: LD_INT 1
12068: DEC
12069: ST_TO_ADDR
12070: LD_INT 2
12072: PUSH
12073: FOR_TO
12074: IFFALSE 12115
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12076: LD_ADDR_VAR 0 3
12080: PUSH
12081: LD_VAR 0 3
12085: PUSH
12086: LD_INT 2
12088: PPUSH
12089: LD_INT 2
12091: PPUSH
12092: LD_INT 14
12094: PPUSH
12095: LD_INT 1
12097: PPUSH
12098: LD_INT 1
12100: PPUSH
12101: LD_INT 32
12103: PPUSH
12104: LD_INT 30
12106: PPUSH
12107: CALL 264 0 7
12111: ADD
12112: ST_TO_ADDR
12113: GO 12073
12115: POP
12116: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12117: LD_ADDR_VAR 0 3
12121: PUSH
12122: LD_VAR 0 3
12126: PUSH
12127: LD_INT 2
12129: PPUSH
12130: LD_INT 2
12132: PPUSH
12133: LD_INT 14
12135: PPUSH
12136: LD_INT 1
12138: PPUSH
12139: LD_INT 1
12141: PPUSH
12142: LD_INT 26
12144: PPUSH
12145: LD_INT 33
12147: PPUSH
12148: CALL 264 0 7
12152: ADD
12153: ST_TO_ADDR
// tmp := tmp diff 0 ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: LD_VAR 0 3
12163: PUSH
12164: LD_INT 0
12166: DIFF
12167: ST_TO_ADDR
// for i in ar_force do
12168: LD_ADDR_VAR 0 4
12172: PUSH
12173: LD_EXP 33
12177: PUSH
12178: FOR_IN
12179: IFFALSE 12322
// begin if GetClass ( i ) = 3 then
12181: LD_VAR 0 4
12185: PPUSH
12186: CALL_OW 257
12190: PUSH
12191: LD_INT 3
12193: EQUAL
12194: IFFALSE 12276
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12196: LD_VAR 0 3
12200: PUSH
12201: LD_INT 1
12203: ARRAY
12204: PPUSH
12205: LD_INT 1
12207: PPUSH
12208: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12212: LD_VAR 0 3
12216: PUSH
12217: LD_INT 1
12219: ARRAY
12220: PPUSH
12221: LD_VAR 0 5
12225: PPUSH
12226: LD_VAR 0 6
12230: PPUSH
12231: LD_INT 0
12233: PPUSH
12234: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12238: LD_VAR 0 4
12242: PPUSH
12243: LD_VAR 0 3
12247: PUSH
12248: LD_INT 1
12250: ARRAY
12251: PPUSH
12252: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12256: LD_ADDR_VAR 0 3
12260: PUSH
12261: LD_VAR 0 3
12265: PPUSH
12266: LD_INT 1
12268: PPUSH
12269: CALL_OW 3
12273: ST_TO_ADDR
// end else
12274: GO 12298
// PlaceUnitXY ( i , x , y , false ) ;
12276: LD_VAR 0 4
12280: PPUSH
12281: LD_VAR 0 5
12285: PPUSH
12286: LD_VAR 0 6
12290: PPUSH
12291: LD_INT 0
12293: PPUSH
12294: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12298: LD_VAR 0 4
12302: PPUSH
12303: LD_INT 86
12305: PPUSH
12306: LD_INT 121
12308: PPUSH
12309: CALL_OW 111
// wait ( 0 0$2 ) ;
12313: LD_INT 70
12315: PPUSH
12316: CALL_OW 67
// end ;
12320: GO 12178
12322: POP
12323: POP
// ar_force := ar_force ^ tmp ;
12324: LD_ADDR_EXP 33
12328: PUSH
12329: LD_EXP 33
12333: PUSH
12334: LD_VAR 0 3
12338: ADD
12339: ST_TO_ADDR
// ar_spawned := true ;
12340: LD_ADDR_EXP 11
12344: PUSH
12345: LD_INT 1
12347: ST_TO_ADDR
// end ; end_of_file
12348: LD_VAR 0 1
12352: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12353: LD_INT 0
12355: PPUSH
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
12360: PPUSH
12361: PPUSH
// InitHc ;
12362: CALL_OW 19
// uc_side := 3 ;
12366: LD_ADDR_OWVAR 20
12370: PUSH
12371: LD_INT 3
12373: ST_TO_ADDR
// uc_nation := 3 ;
12374: LD_ADDR_OWVAR 21
12378: PUSH
12379: LD_INT 3
12381: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12382: LD_ADDR_VAR 0 5
12386: PUSH
12387: LD_INT 5
12389: PUSH
12390: LD_INT 6
12392: PUSH
12393: LD_INT 7
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: LIST
12400: PUSH
12401: LD_OWVAR 67
12405: ARRAY
12406: ST_TO_ADDR
// ru_force := [ ] ;
12407: LD_ADDR_EXP 34
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// ru_rebuild := [ ] ;
12414: LD_ADDR_EXP 35
12418: PUSH
12419: EMPTY
12420: ST_TO_ADDR
// ru_produce_list := [ ] ;
12421: LD_ADDR_EXP 36
12425: PUSH
12426: EMPTY
12427: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12428: LD_ADDR_VAR 0 6
12432: PUSH
12433: LD_INT 22
12435: PUSH
12436: LD_INT 3
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: PUSH
12443: LD_INT 30
12445: PUSH
12446: LD_INT 8
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PPUSH
12457: CALL_OW 69
12461: PUSH
12462: LD_INT 1
12464: ARRAY
12465: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12466: LD_ADDR_VAR 0 4
12470: PUSH
12471: LD_INT 43
12473: PUSH
12474: LD_INT 46
12476: PUSH
12477: LD_INT 45
12479: PUSH
12480: EMPTY
12481: LIST
12482: LIST
12483: LIST
12484: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12485: LD_ADDR_VAR 0 7
12489: PUSH
12490: LD_INT 22
12492: PUSH
12493: LD_INT 3
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: LD_INT 30
12502: PUSH
12503: LD_INT 1
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PPUSH
12514: CALL_OW 69
12518: PUSH
12519: LD_INT 1
12521: ARRAY
12522: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12523: LD_VAR 0 7
12527: PPUSH
12528: CALL_OW 274
12532: PPUSH
12533: LD_INT 1
12535: PPUSH
12536: LD_INT 5000
12538: PPUSH
12539: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12543: LD_VAR 0 7
12547: PPUSH
12548: CALL_OW 274
12552: PPUSH
12553: LD_INT 2
12555: PPUSH
12556: LD_INT 1000
12558: PPUSH
12559: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12563: LD_VAR 0 7
12567: PPUSH
12568: CALL_OW 274
12572: PPUSH
12573: LD_INT 3
12575: PPUSH
12576: LD_INT 30
12578: PPUSH
12579: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12583: LD_ADDR_VAR 0 2
12587: PUSH
12588: LD_INT 22
12590: PUSH
12591: LD_INT 3
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PUSH
12598: LD_INT 30
12600: PUSH
12601: LD_INT 33
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PPUSH
12612: CALL_OW 69
12616: PUSH
12617: FOR_IN
12618: IFFALSE 12650
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12620: LD_VAR 0 2
12624: PPUSH
12625: LD_VAR 0 4
12629: PUSH
12630: LD_VAR 0 2
12634: PUSH
12635: LD_INT 3
12637: MOD
12638: PUSH
12639: LD_INT 1
12641: PLUS
12642: ARRAY
12643: PPUSH
12644: CALL_OW 431
// end ;
12648: GO 12617
12650: POP
12651: POP
// for i = 1 to 4 do
12652: LD_ADDR_VAR 0 2
12656: PUSH
12657: DOUBLE
12658: LD_INT 1
12660: DEC
12661: ST_TO_ADDR
12662: LD_INT 4
12664: PUSH
12665: FOR_TO
12666: IFFALSE 12727
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12668: LD_INT 0
12670: PPUSH
12671: LD_INT 9
12673: PPUSH
12674: LD_VAR 0 5
12678: PPUSH
12679: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12683: CALL_OW 44
12687: PPUSH
12688: LD_INT 22
12690: PUSH
12691: LD_INT 3
12693: PUSH
12694: EMPTY
12695: LIST
12696: LIST
12697: PUSH
12698: LD_INT 30
12700: PUSH
12701: LD_INT 5
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: PUSH
12708: EMPTY
12709: LIST
12710: LIST
12711: PPUSH
12712: CALL_OW 69
12716: PUSH
12717: LD_INT 1
12719: ARRAY
12720: PPUSH
12721: CALL_OW 52
// end ;
12725: GO 12665
12727: POP
12728: POP
// for i = 1 to 5 do
12729: LD_ADDR_VAR 0 2
12733: PUSH
12734: DOUBLE
12735: LD_INT 1
12737: DEC
12738: ST_TO_ADDR
12739: LD_INT 5
12741: PUSH
12742: FOR_TO
12743: IFFALSE 12804
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12745: LD_INT 0
12747: PPUSH
12748: LD_INT 3
12750: PPUSH
12751: LD_VAR 0 5
12755: PPUSH
12756: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12760: CALL_OW 44
12764: PPUSH
12765: LD_INT 22
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 30
12777: PUSH
12778: LD_INT 3
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PPUSH
12789: CALL_OW 69
12793: PUSH
12794: LD_INT 1
12796: ARRAY
12797: PPUSH
12798: CALL_OW 52
// end ;
12802: GO 12742
12804: POP
12805: POP
// for i = 1 to 4 do
12806: LD_ADDR_VAR 0 2
12810: PUSH
12811: DOUBLE
12812: LD_INT 1
12814: DEC
12815: ST_TO_ADDR
12816: LD_INT 4
12818: PUSH
12819: FOR_TO
12820: IFFALSE 12881
// begin PrepareHuman ( false , class_engineer , skill ) ;
12822: LD_INT 0
12824: PPUSH
12825: LD_INT 2
12827: PPUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12837: CALL_OW 44
12841: PPUSH
12842: LD_INT 22
12844: PUSH
12845: LD_INT 3
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: LD_INT 30
12854: PUSH
12855: LD_INT 1
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PPUSH
12866: CALL_OW 69
12870: PUSH
12871: LD_INT 1
12873: ARRAY
12874: PPUSH
12875: CALL_OW 52
// end ;
12879: GO 12819
12881: POP
12882: POP
// for i = 1 to 3 do
12883: LD_ADDR_VAR 0 2
12887: PUSH
12888: DOUBLE
12889: LD_INT 1
12891: DEC
12892: ST_TO_ADDR
12893: LD_INT 3
12895: PUSH
12896: FOR_TO
12897: IFFALSE 12930
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12899: LD_INT 0
12901: PPUSH
12902: LD_INT 4
12904: PPUSH
12905: LD_VAR 0 5
12909: PPUSH
12910: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12914: CALL_OW 44
12918: PPUSH
12919: LD_VAR 0 6
12923: PPUSH
12924: CALL_OW 52
// end ;
12928: GO 12896
12930: POP
12931: POP
// AddComResearch ( lab , tech_tech2 ) ;
12932: LD_VAR 0 6
12936: PPUSH
12937: LD_INT 49
12939: PPUSH
12940: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12944: LD_VAR 0 6
12948: PPUSH
12949: LD_INT 50
12951: PPUSH
12952: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12956: LD_VAR 0 6
12960: PPUSH
12961: LD_INT 51
12963: PPUSH
12964: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12968: LD_VAR 0 6
12972: PPUSH
12973: LD_INT 52
12975: PPUSH
12976: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12980: LD_VAR 0 6
12984: PPUSH
12985: LD_INT 69
12987: PPUSH
12988: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12992: LD_VAR 0 6
12996: PPUSH
12997: LD_INT 39
12999: PPUSH
13000: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13004: LD_VAR 0 6
13008: PPUSH
13009: LD_INT 34
13011: PPUSH
13012: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13016: LD_VAR 0 6
13020: PPUSH
13021: LD_INT 40
13023: PPUSH
13024: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13028: LD_VAR 0 6
13032: PPUSH
13033: LD_INT 57
13035: PPUSH
13036: CALL_OW 184
// if Difficulty > 1 then
13040: LD_OWVAR 67
13044: PUSH
13045: LD_INT 1
13047: GREATER
13048: IFFALSE 13062
// AddComResearch ( lab , tech_comp2 ) ;
13050: LD_VAR 0 6
13054: PPUSH
13055: LD_INT 58
13057: PPUSH
13058: CALL_OW 184
// end ;
13062: LD_VAR 0 1
13066: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13067: LD_INT 7
13069: PPUSH
13070: CALL_OW 353
13074: PUSH
13075: LD_INT 3
13077: GREATER
13078: PUSH
13079: LD_INT 22
13081: PUSH
13082: LD_INT 3
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 34
13091: PUSH
13092: LD_INT 53
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PPUSH
13103: CALL_OW 69
13107: NOT
13108: AND
13109: IFFALSE 13144
13111: GO 13113
13113: DISABLE
// begin enable ;
13114: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13115: LD_ADDR_EXP 36
13119: PUSH
13120: LD_EXP 36
13124: PUSH
13125: LD_INT 24
13127: PUSH
13128: LD_INT 1
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: LD_INT 53
13136: PUSH
13137: EMPTY
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: ADD
13143: ST_TO_ADDR
// end ;
13144: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13145: LD_INT 22
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: LD_INT 21
13157: PUSH
13158: LD_INT 3
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: PPUSH
13169: CALL_OW 69
13173: IFFALSE 13951
13175: GO 13177
13177: DISABLE
13178: LD_INT 0
13180: PPUSH
13181: PPUSH
13182: PPUSH
13183: PPUSH
13184: PPUSH
13185: PPUSH
13186: PPUSH
13187: PPUSH
// begin enable ;
13188: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13189: LD_ADDR_VAR 0 3
13193: PUSH
13194: LD_INT 22
13196: PUSH
13197: LD_INT 3
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: PUSH
13204: LD_INT 21
13206: PUSH
13207: LD_INT 3
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 3
13216: PUSH
13217: LD_INT 24
13219: PUSH
13220: LD_INT 1000
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: PUSH
13227: EMPTY
13228: LIST
13229: LIST
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: LIST
13235: PPUSH
13236: CALL_OW 69
13240: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13241: LD_ADDR_VAR 0 4
13245: PUSH
13246: LD_INT 22
13248: PUSH
13249: LD_INT 3
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: LD_INT 25
13258: PUSH
13259: LD_INT 2
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: PPUSH
13270: CALL_OW 69
13274: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13275: LD_ADDR_VAR 0 5
13279: PUSH
13280: LD_INT 22
13282: PUSH
13283: LD_INT 3
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PUSH
13290: LD_INT 30
13292: PUSH
13293: LD_INT 1
13295: PUSH
13296: EMPTY
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: LIST
13303: PPUSH
13304: CALL_OW 69
13308: PUSH
13309: LD_INT 1
13311: ARRAY
13312: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13313: LD_ADDR_VAR 0 8
13317: PUSH
13318: LD_INT 22
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PUSH
13328: LD_INT 2
13330: PUSH
13331: LD_INT 30
13333: PUSH
13334: LD_INT 6
13336: PUSH
13337: EMPTY
13338: LIST
13339: LIST
13340: PUSH
13341: LD_INT 30
13343: PUSH
13344: LD_INT 7
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: PUSH
13351: LD_INT 30
13353: PUSH
13354: LD_INT 8
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PUSH
13361: EMPTY
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: PPUSH
13371: CALL_OW 69
13375: PUSH
13376: LD_INT 1
13378: ARRAY
13379: ST_TO_ADDR
// if not engs then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13389
// exit ;
13387: GO 13951
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13389: LD_ADDR_VAR 0 6
13393: PUSH
13394: LD_VAR 0 4
13398: PPUSH
13399: LD_INT 3
13401: PUSH
13402: LD_INT 24
13404: PUSH
13405: LD_INT 600
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PPUSH
13416: CALL_OW 72
13420: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13421: LD_ADDR_VAR 0 7
13425: PUSH
13426: LD_INT 22
13428: PUSH
13429: LD_INT 3
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: LD_INT 25
13438: PUSH
13439: LD_INT 4
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PPUSH
13450: CALL_OW 69
13454: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13455: LD_VAR 0 3
13459: NOT
13460: PUSH
13461: LD_EXP 35
13465: NOT
13466: AND
13467: IFFALSE 13527
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13469: LD_VAR 0 4
13473: PPUSH
13474: LD_INT 3
13476: PUSH
13477: LD_INT 54
13479: PUSH
13480: EMPTY
13481: LIST
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: PPUSH
13487: CALL_OW 72
13491: IFFALSE 13525
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13493: LD_VAR 0 4
13497: PPUSH
13498: LD_INT 3
13500: PUSH
13501: LD_INT 54
13503: PUSH
13504: EMPTY
13505: LIST
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PPUSH
13511: CALL_OW 72
13515: PPUSH
13516: LD_VAR 0 5
13520: PPUSH
13521: CALL_OW 120
// exit ;
13525: GO 13951
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13527: LD_VAR 0 4
13531: PPUSH
13532: LD_INT 54
13534: PUSH
13535: EMPTY
13536: LIST
13537: PPUSH
13538: CALL_OW 72
13542: IFFALSE 13564
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13544: LD_VAR 0 4
13548: PPUSH
13549: LD_INT 54
13551: PUSH
13552: EMPTY
13553: LIST
13554: PPUSH
13555: CALL_OW 72
13559: PPUSH
13560: CALL_OW 122
// if not tmp then
13564: LD_VAR 0 3
13568: NOT
13569: IFFALSE 13701
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13571: LD_INT 81
13573: PUSH
13574: LD_INT 3
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: PUSH
13581: LD_INT 92
13583: PUSH
13584: LD_INT 147
13586: PUSH
13587: LD_INT 212
13589: PUSH
13590: LD_INT 30
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: PPUSH
13603: CALL_OW 69
13607: NOT
13608: IFFALSE 13701
// begin if not HasTask ( engs [ 1 ] ) then
13610: LD_VAR 0 4
13614: PUSH
13615: LD_INT 1
13617: ARRAY
13618: PPUSH
13619: CALL_OW 314
13623: NOT
13624: IFFALSE 13701
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13626: LD_ADDR_VAR 0 2
13630: PUSH
13631: LD_VAR 0 4
13635: PPUSH
13636: LD_EXP 35
13640: PUSH
13641: LD_INT 1
13643: ARRAY
13644: PPUSH
13645: LD_EXP 35
13649: PUSH
13650: LD_INT 2
13652: ARRAY
13653: PPUSH
13654: LD_EXP 35
13658: PUSH
13659: LD_INT 3
13661: ARRAY
13662: PPUSH
13663: LD_EXP 35
13667: PUSH
13668: LD_INT 4
13670: ARRAY
13671: PPUSH
13672: CALL_OW 145
13676: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13677: LD_VAR 0 2
13681: PPUSH
13682: CALL_OW 266
13686: PUSH
13687: LD_INT 4
13689: EQUAL
13690: IFFALSE 13701
// AddComUpgrade ( i ) ;
13692: LD_VAR 0 2
13696: PPUSH
13697: CALL_OW 206
// end ; end ; end ; for i in engs do
13701: LD_ADDR_VAR 0 2
13705: PUSH
13706: LD_VAR 0 4
13710: PUSH
13711: FOR_IN
13712: IFFALSE 13830
// begin if i in to_heal and sci then
13714: LD_VAR 0 2
13718: PUSH
13719: LD_VAR 0 6
13723: IN
13724: PUSH
13725: LD_VAR 0 7
13729: AND
13730: IFFALSE 13781
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13732: LD_VAR 0 2
13736: PPUSH
13737: LD_INT 149
13739: PPUSH
13740: LD_INT 220
13742: PPUSH
13743: CALL_OW 297
13747: PUSH
13748: LD_INT 5
13750: LESS
13751: IFFALSE 13755
// continue ;
13753: GO 13711
// ComMoveXY ( i , 149 , 220 ) ;
13755: LD_VAR 0 2
13759: PPUSH
13760: LD_INT 149
13762: PPUSH
13763: LD_INT 220
13765: PPUSH
13766: CALL_OW 111
// AddComHold ( i ) ;
13770: LD_VAR 0 2
13774: PPUSH
13775: CALL_OW 200
// end else
13779: GO 13828
// if not HasTask ( i ) or WantsToAttack ( i ) then
13781: LD_VAR 0 2
13785: PPUSH
13786: CALL_OW 314
13790: NOT
13791: PUSH
13792: LD_VAR 0 2
13796: PPUSH
13797: CALL_OW 319
13801: OR
13802: IFFALSE 13828
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13804: LD_VAR 0 2
13808: PPUSH
13809: LD_VAR 0 3
13813: PPUSH
13814: LD_VAR 0 2
13818: PPUSH
13819: CALL_OW 74
13823: PPUSH
13824: CALL_OW 130
// end ;
13828: GO 13711
13830: POP
13831: POP
// if to_heal and sci then
13832: LD_VAR 0 6
13836: PUSH
13837: LD_VAR 0 7
13841: AND
13842: IFFALSE 13903
// begin if UnitFilter ( sci , [ f_inside ] ) then
13844: LD_VAR 0 7
13848: PPUSH
13849: LD_INT 54
13851: PUSH
13852: EMPTY
13853: LIST
13854: PPUSH
13855: CALL_OW 72
13859: IFFALSE 13883
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13861: LD_VAR 0 7
13865: PPUSH
13866: LD_INT 54
13868: PUSH
13869: EMPTY
13870: LIST
13871: PPUSH
13872: CALL_OW 72
13876: PPUSH
13877: CALL_OW 122
13881: GO 13901
// ComHeal ( sci , to_heal [ 1 ] ) ;
13883: LD_VAR 0 7
13887: PPUSH
13888: LD_VAR 0 6
13892: PUSH
13893: LD_INT 1
13895: ARRAY
13896: PPUSH
13897: CALL_OW 128
// end else
13901: GO 13951
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13903: LD_VAR 0 7
13907: PPUSH
13908: LD_INT 56
13910: PUSH
13911: EMPTY
13912: LIST
13913: PPUSH
13914: CALL_OW 72
13918: PUSH
13919: LD_VAR 0 8
13923: AND
13924: IFFALSE 13951
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13926: LD_VAR 0 7
13930: PPUSH
13931: LD_INT 56
13933: PUSH
13934: EMPTY
13935: LIST
13936: PPUSH
13937: CALL_OW 72
13941: PPUSH
13942: LD_VAR 0 8
13946: PPUSH
13947: CALL_OW 120
// end ;
13951: PPOPN 8
13953: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13954: LD_INT 22
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 30
13966: PUSH
13967: LD_INT 3
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: PPUSH
13978: CALL_OW 69
13982: PUSH
13983: LD_EXP 36
13987: AND
13988: IFFALSE 14114
13990: GO 13992
13992: DISABLE
13993: LD_INT 0
13995: PPUSH
13996: PPUSH
13997: PPUSH
// begin enable ;
13998: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13999: LD_ADDR_VAR 0 3
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 3
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: PUSH
14014: LD_INT 30
14016: PUSH
14017: LD_INT 3
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: PPUSH
14028: CALL_OW 69
14032: PUSH
14033: LD_INT 1
14035: ARRAY
14036: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14037: LD_VAR 0 3
14041: PPUSH
14042: CALL_OW 313
14046: PUSH
14047: LD_INT 0
14049: EQUAL
14050: IFFALSE 14054
// exit ;
14052: GO 14114
// if BuildingStatus ( fac ) = bs_idle then
14054: LD_VAR 0 3
14058: PPUSH
14059: CALL_OW 461
14063: PUSH
14064: LD_INT 2
14066: EQUAL
14067: IFFALSE 14114
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14069: LD_VAR 0 3
14073: PPUSH
14074: LD_EXP 36
14078: PUSH
14079: LD_INT 1
14081: ARRAY
14082: PPUSH
14083: LD_EXP 36
14087: PUSH
14088: LD_INT 2
14090: ARRAY
14091: PPUSH
14092: LD_EXP 36
14096: PUSH
14097: LD_INT 3
14099: ARRAY
14100: PPUSH
14101: LD_EXP 36
14105: PUSH
14106: LD_INT 4
14108: ARRAY
14109: PPUSH
14110: CALL_OW 125
// end ;
14114: PPOPN 3
14116: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14117: LD_INT 0
14119: PPUSH
14120: PPUSH
14121: PPUSH
14122: PPUSH
14123: PPUSH
// uc_side := 3 ;
14124: LD_ADDR_OWVAR 20
14128: PUSH
14129: LD_INT 3
14131: ST_TO_ADDR
// uc_nation := 3 ;
14132: LD_ADDR_OWVAR 21
14136: PUSH
14137: LD_INT 3
14139: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14140: LD_ADDR_VAR 0 6
14144: PUSH
14145: LD_INT 22
14147: PUSH
14148: LD_INT 3
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PUSH
14155: LD_INT 30
14157: PUSH
14158: LD_INT 3
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: PUSH
14165: EMPTY
14166: LIST
14167: LIST
14168: PPUSH
14169: CALL_OW 69
14173: ST_TO_ADDR
// if fac then
14174: LD_VAR 0 6
14178: IFFALSE 14330
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14180: LD_ADDR_EXP 36
14184: PUSH
14185: LD_INT 24
14187: PUSH
14188: LD_INT 1
14190: PUSH
14191: LD_INT 3
14193: PUSH
14194: LD_INT 43
14196: PUSH
14197: EMPTY
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: ST_TO_ADDR
// if wave > 1 then
14203: LD_VAR 0 1
14207: PUSH
14208: LD_INT 1
14210: GREATER
14211: IFFALSE 14264
// for i = 1 to Difficulty do
14213: LD_ADDR_VAR 0 3
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_OWVAR 67
14227: PUSH
14228: FOR_TO
14229: IFFALSE 14262
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14231: LD_ADDR_EXP 36
14235: PUSH
14236: LD_EXP 36
14240: PUSH
14241: LD_INT 24
14243: PUSH
14244: LD_INT 1
14246: PUSH
14247: LD_INT 3
14249: PUSH
14250: LD_INT 45
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: ADD
14259: ST_TO_ADDR
14260: GO 14228
14262: POP
14263: POP
// repeat wait ( 0 0$1 ) ;
14264: LD_INT 35
14266: PPUSH
14267: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14271: LD_EXP 36
14275: PUSH
14276: LD_INT 4
14278: LESS
14279: PUSH
14280: LD_VAR 0 6
14284: PUSH
14285: LD_INT 1
14287: ARRAY
14288: PPUSH
14289: CALL_OW 313
14293: PUSH
14294: LD_INT 0
14296: EQUAL
14297: OR
14298: PUSH
14299: LD_VAR 0 6
14303: PUSH
14304: LD_INT 1
14306: ARRAY
14307: PPUSH
14308: CALL_OW 461
14312: PUSH
14313: LD_INT 8
14315: PUSH
14316: LD_INT 6
14318: PUSH
14319: LD_INT 7
14321: PUSH
14322: EMPTY
14323: LIST
14324: LIST
14325: LIST
14326: IN
14327: OR
14328: IFFALSE 14264
// end ; case wave of 1 :
14330: LD_VAR 0 1
14334: PUSH
14335: LD_INT 1
14337: DOUBLE
14338: EQUAL
14339: IFTRUE 14343
14341: GO 14428
14343: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14344: LD_ADDR_VAR 0 3
14348: PUSH
14349: DOUBLE
14350: LD_INT 1
14352: DEC
14353: ST_TO_ADDR
14354: LD_INT 4
14356: PUSH
14357: LD_INT 5
14359: PUSH
14360: LD_INT 6
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: LIST
14367: PUSH
14368: LD_OWVAR 67
14372: ARRAY
14373: PUSH
14374: FOR_TO
14375: IFFALSE 14383
// Sold ;
14377: CALL 14646 0 0
14381: GO 14374
14383: POP
14384: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14385: LD_ADDR_VAR 0 3
14389: PUSH
14390: DOUBLE
14391: LD_INT 1
14393: DEC
14394: ST_TO_ADDR
14395: LD_INT 2
14397: PUSH
14398: LD_INT 3
14400: PUSH
14401: LD_INT 3
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: LIST
14408: PUSH
14409: LD_OWVAR 67
14413: ARRAY
14414: PUSH
14415: FOR_TO
14416: IFFALSE 14424
// Tank ;
14418: CALL 14776 0 0
14422: GO 14415
14424: POP
14425: POP
// end ; 2 .. 9 :
14426: GO 14641
14428: LD_INT 2
14430: DOUBLE
14431: GREATEREQUAL
14432: IFFALSE 14440
14434: LD_INT 9
14436: DOUBLE
14437: LESSEQUAL
14438: IFTRUE 14442
14440: GO 14547
14442: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: DOUBLE
14449: LD_INT 1
14451: DEC
14452: ST_TO_ADDR
14453: LD_INT 4
14455: PUSH
14456: LD_INT 5
14458: PUSH
14459: LD_INT 6
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: LIST
14466: PUSH
14467: LD_OWVAR 67
14471: ARRAY
14472: PUSH
14473: LD_VAR 0 1
14477: PUSH
14478: LD_INT 2
14480: DIV
14481: PLUS
14482: PUSH
14483: FOR_TO
14484: IFFALSE 14492
// Sold ;
14486: CALL 14646 0 0
14490: GO 14483
14492: POP
14493: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14494: LD_ADDR_VAR 0 3
14498: PUSH
14499: DOUBLE
14500: LD_INT 1
14502: DEC
14503: ST_TO_ADDR
14504: LD_INT 3
14506: PUSH
14507: LD_INT 4
14509: PUSH
14510: LD_INT 4
14512: PUSH
14513: EMPTY
14514: LIST
14515: LIST
14516: LIST
14517: PUSH
14518: LD_OWVAR 67
14522: ARRAY
14523: PUSH
14524: LD_VAR 0 1
14528: PUSH
14529: LD_INT 2
14531: DIV
14532: PLUS
14533: PUSH
14534: FOR_TO
14535: IFFALSE 14543
// Tank ;
14537: CALL 14776 0 0
14541: GO 14534
14543: POP
14544: POP
// end ; 10 :
14545: GO 14641
14547: LD_INT 10
14549: DOUBLE
14550: EQUAL
14551: IFTRUE 14555
14553: GO 14640
14555: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14556: LD_ADDR_VAR 0 3
14560: PUSH
14561: DOUBLE
14562: LD_INT 1
14564: DEC
14565: ST_TO_ADDR
14566: LD_INT 10
14568: PUSH
14569: LD_INT 12
14571: PUSH
14572: LD_INT 14
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: PUSH
14580: LD_OWVAR 67
14584: ARRAY
14585: PUSH
14586: FOR_TO
14587: IFFALSE 14595
// Sold ;
14589: CALL 14646 0 0
14593: GO 14586
14595: POP
14596: POP
// for i = 1 to [ 9 , 11 , 15 ] [ Difficulty ] do
14597: LD_ADDR_VAR 0 3
14601: PUSH
14602: DOUBLE
14603: LD_INT 1
14605: DEC
14606: ST_TO_ADDR
14607: LD_INT 9
14609: PUSH
14610: LD_INT 11
14612: PUSH
14613: LD_INT 15
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: LIST
14620: PUSH
14621: LD_OWVAR 67
14625: ARRAY
14626: PUSH
14627: FOR_TO
14628: IFFALSE 14636
// Tank ;
14630: CALL 14776 0 0
14634: GO 14627
14636: POP
14637: POP
// end ; end ;
14638: GO 14641
14640: POP
// end ;
14641: LD_VAR 0 2
14645: RET
// function Sold ( ) ; var un , skill ; begin
14646: LD_INT 0
14648: PPUSH
14649: PPUSH
14650: PPUSH
// uc_side := 3 ;
14651: LD_ADDR_OWVAR 20
14655: PUSH
14656: LD_INT 3
14658: ST_TO_ADDR
// uc_nation := 3 ;
14659: LD_ADDR_OWVAR 21
14663: PUSH
14664: LD_INT 3
14666: ST_TO_ADDR
// InitHc ;
14667: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14671: LD_ADDR_VAR 0 3
14675: PUSH
14676: LD_INT 6
14678: PUSH
14679: LD_INT 7
14681: PUSH
14682: LD_INT 7
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: PUSH
14690: LD_OWVAR 67
14694: ARRAY
14695: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14696: LD_INT 0
14698: PPUSH
14699: LD_INT 1
14701: PUSH
14702: LD_INT 9
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: PUSH
14709: LD_INT 1
14711: PPUSH
14712: LD_INT 2
14714: PPUSH
14715: CALL_OW 12
14719: ARRAY
14720: PPUSH
14721: LD_VAR 0 3
14725: PPUSH
14726: CALL_OW 380
// un := CreateHuman ;
14730: LD_ADDR_VAR 0 2
14734: PUSH
14735: CALL_OW 44
14739: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14740: LD_VAR 0 2
14744: PPUSH
14745: LD_INT 4
14747: PPUSH
14748: LD_INT 0
14750: PPUSH
14751: CALL_OW 49
// ru_force := ru_force ^ un ;
14755: LD_ADDR_EXP 34
14759: PUSH
14760: LD_EXP 34
14764: PUSH
14765: LD_VAR 0 2
14769: ADD
14770: ST_TO_ADDR
// end ;
14771: LD_VAR 0 1
14775: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14776: LD_INT 0
14778: PPUSH
14779: PPUSH
14780: PPUSH
14781: PPUSH
14782: PPUSH
// uc_side := 3 ;
14783: LD_ADDR_OWVAR 20
14787: PUSH
14788: LD_INT 3
14790: ST_TO_ADDR
// uc_nation := 3 ;
14791: LD_ADDR_OWVAR 21
14795: PUSH
14796: LD_INT 3
14798: ST_TO_ADDR
// InitHc ;
14799: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14803: LD_ADDR_VAR 0 5
14807: PUSH
14808: LD_INT 5
14810: PUSH
14811: LD_INT 6
14813: PUSH
14814: LD_INT 7
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: LIST
14821: PUSH
14822: LD_OWVAR 67
14826: ARRAY
14827: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14828: LD_ADDR_VAR 0 3
14832: PUSH
14833: LD_INT 22
14835: PUSH
14836: LD_INT 24
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PUSH
14843: LD_INT 1
14845: PPUSH
14846: LD_INT 2
14848: PPUSH
14849: CALL_OW 12
14853: ARRAY
14854: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 22
14862: EQUAL
14863: IFFALSE 14898
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14865: LD_ADDR_VAR 0 4
14869: PUSH
14870: LD_INT 45
14872: PUSH
14873: LD_INT 43
14875: PUSH
14876: LD_INT 44
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: PUSH
14884: LD_INT 1
14886: PPUSH
14887: LD_INT 3
14889: PPUSH
14890: CALL_OW 12
14894: ARRAY
14895: ST_TO_ADDR
14896: GO 14929
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14898: LD_ADDR_VAR 0 4
14902: PUSH
14903: LD_INT 46
14905: PUSH
14906: LD_INT 44
14908: PUSH
14909: LD_INT 45
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: LIST
14916: PUSH
14917: LD_INT 1
14919: PPUSH
14920: LD_INT 3
14922: PPUSH
14923: CALL_OW 12
14927: ARRAY
14928: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14929: LD_ADDR_VAR 0 2
14933: PUSH
14934: LD_INT 3
14936: PPUSH
14937: LD_INT 3
14939: PPUSH
14940: LD_VAR 0 3
14944: PPUSH
14945: LD_INT 1
14947: PPUSH
14948: LD_INT 3
14950: PUSH
14951: LD_INT 3
14953: PUSH
14954: LD_INT 3
14956: PUSH
14957: LD_INT 1
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: LIST
14964: LIST
14965: PUSH
14966: LD_INT 1
14968: PPUSH
14969: LD_INT 4
14971: PPUSH
14972: CALL_OW 12
14976: ARRAY
14977: PPUSH
14978: LD_VAR 0 4
14982: PPUSH
14983: LD_INT 99
14985: PPUSH
14986: CALL 264 0 7
14990: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14991: LD_VAR 0 2
14995: PPUSH
14996: CALL_OW 263
15000: PUSH
15001: LD_INT 1
15003: EQUAL
15004: IFFALSE 15035
// begin PrepareHuman ( false , 3 , skill ) ;
15006: LD_INT 0
15008: PPUSH
15009: LD_INT 3
15011: PPUSH
15012: LD_VAR 0 5
15016: PPUSH
15017: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15021: CALL_OW 44
15025: PPUSH
15026: LD_VAR 0 2
15030: PPUSH
15031: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15035: LD_VAR 0 2
15039: PPUSH
15040: LD_INT 3
15042: PPUSH
15043: LD_INT 0
15045: PPUSH
15046: CALL_OW 49
// ru_force := ru_force ^ un ;
15050: LD_ADDR_EXP 34
15054: PUSH
15055: LD_EXP 34
15059: PUSH
15060: LD_VAR 0 2
15064: ADD
15065: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15066: LD_VAR 0 2
15070: PPUSH
15071: LD_INT 126
15073: PPUSH
15074: LD_INT 158
15076: PPUSH
15077: CALL_OW 111
// Wait ( 0 0$3 ) ;
15081: LD_INT 105
15083: PPUSH
15084: CALL_OW 67
// ComStop ( un ) ;
15088: LD_VAR 0 2
15092: PPUSH
15093: CALL_OW 141
// end ;
15097: LD_VAR 0 1
15101: RET
// every 0 0$1 do var i , time , wave ;
15102: GO 15104
15104: DISABLE
15105: LD_INT 0
15107: PPUSH
15108: PPUSH
15109: PPUSH
// begin time := [ 14 14$00 , 12 12$30 , 11 11$00 ] [ Difficulty ] ;
15110: LD_ADDR_VAR 0 2
15114: PUSH
15115: LD_INT 29400
15117: PUSH
15118: LD_INT 26250
15120: PUSH
15121: LD_INT 23100
15123: PUSH
15124: EMPTY
15125: LIST
15126: LIST
15127: LIST
15128: PUSH
15129: LD_OWVAR 67
15133: ARRAY
15134: ST_TO_ADDR
// wait ( time ) ;
15135: LD_VAR 0 2
15139: PPUSH
15140: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
15144: LD_ADDR_VAR 0 2
15148: PUSH
15149: LD_INT 17850
15151: PUSH
15152: LD_INT 16450
15154: PUSH
15155: LD_INT 15750
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: LIST
15162: PUSH
15163: LD_OWVAR 67
15167: ARRAY
15168: ST_TO_ADDR
// wave := 0 ;
15169: LD_ADDR_VAR 0 3
15173: PUSH
15174: LD_INT 0
15176: ST_TO_ADDR
// while true do
15177: LD_INT 1
15179: IFFALSE 15276
// begin wave := wave + 1 ;
15181: LD_ADDR_VAR 0 3
15185: PUSH
15186: LD_VAR 0 3
15190: PUSH
15191: LD_INT 1
15193: PLUS
15194: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15195: LD_INT 22
15197: PUSH
15198: LD_INT 2
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PPUSH
15205: CALL_OW 69
15209: IFFALSE 15238
// repeat wait ( 0 0$1 ) ;
15211: LD_INT 35
15213: PPUSH
15214: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15218: LD_INT 22
15220: PUSH
15221: LD_INT 2
15223: PUSH
15224: EMPTY
15225: LIST
15226: LIST
15227: PPUSH
15228: CALL_OW 69
15232: PUSH
15233: LD_INT 0
15235: EQUAL
15236: IFFALSE 15211
// if ru_force < 20 then
15238: LD_EXP 34
15242: PUSH
15243: LD_INT 20
15245: LESS
15246: IFFALSE 15257
// PrepareAttack ( wave ) ;
15248: LD_VAR 0 3
15252: PPUSH
15253: CALL 14117 0 1
// ru_can_attack := true ;
15257: LD_ADDR_EXP 8
15261: PUSH
15262: LD_INT 1
15264: ST_TO_ADDR
// wait ( time ) ;
15265: LD_VAR 0 2
15269: PPUSH
15270: CALL_OW 67
// end ;
15274: GO 15177
// end ;
15276: PPOPN 3
15278: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15279: LD_EXP 8
15283: PUSH
15284: LD_EXP 34
15288: AND
15289: IFFALSE 16061
15291: GO 15293
15293: DISABLE
15294: LD_INT 0
15296: PPUSH
15297: PPUSH
15298: PPUSH
15299: PPUSH
15300: PPUSH
15301: PPUSH
15302: PPUSH
15303: PPUSH
15304: PPUSH
// begin enable ;
15305: ENABLE
// points1 := [ 107 , 123 ] ;
15306: LD_ADDR_VAR 0 4
15310: PUSH
15311: LD_INT 107
15313: PUSH
15314: LD_INT 123
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15321: LD_ADDR_VAR 0 5
15325: PUSH
15326: LD_INT 55
15328: PUSH
15329: LD_INT 42
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15336: LD_ADDR_VAR 0 6
15340: PUSH
15341: LD_INT 102
15343: PUSH
15344: LD_INT 140
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PUSH
15351: LD_INT 105
15353: PUSH
15354: LD_INT 142
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: PUSH
15361: LD_INT 129
15363: PUSH
15364: LD_INT 131
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: LIST
15375: ST_TO_ADDR
// for i in ru_force do
15376: LD_ADDR_VAR 0 1
15380: PUSH
15381: LD_EXP 34
15385: PUSH
15386: FOR_IN
15387: IFFALSE 16059
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15389: LD_ADDR_VAR 0 3
15393: PUSH
15394: LD_INT 81
15396: PUSH
15397: LD_INT 3
15399: PUSH
15400: EMPTY
15401: LIST
15402: LIST
15403: PPUSH
15404: CALL_OW 69
15408: PPUSH
15409: LD_VAR 0 1
15413: PPUSH
15414: CALL_OW 74
15418: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 3
15428: PPUSH
15429: CALL_OW 296
15433: PUSH
15434: LD_INT 12
15436: LESS
15437: IFFALSE 15582
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15439: LD_VAR 0 1
15443: PPUSH
15444: CALL_OW 247
15448: PUSH
15449: LD_INT 1
15451: EQUAL
15452: PUSH
15453: LD_VAR 0 1
15457: PPUSH
15458: CALL_OW 257
15462: PUSH
15463: LD_INT 1
15465: EQUAL
15466: AND
15467: PUSH
15468: LD_VAR 0 3
15472: PUSH
15473: LD_INT 21
15475: PUSH
15476: LD_INT 2
15478: PUSH
15479: EMPTY
15480: LIST
15481: LIST
15482: PUSH
15483: LD_INT 58
15485: PUSH
15486: EMPTY
15487: LIST
15488: PUSH
15489: EMPTY
15490: LIST
15491: LIST
15492: PPUSH
15493: CALL_OW 69
15497: IN
15498: AND
15499: IFFALSE 15517
// ComEnterUnit ( i , un ) else
15501: LD_VAR 0 1
15505: PPUSH
15506: LD_VAR 0 3
15510: PPUSH
15511: CALL_OW 120
15515: GO 15580
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15517: LD_VAR 0 3
15521: PUSH
15522: LD_INT 21
15524: PUSH
15525: LD_INT 2
15527: PUSH
15528: EMPTY
15529: LIST
15530: LIST
15531: PUSH
15532: LD_INT 58
15534: PUSH
15535: EMPTY
15536: LIST
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: PPUSH
15542: CALL_OW 69
15546: IN
15547: NOT
15548: IFFALSE 15566
// ComAttackUnit ( i , un ) else
15550: LD_VAR 0 1
15554: PPUSH
15555: LD_VAR 0 3
15559: PPUSH
15560: CALL_OW 115
15564: GO 15580
// ComAttackUnit ( i , JMM ) ;
15566: LD_VAR 0 1
15570: PPUSH
15571: LD_EXP 18
15575: PPUSH
15576: CALL_OW 115
// end else
15580: GO 16057
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
15582: LD_VAR 0 1
15586: PPUSH
15587: LD_VAR 0 4
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: LD_VAR 0 4
15600: PUSH
15601: LD_INT 2
15603: ARRAY
15604: PPUSH
15605: CALL_OW 297
15609: PUSH
15610: LD_VAR 0 1
15614: PPUSH
15615: LD_VAR 0 5
15619: PUSH
15620: LD_INT 1
15622: ARRAY
15623: PPUSH
15624: LD_VAR 0 5
15628: PUSH
15629: LD_INT 2
15631: ARRAY
15632: PPUSH
15633: CALL_OW 297
15637: GREATER
15638: PUSH
15639: LD_EXP 9
15643: AND
15644: PUSH
15645: LD_INT 9
15647: PPUSH
15648: LD_INT 22
15650: PUSH
15651: LD_INT 1
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: PPUSH
15658: CALL_OW 70
15662: PUSH
15663: LD_INT 0
15665: EQUAL
15666: OR
15667: IFFALSE 15698
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15669: LD_VAR 0 1
15673: PPUSH
15674: LD_VAR 0 5
15678: PUSH
15679: LD_INT 1
15681: ARRAY
15682: PPUSH
15683: LD_VAR 0 5
15687: PUSH
15688: LD_INT 2
15690: ARRAY
15691: PPUSH
15692: CALL_OW 114
15696: GO 16057
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 264
15707: PUSH
15708: LD_INT 45
15710: EQUAL
15711: PUSH
15712: LD_EXP 34
15716: PPUSH
15717: LD_INT 3
15719: PUSH
15720: LD_INT 34
15722: PUSH
15723: LD_INT 45
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PPUSH
15734: CALL_OW 72
15738: AND
15739: IFFALSE 15920
// begin dist := 9999 ;
15741: LD_ADDR_VAR 0 8
15745: PUSH
15746: LD_INT 9999
15748: ST_TO_ADDR
// xy := 0 ;
15749: LD_ADDR_VAR 0 9
15753: PUSH
15754: LD_INT 0
15756: ST_TO_ADDR
// for x in pointsr do
15757: LD_ADDR_VAR 0 7
15761: PUSH
15762: LD_VAR 0 6
15766: PUSH
15767: FOR_IN
15768: IFFALSE 15916
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_VAR 0 7
15779: PUSH
15780: LD_INT 1
15782: ARRAY
15783: PPUSH
15784: LD_VAR 0 7
15788: PUSH
15789: LD_INT 2
15791: ARRAY
15792: PPUSH
15793: CALL_OW 297
15797: PUSH
15798: LD_VAR 0 8
15802: LESS
15803: IFFALSE 15848
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15805: LD_ADDR_VAR 0 8
15809: PUSH
15810: LD_VAR 0 1
15814: PPUSH
15815: LD_VAR 0 7
15819: PUSH
15820: LD_INT 1
15822: ARRAY
15823: PPUSH
15824: LD_VAR 0 7
15828: PUSH
15829: LD_INT 2
15831: ARRAY
15832: PPUSH
15833: CALL_OW 297
15837: ST_TO_ADDR
// xy := x ;
15838: LD_ADDR_VAR 0 9
15842: PUSH
15843: LD_VAR 0 7
15847: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15848: LD_VAR 0 9
15852: PUSH
15853: LD_VAR 0 1
15857: PPUSH
15858: LD_VAR 0 9
15862: PUSH
15863: LD_INT 1
15865: ARRAY
15866: PPUSH
15867: LD_VAR 0 9
15871: PUSH
15872: LD_INT 2
15874: ARRAY
15875: PPUSH
15876: CALL_OW 297
15880: PUSH
15881: LD_INT 9
15883: GREATER
15884: AND
15885: IFFALSE 15914
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15887: LD_VAR 0 1
15891: PPUSH
15892: LD_VAR 0 9
15896: PUSH
15897: LD_INT 1
15899: ARRAY
15900: PPUSH
15901: LD_VAR 0 9
15905: PUSH
15906: LD_INT 2
15908: ARRAY
15909: PPUSH
15910: CALL_OW 114
// end ;
15914: GO 15767
15916: POP
15917: POP
// end else
15918: GO 16057
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
15920: LD_ADDR_VAR 0 3
15924: PUSH
15925: LD_OWVAR 3
15929: PUSH
15930: LD_VAR 0 1
15934: DIFF
15935: PPUSH
15936: LD_VAR 0 1
15940: PPUSH
15941: CALL_OW 74
15945: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15946: LD_VAR 0 3
15950: PUSH
15951: LD_INT 21
15953: PUSH
15954: LD_INT 2
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: LD_INT 58
15963: PUSH
15964: EMPTY
15965: LIST
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PPUSH
15971: CALL_OW 69
15975: IN
15976: PUSH
15977: LD_VAR 0 3
15981: PUSH
15982: LD_INT 22
15984: PUSH
15985: LD_INT 3
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: PUSH
15992: LD_INT 24
15994: PUSH
15995: LD_INT 249
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PPUSH
16006: CALL_OW 69
16010: IN
16011: OR
16012: IFFALSE 16030
// ComAttackUnit ( i , un ) else
16014: LD_VAR 0 1
16018: PPUSH
16019: LD_VAR 0 3
16023: PPUSH
16024: CALL_OW 115
16028: GO 16057
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
16030: LD_VAR 0 1
16034: PPUSH
16035: LD_VAR 0 4
16039: PUSH
16040: LD_INT 1
16042: ARRAY
16043: PPUSH
16044: LD_VAR 0 4
16048: PUSH
16049: LD_INT 2
16051: ARRAY
16052: PPUSH
16053: CALL_OW 114
// end ; end ; end ; end ;
16057: GO 15386
16059: POP
16060: POP
// end ;
16061: PPOPN 9
16063: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16064: LD_INT 22
16066: PUSH
16067: LD_INT 3
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: PUSH
16074: LD_INT 32
16076: PUSH
16077: LD_INT 1
16079: PUSH
16080: EMPTY
16081: LIST
16082: LIST
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: PPUSH
16088: CALL_OW 69
16092: IFFALSE 16180
16094: GO 16096
16096: DISABLE
16097: LD_INT 0
16099: PPUSH
16100: PPUSH
// begin enable ;
16101: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16102: LD_ADDR_VAR 0 2
16106: PUSH
16107: LD_INT 22
16109: PUSH
16110: LD_INT 3
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PUSH
16117: LD_INT 32
16119: PUSH
16120: LD_INT 1
16122: PUSH
16123: EMPTY
16124: LIST
16125: LIST
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: PPUSH
16131: CALL_OW 69
16135: ST_TO_ADDR
// for i in tmp do
16136: LD_ADDR_VAR 0 1
16140: PUSH
16141: LD_VAR 0 2
16145: PUSH
16146: FOR_IN
16147: IFFALSE 16178
// if GetFuel ( i ) < 12 then
16149: LD_VAR 0 1
16153: PPUSH
16154: CALL_OW 261
16158: PUSH
16159: LD_INT 12
16161: LESS
16162: IFFALSE 16176
// SetFuel ( i , 12 ) ;
16164: LD_VAR 0 1
16168: PPUSH
16169: LD_INT 12
16171: PPUSH
16172: CALL_OW 240
16176: GO 16146
16178: POP
16179: POP
// end ;
16180: PPOPN 2
16182: END
// every 0 0$1 trigger can_end do
16183: LD_EXP 17
16187: IFFALSE 16214
16189: GO 16191
16191: DISABLE
// begin Wait ( 1 1$35 ) ;
16192: LD_INT 3325
16194: PPUSH
16195: CALL_OW 67
// PrepareAttack ( 10 ) ;
16199: LD_INT 10
16201: PPUSH
16202: CALL 14117 0 1
// ru_can_attack := true ;
16206: LD_ADDR_EXP 8
16210: PUSH
16211: LD_INT 1
16213: ST_TO_ADDR
// end ;
16214: END
