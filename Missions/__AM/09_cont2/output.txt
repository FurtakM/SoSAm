// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12642 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1745 0 0
// Action ;
  32: CALL 2620 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 56
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1713
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// for i = 1 to 4 do
1676: LD_ADDR_VAR 0 5
1680: PUSH
1681: DOUBLE
1682: LD_INT 1
1684: DEC
1685: ST_TO_ADDR
1686: LD_INT 4
1688: PUSH
1689: FOR_TO
1690: IFFALSE 1711
// AddExperience ( Houten , i , 10000 ) ;
1692: LD_EXP 22
1696: PPUSH
1697: LD_VAR 0 5
1701: PPUSH
1702: LD_INT 10000
1704: PPUSH
1705: CALL_OW 492
1709: GO 1689
1711: POP
1712: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1713: LD_ADDR_EXP 25
1717: PUSH
1718: LD_STRING Powell
1720: PPUSH
1721: LD_INT 0
1723: PPUSH
1724: LD_STRING 
1726: PPUSH
1727: CALL 201 0 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// InitUc ;
1736: CALL_OW 18
// end ;
1740: LD_VAR 0 1
1744: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1745: LD_INT 0
1747: PPUSH
1748: PPUSH
1749: PPUSH
1750: PPUSH
1751: PPUSH
// uc_side := 4 ;
1752: LD_ADDR_OWVAR 20
1756: PUSH
1757: LD_INT 4
1759: ST_TO_ADDR
// uc_nation := 3 ;
1760: LD_ADDR_OWVAR 21
1764: PUSH
1765: LD_INT 3
1767: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_STRING 09_ovsyenko_base
1775: PPUSH
1776: LD_INT 0
1778: PUSH
1779: LD_INT 101
1781: PUSH
1782: LD_INT 118
1784: PUSH
1785: LD_INT 2
1787: PUSH
1788: LD_INT 500
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 31
1800: PUSH
1801: LD_INT 109
1803: PUSH
1804: LD_INT 114
1806: PUSH
1807: LD_INT 4
1809: PUSH
1810: LD_INT 500
1812: PUSH
1813: EMPTY
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_INT 31
1822: PUSH
1823: LD_INT 115
1825: PUSH
1826: LD_INT 132
1828: PUSH
1829: LD_INT 5
1831: PUSH
1832: LD_INT 500
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 31
1844: PUSH
1845: LD_INT 98
1847: PUSH
1848: LD_INT 120
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 500
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: PPUSH
1870: CALL_OW 30
1874: ST_TO_ADDR
// for i in tmp do
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: LD_VAR 0 4
1884: PUSH
1885: FOR_IN
1886: IFFALSE 2042
// begin bc_type := i [ 1 ] ;
1888: LD_ADDR_OWVAR 42
1892: PUSH
1893: LD_VAR 0 2
1897: PUSH
1898: LD_INT 1
1900: ARRAY
1901: ST_TO_ADDR
// bc_level := 3 ;
1902: LD_ADDR_OWVAR 43
1906: PUSH
1907: LD_INT 3
1909: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1910: LD_ADDR_VAR 0 3
1914: PUSH
1915: LD_VAR 0 2
1919: PUSH
1920: LD_INT 2
1922: ARRAY
1923: PPUSH
1924: LD_VAR 0 2
1928: PUSH
1929: LD_INT 3
1931: ARRAY
1932: PPUSH
1933: LD_VAR 0 2
1937: PUSH
1938: LD_INT 4
1940: ARRAY
1941: PPUSH
1942: CALL_OW 47
1946: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1947: LD_VAR 0 3
1951: PPUSH
1952: CALL_OW 266
1956: PUSH
1957: LD_INT 0
1959: EQUAL
1960: IFFALSE 1994
// begin SetBName ( b , ovsyenko ) ;
1962: LD_VAR 0 3
1966: PPUSH
1967: LD_STRING ovsyenko
1969: PPUSH
1970: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1974: LD_VAR 0 3
1978: PPUSH
1979: CALL_OW 274
1983: PPUSH
1984: LD_INT 1
1986: PPUSH
1987: LD_INT 50
1989: PPUSH
1990: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1994: LD_VAR 0 2
1998: PUSH
1999: LD_INT 5
2001: ARRAY
2002: PUSH
2003: LD_INT 250
2005: LESS
2006: IFFALSE 2022
// SetLives ( b , 333 ) else
2008: LD_VAR 0 3
2012: PPUSH
2013: LD_INT 333
2015: PPUSH
2016: CALL_OW 234
2020: GO 2040
// SetLives ( b , i [ 5 ] ) ;
2022: LD_VAR 0 3
2026: PPUSH
2027: LD_VAR 0 2
2031: PUSH
2032: LD_INT 5
2034: ARRAY
2035: PPUSH
2036: CALL_OW 234
// end ;
2040: GO 1885
2042: POP
2043: POP
// uc_nation := 1 ;
2044: LD_ADDR_OWVAR 21
2048: PUSH
2049: LD_INT 1
2051: ST_TO_ADDR
// tmp := [ ] ;
2052: LD_ADDR_VAR 0 4
2056: PUSH
2057: EMPTY
2058: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2059: LD_ADDR_EXP 19
2063: PUSH
2064: LD_STRING Gary
2066: PPUSH
2067: LD_EXP 2
2071: NOT
2072: PPUSH
2073: LD_STRING 
2075: PPUSH
2076: CALL 201 0 3
2080: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 4
2090: PUSH
2091: LD_EXP 19
2095: ADD
2096: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2097: LD_ADDR_EXP 20
2101: PUSH
2102: LD_STRING Bobby
2104: PPUSH
2105: LD_EXP 2
2109: NOT
2110: PPUSH
2111: LD_STRING 03_
2113: PPUSH
2114: CALL 201 0 3
2118: ST_TO_ADDR
// if Bobby then
2119: LD_EXP 20
2123: IFFALSE 2141
// tmp := tmp ^ Bobby ;
2125: LD_ADDR_VAR 0 4
2129: PUSH
2130: LD_VAR 0 4
2134: PUSH
2135: LD_EXP 20
2139: ADD
2140: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2141: LD_ADDR_EXP 21
2145: PUSH
2146: LD_STRING Cyrus
2148: PPUSH
2149: LD_EXP 2
2153: NOT
2154: PPUSH
2155: LD_STRING 03_
2157: PPUSH
2158: CALL 201 0 3
2162: ST_TO_ADDR
// if Cyrus then
2163: LD_EXP 21
2167: IFFALSE 2185
// tmp := tmp ^ Cyrus ;
2169: LD_ADDR_VAR 0 4
2173: PUSH
2174: LD_VAR 0 4
2178: PUSH
2179: LD_EXP 21
2183: ADD
2184: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2185: LD_ADDR_VAR 0 4
2189: PUSH
2190: LD_VAR 0 4
2194: PUSH
2195: LD_STRING 09_prev_squad
2197: PPUSH
2198: CALL_OW 31
2202: ADD
2203: ST_TO_ADDR
// tmp := tmp diff 0 ;
2204: LD_ADDR_VAR 0 4
2208: PUSH
2209: LD_VAR 0 4
2213: PUSH
2214: LD_INT 0
2216: DIFF
2217: ST_TO_ADDR
// if debug then
2218: LD_EXP 2
2222: IFFALSE 2273
// begin for i = 1 to 6 do
2224: LD_ADDR_VAR 0 2
2228: PUSH
2229: DOUBLE
2230: LD_INT 1
2232: DEC
2233: ST_TO_ADDR
2234: LD_INT 6
2236: PUSH
2237: FOR_TO
2238: IFFALSE 2271
// begin PrepareHuman ( false , 1 , 6 ) ;
2240: LD_INT 0
2242: PPUSH
2243: LD_INT 1
2245: PPUSH
2246: LD_INT 6
2248: PPUSH
2249: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2253: LD_ADDR_VAR 0 4
2257: PUSH
2258: LD_VAR 0 4
2262: PUSH
2263: CALL_OW 44
2267: ADD
2268: ST_TO_ADDR
// end ;
2269: GO 2237
2271: POP
2272: POP
// end ; for i in tmp do
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: LD_VAR 0 4
2282: PUSH
2283: FOR_IN
2284: IFFALSE 2343
// begin if GetClass ( i ) in [ 2 , 3 ] then
2286: LD_VAR 0 2
2290: PPUSH
2291: CALL_OW 257
2295: PUSH
2296: LD_INT 2
2298: PUSH
2299: LD_INT 3
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: IN
2306: IFFALSE 2320
// SetClass ( i , 1 ) ;
2308: LD_VAR 0 2
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2320: LD_VAR 0 2
2324: PPUSH
2325: LD_INT 106
2327: PPUSH
2328: LD_INT 122
2330: PPUSH
2331: LD_INT 5
2333: PPUSH
2334: LD_INT 0
2336: PPUSH
2337: CALL_OW 50
// end ;
2341: GO 2283
2343: POP
2344: POP
// tmp := tmp diff Gary ;
2345: LD_ADDR_VAR 0 4
2349: PUSH
2350: LD_VAR 0 4
2354: PUSH
2355: LD_EXP 19
2359: DIFF
2360: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2361: LD_ADDR_VAR 0 3
2365: PUSH
2366: LD_INT 22
2368: PUSH
2369: LD_INT 4
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: LD_INT 30
2378: PUSH
2379: LD_INT 31
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: PPUSH
2390: CALL_OW 69
2394: ST_TO_ADDR
// for i = 1 to b do
2395: LD_ADDR_VAR 0 2
2399: PUSH
2400: DOUBLE
2401: LD_INT 1
2403: DEC
2404: ST_TO_ADDR
2405: LD_VAR 0 3
2409: PUSH
2410: FOR_TO
2411: IFFALSE 2441
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2413: LD_VAR 0 4
2417: PUSH
2418: LD_VAR 0 2
2422: ARRAY
2423: PPUSH
2424: LD_VAR 0 3
2428: PUSH
2429: LD_VAR 0 2
2433: ARRAY
2434: PPUSH
2435: CALL_OW 120
// end ;
2439: GO 2410
2441: POP
2442: POP
// InitHc ;
2443: CALL_OW 19
// InitUc ;
2447: CALL_OW 18
// end ;
2451: LD_VAR 0 1
2455: RET
// export function PowellTransport ; var i , un ; begin
2456: LD_INT 0
2458: PPUSH
2459: PPUSH
2460: PPUSH
// uc_side := 4 ;
2461: LD_ADDR_OWVAR 20
2465: PUSH
2466: LD_INT 4
2468: ST_TO_ADDR
// uc_nation := 1 ;
2469: LD_ADDR_OWVAR 21
2473: PUSH
2474: LD_INT 1
2476: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2477: LD_INT 1
2479: PPUSH
2480: LD_INT 3
2482: PPUSH
2483: LD_INT 6
2485: PPUSH
2486: CALL_OW 380
// hc_name :=  ;
2490: LD_ADDR_OWVAR 26
2494: PUSH
2495: LD_STRING 
2497: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2498: LD_ADDR_OWVAR 33
2502: PUSH
2503: LD_STRING SecondCharsGal
2505: ST_TO_ADDR
// hc_face_number := 30 ;
2506: LD_ADDR_OWVAR 34
2510: PUSH
2511: LD_INT 30
2513: ST_TO_ADDR
// powell_trans := CreateHuman ;
2514: LD_ADDR_EXP 24
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// hc_face_number := 31 ;
2524: LD_ADDR_OWVAR 34
2528: PUSH
2529: LD_INT 31
2531: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2532: LD_ADDR_EXP 24
2536: PUSH
2537: LD_EXP 24
2541: PUSH
2542: CALL_OW 44
2546: ADD
2547: ST_TO_ADDR
// for i = 1 to 2 do
2548: LD_ADDR_VAR 0 2
2552: PUSH
2553: DOUBLE
2554: LD_INT 1
2556: DEC
2557: ST_TO_ADDR
2558: LD_INT 2
2560: PUSH
2561: FOR_TO
2562: IFFALSE 2613
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2564: LD_ADDR_VAR 0 3
2568: PUSH
2569: LD_INT 4
2571: PPUSH
2572: LD_INT 1
2574: PPUSH
2575: LD_INT 3
2577: PPUSH
2578: LD_INT 1
2580: PPUSH
2581: LD_INT 1
2583: PPUSH
2584: LD_INT 12
2586: PPUSH
2587: LD_INT 66
2589: PPUSH
2590: CALL 264 0 7
2594: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2595: LD_ADDR_EXP 24
2599: PUSH
2600: LD_EXP 24
2604: PUSH
2605: LD_VAR 0 3
2609: ADD
2610: ST_TO_ADDR
// end ;
2611: GO 2561
2613: POP
2614: POP
// end ; end_of_file
2615: LD_VAR 0 1
2619: RET
// export function Action ; var i , veh ; begin
2620: LD_INT 0
2622: PPUSH
2623: PPUSH
2624: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2625: LD_EXP 23
2629: PPUSH
2630: LD_INT 0
2632: PPUSH
2633: LD_INT 50
2635: PPUSH
2636: LD_INT 38
2638: PPUSH
2639: LD_INT 2
2641: PPUSH
2642: CALL_OW 145
// InGameOn ;
2646: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 9
2655: PPUSH
2656: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2660: LD_EXP 18
2664: PPUSH
2665: LD_INT 54
2667: PPUSH
2668: LD_INT 34
2670: PPUSH
2671: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2675: LD_EXP 18
2679: PPUSH
2680: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2684: LD_EXP 18
2688: PPUSH
2689: LD_EXP 23
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2702: LD_INT 35
2704: PPUSH
2705: CALL_OW 67
// until See ( 4 , JMM ) ;
2709: LD_INT 4
2711: PPUSH
2712: LD_EXP 18
2716: PPUSH
2717: CALL_OW 292
2721: IFFALSE 2702
// CenterNowOnUnits ( JMM ) ;
2723: LD_EXP 18
2727: PPUSH
2728: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2732: LD_EXP 18
2736: PPUSH
2737: LD_STRING D2-JMM-1
2739: PPUSH
2740: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2744: LD_EXP 23
2748: PUSH
2749: LD_INT 3
2751: ARRAY
2752: PPUSH
2753: LD_EXP 18
2757: PPUSH
2758: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2762: LD_EXP 23
2766: PUSH
2767: LD_INT 3
2769: ARRAY
2770: PPUSH
2771: LD_STRING D2-Eng1-1
2773: PPUSH
2774: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2778: LD_EXP 18
2782: PPUSH
2783: LD_STRING D2-JMM-2
2785: PPUSH
2786: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2790: LD_EXP 23
2794: PUSH
2795: LD_INT 3
2797: ARRAY
2798: PPUSH
2799: LD_STRING D2-Eng1-2
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2806: LD_EXP 18
2810: PPUSH
2811: LD_STRING D2-JMM-3
2813: PPUSH
2814: CALL_OW 88
// if Houten then
2818: LD_EXP 22
2822: IFFALSE 3020
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2824: LD_ADDR_VAR 0 3
2828: PUSH
2829: LD_INT 4
2831: PPUSH
2832: LD_INT 1
2834: PPUSH
2835: LD_INT 3
2837: PPUSH
2838: LD_INT 2
2840: PPUSH
2841: LD_INT 1
2843: PPUSH
2844: LD_INT 4
2846: PPUSH
2847: LD_INT 55
2849: PPUSH
2850: CALL 264 0 7
2854: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2855: LD_VAR 0 3
2859: PPUSH
2860: LD_INT 3
2862: PPUSH
2863: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 46
2874: PPUSH
2875: LD_INT 19
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2885: LD_EXP 22
2889: PPUSH
2890: LD_VAR 0 3
2894: PPUSH
2895: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2899: LD_EXP 22
2903: PPUSH
2904: LD_INT 49
2906: PPUSH
2907: LD_INT 33
2909: PPUSH
2910: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2914: LD_EXP 22
2918: PPUSH
2919: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2923: LD_EXP 22
2927: PPUSH
2928: LD_EXP 18
2932: PPUSH
2933: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2937: LD_INT 35
2939: PPUSH
2940: CALL_OW 67
// until See ( 1 , Houten ) ;
2944: LD_INT 1
2946: PPUSH
2947: LD_EXP 22
2951: PPUSH
2952: CALL_OW 292
2956: IFFALSE 2937
// ComTurnUnit ( JMM , Houten ) ;
2958: LD_EXP 18
2962: PPUSH
2963: LD_EXP 22
2967: PPUSH
2968: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2972: LD_EXP 18
2976: PPUSH
2977: LD_STRING D1d-JMM-1
2979: PPUSH
2980: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2984: LD_EXP 22
2988: PPUSH
2989: LD_STRING D1-VanH-1
2991: PPUSH
2992: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2996: LD_EXP 18
3000: PPUSH
3001: LD_STRING D1-JMM-1v
3003: PPUSH
3004: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3008: LD_EXP 18
3012: PPUSH
3013: LD_STRING D1-JMM-2v
3015: PPUSH
3016: CALL_OW 88
// end ; InGameOff ;
3020: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3024: LD_STRING M1
3026: PPUSH
3027: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3031: LD_INT 22
3033: PUSH
3034: LD_INT 4
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: PUSH
3041: LD_INT 92
3043: PUSH
3044: LD_EXP 18
3048: PPUSH
3049: CALL_OW 250
3053: PUSH
3054: LD_EXP 18
3058: PPUSH
3059: CALL_OW 251
3063: PUSH
3064: LD_INT 15
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PPUSH
3077: CALL_OW 69
3081: PPUSH
3082: LD_INT 1
3084: PPUSH
3085: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3089: LD_EXP 23
3093: PUSH
3094: LD_EXP 18
3098: ADD
3099: PUSH
3100: LD_EXP 22
3104: ADD
3105: PPUSH
3106: CALL_OW 141
// end ;
3110: LD_VAR 0 1
3114: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3115: LD_INT 1
3117: PPUSH
3118: LD_EXP 19
3122: PPUSH
3123: CALL_OW 292
3127: PUSH
3128: LD_EXP 18
3132: PPUSH
3133: LD_EXP 19
3137: PPUSH
3138: CALL_OW 296
3142: PUSH
3143: LD_INT 6
3145: LESS
3146: AND
3147: IFFALSE 3910
3149: GO 3151
3151: DISABLE
3152: LD_INT 0
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
// begin InGameOn ;
3159: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3163: LD_INT 22
3165: PUSH
3166: LD_INT 4
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PPUSH
3173: CALL_OW 69
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3185: LD_ADDR_VAR 0 4
3189: PUSH
3190: LD_INT 22
3192: PUSH
3193: LD_INT 1
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 2
3202: PUSH
3203: LD_INT 25
3205: PUSH
3206: LD_INT 1
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 2
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PUSH
3223: LD_INT 25
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: PUSH
3233: LD_INT 25
3235: PUSH
3236: LD_INT 4
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: PPUSH
3254: CALL_OW 69
3258: ST_TO_ADDR
// ComHold ( tmp ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3268: LD_EXP 18
3272: PPUSH
3273: LD_STRING D2-JMM-3a
3275: PPUSH
3276: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3280: LD_EXP 19
3284: PPUSH
3285: LD_EXP 18
3289: PPUSH
3290: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3294: LD_EXP 19
3298: PPUSH
3299: LD_STRING D2-Gary-3
3301: PPUSH
3302: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3306: LD_EXP 18
3310: PPUSH
3311: LD_EXP 19
3315: PPUSH
3316: CALL_OW 119
// for i in tmp do
3320: LD_ADDR_VAR 0 5
3324: PUSH
3325: LD_VAR 0 4
3329: PUSH
3330: FOR_IN
3331: IFFALSE 3376
// begin if IsInUnit ( i ) then
3333: LD_VAR 0 5
3337: PPUSH
3338: CALL_OW 310
3342: IFFALSE 3353
// ComExitBuilding ( i ) ;
3344: LD_VAR 0 5
3348: PPUSH
3349: CALL_OW 122
// wait ( 1 ) ;
3353: LD_INT 1
3355: PPUSH
3356: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3360: LD_VAR 0 5
3364: PPUSH
3365: LD_EXP 18
3369: PPUSH
3370: CALL_OW 119
// end ;
3374: GO 3330
3376: POP
3377: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3378: LD_ADDR_VAR 0 4
3382: PUSH
3383: LD_VAR 0 4
3387: PUSH
3388: LD_EXP 18
3392: PUSH
3393: LD_EXP 22
3397: PUSH
3398: LD_EXP 19
3402: PUSH
3403: LD_EXP 21
3407: PUSH
3408: LD_EXP 20
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_EXP 23
3424: ADD
3425: DIFF
3426: ST_TO_ADDR
// if Bobby then
3427: LD_EXP 20
3431: IFFALSE 3445
// Say ( Bobby , D2-Bobby-3 ) ;
3433: LD_EXP 20
3437: PPUSH
3438: LD_STRING D2-Bobby-3
3440: PPUSH
3441: CALL_OW 88
// if Cyrus then
3445: LD_EXP 21
3449: IFFALSE 3463
// Say ( Cyrus , D2-Cyrus-3 ) ;
3451: LD_EXP 21
3455: PPUSH
3456: LD_STRING D2-Cyrus-3
3458: PPUSH
3459: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3463: LD_EXP 18
3467: PPUSH
3468: LD_STRING D2-JMM-4
3470: PPUSH
3471: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3475: LD_EXP 19
3479: PPUSH
3480: LD_STRING D2-Gary-4
3482: PPUSH
3483: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: LD_VAR 0 4
3496: PPUSH
3497: LD_INT 26
3499: PUSH
3500: LD_INT 1
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PPUSH
3507: CALL_OW 72
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: ST_TO_ADDR
// if Cyrus then
3516: LD_EXP 21
3520: IFFALSE 3536
// Say ( Cyrus , D2-Cyrus-4 ) else
3522: LD_EXP 21
3526: PPUSH
3527: LD_STRING D2-Cyrus-4
3529: PPUSH
3530: CALL_OW 88
3534: GO 3548
// Say ( un1 , D2-Sol1-4 ) ;
3536: LD_VAR 0 1
3540: PPUSH
3541: LD_STRING D2-Sol1-4
3543: PPUSH
3544: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3548: LD_EXP 18
3552: PPUSH
3553: LD_STRING D2-JMM-5
3555: PPUSH
3556: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_EXP 23
3569: PPUSH
3570: LD_INT 91
3572: PUSH
3573: LD_EXP 18
3577: PUSH
3578: LD_INT 10
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 26
3588: PUSH
3589: LD_INT 2
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 72
3604: ST_TO_ADDR
// if un2 then
3605: LD_VAR 0 2
3609: IFFALSE 3663
// begin un2 := un2 [ un2 ] ;
3611: LD_ADDR_VAR 0 2
3615: PUSH
3616: LD_VAR 0 2
3620: PUSH
3621: LD_VAR 0 2
3625: ARRAY
3626: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3627: LD_VAR 0 2
3631: PPUSH
3632: LD_STRING D2-FEng1-5
3634: PPUSH
3635: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3639: LD_EXP 18
3643: PPUSH
3644: LD_STRING D2-JMM-6
3646: PPUSH
3647: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3651: LD_VAR 0 2
3655: PPUSH
3656: LD_STRING D2-FEng1-6
3658: PPUSH
3659: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_EXP 23
3672: PPUSH
3673: LD_INT 91
3675: PUSH
3676: LD_EXP 18
3680: PUSH
3681: LD_INT 10
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 26
3691: PUSH
3692: LD_INT 1
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PPUSH
3703: CALL_OW 72
3707: ST_TO_ADDR
// if un3 then
3708: LD_VAR 0 3
3712: IFFALSE 3767
// begin un3 := un3 [ 1 ] ;
3714: LD_ADDR_VAR 0 3
3718: PUSH
3719: LD_VAR 0 3
3723: PUSH
3724: LD_INT 1
3726: ARRAY
3727: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3728: LD_VAR 0 3
3732: PPUSH
3733: LD_INT 114
3735: PPUSH
3736: LD_INT 122
3738: PPUSH
3739: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3743: LD_VAR 0 3
3747: PPUSH
3748: LD_STRING D2-Eng1-6
3750: PPUSH
3751: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3755: LD_EXP 18
3759: PPUSH
3760: LD_STRING D2-JMM-7
3762: PPUSH
3763: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3767: LD_EXP 19
3771: PPUSH
3772: LD_STRING D2-Gary-7
3774: PPUSH
3775: CALL_OW 88
// if un2 then
3779: LD_VAR 0 2
3783: IFFALSE 3797
// Say ( un2 , D2-FEng1-7 ) ;
3785: LD_VAR 0 2
3789: PPUSH
3790: LD_STRING D2-FEng1-7
3792: PPUSH
3793: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3797: LD_VAR 0 1
3801: PPUSH
3802: LD_STRING D2-Sol1-7
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3809: LD_EXP 18
3813: PPUSH
3814: LD_STRING D2-JMM-8
3816: PPUSH
3817: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3821: LD_INT 22
3823: PUSH
3824: LD_INT 1
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: PPUSH
3831: CALL_OW 69
3835: PPUSH
3836: CALL_OW 141
// InGameOff ;
3840: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3844: LD_STRING M1a
3846: PPUSH
3847: CALL_OW 337
// jmm_in_ovsyenko := true ;
3851: LD_ADDR_EXP 4
3855: PUSH
3856: LD_INT 1
3858: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3859: LD_INT 1050
3861: PPUSH
3862: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3866: LD_ADDR_VAR 0 4
3870: PUSH
3871: LD_INT 25
3873: PUSH
3874: LD_INT 14
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: PPUSH
3881: CALL_OW 69
3885: ST_TO_ADDR
// if not tmp then
3886: LD_VAR 0 4
3890: NOT
3891: IFFALSE 3895
// exit ;
3893: GO 3910
// ComMoveXY ( tmp , 75 , 75 ) ;
3895: LD_VAR 0 4
3899: PPUSH
3900: LD_INT 75
3902: PPUSH
3903: LD_INT 75
3905: PPUSH
3906: CALL_OW 111
// end ;
3910: PPOPN 5
3912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3913: LD_INT 22
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: LD_INT 30
3925: PUSH
3926: LD_INT 30
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: PUSH
3933: LD_INT 3
3935: PUSH
3936: LD_INT 57
3938: PUSH
3939: EMPTY
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: LIST
3950: PPUSH
3951: CALL_OW 69
3955: IFFALSE 3997
3957: GO 3959
3959: DISABLE
3960: LD_INT 0
3962: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3963: LD_ADDR_VAR 0 1
3967: PUSH
3968: LD_STRING M2easy
3970: PUSH
3971: LD_STRING M2
3973: PUSH
3974: LD_STRING M2hard
3976: PUSH
3977: EMPTY
3978: LIST
3979: LIST
3980: LIST
3981: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3982: LD_VAR 0 1
3986: PUSH
3987: LD_OWVAR 67
3991: ARRAY
3992: PPUSH
3993: CALL_OW 337
// end ;
3997: PPOPN 1
3999: END
// every 3 3$00 do
4000: GO 4002
4002: DISABLE
// begin DialogueOn ;
4003: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4007: LD_EXP 25
4011: PPUSH
4012: LD_STRING D3-Pow-1
4014: PPUSH
4015: CALL_OW 94
// if jmm_in_ovsyenko then
4019: LD_EXP 4
4023: IFFALSE 4051
// begin Say ( JMM , D3-JMM-1 ) ;
4025: LD_EXP 18
4029: PPUSH
4030: LD_STRING D3-JMM-1
4032: PPUSH
4033: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4037: LD_EXP 18
4041: PPUSH
4042: LD_STRING D3-JMM-1b
4044: PPUSH
4045: CALL_OW 88
// end else
4049: GO 4063
// Say ( JMM , D3-JMM-1a ) ;
4051: LD_EXP 18
4055: PPUSH
4056: LD_STRING D3-JMM-1a
4058: PPUSH
4059: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4063: LD_EXP 25
4067: PPUSH
4068: LD_STRING D3-Pow-2
4070: PPUSH
4071: CALL_OW 94
// DialogueOff ;
4075: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4079: LD_STRING M3
4081: PPUSH
4082: CALL_OW 337
// powell_want_sib := true ;
4086: LD_ADDR_EXP 5
4090: PUSH
4091: LD_INT 1
4093: ST_TO_ADDR
// end ;
4094: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4095: LD_EXP 6
4099: PUSH
4100: LD_INT 0
4102: EQUAL
4103: IFFALSE 5550
4105: GO 4107
4107: DISABLE
4108: LD_INT 0
4110: PPUSH
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
4115: PPUSH
4116: PPUSH
4117: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4118: LD_INT 4
4120: PPUSH
4121: LD_INT 1
4123: PPUSH
4124: CALL_OW 343
// PowellTransport ;
4128: CALL 2456 0 0
// for i = 1 to 3 do
4132: LD_ADDR_VAR 0 4
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 3
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4213
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4148: LD_ADDR_VAR 0 1
4152: PUSH
4153: LD_INT 6
4155: PPUSH
4156: LD_VAR 0 4
4160: PPUSH
4161: CALL_OW 287
4165: ST_TO_ADDR
// if not tmp then
4166: LD_VAR 0 1
4170: NOT
4171: IFFALSE 4175
// continue ;
4173: GO 4145
// EraseResourceArea ( terminalArea , i ) ;
4175: LD_INT 6
4177: PPUSH
4178: LD_VAR 0 4
4182: PPUSH
4183: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4187: LD_EXP 3
4191: PPUSH
4192: CALL_OW 274
4196: PPUSH
4197: LD_VAR 0 4
4201: PPUSH
4202: LD_VAR 0 1
4206: PPUSH
4207: CALL_OW 276
// end ;
4211: GO 4145
4213: POP
4214: POP
// x := 43 ;
4215: LD_ADDR_VAR 0 2
4219: PUSH
4220: LD_INT 43
4222: ST_TO_ADDR
// y := 3 ;
4223: LD_ADDR_VAR 0 3
4227: PUSH
4228: LD_INT 3
4230: ST_TO_ADDR
// for i = 3 to 4 do
4231: LD_ADDR_VAR 0 4
4235: PUSH
4236: DOUBLE
4237: LD_INT 3
4239: DEC
4240: ST_TO_ADDR
4241: LD_INT 4
4243: PUSH
4244: FOR_TO
4245: IFFALSE 4436
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4247: LD_EXP 24
4251: PUSH
4252: LD_VAR 0 4
4256: ARRAY
4257: PPUSH
4258: LD_INT 4
4260: PPUSH
4261: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4265: LD_EXP 24
4269: PUSH
4270: LD_VAR 0 4
4274: ARRAY
4275: PPUSH
4276: LD_VAR 0 2
4280: PPUSH
4281: LD_VAR 0 3
4285: PPUSH
4286: LD_INT 0
4288: PPUSH
4289: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4293: LD_EXP 24
4297: PUSH
4298: LD_VAR 0 4
4302: PUSH
4303: LD_INT 2
4305: MINUS
4306: ARRAY
4307: PPUSH
4308: LD_EXP 24
4312: PUSH
4313: LD_VAR 0 4
4317: ARRAY
4318: PPUSH
4319: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4323: LD_EXP 24
4327: PUSH
4328: LD_VAR 0 4
4332: ARRAY
4333: PPUSH
4334: LD_INT 1
4336: PPUSH
4337: LD_INT 100
4339: PPUSH
4340: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4344: LD_EXP 24
4348: PUSH
4349: LD_VAR 0 4
4353: PUSH
4354: LD_INT 2
4356: MINUS
4357: ARRAY
4358: PPUSH
4359: LD_INT 54
4361: PPUSH
4362: LD_INT 42
4364: PPUSH
4365: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4369: LD_EXP 24
4373: PUSH
4374: LD_VAR 0 4
4378: PUSH
4379: LD_INT 2
4381: MINUS
4382: ARRAY
4383: PPUSH
4384: LD_EXP 3
4388: PPUSH
4389: CALL_OW 250
4393: PPUSH
4394: LD_EXP 3
4398: PPUSH
4399: CALL_OW 251
4403: PPUSH
4404: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4408: LD_EXP 24
4412: PUSH
4413: LD_VAR 0 4
4417: PUSH
4418: LD_INT 2
4420: MINUS
4421: ARRAY
4422: PPUSH
4423: CALL_OW 200
// Wait ( 0 0$02 ) ;
4427: LD_INT 70
4429: PPUSH
4430: CALL_OW 67
// end ;
4434: GO 4244
4436: POP
4437: POP
// time := 0 0$20 ;
4438: LD_ADDR_VAR 0 8
4442: PUSH
4443: LD_INT 700
4445: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4446: LD_INT 35
4448: PPUSH
4449: CALL_OW 67
// time := time - 0 0$01 ;
4453: LD_ADDR_VAR 0 8
4457: PUSH
4458: LD_VAR 0 8
4462: PUSH
4463: LD_INT 35
4465: MINUS
4466: ST_TO_ADDR
// for i = 3 to 4 do
4467: LD_ADDR_VAR 0 4
4471: PUSH
4472: DOUBLE
4473: LD_INT 3
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 4
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4616
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4483: LD_EXP 24
4487: PUSH
4488: LD_VAR 0 4
4492: ARRAY
4493: PPUSH
4494: LD_INT 1
4496: PPUSH
4497: CALL_OW 289
4501: PUSH
4502: LD_INT 0
4504: GREATER
4505: PUSH
4506: LD_EXP 24
4510: PUSH
4511: LD_VAR 0 4
4515: ARRAY
4516: PPUSH
4517: CALL_OW 314
4521: NOT
4522: AND
4523: IFFALSE 4614
// begin x := rand ( 0 , 5 ) ;
4525: LD_ADDR_VAR 0 2
4529: PUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_INT 5
4535: PPUSH
4536: CALL_OW 12
4540: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4541: LD_EXP 24
4545: PUSH
4546: LD_VAR 0 4
4550: ARRAY
4551: PPUSH
4552: LD_EXP 24
4556: PUSH
4557: LD_VAR 0 4
4561: ARRAY
4562: PPUSH
4563: CALL_OW 250
4567: PPUSH
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_INT 3
4575: PPUSH
4576: CALL_OW 272
4580: PPUSH
4581: LD_EXP 24
4585: PUSH
4586: LD_VAR 0 4
4590: ARRAY
4591: PPUSH
4592: CALL_OW 251
4596: PPUSH
4597: LD_VAR 0 2
4601: PPUSH
4602: LD_INT 3
4604: PPUSH
4605: CALL_OW 273
4609: PPUSH
4610: CALL_OW 171
// end ;
4614: GO 4480
4616: POP
4617: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4618: LD_EXP 24
4622: PUSH
4623: LD_INT 1
4625: ARRAY
4626: PPUSH
4627: LD_INT 54
4629: PPUSH
4630: LD_INT 42
4632: PPUSH
4633: CALL_OW 297
4637: PUSH
4638: LD_INT 4
4640: LESS
4641: PUSH
4642: LD_VAR 0 8
4646: PUSH
4647: LD_INT 0
4649: EQUAL
4650: OR
4651: IFFALSE 4446
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4653: LD_EXP 24
4657: PUSH
4658: LD_INT 3
4660: ARRAY
4661: PPUSH
4662: LD_INT 1
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4672: LD_EXP 24
4676: PUSH
4677: LD_INT 4
4679: ARRAY
4680: PPUSH
4681: LD_INT 1
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4691: LD_EXP 3
4695: PPUSH
4696: CALL_OW 274
4700: PPUSH
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 200
4706: PPUSH
4707: CALL_OW 276
// DialogueOn ;
4711: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4715: LD_INT 53
4717: PPUSH
4718: LD_INT 35
4720: PPUSH
4721: CALL_OW 86
// un := powell_trans [ 1 ] ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_EXP 24
4734: PUSH
4735: LD_INT 1
4737: ARRAY
4738: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_STRING D4-Mech1-1
4746: PPUSH
4747: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4751: LD_EXP 18
4755: PPUSH
4756: LD_STRING D4-JMM-1
4758: PPUSH
4759: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4763: LD_VAR 0 5
4767: PPUSH
4768: LD_STRING D4-Mech1-2
4770: PPUSH
4771: CALL_OW 88
// powell_happy := false ;
4775: LD_ADDR_VAR 0 6
4779: PUSH
4780: LD_INT 0
4782: ST_TO_ADDR
// take_cargo := false ;
4783: LD_ADDR_VAR 0 7
4787: PUSH
4788: LD_INT 0
4790: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4791: CALL 784 0 0
4795: PUSH
4796: LD_INT 60
4798: GREATEREQUAL
4799: IFFALSE 4847
// begin Say ( JMM , D5-JMM-1 ) ;
4801: LD_EXP 18
4805: PPUSH
4806: LD_STRING D5-JMM-1
4808: PPUSH
4809: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4813: LD_VAR 0 5
4817: PPUSH
4818: LD_STRING D6-Mech1-1
4820: PPUSH
4821: CALL_OW 88
// powell_happy := true ;
4825: LD_ADDR_VAR 0 6
4829: PUSH
4830: LD_INT 1
4832: ST_TO_ADDR
// take_cargo := true ;
4833: LD_ADDR_VAR 0 7
4837: PUSH
4838: LD_INT 1
4840: ST_TO_ADDR
// DialogueOff ;
4841: CALL_OW 7
// end else
4845: GO 5081
// if GetTerminalCargo > 0 then
4847: CALL 784 0 0
4851: PUSH
4852: LD_INT 0
4854: GREATER
4855: IFFALSE 5053
// begin case Query ( QWait ) of 1 :
4857: LD_STRING QWait
4859: PPUSH
4860: CALL_OW 97
4864: PUSH
4865: LD_INT 1
4867: DOUBLE
4868: EQUAL
4869: IFTRUE 4873
4871: GO 4964
4873: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4874: LD_EXP 18
4878: PPUSH
4879: LD_STRING D5b-JMM-1
4881: PPUSH
4882: CALL_OW 88
// DialogueOff ;
4886: CALL_OW 7
// wait ( 5 5$00 ) ;
4890: LD_INT 10500
4892: PPUSH
4893: CALL_OW 67
// if GetTerminalCargo < 60 then
4897: CALL 784 0 0
4901: PUSH
4902: LD_INT 60
4904: LESS
4905: IFFALSE 4946
// begin DialogueOn ;
4907: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4911: LD_EXP 3
4915: PPUSH
4916: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4920: LD_VAR 0 5
4924: PPUSH
4925: LD_STRING D6-Mech1-1a
4927: PPUSH
4928: CALL_OW 88
// DialogueOff ;
4932: CALL_OW 7
// powell_happy := false ;
4936: LD_ADDR_VAR 0 6
4940: PUSH
4941: LD_INT 0
4943: ST_TO_ADDR
// end else
4944: GO 4962
// begin powell_happy := true ;
4946: LD_ADDR_VAR 0 6
4950: PUSH
4951: LD_INT 1
4953: ST_TO_ADDR
// take_cargo := true ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: LD_INT 1
4961: ST_TO_ADDR
// end ; end ; 2 :
4962: GO 5051
4964: LD_INT 2
4966: DOUBLE
4967: EQUAL
4968: IFTRUE 4972
4970: GO 5011
4972: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4973: LD_EXP 18
4977: PPUSH
4978: LD_STRING D5b-JMM-1
4980: PPUSH
4981: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: LD_STRING D6-Mech1-1a
4992: PPUSH
4993: CALL_OW 88
// DialogueOff ;
4997: CALL_OW 7
// take_cargo := true ;
5001: LD_ADDR_VAR 0 7
5005: PUSH
5006: LD_INT 1
5008: ST_TO_ADDR
// end ; 3 :
5009: GO 5051
5011: LD_INT 3
5013: DOUBLE
5014: EQUAL
5015: IFTRUE 5019
5017: GO 5050
5019: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5020: LD_EXP 18
5024: PPUSH
5025: LD_STRING D5c-JMM-1
5027: PPUSH
5028: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5032: LD_VAR 0 5
5036: PPUSH
5037: LD_STRING D6-Mech1-1b
5039: PPUSH
5040: CALL_OW 88
// DialogueOff ;
5044: CALL_OW 7
// end ; end ;
5048: GO 5051
5050: POP
// end else
5051: GO 5081
// begin Say ( JMM , D5c-JMM-1 ) ;
5053: LD_EXP 18
5057: PPUSH
5058: LD_STRING D5c-JMM-1
5060: PPUSH
5061: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5065: LD_VAR 0 5
5069: PPUSH
5070: LD_STRING D6-Mech1-1b
5072: PPUSH
5073: CALL_OW 88
// DialogueOff ;
5077: CALL_OW 7
// end ; if take_cargo then
5081: LD_VAR 0 7
5085: IFFALSE 5164
// begin x := GetTerminalCargo ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: CALL 784 0 0
5096: ST_TO_ADDR
// if x > 60 then
5097: LD_VAR 0 2
5101: PUSH
5102: LD_INT 60
5104: GREATER
5105: IFFALSE 5115
// x := 60 ;
5107: LD_ADDR_VAR 0 2
5111: PUSH
5112: LD_INT 60
5114: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5115: LD_EXP 3
5119: PPUSH
5120: CALL_OW 274
5124: PPUSH
5125: LD_INT 3
5127: PPUSH
5128: CALL 784 0 0
5132: PUSH
5133: LD_VAR 0 2
5137: MINUS
5138: PPUSH
5139: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5143: LD_EXP 24
5147: PUSH
5148: LD_INT 3
5150: ARRAY
5151: PPUSH
5152: LD_INT 3
5154: PPUSH
5155: LD_VAR 0 2
5159: PPUSH
5160: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5164: LD_EXP 24
5168: PPUSH
5169: LD_INT 43
5171: PPUSH
5172: LD_INT 3
5174: PPUSH
5175: CALL_OW 171
// x := 0 0$20 ;
5179: LD_ADDR_VAR 0 2
5183: PUSH
5184: LD_INT 700
5186: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5187: LD_INT 35
5189: PPUSH
5190: CALL_OW 67
// x := x - 0 0$01 ;
5194: LD_ADDR_VAR 0 2
5198: PUSH
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 35
5206: MINUS
5207: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5208: LD_VAR 0 2
5212: PUSH
5213: LD_INT 0
5215: EQUAL
5216: PUSH
5217: LD_EXP 24
5221: PUSH
5222: LD_INT 3
5224: ARRAY
5225: PPUSH
5226: LD_INT 43
5228: PPUSH
5229: LD_INT 3
5231: PPUSH
5232: CALL_OW 297
5236: PUSH
5237: LD_INT 4
5239: LESS
5240: PUSH
5241: LD_EXP 24
5245: PUSH
5246: LD_INT 3
5248: ARRAY
5249: PPUSH
5250: LD_INT 43
5252: PPUSH
5253: LD_INT 3
5255: PPUSH
5256: CALL_OW 297
5260: PUSH
5261: LD_INT 4
5263: LESS
5264: AND
5265: OR
5266: IFFALSE 5187
// for i in powell_trans do
5268: LD_ADDR_VAR 0 4
5272: PUSH
5273: LD_EXP 24
5277: PUSH
5278: FOR_IN
5279: IFFALSE 5292
// RemoveUnit ( i ) ;
5281: LD_VAR 0 4
5285: PPUSH
5286: CALL_OW 64
5290: GO 5278
5292: POP
5293: POP
// if not powell_happy then
5294: LD_VAR 0 6
5298: NOT
5299: IFFALSE 5310
// powell_happy := - 1 ;
5301: LD_ADDR_VAR 0 6
5305: PUSH
5306: LD_INT 1
5308: NEG
5309: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5310: LD_STRING EarlySiberite
5312: PPUSH
5313: LD_VAR 0 6
5317: PPUSH
5318: CALL_OW 101
// if powell_happy then
5322: LD_VAR 0 6
5326: IFFALSE 5337
// ChangeMissionObjectives ( M3a ) else
5328: LD_STRING M3a
5330: PPUSH
5331: CALL_OW 337
5335: GO 5344
// ChangeMissionObjectives ( M3b ) ;
5337: LD_STRING M3b
5339: PPUSH
5340: CALL_OW 337
// ru_can_attack_terminal := true ;
5344: LD_ADDR_EXP 9
5348: PUSH
5349: LD_INT 1
5351: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5352: LD_INT 25200
5354: PPUSH
5355: CALL_OW 67
// time := 2 2$00 ;
5359: LD_ADDR_VAR 0 8
5363: PUSH
5364: LD_INT 4200
5366: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5367: LD_INT 35
5369: PPUSH
5370: CALL_OW 67
// time := time - 0 0$1 ;
5374: LD_ADDR_VAR 0 8
5378: PUSH
5379: LD_VAR 0 8
5383: PUSH
5384: LD_INT 35
5386: MINUS
5387: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5388: LD_EXP 8
5392: NOT
5393: PUSH
5394: LD_EXP 35
5398: PUSH
5399: LD_INT 0
5401: EQUAL
5402: OR
5403: PUSH
5404: LD_VAR 0 8
5408: PUSH
5409: LD_INT 0
5411: EQUAL
5412: OR
5413: IFFALSE 5367
// if ru_force then
5415: LD_EXP 35
5419: IFFALSE 5518
// for i in ru_force do
5421: LD_ADDR_VAR 0 4
5425: PUSH
5426: LD_EXP 35
5430: PUSH
5431: FOR_IN
5432: IFFALSE 5516
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5434: LD_INT 1
5436: PPUSH
5437: LD_VAR 0 4
5441: PPUSH
5442: CALL_OW 292
5446: NOT
5447: PUSH
5448: LD_VAR 0 4
5452: PPUSH
5453: LD_INT 81
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL_OW 69
5467: PPUSH
5468: LD_VAR 0 4
5472: PPUSH
5473: CALL_OW 74
5477: PPUSH
5478: CALL_OW 296
5482: PUSH
5483: LD_INT 10
5485: GREATER
5486: AND
5487: IFFALSE 5514
// begin RemoveUnit ( i ) ;
5489: LD_VAR 0 4
5493: PPUSH
5494: CALL_OW 64
// ru_force := ru_force diff i ;
5498: LD_ADDR_EXP 35
5502: PUSH
5503: LD_EXP 35
5507: PUSH
5508: LD_VAR 0 4
5512: DIFF
5513: ST_TO_ADDR
// end ;
5514: GO 5431
5516: POP
5517: POP
// repeat wait ( 0 0$03 ) ;
5518: LD_INT 105
5520: PPUSH
5521: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5525: LD_EXP 8
5529: NOT
5530: PUSH
5531: LD_EXP 35
5535: PUSH
5536: LD_INT 3
5538: LESS
5539: OR
5540: IFFALSE 5518
// ar_can_arrive := true ;
5542: LD_ADDR_EXP 10
5546: PUSH
5547: LD_INT 1
5549: ST_TO_ADDR
// end ;
5550: PPOPN 8
5552: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5553: LD_INT 1
5555: PPUSH
5556: LD_INT 20
5558: PPUSH
5559: CALL_OW 325
5563: IFFALSE 5704
5565: GO 5567
5567: DISABLE
5568: LD_INT 0
5570: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5571: LD_ADDR_VAR 0 1
5575: PUSH
5576: LD_INT 22
5578: PUSH
5579: LD_INT 1
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 26
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PUSH
5596: LD_INT 25
5598: PUSH
5599: LD_INT 4
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 69
5615: PUSH
5616: LD_EXP 18
5620: PUSH
5621: LD_EXP 21
5625: PUSH
5626: LD_EXP 20
5630: PUSH
5631: LD_EXP 22
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: DIFF
5642: ST_TO_ADDR
// if not un then
5643: LD_VAR 0 1
5647: NOT
5648: IFFALSE 5652
// exit ;
5650: GO 5704
// DialogueOn ;
5652: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5656: LD_VAR 0 1
5660: PUSH
5661: LD_INT 1
5663: ARRAY
5664: PPUSH
5665: LD_STRING D13-Sci1-1
5667: PPUSH
5668: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5672: LD_EXP 18
5676: PPUSH
5677: LD_STRING D13-JMM-1
5679: PPUSH
5680: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5684: LD_VAR 0 1
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PPUSH
5693: LD_STRING D13-Sci1-2
5695: PPUSH
5696: CALL_OW 88
// DialogueOff ;
5700: CALL_OW 7
// end ;
5704: PPOPN 1
5706: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5707: LD_INT 1
5709: PPUSH
5710: CALL 815 0 1
5714: PUSH
5715: LD_INT 77
5717: GREATER
5718: PUSH
5719: LD_EXP 8
5723: NOT
5724: AND
5725: PUSH
5726: LD_INT 22
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 25
5738: PUSH
5739: LD_INT 4
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PUSH
5746: LD_INT 26
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PPUSH
5761: CALL_OW 69
5765: PUSH
5766: LD_EXP 18
5770: PUSH
5771: LD_EXP 20
5775: PUSH
5776: LD_EXP 21
5780: PUSH
5781: LD_EXP 19
5785: PUSH
5786: LD_EXP 22
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: DIFF
5798: AND
5799: IFFALSE 5977
5801: GO 5803
5803: DISABLE
5804: LD_INT 0
5806: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5807: LD_ADDR_VAR 0 1
5811: PUSH
5812: LD_INT 22
5814: PUSH
5815: LD_INT 1
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: PUSH
5822: LD_INT 25
5824: PUSH
5825: LD_INT 4
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 1
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: PUSH
5842: EMPTY
5843: LIST
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_EXP 18
5856: PUSH
5857: LD_EXP 20
5861: PUSH
5862: LD_EXP 21
5866: PUSH
5867: LD_EXP 19
5871: PUSH
5872: LD_EXP 22
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: DIFF
5884: ST_TO_ADDR
// DialogueOn ;
5885: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5889: LD_VAR 0 1
5893: PUSH
5894: LD_INT 1
5896: ARRAY
5897: PPUSH
5898: LD_STRING D7-Sci1-1
5900: PPUSH
5901: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5905: LD_EXP 18
5909: PPUSH
5910: LD_STRING D7-JMM-1
5912: PPUSH
5913: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5917: LD_VAR 0 1
5921: PUSH
5922: LD_INT 1
5924: ARRAY
5925: PPUSH
5926: LD_STRING D7-Sci1-2
5928: PPUSH
5929: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5933: LD_EXP 18
5937: PPUSH
5938: LD_STRING D7-JMM-2
5940: PPUSH
5941: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5945: LD_VAR 0 1
5949: PUSH
5950: LD_INT 1
5952: ARRAY
5953: PPUSH
5954: LD_STRING D7-Sci1-3
5956: PPUSH
5957: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5961: LD_EXP 18
5965: PPUSH
5966: LD_STRING D7-JMM-3
5968: PPUSH
5969: CALL_OW 88
// DialogueOff ;
5973: CALL_OW 7
// end ;
5977: PPOPN 1
5979: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5980: LD_EXP 10
5984: IFFALSE 9344
5986: GO 5988
5988: DISABLE
5989: LD_INT 0
5991: PPUSH
5992: PPUSH
5993: PPUSH
5994: PPUSH
5995: PPUSH
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin PrepareArabian ;
5999: CALL 11765 0 0
// repeat wait ( 0 0$01 ) ;
6003: LD_INT 35
6005: PPUSH
6006: CALL_OW 67
// until ar_spawned ;
6010: LD_EXP 11
6014: IFFALSE 6003
// DialogueOn ;
6016: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6020: LD_EXP 26
6024: PPUSH
6025: LD_STRING D8-Ar1-1
6027: PPUSH
6028: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6032: LD_EXP 18
6036: PPUSH
6037: LD_STRING D8-JMM-1
6039: PPUSH
6040: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6044: LD_EXP 26
6048: PPUSH
6049: LD_STRING D8-Ar1-2
6051: PPUSH
6052: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6056: LD_EXP 18
6060: PPUSH
6061: LD_STRING D8-JMM-2
6063: PPUSH
6064: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6068: LD_EXP 26
6072: PPUSH
6073: LD_STRING D8-Ar1-3
6075: PPUSH
6076: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6080: LD_EXP 18
6084: PPUSH
6085: LD_STRING D8-JMM-3
6087: PPUSH
6088: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6092: LD_EXP 26
6096: PPUSH
6097: LD_STRING D8-Ar1-4
6099: PPUSH
6100: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6104: LD_EXP 18
6108: PPUSH
6109: LD_STRING D8-JMM-4
6111: PPUSH
6112: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6116: LD_EXP 26
6120: PPUSH
6121: LD_STRING D8-Ar1-5
6123: PPUSH
6124: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6128: LD_EXP 18
6132: PPUSH
6133: LD_STRING D8-JMM-5
6135: PPUSH
6136: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6140: LD_EXP 26
6144: PPUSH
6145: LD_STRING D8-Ar1-6
6147: PPUSH
6148: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6152: LD_EXP 27
6156: PPUSH
6157: LD_STRING D8-Ar2-6
6159: PPUSH
6160: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6164: LD_EXP 18
6168: PPUSH
6169: LD_STRING D8-JMM-6
6171: PPUSH
6172: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6176: LD_EXP 27
6180: PPUSH
6181: LD_STRING D8-Ar2-7
6183: PPUSH
6184: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6188: LD_STRING QBarracks
6190: PPUSH
6191: CALL_OW 97
6195: PUSH
6196: LD_INT 1
6198: DOUBLE
6199: EQUAL
6200: IFTRUE 6204
6202: GO 6239
6204: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6205: LD_EXP 18
6209: PPUSH
6210: LD_STRING D8a-JMM-1
6212: PPUSH
6213: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6217: LD_EXP 26
6221: PPUSH
6222: LD_STRING D8a-Ar1-1
6224: PPUSH
6225: CALL_OW 94
// player_want_mortar := true ;
6229: LD_ADDR_EXP 12
6233: PUSH
6234: LD_INT 1
6236: ST_TO_ADDR
// end ; 2 :
6237: GO 6397
6239: LD_INT 2
6241: DOUBLE
6242: EQUAL
6243: IFTRUE 6247
6245: GO 6361
6247: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6248: LD_EXP 18
6252: PPUSH
6253: LD_STRING D8b-JMM-1
6255: PPUSH
6256: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6260: LD_EXP 26
6264: PPUSH
6265: LD_STRING D8b-Ar1-1
6267: PPUSH
6268: CALL_OW 94
// case Query ( QInfo ) of 1 :
6272: LD_STRING QInfo
6274: PPUSH
6275: CALL_OW 97
6279: PUSH
6280: LD_INT 1
6282: DOUBLE
6283: EQUAL
6284: IFTRUE 6288
6286: GO 6323
6288: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6289: LD_EXP 18
6293: PPUSH
6294: LD_STRING D8b1-JMM-1
6296: PPUSH
6297: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6301: LD_EXP 26
6305: PPUSH
6306: LD_STRING D8b1-Ar1-1
6308: PPUSH
6309: CALL_OW 94
// player_want_info := 2 ;
6313: LD_ADDR_EXP 13
6317: PUSH
6318: LD_INT 2
6320: ST_TO_ADDR
// end ; 2 :
6321: GO 6359
6323: LD_INT 2
6325: DOUBLE
6326: EQUAL
6327: IFTRUE 6331
6329: GO 6358
6331: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6332: LD_EXP 18
6336: PPUSH
6337: LD_STRING D8b2-JMM-1
6339: PPUSH
6340: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6344: LD_EXP 26
6348: PPUSH
6349: LD_STRING D8b2-Ar1-1
6351: PPUSH
6352: CALL_OW 94
// end ; end ;
6356: GO 6359
6358: POP
// end ; 3 :
6359: GO 6397
6361: LD_INT 3
6363: DOUBLE
6364: EQUAL
6365: IFTRUE 6369
6367: GO 6396
6369: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6370: LD_EXP 18
6374: PPUSH
6375: LD_STRING D8c-JMM-1
6377: PPUSH
6378: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6382: LD_EXP 26
6386: PPUSH
6387: LD_STRING D8c-Ar1-1
6389: PPUSH
6390: CALL_OW 94
// end ; end ;
6394: GO 6397
6396: POP
// DialogueOff ;
6397: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6401: LD_ADDR_VAR 0 4
6405: PUSH
6406: LD_INT 9
6408: PPUSH
6409: LD_INT 2
6411: PUSH
6412: LD_INT 30
6414: PUSH
6415: LD_INT 0
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PUSH
6422: LD_INT 30
6424: PUSH
6425: LD_INT 1
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: LIST
6436: PPUSH
6437: CALL_OW 70
6441: ST_TO_ADDR
// if dep then
6442: LD_VAR 0 4
6446: IFFALSE 6464
// dep := dep [ 1 ] else
6448: LD_ADDR_VAR 0 4
6452: PUSH
6453: LD_VAR 0 4
6457: PUSH
6458: LD_INT 1
6460: ARRAY
6461: ST_TO_ADDR
6462: GO 6526
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6464: LD_ADDR_VAR 0 4
6468: PUSH
6469: LD_INT 22
6471: PUSH
6472: LD_INT 1
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PUSH
6479: LD_INT 2
6481: PUSH
6482: LD_INT 30
6484: PUSH
6485: LD_INT 0
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: PUSH
6492: LD_INT 30
6494: PUSH
6495: LD_INT 1
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL_OW 69
6515: PPUSH
6516: LD_EXP 27
6520: PPUSH
6521: CALL_OW 74
6525: ST_TO_ADDR
// if not dep then
6526: LD_VAR 0 4
6530: NOT
6531: IFFALSE 6569
// begin case Query ( QInfoNothing ) of 1 :
6533: LD_STRING QInfoNothing
6535: PPUSH
6536: CALL_OW 97
6540: PUSH
6541: LD_INT 1
6543: DOUBLE
6544: EQUAL
6545: IFTRUE 6549
6547: GO 6552
6549: POP
// ; end ;
6550: GO 6553
6552: POP
// player_want_info := false ;
6553: LD_ADDR_EXP 13
6557: PUSH
6558: LD_INT 0
6560: ST_TO_ADDR
// player_want_mortar := false ;
6561: LD_ADDR_EXP 12
6565: PUSH
6566: LD_INT 0
6568: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6569: LD_ADDR_VAR 0 3
6573: PUSH
6574: LD_INT 22
6576: PUSH
6577: LD_INT 2
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: LD_INT 21
6586: PUSH
6587: LD_INT 2
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PPUSH
6598: CALL_OW 69
6602: ST_TO_ADDR
// time := 1 1$35 ;
6603: LD_ADDR_VAR 0 5
6607: PUSH
6608: LD_INT 3325
6610: ST_TO_ADDR
// no_oil_gain := false ;
6611: LD_ADDR_VAR 0 6
6615: PUSH
6616: LD_INT 0
6618: ST_TO_ADDR
// first_warn := false ;
6619: LD_ADDR_VAR 0 7
6623: PUSH
6624: LD_INT 0
6626: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6627: LD_EXP 12
6631: PUSH
6632: LD_EXP 13
6636: OR
6637: IFFALSE 6742
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6639: LD_EXP 33
6643: PPUSH
6644: LD_INT 25
6646: PUSH
6647: LD_INT 1
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PPUSH
6654: CALL_OW 72
6658: PPUSH
6659: LD_VAR 0 4
6663: PPUSH
6664: CALL_OW 250
6668: PPUSH
6669: LD_VAR 0 4
6673: PPUSH
6674: CALL_OW 251
6678: PPUSH
6679: LD_VAR 0 4
6683: PPUSH
6684: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6688: LD_EXP 33
6692: PPUSH
6693: LD_INT 25
6695: PUSH
6696: LD_INT 1
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PPUSH
6703: CALL_OW 72
6707: PPUSH
6708: LD_INT 86
6710: PPUSH
6711: LD_INT 121
6713: PPUSH
6714: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6718: LD_EXP 33
6722: PPUSH
6723: LD_INT 25
6725: PUSH
6726: LD_INT 1
6728: PUSH
6729: EMPTY
6730: LIST
6731: LIST
6732: PPUSH
6733: CALL_OW 72
6737: PPUSH
6738: CALL_OW 200
// end ; if player_attacked_ar then
6742: LD_EXP 16
6746: IFFALSE 6750
// exit ;
6748: GO 9344
// if player_want_mortar then
6750: LD_EXP 12
6754: IFFALSE 8146
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6756: LD_EXP 27
6760: PPUSH
6761: LD_VAR 0 4
6765: PPUSH
6766: CALL_OW 250
6770: PUSH
6771: LD_INT 1
6773: PLUS
6774: PPUSH
6775: LD_VAR 0 4
6779: PPUSH
6780: CALL_OW 251
6784: PUSH
6785: LD_INT 1
6787: PLUS
6788: PPUSH
6789: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6800: LD_EXP 27
6804: PPUSH
6805: LD_VAR 0 4
6809: PPUSH
6810: CALL_OW 296
6814: PUSH
6815: LD_INT 4
6817: LESS
6818: IFFALSE 6793
// for i = 1 to 6 do
6820: LD_ADDR_VAR 0 1
6824: PUSH
6825: DOUBLE
6826: LD_INT 1
6828: DEC
6829: ST_TO_ADDR
6830: LD_INT 6
6832: PUSH
6833: FOR_TO
6834: IFFALSE 7031
// begin if player_attacked_ar then
6836: LD_EXP 16
6840: IFFALSE 6846
// exit ;
6842: POP
6843: POP
6844: GO 9344
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6846: LD_VAR 0 4
6850: PPUSH
6851: CALL_OW 274
6855: PPUSH
6856: LD_INT 2
6858: PPUSH
6859: CALL_OW 275
6863: PUSH
6864: LD_INT 10
6866: LESS
6867: PUSH
6868: LD_VAR 0 7
6872: NOT
6873: AND
6874: IFFALSE 6937
// begin first_warn := true ;
6876: LD_ADDR_VAR 0 7
6880: PUSH
6881: LD_INT 1
6883: ST_TO_ADDR
// DialogueOn ;
6884: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6888: LD_EXP 28
6892: PPUSH
6893: LD_STRING D9a-FAr1-1
6895: PPUSH
6896: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6900: LD_EXP 18
6904: PPUSH
6905: LD_STRING D9a-JMM-1
6907: PPUSH
6908: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6912: LD_EXP 26
6916: PPUSH
6917: LD_STRING D9a2-Ar1-1
6919: PPUSH
6920: CALL_OW 88
// DialogueOff ;
6924: CALL_OW 7
// wait ( time ) ;
6928: LD_VAR 0 5
6932: PPUSH
6933: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6937: LD_VAR 0 4
6941: PPUSH
6942: CALL_OW 274
6946: PPUSH
6947: LD_INT 2
6949: PPUSH
6950: CALL_OW 275
6954: PUSH
6955: LD_INT 10
6957: LESS
6958: IFFALSE 6984
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6960: LD_EXP 26
6964: PPUSH
6965: LD_STRING D9a3-Ar1-1
6967: PPUSH
6968: CALL_OW 88
// no_oil_gain := true ;
6972: LD_ADDR_VAR 0 6
6976: PUSH
6977: LD_INT 1
6979: ST_TO_ADDR
// break ;
6980: GO 7031
// end else
6982: GO 7029
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6984: LD_EXP 27
6988: PPUSH
6989: LD_VAR 0 4
6993: PPUSH
6994: LD_INT 2
6996: PPUSH
6997: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7001: LD_EXP 27
7005: PPUSH
7006: LD_VAR 0 3
7010: PUSH
7011: LD_VAR 0 1
7015: PUSH
7016: LD_INT 3
7018: MOD
7019: PUSH
7020: LD_INT 1
7022: PLUS
7023: ARRAY
7024: PPUSH
7025: CALL_OW 210
// end ; end ;
7029: GO 6833
7031: POP
7032: POP
// if not no_oil_gain then
7033: LD_VAR 0 6
7037: NOT
7038: IFFALSE 8146
// begin repeat wait ( 0 0$01 ) ;
7040: LD_INT 35
7042: PPUSH
7043: CALL_OW 67
// if player_attacked_ar then
7047: LD_EXP 16
7051: IFFALSE 7055
// exit ;
7053: GO 9344
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7055: LD_VAR 0 3
7059: PUSH
7060: LD_INT 1
7062: ARRAY
7063: PPUSH
7064: CALL_OW 261
7068: PUSH
7069: LD_INT 80
7071: GREATER
7072: PUSH
7073: LD_VAR 0 3
7077: PUSH
7078: LD_INT 2
7080: ARRAY
7081: PPUSH
7082: CALL_OW 261
7086: PUSH
7087: LD_INT 80
7089: GREATER
7090: AND
7091: PUSH
7092: LD_VAR 0 3
7096: PUSH
7097: LD_INT 3
7099: ARRAY
7100: PPUSH
7101: CALL_OW 261
7105: PUSH
7106: LD_INT 80
7108: GREATER
7109: AND
7110: IFFALSE 7040
// ComMoveXY ( Gali , 105 , 127 ) ;
7112: LD_EXP 27
7116: PPUSH
7117: LD_INT 105
7119: PPUSH
7120: LD_INT 127
7122: PPUSH
7123: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7127: LD_EXP 27
7131: PPUSH
7132: LD_INT 2
7134: PPUSH
7135: CALL_OW 173
// AddComHold ( Gali ) ;
7139: LD_EXP 27
7143: PPUSH
7144: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7148: LD_INT 35
7150: PPUSH
7151: CALL_OW 67
// if player_attacked_ar then
7155: LD_EXP 16
7159: IFFALSE 7163
// exit ;
7161: GO 9344
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7163: LD_EXP 27
7167: PPUSH
7168: LD_INT 105
7170: PPUSH
7171: LD_INT 127
7173: PPUSH
7174: CALL_OW 297
7178: PUSH
7179: LD_INT 4
7181: LESS
7182: IFFALSE 7148
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7184: LD_VAR 0 4
7188: PPUSH
7189: CALL_OW 274
7193: PPUSH
7194: LD_INT 1
7196: PPUSH
7197: CALL_OW 275
7201: PUSH
7202: LD_INT 50
7204: LESS
7205: IFFALSE 7501
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7207: LD_VAR 0 4
7211: PPUSH
7212: CALL_OW 274
7216: PPUSH
7217: LD_INT 1
7219: PPUSH
7220: CALL_OW 275
7224: PUSH
7225: LD_INT 0
7227: DOUBLE
7228: GREATEREQUAL
7229: IFFALSE 7237
7231: LD_INT 24
7233: DOUBLE
7234: LESSEQUAL
7235: IFTRUE 7239
7237: GO 7254
7239: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7240: LD_EXP 27
7244: PPUSH
7245: LD_STRING D9b-Ar2-1
7247: PPUSH
7248: CALL_OW 88
7252: GO 7284
7254: LD_INT 25
7256: DOUBLE
7257: GREATEREQUAL
7258: IFFALSE 7266
7260: LD_INT 49
7262: DOUBLE
7263: LESSEQUAL
7264: IFTRUE 7268
7266: GO 7283
7268: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7269: LD_EXP 27
7273: PPUSH
7274: LD_STRING D9b-Ar2-1a
7276: PPUSH
7277: CALL_OW 88
7281: GO 7284
7283: POP
// Say ( JMM , D9b-JMM-1 ) ;
7284: LD_EXP 18
7288: PPUSH
7289: LD_STRING D9b-JMM-1
7291: PPUSH
7292: CALL_OW 88
// x := 0 0$0 ;
7296: LD_ADDR_VAR 0 2
7300: PUSH
7301: LD_INT 0
7303: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7304: LD_INT 35
7306: PPUSH
7307: CALL_OW 67
// x := x + 0 0$1 ;
7311: LD_ADDR_VAR 0 2
7315: PUSH
7316: LD_VAR 0 2
7320: PUSH
7321: LD_INT 35
7323: PLUS
7324: ST_TO_ADDR
// if player_attacked_ar then
7325: LD_EXP 16
7329: IFFALSE 7333
// exit ;
7331: GO 9344
// until x >= time ;
7333: LD_VAR 0 2
7337: PUSH
7338: LD_VAR 0 5
7342: GREATEREQUAL
7343: IFFALSE 7304
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7345: LD_VAR 0 4
7349: PPUSH
7350: CALL_OW 274
7354: PPUSH
7355: LD_INT 1
7357: PPUSH
7358: CALL_OW 275
7362: PUSH
7363: LD_INT 50
7365: LESS
7366: IFFALSE 7499
// begin DialogueOn ;
7368: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7372: LD_EXP 26
7376: PPUSH
7377: LD_STRING D9c-Ar1-1
7379: PPUSH
7380: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7384: LD_EXP 18
7388: PPUSH
7389: LD_STRING D9c-JMM-1
7391: PPUSH
7392: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7396: LD_EXP 26
7400: PPUSH
7401: LD_STRING D9c-Ar1-2
7403: PPUSH
7404: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7408: LD_EXP 28
7412: PPUSH
7413: LD_STRING D9c-FAr1-2
7415: PPUSH
7416: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7420: LD_EXP 26
7424: PPUSH
7425: LD_STRING D9c-Ar1-3
7427: PPUSH
7428: CALL_OW 88
// case Query ( QInfo ) of 1 :
7432: LD_STRING QInfo
7434: PPUSH
7435: CALL_OW 97
7439: PUSH
7440: LD_INT 1
7442: DOUBLE
7443: EQUAL
7444: IFTRUE 7448
7446: GO 7471
7448: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7449: LD_EXP 18
7453: PPUSH
7454: LD_STRING D8b1-JMM-1
7456: PPUSH
7457: CALL_OW 88
// player_want_info := 2 ;
7461: LD_ADDR_EXP 13
7465: PUSH
7466: LD_INT 2
7468: ST_TO_ADDR
// end ; 2 :
7469: GO 7495
7471: LD_INT 2
7473: DOUBLE
7474: EQUAL
7475: IFTRUE 7479
7477: GO 7494
7479: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7480: LD_EXP 26
7484: PPUSH
7485: LD_STRING D8b2-Ar1-1
7487: PPUSH
7488: CALL_OW 88
// end ; end ;
7492: GO 7495
7494: POP
// DialogueOff ;
7495: CALL_OW 7
// end ; end else
7499: GO 8146
// begin RemoveEnvironmentArea ( mortarArea ) ;
7501: LD_INT 2
7503: PPUSH
7504: CALL_OW 355
// wait ( 1 ) ;
7508: LD_INT 1
7510: PPUSH
7511: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7515: LD_EXP 27
7519: PPUSH
7520: LD_INT 1
7522: PPUSH
7523: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7527: LD_EXP 27
7531: PPUSH
7532: LD_INT 4
7534: PPUSH
7535: LD_INT 107
7537: PPUSH
7538: LD_INT 131
7540: PPUSH
7541: LD_INT 0
7543: PPUSH
7544: CALL_OW 145
// repeat wait ( 1 ) ;
7548: LD_INT 1
7550: PPUSH
7551: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7555: LD_INT 30
7557: PUSH
7558: LD_INT 4
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PUSH
7565: LD_INT 23
7567: PUSH
7568: LD_INT 2
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PPUSH
7579: CALL_OW 69
7583: IFFALSE 7548
// SetSide ( Gali , 2 ) ;
7585: LD_EXP 27
7589: PPUSH
7590: LD_INT 2
7592: PPUSH
7593: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7597: LD_ADDR_VAR 0 8
7601: PUSH
7602: LD_INT 30
7604: PUSH
7605: LD_INT 4
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 23
7614: PUSH
7615: LD_INT 2
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 69
7630: PUSH
7631: LD_INT 1
7633: ARRAY
7634: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7635: LD_INT 35
7637: PPUSH
7638: CALL_OW 67
// if player_attacked_ar then
7642: LD_EXP 16
7646: IFFALSE 7650
// exit ;
7648: GO 9344
// until BuildingStatus ( b ) <> bs_build ;
7650: LD_VAR 0 8
7654: PPUSH
7655: CALL_OW 461
7659: PUSH
7660: LD_INT 1
7662: NONEQUAL
7663: IFFALSE 7635
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7665: LD_VAR 0 8
7669: PPUSH
7670: CALL_OW 302
7674: PUSH
7675: LD_VAR 0 4
7679: PPUSH
7680: CALL_OW 274
7684: PPUSH
7685: LD_INT 1
7687: PPUSH
7688: CALL_OW 275
7692: PUSH
7693: LD_INT 25
7695: GREATEREQUAL
7696: AND
7697: IFFALSE 7796
// begin ComUpgrade ( b ) ;
7699: LD_VAR 0 8
7703: PPUSH
7704: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7708: LD_EXP 27
7712: PPUSH
7713: LD_STRING h
7715: PUSH
7716: LD_VAR 0 8
7720: PPUSH
7721: CALL_OW 250
7725: PUSH
7726: LD_VAR 0 8
7730: PPUSH
7731: CALL_OW 251
7735: PUSH
7736: LD_VAR 0 8
7740: PUSH
7741: LD_INT 0
7743: PUSH
7744: LD_INT 0
7746: PUSH
7747: LD_INT 0
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: EMPTY
7760: LIST
7761: PPUSH
7762: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// if player_attacked_ar then
7773: LD_EXP 16
7777: IFFALSE 7781
// exit ;
7779: GO 9344
// until BuildingStatus ( b ) <> bs_build ;
7781: LD_VAR 0 8
7785: PPUSH
7786: CALL_OW 461
7790: PUSH
7791: LD_INT 1
7793: NONEQUAL
7794: IFFALSE 7766
// end ; if b then
7796: LD_VAR 0 8
7800: IFFALSE 7811
// CenterNowOnUnits ( b ) ;
7802: LD_VAR 0 8
7806: PPUSH
7807: CALL_OW 87
// DialogueOn ;
7811: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7815: LD_EXP 27
7819: PPUSH
7820: LD_STRING D9d-Ar2-1
7822: PPUSH
7823: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7827: LD_EXP 26
7831: PPUSH
7832: LD_STRING D9d-Ar1-1
7834: PPUSH
7835: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7839: LD_EXP 18
7843: PPUSH
7844: LD_STRING D9d-JMM-1
7846: PPUSH
7847: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7851: LD_EXP 26
7855: PPUSH
7856: LD_STRING D9d-Ar1-2
7858: PPUSH
7859: CALL_OW 88
// DialogueOff ;
7863: CALL_OW 7
// i := [ ] ;
7867: LD_ADDR_VAR 0 1
7871: PUSH
7872: EMPTY
7873: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7874: LD_VAR 0 4
7878: PPUSH
7879: CALL_OW 274
7883: PPUSH
7884: LD_INT 3
7886: PPUSH
7887: CALL_OW 275
7891: PUSH
7892: LD_INT 20
7894: GREATEREQUAL
7895: IFFALSE 7914
// i := i ^ [ 1 ] ;
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: LD_VAR 0 1
7906: PUSH
7907: LD_INT 1
7909: PUSH
7910: EMPTY
7911: LIST
7912: ADD
7913: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7914: LD_VAR 0 4
7918: PPUSH
7919: CALL_OW 274
7923: PPUSH
7924: LD_INT 1
7926: PPUSH
7927: CALL_OW 275
7931: PUSH
7932: LD_INT 50
7934: GREATEREQUAL
7935: IFFALSE 7954
// i := i ^ [ 2 ] ;
7937: LD_ADDR_VAR 0 1
7941: PUSH
7942: LD_VAR 0 1
7946: PUSH
7947: LD_INT 2
7949: PUSH
7950: EMPTY
7951: LIST
7952: ADD
7953: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7954: LD_VAR 0 4
7958: PPUSH
7959: CALL_OW 274
7963: PPUSH
7964: LD_INT 2
7966: PPUSH
7967: CALL_OW 275
7971: PUSH
7972: LD_INT 80
7974: GREATEREQUAL
7975: IFFALSE 7994
// i := i ^ [ 3 ] ;
7977: LD_ADDR_VAR 0 1
7981: PUSH
7982: LD_VAR 0 1
7986: PUSH
7987: LD_INT 3
7989: PUSH
7990: EMPTY
7991: LIST
7992: ADD
7993: ST_TO_ADDR
// i := i diff 0 ;
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: LD_VAR 0 1
8003: PUSH
8004: LD_INT 0
8006: DIFF
8007: ST_TO_ADDR
// if i then
8008: LD_VAR 0 1
8012: IFFALSE 8118
// begin i := i ^ [ 4 ] ;
8014: LD_ADDR_VAR 0 1
8018: PUSH
8019: LD_VAR 0 1
8023: PUSH
8024: LD_INT 4
8026: PUSH
8027: EMPTY
8028: LIST
8029: ADD
8030: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8031: LD_STRING QInfo2
8033: PPUSH
8034: CALL_OW 97
8038: PUSH
8039: LD_INT 1
8041: DOUBLE
8042: EQUAL
8043: IFTRUE 8047
8045: GO 8058
8047: POP
// player_want_info := 3 ; 2 :
8048: LD_ADDR_EXP 13
8052: PUSH
8053: LD_INT 3
8055: ST_TO_ADDR
8056: GO 8116
8058: LD_INT 2
8060: DOUBLE
8061: EQUAL
8062: IFTRUE 8066
8064: GO 8077
8066: POP
// player_want_info := 1 ; 3 :
8067: LD_ADDR_EXP 13
8071: PUSH
8072: LD_INT 1
8074: ST_TO_ADDR
8075: GO 8116
8077: LD_INT 3
8079: DOUBLE
8080: EQUAL
8081: IFTRUE 8085
8083: GO 8096
8085: POP
// player_want_info := 2 ; 4 :
8086: LD_ADDR_EXP 13
8090: PUSH
8091: LD_INT 2
8093: ST_TO_ADDR
8094: GO 8116
8096: LD_INT 4
8098: DOUBLE
8099: EQUAL
8100: IFTRUE 8104
8102: GO 8115
8104: POP
// player_want_info := 0 ; end ;
8105: LD_ADDR_EXP 13
8109: PUSH
8110: LD_INT 0
8112: ST_TO_ADDR
8113: GO 8116
8115: POP
// end else
8116: GO 8146
// case Query ( QInfoNothing ) of 1 :
8118: LD_STRING QInfoNothing
8120: PPUSH
8121: CALL_OW 97
8125: PUSH
8126: LD_INT 1
8128: DOUBLE
8129: EQUAL
8130: IFTRUE 8134
8132: GO 8145
8134: POP
// player_want_info := 0 ; end ;
8135: LD_ADDR_EXP 13
8139: PUSH
8140: LD_INT 0
8142: ST_TO_ADDR
8143: GO 8146
8145: POP
// end ; end ; end ; if player_want_info then
8146: LD_EXP 13
8150: IFFALSE 9164
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8152: LD_ADDR_VAR 0 3
8156: PUSH
8157: LD_VAR 0 3
8161: PPUSH
8162: LD_INT 34
8164: PUSH
8165: LD_INT 32
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PPUSH
8172: CALL_OW 72
8176: ST_TO_ADDR
// if player_want_mortar then
8177: LD_EXP 12
8181: IFFALSE 8503
// begin case player_want_info of 1 :
8183: LD_EXP 13
8187: PUSH
8188: LD_INT 1
8190: DOUBLE
8191: EQUAL
8192: IFTRUE 8196
8194: GO 8207
8196: POP
// x := 5 ; 2 :
8197: LD_ADDR_VAR 0 2
8201: PUSH
8202: LD_INT 5
8204: ST_TO_ADDR
8205: GO 8246
8207: LD_INT 2
8209: DOUBLE
8210: EQUAL
8211: IFTRUE 8215
8213: GO 8226
8215: POP
// x := 8 ; 3 :
8216: LD_ADDR_VAR 0 2
8220: PUSH
8221: LD_INT 8
8223: ST_TO_ADDR
8224: GO 8246
8226: LD_INT 3
8228: DOUBLE
8229: EQUAL
8230: IFTRUE 8234
8232: GO 8245
8234: POP
// x := 2 ; end ;
8235: LD_ADDR_VAR 0 2
8239: PUSH
8240: LD_INT 2
8242: ST_TO_ADDR
8243: GO 8246
8245: POP
// repeat wait ( 0 0$1 ) ;
8246: LD_INT 35
8248: PPUSH
8249: CALL_OW 67
// until not HasTask ( Gali ) ;
8253: LD_EXP 27
8257: PPUSH
8258: CALL_OW 314
8262: NOT
8263: IFFALSE 8246
// for i = 1 to x do
8265: LD_ADDR_VAR 0 1
8269: PUSH
8270: DOUBLE
8271: LD_INT 1
8273: DEC
8274: ST_TO_ADDR
8275: LD_VAR 0 2
8279: PUSH
8280: FOR_TO
8281: IFFALSE 8446
// begin AddComTransport ( Gali , dep , player_want_info ) ;
8283: LD_EXP 27
8287: PPUSH
8288: LD_VAR 0 4
8292: PPUSH
8293: LD_EXP 13
8297: PPUSH
8298: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
8302: LD_EXP 27
8306: PPUSH
8307: LD_VAR 0 3
8311: PUSH
8312: LD_INT 1
8314: ARRAY
8315: PPUSH
8316: CALL_OW 172
// AddComHold ( Gali ) ;
8320: LD_EXP 27
8324: PPUSH
8325: CALL_OW 200
// repeat wait ( 3 ) ;
8329: LD_INT 3
8331: PPUSH
8332: CALL_OW 67
// if player_attacked_ar then
8336: LD_EXP 16
8340: IFFALSE 8346
// exit ;
8342: POP
8343: POP
8344: GO 9344
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
8346: LD_EXP 27
8350: PPUSH
8351: LD_VAR 0 3
8355: PUSH
8356: LD_INT 1
8358: ARRAY
8359: PPUSH
8360: CALL_OW 296
8364: PUSH
8365: LD_INT 4
8367: LESS
8368: PUSH
8369: LD_EXP 27
8373: PPUSH
8374: LD_EXP 13
8378: PPUSH
8379: CALL_OW 289
8383: AND
8384: IFFALSE 8329
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8386: LD_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_EXP 13
8399: PPUSH
8400: LD_VAR 0 3
8404: PUSH
8405: LD_INT 1
8407: ARRAY
8408: PPUSH
8409: LD_EXP 13
8413: PPUSH
8414: CALL_OW 289
8418: PUSH
8419: LD_INT 10
8421: PLUS
8422: PPUSH
8423: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8427: LD_EXP 27
8431: PPUSH
8432: LD_EXP 13
8436: PPUSH
8437: LD_INT 0
8439: PPUSH
8440: CALL_OW 290
// end ;
8444: GO 8280
8446: POP
8447: POP
// repeat wait ( 0 0$1 ) ;
8448: LD_INT 35
8450: PPUSH
8451: CALL_OW 67
// if player_attacked_ar then
8455: LD_EXP 16
8459: IFFALSE 8463
// exit ;
8461: GO 9344
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8463: LD_VAR 0 3
8467: PUSH
8468: LD_INT 1
8470: ARRAY
8471: PPUSH
8472: LD_EXP 13
8476: PPUSH
8477: CALL_OW 289
8481: PUSH
8482: LD_VAR 0 2
8486: PUSH
8487: LD_INT 10
8489: MUL
8490: EQUAL
8491: IFFALSE 8448
// no_oil_gain := false ;
8493: LD_ADDR_VAR 0 6
8497: PUSH
8498: LD_INT 0
8500: ST_TO_ADDR
// end else
8501: GO 8985
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: LD_INT 22
8510: PUSH
8511: LD_INT 2
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PUSH
8518: LD_INT 21
8520: PUSH
8521: LD_INT 2
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PUSH
8528: EMPTY
8529: LIST
8530: LIST
8531: PPUSH
8532: CALL_OW 69
8536: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8537: LD_EXP 27
8541: PPUSH
8542: LD_VAR 0 4
8546: PPUSH
8547: CALL_OW 250
8551: PUSH
8552: LD_INT 1
8554: PLUS
8555: PPUSH
8556: LD_VAR 0 4
8560: PPUSH
8561: CALL_OW 251
8565: PUSH
8566: LD_INT 1
8568: PLUS
8569: PPUSH
8570: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8574: LD_INT 35
8576: PPUSH
8577: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8581: LD_EXP 27
8585: PPUSH
8586: LD_VAR 0 4
8590: PPUSH
8591: CALL_OW 296
8595: PUSH
8596: LD_INT 4
8598: LESS
8599: IFFALSE 8574
// for i = 1 to 6 do
8601: LD_ADDR_VAR 0 1
8605: PUSH
8606: DOUBLE
8607: LD_INT 1
8609: DEC
8610: ST_TO_ADDR
8611: LD_INT 6
8613: PUSH
8614: FOR_TO
8615: IFFALSE 8812
// begin if player_attacked_ar then
8617: LD_EXP 16
8621: IFFALSE 8627
// exit ;
8623: POP
8624: POP
8625: GO 9344
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8627: LD_VAR 0 4
8631: PPUSH
8632: CALL_OW 274
8636: PPUSH
8637: LD_INT 2
8639: PPUSH
8640: CALL_OW 275
8644: PUSH
8645: LD_INT 10
8647: LESS
8648: PUSH
8649: LD_VAR 0 7
8653: NOT
8654: AND
8655: IFFALSE 8718
// begin first_warn := true ;
8657: LD_ADDR_VAR 0 7
8661: PUSH
8662: LD_INT 1
8664: ST_TO_ADDR
// DialogueOn ;
8665: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8669: LD_EXP 28
8673: PPUSH
8674: LD_STRING D9a-FAr1-1
8676: PPUSH
8677: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8681: LD_EXP 18
8685: PPUSH
8686: LD_STRING D9a-JMM-1
8688: PPUSH
8689: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8693: LD_EXP 26
8697: PPUSH
8698: LD_STRING D9a2-Ar1-1
8700: PPUSH
8701: CALL_OW 88
// DialogueOff ;
8705: CALL_OW 7
// wait ( time ) ;
8709: LD_VAR 0 5
8713: PPUSH
8714: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8718: LD_VAR 0 4
8722: PPUSH
8723: CALL_OW 274
8727: PPUSH
8728: LD_INT 2
8730: PPUSH
8731: CALL_OW 275
8735: PUSH
8736: LD_INT 10
8738: LESS
8739: IFFALSE 8765
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8741: LD_EXP 26
8745: PPUSH
8746: LD_STRING D9a3-Ar1-1
8748: PPUSH
8749: CALL_OW 88
// no_oil_gain := true ;
8753: LD_ADDR_VAR 0 6
8757: PUSH
8758: LD_INT 1
8760: ST_TO_ADDR
// break ;
8761: GO 8812
// end else
8763: GO 8810
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8765: LD_EXP 27
8769: PPUSH
8770: LD_VAR 0 4
8774: PPUSH
8775: LD_INT 2
8777: PPUSH
8778: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8782: LD_EXP 27
8786: PPUSH
8787: LD_VAR 0 3
8791: PUSH
8792: LD_VAR 0 1
8796: PUSH
8797: LD_INT 3
8799: MOD
8800: PUSH
8801: LD_INT 1
8803: PLUS
8804: ARRAY
8805: PPUSH
8806: CALL_OW 210
// end ; end ;
8810: GO 8614
8812: POP
8813: POP
// repeat wait ( 0 0$1 ) ;
8814: LD_INT 35
8816: PPUSH
8817: CALL_OW 67
// if player_attacked_ar then
8821: LD_EXP 16
8825: IFFALSE 8829
// exit ;
8827: GO 9344
// for i in tmp do
8829: LD_ADDR_VAR 0 1
8833: PUSH
8834: LD_VAR 0 3
8838: PUSH
8839: FOR_IN
8840: IFFALSE 8871
// if GetFuel ( i ) < 100 then
8842: LD_VAR 0 1
8846: PPUSH
8847: CALL_OW 261
8851: PUSH
8852: LD_INT 100
8854: LESS
8855: IFFALSE 8869
// begin x := i ;
8857: LD_ADDR_VAR 0 2
8861: PUSH
8862: LD_VAR 0 1
8866: ST_TO_ADDR
// break ;
8867: GO 8871
// end ;
8869: GO 8839
8871: POP
8872: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8873: LD_EXP 27
8877: PPUSH
8878: CALL_OW 314
8882: NOT
8883: PUSH
8884: LD_EXP 27
8888: PPUSH
8889: CALL_OW 281
8893: NOT
8894: AND
8895: IFFALSE 8928
// begin ComTransport ( Gali , dep , mat_oil ) ;
8897: LD_EXP 27
8901: PPUSH
8902: LD_VAR 0 4
8906: PPUSH
8907: LD_INT 2
8909: PPUSH
8910: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8914: LD_EXP 27
8918: PPUSH
8919: LD_VAR 0 2
8923: PPUSH
8924: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8928: LD_VAR 0 3
8932: PUSH
8933: LD_INT 1
8935: ARRAY
8936: PPUSH
8937: CALL_OW 261
8941: PUSH
8942: LD_INT 80
8944: GREATER
8945: PUSH
8946: LD_VAR 0 3
8950: PUSH
8951: LD_INT 2
8953: ARRAY
8954: PPUSH
8955: CALL_OW 261
8959: PUSH
8960: LD_INT 80
8962: GREATER
8963: AND
8964: PUSH
8965: LD_VAR 0 3
8969: PUSH
8970: LD_INT 3
8972: ARRAY
8973: PPUSH
8974: CALL_OW 261
8978: PUSH
8979: LD_INT 80
8981: GREATER
8982: AND
8983: IFFALSE 8814
// end ; ComHold ( Gali ) ;
8985: LD_EXP 27
8989: PPUSH
8990: CALL_OW 140
// if not no_oil_gain then
8994: LD_VAR 0 6
8998: NOT
8999: IFFALSE 9164
// begin DialogueOn ;
9001: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9005: LD_EXP 26
9009: PPUSH
9010: CALL_OW 87
// if player_want_mortar then
9014: LD_EXP 12
9018: IFFALSE 9044
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9020: LD_EXP 26
9024: PPUSH
9025: LD_STRING D9e-Ar1-1
9027: PPUSH
9028: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9032: LD_EXP 18
9036: PPUSH
9037: LD_STRING D10a-JMM-1
9039: PPUSH
9040: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9044: LD_EXP 26
9048: PPUSH
9049: LD_STRING D10a-Ar1-1
9051: PPUSH
9052: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9056: LD_EXP 27
9060: PPUSH
9061: LD_STRING D10a-Ar2-1
9063: PPUSH
9064: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9068: LD_EXP 28
9072: PPUSH
9073: LD_STRING D10a-FAr1-1
9075: PPUSH
9076: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9080: LD_EXP 27
9084: PPUSH
9085: LD_STRING D10a-Ar2-2
9087: PPUSH
9088: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9092: LD_EXP 28
9096: PPUSH
9097: LD_STRING D10a-FAr1-2
9099: PPUSH
9100: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9104: LD_EXP 26
9108: PPUSH
9109: LD_STRING D10a-Ar1-2
9111: PPUSH
9112: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9116: LD_EXP 18
9120: PPUSH
9121: LD_STRING D10a-JMM-2
9123: PPUSH
9124: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9128: LD_EXP 26
9132: PPUSH
9133: LD_STRING D10a-Ar1-3
9135: PPUSH
9136: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9140: LD_EXP 18
9144: PPUSH
9145: LD_STRING D10a-JMM-3
9147: PPUSH
9148: CALL_OW 88
// player_get_info := true ;
9152: LD_ADDR_EXP 15
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// DialogueOff ;
9160: CALL_OW 7
// end ; end ; if player_attacked_ar then
9164: LD_EXP 16
9168: IFFALSE 9172
// exit ;
9170: GO 9344
// if player_want_mortar or player_want_info then
9172: LD_EXP 12
9176: PUSH
9177: LD_EXP 13
9181: OR
9182: IFFALSE 9196
// Say ( Vervecken , D9f-Ar1-1 ) ;
9184: LD_EXP 26
9188: PPUSH
9189: LD_STRING D9f-Ar1-1
9191: PPUSH
9192: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9196: LD_INT 22
9198: PUSH
9199: LD_INT 2
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PPUSH
9206: CALL_OW 69
9210: PPUSH
9211: LD_INT 51
9213: PPUSH
9214: LD_INT 99
9216: PPUSH
9217: CALL_OW 111
// wait ( 0 0$1 ) ;
9221: LD_INT 35
9223: PPUSH
9224: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9228: LD_INT 22
9230: PUSH
9231: LD_INT 2
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: PUSH
9238: LD_INT 92
9240: PUSH
9241: LD_INT 51
9243: PUSH
9244: LD_INT 99
9246: PUSH
9247: LD_INT 2
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: LIST
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: PPUSH
9260: CALL_OW 69
9264: IFFALSE 9324
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9266: LD_ADDR_VAR 0 1
9270: PUSH
9271: LD_INT 22
9273: PUSH
9274: LD_INT 2
9276: PUSH
9277: EMPTY
9278: LIST
9279: LIST
9280: PUSH
9281: LD_INT 92
9283: PUSH
9284: LD_INT 51
9286: PUSH
9287: LD_INT 99
9289: PUSH
9290: LD_INT 2
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: LIST
9297: LIST
9298: PUSH
9299: EMPTY
9300: LIST
9301: LIST
9302: PPUSH
9303: CALL_OW 69
9307: PUSH
9308: FOR_IN
9309: IFFALSE 9322
// RemoveUnit ( i ) ;
9311: LD_VAR 0 1
9315: PPUSH
9316: CALL_OW 64
9320: GO 9308
9322: POP
9323: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9324: LD_INT 22
9326: PUSH
9327: LD_INT 2
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PPUSH
9334: CALL_OW 69
9338: PUSH
9339: LD_INT 0
9341: EQUAL
9342: IFFALSE 9196
// end ;
9344: PPOPN 8
9346: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9347: LD_EXP 16
9351: IFFALSE 9704
9353: GO 9355
9355: DISABLE
9356: LD_INT 0
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin ru_can_attack := true ;
9362: LD_ADDR_EXP 8
9366: PUSH
9367: LD_INT 1
9369: ST_TO_ADDR
// mine_launched := false ;
9370: LD_ADDR_VAR 0 3
9374: PUSH
9375: LD_INT 0
9377: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9378: LD_INT 22
9380: PUSH
9381: LD_INT 2
9383: PUSH
9384: EMPTY
9385: LIST
9386: LIST
9387: PPUSH
9388: CALL_OW 69
9392: PPUSH
9393: LD_INT 51
9395: PPUSH
9396: LD_INT 99
9398: PPUSH
9399: CALL_OW 111
// if IsOk ( Vervecken ) then
9403: LD_EXP 26
9407: PPUSH
9408: CALL_OW 302
9412: IFFALSE 9426
// Say ( Vervecken , D11a-Ar1-1 ) ;
9414: LD_EXP 26
9418: PPUSH
9419: LD_STRING D11a-Ar1-1
9421: PPUSH
9422: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9426: LD_ADDR_VAR 0 2
9430: PUSH
9431: LD_EXP 33
9435: PPUSH
9436: LD_INT 25
9438: PUSH
9439: LD_INT 1
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PPUSH
9446: CALL_OW 72
9450: ST_TO_ADDR
// for i in tmp do
9451: LD_ADDR_VAR 0 1
9455: PUSH
9456: LD_VAR 0 2
9460: PUSH
9461: FOR_IN
9462: IFFALSE 9525
// if MineOfUnit ( i ) then
9464: LD_VAR 0 1
9468: PPUSH
9469: CALL_OW 459
9473: IFFALSE 9523
// begin x := MineOfUnit ( i ) ;
9475: LD_ADDR_VAR 0 4
9479: PUSH
9480: LD_VAR 0 1
9484: PPUSH
9485: CALL_OW 459
9489: ST_TO_ADDR
// mine_launched := true ;
9490: LD_ADDR_VAR 0 3
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9498: LD_VAR 0 4
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: LD_VAR 0 4
9511: PUSH
9512: LD_INT 2
9514: ARRAY
9515: PPUSH
9516: LD_INT 2
9518: PPUSH
9519: CALL_OW 456
// end ;
9523: GO 9461
9525: POP
9526: POP
// if mine_launched and IsOk ( Vervecken ) then
9527: LD_VAR 0 3
9531: PUSH
9532: LD_EXP 26
9536: PPUSH
9537: CALL_OW 302
9541: AND
9542: IFFALSE 9556
// Say ( Vervecken , D11b-Ar1-1 ) ;
9544: LD_EXP 26
9548: PPUSH
9549: LD_STRING D11b-Ar1-1
9551: PPUSH
9552: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9556: LD_INT 22
9558: PUSH
9559: LD_INT 2
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: PPUSH
9566: CALL_OW 69
9570: PPUSH
9571: LD_INT 51
9573: PPUSH
9574: LD_INT 99
9576: PPUSH
9577: CALL_OW 111
// wait ( 0 0$1 ) ;
9581: LD_INT 35
9583: PPUSH
9584: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9588: LD_INT 22
9590: PUSH
9591: LD_INT 2
9593: PUSH
9594: EMPTY
9595: LIST
9596: LIST
9597: PUSH
9598: LD_INT 92
9600: PUSH
9601: LD_INT 51
9603: PUSH
9604: LD_INT 99
9606: PUSH
9607: LD_INT 2
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: PPUSH
9620: CALL_OW 69
9624: IFFALSE 9684
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9626: LD_ADDR_VAR 0 1
9630: PUSH
9631: LD_INT 22
9633: PUSH
9634: LD_INT 2
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: PUSH
9641: LD_INT 92
9643: PUSH
9644: LD_INT 51
9646: PUSH
9647: LD_INT 99
9649: PUSH
9650: LD_INT 2
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: PPUSH
9663: CALL_OW 69
9667: PUSH
9668: FOR_IN
9669: IFFALSE 9682
// RemoveUnit ( i ) ;
9671: LD_VAR 0 1
9675: PPUSH
9676: CALL_OW 64
9680: GO 9668
9682: POP
9683: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9684: LD_INT 22
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PPUSH
9694: CALL_OW 69
9698: PUSH
9699: LD_INT 0
9701: EQUAL
9702: IFFALSE 9556
// end ;
9704: PPOPN 4
9706: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9707: LD_EXP 10
9711: IFFALSE 9890
9713: GO 9715
9715: DISABLE
9716: LD_INT 0
9718: PPUSH
// begin Wait ( 10 10$00 ) ;
9719: LD_INT 21000
9721: PPUSH
9722: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9726: LD_INT 22
9728: PUSH
9729: LD_INT 2
9731: PUSH
9732: EMPTY
9733: LIST
9734: LIST
9735: PPUSH
9736: CALL_OW 69
9740: IFFALSE 9890
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9742: LD_INT 22
9744: PUSH
9745: LD_INT 2
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: PPUSH
9752: CALL_OW 69
9756: PPUSH
9757: LD_INT 51
9759: PPUSH
9760: LD_INT 99
9762: PPUSH
9763: CALL_OW 114
// wait ( 0 0$1 ) ;
9767: LD_INT 35
9769: PPUSH
9770: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9774: LD_INT 22
9776: PUSH
9777: LD_INT 2
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: LD_INT 92
9786: PUSH
9787: LD_INT 51
9789: PUSH
9790: LD_INT 99
9792: PUSH
9793: LD_INT 2
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: PUSH
9802: EMPTY
9803: LIST
9804: LIST
9805: PPUSH
9806: CALL_OW 69
9810: IFFALSE 9870
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9812: LD_ADDR_VAR 0 1
9816: PUSH
9817: LD_INT 22
9819: PUSH
9820: LD_INT 2
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: PUSH
9827: LD_INT 92
9829: PUSH
9830: LD_INT 51
9832: PUSH
9833: LD_INT 99
9835: PUSH
9836: LD_INT 2
9838: PUSH
9839: EMPTY
9840: LIST
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: PUSH
9854: FOR_IN
9855: IFFALSE 9868
// RemoveUnit ( i ) ;
9857: LD_VAR 0 1
9861: PPUSH
9862: CALL_OW 64
9866: GO 9854
9868: POP
9869: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9870: LD_INT 22
9872: PUSH
9873: LD_INT 2
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: PPUSH
9880: CALL_OW 69
9884: PUSH
9885: LD_INT 0
9887: EQUAL
9888: IFFALSE 9742
// end ; end ;
9890: PPOPN 1
9892: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9893: LD_EXP 4
9897: IFFALSE 10825
9899: GO 9901
9901: DISABLE
9902: LD_INT 0
9904: PPUSH
9905: PPUSH
9906: PPUSH
// begin Wait ( game_time ) ;
9907: LD_EXP 7
9911: PPUSH
9912: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9916: LD_INT 35
9918: PPUSH
9919: CALL_OW 67
// until ( not ru_can_attack ) ;
9923: LD_EXP 8
9927: NOT
9928: IFFALSE 9916
// Wait ( 0 0$35 ) ;
9930: LD_INT 1225
9932: PPUSH
9933: CALL_OW 67
// DialogueOn ;
9937: CALL_OW 6
// InGameOn ;
9941: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9945: LD_EXP 25
9949: PPUSH
9950: LD_STRING D12-Pow-1
9952: PPUSH
9953: CALL_OW 94
// InGameOff ;
9957: CALL_OW 9
// DialogueOff ;
9961: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9965: LD_STRING M4
9967: PPUSH
9968: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9972: LD_INT 5
9974: PPUSH
9975: LD_INT 1
9977: PPUSH
9978: CALL_OW 424
// can_end := true ;
9982: LD_ADDR_EXP 17
9986: PUSH
9987: LD_INT 1
9989: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9990: LD_INT 35
9992: PPUSH
9993: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9997: CALL 784 0 0
10001: PUSH
10002: LD_INT 20
10004: GREATEREQUAL
10005: PUSH
10006: LD_INT 22
10008: PUSH
10009: LD_INT 1
10011: PUSH
10012: EMPTY
10013: LIST
10014: LIST
10015: PUSH
10016: LD_INT 21
10018: PUSH
10019: LD_INT 1
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PPUSH
10030: CALL_OW 69
10034: PUSH
10035: LD_INT 5
10037: PPUSH
10038: LD_INT 22
10040: PUSH
10041: LD_INT 1
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PUSH
10048: LD_INT 21
10050: PUSH
10051: LD_INT 1
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: PPUSH
10062: CALL_OW 70
10066: PUSH
10067: LD_INT 22
10069: PUSH
10070: LD_INT 1
10072: PUSH
10073: EMPTY
10074: LIST
10075: LIST
10076: PUSH
10077: LD_INT 55
10079: PUSH
10080: EMPTY
10081: LIST
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: PPUSH
10087: CALL_OW 69
10091: PLUS
10092: LESSEQUAL
10093: AND
10094: IFFALSE 9990
// if not player_get_info then
10096: LD_EXP 15
10100: NOT
10101: IFFALSE 10112
// player_get_info := - 1 ;
10103: LD_ADDR_EXP 15
10107: PUSH
10108: LD_INT 1
10110: NEG
10111: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10112: LD_STRING Information
10114: PPUSH
10115: LD_EXP 15
10119: PPUSH
10120: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10124: LD_ADDR_VAR 0 2
10128: PUSH
10129: LD_INT 22
10131: PUSH
10132: LD_INT 1
10134: PUSH
10135: EMPTY
10136: LIST
10137: LIST
10138: PUSH
10139: LD_INT 2
10141: PUSH
10142: LD_INT 25
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 25
10154: PUSH
10155: LD_INT 16
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PUSH
10162: LD_INT 34
10164: PUSH
10165: LD_INT 12
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PUSH
10172: EMPTY
10173: LIST
10174: LIST
10175: LIST
10176: LIST
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL_OW 69
10186: ST_TO_ADDR
// sib := GetTerminalCargo ;
10187: LD_ADDR_VAR 0 3
10191: PUSH
10192: CALL 784 0 0
10196: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10197: LD_ADDR_VAR 0 3
10201: PUSH
10202: LD_VAR 0 3
10206: PUSH
10207: LD_INT 6
10209: PPUSH
10210: LD_INT 3
10212: PPUSH
10213: CALL_OW 287
10217: PLUS
10218: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10219: LD_ADDR_VAR 0 3
10223: PUSH
10224: LD_VAR 0 3
10228: PUSH
10229: LD_VAR 0 2
10233: PPUSH
10234: LD_INT 3
10236: PPUSH
10237: CALL_OW 289
10241: PLUS
10242: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10243: LD_VAR 0 3
10247: PUSH
10248: LD_INT 2
10250: PUSH
10251: LD_OWVAR 67
10255: PLUS
10256: PUSH
10257: LD_INT 50
10259: MUL
10260: LESS
10261: IFFALSE 10286
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10263: LD_STRING MuchSiberite
10265: PPUSH
10266: LD_INT 2
10268: NEG
10269: PUSH
10270: LD_OWVAR 67
10274: MUL
10275: PUSH
10276: LD_INT 1
10278: PLUS
10279: PPUSH
10280: CALL_OW 101
10284: GO 10296
// AddMedal ( MuchSiberite , 1 ) ;
10286: LD_STRING MuchSiberite
10288: PPUSH
10289: LD_INT 1
10291: PPUSH
10292: CALL_OW 101
// GiveMedals ( MAIN ) ;
10296: LD_STRING MAIN
10298: PPUSH
10299: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10303: LD_INT 22
10305: PUSH
10306: LD_INT 1
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 2
10315: PUSH
10316: LD_INT 25
10318: PUSH
10319: LD_INT 1
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: PUSH
10326: LD_INT 25
10328: PUSH
10329: LD_INT 2
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 25
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PUSH
10346: LD_INT 25
10348: PUSH
10349: LD_INT 4
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: LD_INT 25
10358: PUSH
10359: LD_INT 8
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: PPUSH
10378: CALL_OW 69
10382: PPUSH
10383: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10387: LD_ADDR_VAR 0 2
10391: PUSH
10392: LD_INT 22
10394: PUSH
10395: LD_INT 1
10397: PUSH
10398: EMPTY
10399: LIST
10400: LIST
10401: PUSH
10402: LD_INT 25
10404: PUSH
10405: LD_INT 8
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PPUSH
10416: CALL_OW 69
10420: ST_TO_ADDR
// if tmp then
10421: LD_VAR 0 2
10425: IFFALSE 10456
// for i in tmp do
10427: LD_ADDR_VAR 0 1
10431: PUSH
10432: LD_VAR 0 2
10436: PUSH
10437: FOR_IN
10438: IFFALSE 10454
// SetClass ( i , 1 ) ;
10440: LD_VAR 0 1
10444: PPUSH
10445: LD_INT 1
10447: PPUSH
10448: CALL_OW 336
10452: GO 10437
10454: POP
10455: POP
// SaveVariable ( sib , 09_sibRes ) ;
10456: LD_VAR 0 3
10460: PPUSH
10461: LD_STRING 09_sibRes
10463: PPUSH
10464: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10468: LD_EXP 15
10472: PPUSH
10473: LD_STRING 09_arInfo
10475: PPUSH
10476: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10480: LD_EXP 18
10484: PPUSH
10485: LD_EXP 1
10489: PUSH
10490: LD_STRING JMM
10492: STR
10493: PPUSH
10494: CALL_OW 38
// if IsLive ( Gary ) then
10498: LD_EXP 19
10502: PPUSH
10503: CALL_OW 300
10507: IFFALSE 10527
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10509: LD_EXP 19
10513: PPUSH
10514: LD_EXP 1
10518: PUSH
10519: LD_STRING Gary
10521: STR
10522: PPUSH
10523: CALL_OW 38
// if IsLive ( Bobby ) then
10527: LD_EXP 20
10531: PPUSH
10532: CALL_OW 300
10536: IFFALSE 10556
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10538: LD_EXP 20
10542: PPUSH
10543: LD_EXP 1
10547: PUSH
10548: LD_STRING Bobby
10550: STR
10551: PPUSH
10552: CALL_OW 38
// if IsLive ( Cyrus ) then
10556: LD_EXP 21
10560: PPUSH
10561: CALL_OW 300
10565: IFFALSE 10585
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10567: LD_EXP 21
10571: PPUSH
10572: LD_EXP 1
10576: PUSH
10577: LD_STRING Cyrus
10579: STR
10580: PPUSH
10581: CALL_OW 38
// if IsLive ( Houten ) then
10585: LD_EXP 22
10589: PPUSH
10590: CALL_OW 300
10594: IFFALSE 10614
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10596: LD_EXP 22
10600: PPUSH
10601: LD_EXP 1
10605: PUSH
10606: LD_STRING Houten
10608: STR
10609: PPUSH
10610: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
10614: LD_ADDR_VAR 0 2
10618: PUSH
10619: LD_INT 22
10621: PUSH
10622: LD_INT 1
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: PUSH
10629: LD_INT 2
10631: PUSH
10632: LD_INT 25
10634: PUSH
10635: LD_INT 1
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: PUSH
10642: LD_INT 25
10644: PUSH
10645: LD_INT 2
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: PUSH
10652: LD_INT 25
10654: PUSH
10655: LD_INT 3
10657: PUSH
10658: EMPTY
10659: LIST
10660: LIST
10661: PUSH
10662: LD_INT 25
10664: PUSH
10665: LD_INT 4
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: LIST
10676: LIST
10677: LIST
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PPUSH
10683: CALL_OW 69
10687: PUSH
10688: LD_EXP 18
10692: PUSH
10693: LD_EXP 21
10697: PUSH
10698: LD_EXP 20
10702: PUSH
10703: LD_EXP 22
10707: PUSH
10708: LD_EXP 19
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: DIFF
10720: ST_TO_ADDR
// if tmp then
10721: LD_VAR 0 2
10725: IFFALSE 10745
// SaveCharacters ( tmp , mission_prefix & others ) ;
10727: LD_VAR 0 2
10731: PPUSH
10732: LD_EXP 1
10736: PUSH
10737: LD_STRING others
10739: STR
10740: PPUSH
10741: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
10745: LD_ADDR_VAR 0 2
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 1
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: LD_INT 2
10762: PUSH
10763: LD_INT 25
10765: PUSH
10766: LD_INT 12
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PUSH
10773: LD_INT 25
10775: PUSH
10776: LD_INT 16
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: PUSH
10783: EMPTY
10784: LIST
10785: LIST
10786: LIST
10787: PUSH
10788: EMPTY
10789: LIST
10790: LIST
10791: PPUSH
10792: CALL_OW 69
10796: ST_TO_ADDR
// if tmp then
10797: LD_VAR 0 2
10801: IFFALSE 10821
// SaveCharacters ( tmp , mission_prefix & apes ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: LD_EXP 1
10812: PUSH
10813: LD_STRING apes
10815: STR
10816: PPUSH
10817: CALL_OW 38
// YouWin ;
10821: CALL_OW 103
// end ; end_of_file
10825: PPOPN 3
10827: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10828: LD_VAR 0 1
10832: PPUSH
10833: CALL_OW 266
10837: PUSH
10838: LD_INT 0
10840: EQUAL
10841: PUSH
10842: LD_EXP 3
10846: NOT
10847: AND
10848: IFFALSE 10872
// begin terminal := b ;
10850: LD_ADDR_EXP 3
10854: PUSH
10855: LD_VAR 0 1
10859: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10860: LD_EXP 3
10864: PPUSH
10865: LD_STRING terminal
10867: PPUSH
10868: CALL_OW 500
// end ; end ;
10872: PPOPN 2
10874: END
// on BuildingComplete ( b ) do var i ;
10875: LD_INT 0
10877: PPUSH
// begin if GetSide ( b ) = 3 then
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 255
10887: PUSH
10888: LD_INT 3
10890: EQUAL
10891: IFFALSE 10931
// for i = 1 to 4 do
10893: LD_ADDR_VAR 0 2
10897: PUSH
10898: DOUBLE
10899: LD_INT 1
10901: DEC
10902: ST_TO_ADDR
10903: LD_INT 4
10905: PUSH
10906: FOR_TO
10907: IFFALSE 10929
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10909: LD_ADDR_EXP 36
10913: PUSH
10914: LD_EXP 36
10918: PPUSH
10919: LD_INT 1
10921: PPUSH
10922: CALL_OW 3
10926: ST_TO_ADDR
10927: GO 10906
10929: POP
10930: POP
// end ;
10931: PPOPN 2
10933: END
// on VehicleConstructed ( veh , fac ) do var i ;
10934: LD_INT 0
10936: PPUSH
// begin if GetSide ( veh ) = 3 then
10937: LD_VAR 0 1
10941: PPUSH
10942: CALL_OW 255
10946: PUSH
10947: LD_INT 3
10949: EQUAL
10950: IFFALSE 11075
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10952: LD_VAR 0 1
10956: PPUSH
10957: CALL_OW 264
10961: PUSH
10962: LD_INT 53
10964: PUSH
10965: LD_INT 52
10967: PUSH
10968: LD_INT 51
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: IN
10976: NOT
10977: IFFALSE 10995
// ru_force := ru_force ^ veh ;
10979: LD_ADDR_EXP 35
10983: PUSH
10984: LD_EXP 35
10988: PUSH
10989: LD_VAR 0 1
10993: ADD
10994: ST_TO_ADDR
// for i = 1 to 4 do
10995: LD_ADDR_VAR 0 3
10999: PUSH
11000: DOUBLE
11001: LD_INT 1
11003: DEC
11004: ST_TO_ADDR
11005: LD_INT 4
11007: PUSH
11008: FOR_TO
11009: IFFALSE 11031
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11011: LD_ADDR_EXP 37
11015: PUSH
11016: LD_EXP 37
11020: PPUSH
11021: LD_INT 1
11023: PPUSH
11024: CALL_OW 3
11028: ST_TO_ADDR
11029: GO 11008
11031: POP
11032: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11033: LD_VAR 0 1
11037: PPUSH
11038: CALL_OW 264
11042: PUSH
11043: LD_INT 53
11045: EQUAL
11046: IFFALSE 11075
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11048: LD_VAR 0 1
11052: PPUSH
11053: LD_INT 7
11055: PPUSH
11056: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11060: LD_VAR 0 1
11064: PPUSH
11065: LD_INT 170
11067: PPUSH
11068: LD_INT 235
11070: PPUSH
11071: CALL_OW 171
// end ; end ; end ;
11075: PPOPN 3
11077: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11078: LD_VAR 0 1
11082: PUSH
11083: LD_INT 1
11085: EQUAL
11086: PUSH
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 2
11094: EQUAL
11095: AND
11096: PUSH
11097: LD_VAR 0 1
11101: PUSH
11102: LD_INT 2
11104: EQUAL
11105: PUSH
11106: LD_VAR 0 2
11110: PUSH
11111: LD_INT 1
11113: EQUAL
11114: AND
11115: OR
11116: IFFALSE 11126
// player_attacked_ar := true ;
11118: LD_ADDR_EXP 16
11122: PUSH
11123: LD_INT 1
11125: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11126: LD_VAR 0 1
11130: PUSH
11131: LD_INT 1
11133: EQUAL
11134: PUSH
11135: LD_VAR 0 2
11139: PUSH
11140: LD_INT 4
11142: EQUAL
11143: AND
11144: PUSH
11145: LD_VAR 0 1
11149: PUSH
11150: LD_INT 4
11152: EQUAL
11153: PUSH
11154: LD_VAR 0 2
11158: PUSH
11159: LD_INT 1
11161: EQUAL
11162: AND
11163: OR
11164: IFFALSE 11173
// YouLost ( Traitor ) ;
11166: LD_STRING Traitor
11168: PPUSH
11169: CALL_OW 104
// end ;
11173: PPOPN 2
11175: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11176: LD_VAR 0 1
11180: PUSH
11181: LD_EXP 18
11185: EQUAL
11186: IFFALSE 11195
// YouLost ( JMM ) ;
11188: LD_STRING JMM
11190: PPUSH
11191: CALL_OW 104
// if un = terminal then
11195: LD_VAR 0 1
11199: PUSH
11200: LD_EXP 3
11204: EQUAL
11205: IFFALSE 11214
// YouLost ( Terminal ) ;
11207: LD_STRING Terminal
11209: PPUSH
11210: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11214: LD_VAR 0 1
11218: PUSH
11219: LD_INT 22
11221: PUSH
11222: LD_INT 3
11224: PUSH
11225: EMPTY
11226: LIST
11227: LIST
11228: PUSH
11229: LD_INT 21
11231: PUSH
11232: LD_INT 3
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: PUSH
11239: EMPTY
11240: LIST
11241: LIST
11242: PPUSH
11243: CALL_OW 69
11247: IN
11248: IFFALSE 11394
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11250: LD_VAR 0 1
11254: PPUSH
11255: CALL_OW 266
11259: PUSH
11260: LD_INT 33
11262: PUSH
11263: LD_INT 26
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: IN
11270: IFFALSE 11329
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11272: LD_ADDR_EXP 36
11276: PUSH
11277: LD_EXP 36
11281: PUSH
11282: LD_VAR 0 1
11286: PPUSH
11287: CALL_OW 266
11291: PUSH
11292: LD_VAR 0 1
11296: PPUSH
11297: CALL_OW 250
11301: PUSH
11302: LD_VAR 0 1
11306: PPUSH
11307: CALL_OW 251
11311: PUSH
11312: LD_VAR 0 1
11316: PPUSH
11317: CALL_OW 254
11321: PUSH
11322: EMPTY
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: ADD
11328: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11329: LD_VAR 0 1
11333: PPUSH
11334: CALL_OW 266
11338: PUSH
11339: LD_INT 5
11341: EQUAL
11342: IFFALSE 11394
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11344: LD_ADDR_EXP 36
11348: PUSH
11349: LD_EXP 36
11353: PUSH
11354: LD_INT 4
11356: PUSH
11357: LD_VAR 0 1
11361: PPUSH
11362: CALL_OW 250
11366: PUSH
11367: LD_VAR 0 1
11371: PPUSH
11372: CALL_OW 251
11376: PUSH
11377: LD_VAR 0 1
11381: PPUSH
11382: CALL_OW 254
11386: PUSH
11387: EMPTY
11388: LIST
11389: LIST
11390: LIST
11391: LIST
11392: ADD
11393: ST_TO_ADDR
// end ; if un in ru_force then
11394: LD_VAR 0 1
11398: PUSH
11399: LD_EXP 35
11403: IN
11404: IFFALSE 11440
// begin ru_force := ru_force diff un ;
11406: LD_ADDR_EXP 35
11410: PUSH
11411: LD_EXP 35
11415: PUSH
11416: LD_VAR 0 1
11420: DIFF
11421: ST_TO_ADDR
// if ru_force = 0 then
11422: LD_EXP 35
11426: PUSH
11427: LD_INT 0
11429: EQUAL
11430: IFFALSE 11440
// ru_can_attack := false ;
11432: LD_ADDR_EXP 8
11436: PUSH
11437: LD_INT 0
11439: ST_TO_ADDR
// end ; end ; end_of_file
11440: PPOPN 1
11442: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
11443: LD_EXP 5
11447: PUSH
11448: LD_EXP 6
11452: AND
11453: IFFALSE 11531
11455: GO 11457
11457: DISABLE
11458: LD_INT 0
11460: PPUSH
// begin enable ;
11461: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
11462: LD_ADDR_VAR 0 1
11466: PUSH
11467: LD_INT 60
11469: PUSH
11470: CALL 784 0 0
11474: MINUS
11475: ST_TO_ADDR
// if sib < 0 then
11476: LD_VAR 0 1
11480: PUSH
11481: LD_INT 0
11483: LESS
11484: IFFALSE 11494
// sib := 0 ;
11486: LD_ADDR_VAR 0 1
11490: PUSH
11491: LD_INT 0
11493: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11494: LD_ADDR_OWVAR 47
11498: PUSH
11499: LD_STRING #Am09-1
11501: PUSH
11502: LD_VAR 0 1
11506: PUSH
11507: LD_EXP 6
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: LIST
11516: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11517: LD_ADDR_EXP 6
11521: PUSH
11522: LD_EXP 6
11526: PUSH
11527: LD_INT 35
11529: MINUS
11530: ST_TO_ADDR
// end ;
11531: PPOPN 1
11533: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11534: LD_EXP 6
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11554
11544: GO 11546
11546: DISABLE
// display_strings := [ ] ;
11547: LD_ADDR_OWVAR 47
11551: PUSH
11552: EMPTY
11553: ST_TO_ADDR
11554: END
// every 0 0$01 trigger ru_force and debug do
11555: LD_EXP 35
11559: PUSH
11560: LD_EXP 2
11564: AND
11565: IFFALSE 11581
11567: GO 11569
11569: DISABLE
// begin enable ;
11570: ENABLE
// display_strings := ru_force ;
11571: LD_ADDR_OWVAR 47
11575: PUSH
11576: LD_EXP 35
11580: ST_TO_ADDR
// end ;
11581: END
// every 1 1$35 do var i , tmp ;
11582: GO 11584
11584: DISABLE
11585: LD_INT 0
11587: PPUSH
11588: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11589: LD_ADDR_VAR 0 2
11593: PUSH
11594: LD_INT 1155
11596: PUSH
11597: LD_INT 1225
11599: PUSH
11600: LD_INT 1435
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: LIST
11607: PUSH
11608: LD_OWVAR 67
11612: ARRAY
11613: ST_TO_ADDR
// i := 0 ;
11614: LD_ADDR_VAR 0 1
11618: PUSH
11619: LD_INT 0
11621: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11622: LD_INT 1
11624: PPUSH
11625: LD_INT 5
11627: PPUSH
11628: CALL_OW 12
11632: PPUSH
11633: LD_INT 75
11635: PPUSH
11636: LD_INT 75
11638: PPUSH
11639: LD_INT 20
11641: PPUSH
11642: LD_INT 1
11644: PPUSH
11645: CALL_OW 56
// wait ( tmp ) ;
11649: LD_VAR 0 2
11653: PPUSH
11654: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11658: LD_ADDR_VAR 0 2
11662: PUSH
11663: LD_VAR 0 2
11667: PUSH
11668: LD_INT 105
11670: PPUSH
11671: LD_INT 315
11673: PPUSH
11674: CALL_OW 12
11678: PLUS
11679: ST_TO_ADDR
// i := i + 1 ;
11680: LD_ADDR_VAR 0 1
11684: PUSH
11685: LD_VAR 0 1
11689: PUSH
11690: LD_INT 1
11692: PLUS
11693: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11694: LD_VAR 0 1
11698: PUSH
11699: LD_INT 3
11701: MOD
11702: PUSH
11703: LD_INT 0
11705: EQUAL
11706: PUSH
11707: LD_EXP 4
11711: AND
11712: IFFALSE 11750
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11714: LD_INT 2
11716: PPUSH
11717: LD_INT 5
11719: PPUSH
11720: CALL_OW 12
11724: PPUSH
11725: LD_INT 8
11727: PPUSH
11728: LD_INT 1
11730: PPUSH
11731: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11735: LD_INT 665
11737: PPUSH
11738: LD_INT 735
11740: PPUSH
11741: CALL_OW 12
11745: PPUSH
11746: CALL_OW 67
// end ; until tick > game_time ;
11750: LD_OWVAR 1
11754: PUSH
11755: LD_EXP 7
11759: GREATER
11760: IFFALSE 11622
// end ; end_of_file
11762: PPOPN 2
11764: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11765: LD_INT 0
11767: PPUSH
11768: PPUSH
11769: PPUSH
11770: PPUSH
11771: PPUSH
11772: PPUSH
// x := 76 ;
11773: LD_ADDR_VAR 0 5
11777: PUSH
11778: LD_INT 76
11780: ST_TO_ADDR
// y := 147 ;
11781: LD_ADDR_VAR 0 6
11785: PUSH
11786: LD_INT 147
11788: ST_TO_ADDR
// uc_side := 2 ;
11789: LD_ADDR_OWVAR 20
11793: PUSH
11794: LD_INT 2
11796: ST_TO_ADDR
// uc_nation := 2 ;
11797: LD_ADDR_OWVAR 21
11801: PUSH
11802: LD_INT 2
11804: ST_TO_ADDR
// InitHc ;
11805: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11809: LD_INT 1
11811: PPUSH
11812: LD_INT 1
11814: PPUSH
11815: LD_INT 6
11817: PPUSH
11818: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11822: LD_ADDR_OWVAR 26
11826: PUSH
11827: LD_STRING Nicolas Vervecken
11829: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11830: LD_ADDR_OWVAR 33
11834: PUSH
11835: LD_STRING SecondCharsGal
11837: ST_TO_ADDR
// hc_face_number := 3 ;
11838: LD_ADDR_OWVAR 34
11842: PUSH
11843: LD_INT 3
11845: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11846: LD_ADDR_OWVAR 29
11850: PUSH
11851: LD_INT 11
11853: PUSH
11854: LD_INT 10
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: ST_TO_ADDR
// Vervecken := CreateHuman ;
11861: LD_ADDR_EXP 26
11865: PUSH
11866: CALL_OW 44
11870: ST_TO_ADDR
// ar_force := Vervecken ;
11871: LD_ADDR_EXP 33
11875: PUSH
11876: LD_EXP 26
11880: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11881: LD_INT 1
11883: PPUSH
11884: LD_INT 2
11886: PPUSH
11887: LD_INT 6
11889: PPUSH
11890: CALL_OW 380
// hc_name := Louis Gali ;
11894: LD_ADDR_OWVAR 26
11898: PUSH
11899: LD_STRING Louis Gali
11901: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11902: LD_ADDR_OWVAR 33
11906: PUSH
11907: LD_STRING SecondCharsGal
11909: ST_TO_ADDR
// hc_face_number := 2 ;
11910: LD_ADDR_OWVAR 34
11914: PUSH
11915: LD_INT 2
11917: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11918: LD_ADDR_OWVAR 29
11922: PUSH
11923: LD_INT 10
11925: PUSH
11926: LD_INT 11
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: ST_TO_ADDR
// Gali := CreateHuman ;
11933: LD_ADDR_EXP 27
11937: PUSH
11938: CALL_OW 44
11942: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11943: LD_ADDR_EXP 33
11947: PUSH
11948: LD_EXP 33
11952: PUSH
11953: LD_EXP 27
11957: ADD
11958: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11959: LD_INT 2
11961: PPUSH
11962: LD_INT 1
11964: PPUSH
11965: LD_INT 6
11967: PPUSH
11968: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11972: LD_ADDR_OWVAR 26
11976: PUSH
11977: LD_STRING Maria Bogdanovic
11979: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11980: LD_ADDR_OWVAR 33
11984: PUSH
11985: LD_STRING SecondCharsGal
11987: ST_TO_ADDR
// hc_face_number := 14 ;
11988: LD_ADDR_OWVAR 34
11992: PUSH
11993: LD_INT 14
11995: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11996: LD_ADDR_OWVAR 29
12000: PUSH
12001: LD_INT 12
12003: PUSH
12004: LD_INT 9
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12011: LD_ADDR_EXP 28
12015: PUSH
12016: CALL_OW 44
12020: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12021: LD_ADDR_EXP 33
12025: PUSH
12026: LD_EXP 33
12030: PUSH
12031: LD_EXP 28
12035: ADD
12036: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12037: LD_INT 1
12039: PPUSH
12040: LD_INT 3
12042: PPUSH
12043: LD_INT 6
12045: PPUSH
12046: CALL_OW 380
// hc_name = Kntor Radomr ;
12050: LD_ADDR_OWVAR 26
12054: PUSH
12055: LD_STRING Kntor Radomr
12057: ST_TO_ADDR
// hc_gallery = sandar ;
12058: LD_ADDR_OWVAR 33
12062: PUSH
12063: LD_STRING sandar
12065: ST_TO_ADDR
// hc_face_number = 12 ;
12066: LD_ADDR_OWVAR 34
12070: PUSH
12071: LD_INT 12
12073: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12074: LD_ADDR_OWVAR 29
12078: PUSH
12079: LD_INT 9
12081: PUSH
12082: LD_INT 9
12084: PUSH
12085: EMPTY
12086: LIST
12087: LIST
12088: ST_TO_ADDR
// Kantor = CreateHuman ;
12089: LD_ADDR_EXP 29
12093: PUSH
12094: CALL_OW 44
12098: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12099: LD_ADDR_EXP 33
12103: PUSH
12104: LD_EXP 33
12108: PUSH
12109: LD_EXP 29
12113: ADD
12114: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12115: LD_INT 1
12117: PPUSH
12118: LD_INT 3
12120: PPUSH
12121: LD_INT 6
12123: PPUSH
12124: CALL_OW 380
// hc_name = Herczeg Farkas ;
12128: LD_ADDR_OWVAR 26
12132: PUSH
12133: LD_STRING Herczeg Farkas
12135: ST_TO_ADDR
// hc_gallery = sandar ;
12136: LD_ADDR_OWVAR 33
12140: PUSH
12141: LD_STRING sandar
12143: ST_TO_ADDR
// hc_face_number = 28 ;
12144: LD_ADDR_OWVAR 34
12148: PUSH
12149: LD_INT 28
12151: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12152: LD_ADDR_OWVAR 29
12156: PUSH
12157: LD_INT 10
12159: PUSH
12160: LD_INT 9
12162: PUSH
12163: EMPTY
12164: LIST
12165: LIST
12166: ST_TO_ADDR
// Herczeg = CreateHuman ;
12167: LD_ADDR_EXP 30
12171: PUSH
12172: CALL_OW 44
12176: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12177: LD_ADDR_EXP 33
12181: PUSH
12182: LD_EXP 33
12186: PUSH
12187: LD_EXP 30
12191: ADD
12192: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12193: LD_INT 1
12195: PPUSH
12196: LD_INT 1
12198: PPUSH
12199: LD_INT 6
12201: PPUSH
12202: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12206: LD_ADDR_OWVAR 26
12210: PUSH
12211: LD_STRING Ronn Horntvedt
12213: ST_TO_ADDR
// hc_gallery = sandar ;
12214: LD_ADDR_OWVAR 33
12218: PUSH
12219: LD_STRING sandar
12221: ST_TO_ADDR
// hc_face_number = 29 ;
12222: LD_ADDR_OWVAR 34
12226: PUSH
12227: LD_INT 29
12229: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12230: LD_ADDR_OWVAR 29
12234: PUSH
12235: LD_INT 11
12237: PUSH
12238: LD_INT 11
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: ST_TO_ADDR
// Ronn = CreateHuman ;
12245: LD_ADDR_EXP 31
12249: PUSH
12250: CALL_OW 44
12254: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12255: LD_ADDR_EXP 33
12259: PUSH
12260: LD_EXP 33
12264: PUSH
12265: LD_EXP 31
12269: ADD
12270: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12271: LD_INT 2
12273: PPUSH
12274: LD_INT 3
12276: PPUSH
12277: LD_INT 6
12279: PPUSH
12280: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12284: LD_ADDR_OWVAR 26
12288: PUSH
12289: LD_STRING Mia D. Mathiasen
12291: ST_TO_ADDR
// hc_gallery = sandar ;
12292: LD_ADDR_OWVAR 33
12296: PUSH
12297: LD_STRING sandar
12299: ST_TO_ADDR
// hc_face_number = 31 ;
12300: LD_ADDR_OWVAR 34
12304: PUSH
12305: LD_INT 31
12307: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12308: LD_ADDR_OWVAR 29
12312: PUSH
12313: LD_INT 10
12315: PUSH
12316: LD_INT 10
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: ST_TO_ADDR
// Mia = CreateHuman ;
12323: LD_ADDR_EXP 32
12327: PUSH
12328: CALL_OW 44
12332: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12333: LD_ADDR_EXP 33
12337: PUSH
12338: LD_EXP 33
12342: PUSH
12343: LD_EXP 32
12347: ADD
12348: ST_TO_ADDR
// for i = 1 to 2 do
12349: LD_ADDR_VAR 0 4
12353: PUSH
12354: DOUBLE
12355: LD_INT 1
12357: DEC
12358: ST_TO_ADDR
12359: LD_INT 2
12361: PUSH
12362: FOR_TO
12363: IFFALSE 12404
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12365: LD_ADDR_VAR 0 3
12369: PUSH
12370: LD_VAR 0 3
12374: PUSH
12375: LD_INT 2
12377: PPUSH
12378: LD_INT 2
12380: PPUSH
12381: LD_INT 14
12383: PPUSH
12384: LD_INT 1
12386: PPUSH
12387: LD_INT 1
12389: PPUSH
12390: LD_INT 32
12392: PPUSH
12393: LD_INT 30
12395: PPUSH
12396: CALL 264 0 7
12400: ADD
12401: ST_TO_ADDR
12402: GO 12362
12404: POP
12405: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
12406: LD_ADDR_VAR 0 3
12410: PUSH
12411: LD_VAR 0 3
12415: PUSH
12416: LD_INT 2
12418: PPUSH
12419: LD_INT 2
12421: PPUSH
12422: LD_INT 14
12424: PPUSH
12425: LD_INT 1
12427: PPUSH
12428: LD_INT 1
12430: PPUSH
12431: LD_INT 26
12433: PPUSH
12434: LD_INT 33
12436: PPUSH
12437: CALL 264 0 7
12441: ADD
12442: ST_TO_ADDR
// tmp := tmp diff 0 ;
12443: LD_ADDR_VAR 0 3
12447: PUSH
12448: LD_VAR 0 3
12452: PUSH
12453: LD_INT 0
12455: DIFF
12456: ST_TO_ADDR
// for i in ar_force do
12457: LD_ADDR_VAR 0 4
12461: PUSH
12462: LD_EXP 33
12466: PUSH
12467: FOR_IN
12468: IFFALSE 12611
// begin if GetClass ( i ) = 3 then
12470: LD_VAR 0 4
12474: PPUSH
12475: CALL_OW 257
12479: PUSH
12480: LD_INT 3
12482: EQUAL
12483: IFFALSE 12565
// begin SetDir ( tmp [ 1 ] , 1 ) ;
12485: LD_VAR 0 3
12489: PUSH
12490: LD_INT 1
12492: ARRAY
12493: PPUSH
12494: LD_INT 1
12496: PPUSH
12497: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
12501: LD_VAR 0 3
12505: PUSH
12506: LD_INT 1
12508: ARRAY
12509: PPUSH
12510: LD_VAR 0 5
12514: PPUSH
12515: LD_VAR 0 6
12519: PPUSH
12520: LD_INT 0
12522: PPUSH
12523: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12527: LD_VAR 0 4
12531: PPUSH
12532: LD_VAR 0 3
12536: PUSH
12537: LD_INT 1
12539: ARRAY
12540: PPUSH
12541: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12545: LD_ADDR_VAR 0 3
12549: PUSH
12550: LD_VAR 0 3
12554: PPUSH
12555: LD_INT 1
12557: PPUSH
12558: CALL_OW 3
12562: ST_TO_ADDR
// end else
12563: GO 12587
// PlaceUnitXY ( i , x , y , false ) ;
12565: LD_VAR 0 4
12569: PPUSH
12570: LD_VAR 0 5
12574: PPUSH
12575: LD_VAR 0 6
12579: PPUSH
12580: LD_INT 0
12582: PPUSH
12583: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12587: LD_VAR 0 4
12591: PPUSH
12592: LD_INT 86
12594: PPUSH
12595: LD_INT 121
12597: PPUSH
12598: CALL_OW 111
// wait ( 0 0$2 ) ;
12602: LD_INT 70
12604: PPUSH
12605: CALL_OW 67
// end ;
12609: GO 12467
12611: POP
12612: POP
// ar_force := ar_force ^ tmp ;
12613: LD_ADDR_EXP 33
12617: PUSH
12618: LD_EXP 33
12622: PUSH
12623: LD_VAR 0 3
12627: ADD
12628: ST_TO_ADDR
// ar_spawned := true ;
12629: LD_ADDR_EXP 11
12633: PUSH
12634: LD_INT 1
12636: ST_TO_ADDR
// end ; end_of_file
12637: LD_VAR 0 1
12641: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12642: LD_INT 0
12644: PPUSH
12645: PPUSH
12646: PPUSH
12647: PPUSH
12648: PPUSH
12649: PPUSH
12650: PPUSH
// InitHc ;
12651: CALL_OW 19
// uc_side := 3 ;
12655: LD_ADDR_OWVAR 20
12659: PUSH
12660: LD_INT 3
12662: ST_TO_ADDR
// uc_nation := 3 ;
12663: LD_ADDR_OWVAR 21
12667: PUSH
12668: LD_INT 3
12670: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12671: LD_ADDR_VAR 0 5
12675: PUSH
12676: LD_INT 5
12678: PUSH
12679: LD_INT 6
12681: PUSH
12682: LD_INT 7
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: LIST
12689: PUSH
12690: LD_OWVAR 67
12694: ARRAY
12695: ST_TO_ADDR
// ru_force := [ ] ;
12696: LD_ADDR_EXP 35
12700: PUSH
12701: EMPTY
12702: ST_TO_ADDR
// ru_rebuild := [ ] ;
12703: LD_ADDR_EXP 36
12707: PUSH
12708: EMPTY
12709: ST_TO_ADDR
// ru_produce_list := [ ] ;
12710: LD_ADDR_EXP 37
12714: PUSH
12715: EMPTY
12716: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12717: LD_ADDR_VAR 0 6
12721: PUSH
12722: LD_INT 22
12724: PUSH
12725: LD_INT 3
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PUSH
12732: LD_INT 30
12734: PUSH
12735: LD_INT 8
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: PPUSH
12746: CALL_OW 69
12750: PUSH
12751: LD_INT 1
12753: ARRAY
12754: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12755: LD_ADDR_VAR 0 4
12759: PUSH
12760: LD_INT 43
12762: PUSH
12763: LD_INT 46
12765: PUSH
12766: LD_INT 45
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12774: LD_ADDR_VAR 0 7
12778: PUSH
12779: LD_INT 22
12781: PUSH
12782: LD_INT 3
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PUSH
12789: LD_INT 30
12791: PUSH
12792: LD_INT 1
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PPUSH
12803: CALL_OW 69
12807: PUSH
12808: LD_INT 1
12810: ARRAY
12811: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12812: LD_VAR 0 7
12816: PPUSH
12817: CALL_OW 274
12821: PPUSH
12822: LD_INT 1
12824: PPUSH
12825: LD_INT 5000
12827: PPUSH
12828: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12832: LD_VAR 0 7
12836: PPUSH
12837: CALL_OW 274
12841: PPUSH
12842: LD_INT 2
12844: PPUSH
12845: LD_INT 1000
12847: PPUSH
12848: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12852: LD_VAR 0 7
12856: PPUSH
12857: CALL_OW 274
12861: PPUSH
12862: LD_INT 3
12864: PPUSH
12865: LD_INT 30
12867: PPUSH
12868: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12872: LD_ADDR_VAR 0 2
12876: PUSH
12877: LD_INT 22
12879: PUSH
12880: LD_INT 3
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PUSH
12887: LD_INT 30
12889: PUSH
12890: LD_INT 33
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: PPUSH
12901: CALL_OW 69
12905: PUSH
12906: FOR_IN
12907: IFFALSE 12939
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
12909: LD_VAR 0 2
12913: PPUSH
12914: LD_VAR 0 4
12918: PUSH
12919: LD_VAR 0 2
12923: PUSH
12924: LD_INT 3
12926: MOD
12927: PUSH
12928: LD_INT 1
12930: PLUS
12931: ARRAY
12932: PPUSH
12933: CALL_OW 431
// end ;
12937: GO 12906
12939: POP
12940: POP
// for i = 1 to 4 do
12941: LD_ADDR_VAR 0 2
12945: PUSH
12946: DOUBLE
12947: LD_INT 1
12949: DEC
12950: ST_TO_ADDR
12951: LD_INT 4
12953: PUSH
12954: FOR_TO
12955: IFFALSE 13016
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12957: LD_INT 0
12959: PPUSH
12960: LD_INT 9
12962: PPUSH
12963: LD_VAR 0 5
12967: PPUSH
12968: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12972: CALL_OW 44
12976: PPUSH
12977: LD_INT 22
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: LD_INT 30
12989: PUSH
12990: LD_INT 5
12992: PUSH
12993: EMPTY
12994: LIST
12995: LIST
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: PPUSH
13001: CALL_OW 69
13005: PUSH
13006: LD_INT 1
13008: ARRAY
13009: PPUSH
13010: CALL_OW 52
// end ;
13014: GO 12954
13016: POP
13017: POP
// for i = 1 to 5 do
13018: LD_ADDR_VAR 0 2
13022: PUSH
13023: DOUBLE
13024: LD_INT 1
13026: DEC
13027: ST_TO_ADDR
13028: LD_INT 5
13030: PUSH
13031: FOR_TO
13032: IFFALSE 13093
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13034: LD_INT 0
13036: PPUSH
13037: LD_INT 3
13039: PPUSH
13040: LD_VAR 0 5
13044: PPUSH
13045: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13049: CALL_OW 44
13053: PPUSH
13054: LD_INT 22
13056: PUSH
13057: LD_INT 3
13059: PUSH
13060: EMPTY
13061: LIST
13062: LIST
13063: PUSH
13064: LD_INT 30
13066: PUSH
13067: LD_INT 3
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: PPUSH
13078: CALL_OW 69
13082: PUSH
13083: LD_INT 1
13085: ARRAY
13086: PPUSH
13087: CALL_OW 52
// end ;
13091: GO 13031
13093: POP
13094: POP
// for i = 1 to 4 do
13095: LD_ADDR_VAR 0 2
13099: PUSH
13100: DOUBLE
13101: LD_INT 1
13103: DEC
13104: ST_TO_ADDR
13105: LD_INT 4
13107: PUSH
13108: FOR_TO
13109: IFFALSE 13170
// begin PrepareHuman ( false , class_engineer , skill ) ;
13111: LD_INT 0
13113: PPUSH
13114: LD_INT 2
13116: PPUSH
13117: LD_VAR 0 5
13121: PPUSH
13122: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13126: CALL_OW 44
13130: PPUSH
13131: LD_INT 22
13133: PUSH
13134: LD_INT 3
13136: PUSH
13137: EMPTY
13138: LIST
13139: LIST
13140: PUSH
13141: LD_INT 30
13143: PUSH
13144: LD_INT 1
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PPUSH
13155: CALL_OW 69
13159: PUSH
13160: LD_INT 1
13162: ARRAY
13163: PPUSH
13164: CALL_OW 52
// end ;
13168: GO 13108
13170: POP
13171: POP
// for i = 1 to 3 do
13172: LD_ADDR_VAR 0 2
13176: PUSH
13177: DOUBLE
13178: LD_INT 1
13180: DEC
13181: ST_TO_ADDR
13182: LD_INT 3
13184: PUSH
13185: FOR_TO
13186: IFFALSE 13219
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13188: LD_INT 0
13190: PPUSH
13191: LD_INT 4
13193: PPUSH
13194: LD_VAR 0 5
13198: PPUSH
13199: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13203: CALL_OW 44
13207: PPUSH
13208: LD_VAR 0 6
13212: PPUSH
13213: CALL_OW 52
// end ;
13217: GO 13185
13219: POP
13220: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13221: LD_ADDR_EXP 34
13225: PUSH
13226: LD_STRING Yakotich
13228: PPUSH
13229: LD_EXP 2
13233: NOT
13234: PPUSH
13235: LD_STRING 
13237: PPUSH
13238: CALL 201 0 3
13242: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13243: LD_EXP 34
13247: PPUSH
13248: LD_INT 74
13250: PPUSH
13251: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13255: LD_VAR 0 6
13259: PPUSH
13260: LD_INT 49
13262: PPUSH
13263: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13267: LD_VAR 0 6
13271: PPUSH
13272: LD_INT 50
13274: PPUSH
13275: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13279: LD_VAR 0 6
13283: PPUSH
13284: LD_INT 51
13286: PPUSH
13287: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13291: LD_VAR 0 6
13295: PPUSH
13296: LD_INT 52
13298: PPUSH
13299: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13303: LD_VAR 0 6
13307: PPUSH
13308: LD_INT 69
13310: PPUSH
13311: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13315: LD_VAR 0 6
13319: PPUSH
13320: LD_INT 39
13322: PPUSH
13323: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13327: LD_VAR 0 6
13331: PPUSH
13332: LD_INT 34
13334: PPUSH
13335: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13339: LD_VAR 0 6
13343: PPUSH
13344: LD_INT 40
13346: PPUSH
13347: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13351: LD_VAR 0 6
13355: PPUSH
13356: LD_INT 57
13358: PPUSH
13359: CALL_OW 184
// if Difficulty > 1 then
13363: LD_OWVAR 67
13367: PUSH
13368: LD_INT 1
13370: GREATER
13371: IFFALSE 13385
// AddComResearch ( lab , tech_comp2 ) ;
13373: LD_VAR 0 6
13377: PPUSH
13378: LD_INT 58
13380: PPUSH
13381: CALL_OW 184
// end ;
13385: LD_VAR 0 1
13389: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
13390: LD_INT 7
13392: PPUSH
13393: CALL_OW 353
13397: PUSH
13398: LD_INT 3
13400: GREATER
13401: PUSH
13402: LD_INT 22
13404: PUSH
13405: LD_INT 3
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: LD_INT 34
13414: PUSH
13415: LD_INT 53
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PPUSH
13426: CALL_OW 69
13430: NOT
13431: AND
13432: IFFALSE 13467
13434: GO 13436
13436: DISABLE
// begin enable ;
13437: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
13438: LD_ADDR_EXP 37
13442: PUSH
13443: LD_EXP 37
13447: PUSH
13448: LD_INT 24
13450: PUSH
13451: LD_INT 1
13453: PUSH
13454: LD_INT 3
13456: PUSH
13457: LD_INT 53
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: LIST
13464: LIST
13465: ADD
13466: ST_TO_ADDR
// end ;
13467: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
13468: LD_INT 22
13470: PUSH
13471: LD_INT 3
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: LD_INT 21
13480: PUSH
13481: LD_INT 3
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: EMPTY
13489: LIST
13490: LIST
13491: PPUSH
13492: CALL_OW 69
13496: IFFALSE 14274
13498: GO 13500
13500: DISABLE
13501: LD_INT 0
13503: PPUSH
13504: PPUSH
13505: PPUSH
13506: PPUSH
13507: PPUSH
13508: PPUSH
13509: PPUSH
13510: PPUSH
// begin enable ;
13511: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13512: LD_ADDR_VAR 0 3
13516: PUSH
13517: LD_INT 22
13519: PUSH
13520: LD_INT 3
13522: PUSH
13523: EMPTY
13524: LIST
13525: LIST
13526: PUSH
13527: LD_INT 21
13529: PUSH
13530: LD_INT 3
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PUSH
13537: LD_INT 3
13539: PUSH
13540: LD_INT 24
13542: PUSH
13543: LD_INT 1000
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PUSH
13550: EMPTY
13551: LIST
13552: LIST
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: PPUSH
13559: CALL_OW 69
13563: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13564: LD_ADDR_VAR 0 4
13568: PUSH
13569: LD_INT 22
13571: PUSH
13572: LD_INT 3
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 25
13581: PUSH
13582: LD_INT 2
13584: PUSH
13585: EMPTY
13586: LIST
13587: LIST
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PPUSH
13593: CALL_OW 69
13597: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13598: LD_ADDR_VAR 0 5
13602: PUSH
13603: LD_INT 22
13605: PUSH
13606: LD_INT 3
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PUSH
13613: LD_INT 30
13615: PUSH
13616: LD_INT 1
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PPUSH
13627: CALL_OW 69
13631: PUSH
13632: LD_INT 1
13634: ARRAY
13635: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13636: LD_ADDR_VAR 0 8
13640: PUSH
13641: LD_INT 22
13643: PUSH
13644: LD_INT 3
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 2
13653: PUSH
13654: LD_INT 30
13656: PUSH
13657: LD_INT 6
13659: PUSH
13660: EMPTY
13661: LIST
13662: LIST
13663: PUSH
13664: LD_INT 30
13666: PUSH
13667: LD_INT 7
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: PUSH
13674: LD_INT 30
13676: PUSH
13677: LD_INT 8
13679: PUSH
13680: EMPTY
13681: LIST
13682: LIST
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: PPUSH
13694: CALL_OW 69
13698: PUSH
13699: LD_INT 1
13701: ARRAY
13702: ST_TO_ADDR
// if not engs then
13703: LD_VAR 0 4
13707: NOT
13708: IFFALSE 13712
// exit ;
13710: GO 14274
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13712: LD_ADDR_VAR 0 6
13716: PUSH
13717: LD_VAR 0 4
13721: PPUSH
13722: LD_INT 3
13724: PUSH
13725: LD_INT 24
13727: PUSH
13728: LD_INT 600
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PPUSH
13739: CALL_OW 72
13743: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13744: LD_ADDR_VAR 0 7
13748: PUSH
13749: LD_INT 22
13751: PUSH
13752: LD_INT 3
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PUSH
13759: LD_INT 25
13761: PUSH
13762: LD_INT 4
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PPUSH
13773: CALL_OW 69
13777: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13778: LD_VAR 0 3
13782: NOT
13783: PUSH
13784: LD_EXP 36
13788: NOT
13789: AND
13790: IFFALSE 13850
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13792: LD_VAR 0 4
13796: PPUSH
13797: LD_INT 3
13799: PUSH
13800: LD_INT 54
13802: PUSH
13803: EMPTY
13804: LIST
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PPUSH
13810: CALL_OW 72
13814: IFFALSE 13848
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13816: LD_VAR 0 4
13820: PPUSH
13821: LD_INT 3
13823: PUSH
13824: LD_INT 54
13826: PUSH
13827: EMPTY
13828: LIST
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PPUSH
13834: CALL_OW 72
13838: PPUSH
13839: LD_VAR 0 5
13843: PPUSH
13844: CALL_OW 120
// exit ;
13848: GO 14274
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13850: LD_VAR 0 4
13854: PPUSH
13855: LD_INT 54
13857: PUSH
13858: EMPTY
13859: LIST
13860: PPUSH
13861: CALL_OW 72
13865: IFFALSE 13887
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13867: LD_VAR 0 4
13871: PPUSH
13872: LD_INT 54
13874: PUSH
13875: EMPTY
13876: LIST
13877: PPUSH
13878: CALL_OW 72
13882: PPUSH
13883: CALL_OW 122
// if not tmp then
13887: LD_VAR 0 3
13891: NOT
13892: IFFALSE 14024
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13894: LD_INT 81
13896: PUSH
13897: LD_INT 3
13899: PUSH
13900: EMPTY
13901: LIST
13902: LIST
13903: PUSH
13904: LD_INT 92
13906: PUSH
13907: LD_INT 147
13909: PUSH
13910: LD_INT 212
13912: PUSH
13913: LD_INT 30
13915: PUSH
13916: EMPTY
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PPUSH
13926: CALL_OW 69
13930: NOT
13931: IFFALSE 14024
// begin if not HasTask ( engs [ 1 ] ) then
13933: LD_VAR 0 4
13937: PUSH
13938: LD_INT 1
13940: ARRAY
13941: PPUSH
13942: CALL_OW 314
13946: NOT
13947: IFFALSE 14024
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13949: LD_ADDR_VAR 0 2
13953: PUSH
13954: LD_VAR 0 4
13958: PPUSH
13959: LD_EXP 36
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PPUSH
13968: LD_EXP 36
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: PPUSH
13977: LD_EXP 36
13981: PUSH
13982: LD_INT 3
13984: ARRAY
13985: PPUSH
13986: LD_EXP 36
13990: PUSH
13991: LD_INT 4
13993: ARRAY
13994: PPUSH
13995: CALL_OW 145
13999: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14000: LD_VAR 0 2
14004: PPUSH
14005: CALL_OW 266
14009: PUSH
14010: LD_INT 4
14012: EQUAL
14013: IFFALSE 14024
// AddComUpgrade ( i ) ;
14015: LD_VAR 0 2
14019: PPUSH
14020: CALL_OW 206
// end ; end ; end ; for i in engs do
14024: LD_ADDR_VAR 0 2
14028: PUSH
14029: LD_VAR 0 4
14033: PUSH
14034: FOR_IN
14035: IFFALSE 14153
// begin if i in to_heal and sci then
14037: LD_VAR 0 2
14041: PUSH
14042: LD_VAR 0 6
14046: IN
14047: PUSH
14048: LD_VAR 0 7
14052: AND
14053: IFFALSE 14104
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14055: LD_VAR 0 2
14059: PPUSH
14060: LD_INT 149
14062: PPUSH
14063: LD_INT 220
14065: PPUSH
14066: CALL_OW 297
14070: PUSH
14071: LD_INT 5
14073: LESS
14074: IFFALSE 14078
// continue ;
14076: GO 14034
// ComMoveXY ( i , 149 , 220 ) ;
14078: LD_VAR 0 2
14082: PPUSH
14083: LD_INT 149
14085: PPUSH
14086: LD_INT 220
14088: PPUSH
14089: CALL_OW 111
// AddComHold ( i ) ;
14093: LD_VAR 0 2
14097: PPUSH
14098: CALL_OW 200
// end else
14102: GO 14151
// if not HasTask ( i ) or WantsToAttack ( i ) then
14104: LD_VAR 0 2
14108: PPUSH
14109: CALL_OW 314
14113: NOT
14114: PUSH
14115: LD_VAR 0 2
14119: PPUSH
14120: CALL_OW 319
14124: OR
14125: IFFALSE 14151
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14127: LD_VAR 0 2
14131: PPUSH
14132: LD_VAR 0 3
14136: PPUSH
14137: LD_VAR 0 2
14141: PPUSH
14142: CALL_OW 74
14146: PPUSH
14147: CALL_OW 130
// end ;
14151: GO 14034
14153: POP
14154: POP
// if to_heal and sci then
14155: LD_VAR 0 6
14159: PUSH
14160: LD_VAR 0 7
14164: AND
14165: IFFALSE 14226
// begin if UnitFilter ( sci , [ f_inside ] ) then
14167: LD_VAR 0 7
14171: PPUSH
14172: LD_INT 54
14174: PUSH
14175: EMPTY
14176: LIST
14177: PPUSH
14178: CALL_OW 72
14182: IFFALSE 14206
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14184: LD_VAR 0 7
14188: PPUSH
14189: LD_INT 54
14191: PUSH
14192: EMPTY
14193: LIST
14194: PPUSH
14195: CALL_OW 72
14199: PPUSH
14200: CALL_OW 122
14204: GO 14224
// ComHeal ( sci , to_heal [ 1 ] ) ;
14206: LD_VAR 0 7
14210: PPUSH
14211: LD_VAR 0 6
14215: PUSH
14216: LD_INT 1
14218: ARRAY
14219: PPUSH
14220: CALL_OW 128
// end else
14224: GO 14274
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14226: LD_VAR 0 7
14230: PPUSH
14231: LD_INT 56
14233: PUSH
14234: EMPTY
14235: LIST
14236: PPUSH
14237: CALL_OW 72
14241: PUSH
14242: LD_VAR 0 8
14246: AND
14247: IFFALSE 14274
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14249: LD_VAR 0 7
14253: PPUSH
14254: LD_INT 56
14256: PUSH
14257: EMPTY
14258: LIST
14259: PPUSH
14260: CALL_OW 72
14264: PPUSH
14265: LD_VAR 0 8
14269: PPUSH
14270: CALL_OW 120
// end ;
14274: PPOPN 8
14276: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14277: LD_INT 22
14279: PUSH
14280: LD_INT 3
14282: PUSH
14283: EMPTY
14284: LIST
14285: LIST
14286: PUSH
14287: LD_INT 30
14289: PUSH
14290: LD_INT 3
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: PPUSH
14301: CALL_OW 69
14305: PUSH
14306: LD_EXP 37
14310: AND
14311: IFFALSE 14437
14313: GO 14315
14315: DISABLE
14316: LD_INT 0
14318: PPUSH
14319: PPUSH
14320: PPUSH
// begin enable ;
14321: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14322: LD_ADDR_VAR 0 3
14326: PUSH
14327: LD_INT 22
14329: PUSH
14330: LD_INT 3
14332: PUSH
14333: EMPTY
14334: LIST
14335: LIST
14336: PUSH
14337: LD_INT 30
14339: PUSH
14340: LD_INT 3
14342: PUSH
14343: EMPTY
14344: LIST
14345: LIST
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: PPUSH
14351: CALL_OW 69
14355: PUSH
14356: LD_INT 1
14358: ARRAY
14359: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14360: LD_VAR 0 3
14364: PPUSH
14365: CALL_OW 313
14369: PUSH
14370: LD_INT 0
14372: EQUAL
14373: IFFALSE 14377
// exit ;
14375: GO 14437
// if BuildingStatus ( fac ) = bs_idle then
14377: LD_VAR 0 3
14381: PPUSH
14382: CALL_OW 461
14386: PUSH
14387: LD_INT 2
14389: EQUAL
14390: IFFALSE 14437
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
14392: LD_VAR 0 3
14396: PPUSH
14397: LD_EXP 37
14401: PUSH
14402: LD_INT 1
14404: ARRAY
14405: PPUSH
14406: LD_EXP 37
14410: PUSH
14411: LD_INT 2
14413: ARRAY
14414: PPUSH
14415: LD_EXP 37
14419: PUSH
14420: LD_INT 3
14422: ARRAY
14423: PPUSH
14424: LD_EXP 37
14428: PUSH
14429: LD_INT 4
14431: ARRAY
14432: PPUSH
14433: CALL_OW 125
// end ;
14437: PPOPN 3
14439: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
14444: PPUSH
14445: PPUSH
14446: PPUSH
// uc_side := 3 ;
14447: LD_ADDR_OWVAR 20
14451: PUSH
14452: LD_INT 3
14454: ST_TO_ADDR
// uc_nation := 3 ;
14455: LD_ADDR_OWVAR 21
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// ru_can_attack := false ;
14463: LD_ADDR_EXP 8
14467: PUSH
14468: LD_INT 0
14470: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
14471: LD_ADDR_VAR 0 6
14475: PUSH
14476: LD_INT 22
14478: PUSH
14479: LD_INT 3
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: PUSH
14486: LD_INT 30
14488: PUSH
14489: LD_INT 3
14491: PUSH
14492: EMPTY
14493: LIST
14494: LIST
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: PPUSH
14500: CALL_OW 69
14504: ST_TO_ADDR
// if fac then
14505: LD_VAR 0 6
14509: IFFALSE 14661
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
14511: LD_ADDR_EXP 37
14515: PUSH
14516: LD_INT 24
14518: PUSH
14519: LD_INT 1
14521: PUSH
14522: LD_INT 3
14524: PUSH
14525: LD_INT 43
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: ST_TO_ADDR
// if wave > 1 then
14534: LD_VAR 0 1
14538: PUSH
14539: LD_INT 1
14541: GREATER
14542: IFFALSE 14595
// for i = 1 to Difficulty do
14544: LD_ADDR_VAR 0 3
14548: PUSH
14549: DOUBLE
14550: LD_INT 1
14552: DEC
14553: ST_TO_ADDR
14554: LD_OWVAR 67
14558: PUSH
14559: FOR_TO
14560: IFFALSE 14593
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14562: LD_ADDR_EXP 37
14566: PUSH
14567: LD_EXP 37
14571: PUSH
14572: LD_INT 24
14574: PUSH
14575: LD_INT 1
14577: PUSH
14578: LD_INT 3
14580: PUSH
14581: LD_INT 45
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: ADD
14590: ST_TO_ADDR
14591: GO 14559
14593: POP
14594: POP
// repeat wait ( 0 0$1 ) ;
14595: LD_INT 35
14597: PPUSH
14598: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14602: LD_EXP 37
14606: PUSH
14607: LD_INT 4
14609: LESS
14610: PUSH
14611: LD_VAR 0 6
14615: PUSH
14616: LD_INT 1
14618: ARRAY
14619: PPUSH
14620: CALL_OW 313
14624: PUSH
14625: LD_INT 0
14627: EQUAL
14628: OR
14629: PUSH
14630: LD_VAR 0 6
14634: PUSH
14635: LD_INT 1
14637: ARRAY
14638: PPUSH
14639: CALL_OW 461
14643: PUSH
14644: LD_INT 8
14646: PUSH
14647: LD_INT 6
14649: PUSH
14650: LD_INT 7
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: LIST
14657: IN
14658: OR
14659: IFFALSE 14595
// end ; case wave of 1 :
14661: LD_VAR 0 1
14665: PUSH
14666: LD_INT 1
14668: DOUBLE
14669: EQUAL
14670: IFTRUE 14674
14672: GO 14759
14674: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14675: LD_ADDR_VAR 0 3
14679: PUSH
14680: DOUBLE
14681: LD_INT 1
14683: DEC
14684: ST_TO_ADDR
14685: LD_INT 4
14687: PUSH
14688: LD_INT 5
14690: PUSH
14691: LD_INT 6
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: LIST
14698: PUSH
14699: LD_OWVAR 67
14703: ARRAY
14704: PUSH
14705: FOR_TO
14706: IFFALSE 14714
// Sold ;
14708: CALL 14985 0 0
14712: GO 14705
14714: POP
14715: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14716: LD_ADDR_VAR 0 3
14720: PUSH
14721: DOUBLE
14722: LD_INT 1
14724: DEC
14725: ST_TO_ADDR
14726: LD_INT 2
14728: PUSH
14729: LD_INT 3
14731: PUSH
14732: LD_INT 3
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: LIST
14739: PUSH
14740: LD_OWVAR 67
14744: ARRAY
14745: PUSH
14746: FOR_TO
14747: IFFALSE 14755
// Tank ;
14749: CALL 15115 0 0
14753: GO 14746
14755: POP
14756: POP
// end ; 2 .. 9 :
14757: GO 14972
14759: LD_INT 2
14761: DOUBLE
14762: GREATEREQUAL
14763: IFFALSE 14771
14765: LD_INT 9
14767: DOUBLE
14768: LESSEQUAL
14769: IFTRUE 14773
14771: GO 14878
14773: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( wave div 2 ) do
14774: LD_ADDR_VAR 0 3
14778: PUSH
14779: DOUBLE
14780: LD_INT 1
14782: DEC
14783: ST_TO_ADDR
14784: LD_INT 4
14786: PUSH
14787: LD_INT 5
14789: PUSH
14790: LD_INT 6
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: LIST
14797: PUSH
14798: LD_OWVAR 67
14802: ARRAY
14803: PUSH
14804: LD_VAR 0 1
14808: PUSH
14809: LD_INT 2
14811: DIV
14812: PLUS
14813: PUSH
14814: FOR_TO
14815: IFFALSE 14823
// Sold ;
14817: CALL 14985 0 0
14821: GO 14814
14823: POP
14824: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14825: LD_ADDR_VAR 0 3
14829: PUSH
14830: DOUBLE
14831: LD_INT 1
14833: DEC
14834: ST_TO_ADDR
14835: LD_INT 3
14837: PUSH
14838: LD_INT 4
14840: PUSH
14841: LD_INT 4
14843: PUSH
14844: EMPTY
14845: LIST
14846: LIST
14847: LIST
14848: PUSH
14849: LD_OWVAR 67
14853: ARRAY
14854: PUSH
14855: LD_VAR 0 1
14859: PUSH
14860: LD_INT 2
14862: DIV
14863: PLUS
14864: PUSH
14865: FOR_TO
14866: IFFALSE 14874
// Tank ;
14868: CALL 15115 0 0
14872: GO 14865
14874: POP
14875: POP
// end ; 10 :
14876: GO 14972
14878: LD_INT 10
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14971
14886: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: DOUBLE
14893: LD_INT 1
14895: DEC
14896: ST_TO_ADDR
14897: LD_INT 10
14899: PUSH
14900: LD_INT 12
14902: PUSH
14903: LD_INT 14
14905: PUSH
14906: EMPTY
14907: LIST
14908: LIST
14909: LIST
14910: PUSH
14911: LD_OWVAR 67
14915: ARRAY
14916: PUSH
14917: FOR_TO
14918: IFFALSE 14926
// Sold ;
14920: CALL 14985 0 0
14924: GO 14917
14926: POP
14927: POP
// for i = 1 to [ 9 , 11 , 15 ] [ Difficulty ] do
14928: LD_ADDR_VAR 0 3
14932: PUSH
14933: DOUBLE
14934: LD_INT 1
14936: DEC
14937: ST_TO_ADDR
14938: LD_INT 9
14940: PUSH
14941: LD_INT 11
14943: PUSH
14944: LD_INT 15
14946: PUSH
14947: EMPTY
14948: LIST
14949: LIST
14950: LIST
14951: PUSH
14952: LD_OWVAR 67
14956: ARRAY
14957: PUSH
14958: FOR_TO
14959: IFFALSE 14967
// Tank ;
14961: CALL 15115 0 0
14965: GO 14958
14967: POP
14968: POP
// end ; end ;
14969: GO 14972
14971: POP
// ru_can_attack := true ;
14972: LD_ADDR_EXP 8
14976: PUSH
14977: LD_INT 1
14979: ST_TO_ADDR
// end ;
14980: LD_VAR 0 2
14984: RET
// function Sold ( ) ; var un , skill ; begin
14985: LD_INT 0
14987: PPUSH
14988: PPUSH
14989: PPUSH
// uc_side := 3 ;
14990: LD_ADDR_OWVAR 20
14994: PUSH
14995: LD_INT 3
14997: ST_TO_ADDR
// uc_nation := 3 ;
14998: LD_ADDR_OWVAR 21
15002: PUSH
15003: LD_INT 3
15005: ST_TO_ADDR
// InitHc ;
15006: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15010: LD_ADDR_VAR 0 3
15014: PUSH
15015: LD_INT 6
15017: PUSH
15018: LD_INT 7
15020: PUSH
15021: LD_INT 7
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: LIST
15028: PUSH
15029: LD_OWVAR 67
15033: ARRAY
15034: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15035: LD_INT 0
15037: PPUSH
15038: LD_INT 1
15040: PUSH
15041: LD_INT 9
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: LD_INT 1
15050: PPUSH
15051: LD_INT 2
15053: PPUSH
15054: CALL_OW 12
15058: ARRAY
15059: PPUSH
15060: LD_VAR 0 3
15064: PPUSH
15065: CALL_OW 380
// un := CreateHuman ;
15069: LD_ADDR_VAR 0 2
15073: PUSH
15074: CALL_OW 44
15078: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15079: LD_VAR 0 2
15083: PPUSH
15084: LD_INT 4
15086: PPUSH
15087: LD_INT 0
15089: PPUSH
15090: CALL_OW 49
// ru_force := ru_force ^ un ;
15094: LD_ADDR_EXP 35
15098: PUSH
15099: LD_EXP 35
15103: PUSH
15104: LD_VAR 0 2
15108: ADD
15109: ST_TO_ADDR
// end ;
15110: LD_VAR 0 1
15114: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15115: LD_INT 0
15117: PPUSH
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
// uc_side := 3 ;
15122: LD_ADDR_OWVAR 20
15126: PUSH
15127: LD_INT 3
15129: ST_TO_ADDR
// uc_nation := 3 ;
15130: LD_ADDR_OWVAR 21
15134: PUSH
15135: LD_INT 3
15137: ST_TO_ADDR
// InitHc ;
15138: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15142: LD_ADDR_VAR 0 5
15146: PUSH
15147: LD_INT 5
15149: PUSH
15150: LD_INT 6
15152: PUSH
15153: LD_INT 7
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: LIST
15160: PUSH
15161: LD_OWVAR 67
15165: ARRAY
15166: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15167: LD_ADDR_VAR 0 3
15171: PUSH
15172: LD_INT 22
15174: PUSH
15175: LD_INT 24
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 1
15184: PPUSH
15185: LD_INT 2
15187: PPUSH
15188: CALL_OW 12
15192: ARRAY
15193: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15194: LD_VAR 0 3
15198: PUSH
15199: LD_INT 22
15201: EQUAL
15202: IFFALSE 15237
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15204: LD_ADDR_VAR 0 4
15208: PUSH
15209: LD_INT 45
15211: PUSH
15212: LD_INT 43
15214: PUSH
15215: LD_INT 44
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: LIST
15222: PUSH
15223: LD_INT 1
15225: PPUSH
15226: LD_INT 3
15228: PPUSH
15229: CALL_OW 12
15233: ARRAY
15234: ST_TO_ADDR
15235: GO 15268
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15237: LD_ADDR_VAR 0 4
15241: PUSH
15242: LD_INT 46
15244: PUSH
15245: LD_INT 44
15247: PUSH
15248: LD_INT 45
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: PUSH
15256: LD_INT 1
15258: PPUSH
15259: LD_INT 3
15261: PPUSH
15262: CALL_OW 12
15266: ARRAY
15267: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15268: LD_ADDR_VAR 0 2
15272: PUSH
15273: LD_INT 3
15275: PPUSH
15276: LD_INT 3
15278: PPUSH
15279: LD_VAR 0 3
15283: PPUSH
15284: LD_INT 1
15286: PPUSH
15287: LD_INT 3
15289: PUSH
15290: LD_INT 3
15292: PUSH
15293: LD_INT 3
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: LIST
15302: LIST
15303: LIST
15304: PUSH
15305: LD_INT 1
15307: PPUSH
15308: LD_INT 4
15310: PPUSH
15311: CALL_OW 12
15315: ARRAY
15316: PPUSH
15317: LD_VAR 0 4
15321: PPUSH
15322: LD_INT 99
15324: PPUSH
15325: CALL 264 0 7
15329: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15330: LD_VAR 0 2
15334: PPUSH
15335: CALL_OW 263
15339: PUSH
15340: LD_INT 1
15342: EQUAL
15343: IFFALSE 15374
// begin PrepareHuman ( false , 3 , skill ) ;
15345: LD_INT 0
15347: PPUSH
15348: LD_INT 3
15350: PPUSH
15351: LD_VAR 0 5
15355: PPUSH
15356: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15360: CALL_OW 44
15364: PPUSH
15365: LD_VAR 0 2
15369: PPUSH
15370: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15374: LD_VAR 0 2
15378: PPUSH
15379: LD_INT 3
15381: PPUSH
15382: LD_INT 0
15384: PPUSH
15385: CALL_OW 49
// ru_force := ru_force ^ un ;
15389: LD_ADDR_EXP 35
15393: PUSH
15394: LD_EXP 35
15398: PUSH
15399: LD_VAR 0 2
15403: ADD
15404: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
15405: LD_VAR 0 2
15409: PPUSH
15410: LD_INT 126
15412: PPUSH
15413: LD_INT 158
15415: PPUSH
15416: CALL_OW 111
// Wait ( 0 0$3 ) ;
15420: LD_INT 105
15422: PPUSH
15423: CALL_OW 67
// ComStop ( un ) ;
15427: LD_VAR 0 2
15431: PPUSH
15432: CALL_OW 141
// end ;
15436: LD_VAR 0 1
15440: RET
// every 0 0$1 do var i , time , wave ;
15441: GO 15443
15443: DISABLE
15444: LD_INT 0
15446: PPUSH
15447: PPUSH
15448: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_INT 25200
15456: PUSH
15457: LD_INT 24150
15459: PUSH
15460: LD_INT 23100
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: LIST
15467: PUSH
15468: LD_OWVAR 67
15472: ARRAY
15473: ST_TO_ADDR
// wait ( time ) ;
15474: LD_VAR 0 2
15478: PPUSH
15479: CALL_OW 67
// time := [ 7 7$30 , 7 7$10 , 6 6$50 ] [ Difficulty ] ;
15483: LD_ADDR_VAR 0 2
15487: PUSH
15488: LD_INT 15750
15490: PUSH
15491: LD_INT 15050
15493: PUSH
15494: LD_INT 14350
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: LIST
15501: PUSH
15502: LD_OWVAR 67
15506: ARRAY
15507: ST_TO_ADDR
// wave := 0 ;
15508: LD_ADDR_VAR 0 3
15512: PUSH
15513: LD_INT 0
15515: ST_TO_ADDR
// while true do
15516: LD_INT 1
15518: IFFALSE 15615
// begin wave := wave + 1 ;
15520: LD_ADDR_VAR 0 3
15524: PUSH
15525: LD_VAR 0 3
15529: PUSH
15530: LD_INT 1
15532: PLUS
15533: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
15534: LD_INT 22
15536: PUSH
15537: LD_INT 2
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL_OW 69
15548: IFFALSE 15577
// repeat wait ( 0 0$1 ) ;
15550: LD_INT 35
15552: PPUSH
15553: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
15557: LD_INT 22
15559: PUSH
15560: LD_INT 2
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PPUSH
15567: CALL_OW 69
15571: PUSH
15572: LD_INT 0
15574: EQUAL
15575: IFFALSE 15550
// if ru_force < 20 then
15577: LD_EXP 35
15581: PUSH
15582: LD_INT 20
15584: LESS
15585: IFFALSE 15596
// PrepareAttack ( wave ) ;
15587: LD_VAR 0 3
15591: PPUSH
15592: CALL 14440 0 1
// ru_can_attack := true ;
15596: LD_ADDR_EXP 8
15600: PUSH
15601: LD_INT 1
15603: ST_TO_ADDR
// wait ( time ) ;
15604: LD_VAR 0 2
15608: PPUSH
15609: CALL_OW 67
// end ;
15613: GO 15516
// end ;
15615: PPOPN 3
15617: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15618: LD_EXP 8
15622: PUSH
15623: LD_EXP 35
15627: AND
15628: IFFALSE 16462
15630: GO 15632
15632: DISABLE
15633: LD_INT 0
15635: PPUSH
15636: PPUSH
15637: PPUSH
15638: PPUSH
15639: PPUSH
15640: PPUSH
15641: PPUSH
15642: PPUSH
15643: PPUSH
// begin enable ;
15644: ENABLE
// points1 := [ 107 , 123 ] ;
15645: LD_ADDR_VAR 0 4
15649: PUSH
15650: LD_INT 107
15652: PUSH
15653: LD_INT 123
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15660: LD_ADDR_VAR 0 5
15664: PUSH
15665: LD_INT 55
15667: PUSH
15668: LD_INT 42
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15675: LD_ADDR_VAR 0 6
15679: PUSH
15680: LD_INT 102
15682: PUSH
15683: LD_INT 140
15685: PUSH
15686: EMPTY
15687: LIST
15688: LIST
15689: PUSH
15690: LD_INT 105
15692: PUSH
15693: LD_INT 142
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PUSH
15700: LD_INT 129
15702: PUSH
15703: LD_INT 131
15705: PUSH
15706: EMPTY
15707: LIST
15708: LIST
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: LIST
15714: ST_TO_ADDR
// for i in ru_force do
15715: LD_ADDR_VAR 0 1
15719: PUSH
15720: LD_EXP 35
15724: PUSH
15725: FOR_IN
15726: IFFALSE 16460
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15728: LD_ADDR_VAR 0 3
15732: PUSH
15733: LD_INT 81
15735: PUSH
15736: LD_INT 3
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PPUSH
15743: CALL_OW 69
15747: PPUSH
15748: LD_VAR 0 1
15752: PPUSH
15753: CALL_OW 74
15757: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15758: LD_VAR 0 1
15762: PPUSH
15763: LD_VAR 0 3
15767: PPUSH
15768: CALL_OW 296
15772: PUSH
15773: LD_INT 12
15775: LESS
15776: IFFALSE 15921
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15778: LD_VAR 0 1
15782: PPUSH
15783: CALL_OW 247
15787: PUSH
15788: LD_INT 1
15790: EQUAL
15791: PUSH
15792: LD_VAR 0 1
15796: PPUSH
15797: CALL_OW 257
15801: PUSH
15802: LD_INT 1
15804: EQUAL
15805: AND
15806: PUSH
15807: LD_VAR 0 3
15811: PUSH
15812: LD_INT 21
15814: PUSH
15815: LD_INT 2
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PUSH
15822: LD_INT 58
15824: PUSH
15825: EMPTY
15826: LIST
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: PPUSH
15832: CALL_OW 69
15836: IN
15837: AND
15838: IFFALSE 15856
// ComEnterUnit ( i , un ) else
15840: LD_VAR 0 1
15844: PPUSH
15845: LD_VAR 0 3
15849: PPUSH
15850: CALL_OW 120
15854: GO 15919
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15856: LD_VAR 0 3
15860: PUSH
15861: LD_INT 21
15863: PUSH
15864: LD_INT 2
15866: PUSH
15867: EMPTY
15868: LIST
15869: LIST
15870: PUSH
15871: LD_INT 58
15873: PUSH
15874: EMPTY
15875: LIST
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: IN
15886: NOT
15887: IFFALSE 15905
// ComAttackUnit ( i , un ) else
15889: LD_VAR 0 1
15893: PPUSH
15894: LD_VAR 0 3
15898: PPUSH
15899: CALL_OW 115
15903: GO 15919
// ComAttackUnit ( i , JMM ) ;
15905: LD_VAR 0 1
15909: PPUSH
15910: LD_EXP 18
15914: PPUSH
15915: CALL_OW 115
// end else
15919: GO 16458
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
15921: LD_VAR 0 1
15925: PPUSH
15926: LD_VAR 0 4
15930: PUSH
15931: LD_INT 1
15933: ARRAY
15934: PPUSH
15935: LD_VAR 0 4
15939: PUSH
15940: LD_INT 2
15942: ARRAY
15943: PPUSH
15944: CALL_OW 297
15948: PUSH
15949: LD_VAR 0 1
15953: PPUSH
15954: LD_VAR 0 5
15958: PUSH
15959: LD_INT 1
15961: ARRAY
15962: PPUSH
15963: LD_VAR 0 5
15967: PUSH
15968: LD_INT 2
15970: ARRAY
15971: PPUSH
15972: CALL_OW 297
15976: GREATER
15977: PUSH
15978: LD_EXP 9
15982: AND
15983: PUSH
15984: LD_INT 9
15986: PPUSH
15987: LD_INT 81
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PPUSH
15997: CALL_OW 70
16001: PUSH
16002: LD_INT 0
16004: EQUAL
16005: OR
16006: IFFALSE 16044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16008: LD_VAR 0 1
16012: PPUSH
16013: LD_INT 81
16015: PUSH
16016: LD_INT 3
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PPUSH
16023: CALL_OW 69
16027: PPUSH
16028: LD_VAR 0 1
16032: PPUSH
16033: CALL_OW 74
16037: PPUSH
16038: CALL_OW 115
16042: GO 16458
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16044: LD_VAR 0 1
16048: PPUSH
16049: CALL_OW 264
16053: PUSH
16054: LD_INT 45
16056: EQUAL
16057: PUSH
16058: LD_EXP 35
16062: PPUSH
16063: LD_INT 3
16065: PUSH
16066: LD_INT 34
16068: PUSH
16069: LD_INT 45
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: PPUSH
16080: CALL_OW 72
16084: PUSH
16085: LD_INT 6
16087: GREATER
16088: AND
16089: IFFALSE 16270
// begin dist := 9999 ;
16091: LD_ADDR_VAR 0 8
16095: PUSH
16096: LD_INT 9999
16098: ST_TO_ADDR
// xy := 0 ;
16099: LD_ADDR_VAR 0 9
16103: PUSH
16104: LD_INT 0
16106: ST_TO_ADDR
// for x in pointsr do
16107: LD_ADDR_VAR 0 7
16111: PUSH
16112: LD_VAR 0 6
16116: PUSH
16117: FOR_IN
16118: IFFALSE 16266
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16120: LD_VAR 0 1
16124: PPUSH
16125: LD_VAR 0 7
16129: PUSH
16130: LD_INT 1
16132: ARRAY
16133: PPUSH
16134: LD_VAR 0 7
16138: PUSH
16139: LD_INT 2
16141: ARRAY
16142: PPUSH
16143: CALL_OW 297
16147: PUSH
16148: LD_VAR 0 8
16152: LESS
16153: IFFALSE 16198
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16155: LD_ADDR_VAR 0 8
16159: PUSH
16160: LD_VAR 0 1
16164: PPUSH
16165: LD_VAR 0 7
16169: PUSH
16170: LD_INT 1
16172: ARRAY
16173: PPUSH
16174: LD_VAR 0 7
16178: PUSH
16179: LD_INT 2
16181: ARRAY
16182: PPUSH
16183: CALL_OW 297
16187: ST_TO_ADDR
// xy := x ;
16188: LD_ADDR_VAR 0 9
16192: PUSH
16193: LD_VAR 0 7
16197: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16198: LD_VAR 0 9
16202: PUSH
16203: LD_VAR 0 1
16207: PPUSH
16208: LD_VAR 0 9
16212: PUSH
16213: LD_INT 1
16215: ARRAY
16216: PPUSH
16217: LD_VAR 0 9
16221: PUSH
16222: LD_INT 2
16224: ARRAY
16225: PPUSH
16226: CALL_OW 297
16230: PUSH
16231: LD_INT 9
16233: GREATER
16234: AND
16235: IFFALSE 16264
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16237: LD_VAR 0 1
16241: PPUSH
16242: LD_VAR 0 9
16246: PUSH
16247: LD_INT 1
16249: ARRAY
16250: PPUSH
16251: LD_VAR 0 9
16255: PUSH
16256: LD_INT 2
16258: ARRAY
16259: PPUSH
16260: CALL_OW 114
// end ;
16264: GO 16117
16266: POP
16267: POP
// end else
16268: GO 16458
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16270: LD_ADDR_VAR 0 3
16274: PUSH
16275: LD_OWVAR 3
16279: PUSH
16280: LD_VAR 0 1
16284: DIFF
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 74
16295: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16296: LD_VAR 0 1
16300: PPUSH
16301: CALL_OW 320
16305: NOT
16306: PUSH
16307: LD_VAR 0 3
16311: PUSH
16312: LD_INT 21
16314: PUSH
16315: LD_INT 2
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 33
16324: PUSH
16325: LD_INT 1
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 58
16334: PUSH
16335: EMPTY
16336: LIST
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: LIST
16342: PPUSH
16343: CALL_OW 69
16347: IN
16348: PUSH
16349: LD_VAR 0 3
16353: PUSH
16354: LD_INT 22
16356: PUSH
16357: LD_INT 3
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PUSH
16364: LD_INT 21
16366: PUSH
16367: LD_INT 2
16369: PUSH
16370: EMPTY
16371: LIST
16372: LIST
16373: PUSH
16374: LD_INT 3
16376: PUSH
16377: LD_INT 24
16379: PUSH
16380: LD_INT 249
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: LIST
16395: PPUSH
16396: CALL_OW 69
16400: IN
16401: OR
16402: AND
16403: IFFALSE 16421
// ComAttackUnit ( i , un ) else
16405: LD_VAR 0 1
16409: PPUSH
16410: LD_VAR 0 3
16414: PPUSH
16415: CALL_OW 115
16419: GO 16458
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
16421: LD_VAR 0 1
16425: PPUSH
16426: LD_INT 9
16428: PPUSH
16429: LD_INT 81
16431: PUSH
16432: LD_INT 3
16434: PUSH
16435: EMPTY
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL_OW 70
16443: PPUSH
16444: LD_VAR 0 1
16448: PPUSH
16449: CALL_OW 74
16453: PPUSH
16454: CALL_OW 115
// end ; end ; end ; end ;
16458: GO 15725
16460: POP
16461: POP
// end ;
16462: PPOPN 9
16464: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
16465: LD_INT 22
16467: PUSH
16468: LD_INT 3
16470: PUSH
16471: EMPTY
16472: LIST
16473: LIST
16474: PUSH
16475: LD_INT 32
16477: PUSH
16478: LD_INT 1
16480: PUSH
16481: EMPTY
16482: LIST
16483: LIST
16484: PUSH
16485: EMPTY
16486: LIST
16487: LIST
16488: PPUSH
16489: CALL_OW 69
16493: IFFALSE 16581
16495: GO 16497
16497: DISABLE
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
// begin enable ;
16502: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
16503: LD_ADDR_VAR 0 2
16507: PUSH
16508: LD_INT 22
16510: PUSH
16511: LD_INT 3
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PUSH
16518: LD_INT 32
16520: PUSH
16521: LD_INT 1
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PUSH
16528: EMPTY
16529: LIST
16530: LIST
16531: PPUSH
16532: CALL_OW 69
16536: ST_TO_ADDR
// for i in tmp do
16537: LD_ADDR_VAR 0 1
16541: PUSH
16542: LD_VAR 0 2
16546: PUSH
16547: FOR_IN
16548: IFFALSE 16579
// if GetFuel ( i ) < 12 then
16550: LD_VAR 0 1
16554: PPUSH
16555: CALL_OW 261
16559: PUSH
16560: LD_INT 12
16562: LESS
16563: IFFALSE 16577
// SetFuel ( i , 12 ) ;
16565: LD_VAR 0 1
16569: PPUSH
16570: LD_INT 12
16572: PPUSH
16573: CALL_OW 240
16577: GO 16547
16579: POP
16580: POP
// end ;
16581: PPOPN 2
16583: END
// every 0 0$1 trigger can_end do
16584: LD_EXP 17
16588: IFFALSE 16607
16590: GO 16592
16592: DISABLE
// begin Wait ( 1 1$35 ) ;
16593: LD_INT 3325
16595: PPUSH
16596: CALL_OW 67
// PrepareAttack ( 10 ) ;
16600: LD_INT 10
16602: PPUSH
16603: CALL 14440 0 1
// end ;
16607: END
