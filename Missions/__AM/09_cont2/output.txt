// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// Init ;
   8: CALL 41 0 0
// DebugMode ;
  12: CALL 177 0 0
// PrepareNature ;
  16: CALL 352 0 0
// PrepareRussian ;
  20: CALL 12137 0 0
// PrepareAmerican ;
  24: CALL 1085 0 0
// PrepareOvsyenko ;
  28: CALL 1745 0 0
// Action ;
  32: CALL 2549 0 0
// SaveForQuickRestart ;
  36: CALL_OW 22
// end ;
  40: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := false ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// mission_prefix := 09_ ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_STRING 09_
  67: ST_TO_ADDR
// powell_want_sib := false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 31500
  83: ST_TO_ADDR
// game_time := 47 47$00 ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 98700
  91: ST_TO_ADDR
// ru_can_attack := false ;
  92: LD_ADDR_EXP 8
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// ar_can_arrive := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// ar_spawned := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// player_want_mortar := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// player_want_info := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// player_get_mortar := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_get_info := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_attacked_ar := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// can_end := false ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// end ;
 172: LD_VAR 0 1
 176: RET
// function DebugMode ; begin
 177: LD_INT 0
 179: PPUSH
// if not debug then
 180: LD_EXP 2
 184: NOT
 185: IFFALSE 189
// exit ;
 187: GO 196
// FogOff ( 1 ) ;
 189: LD_INT 1
 191: PPUSH
 192: CALL_OW 344
// end ; end_of_file
 196: LD_VAR 0 1
 200: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
// if exist_mode then
 205: LD_VAR 0 2
 209: IFFALSE 234
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 211: LD_ADDR_VAR 0 5
 215: PUSH
 216: LD_VAR 0 3
 220: PUSH
 221: LD_VAR 0 1
 225: STR
 226: PPUSH
 227: CALL_OW 34
 231: ST_TO_ADDR
 232: GO 249
// unit := NewCharacter ( ident ) ;
 234: LD_ADDR_VAR 0 5
 238: PUSH
 239: LD_VAR 0 1
 243: PPUSH
 244: CALL_OW 25
 248: ST_TO_ADDR
// result := unit ;
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 5
 258: ST_TO_ADDR
// end ;
 259: LD_VAR 0 4
 263: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 264: LD_INT 0
 266: PPUSH
// uc_side := side ;
 267: LD_ADDR_OWVAR 20
 271: PUSH
 272: LD_VAR 0 1
 276: ST_TO_ADDR
// uc_nation := nation ;
 277: LD_ADDR_OWVAR 21
 281: PUSH
 282: LD_VAR 0 2
 286: ST_TO_ADDR
// vc_chassis := chassis ;
 287: LD_ADDR_OWVAR 37
 291: PUSH
 292: LD_VAR 0 3
 296: ST_TO_ADDR
// vc_engine := engine ;
 297: LD_ADDR_OWVAR 39
 301: PUSH
 302: LD_VAR 0 4
 306: ST_TO_ADDR
// vc_control := control ;
 307: LD_ADDR_OWVAR 38
 311: PUSH
 312: LD_VAR 0 5
 316: ST_TO_ADDR
// vc_weapon := weapon ;
 317: LD_ADDR_OWVAR 40
 321: PUSH
 322: LD_VAR 0 6
 326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 327: LD_ADDR_OWVAR 41
 331: PUSH
 332: LD_VAR 0 7
 336: ST_TO_ADDR
// result := CreateVehicle ;
 337: LD_ADDR_VAR 0 8
 341: PUSH
 342: CALL_OW 45
 346: ST_TO_ADDR
// end ;
 347: LD_VAR 0 8
 351: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 352: LD_INT 0
 354: PPUSH
 355: PPUSH
 356: PPUSH
 357: PPUSH
// uc_side = 0 ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// uc_nation = 0 ;
 366: LD_ADDR_OWVAR 21
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// nat_area := natureArea ;
 374: LD_ADDR_VAR 0 4
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// InitHc ;
 382: CALL_OW 19
// for i = 1 to 4 do
 386: LD_ADDR_VAR 0 2
 390: PUSH
 391: DOUBLE
 392: LD_INT 1
 394: DEC
 395: ST_TO_ADDR
 396: LD_INT 4
 398: PUSH
 399: FOR_TO
 400: IFFALSE 455
// begin hc_class = 18 ;
 402: LD_ADDR_OWVAR 28
 406: PUSH
 407: LD_INT 18
 409: ST_TO_ADDR
// hc_gallery =  ;
 410: LD_ADDR_OWVAR 33
 414: PUSH
 415: LD_STRING 
 417: ST_TO_ADDR
// hc_face_number = 1 ;
 418: LD_ADDR_OWVAR 34
 422: PUSH
 423: LD_INT 1
 425: ST_TO_ADDR
// animal := CreateHuman ;
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: CALL_OW 44
 435: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 436: LD_VAR 0 3
 440: PPUSH
 441: LD_VAR 0 4
 445: PPUSH
 446: LD_INT 0
 448: PPUSH
 449: CALL_OW 49
// end ;
 453: GO 399
 455: POP
 456: POP
// for i = 1 to 4 do
 457: LD_ADDR_VAR 0 2
 461: PUSH
 462: DOUBLE
 463: LD_INT 1
 465: DEC
 466: ST_TO_ADDR
 467: LD_INT 4
 469: PUSH
 470: FOR_TO
 471: IFFALSE 543
// begin hc_class = class_tiger ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 14
 480: ST_TO_ADDR
// hc_gallery =  ;
 481: LD_ADDR_OWVAR 33
 485: PUSH
 486: LD_STRING 
 488: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 489: LD_ADDR_OWVAR 35
 493: PUSH
 494: LD_INT 5
 496: NEG
 497: PPUSH
 498: LD_INT 5
 500: PPUSH
 501: CALL_OW 12
 505: ST_TO_ADDR
// hc_face_number = 3 ;
 506: LD_ADDR_OWVAR 34
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// animal := CreateHuman ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: CALL_OW 44
 523: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 524: LD_VAR 0 3
 528: PPUSH
 529: LD_VAR 0 4
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 49
// end ;
 541: GO 470
 543: POP
 544: POP
// for i = 1 to 8 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 8
 557: PUSH
 558: FOR_TO
 559: IFFALSE 662
// begin hc_class = class_apeman ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 12
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 577: LD_ADDR_OWVAR 35
 581: PUSH
 582: LD_INT 2
 584: NEG
 585: PPUSH
 586: LD_INT 2
 588: PPUSH
 589: CALL_OW 12
 593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 594: LD_ADDR_OWVAR 31
 598: PUSH
 599: LD_INT 1
 601: PPUSH
 602: LD_INT 3
 604: PPUSH
 605: CALL_OW 12
 609: PUSH
 610: LD_INT 1
 612: PPUSH
 613: LD_INT 3
 615: PPUSH
 616: CALL_OW 12
 620: PUSH
 621: LD_INT 0
 623: PUSH
 624: LD_INT 0
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: LIST
 632: ST_TO_ADDR
// animal := CreateHuman ;
 633: LD_ADDR_VAR 0 3
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 643: LD_VAR 0 3
 647: PPUSH
 648: LD_VAR 0 4
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 558
 662: POP
 663: POP
// for i = 1 to 6 do
 664: LD_ADDR_VAR 0 2
 668: PUSH
 669: DOUBLE
 670: LD_INT 1
 672: DEC
 673: ST_TO_ADDR
 674: LD_INT 6
 676: PUSH
 677: FOR_TO
 678: IFFALSE 733
// begin hc_class = 13 ;
 680: LD_ADDR_OWVAR 28
 684: PUSH
 685: LD_INT 13
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_face_number = 4 ;
 696: LD_ADDR_OWVAR 34
 700: PUSH
 701: LD_INT 4
 703: ST_TO_ADDR
// animal := CreateHuman ;
 704: LD_ADDR_VAR 0 3
 708: PUSH
 709: CALL_OW 44
 713: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 714: LD_VAR 0 3
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: LD_INT 0
 726: PPUSH
 727: CALL_OW 49
// end ;
 731: GO 677
 733: POP
 734: POP
// vc_chassis := 31 ;
 735: LD_ADDR_OWVAR 37
 739: PUSH
 740: LD_INT 31
 742: ST_TO_ADDR
// vc_control := control_rider ;
 743: LD_ADDR_OWVAR 38
 747: PUSH
 748: LD_INT 4
 750: ST_TO_ADDR
// animal := CreateVehicle ;
 751: LD_ADDR_VAR 0 3
 755: PUSH
 756: CALL_OW 45
 760: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_INT 21
 768: PPUSH
 769: LD_INT 22
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: CALL_OW 48
// end ;
 779: LD_VAR 0 1
 783: RET
// export function GetTerminalCargo ; begin
 784: LD_INT 0
 786: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 787: LD_ADDR_VAR 0 1
 791: PUSH
 792: LD_EXP 3
 796: PPUSH
 797: CALL_OW 274
 801: PPUSH
 802: LD_INT 3
 804: PPUSH
 805: CALL_OW 275
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// result := 0 ;
 820: LD_ADDR_VAR 0 2
 824: PUSH
 825: LD_INT 0
 827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 828: LD_ADDR_VAR 0 4
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_VAR 0 1
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: LD_INT 30
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PPUSH
 877: CALL_OW 69
 881: ST_TO_ADDR
// if not tmp then
 882: LD_VAR 0 4
 886: NOT
 887: IFFALSE 891
// exit ;
 889: GO 937
// for i in tmp do
 891: LD_ADDR_VAR 0 3
 895: PUSH
 896: LD_VAR 0 4
 900: PUSH
 901: FOR_IN
 902: IFFALSE 935
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 904: LD_ADDR_VAR 0 2
 908: PUSH
 909: LD_VAR 0 2
 913: PUSH
 914: LD_VAR 0 3
 918: PPUSH
 919: CALL_OW 274
 923: PPUSH
 924: LD_INT 3
 926: PPUSH
 927: CALL_OW 275
 931: PLUS
 932: ST_TO_ADDR
 933: GO 901
 935: POP
 936: POP
// end ;
 937: LD_VAR 0 2
 941: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 942: LD_INT 0
 944: PPUSH
 945: PPUSH
// area = ListEnvironmentArea ( area ) ;
 946: LD_ADDR_VAR 0 2
 950: PUSH
 951: LD_VAR 0 2
 955: PPUSH
 956: CALL_OW 353
 960: ST_TO_ADDR
// if bulldozer > 0 then
 961: LD_VAR 0 1
 965: PUSH
 966: LD_INT 0
 968: GREATER
 969: IFFALSE 1080
// for i = area downto 1 do
 971: LD_ADDR_VAR 0 4
 975: PUSH
 976: DOUBLE
 977: LD_VAR 0 2
 981: INC
 982: ST_TO_ADDR
 983: LD_INT 1
 985: PUSH
 986: FOR_DOWNTO
 987: IFFALSE 1078
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 989: LD_VAR 0 2
 993: PUSH
 994: LD_VAR 0 4
 998: ARRAY
 999: PUSH
1000: LD_INT 1
1002: ARRAY
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_VAR 0 4
1013: ARRAY
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 351
1023: IFFALSE 1076
// if not HasTask ( bulldozer ) then
1025: LD_VAR 0 1
1029: PPUSH
1030: CALL_OW 314
1034: NOT
1035: IFFALSE 1076
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1037: LD_VAR 0 1
1041: PPUSH
1042: LD_VAR 0 2
1046: PUSH
1047: LD_VAR 0 4
1051: ARRAY
1052: PUSH
1053: LD_INT 1
1055: ARRAY
1056: PPUSH
1057: LD_VAR 0 2
1061: PUSH
1062: LD_VAR 0 4
1066: ARRAY
1067: PUSH
1068: LD_INT 2
1070: ARRAY
1071: PPUSH
1072: CALL_OW 171
1076: GO 986
1078: POP
1079: POP
// end ; end_of_file
1080: LD_VAR 0 3
1084: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1085: LD_INT 0
1087: PPUSH
1088: PPUSH
1089: PPUSH
1090: PPUSH
1091: PPUSH
// uc_side := 1 ;
1092: LD_ADDR_OWVAR 20
1096: PUSH
1097: LD_INT 1
1099: ST_TO_ADDR
// uc_nation := 1 ;
1100: LD_ADDR_OWVAR 21
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1108: LD_ADDR_EXP 18
1112: PUSH
1113: LD_STRING JMM
1115: PPUSH
1116: LD_EXP 2
1120: NOT
1121: PPUSH
1122: LD_STRING 08_
1124: PPUSH
1125: CALL 201 0 3
1129: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: LD_INT 2
1146: PPUSH
1147: LD_INT 1
1149: PPUSH
1150: LD_INT 5
1152: PPUSH
1153: LD_INT 55
1155: PPUSH
1156: CALL 264 0 7
1160: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1161: LD_VAR 0 4
1165: PPUSH
1166: LD_INT 3
1168: PPUSH
1169: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1173: LD_VAR 0 4
1177: PPUSH
1178: LD_INT 43
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 0
1186: PPUSH
1187: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1191: LD_EXP 18
1195: PPUSH
1196: LD_VAR 0 4
1200: PPUSH
1201: CALL_OW 52
// tmp := [ ] ;
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: EMPTY
1211: ST_TO_ADDR
// uc_side := 4 ;
1212: LD_ADDR_OWVAR 20
1216: PUSH
1217: LD_INT 4
1219: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1220: LD_ADDR_OWVAR 33
1224: PUSH
1225: LD_STRING SecondCharsGal
1227: ST_TO_ADDR
// hc_class := 2 ;
1228: LD_ADDR_OWVAR 28
1232: PUSH
1233: LD_INT 2
1235: ST_TO_ADDR
// hc_sex := sex_female ;
1236: LD_ADDR_OWVAR 27
1240: PUSH
1241: LD_INT 2
1243: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1244: LD_ADDR_OWVAR 30
1248: PUSH
1249: LD_INT 0
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1267: LD_ADDR_OWVAR 31
1271: PUSH
1272: LD_INT 3
1274: PUSH
1275: LD_INT 4
1277: PUSH
1278: LD_INT 2
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1290: LD_ADDR_OWVAR 29
1294: PUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 11
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1305: LD_ADDR_OWVAR 26
1309: PUSH
1310: LD_STRING Naoma Goichman
1312: ST_TO_ADDR
// hc_face_number := 43 ;
1313: LD_ADDR_OWVAR 34
1317: PUSH
1318: LD_INT 43
1320: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1321: LD_ADDR_VAR 0 2
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: CALL_OW 44
1335: ADD
1336: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1337: LD_ADDR_OWVAR 30
1341: PUSH
1342: LD_INT 0
1344: PUSH
1345: LD_INT 2
1347: PUSH
1348: LD_INT 0
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1360: LD_ADDR_OWVAR 31
1364: PUSH
1365: LD_INT 0
1367: PUSH
1368: LD_INT 5
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 1
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1383: LD_ADDR_OWVAR 29
1387: PUSH
1388: LD_INT 10
1390: PUSH
1391: LD_INT 10
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING Magdalene Glance
1405: ST_TO_ADDR
// hc_face_number := 44 ;
1406: LD_ADDR_OWVAR 34
1410: PUSH
1411: LD_INT 44
1413: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_VAR 0 2
1423: PUSH
1424: CALL_OW 44
1428: ADD
1429: ST_TO_ADDR
// hc_sex := sex_male ;
1430: LD_ADDR_OWVAR 27
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1438: LD_ADDR_OWVAR 30
1442: PUSH
1443: LD_INT 2
1445: PUSH
1446: LD_INT 2
1448: PUSH
1449: LD_INT 0
1451: PUSH
1452: LD_INT 0
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1461: LD_ADDR_OWVAR 31
1465: PUSH
1466: LD_INT 3
1468: PUSH
1469: LD_INT 4
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 0
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1484: LD_ADDR_OWVAR 29
1488: PUSH
1489: LD_INT 12
1491: PUSH
1492: LD_INT 10
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: ST_TO_ADDR
// hc_name := Steve Holland ;
1499: LD_ADDR_OWVAR 26
1503: PUSH
1504: LD_STRING Steve Holland
1506: ST_TO_ADDR
// hc_face_number := 60 ;
1507: LD_ADDR_OWVAR 34
1511: PUSH
1512: LD_INT 60
1514: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1515: LD_ADDR_VAR 0 2
1519: PUSH
1520: LD_VAR 0 2
1524: PUSH
1525: CALL_OW 44
1529: ADD
1530: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1531: LD_ADDR_EXP 23
1535: PUSH
1536: LD_VAR 0 2
1540: PUSH
1541: LD_INT 0
1543: DIFF
1544: ST_TO_ADDR
// for un in alpha_engs do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: LD_EXP 23
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1581
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1558: LD_VAR 0 3
1562: PPUSH
1563: LD_INT 52
1565: PPUSH
1566: LD_INT 35
1568: PPUSH
1569: LD_INT 3
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 50
1579: GO 1555
1581: POP
1582: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1583: LD_ADDR_VAR 0 2
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_INT 1
1595: PUSH
1596: LD_STRING 06_crates_1
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 30
1606: PLUS
1607: PUSH
1608: LD_INT 2
1610: MUL
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1639
// CreateResourcesXYR ( mat_cans , 5 , 54 , 40 , 2 , false ) ;
1615: LD_INT 1
1617: PPUSH
1618: LD_INT 5
1620: PPUSH
1621: LD_INT 54
1623: PPUSH
1624: LD_INT 40
1626: PPUSH
1627: LD_INT 2
1629: PPUSH
1630: LD_INT 0
1632: PPUSH
1633: CALL_OW 60
1637: GO 1612
1639: POP
1640: POP
// if LoadVariable ( gamma_commander , 0 ) < 3 then
1641: LD_STRING gamma_commander
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 30
1651: PUSH
1652: LD_INT 3
1654: LESS
1655: IFFALSE 1713
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
1657: LD_ADDR_EXP 22
1661: PUSH
1662: LD_STRING VanHouten
1664: PPUSH
1665: LD_INT 0
1667: PPUSH
1668: LD_STRING 
1670: PPUSH
1671: CALL 201 0 3
1675: ST_TO_ADDR
// for i = 1 to 4 do
1676: LD_ADDR_VAR 0 5
1680: PUSH
1681: DOUBLE
1682: LD_INT 1
1684: DEC
1685: ST_TO_ADDR
1686: LD_INT 4
1688: PUSH
1689: FOR_TO
1690: IFFALSE 1711
// AddExperience ( Houten , i , 10000 ) ;
1692: LD_EXP 22
1696: PPUSH
1697: LD_VAR 0 5
1701: PPUSH
1702: LD_INT 10000
1704: PPUSH
1705: CALL_OW 492
1709: GO 1689
1711: POP
1712: POP
// end ; Powell := PrepareUnit ( Powell , false ,  ) ;
1713: LD_ADDR_EXP 25
1717: PUSH
1718: LD_STRING Powell
1720: PPUSH
1721: LD_INT 0
1723: PPUSH
1724: LD_STRING 
1726: PPUSH
1727: CALL 201 0 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// InitUc ;
1736: CALL_OW 18
// end ;
1740: LD_VAR 0 1
1744: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1745: LD_INT 0
1747: PPUSH
1748: PPUSH
1749: PPUSH
1750: PPUSH
1751: PPUSH
// uc_side := 4 ;
1752: LD_ADDR_OWVAR 20
1756: PUSH
1757: LD_INT 4
1759: ST_TO_ADDR
// uc_nation := 3 ;
1760: LD_ADDR_OWVAR 21
1764: PUSH
1765: LD_INT 3
1767: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 ] , [ b_breastwork , 109 , 114 , 4 ] , [ b_breastwork , 115 , 132 , 5 ] , [ b_breastwork , 98 , 120 , 1 ] ] ) ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_STRING 09_ovsyenko_base
1775: PPUSH
1776: LD_INT 0
1778: PUSH
1779: LD_INT 101
1781: PUSH
1782: LD_INT 118
1784: PUSH
1785: LD_INT 2
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 31
1796: PUSH
1797: LD_INT 109
1799: PUSH
1800: LD_INT 114
1802: PUSH
1803: LD_INT 4
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: PUSH
1812: LD_INT 31
1814: PUSH
1815: LD_INT 115
1817: PUSH
1818: LD_INT 132
1820: PUSH
1821: LD_INT 5
1823: PUSH
1824: EMPTY
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: LD_INT 31
1832: PUSH
1833: LD_INT 98
1835: PUSH
1836: LD_INT 120
1838: PUSH
1839: LD_INT 1
1841: PUSH
1842: EMPTY
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: PPUSH
1854: CALL_OW 30
1858: ST_TO_ADDR
// for i in tmp do
1859: LD_ADDR_VAR 0 2
1863: PUSH
1864: LD_VAR 0 4
1868: PUSH
1869: FOR_IN
1870: IFFALSE 2026
// begin bc_type := i [ 1 ] ;
1872: LD_ADDR_OWVAR 42
1876: PUSH
1877: LD_VAR 0 2
1881: PUSH
1882: LD_INT 1
1884: ARRAY
1885: ST_TO_ADDR
// bc_level := 3 ;
1886: LD_ADDR_OWVAR 43
1890: PUSH
1891: LD_INT 3
1893: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1894: LD_ADDR_VAR 0 3
1898: PUSH
1899: LD_VAR 0 2
1903: PUSH
1904: LD_INT 2
1906: ARRAY
1907: PPUSH
1908: LD_VAR 0 2
1912: PUSH
1913: LD_INT 3
1915: ARRAY
1916: PPUSH
1917: LD_VAR 0 2
1921: PUSH
1922: LD_INT 4
1924: ARRAY
1925: PPUSH
1926: CALL_OW 47
1930: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1931: LD_VAR 0 3
1935: PPUSH
1936: CALL_OW 266
1940: PUSH
1941: LD_INT 0
1943: EQUAL
1944: IFFALSE 1978
// begin SetBName ( b , ovsyenko ) ;
1946: LD_VAR 0 3
1950: PPUSH
1951: LD_STRING ovsyenko
1953: PPUSH
1954: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1958: LD_VAR 0 3
1962: PPUSH
1963: CALL_OW 274
1967: PPUSH
1968: LD_INT 1
1970: PPUSH
1971: LD_INT 50
1973: PPUSH
1974: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1978: LD_VAR 0 2
1982: PUSH
1983: LD_INT 5
1985: ARRAY
1986: PUSH
1987: LD_INT 250
1989: LESS
1990: IFFALSE 2006
// SetLives ( b , 333 ) else
1992: LD_VAR 0 3
1996: PPUSH
1997: LD_INT 333
1999: PPUSH
2000: CALL_OW 234
2004: GO 2024
// SetLives ( b , i [ 5 ] ) ;
2006: LD_VAR 0 3
2010: PPUSH
2011: LD_VAR 0 2
2015: PUSH
2016: LD_INT 5
2018: ARRAY
2019: PPUSH
2020: CALL_OW 234
// end ;
2024: GO 1869
2026: POP
2027: POP
// uc_nation := 1 ;
2028: LD_ADDR_OWVAR 21
2032: PUSH
2033: LD_INT 1
2035: ST_TO_ADDR
// tmp := [ ] ;
2036: LD_ADDR_VAR 0 4
2040: PUSH
2041: EMPTY
2042: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2043: LD_ADDR_EXP 19
2047: PUSH
2048: LD_STRING Gary
2050: PPUSH
2051: LD_EXP 2
2055: NOT
2056: PPUSH
2057: LD_STRING 
2059: PPUSH
2060: CALL 201 0 3
2064: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2065: LD_ADDR_VAR 0 4
2069: PUSH
2070: LD_VAR 0 4
2074: PUSH
2075: LD_EXP 19
2079: ADD
2080: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2081: LD_ADDR_EXP 20
2085: PUSH
2086: LD_STRING Bobby
2088: PPUSH
2089: LD_EXP 2
2093: NOT
2094: PPUSH
2095: LD_STRING 03_
2097: PPUSH
2098: CALL 201 0 3
2102: ST_TO_ADDR
// if Bobby then
2103: LD_EXP 20
2107: IFFALSE 2125
// tmp := tmp ^ Bobby ;
2109: LD_ADDR_VAR 0 4
2113: PUSH
2114: LD_VAR 0 4
2118: PUSH
2119: LD_EXP 20
2123: ADD
2124: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2125: LD_ADDR_EXP 21
2129: PUSH
2130: LD_STRING Cyrus
2132: PPUSH
2133: LD_EXP 2
2137: NOT
2138: PPUSH
2139: LD_STRING 03_
2141: PPUSH
2142: CALL 201 0 3
2146: ST_TO_ADDR
// if Cyrus then
2147: LD_EXP 21
2151: IFFALSE 2169
// tmp := tmp ^ Cyrus ;
2153: LD_ADDR_VAR 0 4
2157: PUSH
2158: LD_VAR 0 4
2162: PUSH
2163: LD_EXP 21
2167: ADD
2168: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2169: LD_ADDR_VAR 0 4
2173: PUSH
2174: LD_VAR 0 4
2178: PUSH
2179: LD_STRING 09_prev_squad
2181: PPUSH
2182: CALL_OW 31
2186: ADD
2187: ST_TO_ADDR
// tmp := tmp diff 0 ;
2188: LD_ADDR_VAR 0 4
2192: PUSH
2193: LD_VAR 0 4
2197: PUSH
2198: LD_INT 0
2200: DIFF
2201: ST_TO_ADDR
// for i in tmp do
2202: LD_ADDR_VAR 0 2
2206: PUSH
2207: LD_VAR 0 4
2211: PUSH
2212: FOR_IN
2213: IFFALSE 2272
// begin if GetClass ( i ) in [ 2 , 3 ] then
2215: LD_VAR 0 2
2219: PPUSH
2220: CALL_OW 257
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: LD_INT 3
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: IN
2235: IFFALSE 2249
// SetClass ( i , 1 ) ;
2237: LD_VAR 0 2
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2249: LD_VAR 0 2
2253: PPUSH
2254: LD_INT 106
2256: PPUSH
2257: LD_INT 122
2259: PPUSH
2260: LD_INT 5
2262: PPUSH
2263: LD_INT 0
2265: PPUSH
2266: CALL_OW 50
// end ;
2270: GO 2212
2272: POP
2273: POP
// tmp := tmp diff Gary ;
2274: LD_ADDR_VAR 0 4
2278: PUSH
2279: LD_VAR 0 4
2283: PUSH
2284: LD_EXP 19
2288: DIFF
2289: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2290: LD_ADDR_VAR 0 3
2294: PUSH
2295: LD_INT 22
2297: PUSH
2298: LD_INT 4
2300: PUSH
2301: EMPTY
2302: LIST
2303: LIST
2304: PUSH
2305: LD_INT 30
2307: PUSH
2308: LD_INT 31
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: CALL_OW 69
2323: ST_TO_ADDR
// for i = 1 to b do
2324: LD_ADDR_VAR 0 2
2328: PUSH
2329: DOUBLE
2330: LD_INT 1
2332: DEC
2333: ST_TO_ADDR
2334: LD_VAR 0 3
2338: PUSH
2339: FOR_TO
2340: IFFALSE 2370
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2342: LD_VAR 0 4
2346: PUSH
2347: LD_VAR 0 2
2351: ARRAY
2352: PPUSH
2353: LD_VAR 0 3
2357: PUSH
2358: LD_VAR 0 2
2362: ARRAY
2363: PPUSH
2364: CALL_OW 120
// end ;
2368: GO 2339
2370: POP
2371: POP
// InitHc ;
2372: CALL_OW 19
// InitUc ;
2376: CALL_OW 18
// end ;
2380: LD_VAR 0 1
2384: RET
// export function PowellTransport ; var i , un ; begin
2385: LD_INT 0
2387: PPUSH
2388: PPUSH
2389: PPUSH
// uc_side := 4 ;
2390: LD_ADDR_OWVAR 20
2394: PUSH
2395: LD_INT 4
2397: ST_TO_ADDR
// uc_nation := 1 ;
2398: LD_ADDR_OWVAR 21
2402: PUSH
2403: LD_INT 1
2405: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2406: LD_INT 1
2408: PPUSH
2409: LD_INT 3
2411: PPUSH
2412: LD_INT 6
2414: PPUSH
2415: CALL_OW 380
// hc_name :=  ;
2419: LD_ADDR_OWVAR 26
2423: PUSH
2424: LD_STRING 
2426: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2427: LD_ADDR_OWVAR 33
2431: PUSH
2432: LD_STRING SecondCharsGal
2434: ST_TO_ADDR
// hc_face_number := 30 ;
2435: LD_ADDR_OWVAR 34
2439: PUSH
2440: LD_INT 30
2442: ST_TO_ADDR
// powell_trans := CreateHuman ;
2443: LD_ADDR_EXP 24
2447: PUSH
2448: CALL_OW 44
2452: ST_TO_ADDR
// hc_face_number := 31 ;
2453: LD_ADDR_OWVAR 34
2457: PUSH
2458: LD_INT 31
2460: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2461: LD_ADDR_EXP 24
2465: PUSH
2466: LD_EXP 24
2470: PUSH
2471: CALL_OW 44
2475: ADD
2476: ST_TO_ADDR
// for i = 1 to 2 do
2477: LD_ADDR_VAR 0 2
2481: PUSH
2482: DOUBLE
2483: LD_INT 1
2485: DEC
2486: ST_TO_ADDR
2487: LD_INT 2
2489: PUSH
2490: FOR_TO
2491: IFFALSE 2542
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2493: LD_ADDR_VAR 0 3
2497: PUSH
2498: LD_INT 4
2500: PPUSH
2501: LD_INT 1
2503: PPUSH
2504: LD_INT 3
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: LD_INT 1
2512: PPUSH
2513: LD_INT 12
2515: PPUSH
2516: LD_INT 66
2518: PPUSH
2519: CALL 264 0 7
2523: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2524: LD_ADDR_EXP 24
2528: PUSH
2529: LD_EXP 24
2533: PUSH
2534: LD_VAR 0 3
2538: ADD
2539: ST_TO_ADDR
// end ;
2540: GO 2490
2542: POP
2543: POP
// end ; end_of_file
2544: LD_VAR 0 1
2548: RET
// export function Action ; var i , veh ; begin
2549: LD_INT 0
2551: PPUSH
2552: PPUSH
2553: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2554: LD_EXP 23
2558: PPUSH
2559: LD_INT 0
2561: PPUSH
2562: LD_INT 50
2564: PPUSH
2565: LD_INT 38
2567: PPUSH
2568: LD_INT 2
2570: PPUSH
2571: CALL_OW 145
// InGameOn ;
2575: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2579: LD_INT 43
2581: PPUSH
2582: LD_INT 9
2584: PPUSH
2585: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2589: LD_EXP 18
2593: PPUSH
2594: LD_INT 54
2596: PPUSH
2597: LD_INT 34
2599: PPUSH
2600: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2604: LD_EXP 18
2608: PPUSH
2609: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2613: LD_EXP 18
2617: PPUSH
2618: LD_EXP 23
2622: PUSH
2623: LD_INT 1
2625: ARRAY
2626: PPUSH
2627: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2631: LD_INT 35
2633: PPUSH
2634: CALL_OW 67
// until See ( 4 , JMM ) ;
2638: LD_INT 4
2640: PPUSH
2641: LD_EXP 18
2645: PPUSH
2646: CALL_OW 292
2650: IFFALSE 2631
// CenterNowOnUnits ( JMM ) ;
2652: LD_EXP 18
2656: PPUSH
2657: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2661: LD_EXP 18
2665: PPUSH
2666: LD_STRING D2-JMM-1
2668: PPUSH
2669: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2673: LD_EXP 23
2677: PUSH
2678: LD_INT 3
2680: ARRAY
2681: PPUSH
2682: LD_EXP 18
2686: PPUSH
2687: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2691: LD_EXP 23
2695: PUSH
2696: LD_INT 3
2698: ARRAY
2699: PPUSH
2700: LD_STRING D2-Eng1-1
2702: PPUSH
2703: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2707: LD_EXP 18
2711: PPUSH
2712: LD_STRING D2-JMM-2
2714: PPUSH
2715: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2719: LD_EXP 23
2723: PUSH
2724: LD_INT 3
2726: ARRAY
2727: PPUSH
2728: LD_STRING D2-Eng1-2
2730: PPUSH
2731: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2735: LD_EXP 18
2739: PPUSH
2740: LD_STRING D2-JMM-3
2742: PPUSH
2743: CALL_OW 88
// if Houten then
2747: LD_EXP 22
2751: IFFALSE 2949
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2753: LD_ADDR_VAR 0 3
2757: PUSH
2758: LD_INT 4
2760: PPUSH
2761: LD_INT 1
2763: PPUSH
2764: LD_INT 3
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_INT 1
2772: PPUSH
2773: LD_INT 4
2775: PPUSH
2776: LD_INT 55
2778: PPUSH
2779: CALL 264 0 7
2783: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_INT 3
2791: PPUSH
2792: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2796: LD_VAR 0 3
2800: PPUSH
2801: LD_INT 46
2803: PPUSH
2804: LD_INT 19
2806: PPUSH
2807: LD_INT 0
2809: PPUSH
2810: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2814: LD_EXP 22
2818: PPUSH
2819: LD_VAR 0 3
2823: PPUSH
2824: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2828: LD_EXP 22
2832: PPUSH
2833: LD_INT 49
2835: PPUSH
2836: LD_INT 33
2838: PPUSH
2839: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2843: LD_EXP 22
2847: PPUSH
2848: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2852: LD_EXP 22
2856: PPUSH
2857: LD_EXP 18
2861: PPUSH
2862: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2866: LD_INT 35
2868: PPUSH
2869: CALL_OW 67
// until See ( 1 , Houten ) ;
2873: LD_INT 1
2875: PPUSH
2876: LD_EXP 22
2880: PPUSH
2881: CALL_OW 292
2885: IFFALSE 2866
// ComTurnUnit ( JMM , Houten ) ;
2887: LD_EXP 18
2891: PPUSH
2892: LD_EXP 22
2896: PPUSH
2897: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
2901: LD_EXP 18
2905: PPUSH
2906: LD_STRING D1d-JMM-1
2908: PPUSH
2909: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
2913: LD_EXP 22
2917: PPUSH
2918: LD_STRING D1-VanH-1
2920: PPUSH
2921: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
2925: LD_EXP 18
2929: PPUSH
2930: LD_STRING D1-JMM-1v
2932: PPUSH
2933: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
2937: LD_EXP 18
2941: PPUSH
2942: LD_STRING D1-JMM-2v
2944: PPUSH
2945: CALL_OW 88
// end ; InGameOff ;
2949: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
2953: LD_STRING M1
2955: PPUSH
2956: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
2960: LD_INT 22
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: PUSH
2970: LD_INT 92
2972: PUSH
2973: LD_EXP 18
2977: PPUSH
2978: CALL_OW 250
2982: PUSH
2983: LD_EXP 18
2987: PPUSH
2988: CALL_OW 251
2992: PUSH
2993: LD_INT 15
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: PPUSH
3006: CALL_OW 69
3010: PPUSH
3011: LD_INT 1
3013: PPUSH
3014: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3018: LD_EXP 23
3022: PUSH
3023: LD_EXP 18
3027: ADD
3028: PUSH
3029: LD_EXP 22
3033: ADD
3034: PPUSH
3035: CALL_OW 141
// end ;
3039: LD_VAR 0 1
3043: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3044: LD_INT 1
3046: PPUSH
3047: LD_EXP 19
3051: PPUSH
3052: CALL_OW 292
3056: PUSH
3057: LD_EXP 18
3061: PPUSH
3062: LD_EXP 19
3066: PPUSH
3067: CALL_OW 296
3071: PUSH
3072: LD_INT 6
3074: LESS
3075: AND
3076: IFFALSE 3839
3078: GO 3080
3080: DISABLE
3081: LD_INT 0
3083: PPUSH
3084: PPUSH
3085: PPUSH
3086: PPUSH
3087: PPUSH
// begin InGameOn ;
3088: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3092: LD_INT 22
3094: PUSH
3095: LD_INT 4
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PPUSH
3102: CALL_OW 69
3106: PPUSH
3107: LD_INT 1
3109: PPUSH
3110: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3114: LD_ADDR_VAR 0 4
3118: PUSH
3119: LD_INT 22
3121: PUSH
3122: LD_INT 1
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: LD_INT 2
3131: PUSH
3132: LD_INT 25
3134: PUSH
3135: LD_INT 1
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: LD_INT 25
3144: PUSH
3145: LD_INT 2
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: LD_INT 25
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: PUSH
3162: LD_INT 25
3164: PUSH
3165: LD_INT 4
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: ST_TO_ADDR
// ComHold ( tmp ) ;
3188: LD_VAR 0 4
3192: PPUSH
3193: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3197: LD_EXP 18
3201: PPUSH
3202: LD_STRING D2-JMM-3a
3204: PPUSH
3205: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3209: LD_EXP 19
3213: PPUSH
3214: LD_EXP 18
3218: PPUSH
3219: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3223: LD_EXP 19
3227: PPUSH
3228: LD_STRING D2-Gary-3
3230: PPUSH
3231: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3235: LD_EXP 18
3239: PPUSH
3240: LD_EXP 19
3244: PPUSH
3245: CALL_OW 119
// for i in tmp do
3249: LD_ADDR_VAR 0 5
3253: PUSH
3254: LD_VAR 0 4
3258: PUSH
3259: FOR_IN
3260: IFFALSE 3305
// begin if IsInUnit ( i ) then
3262: LD_VAR 0 5
3266: PPUSH
3267: CALL_OW 310
3271: IFFALSE 3282
// ComExitBuilding ( i ) ;
3273: LD_VAR 0 5
3277: PPUSH
3278: CALL_OW 122
// wait ( 1 ) ;
3282: LD_INT 1
3284: PPUSH
3285: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3289: LD_VAR 0 5
3293: PPUSH
3294: LD_EXP 18
3298: PPUSH
3299: CALL_OW 119
// end ;
3303: GO 3259
3305: POP
3306: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3307: LD_ADDR_VAR 0 4
3311: PUSH
3312: LD_VAR 0 4
3316: PUSH
3317: LD_EXP 18
3321: PUSH
3322: LD_EXP 22
3326: PUSH
3327: LD_EXP 19
3331: PUSH
3332: LD_EXP 21
3336: PUSH
3337: LD_EXP 20
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: LIST
3346: LIST
3347: LIST
3348: PUSH
3349: LD_EXP 23
3353: ADD
3354: DIFF
3355: ST_TO_ADDR
// if Bobby then
3356: LD_EXP 20
3360: IFFALSE 3374
// Say ( Bobby , D2-Bobby-3 ) ;
3362: LD_EXP 20
3366: PPUSH
3367: LD_STRING D2-Bobby-3
3369: PPUSH
3370: CALL_OW 88
// if Cyrus then
3374: LD_EXP 21
3378: IFFALSE 3392
// Say ( Cyrus , D2-Cyrus-3 ) ;
3380: LD_EXP 21
3384: PPUSH
3385: LD_STRING D2-Cyrus-3
3387: PPUSH
3388: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3392: LD_EXP 18
3396: PPUSH
3397: LD_STRING D2-JMM-4
3399: PPUSH
3400: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3404: LD_EXP 19
3408: PPUSH
3409: LD_STRING D2-Gary-4
3411: PPUSH
3412: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3416: LD_ADDR_VAR 0 1
3420: PUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: LD_INT 26
3428: PUSH
3429: LD_INT 1
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PPUSH
3436: CALL_OW 72
3440: PUSH
3441: LD_INT 1
3443: ARRAY
3444: ST_TO_ADDR
// if Cyrus then
3445: LD_EXP 21
3449: IFFALSE 3465
// Say ( Cyrus , D2-Cyrus-4 ) else
3451: LD_EXP 21
3455: PPUSH
3456: LD_STRING D2-Cyrus-4
3458: PPUSH
3459: CALL_OW 88
3463: GO 3477
// Say ( un1 , D2-Sol1-4 ) ;
3465: LD_VAR 0 1
3469: PPUSH
3470: LD_STRING D2-Sol1-4
3472: PPUSH
3473: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3477: LD_EXP 18
3481: PPUSH
3482: LD_STRING D2-JMM-5
3484: PPUSH
3485: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3489: LD_ADDR_VAR 0 2
3493: PUSH
3494: LD_EXP 23
3498: PPUSH
3499: LD_INT 91
3501: PUSH
3502: LD_EXP 18
3506: PUSH
3507: LD_INT 10
3509: PUSH
3510: EMPTY
3511: LIST
3512: LIST
3513: LIST
3514: PUSH
3515: LD_INT 26
3517: PUSH
3518: LD_INT 2
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: PPUSH
3529: CALL_OW 72
3533: ST_TO_ADDR
// if un2 then
3534: LD_VAR 0 2
3538: IFFALSE 3592
// begin un2 := un2 [ un2 ] ;
3540: LD_ADDR_VAR 0 2
3544: PUSH
3545: LD_VAR 0 2
3549: PUSH
3550: LD_VAR 0 2
3554: ARRAY
3555: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3556: LD_VAR 0 2
3560: PPUSH
3561: LD_STRING D2-FEng1-5
3563: PPUSH
3564: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3568: LD_EXP 18
3572: PPUSH
3573: LD_STRING D2-JMM-6
3575: PPUSH
3576: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3580: LD_VAR 0 2
3584: PPUSH
3585: LD_STRING D2-FEng1-6
3587: PPUSH
3588: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3592: LD_ADDR_VAR 0 3
3596: PUSH
3597: LD_EXP 23
3601: PPUSH
3602: LD_INT 91
3604: PUSH
3605: LD_EXP 18
3609: PUSH
3610: LD_INT 10
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: LIST
3617: PUSH
3618: LD_INT 26
3620: PUSH
3621: LD_INT 1
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PUSH
3628: EMPTY
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 72
3636: ST_TO_ADDR
// if un3 then
3637: LD_VAR 0 3
3641: IFFALSE 3696
// begin un3 := un3 [ 1 ] ;
3643: LD_ADDR_VAR 0 3
3647: PUSH
3648: LD_VAR 0 3
3652: PUSH
3653: LD_INT 1
3655: ARRAY
3656: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3657: LD_VAR 0 3
3661: PPUSH
3662: LD_INT 114
3664: PPUSH
3665: LD_INT 122
3667: PPUSH
3668: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3672: LD_VAR 0 3
3676: PPUSH
3677: LD_STRING D2-Eng1-6
3679: PPUSH
3680: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3684: LD_EXP 18
3688: PPUSH
3689: LD_STRING D2-JMM-7
3691: PPUSH
3692: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3696: LD_EXP 19
3700: PPUSH
3701: LD_STRING D2-Gary-7
3703: PPUSH
3704: CALL_OW 88
// if un2 then
3708: LD_VAR 0 2
3712: IFFALSE 3726
// Say ( un2 , D2-FEng1-7 ) ;
3714: LD_VAR 0 2
3718: PPUSH
3719: LD_STRING D2-FEng1-7
3721: PPUSH
3722: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3726: LD_VAR 0 1
3730: PPUSH
3731: LD_STRING D2-Sol1-7
3733: PPUSH
3734: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3738: LD_EXP 18
3742: PPUSH
3743: LD_STRING D2-JMM-8
3745: PPUSH
3746: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3750: LD_INT 22
3752: PUSH
3753: LD_INT 1
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PPUSH
3760: CALL_OW 69
3764: PPUSH
3765: CALL_OW 141
// InGameOff ;
3769: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3773: LD_STRING M1a
3775: PPUSH
3776: CALL_OW 337
// jmm_in_ovsyenko := true ;
3780: LD_ADDR_EXP 4
3784: PUSH
3785: LD_INT 1
3787: ST_TO_ADDR
// wait ( 0 0$30 ) ;
3788: LD_INT 1050
3790: PPUSH
3791: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
3795: LD_ADDR_VAR 0 4
3799: PUSH
3800: LD_INT 25
3802: PUSH
3803: LD_INT 14
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: ST_TO_ADDR
// if not tmp then
3815: LD_VAR 0 4
3819: NOT
3820: IFFALSE 3824
// exit ;
3822: GO 3839
// ComMoveXY ( tmp , 75 , 75 ) ;
3824: LD_VAR 0 4
3828: PPUSH
3829: LD_INT 75
3831: PPUSH
3832: LD_INT 75
3834: PPUSH
3835: CALL_OW 111
// end ;
3839: PPOPN 5
3841: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
3842: LD_INT 22
3844: PUSH
3845: LD_INT 1
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: LD_INT 30
3854: PUSH
3855: LD_INT 30
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: PUSH
3862: LD_INT 3
3864: PUSH
3865: LD_INT 57
3867: PUSH
3868: EMPTY
3869: LIST
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: LIST
3879: PPUSH
3880: CALL_OW 69
3884: IFFALSE 3926
3886: GO 3888
3888: DISABLE
3889: LD_INT 0
3891: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
3892: LD_ADDR_VAR 0 1
3896: PUSH
3897: LD_STRING M2easy
3899: PUSH
3900: LD_STRING M2
3902: PUSH
3903: LD_STRING M2hard
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: LIST
3910: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
3911: LD_VAR 0 1
3915: PUSH
3916: LD_OWVAR 67
3920: ARRAY
3921: PPUSH
3922: CALL_OW 337
// end ;
3926: PPOPN 1
3928: END
// every 3 3$00 do
3929: GO 3931
3931: DISABLE
// begin DialogueOn ;
3932: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
3936: LD_EXP 25
3940: PPUSH
3941: LD_STRING D3-Pow-1
3943: PPUSH
3944: CALL_OW 94
// if jmm_in_ovsyenko then
3948: LD_EXP 4
3952: IFFALSE 3980
// begin Say ( JMM , D3-JMM-1 ) ;
3954: LD_EXP 18
3958: PPUSH
3959: LD_STRING D3-JMM-1
3961: PPUSH
3962: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
3966: LD_EXP 18
3970: PPUSH
3971: LD_STRING D3-JMM-1b
3973: PPUSH
3974: CALL_OW 88
// end else
3978: GO 3992
// Say ( JMM , D3-JMM-1a ) ;
3980: LD_EXP 18
3984: PPUSH
3985: LD_STRING D3-JMM-1a
3987: PPUSH
3988: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
3992: LD_EXP 25
3996: PPUSH
3997: LD_STRING D3-Pow-2
3999: PPUSH
4000: CALL_OW 94
// DialogueOff ;
4004: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4008: LD_STRING M3
4010: PPUSH
4011: CALL_OW 337
// powell_want_sib := true ;
4015: LD_ADDR_EXP 5
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// end ;
4023: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo ;
4024: LD_EXP 6
4028: PUSH
4029: LD_INT 0
4031: EQUAL
4032: IFFALSE 5307
4034: GO 4036
4036: DISABLE
4037: LD_INT 0
4039: PPUSH
4040: PPUSH
4041: PPUSH
4042: PPUSH
4043: PPUSH
4044: PPUSH
4045: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4046: LD_INT 4
4048: PPUSH
4049: LD_INT 1
4051: PPUSH
4052: CALL_OW 343
// PowellTransport ;
4056: CALL 2385 0 0
// for i = 1 to 3 do
4060: LD_ADDR_VAR 0 4
4064: PUSH
4065: DOUBLE
4066: LD_INT 1
4068: DEC
4069: ST_TO_ADDR
4070: LD_INT 3
4072: PUSH
4073: FOR_TO
4074: IFFALSE 4141
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4076: LD_ADDR_VAR 0 1
4080: PUSH
4081: LD_INT 6
4083: PPUSH
4084: LD_VAR 0 4
4088: PPUSH
4089: CALL_OW 287
4093: ST_TO_ADDR
// if not tmp then
4094: LD_VAR 0 1
4098: NOT
4099: IFFALSE 4103
// continue ;
4101: GO 4073
// EraseResourceArea ( terminalArea , i ) ;
4103: LD_INT 6
4105: PPUSH
4106: LD_VAR 0 4
4110: PPUSH
4111: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4115: LD_EXP 3
4119: PPUSH
4120: CALL_OW 274
4124: PPUSH
4125: LD_VAR 0 4
4129: PPUSH
4130: LD_VAR 0 1
4134: PPUSH
4135: CALL_OW 276
// end ;
4139: GO 4073
4141: POP
4142: POP
// x := 43 ;
4143: LD_ADDR_VAR 0 2
4147: PUSH
4148: LD_INT 43
4150: ST_TO_ADDR
// y := 3 ;
4151: LD_ADDR_VAR 0 3
4155: PUSH
4156: LD_INT 3
4158: ST_TO_ADDR
// for i = 3 to 4 do
4159: LD_ADDR_VAR 0 4
4163: PUSH
4164: DOUBLE
4165: LD_INT 3
4167: DEC
4168: ST_TO_ADDR
4169: LD_INT 4
4171: PUSH
4172: FOR_TO
4173: IFFALSE 4383
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4175: LD_EXP 24
4179: PUSH
4180: LD_VAR 0 4
4184: ARRAY
4185: PPUSH
4186: LD_INT 4
4188: PPUSH
4189: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4193: LD_EXP 24
4197: PUSH
4198: LD_VAR 0 4
4202: ARRAY
4203: PPUSH
4204: LD_VAR 0 2
4208: PPUSH
4209: LD_VAR 0 3
4213: PPUSH
4214: LD_INT 0
4216: PPUSH
4217: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4221: LD_EXP 24
4225: PUSH
4226: LD_VAR 0 4
4230: PUSH
4231: LD_INT 2
4233: MINUS
4234: ARRAY
4235: PPUSH
4236: LD_EXP 24
4240: PUSH
4241: LD_VAR 0 4
4245: ARRAY
4246: PPUSH
4247: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4251: LD_EXP 24
4255: PUSH
4256: LD_VAR 0 4
4260: ARRAY
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4272: LD_EXP 24
4276: PUSH
4277: LD_VAR 0 4
4281: PUSH
4282: LD_INT 2
4284: MINUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 54
4289: PPUSH
4290: LD_INT 42
4292: PPUSH
4293: CALL_OW 111
// AddComUnload ( powell_trans [ i - 2 ] ) ;
4297: LD_EXP 24
4301: PUSH
4302: LD_VAR 0 4
4306: PUSH
4307: LD_INT 2
4309: MINUS
4310: ARRAY
4311: PPUSH
4312: CALL_OW 219
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4316: LD_EXP 24
4320: PUSH
4321: LD_VAR 0 4
4325: PUSH
4326: LD_INT 2
4328: MINUS
4329: ARRAY
4330: PPUSH
4331: LD_EXP 3
4335: PPUSH
4336: CALL_OW 250
4340: PPUSH
4341: LD_EXP 3
4345: PPUSH
4346: CALL_OW 251
4350: PPUSH
4351: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4355: LD_EXP 24
4359: PUSH
4360: LD_VAR 0 4
4364: PUSH
4365: LD_INT 2
4367: MINUS
4368: ARRAY
4369: PPUSH
4370: CALL_OW 200
// Wait ( 0 0$02 ) ;
4374: LD_INT 70
4376: PPUSH
4377: CALL_OW 67
// end ;
4381: GO 4172
4383: POP
4384: POP
// repeat wait ( 0 0$01 ) ;
4385: LD_INT 35
4387: PPUSH
4388: CALL_OW 67
// for i = 3 to 4 do
4392: LD_ADDR_VAR 0 4
4396: PUSH
4397: DOUBLE
4398: LD_INT 3
4400: DEC
4401: ST_TO_ADDR
4402: LD_INT 4
4404: PUSH
4405: FOR_TO
4406: IFFALSE 4556
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4408: LD_EXP 24
4412: PUSH
4413: LD_VAR 0 4
4417: ARRAY
4418: PPUSH
4419: LD_INT 1
4421: PPUSH
4422: CALL_OW 289
4426: PUSH
4427: LD_INT 0
4429: GREATER
4430: PUSH
4431: LD_EXP 24
4435: PUSH
4436: LD_VAR 0 4
4440: ARRAY
4441: PPUSH
4442: CALL_OW 314
4446: NOT
4447: AND
4448: IFFALSE 4554
// begin ComUnload ( powell_trans [ i ] ) ;
4450: LD_EXP 24
4454: PUSH
4455: LD_VAR 0 4
4459: ARRAY
4460: PPUSH
4461: CALL_OW 159
// x := rand ( 0 , 5 ) ;
4465: LD_ADDR_VAR 0 2
4469: PUSH
4470: LD_INT 0
4472: PPUSH
4473: LD_INT 5
4475: PPUSH
4476: CALL_OW 12
4480: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4481: LD_EXP 24
4485: PUSH
4486: LD_VAR 0 4
4490: ARRAY
4491: PPUSH
4492: LD_EXP 24
4496: PUSH
4497: LD_VAR 0 4
4501: ARRAY
4502: PPUSH
4503: CALL_OW 250
4507: PPUSH
4508: LD_VAR 0 2
4512: PPUSH
4513: LD_INT 3
4515: PPUSH
4516: CALL_OW 272
4520: PPUSH
4521: LD_EXP 24
4525: PUSH
4526: LD_VAR 0 4
4530: ARRAY
4531: PPUSH
4532: CALL_OW 251
4536: PPUSH
4537: LD_VAR 0 2
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: CALL_OW 273
4549: PPUSH
4550: CALL_OW 171
// end ;
4554: GO 4405
4556: POP
4557: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 and ( GetCargo ( powell_trans [ 3 ] , mat_cans ) = 0 ) and ( GetCargo ( powell_trans [ 4 ] , mat_cans ) = 0 ) ;
4558: LD_EXP 24
4562: PUSH
4563: LD_INT 1
4565: ARRAY
4566: PPUSH
4567: LD_INT 54
4569: PPUSH
4570: LD_INT 42
4572: PPUSH
4573: CALL_OW 297
4577: PUSH
4578: LD_INT 4
4580: LESS
4581: PUSH
4582: LD_EXP 24
4586: PUSH
4587: LD_INT 3
4589: ARRAY
4590: PPUSH
4591: LD_INT 1
4593: PPUSH
4594: CALL_OW 289
4598: PUSH
4599: LD_INT 0
4601: EQUAL
4602: AND
4603: PUSH
4604: LD_EXP 24
4608: PUSH
4609: LD_INT 4
4611: ARRAY
4612: PPUSH
4613: LD_INT 1
4615: PPUSH
4616: CALL_OW 289
4620: PUSH
4621: LD_INT 0
4623: EQUAL
4624: AND
4625: IFFALSE 4385
// DialogueOn ;
4627: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4631: LD_INT 53
4633: PPUSH
4634: LD_INT 35
4636: PPUSH
4637: CALL_OW 86
// un := powell_trans [ 1 ] ;
4641: LD_ADDR_VAR 0 5
4645: PUSH
4646: LD_EXP 24
4650: PUSH
4651: LD_INT 1
4653: ARRAY
4654: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4655: LD_VAR 0 5
4659: PPUSH
4660: LD_STRING D4-Mech1-1
4662: PPUSH
4663: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4667: LD_EXP 18
4671: PPUSH
4672: LD_STRING D4-JMM-1
4674: PPUSH
4675: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4679: LD_VAR 0 5
4683: PPUSH
4684: LD_STRING D4-Mech1-2
4686: PPUSH
4687: CALL_OW 88
// powell_happy := false ;
4691: LD_ADDR_VAR 0 6
4695: PUSH
4696: LD_INT 0
4698: ST_TO_ADDR
// take_cargo := false ;
4699: LD_ADDR_VAR 0 7
4703: PUSH
4704: LD_INT 0
4706: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4707: CALL 784 0 0
4711: PUSH
4712: LD_INT 60
4714: GREATEREQUAL
4715: IFFALSE 4763
// begin Say ( JMM , D5-JMM-1 ) ;
4717: LD_EXP 18
4721: PPUSH
4722: LD_STRING D5-JMM-1
4724: PPUSH
4725: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4729: LD_VAR 0 5
4733: PPUSH
4734: LD_STRING D6-Mech1-1
4736: PPUSH
4737: CALL_OW 88
// powell_happy := true ;
4741: LD_ADDR_VAR 0 6
4745: PUSH
4746: LD_INT 1
4748: ST_TO_ADDR
// take_cargo := true ;
4749: LD_ADDR_VAR 0 7
4753: PUSH
4754: LD_INT 1
4756: ST_TO_ADDR
// DialogueOff ;
4757: CALL_OW 7
// end else
4761: GO 4997
// if GetTerminalCargo > 0 then
4763: CALL 784 0 0
4767: PUSH
4768: LD_INT 0
4770: GREATER
4771: IFFALSE 4969
// begin case Query ( QWait ) of 1 :
4773: LD_STRING QWait
4775: PPUSH
4776: CALL_OW 97
4780: PUSH
4781: LD_INT 1
4783: DOUBLE
4784: EQUAL
4785: IFTRUE 4789
4787: GO 4880
4789: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4790: LD_EXP 18
4794: PPUSH
4795: LD_STRING D5b-JMM-1
4797: PPUSH
4798: CALL_OW 88
// DialogueOff ;
4802: CALL_OW 7
// wait ( 5 5$00 ) ;
4806: LD_INT 10500
4808: PPUSH
4809: CALL_OW 67
// if GetTerminalCargo < 60 then
4813: CALL 784 0 0
4817: PUSH
4818: LD_INT 60
4820: LESS
4821: IFFALSE 4862
// begin DialogueOn ;
4823: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
4827: LD_EXP 3
4831: PPUSH
4832: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
4836: LD_VAR 0 5
4840: PPUSH
4841: LD_STRING D6-Mech1-1a
4843: PPUSH
4844: CALL_OW 88
// DialogueOff ;
4848: CALL_OW 7
// powell_happy := false ;
4852: LD_ADDR_VAR 0 6
4856: PUSH
4857: LD_INT 0
4859: ST_TO_ADDR
// end else
4860: GO 4878
// begin powell_happy := true ;
4862: LD_ADDR_VAR 0 6
4866: PUSH
4867: LD_INT 1
4869: ST_TO_ADDR
// take_cargo := true ;
4870: LD_ADDR_VAR 0 7
4874: PUSH
4875: LD_INT 1
4877: ST_TO_ADDR
// end ; end ; 2 :
4878: GO 4967
4880: LD_INT 2
4882: DOUBLE
4883: EQUAL
4884: IFTRUE 4888
4886: GO 4927
4888: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
4889: LD_EXP 18
4893: PPUSH
4894: LD_STRING D5b-JMM-1
4896: PPUSH
4897: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
4901: LD_VAR 0 5
4905: PPUSH
4906: LD_STRING D6-Mech1-1a
4908: PPUSH
4909: CALL_OW 88
// DialogueOff ;
4913: CALL_OW 7
// take_cargo := true ;
4917: LD_ADDR_VAR 0 7
4921: PUSH
4922: LD_INT 1
4924: ST_TO_ADDR
// end ; 3 :
4925: GO 4967
4927: LD_INT 3
4929: DOUBLE
4930: EQUAL
4931: IFTRUE 4935
4933: GO 4966
4935: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
4936: LD_EXP 18
4940: PPUSH
4941: LD_STRING D5c-JMM-1
4943: PPUSH
4944: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_STRING D6-Mech1-1b
4955: PPUSH
4956: CALL_OW 88
// DialogueOff ;
4960: CALL_OW 7
// end ; end ;
4964: GO 4967
4966: POP
// end else
4967: GO 4997
// begin Say ( JMM , D5c-JMM-1 ) ;
4969: LD_EXP 18
4973: PPUSH
4974: LD_STRING D5c-JMM-1
4976: PPUSH
4977: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
4981: LD_VAR 0 5
4985: PPUSH
4986: LD_STRING D6-Mech1-1b
4988: PPUSH
4989: CALL_OW 88
// DialogueOff ;
4993: CALL_OW 7
// end ; if take_cargo then
4997: LD_VAR 0 7
5001: IFFALSE 5080
// begin x := GetTerminalCargo ;
5003: LD_ADDR_VAR 0 2
5007: PUSH
5008: CALL 784 0 0
5012: ST_TO_ADDR
// if x > 60 then
5013: LD_VAR 0 2
5017: PUSH
5018: LD_INT 60
5020: GREATER
5021: IFFALSE 5031
// x := 60 ;
5023: LD_ADDR_VAR 0 2
5027: PUSH
5028: LD_INT 60
5030: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5031: LD_EXP 3
5035: PPUSH
5036: CALL_OW 274
5040: PPUSH
5041: LD_INT 3
5043: PPUSH
5044: CALL 784 0 0
5048: PUSH
5049: LD_VAR 0 2
5053: MINUS
5054: PPUSH
5055: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5059: LD_EXP 24
5063: PUSH
5064: LD_INT 3
5066: ARRAY
5067: PPUSH
5068: LD_INT 3
5070: PPUSH
5071: LD_VAR 0 2
5075: PPUSH
5076: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5080: LD_EXP 24
5084: PPUSH
5085: LD_INT 43
5087: PPUSH
5088: LD_INT 3
5090: PPUSH
5091: CALL_OW 171
// x := 0 0$20 ;
5095: LD_ADDR_VAR 0 2
5099: PUSH
5100: LD_INT 700
5102: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5103: LD_INT 35
5105: PPUSH
5106: CALL_OW 67
// x := x - 0 0$01 ;
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_VAR 0 2
5119: PUSH
5120: LD_INT 35
5122: MINUS
5123: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5124: LD_VAR 0 2
5128: PUSH
5129: LD_INT 0
5131: EQUAL
5132: PUSH
5133: LD_EXP 24
5137: PUSH
5138: LD_INT 3
5140: ARRAY
5141: PPUSH
5142: LD_INT 43
5144: PPUSH
5145: LD_INT 3
5147: PPUSH
5148: CALL_OW 297
5152: PUSH
5153: LD_INT 4
5155: LESS
5156: PUSH
5157: LD_EXP 24
5161: PUSH
5162: LD_INT 3
5164: ARRAY
5165: PPUSH
5166: LD_INT 43
5168: PPUSH
5169: LD_INT 3
5171: PPUSH
5172: CALL_OW 297
5176: PUSH
5177: LD_INT 4
5179: LESS
5180: AND
5181: OR
5182: IFFALSE 5103
// for i in powell_trans do
5184: LD_ADDR_VAR 0 4
5188: PUSH
5189: LD_EXP 24
5193: PUSH
5194: FOR_IN
5195: IFFALSE 5208
// RemoveUnit ( i ) ;
5197: LD_VAR 0 4
5201: PPUSH
5202: CALL_OW 64
5206: GO 5194
5208: POP
5209: POP
// if not powell_happy then
5210: LD_VAR 0 6
5214: NOT
5215: IFFALSE 5226
// powell_happy := - 1 ;
5217: LD_ADDR_VAR 0 6
5221: PUSH
5222: LD_INT 1
5224: NEG
5225: ST_TO_ADDR
// AddMedal ( powell_happy , EarlySiberite ) ;
5226: LD_VAR 0 6
5230: PPUSH
5231: LD_STRING EarlySiberite
5233: PPUSH
5234: CALL_OW 101
// if powell_happy then
5238: LD_VAR 0 6
5242: IFFALSE 5253
// ChangeMissionObjectives ( M3a ) else
5244: LD_STRING M3a
5246: PPUSH
5247: CALL_OW 337
5251: GO 5260
// ChangeMissionObjectives ( M3b ) ;
5253: LD_STRING M3b
5255: PPUSH
5256: CALL_OW 337
// ru_can_attack_terminal := true ;
5260: LD_ADDR_EXP 9
5264: PUSH
5265: LD_INT 1
5267: ST_TO_ADDR
// Wait ( 6 6$00 ) ;
5268: LD_INT 12600
5270: PPUSH
5271: CALL_OW 67
// repeat wait ( 0 0$03 ) ;
5275: LD_INT 105
5277: PPUSH
5278: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5282: LD_EXP 8
5286: NOT
5287: PUSH
5288: LD_EXP 34
5292: PUSH
5293: LD_INT 3
5295: LESS
5296: OR
5297: IFFALSE 5275
// ar_can_arrive := true ;
5299: LD_ADDR_EXP 10
5303: PUSH
5304: LD_INT 1
5306: ST_TO_ADDR
// end ;
5307: PPOPN 7
5309: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5310: LD_INT 1
5312: PPUSH
5313: LD_INT 20
5315: PPUSH
5316: CALL_OW 325
5320: IFFALSE 5461
5322: GO 5324
5324: DISABLE
5325: LD_INT 0
5327: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5328: LD_ADDR_VAR 0 1
5332: PUSH
5333: LD_INT 22
5335: PUSH
5336: LD_INT 1
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 26
5345: PUSH
5346: LD_INT 1
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PUSH
5353: LD_INT 25
5355: PUSH
5356: LD_INT 4
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: LIST
5367: PPUSH
5368: CALL_OW 69
5372: PUSH
5373: LD_EXP 18
5377: PUSH
5378: LD_EXP 21
5382: PUSH
5383: LD_EXP 20
5387: PUSH
5388: LD_EXP 22
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: LIST
5397: LIST
5398: DIFF
5399: ST_TO_ADDR
// if not un then
5400: LD_VAR 0 1
5404: NOT
5405: IFFALSE 5409
// exit ;
5407: GO 5461
// DialogueOn ;
5409: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5413: LD_VAR 0 1
5417: PUSH
5418: LD_INT 1
5420: ARRAY
5421: PPUSH
5422: LD_STRING D13-Sci1-1
5424: PPUSH
5425: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5429: LD_EXP 18
5433: PPUSH
5434: LD_STRING D13-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5441: LD_VAR 0 1
5445: PUSH
5446: LD_INT 1
5448: ARRAY
5449: PPUSH
5450: LD_STRING D13-Sci1-2
5452: PPUSH
5453: CALL_OW 88
// DialogueOff ;
5457: CALL_OW 7
// end ;
5461: PPOPN 1
5463: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5464: LD_INT 1
5466: PPUSH
5467: CALL 815 0 1
5471: PUSH
5472: LD_INT 77
5474: GREATER
5475: PUSH
5476: LD_EXP 8
5480: NOT
5481: AND
5482: PUSH
5483: LD_INT 22
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 25
5495: PUSH
5496: LD_INT 4
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PUSH
5503: LD_INT 26
5505: PUSH
5506: LD_INT 1
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: CALL_OW 69
5522: PUSH
5523: LD_EXP 18
5527: PUSH
5528: LD_EXP 20
5532: PUSH
5533: LD_EXP 21
5537: PUSH
5538: LD_EXP 19
5542: PUSH
5543: LD_EXP 22
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: DIFF
5555: AND
5556: IFFALSE 5734
5558: GO 5560
5560: DISABLE
5561: LD_INT 0
5563: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5564: LD_ADDR_VAR 0 1
5568: PUSH
5569: LD_INT 22
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PUSH
5579: LD_INT 25
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 26
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: PPUSH
5604: CALL_OW 69
5608: PUSH
5609: LD_EXP 18
5613: PUSH
5614: LD_EXP 20
5618: PUSH
5619: LD_EXP 21
5623: PUSH
5624: LD_EXP 19
5628: PUSH
5629: LD_EXP 22
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: DIFF
5641: ST_TO_ADDR
// DialogueOn ;
5642: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
5646: LD_VAR 0 1
5650: PUSH
5651: LD_INT 1
5653: ARRAY
5654: PPUSH
5655: LD_STRING D7-Sci1-1
5657: PPUSH
5658: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5662: LD_EXP 18
5666: PPUSH
5667: LD_STRING D7-JMM-1
5669: PPUSH
5670: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
5674: LD_VAR 0 1
5678: PUSH
5679: LD_INT 1
5681: ARRAY
5682: PPUSH
5683: LD_STRING D7-Sci1-2
5685: PPUSH
5686: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5690: LD_EXP 18
5694: PPUSH
5695: LD_STRING D7-JMM-2
5697: PPUSH
5698: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
5702: LD_VAR 0 1
5706: PUSH
5707: LD_INT 1
5709: ARRAY
5710: PPUSH
5711: LD_STRING D7-Sci1-3
5713: PPUSH
5714: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5718: LD_EXP 18
5722: PPUSH
5723: LD_STRING D7-JMM-3
5725: PPUSH
5726: CALL_OW 88
// DialogueOff ;
5730: CALL_OW 7
// end ;
5734: PPOPN 1
5736: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b ;
5737: LD_EXP 10
5741: IFFALSE 8995
5743: GO 5745
5745: DISABLE
5746: LD_INT 0
5748: PPUSH
5749: PPUSH
5750: PPUSH
5751: PPUSH
5752: PPUSH
5753: PPUSH
5754: PPUSH
5755: PPUSH
// begin PrepareArabian ;
5756: CALL 11260 0 0
// repeat wait ( 0 0$01 ) ;
5760: LD_INT 35
5762: PPUSH
5763: CALL_OW 67
// until ar_spawned ;
5767: LD_EXP 11
5771: IFFALSE 5760
// DialogueOn ;
5773: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
5777: LD_EXP 26
5781: PPUSH
5782: LD_STRING D8-Ar1-1
5784: PPUSH
5785: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
5789: LD_EXP 18
5793: PPUSH
5794: LD_STRING D8-JMM-1
5796: PPUSH
5797: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
5801: LD_EXP 26
5805: PPUSH
5806: LD_STRING D8-Ar1-2
5808: PPUSH
5809: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
5813: LD_EXP 18
5817: PPUSH
5818: LD_STRING D8-JMM-2
5820: PPUSH
5821: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
5825: LD_EXP 26
5829: PPUSH
5830: LD_STRING D8-Ar1-3
5832: PPUSH
5833: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
5837: LD_EXP 18
5841: PPUSH
5842: LD_STRING D8-JMM-3
5844: PPUSH
5845: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
5849: LD_EXP 26
5853: PPUSH
5854: LD_STRING D8-Ar1-4
5856: PPUSH
5857: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
5861: LD_EXP 18
5865: PPUSH
5866: LD_STRING D8-JMM-4
5868: PPUSH
5869: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
5873: LD_EXP 26
5877: PPUSH
5878: LD_STRING D8-Ar1-5
5880: PPUSH
5881: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
5885: LD_EXP 18
5889: PPUSH
5890: LD_STRING D8-JMM-5
5892: PPUSH
5893: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
5897: LD_EXP 26
5901: PPUSH
5902: LD_STRING D8-Ar1-6
5904: PPUSH
5905: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
5909: LD_EXP 27
5913: PPUSH
5914: LD_STRING D8-Ar2-6
5916: PPUSH
5917: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
5921: LD_EXP 18
5925: PPUSH
5926: LD_STRING D8-JMM-6
5928: PPUSH
5929: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
5933: LD_EXP 27
5937: PPUSH
5938: LD_STRING D8-Ar2-7
5940: PPUSH
5941: CALL_OW 94
// case Query ( QBarracks ) of 1 :
5945: LD_STRING QBarracks
5947: PPUSH
5948: CALL_OW 97
5952: PUSH
5953: LD_INT 1
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5996
5961: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
5962: LD_EXP 18
5966: PPUSH
5967: LD_STRING D8a-JMM-1
5969: PPUSH
5970: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
5974: LD_EXP 26
5978: PPUSH
5979: LD_STRING D8a-Ar1-1
5981: PPUSH
5982: CALL_OW 94
// player_want_mortar := true ;
5986: LD_ADDR_EXP 12
5990: PUSH
5991: LD_INT 1
5993: ST_TO_ADDR
// end ; 2 :
5994: GO 6154
5996: LD_INT 2
5998: DOUBLE
5999: EQUAL
6000: IFTRUE 6004
6002: GO 6118
6004: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6005: LD_EXP 18
6009: PPUSH
6010: LD_STRING D8b-JMM-1
6012: PPUSH
6013: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6017: LD_EXP 26
6021: PPUSH
6022: LD_STRING D8b-Ar1-1
6024: PPUSH
6025: CALL_OW 94
// case Query ( QInfo ) of 1 :
6029: LD_STRING QInfo
6031: PPUSH
6032: CALL_OW 97
6036: PUSH
6037: LD_INT 1
6039: DOUBLE
6040: EQUAL
6041: IFTRUE 6045
6043: GO 6080
6045: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6046: LD_EXP 18
6050: PPUSH
6051: LD_STRING D8b1-JMM-1
6053: PPUSH
6054: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6058: LD_EXP 26
6062: PPUSH
6063: LD_STRING D8b1-Ar1-1
6065: PPUSH
6066: CALL_OW 94
// player_want_info := 2 ;
6070: LD_ADDR_EXP 13
6074: PUSH
6075: LD_INT 2
6077: ST_TO_ADDR
// end ; 2 :
6078: GO 6116
6080: LD_INT 2
6082: DOUBLE
6083: EQUAL
6084: IFTRUE 6088
6086: GO 6115
6088: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6089: LD_EXP 18
6093: PPUSH
6094: LD_STRING D8b2-JMM-1
6096: PPUSH
6097: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6101: LD_EXP 26
6105: PPUSH
6106: LD_STRING D8b2-Ar1-1
6108: PPUSH
6109: CALL_OW 94
// end ; end ;
6113: GO 6116
6115: POP
// end ; 3 :
6116: GO 6154
6118: LD_INT 3
6120: DOUBLE
6121: EQUAL
6122: IFTRUE 6126
6124: GO 6153
6126: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6127: LD_EXP 18
6131: PPUSH
6132: LD_STRING D8c-JMM-1
6134: PPUSH
6135: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6139: LD_EXP 26
6143: PPUSH
6144: LD_STRING D8c-Ar1-1
6146: PPUSH
6147: CALL_OW 94
// end ; end ;
6151: GO 6154
6153: POP
// DialogueOff ;
6154: CALL_OW 7
// dep := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) , Gali ) ;
6158: LD_ADDR_VAR 0 4
6162: PUSH
6163: LD_INT 22
6165: PUSH
6166: LD_INT 1
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PUSH
6173: LD_INT 2
6175: PUSH
6176: LD_INT 30
6178: PUSH
6179: LD_INT 0
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 30
6188: PUSH
6189: LD_INT 1
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: PPUSH
6205: CALL_OW 69
6209: PPUSH
6210: LD_EXP 27
6214: PPUSH
6215: CALL_OW 74
6219: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6220: LD_ADDR_VAR 0 3
6224: PUSH
6225: LD_INT 22
6227: PUSH
6228: LD_INT 2
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 21
6237: PUSH
6238: LD_INT 2
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: PPUSH
6249: CALL_OW 69
6253: ST_TO_ADDR
// time := 1 1$35 ;
6254: LD_ADDR_VAR 0 5
6258: PUSH
6259: LD_INT 3325
6261: ST_TO_ADDR
// no_oil_gain := false ;
6262: LD_ADDR_VAR 0 6
6266: PUSH
6267: LD_INT 0
6269: ST_TO_ADDR
// first_warn := false ;
6270: LD_ADDR_VAR 0 7
6274: PUSH
6275: LD_INT 0
6277: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6278: LD_EXP 12
6282: PUSH
6283: LD_EXP 13
6287: OR
6288: IFFALSE 6393
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6290: LD_EXP 33
6294: PPUSH
6295: LD_INT 25
6297: PUSH
6298: LD_INT 1
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PPUSH
6305: CALL_OW 72
6309: PPUSH
6310: LD_VAR 0 4
6314: PPUSH
6315: CALL_OW 250
6319: PPUSH
6320: LD_VAR 0 4
6324: PPUSH
6325: CALL_OW 251
6329: PPUSH
6330: LD_VAR 0 4
6334: PPUSH
6335: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6339: LD_EXP 33
6343: PPUSH
6344: LD_INT 25
6346: PUSH
6347: LD_INT 1
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PPUSH
6354: CALL_OW 72
6358: PPUSH
6359: LD_INT 86
6361: PPUSH
6362: LD_INT 121
6364: PPUSH
6365: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6369: LD_EXP 33
6373: PPUSH
6374: LD_INT 25
6376: PUSH
6377: LD_INT 1
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PPUSH
6384: CALL_OW 72
6388: PPUSH
6389: CALL_OW 200
// end ; if player_attacked_ar then
6393: LD_EXP 16
6397: IFFALSE 6401
// exit ;
6399: GO 8995
// if player_want_mortar then
6401: LD_EXP 12
6405: IFFALSE 7797
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6407: LD_EXP 27
6411: PPUSH
6412: LD_VAR 0 4
6416: PPUSH
6417: CALL_OW 250
6421: PUSH
6422: LD_INT 1
6424: PLUS
6425: PPUSH
6426: LD_VAR 0 4
6430: PPUSH
6431: CALL_OW 251
6435: PUSH
6436: LD_INT 1
6438: PLUS
6439: PPUSH
6440: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6444: LD_INT 35
6446: PPUSH
6447: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6451: LD_EXP 27
6455: PPUSH
6456: LD_VAR 0 4
6460: PPUSH
6461: CALL_OW 296
6465: PUSH
6466: LD_INT 4
6468: LESS
6469: IFFALSE 6444
// for i = 1 to 6 do
6471: LD_ADDR_VAR 0 1
6475: PUSH
6476: DOUBLE
6477: LD_INT 1
6479: DEC
6480: ST_TO_ADDR
6481: LD_INT 6
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6682
// begin if player_attacked_ar then
6487: LD_EXP 16
6491: IFFALSE 6497
// exit ;
6493: POP
6494: POP
6495: GO 8995
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6497: LD_VAR 0 4
6501: PPUSH
6502: CALL_OW 274
6506: PPUSH
6507: LD_INT 2
6509: PPUSH
6510: CALL_OW 275
6514: PUSH
6515: LD_INT 10
6517: LESS
6518: PUSH
6519: LD_VAR 0 7
6523: NOT
6524: AND
6525: IFFALSE 6588
// begin first_warn := true ;
6527: LD_ADDR_VAR 0 7
6531: PUSH
6532: LD_INT 1
6534: ST_TO_ADDR
// DialogueOn ;
6535: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
6539: LD_EXP 28
6543: PPUSH
6544: LD_STRING D9a-FAr1-1
6546: PPUSH
6547: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
6551: LD_EXP 18
6555: PPUSH
6556: LD_STRING D9a-JMM-1
6558: PPUSH
6559: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
6563: LD_EXP 26
6567: PPUSH
6568: LD_STRING D9a2-Ar1-1
6570: PPUSH
6571: CALL_OW 88
// DialogueOff ;
6575: CALL_OW 7
// wait ( time ) ;
6579: LD_VAR 0 5
6583: PPUSH
6584: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
6588: LD_VAR 0 4
6592: PPUSH
6593: CALL_OW 274
6597: PPUSH
6598: LD_INT 2
6600: PPUSH
6601: CALL_OW 275
6605: PUSH
6606: LD_INT 10
6608: LESS
6609: IFFALSE 6635
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
6611: LD_EXP 26
6615: PPUSH
6616: LD_STRING D9a3-Ar1-1
6618: PPUSH
6619: CALL_OW 88
// no_oil_gain := true ;
6623: LD_ADDR_VAR 0 6
6627: PUSH
6628: LD_INT 1
6630: ST_TO_ADDR
// break ;
6631: GO 6682
// end else
6633: GO 6680
// begin AddComTransport ( Gali , dep , mat_oil ) ;
6635: LD_EXP 27
6639: PPUSH
6640: LD_VAR 0 4
6644: PPUSH
6645: LD_INT 2
6647: PPUSH
6648: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
6652: LD_EXP 27
6656: PPUSH
6657: LD_VAR 0 3
6661: PUSH
6662: LD_VAR 0 1
6666: PUSH
6667: LD_INT 3
6669: MOD
6670: PUSH
6671: LD_INT 1
6673: PLUS
6674: ARRAY
6675: PPUSH
6676: CALL_OW 210
// end ; end ;
6680: GO 6484
6682: POP
6683: POP
// if not no_oil_gain then
6684: LD_VAR 0 6
6688: NOT
6689: IFFALSE 7797
// begin repeat wait ( 0 0$01 ) ;
6691: LD_INT 35
6693: PPUSH
6694: CALL_OW 67
// if player_attacked_ar then
6698: LD_EXP 16
6702: IFFALSE 6706
// exit ;
6704: GO 8995
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
6706: LD_VAR 0 3
6710: PUSH
6711: LD_INT 1
6713: ARRAY
6714: PPUSH
6715: CALL_OW 261
6719: PUSH
6720: LD_INT 80
6722: GREATER
6723: PUSH
6724: LD_VAR 0 3
6728: PUSH
6729: LD_INT 2
6731: ARRAY
6732: PPUSH
6733: CALL_OW 261
6737: PUSH
6738: LD_INT 80
6740: GREATER
6741: AND
6742: PUSH
6743: LD_VAR 0 3
6747: PUSH
6748: LD_INT 3
6750: ARRAY
6751: PPUSH
6752: CALL_OW 261
6756: PUSH
6757: LD_INT 80
6759: GREATER
6760: AND
6761: IFFALSE 6691
// ComMoveXY ( Gali , 105 , 127 ) ;
6763: LD_EXP 27
6767: PPUSH
6768: LD_INT 105
6770: PPUSH
6771: LD_INT 127
6773: PPUSH
6774: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
6778: LD_EXP 27
6782: PPUSH
6783: LD_INT 2
6785: PPUSH
6786: CALL_OW 173
// AddComHold ( Gali ) ;
6790: LD_EXP 27
6794: PPUSH
6795: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
6799: LD_INT 35
6801: PPUSH
6802: CALL_OW 67
// if player_attacked_ar then
6806: LD_EXP 16
6810: IFFALSE 6814
// exit ;
6812: GO 8995
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
6814: LD_EXP 27
6818: PPUSH
6819: LD_INT 105
6821: PPUSH
6822: LD_INT 127
6824: PPUSH
6825: CALL_OW 297
6829: PUSH
6830: LD_INT 4
6832: LESS
6833: IFFALSE 6799
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6835: LD_VAR 0 4
6839: PPUSH
6840: CALL_OW 274
6844: PPUSH
6845: LD_INT 1
6847: PPUSH
6848: CALL_OW 275
6852: PUSH
6853: LD_INT 50
6855: LESS
6856: IFFALSE 7152
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
6858: LD_VAR 0 4
6862: PPUSH
6863: CALL_OW 274
6867: PPUSH
6868: LD_INT 1
6870: PPUSH
6871: CALL_OW 275
6875: PUSH
6876: LD_INT 0
6878: DOUBLE
6879: GREATEREQUAL
6880: IFFALSE 6888
6882: LD_INT 24
6884: DOUBLE
6885: LESSEQUAL
6886: IFTRUE 6890
6888: GO 6905
6890: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
6891: LD_EXP 27
6895: PPUSH
6896: LD_STRING D9b-Ar2-1
6898: PPUSH
6899: CALL_OW 88
6903: GO 6935
6905: LD_INT 25
6907: DOUBLE
6908: GREATEREQUAL
6909: IFFALSE 6917
6911: LD_INT 49
6913: DOUBLE
6914: LESSEQUAL
6915: IFTRUE 6919
6917: GO 6934
6919: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
6920: LD_EXP 27
6924: PPUSH
6925: LD_STRING D9b-Ar2-1a
6927: PPUSH
6928: CALL_OW 88
6932: GO 6935
6934: POP
// Say ( JMM , D9b-JMM-1 ) ;
6935: LD_EXP 18
6939: PPUSH
6940: LD_STRING D9b-JMM-1
6942: PPUSH
6943: CALL_OW 88
// x := 0 0$0 ;
6947: LD_ADDR_VAR 0 2
6951: PUSH
6952: LD_INT 0
6954: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6955: LD_INT 35
6957: PPUSH
6958: CALL_OW 67
// x := x + 0 0$1 ;
6962: LD_ADDR_VAR 0 2
6966: PUSH
6967: LD_VAR 0 2
6971: PUSH
6972: LD_INT 35
6974: PLUS
6975: ST_TO_ADDR
// if player_attacked_ar then
6976: LD_EXP 16
6980: IFFALSE 6984
// exit ;
6982: GO 8995
// until x >= time ;
6984: LD_VAR 0 2
6988: PUSH
6989: LD_VAR 0 5
6993: GREATEREQUAL
6994: IFFALSE 6955
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
6996: LD_VAR 0 4
7000: PPUSH
7001: CALL_OW 274
7005: PPUSH
7006: LD_INT 1
7008: PPUSH
7009: CALL_OW 275
7013: PUSH
7014: LD_INT 50
7016: LESS
7017: IFFALSE 7150
// begin DialogueOn ;
7019: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7023: LD_EXP 26
7027: PPUSH
7028: LD_STRING D9c-Ar1-1
7030: PPUSH
7031: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7035: LD_EXP 18
7039: PPUSH
7040: LD_STRING D9c-JMM-1
7042: PPUSH
7043: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7047: LD_EXP 26
7051: PPUSH
7052: LD_STRING D9c-Ar1-2
7054: PPUSH
7055: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7059: LD_EXP 28
7063: PPUSH
7064: LD_STRING D9c-FAr1-2
7066: PPUSH
7067: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7071: LD_EXP 26
7075: PPUSH
7076: LD_STRING D9c-Ar1-3
7078: PPUSH
7079: CALL_OW 88
// case Query ( QInfo ) of 1 :
7083: LD_STRING QInfo
7085: PPUSH
7086: CALL_OW 97
7090: PUSH
7091: LD_INT 1
7093: DOUBLE
7094: EQUAL
7095: IFTRUE 7099
7097: GO 7122
7099: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7100: LD_EXP 18
7104: PPUSH
7105: LD_STRING D8b1-JMM-1
7107: PPUSH
7108: CALL_OW 88
// player_want_info := 2 ;
7112: LD_ADDR_EXP 13
7116: PUSH
7117: LD_INT 2
7119: ST_TO_ADDR
// end ; 2 :
7120: GO 7146
7122: LD_INT 2
7124: DOUBLE
7125: EQUAL
7126: IFTRUE 7130
7128: GO 7145
7130: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7131: LD_EXP 26
7135: PPUSH
7136: LD_STRING D8b2-Ar1-1
7138: PPUSH
7139: CALL_OW 88
// end ; end ;
7143: GO 7146
7145: POP
// DialogueOff ;
7146: CALL_OW 7
// end ; end else
7150: GO 7797
// begin RemoveEnvironmentArea ( mortarArea ) ;
7152: LD_INT 2
7154: PPUSH
7155: CALL_OW 355
// wait ( 1 ) ;
7159: LD_INT 1
7161: PPUSH
7162: CALL_OW 67
// SetSide ( Gali , 1 ) ;
7166: LD_EXP 27
7170: PPUSH
7171: LD_INT 1
7173: PPUSH
7174: CALL_OW 235
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7178: LD_EXP 27
7182: PPUSH
7183: LD_INT 4
7185: PPUSH
7186: LD_INT 107
7188: PPUSH
7189: LD_INT 131
7191: PPUSH
7192: LD_INT 0
7194: PPUSH
7195: CALL_OW 145
// repeat wait ( 1 ) ;
7199: LD_INT 1
7201: PPUSH
7202: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7206: LD_INT 30
7208: PUSH
7209: LD_INT 4
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: LD_INT 23
7218: PUSH
7219: LD_INT 2
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: PPUSH
7230: CALL_OW 69
7234: IFFALSE 7199
// SetSide ( Gali , 2 ) ;
7236: LD_EXP 27
7240: PPUSH
7241: LD_INT 2
7243: PPUSH
7244: CALL_OW 235
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7248: LD_ADDR_VAR 0 8
7252: PUSH
7253: LD_INT 30
7255: PUSH
7256: LD_INT 4
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 23
7265: PUSH
7266: LD_INT 2
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PUSH
7273: EMPTY
7274: LIST
7275: LIST
7276: PPUSH
7277: CALL_OW 69
7281: PUSH
7282: LD_INT 1
7284: ARRAY
7285: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7286: LD_INT 35
7288: PPUSH
7289: CALL_OW 67
// if player_attacked_ar then
7293: LD_EXP 16
7297: IFFALSE 7301
// exit ;
7299: GO 8995
// until BuildingStatus ( b ) <> bs_build ;
7301: LD_VAR 0 8
7305: PPUSH
7306: CALL_OW 461
7310: PUSH
7311: LD_INT 1
7313: NONEQUAL
7314: IFFALSE 7286
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7316: LD_VAR 0 8
7320: PPUSH
7321: CALL_OW 302
7325: PUSH
7326: LD_VAR 0 4
7330: PPUSH
7331: CALL_OW 274
7335: PPUSH
7336: LD_INT 1
7338: PPUSH
7339: CALL_OW 275
7343: PUSH
7344: LD_INT 25
7346: GREATEREQUAL
7347: AND
7348: IFFALSE 7447
// begin ComUpgrade ( b ) ;
7350: LD_VAR 0 8
7354: PPUSH
7355: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
7359: LD_EXP 27
7363: PPUSH
7364: LD_STRING h
7366: PUSH
7367: LD_VAR 0 8
7371: PPUSH
7372: CALL_OW 250
7376: PUSH
7377: LD_VAR 0 8
7381: PPUSH
7382: CALL_OW 251
7386: PUSH
7387: LD_VAR 0 8
7391: PUSH
7392: LD_INT 0
7394: PUSH
7395: LD_INT 0
7397: PUSH
7398: LD_INT 0
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: LIST
7405: LIST
7406: LIST
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: PPUSH
7413: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
7417: LD_INT 35
7419: PPUSH
7420: CALL_OW 67
// if player_attacked_ar then
7424: LD_EXP 16
7428: IFFALSE 7432
// exit ;
7430: GO 8995
// until BuildingStatus ( b ) <> bs_build ;
7432: LD_VAR 0 8
7436: PPUSH
7437: CALL_OW 461
7441: PUSH
7442: LD_INT 1
7444: NONEQUAL
7445: IFFALSE 7417
// end ; if b then
7447: LD_VAR 0 8
7451: IFFALSE 7462
// CenterNowOnUnits ( b ) ;
7453: LD_VAR 0 8
7457: PPUSH
7458: CALL_OW 87
// DialogueOn ;
7462: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
7466: LD_EXP 27
7470: PPUSH
7471: LD_STRING D9d-Ar2-1
7473: PPUSH
7474: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
7478: LD_EXP 26
7482: PPUSH
7483: LD_STRING D9d-Ar1-1
7485: PPUSH
7486: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
7490: LD_EXP 18
7494: PPUSH
7495: LD_STRING D9d-JMM-1
7497: PPUSH
7498: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
7502: LD_EXP 26
7506: PPUSH
7507: LD_STRING D9d-Ar1-2
7509: PPUSH
7510: CALL_OW 88
// DialogueOff ;
7514: CALL_OW 7
// i := [ ] ;
7518: LD_ADDR_VAR 0 1
7522: PUSH
7523: EMPTY
7524: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
7525: LD_VAR 0 4
7529: PPUSH
7530: CALL_OW 274
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL_OW 275
7542: PUSH
7543: LD_INT 20
7545: GREATEREQUAL
7546: IFFALSE 7565
// i := i ^ [ 1 ] ;
7548: LD_ADDR_VAR 0 1
7552: PUSH
7553: LD_VAR 0 1
7557: PUSH
7558: LD_INT 1
7560: PUSH
7561: EMPTY
7562: LIST
7563: ADD
7564: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
7565: LD_VAR 0 4
7569: PPUSH
7570: CALL_OW 274
7574: PPUSH
7575: LD_INT 1
7577: PPUSH
7578: CALL_OW 275
7582: PUSH
7583: LD_INT 50
7585: GREATEREQUAL
7586: IFFALSE 7605
// i := i ^ [ 2 ] ;
7588: LD_ADDR_VAR 0 1
7592: PUSH
7593: LD_VAR 0 1
7597: PUSH
7598: LD_INT 2
7600: PUSH
7601: EMPTY
7602: LIST
7603: ADD
7604: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
7605: LD_VAR 0 4
7609: PPUSH
7610: CALL_OW 274
7614: PPUSH
7615: LD_INT 2
7617: PPUSH
7618: CALL_OW 275
7622: PUSH
7623: LD_INT 80
7625: GREATEREQUAL
7626: IFFALSE 7645
// i := i ^ [ 3 ] ;
7628: LD_ADDR_VAR 0 1
7632: PUSH
7633: LD_VAR 0 1
7637: PUSH
7638: LD_INT 3
7640: PUSH
7641: EMPTY
7642: LIST
7643: ADD
7644: ST_TO_ADDR
// i := i diff 0 ;
7645: LD_ADDR_VAR 0 1
7649: PUSH
7650: LD_VAR 0 1
7654: PUSH
7655: LD_INT 0
7657: DIFF
7658: ST_TO_ADDR
// if i then
7659: LD_VAR 0 1
7663: IFFALSE 7769
// begin i := i ^ [ 4 ] ;
7665: LD_ADDR_VAR 0 1
7669: PUSH
7670: LD_VAR 0 1
7674: PUSH
7675: LD_INT 4
7677: PUSH
7678: EMPTY
7679: LIST
7680: ADD
7681: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
7682: LD_STRING QInfo2
7684: PPUSH
7685: CALL_OW 97
7689: PUSH
7690: LD_INT 1
7692: DOUBLE
7693: EQUAL
7694: IFTRUE 7698
7696: GO 7709
7698: POP
// player_want_info := 3 ; 2 :
7699: LD_ADDR_EXP 13
7703: PUSH
7704: LD_INT 3
7706: ST_TO_ADDR
7707: GO 7767
7709: LD_INT 2
7711: DOUBLE
7712: EQUAL
7713: IFTRUE 7717
7715: GO 7728
7717: POP
// player_want_info := 1 ; 3 :
7718: LD_ADDR_EXP 13
7722: PUSH
7723: LD_INT 1
7725: ST_TO_ADDR
7726: GO 7767
7728: LD_INT 3
7730: DOUBLE
7731: EQUAL
7732: IFTRUE 7736
7734: GO 7747
7736: POP
// player_want_info := 2 ; 4 :
7737: LD_ADDR_EXP 13
7741: PUSH
7742: LD_INT 2
7744: ST_TO_ADDR
7745: GO 7767
7747: LD_INT 4
7749: DOUBLE
7750: EQUAL
7751: IFTRUE 7755
7753: GO 7766
7755: POP
// player_want_info := 0 ; end ;
7756: LD_ADDR_EXP 13
7760: PUSH
7761: LD_INT 0
7763: ST_TO_ADDR
7764: GO 7767
7766: POP
// end else
7767: GO 7797
// case Query ( QInfoNothing ) of 1 :
7769: LD_STRING QInfoNothing
7771: PPUSH
7772: CALL_OW 97
7776: PUSH
7777: LD_INT 1
7779: DOUBLE
7780: EQUAL
7781: IFTRUE 7785
7783: GO 7796
7785: POP
// player_want_info := 0 ; end ;
7786: LD_ADDR_EXP 13
7790: PUSH
7791: LD_INT 0
7793: ST_TO_ADDR
7794: GO 7797
7796: POP
// end ; end ; end ; if player_want_info then
7797: LD_EXP 13
7801: IFFALSE 8815
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
7803: LD_ADDR_VAR 0 3
7807: PUSH
7808: LD_VAR 0 3
7812: PPUSH
7813: LD_INT 34
7815: PUSH
7816: LD_INT 32
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PPUSH
7823: CALL_OW 72
7827: ST_TO_ADDR
// if player_want_mortar then
7828: LD_EXP 12
7832: IFFALSE 8154
// begin case player_want_info of 1 :
7834: LD_EXP 13
7838: PUSH
7839: LD_INT 1
7841: DOUBLE
7842: EQUAL
7843: IFTRUE 7847
7845: GO 7858
7847: POP
// x := 5 ; 2 :
7848: LD_ADDR_VAR 0 2
7852: PUSH
7853: LD_INT 5
7855: ST_TO_ADDR
7856: GO 7897
7858: LD_INT 2
7860: DOUBLE
7861: EQUAL
7862: IFTRUE 7866
7864: GO 7877
7866: POP
// x := 8 ; 3 :
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_INT 8
7874: ST_TO_ADDR
7875: GO 7897
7877: LD_INT 3
7879: DOUBLE
7880: EQUAL
7881: IFTRUE 7885
7883: GO 7896
7885: POP
// x := 2 ; end ;
7886: LD_ADDR_VAR 0 2
7890: PUSH
7891: LD_INT 2
7893: ST_TO_ADDR
7894: GO 7897
7896: POP
// repeat wait ( 0 0$1 ) ;
7897: LD_INT 35
7899: PPUSH
7900: CALL_OW 67
// until not HasTask ( Gali ) ;
7904: LD_EXP 27
7908: PPUSH
7909: CALL_OW 314
7913: NOT
7914: IFFALSE 7897
// for i = 1 to x do
7916: LD_ADDR_VAR 0 1
7920: PUSH
7921: DOUBLE
7922: LD_INT 1
7924: DEC
7925: ST_TO_ADDR
7926: LD_VAR 0 2
7930: PUSH
7931: FOR_TO
7932: IFFALSE 8097
// begin AddComTransport ( Gali , dep , player_want_info ) ;
7934: LD_EXP 27
7938: PPUSH
7939: LD_VAR 0 4
7943: PPUSH
7944: LD_EXP 13
7948: PPUSH
7949: CALL_OW 211
// AddComMoveUnit ( Gali , tmp [ 1 ] ) ;
7953: LD_EXP 27
7957: PPUSH
7958: LD_VAR 0 3
7962: PUSH
7963: LD_INT 1
7965: ARRAY
7966: PPUSH
7967: CALL_OW 172
// AddComHold ( Gali ) ;
7971: LD_EXP 27
7975: PPUSH
7976: CALL_OW 200
// repeat wait ( 3 ) ;
7980: LD_INT 3
7982: PPUSH
7983: CALL_OW 67
// if player_attacked_ar then
7987: LD_EXP 16
7991: IFFALSE 7997
// exit ;
7993: POP
7994: POP
7995: GO 8995
// until GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) ;
7997: LD_EXP 27
8001: PPUSH
8002: LD_VAR 0 3
8006: PUSH
8007: LD_INT 1
8009: ARRAY
8010: PPUSH
8011: CALL_OW 296
8015: PUSH
8016: LD_INT 4
8018: LESS
8019: PUSH
8020: LD_EXP 27
8024: PPUSH
8025: LD_EXP 13
8029: PPUSH
8030: CALL_OW 289
8034: AND
8035: IFFALSE 7980
// SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8037: LD_VAR 0 3
8041: PUSH
8042: LD_INT 1
8044: ARRAY
8045: PPUSH
8046: LD_EXP 13
8050: PPUSH
8051: LD_VAR 0 3
8055: PUSH
8056: LD_INT 1
8058: ARRAY
8059: PPUSH
8060: LD_EXP 13
8064: PPUSH
8065: CALL_OW 289
8069: PUSH
8070: LD_INT 10
8072: PLUS
8073: PPUSH
8074: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8078: LD_EXP 27
8082: PPUSH
8083: LD_EXP 13
8087: PPUSH
8088: LD_INT 0
8090: PPUSH
8091: CALL_OW 290
// end ;
8095: GO 7931
8097: POP
8098: POP
// repeat wait ( 0 0$1 ) ;
8099: LD_INT 35
8101: PPUSH
8102: CALL_OW 67
// if player_attacked_ar then
8106: LD_EXP 16
8110: IFFALSE 8114
// exit ;
8112: GO 8995
// until GetCargo ( tmp [ 1 ] , player_want_info ) = x * 10 ;
8114: LD_VAR 0 3
8118: PUSH
8119: LD_INT 1
8121: ARRAY
8122: PPUSH
8123: LD_EXP 13
8127: PPUSH
8128: CALL_OW 289
8132: PUSH
8133: LD_VAR 0 2
8137: PUSH
8138: LD_INT 10
8140: MUL
8141: EQUAL
8142: IFFALSE 8099
// no_oil_gain := false ;
8144: LD_ADDR_VAR 0 6
8148: PUSH
8149: LD_INT 0
8151: ST_TO_ADDR
// end else
8152: GO 8636
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8154: LD_ADDR_VAR 0 3
8158: PUSH
8159: LD_INT 22
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: LD_INT 21
8171: PUSH
8172: LD_INT 2
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: PUSH
8179: EMPTY
8180: LIST
8181: LIST
8182: PPUSH
8183: CALL_OW 69
8187: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8188: LD_EXP 27
8192: PPUSH
8193: LD_VAR 0 4
8197: PPUSH
8198: CALL_OW 250
8202: PUSH
8203: LD_INT 1
8205: PLUS
8206: PPUSH
8207: LD_VAR 0 4
8211: PPUSH
8212: CALL_OW 251
8216: PUSH
8217: LD_INT 1
8219: PLUS
8220: PPUSH
8221: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8225: LD_INT 35
8227: PPUSH
8228: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
8232: LD_EXP 27
8236: PPUSH
8237: LD_VAR 0 4
8241: PPUSH
8242: CALL_OW 296
8246: PUSH
8247: LD_INT 4
8249: LESS
8250: IFFALSE 8225
// for i = 1 to 6 do
8252: LD_ADDR_VAR 0 1
8256: PUSH
8257: DOUBLE
8258: LD_INT 1
8260: DEC
8261: ST_TO_ADDR
8262: LD_INT 6
8264: PUSH
8265: FOR_TO
8266: IFFALSE 8463
// begin if player_attacked_ar then
8268: LD_EXP 16
8272: IFFALSE 8278
// exit ;
8274: POP
8275: POP
8276: GO 8995
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8278: LD_VAR 0 4
8282: PPUSH
8283: CALL_OW 274
8287: PPUSH
8288: LD_INT 2
8290: PPUSH
8291: CALL_OW 275
8295: PUSH
8296: LD_INT 10
8298: LESS
8299: PUSH
8300: LD_VAR 0 7
8304: NOT
8305: AND
8306: IFFALSE 8369
// begin first_warn := true ;
8308: LD_ADDR_VAR 0 7
8312: PUSH
8313: LD_INT 1
8315: ST_TO_ADDR
// DialogueOn ;
8316: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
8320: LD_EXP 28
8324: PPUSH
8325: LD_STRING D9a-FAr1-1
8327: PPUSH
8328: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
8332: LD_EXP 18
8336: PPUSH
8337: LD_STRING D9a-JMM-1
8339: PPUSH
8340: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
8344: LD_EXP 26
8348: PPUSH
8349: LD_STRING D9a2-Ar1-1
8351: PPUSH
8352: CALL_OW 88
// DialogueOff ;
8356: CALL_OW 7
// wait ( time ) ;
8360: LD_VAR 0 5
8364: PPUSH
8365: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
8369: LD_VAR 0 4
8373: PPUSH
8374: CALL_OW 274
8378: PPUSH
8379: LD_INT 2
8381: PPUSH
8382: CALL_OW 275
8386: PUSH
8387: LD_INT 10
8389: LESS
8390: IFFALSE 8416
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
8392: LD_EXP 26
8396: PPUSH
8397: LD_STRING D9a3-Ar1-1
8399: PPUSH
8400: CALL_OW 88
// no_oil_gain := true ;
8404: LD_ADDR_VAR 0 6
8408: PUSH
8409: LD_INT 1
8411: ST_TO_ADDR
// break ;
8412: GO 8463
// end else
8414: GO 8461
// begin AddComTransport ( Gali , dep , mat_oil ) ;
8416: LD_EXP 27
8420: PPUSH
8421: LD_VAR 0 4
8425: PPUSH
8426: LD_INT 2
8428: PPUSH
8429: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
8433: LD_EXP 27
8437: PPUSH
8438: LD_VAR 0 3
8442: PUSH
8443: LD_VAR 0 1
8447: PUSH
8448: LD_INT 3
8450: MOD
8451: PUSH
8452: LD_INT 1
8454: PLUS
8455: ARRAY
8456: PPUSH
8457: CALL_OW 210
// end ; end ;
8461: GO 8265
8463: POP
8464: POP
// repeat wait ( 0 0$1 ) ;
8465: LD_INT 35
8467: PPUSH
8468: CALL_OW 67
// if player_attacked_ar then
8472: LD_EXP 16
8476: IFFALSE 8480
// exit ;
8478: GO 8995
// for i in tmp do
8480: LD_ADDR_VAR 0 1
8484: PUSH
8485: LD_VAR 0 3
8489: PUSH
8490: FOR_IN
8491: IFFALSE 8522
// if GetFuel ( i ) < 100 then
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 261
8502: PUSH
8503: LD_INT 100
8505: LESS
8506: IFFALSE 8520
// begin x := i ;
8508: LD_ADDR_VAR 0 2
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// break ;
8518: GO 8522
// end ;
8520: GO 8490
8522: POP
8523: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
8524: LD_EXP 27
8528: PPUSH
8529: CALL_OW 314
8533: NOT
8534: PUSH
8535: LD_EXP 27
8539: PPUSH
8540: CALL_OW 281
8544: NOT
8545: AND
8546: IFFALSE 8579
// begin ComTransport ( Gali , dep , mat_oil ) ;
8548: LD_EXP 27
8552: PPUSH
8553: LD_VAR 0 4
8557: PPUSH
8558: LD_INT 2
8560: PPUSH
8561: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
8565: LD_EXP 27
8569: PPUSH
8570: LD_VAR 0 2
8574: PPUSH
8575: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
8579: LD_VAR 0 3
8583: PUSH
8584: LD_INT 1
8586: ARRAY
8587: PPUSH
8588: CALL_OW 261
8592: PUSH
8593: LD_INT 80
8595: GREATER
8596: PUSH
8597: LD_VAR 0 3
8601: PUSH
8602: LD_INT 2
8604: ARRAY
8605: PPUSH
8606: CALL_OW 261
8610: PUSH
8611: LD_INT 80
8613: GREATER
8614: AND
8615: PUSH
8616: LD_VAR 0 3
8620: PUSH
8621: LD_INT 3
8623: ARRAY
8624: PPUSH
8625: CALL_OW 261
8629: PUSH
8630: LD_INT 80
8632: GREATER
8633: AND
8634: IFFALSE 8465
// end ; ComHold ( Gali ) ;
8636: LD_EXP 27
8640: PPUSH
8641: CALL_OW 140
// if not no_oil_gain then
8645: LD_VAR 0 6
8649: NOT
8650: IFFALSE 8815
// begin DialogueOn ;
8652: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
8656: LD_EXP 26
8660: PPUSH
8661: CALL_OW 87
// if player_want_mortar then
8665: LD_EXP 12
8669: IFFALSE 8695
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
8671: LD_EXP 26
8675: PPUSH
8676: LD_STRING D9e-Ar1-1
8678: PPUSH
8679: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
8683: LD_EXP 18
8687: PPUSH
8688: LD_STRING D10a-JMM-1
8690: PPUSH
8691: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
8695: LD_EXP 26
8699: PPUSH
8700: LD_STRING D10a-Ar1-1
8702: PPUSH
8703: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
8707: LD_EXP 27
8711: PPUSH
8712: LD_STRING D10a-Ar2-1
8714: PPUSH
8715: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
8719: LD_EXP 28
8723: PPUSH
8724: LD_STRING D10a-FAr1-1
8726: PPUSH
8727: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
8731: LD_EXP 27
8735: PPUSH
8736: LD_STRING D10a-Ar2-2
8738: PPUSH
8739: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
8743: LD_EXP 28
8747: PPUSH
8748: LD_STRING D10a-FAr1-2
8750: PPUSH
8751: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
8755: LD_EXP 26
8759: PPUSH
8760: LD_STRING D10a-Ar1-2
8762: PPUSH
8763: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
8767: LD_EXP 18
8771: PPUSH
8772: LD_STRING D10a-JMM-2
8774: PPUSH
8775: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
8779: LD_EXP 26
8783: PPUSH
8784: LD_STRING D10a-Ar1-3
8786: PPUSH
8787: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
8791: LD_EXP 18
8795: PPUSH
8796: LD_STRING D10a-JMM-3
8798: PPUSH
8799: CALL_OW 88
// player_get_info := true ;
8803: LD_ADDR_EXP 15
8807: PUSH
8808: LD_INT 1
8810: ST_TO_ADDR
// DialogueOff ;
8811: CALL_OW 7
// end ; end ; if player_attacked_ar then
8815: LD_EXP 16
8819: IFFALSE 8823
// exit ;
8821: GO 8995
// if player_want_mortar or player_want_info then
8823: LD_EXP 12
8827: PUSH
8828: LD_EXP 13
8832: OR
8833: IFFALSE 8847
// Say ( Vervecken , D9f-Ar1-1 ) ;
8835: LD_EXP 26
8839: PPUSH
8840: LD_STRING D9f-Ar1-1
8842: PPUSH
8843: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
8847: LD_INT 22
8849: PUSH
8850: LD_INT 2
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PPUSH
8857: CALL_OW 69
8861: PPUSH
8862: LD_INT 51
8864: PPUSH
8865: LD_INT 99
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
8879: LD_INT 22
8881: PUSH
8882: LD_INT 2
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: LD_INT 92
8891: PUSH
8892: LD_INT 51
8894: PUSH
8895: LD_INT 99
8897: PUSH
8898: LD_INT 2
8900: PUSH
8901: EMPTY
8902: LIST
8903: LIST
8904: LIST
8905: LIST
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PPUSH
8911: CALL_OW 69
8915: IFFALSE 8975
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
8917: LD_ADDR_VAR 0 1
8921: PUSH
8922: LD_INT 22
8924: PUSH
8925: LD_INT 2
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PUSH
8932: LD_INT 92
8934: PUSH
8935: LD_INT 51
8937: PUSH
8938: LD_INT 99
8940: PUSH
8941: LD_INT 2
8943: PUSH
8944: EMPTY
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: PUSH
8950: EMPTY
8951: LIST
8952: LIST
8953: PPUSH
8954: CALL_OW 69
8958: PUSH
8959: FOR_IN
8960: IFFALSE 8973
// RemoveUnit ( i ) ;
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 64
8971: GO 8959
8973: POP
8974: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
8975: LD_INT 22
8977: PUSH
8978: LD_INT 2
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PPUSH
8985: CALL_OW 69
8989: PUSH
8990: LD_INT 0
8992: EQUAL
8993: IFFALSE 8847
// end ;
8995: PPOPN 8
8997: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
8998: LD_EXP 16
9002: IFFALSE 9355
9004: GO 9006
9006: DISABLE
9007: LD_INT 0
9009: PPUSH
9010: PPUSH
9011: PPUSH
9012: PPUSH
// begin ru_can_attack := true ;
9013: LD_ADDR_EXP 8
9017: PUSH
9018: LD_INT 1
9020: ST_TO_ADDR
// mine_launched := false ;
9021: LD_ADDR_VAR 0 3
9025: PUSH
9026: LD_INT 0
9028: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9029: LD_INT 22
9031: PUSH
9032: LD_INT 2
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PPUSH
9039: CALL_OW 69
9043: PPUSH
9044: LD_INT 51
9046: PPUSH
9047: LD_INT 99
9049: PPUSH
9050: CALL_OW 111
// if IsOk ( Vervecken ) then
9054: LD_EXP 26
9058: PPUSH
9059: CALL_OW 302
9063: IFFALSE 9077
// Say ( Vervecken , D11a-Ar1-1 ) ;
9065: LD_EXP 26
9069: PPUSH
9070: LD_STRING D11a-Ar1-1
9072: PPUSH
9073: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 33
9086: PPUSH
9087: LD_INT 25
9089: PUSH
9090: LD_INT 1
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PPUSH
9097: CALL_OW 72
9101: ST_TO_ADDR
// for i in tmp do
9102: LD_ADDR_VAR 0 1
9106: PUSH
9107: LD_VAR 0 2
9111: PUSH
9112: FOR_IN
9113: IFFALSE 9176
// if MineOfUnit ( i ) then
9115: LD_VAR 0 1
9119: PPUSH
9120: CALL_OW 459
9124: IFFALSE 9174
// begin x := MineOfUnit ( i ) ;
9126: LD_ADDR_VAR 0 4
9130: PUSH
9131: LD_VAR 0 1
9135: PPUSH
9136: CALL_OW 459
9140: ST_TO_ADDR
// mine_launched := true ;
9141: LD_ADDR_VAR 0 3
9145: PUSH
9146: LD_INT 1
9148: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
9149: LD_VAR 0 4
9153: PUSH
9154: LD_INT 1
9156: ARRAY
9157: PPUSH
9158: LD_VAR 0 4
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PPUSH
9167: LD_INT 2
9169: PPUSH
9170: CALL_OW 456
// end ;
9174: GO 9112
9176: POP
9177: POP
// if mine_launched and IsOk ( Vervecken ) then
9178: LD_VAR 0 3
9182: PUSH
9183: LD_EXP 26
9187: PPUSH
9188: CALL_OW 302
9192: AND
9193: IFFALSE 9207
// Say ( Vervecken , D11b-Ar1-1 ) ;
9195: LD_EXP 26
9199: PPUSH
9200: LD_STRING D11b-Ar1-1
9202: PPUSH
9203: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9207: LD_INT 22
9209: PUSH
9210: LD_INT 2
9212: PUSH
9213: EMPTY
9214: LIST
9215: LIST
9216: PPUSH
9217: CALL_OW 69
9221: PPUSH
9222: LD_INT 51
9224: PPUSH
9225: LD_INT 99
9227: PPUSH
9228: CALL_OW 111
// wait ( 0 0$1 ) ;
9232: LD_INT 35
9234: PPUSH
9235: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9239: LD_INT 22
9241: PUSH
9242: LD_INT 2
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: PUSH
9249: LD_INT 92
9251: PUSH
9252: LD_INT 51
9254: PUSH
9255: LD_INT 99
9257: PUSH
9258: LD_INT 2
9260: PUSH
9261: EMPTY
9262: LIST
9263: LIST
9264: LIST
9265: LIST
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: PPUSH
9271: CALL_OW 69
9275: IFFALSE 9335
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9277: LD_ADDR_VAR 0 1
9281: PUSH
9282: LD_INT 22
9284: PUSH
9285: LD_INT 2
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PUSH
9292: LD_INT 92
9294: PUSH
9295: LD_INT 51
9297: PUSH
9298: LD_INT 99
9300: PUSH
9301: LD_INT 2
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: LIST
9308: LIST
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: PUSH
9319: FOR_IN
9320: IFFALSE 9333
// RemoveUnit ( i ) ;
9322: LD_VAR 0 1
9326: PPUSH
9327: CALL_OW 64
9331: GO 9319
9333: POP
9334: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9335: LD_INT 22
9337: PUSH
9338: LD_INT 2
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PPUSH
9345: CALL_OW 69
9349: PUSH
9350: LD_INT 0
9352: EQUAL
9353: IFFALSE 9207
// end ;
9355: PPOPN 4
9357: END
// every 0 0$1 trigger ar_can_arrive do var i ;
9358: LD_EXP 10
9362: IFFALSE 9541
9364: GO 9366
9366: DISABLE
9367: LD_INT 0
9369: PPUSH
// begin Wait ( 10 10$00 ) ;
9370: LD_INT 21000
9372: PPUSH
9373: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
9377: LD_INT 22
9379: PUSH
9380: LD_INT 2
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PPUSH
9387: CALL_OW 69
9391: IFFALSE 9541
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9393: LD_INT 22
9395: PUSH
9396: LD_INT 2
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PPUSH
9403: CALL_OW 69
9407: PPUSH
9408: LD_INT 51
9410: PPUSH
9411: LD_INT 99
9413: PPUSH
9414: CALL_OW 114
// wait ( 0 0$1 ) ;
9418: LD_INT 35
9420: PPUSH
9421: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9425: LD_INT 22
9427: PUSH
9428: LD_INT 2
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 92
9437: PUSH
9438: LD_INT 51
9440: PUSH
9441: LD_INT 99
9443: PUSH
9444: LD_INT 2
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: EMPTY
9454: LIST
9455: LIST
9456: PPUSH
9457: CALL_OW 69
9461: IFFALSE 9521
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9463: LD_ADDR_VAR 0 1
9467: PUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 2
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: LD_INT 92
9480: PUSH
9481: LD_INT 51
9483: PUSH
9484: LD_INT 99
9486: PUSH
9487: LD_INT 2
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: LIST
9494: LIST
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: PPUSH
9500: CALL_OW 69
9504: PUSH
9505: FOR_IN
9506: IFFALSE 9519
// RemoveUnit ( i ) ;
9508: LD_VAR 0 1
9512: PPUSH
9513: CALL_OW 64
9517: GO 9505
9519: POP
9520: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9521: LD_INT 22
9523: PUSH
9524: LD_INT 2
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PPUSH
9531: CALL_OW 69
9535: PUSH
9536: LD_INT 0
9538: EQUAL
9539: IFFALSE 9393
// end ; end ;
9541: PPOPN 1
9543: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
9544: LD_EXP 4
9548: IFFALSE 10350
9550: GO 9552
9552: DISABLE
9553: LD_INT 0
9555: PPUSH
9556: PPUSH
9557: PPUSH
// begin Wait ( game_time ) ;
9558: LD_EXP 7
9562: PPUSH
9563: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9567: LD_INT 35
9569: PPUSH
9570: CALL_OW 67
// until ( not ru_can_attack ) ;
9574: LD_EXP 8
9578: NOT
9579: IFFALSE 9567
// Wait ( 0 0$35 ) ;
9581: LD_INT 1225
9583: PPUSH
9584: CALL_OW 67
// DialogueOn ;
9588: CALL_OW 6
// InGameOn ;
9592: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
9596: LD_EXP 25
9600: PPUSH
9601: LD_STRING D12-Pow-1
9603: PPUSH
9604: CALL_OW 94
// InGameOff ;
9608: CALL_OW 9
// DialogueOff ;
9612: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
9616: LD_STRING M4
9618: PPUSH
9619: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
9623: LD_INT 5
9625: PPUSH
9626: LD_INT 1
9628: PPUSH
9629: CALL_OW 424
// can_end := true ;
9633: LD_ADDR_EXP 17
9637: PUSH
9638: LD_INT 1
9640: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9641: LD_INT 35
9643: PPUSH
9644: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
9648: LD_INT 22
9650: PUSH
9651: LD_INT 1
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PUSH
9658: LD_INT 21
9660: PUSH
9661: LD_INT 1
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: PPUSH
9672: CALL_OW 69
9676: PUSH
9677: LD_INT 5
9679: PPUSH
9680: LD_INT 22
9682: PUSH
9683: LD_INT 1
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: PUSH
9690: LD_INT 21
9692: PUSH
9693: LD_INT 1
9695: PUSH
9696: EMPTY
9697: LIST
9698: LIST
9699: PUSH
9700: EMPTY
9701: LIST
9702: LIST
9703: PPUSH
9704: CALL_OW 70
9708: PUSH
9709: LD_INT 22
9711: PUSH
9712: LD_INT 1
9714: PUSH
9715: EMPTY
9716: LIST
9717: LIST
9718: PUSH
9719: LD_INT 55
9721: PUSH
9722: EMPTY
9723: LIST
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: PPUSH
9729: CALL_OW 69
9733: PLUS
9734: LESSEQUAL
9735: IFFALSE 9641
// if not player_get_info then
9737: LD_EXP 15
9741: NOT
9742: IFFALSE 9753
// player_get_info := - 1 ;
9744: LD_ADDR_EXP 15
9748: PUSH
9749: LD_INT 1
9751: NEG
9752: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
9753: LD_STRING Information
9755: PPUSH
9756: LD_EXP 15
9760: PPUSH
9761: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
9765: LD_ADDR_VAR 0 2
9769: PUSH
9770: LD_INT 22
9772: PUSH
9773: LD_INT 1
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PUSH
9780: LD_INT 2
9782: PUSH
9783: LD_INT 25
9785: PUSH
9786: LD_INT 2
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PUSH
9793: LD_INT 25
9795: PUSH
9796: LD_INT 16
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: PUSH
9803: LD_INT 34
9805: PUSH
9806: LD_INT 12
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: PPUSH
9823: CALL_OW 69
9827: ST_TO_ADDR
// sib := GetTerminalCargo ;
9828: LD_ADDR_VAR 0 3
9832: PUSH
9833: CALL 784 0 0
9837: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
9838: LD_ADDR_VAR 0 3
9842: PUSH
9843: LD_VAR 0 3
9847: PUSH
9848: LD_INT 6
9850: PPUSH
9851: LD_INT 3
9853: PPUSH
9854: CALL_OW 287
9858: PLUS
9859: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
9860: LD_ADDR_VAR 0 3
9864: PUSH
9865: LD_VAR 0 3
9869: PUSH
9870: LD_VAR 0 2
9874: PPUSH
9875: LD_INT 3
9877: PPUSH
9878: CALL_OW 289
9882: PLUS
9883: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
9884: LD_VAR 0 3
9888: PUSH
9889: LD_INT 2
9891: PUSH
9892: LD_OWVAR 67
9896: PLUS
9897: PUSH
9898: LD_INT 50
9900: MUL
9901: LESS
9902: IFFALSE 9927
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
9904: LD_STRING MuchSiberite
9906: PPUSH
9907: LD_INT 2
9909: NEG
9910: PUSH
9911: LD_OWVAR 67
9915: MUL
9916: PUSH
9917: LD_INT 1
9919: PLUS
9920: PPUSH
9921: CALL_OW 101
9925: GO 9937
// AddMedal ( MuchSiberite , 1 ) ;
9927: LD_STRING MuchSiberite
9929: PPUSH
9930: LD_INT 1
9932: PPUSH
9933: CALL_OW 101
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
9937: LD_INT 22
9939: PUSH
9940: LD_INT 1
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: LD_INT 25
9952: PUSH
9953: LD_INT 1
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 25
9962: PUSH
9963: LD_INT 2
9965: PUSH
9966: EMPTY
9967: LIST
9968: LIST
9969: PUSH
9970: LD_INT 25
9972: PUSH
9973: LD_INT 3
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 4
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 25
9992: PUSH
9993: LD_INT 8
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: PPUSH
10012: CALL_OW 69
10016: PPUSH
10017: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10021: LD_ADDR_VAR 0 2
10025: PUSH
10026: LD_INT 22
10028: PUSH
10029: LD_INT 1
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PUSH
10036: LD_INT 25
10038: PUSH
10039: LD_INT 8
10041: PUSH
10042: EMPTY
10043: LIST
10044: LIST
10045: PUSH
10046: EMPTY
10047: LIST
10048: LIST
10049: PPUSH
10050: CALL_OW 69
10054: ST_TO_ADDR
// if tmp then
10055: LD_VAR 0 2
10059: IFFALSE 10090
// for i in tmp do
10061: LD_ADDR_VAR 0 1
10065: PUSH
10066: LD_VAR 0 2
10070: PUSH
10071: FOR_IN
10072: IFFALSE 10088
// SetClass ( i , 1 ) ;
10074: LD_VAR 0 1
10078: PPUSH
10079: LD_INT 1
10081: PPUSH
10082: CALL_OW 336
10086: GO 10071
10088: POP
10089: POP
// SaveVariable ( sib , 09_sibRes ) ;
10090: LD_VAR 0 3
10094: PPUSH
10095: LD_STRING 09_sibRes
10097: PPUSH
10098: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
10102: LD_EXP 15
10106: PPUSH
10107: LD_STRING 09_arInfo
10109: PPUSH
10110: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10114: LD_EXP 18
10118: PPUSH
10119: LD_EXP 1
10123: PUSH
10124: LD_STRING JMM
10126: STR
10127: PPUSH
10128: CALL_OW 38
// if IsLive ( Gary ) then
10132: LD_EXP 19
10136: PPUSH
10137: CALL_OW 300
10141: IFFALSE 10161
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
10143: LD_EXP 19
10147: PPUSH
10148: LD_EXP 1
10152: PUSH
10153: LD_STRING Gary
10155: STR
10156: PPUSH
10157: CALL_OW 38
// if IsLive ( Bobby ) then
10161: LD_EXP 20
10165: PPUSH
10166: CALL_OW 300
10170: IFFALSE 10190
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10172: LD_EXP 20
10176: PPUSH
10177: LD_EXP 1
10181: PUSH
10182: LD_STRING Bobby
10184: STR
10185: PPUSH
10186: CALL_OW 38
// if IsLive ( Cyrus ) then
10190: LD_EXP 21
10194: PPUSH
10195: CALL_OW 300
10199: IFFALSE 10219
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10201: LD_EXP 21
10205: PPUSH
10206: LD_EXP 1
10210: PUSH
10211: LD_STRING Cyrus
10213: STR
10214: PPUSH
10215: CALL_OW 38
// if IsLive ( Houten ) then
10219: LD_EXP 22
10223: PPUSH
10224: CALL_OW 300
10228: IFFALSE 10248
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
10230: LD_EXP 22
10234: PPUSH
10235: LD_EXP 1
10239: PUSH
10240: LD_STRING Houten
10242: STR
10243: PPUSH
10244: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
10248: LD_ADDR_VAR 0 2
10252: PUSH
10253: LD_INT 22
10255: PUSH
10256: LD_INT 1
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 2
10265: PUSH
10266: LD_INT 25
10268: PUSH
10269: LD_INT 1
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 25
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PUSH
10286: LD_INT 25
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: LD_INT 25
10298: PUSH
10299: LD_INT 4
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PPUSH
10317: CALL_OW 69
10321: ST_TO_ADDR
// if tmp then
10322: LD_VAR 0 2
10326: IFFALSE 10346
// SaveCharacters ( tmp , mission_prefix & others ) ;
10328: LD_VAR 0 2
10332: PPUSH
10333: LD_EXP 1
10337: PUSH
10338: LD_STRING others
10340: STR
10341: PPUSH
10342: CALL_OW 38
// YouWin ;
10346: CALL_OW 103
// end ; end_of_file
10350: PPOPN 3
10352: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
10353: LD_VAR 0 1
10357: PPUSH
10358: CALL_OW 266
10362: PUSH
10363: LD_INT 0
10365: EQUAL
10366: PUSH
10367: LD_EXP 3
10371: NOT
10372: AND
10373: IFFALSE 10397
// begin terminal := b ;
10375: LD_ADDR_EXP 3
10379: PUSH
10380: LD_VAR 0 1
10384: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
10385: LD_EXP 3
10389: PPUSH
10390: LD_STRING terminal
10392: PPUSH
10393: CALL_OW 500
// end ; end ;
10397: PPOPN 2
10399: END
// on BuildingComplete ( b ) do var i ;
10400: LD_INT 0
10402: PPUSH
// begin if GetSide ( b ) = 3 then
10403: LD_VAR 0 1
10407: PPUSH
10408: CALL_OW 255
10412: PUSH
10413: LD_INT 3
10415: EQUAL
10416: IFFALSE 10456
// for i = 1 to 4 do
10418: LD_ADDR_VAR 0 2
10422: PUSH
10423: DOUBLE
10424: LD_INT 1
10426: DEC
10427: ST_TO_ADDR
10428: LD_INT 4
10430: PUSH
10431: FOR_TO
10432: IFFALSE 10454
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
10434: LD_ADDR_EXP 35
10438: PUSH
10439: LD_EXP 35
10443: PPUSH
10444: LD_INT 1
10446: PPUSH
10447: CALL_OW 3
10451: ST_TO_ADDR
10452: GO 10431
10454: POP
10455: POP
// end ;
10456: PPOPN 2
10458: END
// on VehicleConstructed ( veh , fac ) do var i ;
10459: LD_INT 0
10461: PPUSH
// begin if GetSide ( veh ) = 3 then
10462: LD_VAR 0 1
10466: PPUSH
10467: CALL_OW 255
10471: PUSH
10472: LD_INT 3
10474: EQUAL
10475: IFFALSE 10600
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
10477: LD_VAR 0 1
10481: PPUSH
10482: CALL_OW 264
10486: PUSH
10487: LD_INT 53
10489: PUSH
10490: LD_INT 52
10492: PUSH
10493: LD_INT 51
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: LIST
10500: IN
10501: NOT
10502: IFFALSE 10520
// ru_force := ru_force ^ veh ;
10504: LD_ADDR_EXP 34
10508: PUSH
10509: LD_EXP 34
10513: PUSH
10514: LD_VAR 0 1
10518: ADD
10519: ST_TO_ADDR
// for i = 1 to 4 do
10520: LD_ADDR_VAR 0 3
10524: PUSH
10525: DOUBLE
10526: LD_INT 1
10528: DEC
10529: ST_TO_ADDR
10530: LD_INT 4
10532: PUSH
10533: FOR_TO
10534: IFFALSE 10556
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
10536: LD_ADDR_EXP 36
10540: PUSH
10541: LD_EXP 36
10545: PPUSH
10546: LD_INT 1
10548: PPUSH
10549: CALL_OW 3
10553: ST_TO_ADDR
10554: GO 10533
10556: POP
10557: POP
// if GetWeapon ( veh ) = ru_bulldozer then
10558: LD_VAR 0 1
10562: PPUSH
10563: CALL_OW 264
10567: PUSH
10568: LD_INT 53
10570: EQUAL
10571: IFFALSE 10600
// begin CutTreeInArea ( veh , cutTreeArea ) ;
10573: LD_VAR 0 1
10577: PPUSH
10578: LD_INT 7
10580: PPUSH
10581: CALL 942 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: LD_INT 170
10592: PPUSH
10593: LD_INT 235
10595: PPUSH
10596: CALL_OW 171
// end ; end ; end ;
10600: PPOPN 3
10602: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
10603: LD_VAR 0 1
10607: PUSH
10608: LD_INT 1
10610: EQUAL
10611: PUSH
10612: LD_VAR 0 2
10616: PUSH
10617: LD_INT 2
10619: EQUAL
10620: AND
10621: PUSH
10622: LD_VAR 0 1
10626: PUSH
10627: LD_INT 2
10629: EQUAL
10630: PUSH
10631: LD_VAR 0 2
10635: PUSH
10636: LD_INT 1
10638: EQUAL
10639: AND
10640: OR
10641: IFFALSE 10651
// player_attacked_ar := true ;
10643: LD_ADDR_EXP 16
10647: PUSH
10648: LD_INT 1
10650: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
10651: LD_VAR 0 1
10655: PUSH
10656: LD_INT 1
10658: EQUAL
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: LD_INT 4
10667: EQUAL
10668: AND
10669: PUSH
10670: LD_VAR 0 1
10674: PUSH
10675: LD_INT 4
10677: EQUAL
10678: PUSH
10679: LD_VAR 0 2
10683: PUSH
10684: LD_INT 1
10686: EQUAL
10687: AND
10688: OR
10689: IFFALSE 10698
// YouLost ( Traitor ) ;
10691: LD_STRING Traitor
10693: PPUSH
10694: CALL_OW 104
// end ;
10698: PPOPN 2
10700: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10701: LD_VAR 0 1
10705: PUSH
10706: LD_EXP 18
10710: EQUAL
10711: IFFALSE 10720
// YouLost ( JMM ) ;
10713: LD_STRING JMM
10715: PPUSH
10716: CALL_OW 104
// if un = terminal then
10720: LD_VAR 0 1
10724: PUSH
10725: LD_EXP 3
10729: EQUAL
10730: IFFALSE 10739
// YouLost ( Terminal ) ;
10732: LD_STRING Terminal
10734: PPUSH
10735: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
10739: LD_VAR 0 1
10743: PUSH
10744: LD_INT 22
10746: PUSH
10747: LD_INT 3
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PUSH
10754: LD_INT 21
10756: PUSH
10757: LD_INT 3
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: PPUSH
10768: CALL_OW 69
10772: IN
10773: IFFALSE 10919
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
10775: LD_VAR 0 1
10779: PPUSH
10780: CALL_OW 266
10784: PUSH
10785: LD_INT 33
10787: PUSH
10788: LD_INT 26
10790: PUSH
10791: EMPTY
10792: LIST
10793: LIST
10794: IN
10795: IFFALSE 10854
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10797: LD_ADDR_EXP 35
10801: PUSH
10802: LD_EXP 35
10806: PUSH
10807: LD_VAR 0 1
10811: PPUSH
10812: CALL_OW 266
10816: PUSH
10817: LD_VAR 0 1
10821: PPUSH
10822: CALL_OW 250
10826: PUSH
10827: LD_VAR 0 1
10831: PPUSH
10832: CALL_OW 251
10836: PUSH
10837: LD_VAR 0 1
10841: PPUSH
10842: CALL_OW 254
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: ADD
10853: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
10854: LD_VAR 0 1
10858: PPUSH
10859: CALL_OW 266
10863: PUSH
10864: LD_INT 5
10866: EQUAL
10867: IFFALSE 10919
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
10869: LD_ADDR_EXP 35
10873: PUSH
10874: LD_EXP 35
10878: PUSH
10879: LD_INT 4
10881: PUSH
10882: LD_VAR 0 1
10886: PPUSH
10887: CALL_OW 250
10891: PUSH
10892: LD_VAR 0 1
10896: PPUSH
10897: CALL_OW 251
10901: PUSH
10902: LD_VAR 0 1
10906: PPUSH
10907: CALL_OW 254
10911: PUSH
10912: EMPTY
10913: LIST
10914: LIST
10915: LIST
10916: LIST
10917: ADD
10918: ST_TO_ADDR
// end ; if un in ru_force then
10919: LD_VAR 0 1
10923: PUSH
10924: LD_EXP 34
10928: IN
10929: IFFALSE 10962
// begin ru_force := ru_force diff un ;
10931: LD_ADDR_EXP 34
10935: PUSH
10936: LD_EXP 34
10940: PUSH
10941: LD_VAR 0 1
10945: DIFF
10946: ST_TO_ADDR
// if not ru_force then
10947: LD_EXP 34
10951: NOT
10952: IFFALSE 10962
// ru_can_attack := false ;
10954: LD_ADDR_EXP 8
10958: PUSH
10959: LD_INT 0
10961: ST_TO_ADDR
// end ; end ; end_of_file
10962: PPOPN 1
10964: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
10965: LD_EXP 5
10969: PUSH
10970: LD_EXP 6
10974: AND
10975: IFFALSE 11053
10977: GO 10979
10979: DISABLE
10980: LD_INT 0
10982: PPUSH
// begin enable ;
10983: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
10984: LD_ADDR_VAR 0 1
10988: PUSH
10989: LD_INT 60
10991: PUSH
10992: CALL 784 0 0
10996: MINUS
10997: ST_TO_ADDR
// if sib < 0 then
10998: LD_VAR 0 1
11002: PUSH
11003: LD_INT 0
11005: LESS
11006: IFFALSE 11016
// sib := 0 ;
11008: LD_ADDR_VAR 0 1
11012: PUSH
11013: LD_INT 0
11015: ST_TO_ADDR
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
11016: LD_ADDR_OWVAR 47
11020: PUSH
11021: LD_STRING #Am09-1
11023: PUSH
11024: LD_VAR 0 1
11028: PUSH
11029: LD_EXP 6
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: LIST
11038: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
11039: LD_ADDR_EXP 6
11043: PUSH
11044: LD_EXP 6
11048: PUSH
11049: LD_INT 35
11051: MINUS
11052: ST_TO_ADDR
// end ;
11053: PPOPN 1
11055: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
11056: LD_EXP 6
11060: PUSH
11061: LD_INT 0
11063: EQUAL
11064: IFFALSE 11076
11066: GO 11068
11068: DISABLE
// display_strings := [ ] ;
11069: LD_ADDR_OWVAR 47
11073: PUSH
11074: EMPTY
11075: ST_TO_ADDR
11076: END
// every 1 1$35 do var i , tmp ;
11077: GO 11079
11079: DISABLE
11080: LD_INT 0
11082: PPUSH
11083: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
11084: LD_ADDR_VAR 0 2
11088: PUSH
11089: LD_INT 1155
11091: PUSH
11092: LD_INT 1225
11094: PUSH
11095: LD_INT 1435
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: LIST
11102: PUSH
11103: LD_OWVAR 67
11107: ARRAY
11108: ST_TO_ADDR
// i := 0 ;
11109: LD_ADDR_VAR 0 1
11113: PUSH
11114: LD_INT 0
11116: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
11117: LD_INT 1
11119: PPUSH
11120: LD_INT 5
11122: PPUSH
11123: CALL_OW 12
11127: PPUSH
11128: LD_INT 75
11130: PPUSH
11131: LD_INT 75
11133: PPUSH
11134: LD_INT 20
11136: PPUSH
11137: LD_INT 1
11139: PPUSH
11140: CALL_OW 56
// wait ( tmp ) ;
11144: LD_VAR 0 2
11148: PPUSH
11149: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
11153: LD_ADDR_VAR 0 2
11157: PUSH
11158: LD_VAR 0 2
11162: PUSH
11163: LD_INT 105
11165: PPUSH
11166: LD_INT 315
11168: PPUSH
11169: CALL_OW 12
11173: PLUS
11174: ST_TO_ADDR
// i := i + 1 ;
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 1
11184: PUSH
11185: LD_INT 1
11187: PLUS
11188: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
11189: LD_VAR 0 1
11193: PUSH
11194: LD_INT 3
11196: MOD
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: PUSH
11202: LD_EXP 4
11206: AND
11207: IFFALSE 11245
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
11209: LD_INT 2
11211: PPUSH
11212: LD_INT 5
11214: PPUSH
11215: CALL_OW 12
11219: PPUSH
11220: LD_INT 8
11222: PPUSH
11223: LD_INT 1
11225: PPUSH
11226: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
11230: LD_INT 665
11232: PPUSH
11233: LD_INT 735
11235: PPUSH
11236: CALL_OW 12
11240: PPUSH
11241: CALL_OW 67
// end ; until tick > game_time ;
11245: LD_OWVAR 1
11249: PUSH
11250: LD_EXP 7
11254: GREATER
11255: IFFALSE 11117
// end ; end_of_file
11257: PPOPN 2
11259: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
11260: LD_INT 0
11262: PPUSH
11263: PPUSH
11264: PPUSH
11265: PPUSH
11266: PPUSH
11267: PPUSH
// x := 76 ;
11268: LD_ADDR_VAR 0 5
11272: PUSH
11273: LD_INT 76
11275: ST_TO_ADDR
// y := 147 ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_INT 147
11283: ST_TO_ADDR
// uc_side := 2 ;
11284: LD_ADDR_OWVAR 20
11288: PUSH
11289: LD_INT 2
11291: ST_TO_ADDR
// uc_nation := 2 ;
11292: LD_ADDR_OWVAR 21
11296: PUSH
11297: LD_INT 2
11299: ST_TO_ADDR
// InitHc ;
11300: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
11304: LD_INT 1
11306: PPUSH
11307: LD_INT 1
11309: PPUSH
11310: LD_INT 6
11312: PPUSH
11313: CALL_OW 380
// hc_name := Nicolas Vervecken ;
11317: LD_ADDR_OWVAR 26
11321: PUSH
11322: LD_STRING Nicolas Vervecken
11324: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11325: LD_ADDR_OWVAR 33
11329: PUSH
11330: LD_STRING SecondCharsGal
11332: ST_TO_ADDR
// hc_face_number := 3 ;
11333: LD_ADDR_OWVAR 34
11337: PUSH
11338: LD_INT 3
11340: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
11341: LD_ADDR_OWVAR 29
11345: PUSH
11346: LD_INT 11
11348: PUSH
11349: LD_INT 10
11351: PUSH
11352: EMPTY
11353: LIST
11354: LIST
11355: ST_TO_ADDR
// Vervecken := CreateHuman ;
11356: LD_ADDR_EXP 26
11360: PUSH
11361: CALL_OW 44
11365: ST_TO_ADDR
// ar_force := Vervecken ;
11366: LD_ADDR_EXP 33
11370: PUSH
11371: LD_EXP 26
11375: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
11376: LD_INT 1
11378: PPUSH
11379: LD_INT 2
11381: PPUSH
11382: LD_INT 6
11384: PPUSH
11385: CALL_OW 380
// hc_name := Louis Gali ;
11389: LD_ADDR_OWVAR 26
11393: PUSH
11394: LD_STRING Louis Gali
11396: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11397: LD_ADDR_OWVAR 33
11401: PUSH
11402: LD_STRING SecondCharsGal
11404: ST_TO_ADDR
// hc_face_number := 2 ;
11405: LD_ADDR_OWVAR 34
11409: PUSH
11410: LD_INT 2
11412: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
11413: LD_ADDR_OWVAR 29
11417: PUSH
11418: LD_INT 10
11420: PUSH
11421: LD_INT 11
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: ST_TO_ADDR
// Gali := CreateHuman ;
11428: LD_ADDR_EXP 27
11432: PUSH
11433: CALL_OW 44
11437: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
11438: LD_ADDR_EXP 33
11442: PUSH
11443: LD_EXP 33
11447: PUSH
11448: LD_EXP 27
11452: ADD
11453: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
11454: LD_INT 2
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: LD_INT 6
11462: PPUSH
11463: CALL_OW 380
// hc_name := Maria Bogdanovic ;
11467: LD_ADDR_OWVAR 26
11471: PUSH
11472: LD_STRING Maria Bogdanovic
11474: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
11475: LD_ADDR_OWVAR 33
11479: PUSH
11480: LD_STRING SecondCharsGal
11482: ST_TO_ADDR
// hc_face_number := 14 ;
11483: LD_ADDR_OWVAR 34
11487: PUSH
11488: LD_INT 14
11490: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
11491: LD_ADDR_OWVAR 29
11495: PUSH
11496: LD_INT 12
11498: PUSH
11499: LD_INT 9
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
11506: LD_ADDR_EXP 28
11510: PUSH
11511: CALL_OW 44
11515: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
11516: LD_ADDR_EXP 33
11520: PUSH
11521: LD_EXP 33
11525: PUSH
11526: LD_EXP 28
11530: ADD
11531: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11532: LD_INT 1
11534: PPUSH
11535: LD_INT 3
11537: PPUSH
11538: LD_INT 6
11540: PPUSH
11541: CALL_OW 380
// hc_name = Kntor Radomr ;
11545: LD_ADDR_OWVAR 26
11549: PUSH
11550: LD_STRING Kntor Radomr
11552: ST_TO_ADDR
// hc_gallery = sandar ;
11553: LD_ADDR_OWVAR 33
11557: PUSH
11558: LD_STRING sandar
11560: ST_TO_ADDR
// hc_face_number = 12 ;
11561: LD_ADDR_OWVAR 34
11565: PUSH
11566: LD_INT 12
11568: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
11569: LD_ADDR_OWVAR 29
11573: PUSH
11574: LD_INT 9
11576: PUSH
11577: LD_INT 9
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: ST_TO_ADDR
// Kantor = CreateHuman ;
11584: LD_ADDR_EXP 29
11588: PUSH
11589: CALL_OW 44
11593: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
11594: LD_ADDR_EXP 33
11598: PUSH
11599: LD_EXP 33
11603: PUSH
11604: LD_EXP 29
11608: ADD
11609: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
11610: LD_INT 1
11612: PPUSH
11613: LD_INT 3
11615: PPUSH
11616: LD_INT 6
11618: PPUSH
11619: CALL_OW 380
// hc_name = Herczeg Farkas ;
11623: LD_ADDR_OWVAR 26
11627: PUSH
11628: LD_STRING Herczeg Farkas
11630: ST_TO_ADDR
// hc_gallery = sandar ;
11631: LD_ADDR_OWVAR 33
11635: PUSH
11636: LD_STRING sandar
11638: ST_TO_ADDR
// hc_face_number = 28 ;
11639: LD_ADDR_OWVAR 34
11643: PUSH
11644: LD_INT 28
11646: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
11647: LD_ADDR_OWVAR 29
11651: PUSH
11652: LD_INT 10
11654: PUSH
11655: LD_INT 9
11657: PUSH
11658: EMPTY
11659: LIST
11660: LIST
11661: ST_TO_ADDR
// Herczeg = CreateHuman ;
11662: LD_ADDR_EXP 30
11666: PUSH
11667: CALL_OW 44
11671: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
11672: LD_ADDR_EXP 33
11676: PUSH
11677: LD_EXP 33
11681: PUSH
11682: LD_EXP 30
11686: ADD
11687: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
11688: LD_INT 1
11690: PPUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 6
11696: PPUSH
11697: CALL_OW 380
// hc_name = Ronn Horntvedt ;
11701: LD_ADDR_OWVAR 26
11705: PUSH
11706: LD_STRING Ronn Horntvedt
11708: ST_TO_ADDR
// hc_gallery = sandar ;
11709: LD_ADDR_OWVAR 33
11713: PUSH
11714: LD_STRING sandar
11716: ST_TO_ADDR
// hc_face_number = 29 ;
11717: LD_ADDR_OWVAR 34
11721: PUSH
11722: LD_INT 29
11724: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
11725: LD_ADDR_OWVAR 29
11729: PUSH
11730: LD_INT 11
11732: PUSH
11733: LD_INT 11
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: ST_TO_ADDR
// Ronn = CreateHuman ;
11740: LD_ADDR_EXP 31
11744: PUSH
11745: CALL_OW 44
11749: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
11750: LD_ADDR_EXP 33
11754: PUSH
11755: LD_EXP 33
11759: PUSH
11760: LD_EXP 31
11764: ADD
11765: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
11766: LD_INT 2
11768: PPUSH
11769: LD_INT 3
11771: PPUSH
11772: LD_INT 6
11774: PPUSH
11775: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
11779: LD_ADDR_OWVAR 26
11783: PUSH
11784: LD_STRING Mia D. Mathiasen
11786: ST_TO_ADDR
// hc_gallery = sandar ;
11787: LD_ADDR_OWVAR 33
11791: PUSH
11792: LD_STRING sandar
11794: ST_TO_ADDR
// hc_face_number = 31 ;
11795: LD_ADDR_OWVAR 34
11799: PUSH
11800: LD_INT 31
11802: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
11803: LD_ADDR_OWVAR 29
11807: PUSH
11808: LD_INT 10
11810: PUSH
11811: LD_INT 10
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: ST_TO_ADDR
// Mia = CreateHuman ;
11818: LD_ADDR_EXP 32
11822: PUSH
11823: CALL_OW 44
11827: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
11828: LD_ADDR_EXP 33
11832: PUSH
11833: LD_EXP 33
11837: PUSH
11838: LD_EXP 32
11842: ADD
11843: ST_TO_ADDR
// for i = 1 to 2 do
11844: LD_ADDR_VAR 0 4
11848: PUSH
11849: DOUBLE
11850: LD_INT 1
11852: DEC
11853: ST_TO_ADDR
11854: LD_INT 2
11856: PUSH
11857: FOR_TO
11858: IFFALSE 11899
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
11860: LD_ADDR_VAR 0 3
11864: PUSH
11865: LD_VAR 0 3
11869: PUSH
11870: LD_INT 2
11872: PPUSH
11873: LD_INT 2
11875: PPUSH
11876: LD_INT 14
11878: PPUSH
11879: LD_INT 1
11881: PPUSH
11882: LD_INT 1
11884: PPUSH
11885: LD_INT 32
11887: PPUSH
11888: LD_INT 30
11890: PPUSH
11891: CALL 264 0 7
11895: ADD
11896: ST_TO_ADDR
11897: GO 11857
11899: POP
11900: POP
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower , 33 ) ;
11901: LD_ADDR_VAR 0 3
11905: PUSH
11906: LD_VAR 0 3
11910: PUSH
11911: LD_INT 2
11913: PPUSH
11914: LD_INT 2
11916: PPUSH
11917: LD_INT 14
11919: PPUSH
11920: LD_INT 1
11922: PPUSH
11923: LD_INT 1
11925: PPUSH
11926: LD_INT 26
11928: PPUSH
11929: LD_INT 33
11931: PPUSH
11932: CALL 264 0 7
11936: ADD
11937: ST_TO_ADDR
// tmp := tmp diff 0 ;
11938: LD_ADDR_VAR 0 3
11942: PUSH
11943: LD_VAR 0 3
11947: PUSH
11948: LD_INT 0
11950: DIFF
11951: ST_TO_ADDR
// for i in ar_force do
11952: LD_ADDR_VAR 0 4
11956: PUSH
11957: LD_EXP 33
11961: PUSH
11962: FOR_IN
11963: IFFALSE 12106
// begin if GetClass ( i ) = 3 then
11965: LD_VAR 0 4
11969: PPUSH
11970: CALL_OW 257
11974: PUSH
11975: LD_INT 3
11977: EQUAL
11978: IFFALSE 12060
// begin SetDir ( tmp [ 1 ] , 1 ) ;
11980: LD_VAR 0 3
11984: PUSH
11985: LD_INT 1
11987: ARRAY
11988: PPUSH
11989: LD_INT 1
11991: PPUSH
11992: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
11996: LD_VAR 0 3
12000: PUSH
12001: LD_INT 1
12003: ARRAY
12004: PPUSH
12005: LD_VAR 0 5
12009: PPUSH
12010: LD_VAR 0 6
12014: PPUSH
12015: LD_INT 0
12017: PPUSH
12018: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
12022: LD_VAR 0 4
12026: PPUSH
12027: LD_VAR 0 3
12031: PUSH
12032: LD_INT 1
12034: ARRAY
12035: PPUSH
12036: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
12040: LD_ADDR_VAR 0 3
12044: PUSH
12045: LD_VAR 0 3
12049: PPUSH
12050: LD_INT 1
12052: PPUSH
12053: CALL_OW 3
12057: ST_TO_ADDR
// end else
12058: GO 12082
// PlaceUnitXY ( i , x , y , false ) ;
12060: LD_VAR 0 4
12064: PPUSH
12065: LD_VAR 0 5
12069: PPUSH
12070: LD_VAR 0 6
12074: PPUSH
12075: LD_INT 0
12077: PPUSH
12078: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
12082: LD_VAR 0 4
12086: PPUSH
12087: LD_INT 86
12089: PPUSH
12090: LD_INT 121
12092: PPUSH
12093: CALL_OW 111
// wait ( 0 0$2 ) ;
12097: LD_INT 70
12099: PPUSH
12100: CALL_OW 67
// end ;
12104: GO 11962
12106: POP
12107: POP
// ar_force := ar_force ^ tmp ;
12108: LD_ADDR_EXP 33
12112: PUSH
12113: LD_EXP 33
12117: PUSH
12118: LD_VAR 0 3
12122: ADD
12123: ST_TO_ADDR
// ar_spawned := true ;
12124: LD_ADDR_EXP 11
12128: PUSH
12129: LD_INT 1
12131: ST_TO_ADDR
// end ; end_of_file
12132: LD_VAR 0 1
12136: RET
// export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
12137: LD_INT 0
12139: PPUSH
12140: PPUSH
12141: PPUSH
12142: PPUSH
12143: PPUSH
12144: PPUSH
12145: PPUSH
// InitHc ;
12146: CALL_OW 19
// uc_side := 3 ;
12150: LD_ADDR_OWVAR 20
12154: PUSH
12155: LD_INT 3
12157: ST_TO_ADDR
// uc_nation := 3 ;
12158: LD_ADDR_OWVAR 21
12162: PUSH
12163: LD_INT 3
12165: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
12166: LD_ADDR_VAR 0 5
12170: PUSH
12171: LD_INT 5
12173: PUSH
12174: LD_INT 6
12176: PUSH
12177: LD_INT 7
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: PUSH
12185: LD_OWVAR 67
12189: ARRAY
12190: ST_TO_ADDR
// ru_force := [ ] ;
12191: LD_ADDR_EXP 34
12195: PUSH
12196: EMPTY
12197: ST_TO_ADDR
// ru_rebuild := [ ] ;
12198: LD_ADDR_EXP 35
12202: PUSH
12203: EMPTY
12204: ST_TO_ADDR
// ru_produce_list := [ ] ;
12205: LD_ADDR_EXP 36
12209: PUSH
12210: EMPTY
12211: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
12212: LD_ADDR_VAR 0 6
12216: PUSH
12217: LD_INT 22
12219: PUSH
12220: LD_INT 3
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 30
12229: PUSH
12230: LD_INT 8
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PPUSH
12241: CALL_OW 69
12245: PUSH
12246: LD_INT 1
12248: ARRAY
12249: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
12250: LD_ADDR_VAR 0 4
12254: PUSH
12255: LD_INT 43
12257: PUSH
12258: LD_INT 46
12260: PUSH
12261: LD_INT 45
12263: PUSH
12264: EMPTY
12265: LIST
12266: LIST
12267: LIST
12268: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
12269: LD_ADDR_VAR 0 7
12273: PUSH
12274: LD_INT 22
12276: PUSH
12277: LD_INT 3
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PUSH
12284: LD_INT 30
12286: PUSH
12287: LD_INT 1
12289: PUSH
12290: EMPTY
12291: LIST
12292: LIST
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: PPUSH
12298: CALL_OW 69
12302: PUSH
12303: LD_INT 1
12305: ARRAY
12306: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
12307: LD_VAR 0 7
12311: PPUSH
12312: CALL_OW 274
12316: PPUSH
12317: LD_INT 1
12319: PPUSH
12320: LD_INT 5000
12322: PPUSH
12323: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
12327: LD_VAR 0 7
12331: PPUSH
12332: CALL_OW 274
12336: PPUSH
12337: LD_INT 2
12339: PPUSH
12340: LD_INT 1000
12342: PPUSH
12343: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
12347: LD_VAR 0 7
12351: PPUSH
12352: CALL_OW 274
12356: PPUSH
12357: LD_INT 3
12359: PPUSH
12360: LD_INT 30
12362: PPUSH
12363: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
12367: LD_ADDR_VAR 0 2
12371: PUSH
12372: LD_INT 22
12374: PUSH
12375: LD_INT 3
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 30
12384: PUSH
12385: LD_INT 33
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PPUSH
12396: CALL_OW 69
12400: PUSH
12401: FOR_IN
12402: IFFALSE 12434
// begin PlaceWeaponTurret ( i , tmp [ rand ( 1 , tmp ) ] ) ;
12404: LD_VAR 0 2
12408: PPUSH
12409: LD_VAR 0 4
12413: PUSH
12414: LD_INT 1
12416: PPUSH
12417: LD_VAR 0 4
12421: PPUSH
12422: CALL_OW 12
12426: ARRAY
12427: PPUSH
12428: CALL_OW 431
// end ;
12432: GO 12401
12434: POP
12435: POP
// for i = 1 to 4 do
12436: LD_ADDR_VAR 0 2
12440: PUSH
12441: DOUBLE
12442: LD_INT 1
12444: DEC
12445: ST_TO_ADDR
12446: LD_INT 4
12448: PUSH
12449: FOR_TO
12450: IFFALSE 12511
// begin PrepareHuman ( false , class_bazooker , skill ) ;
12452: LD_INT 0
12454: PPUSH
12455: LD_INT 9
12457: PPUSH
12458: LD_VAR 0 5
12462: PPUSH
12463: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
12467: CALL_OW 44
12471: PPUSH
12472: LD_INT 22
12474: PUSH
12475: LD_INT 3
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: PUSH
12482: LD_INT 30
12484: PUSH
12485: LD_INT 5
12487: PUSH
12488: EMPTY
12489: LIST
12490: LIST
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: PPUSH
12496: CALL_OW 69
12500: PUSH
12501: LD_INT 1
12503: ARRAY
12504: PPUSH
12505: CALL_OW 52
// end ;
12509: GO 12449
12511: POP
12512: POP
// for i = 1 to 5 do
12513: LD_ADDR_VAR 0 2
12517: PUSH
12518: DOUBLE
12519: LD_INT 1
12521: DEC
12522: ST_TO_ADDR
12523: LD_INT 5
12525: PUSH
12526: FOR_TO
12527: IFFALSE 12588
// begin PrepareHuman ( false , class_mechanic , skill ) ;
12529: LD_INT 0
12531: PPUSH
12532: LD_INT 3
12534: PPUSH
12535: LD_VAR 0 5
12539: PPUSH
12540: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
12544: CALL_OW 44
12548: PPUSH
12549: LD_INT 22
12551: PUSH
12552: LD_INT 3
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 30
12561: PUSH
12562: LD_INT 3
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PPUSH
12573: CALL_OW 69
12577: PUSH
12578: LD_INT 1
12580: ARRAY
12581: PPUSH
12582: CALL_OW 52
// end ;
12586: GO 12526
12588: POP
12589: POP
// for i = 1 to 4 do
12590: LD_ADDR_VAR 0 2
12594: PUSH
12595: DOUBLE
12596: LD_INT 1
12598: DEC
12599: ST_TO_ADDR
12600: LD_INT 4
12602: PUSH
12603: FOR_TO
12604: IFFALSE 12665
// begin PrepareHuman ( false , class_engineer , skill ) ;
12606: LD_INT 0
12608: PPUSH
12609: LD_INT 2
12611: PPUSH
12612: LD_VAR 0 5
12616: PPUSH
12617: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
12621: CALL_OW 44
12625: PPUSH
12626: LD_INT 22
12628: PUSH
12629: LD_INT 3
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: LD_INT 30
12638: PUSH
12639: LD_INT 1
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: PPUSH
12650: CALL_OW 69
12654: PUSH
12655: LD_INT 1
12657: ARRAY
12658: PPUSH
12659: CALL_OW 52
// end ;
12663: GO 12603
12665: POP
12666: POP
// for i = 1 to 3 do
12667: LD_ADDR_VAR 0 2
12671: PUSH
12672: DOUBLE
12673: LD_INT 1
12675: DEC
12676: ST_TO_ADDR
12677: LD_INT 3
12679: PUSH
12680: FOR_TO
12681: IFFALSE 12714
// begin PrepareHuman ( false , class_scientistic , skill ) ;
12683: LD_INT 0
12685: PPUSH
12686: LD_INT 4
12688: PPUSH
12689: LD_VAR 0 5
12693: PPUSH
12694: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
12698: CALL_OW 44
12702: PPUSH
12703: LD_VAR 0 6
12707: PPUSH
12708: CALL_OW 52
// end ;
12712: GO 12680
12714: POP
12715: POP
// AddComResearch ( lab , tech_tech2 ) ;
12716: LD_VAR 0 6
12720: PPUSH
12721: LD_INT 49
12723: PPUSH
12724: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
12728: LD_VAR 0 6
12732: PPUSH
12733: LD_INT 50
12735: PPUSH
12736: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
12740: LD_VAR 0 6
12744: PPUSH
12745: LD_INT 51
12747: PPUSH
12748: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
12752: LD_VAR 0 6
12756: PPUSH
12757: LD_INT 52
12759: PPUSH
12760: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
12764: LD_VAR 0 6
12768: PPUSH
12769: LD_INT 69
12771: PPUSH
12772: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
12776: LD_VAR 0 6
12780: PPUSH
12781: LD_INT 39
12783: PPUSH
12784: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
12788: LD_VAR 0 6
12792: PPUSH
12793: LD_INT 34
12795: PPUSH
12796: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
12800: LD_VAR 0 6
12804: PPUSH
12805: LD_INT 40
12807: PPUSH
12808: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
12812: LD_VAR 0 6
12816: PPUSH
12817: LD_INT 57
12819: PPUSH
12820: CALL_OW 184
// if Difficulty > 1 then
12824: LD_OWVAR 67
12828: PUSH
12829: LD_INT 1
12831: GREATER
12832: IFFALSE 12846
// AddComResearch ( lab , tech_comp2 ) ;
12834: LD_VAR 0 6
12838: PPUSH
12839: LD_INT 58
12841: PPUSH
12842: CALL_OW 184
// end ;
12846: LD_VAR 0 1
12850: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
12851: LD_INT 7
12853: PPUSH
12854: CALL_OW 353
12858: PUSH
12859: LD_INT 3
12861: GREATER
12862: PUSH
12863: LD_INT 22
12865: PUSH
12866: LD_INT 3
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: PUSH
12873: LD_INT 34
12875: PUSH
12876: LD_INT 53
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PPUSH
12887: CALL_OW 69
12891: NOT
12892: AND
12893: IFFALSE 12928
12895: GO 12897
12897: DISABLE
// begin enable ;
12898: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
12899: LD_ADDR_EXP 36
12903: PUSH
12904: LD_EXP 36
12908: PUSH
12909: LD_INT 24
12911: PUSH
12912: LD_INT 1
12914: PUSH
12915: LD_INT 3
12917: PUSH
12918: LD_INT 53
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: ADD
12927: ST_TO_ADDR
// end ;
12928: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
12929: LD_INT 22
12931: PUSH
12932: LD_INT 3
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: PUSH
12939: LD_INT 21
12941: PUSH
12942: LD_INT 3
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PPUSH
12953: CALL_OW 69
12957: IFFALSE 13735
12959: GO 12961
12961: DISABLE
12962: LD_INT 0
12964: PPUSH
12965: PPUSH
12966: PPUSH
12967: PPUSH
12968: PPUSH
12969: PPUSH
12970: PPUSH
12971: PPUSH
// begin enable ;
12972: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12973: LD_ADDR_VAR 0 3
12977: PUSH
12978: LD_INT 22
12980: PUSH
12981: LD_INT 3
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 21
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: LD_INT 3
13000: PUSH
13001: LD_INT 24
13003: PUSH
13004: LD_INT 1000
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
13025: LD_ADDR_VAR 0 4
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 3
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 25
13042: PUSH
13043: LD_INT 2
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PPUSH
13054: CALL_OW 69
13058: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13059: LD_ADDR_VAR 0 5
13063: PUSH
13064: LD_INT 22
13066: PUSH
13067: LD_INT 3
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 30
13076: PUSH
13077: LD_INT 1
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PPUSH
13088: CALL_OW 69
13092: PUSH
13093: LD_INT 1
13095: ARRAY
13096: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
13097: LD_ADDR_VAR 0 8
13101: PUSH
13102: LD_INT 22
13104: PUSH
13105: LD_INT 3
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: PUSH
13112: LD_INT 2
13114: PUSH
13115: LD_INT 30
13117: PUSH
13118: LD_INT 6
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: LD_INT 30
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 30
13137: PUSH
13138: LD_INT 8
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PPUSH
13155: CALL_OW 69
13159: PUSH
13160: LD_INT 1
13162: ARRAY
13163: ST_TO_ADDR
// if not engs then
13164: LD_VAR 0 4
13168: NOT
13169: IFFALSE 13173
// exit ;
13171: GO 13735
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
13173: LD_ADDR_VAR 0 6
13177: PUSH
13178: LD_VAR 0 4
13182: PPUSH
13183: LD_INT 3
13185: PUSH
13186: LD_INT 24
13188: PUSH
13189: LD_INT 600
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: EMPTY
13197: LIST
13198: LIST
13199: PPUSH
13200: CALL_OW 72
13204: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
13205: LD_ADDR_VAR 0 7
13209: PUSH
13210: LD_INT 22
13212: PUSH
13213: LD_INT 3
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: LD_INT 25
13222: PUSH
13223: LD_INT 4
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: PUSH
13230: EMPTY
13231: LIST
13232: LIST
13233: PPUSH
13234: CALL_OW 69
13238: ST_TO_ADDR
// if not tmp and not ru_rebuild then
13239: LD_VAR 0 3
13243: NOT
13244: PUSH
13245: LD_EXP 35
13249: NOT
13250: AND
13251: IFFALSE 13311
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
13253: LD_VAR 0 4
13257: PPUSH
13258: LD_INT 3
13260: PUSH
13261: LD_INT 54
13263: PUSH
13264: EMPTY
13265: LIST
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: PPUSH
13271: CALL_OW 72
13275: IFFALSE 13309
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
13277: LD_VAR 0 4
13281: PPUSH
13282: LD_INT 3
13284: PUSH
13285: LD_INT 54
13287: PUSH
13288: EMPTY
13289: LIST
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: PPUSH
13295: CALL_OW 72
13299: PPUSH
13300: LD_VAR 0 5
13304: PPUSH
13305: CALL_OW 120
// exit ;
13309: GO 13735
// end ; if UnitFilter ( engs , [ f_inside ] ) then
13311: LD_VAR 0 4
13315: PPUSH
13316: LD_INT 54
13318: PUSH
13319: EMPTY
13320: LIST
13321: PPUSH
13322: CALL_OW 72
13326: IFFALSE 13348
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
13328: LD_VAR 0 4
13332: PPUSH
13333: LD_INT 54
13335: PUSH
13336: EMPTY
13337: LIST
13338: PPUSH
13339: CALL_OW 72
13343: PPUSH
13344: CALL_OW 122
// if not tmp then
13348: LD_VAR 0 3
13352: NOT
13353: IFFALSE 13485
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
13355: LD_INT 81
13357: PUSH
13358: LD_INT 3
13360: PUSH
13361: EMPTY
13362: LIST
13363: LIST
13364: PUSH
13365: LD_INT 92
13367: PUSH
13368: LD_INT 147
13370: PUSH
13371: LD_INT 212
13373: PUSH
13374: LD_INT 30
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PPUSH
13387: CALL_OW 69
13391: NOT
13392: IFFALSE 13485
// begin if not HasTask ( engs [ 1 ] ) then
13394: LD_VAR 0 4
13398: PUSH
13399: LD_INT 1
13401: ARRAY
13402: PPUSH
13403: CALL_OW 314
13407: NOT
13408: IFFALSE 13485
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
13410: LD_ADDR_VAR 0 2
13414: PUSH
13415: LD_VAR 0 4
13419: PPUSH
13420: LD_EXP 35
13424: PUSH
13425: LD_INT 1
13427: ARRAY
13428: PPUSH
13429: LD_EXP 35
13433: PUSH
13434: LD_INT 2
13436: ARRAY
13437: PPUSH
13438: LD_EXP 35
13442: PUSH
13443: LD_INT 3
13445: ARRAY
13446: PPUSH
13447: LD_EXP 35
13451: PUSH
13452: LD_INT 4
13454: ARRAY
13455: PPUSH
13456: CALL_OW 145
13460: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
13461: LD_VAR 0 2
13465: PPUSH
13466: CALL_OW 266
13470: PUSH
13471: LD_INT 4
13473: EQUAL
13474: IFFALSE 13485
// AddComUpgrade ( i ) ;
13476: LD_VAR 0 2
13480: PPUSH
13481: CALL_OW 206
// end ; end ; end ; for i in engs do
13485: LD_ADDR_VAR 0 2
13489: PUSH
13490: LD_VAR 0 4
13494: PUSH
13495: FOR_IN
13496: IFFALSE 13614
// begin if i in to_heal and sci then
13498: LD_VAR 0 2
13502: PUSH
13503: LD_VAR 0 6
13507: IN
13508: PUSH
13509: LD_VAR 0 7
13513: AND
13514: IFFALSE 13565
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
13516: LD_VAR 0 2
13520: PPUSH
13521: LD_INT 149
13523: PPUSH
13524: LD_INT 220
13526: PPUSH
13527: CALL_OW 297
13531: PUSH
13532: LD_INT 5
13534: LESS
13535: IFFALSE 13539
// continue ;
13537: GO 13495
// ComMoveXY ( i , 149 , 220 ) ;
13539: LD_VAR 0 2
13543: PPUSH
13544: LD_INT 149
13546: PPUSH
13547: LD_INT 220
13549: PPUSH
13550: CALL_OW 111
// AddComHold ( i ) ;
13554: LD_VAR 0 2
13558: PPUSH
13559: CALL_OW 200
// end else
13563: GO 13612
// if not HasTask ( i ) or WantsToAttack ( i ) then
13565: LD_VAR 0 2
13569: PPUSH
13570: CALL_OW 314
13574: NOT
13575: PUSH
13576: LD_VAR 0 2
13580: PPUSH
13581: CALL_OW 319
13585: OR
13586: IFFALSE 13612
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
13588: LD_VAR 0 2
13592: PPUSH
13593: LD_VAR 0 3
13597: PPUSH
13598: LD_VAR 0 2
13602: PPUSH
13603: CALL_OW 74
13607: PPUSH
13608: CALL_OW 130
// end ;
13612: GO 13495
13614: POP
13615: POP
// if to_heal and sci then
13616: LD_VAR 0 6
13620: PUSH
13621: LD_VAR 0 7
13625: AND
13626: IFFALSE 13687
// begin if UnitFilter ( sci , [ f_inside ] ) then
13628: LD_VAR 0 7
13632: PPUSH
13633: LD_INT 54
13635: PUSH
13636: EMPTY
13637: LIST
13638: PPUSH
13639: CALL_OW 72
13643: IFFALSE 13667
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
13645: LD_VAR 0 7
13649: PPUSH
13650: LD_INT 54
13652: PUSH
13653: EMPTY
13654: LIST
13655: PPUSH
13656: CALL_OW 72
13660: PPUSH
13661: CALL_OW 122
13665: GO 13685
// ComHeal ( sci , to_heal [ 1 ] ) ;
13667: LD_VAR 0 7
13671: PPUSH
13672: LD_VAR 0 6
13676: PUSH
13677: LD_INT 1
13679: ARRAY
13680: PPUSH
13681: CALL_OW 128
// end else
13685: GO 13735
// if UnitFilter ( sci , [ f_outside ] ) and lab then
13687: LD_VAR 0 7
13691: PPUSH
13692: LD_INT 56
13694: PUSH
13695: EMPTY
13696: LIST
13697: PPUSH
13698: CALL_OW 72
13702: PUSH
13703: LD_VAR 0 8
13707: AND
13708: IFFALSE 13735
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
13710: LD_VAR 0 7
13714: PPUSH
13715: LD_INT 56
13717: PUSH
13718: EMPTY
13719: LIST
13720: PPUSH
13721: CALL_OW 72
13725: PPUSH
13726: LD_VAR 0 8
13730: PPUSH
13731: CALL_OW 120
// end ;
13735: PPOPN 8
13737: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
13738: LD_INT 22
13740: PUSH
13741: LD_INT 3
13743: PUSH
13744: EMPTY
13745: LIST
13746: LIST
13747: PUSH
13748: LD_INT 30
13750: PUSH
13751: LD_INT 3
13753: PUSH
13754: EMPTY
13755: LIST
13756: LIST
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: PPUSH
13762: CALL_OW 69
13766: PUSH
13767: LD_EXP 36
13771: AND
13772: IFFALSE 13898
13774: GO 13776
13776: DISABLE
13777: LD_INT 0
13779: PPUSH
13780: PPUSH
13781: PPUSH
// begin enable ;
13782: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
13783: LD_ADDR_VAR 0 3
13787: PUSH
13788: LD_INT 22
13790: PUSH
13791: LD_INT 3
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: PUSH
13798: LD_INT 30
13800: PUSH
13801: LD_INT 3
13803: PUSH
13804: EMPTY
13805: LIST
13806: LIST
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 69
13816: PUSH
13817: LD_INT 1
13819: ARRAY
13820: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
13821: LD_VAR 0 3
13825: PPUSH
13826: CALL_OW 313
13830: PUSH
13831: LD_INT 0
13833: EQUAL
13834: IFFALSE 13838
// exit ;
13836: GO 13898
// if BuildingStatus ( fac ) = bs_idle then
13838: LD_VAR 0 3
13842: PPUSH
13843: CALL_OW 461
13847: PUSH
13848: LD_INT 2
13850: EQUAL
13851: IFFALSE 13898
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
13853: LD_VAR 0 3
13857: PPUSH
13858: LD_EXP 36
13862: PUSH
13863: LD_INT 1
13865: ARRAY
13866: PPUSH
13867: LD_EXP 36
13871: PUSH
13872: LD_INT 2
13874: ARRAY
13875: PPUSH
13876: LD_EXP 36
13880: PUSH
13881: LD_INT 3
13883: ARRAY
13884: PPUSH
13885: LD_EXP 36
13889: PUSH
13890: LD_INT 4
13892: ARRAY
13893: PPUSH
13894: CALL_OW 125
// end ;
13898: PPOPN 3
13900: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
13901: LD_INT 0
13903: PPUSH
13904: PPUSH
13905: PPUSH
13906: PPUSH
13907: PPUSH
// uc_side := 3 ;
13908: LD_ADDR_OWVAR 20
13912: PUSH
13913: LD_INT 3
13915: ST_TO_ADDR
// uc_nation := 3 ;
13916: LD_ADDR_OWVAR 21
13920: PUSH
13921: LD_INT 3
13923: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
13924: LD_ADDR_VAR 0 6
13928: PUSH
13929: LD_INT 22
13931: PUSH
13932: LD_INT 3
13934: PUSH
13935: EMPTY
13936: LIST
13937: LIST
13938: PUSH
13939: LD_INT 30
13941: PUSH
13942: LD_INT 3
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: PPUSH
13953: CALL_OW 69
13957: ST_TO_ADDR
// if fac then
13958: LD_VAR 0 6
13962: IFFALSE 14114
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
13964: LD_ADDR_EXP 36
13968: PUSH
13969: LD_INT 24
13971: PUSH
13972: LD_INT 1
13974: PUSH
13975: LD_INT 3
13977: PUSH
13978: LD_INT 43
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: LIST
13985: LIST
13986: ST_TO_ADDR
// if wave > 1 then
13987: LD_VAR 0 1
13991: PUSH
13992: LD_INT 1
13994: GREATER
13995: IFFALSE 14048
// for i = 1 to Difficulty do
13997: LD_ADDR_VAR 0 3
14001: PUSH
14002: DOUBLE
14003: LD_INT 1
14005: DEC
14006: ST_TO_ADDR
14007: LD_OWVAR 67
14011: PUSH
14012: FOR_TO
14013: IFFALSE 14046
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
14015: LD_ADDR_EXP 36
14019: PUSH
14020: LD_EXP 36
14024: PUSH
14025: LD_INT 24
14027: PUSH
14028: LD_INT 1
14030: PUSH
14031: LD_INT 3
14033: PUSH
14034: LD_INT 45
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: ADD
14043: ST_TO_ADDR
14044: GO 14012
14046: POP
14047: POP
// repeat wait ( 0 0$1 ) ;
14048: LD_INT 35
14050: PPUSH
14051: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
14055: LD_EXP 36
14059: PUSH
14060: LD_INT 4
14062: LESS
14063: PUSH
14064: LD_VAR 0 6
14068: PUSH
14069: LD_INT 1
14071: ARRAY
14072: PPUSH
14073: CALL_OW 313
14077: PUSH
14078: LD_INT 0
14080: EQUAL
14081: OR
14082: PUSH
14083: LD_VAR 0 6
14087: PUSH
14088: LD_INT 1
14090: ARRAY
14091: PPUSH
14092: CALL_OW 461
14096: PUSH
14097: LD_INT 8
14099: PUSH
14100: LD_INT 6
14102: PUSH
14103: LD_INT 7
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: IN
14111: OR
14112: IFFALSE 14048
// end ; case wave of 1 :
14114: LD_VAR 0 1
14118: PUSH
14119: LD_INT 1
14121: DOUBLE
14122: EQUAL
14123: IFTRUE 14127
14125: GO 14212
14127: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
14128: LD_ADDR_VAR 0 3
14132: PUSH
14133: DOUBLE
14134: LD_INT 1
14136: DEC
14137: ST_TO_ADDR
14138: LD_INT 4
14140: PUSH
14141: LD_INT 5
14143: PUSH
14144: LD_INT 6
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: LIST
14151: PUSH
14152: LD_OWVAR 67
14156: ARRAY
14157: PUSH
14158: FOR_TO
14159: IFFALSE 14167
// Sold ;
14161: CALL 14430 0 0
14165: GO 14158
14167: POP
14168: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
14169: LD_ADDR_VAR 0 3
14173: PUSH
14174: DOUBLE
14175: LD_INT 1
14177: DEC
14178: ST_TO_ADDR
14179: LD_INT 2
14181: PUSH
14182: LD_INT 3
14184: PUSH
14185: LD_INT 3
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: LIST
14192: PUSH
14193: LD_OWVAR 67
14197: ARRAY
14198: PUSH
14199: FOR_TO
14200: IFFALSE 14208
// Tank ;
14202: CALL 14544 0 0
14206: GO 14199
14208: POP
14209: POP
// end ; 2 .. 9 :
14210: GO 14425
14212: LD_INT 2
14214: DOUBLE
14215: GREATEREQUAL
14216: IFFALSE 14224
14218: LD_INT 9
14220: DOUBLE
14221: LESSEQUAL
14222: IFTRUE 14226
14224: GO 14331
14226: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] + ( wave div 2 ) do
14227: LD_ADDR_VAR 0 3
14231: PUSH
14232: DOUBLE
14233: LD_INT 1
14235: DEC
14236: ST_TO_ADDR
14237: LD_INT 5
14239: PUSH
14240: LD_INT 6
14242: PUSH
14243: LD_INT 7
14245: PUSH
14246: EMPTY
14247: LIST
14248: LIST
14249: LIST
14250: PUSH
14251: LD_OWVAR 67
14255: ARRAY
14256: PUSH
14257: LD_VAR 0 1
14261: PUSH
14262: LD_INT 2
14264: DIV
14265: PLUS
14266: PUSH
14267: FOR_TO
14268: IFFALSE 14276
// Sold ;
14270: CALL 14430 0 0
14274: GO 14267
14276: POP
14277: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] + ( wave div 2 ) do
14278: LD_ADDR_VAR 0 3
14282: PUSH
14283: DOUBLE
14284: LD_INT 1
14286: DEC
14287: ST_TO_ADDR
14288: LD_INT 3
14290: PUSH
14291: LD_INT 4
14293: PUSH
14294: LD_INT 4
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: LIST
14301: PUSH
14302: LD_OWVAR 67
14306: ARRAY
14307: PUSH
14308: LD_VAR 0 1
14312: PUSH
14313: LD_INT 2
14315: DIV
14316: PLUS
14317: PUSH
14318: FOR_TO
14319: IFFALSE 14327
// Tank ;
14321: CALL 14544 0 0
14325: GO 14318
14327: POP
14328: POP
// end ; 10 :
14329: GO 14425
14331: LD_INT 10
14333: DOUBLE
14334: EQUAL
14335: IFTRUE 14339
14337: GO 14424
14339: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
14340: LD_ADDR_VAR 0 3
14344: PUSH
14345: DOUBLE
14346: LD_INT 1
14348: DEC
14349: ST_TO_ADDR
14350: LD_INT 10
14352: PUSH
14353: LD_INT 12
14355: PUSH
14356: LD_INT 14
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: LIST
14363: PUSH
14364: LD_OWVAR 67
14368: ARRAY
14369: PUSH
14370: FOR_TO
14371: IFFALSE 14379
// Sold ;
14373: CALL 14430 0 0
14377: GO 14370
14379: POP
14380: POP
// for i = 1 to [ 9 , 11 , 15 ] [ Difficulty ] do
14381: LD_ADDR_VAR 0 3
14385: PUSH
14386: DOUBLE
14387: LD_INT 1
14389: DEC
14390: ST_TO_ADDR
14391: LD_INT 9
14393: PUSH
14394: LD_INT 11
14396: PUSH
14397: LD_INT 15
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: LIST
14404: PUSH
14405: LD_OWVAR 67
14409: ARRAY
14410: PUSH
14411: FOR_TO
14412: IFFALSE 14420
// Tank ;
14414: CALL 14544 0 0
14418: GO 14411
14420: POP
14421: POP
// end ; end ;
14422: GO 14425
14424: POP
// end ;
14425: LD_VAR 0 2
14429: RET
// function Sold ( ) ; var un , skill ; begin
14430: LD_INT 0
14432: PPUSH
14433: PPUSH
14434: PPUSH
// InitHc ;
14435: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
14439: LD_ADDR_VAR 0 3
14443: PUSH
14444: LD_INT 6
14446: PUSH
14447: LD_INT 7
14449: PUSH
14450: LD_INT 7
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: LIST
14457: PUSH
14458: LD_OWVAR 67
14462: ARRAY
14463: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
14464: LD_INT 0
14466: PPUSH
14467: LD_INT 1
14469: PUSH
14470: LD_INT 9
14472: PUSH
14473: EMPTY
14474: LIST
14475: LIST
14476: PUSH
14477: LD_INT 1
14479: PPUSH
14480: LD_INT 2
14482: PPUSH
14483: CALL_OW 12
14487: ARRAY
14488: PPUSH
14489: LD_VAR 0 3
14493: PPUSH
14494: CALL_OW 380
// un := CreateHuman ;
14498: LD_ADDR_VAR 0 2
14502: PUSH
14503: CALL_OW 44
14507: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
14508: LD_VAR 0 2
14512: PPUSH
14513: LD_INT 4
14515: PPUSH
14516: LD_INT 0
14518: PPUSH
14519: CALL_OW 49
// ru_force := ru_force ^ un ;
14523: LD_ADDR_EXP 34
14527: PUSH
14528: LD_EXP 34
14532: PUSH
14533: LD_VAR 0 2
14537: ADD
14538: ST_TO_ADDR
// end ;
14539: LD_VAR 0 1
14543: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
14544: LD_INT 0
14546: PPUSH
14547: PPUSH
14548: PPUSH
14549: PPUSH
14550: PPUSH
// InitHc ;
14551: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
14555: LD_ADDR_VAR 0 5
14559: PUSH
14560: LD_INT 5
14562: PUSH
14563: LD_INT 6
14565: PUSH
14566: LD_INT 7
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: PUSH
14574: LD_OWVAR 67
14578: ARRAY
14579: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
14580: LD_ADDR_VAR 0 3
14584: PUSH
14585: LD_INT 22
14587: PUSH
14588: LD_INT 24
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: PUSH
14595: LD_INT 1
14597: PPUSH
14598: LD_INT 2
14600: PPUSH
14601: CALL_OW 12
14605: ARRAY
14606: ST_TO_ADDR
// if chassis = ru_medium_tracked then
14607: LD_VAR 0 3
14611: PUSH
14612: LD_INT 22
14614: EQUAL
14615: IFFALSE 14650
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
14617: LD_ADDR_VAR 0 4
14621: PUSH
14622: LD_INT 45
14624: PUSH
14625: LD_INT 43
14627: PUSH
14628: LD_INT 44
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: LIST
14635: PUSH
14636: LD_INT 1
14638: PPUSH
14639: LD_INT 3
14641: PPUSH
14642: CALL_OW 12
14646: ARRAY
14647: ST_TO_ADDR
14648: GO 14681
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
14650: LD_ADDR_VAR 0 4
14654: PUSH
14655: LD_INT 46
14657: PUSH
14658: LD_INT 44
14660: PUSH
14661: LD_INT 45
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: LIST
14668: PUSH
14669: LD_INT 1
14671: PPUSH
14672: LD_INT 3
14674: PPUSH
14675: CALL_OW 12
14679: ARRAY
14680: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
14681: LD_ADDR_VAR 0 2
14685: PUSH
14686: LD_INT 3
14688: PPUSH
14689: LD_INT 3
14691: PPUSH
14692: LD_VAR 0 3
14696: PPUSH
14697: LD_INT 1
14699: PPUSH
14700: LD_INT 3
14702: PUSH
14703: LD_INT 3
14705: PUSH
14706: LD_INT 3
14708: PUSH
14709: LD_INT 1
14711: PUSH
14712: EMPTY
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: PUSH
14718: LD_INT 1
14720: PPUSH
14721: LD_INT 4
14723: PPUSH
14724: CALL_OW 12
14728: ARRAY
14729: PPUSH
14730: LD_VAR 0 4
14734: PPUSH
14735: LD_INT 99
14737: PPUSH
14738: CALL 264 0 7
14742: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
14743: LD_VAR 0 2
14747: PPUSH
14748: CALL_OW 263
14752: PUSH
14753: LD_INT 1
14755: EQUAL
14756: IFFALSE 14787
// begin PrepareHuman ( false , 3 , skill ) ;
14758: LD_INT 0
14760: PPUSH
14761: LD_INT 3
14763: PPUSH
14764: LD_VAR 0 5
14768: PPUSH
14769: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
14773: CALL_OW 44
14777: PPUSH
14778: LD_VAR 0 2
14782: PPUSH
14783: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
14787: LD_VAR 0 2
14791: PPUSH
14792: LD_INT 3
14794: PPUSH
14795: LD_INT 0
14797: PPUSH
14798: CALL_OW 49
// ru_force := ru_force ^ un ;
14802: LD_ADDR_EXP 34
14806: PUSH
14807: LD_EXP 34
14811: PUSH
14812: LD_VAR 0 2
14816: ADD
14817: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
14818: LD_VAR 0 2
14822: PPUSH
14823: LD_INT 126
14825: PPUSH
14826: LD_INT 158
14828: PPUSH
14829: CALL_OW 111
// Wait ( 0 0$3 ) ;
14833: LD_INT 105
14835: PPUSH
14836: CALL_OW 67
// ComStop ( un ) ;
14840: LD_VAR 0 2
14844: PPUSH
14845: CALL_OW 141
// end ;
14849: LD_VAR 0 1
14853: RET
// every 0 0$1 do var i , time , wave ;
14854: GO 14856
14856: DISABLE
14857: LD_INT 0
14859: PPUSH
14860: PPUSH
14861: PPUSH
// begin time := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
14862: LD_ADDR_VAR 0 2
14866: PUSH
14867: LD_INT 25200
14869: PUSH
14870: LD_INT 23100
14872: PUSH
14873: LD_INT 21000
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: LIST
14880: PUSH
14881: LD_OWVAR 67
14885: ARRAY
14886: ST_TO_ADDR
// wait ( time ) ;
14887: LD_VAR 0 2
14891: PPUSH
14892: CALL_OW 67
// time := [ 8 8$30 , 7 7$50 , 7 7$30 ] [ Difficulty ] ;
14896: LD_ADDR_VAR 0 2
14900: PUSH
14901: LD_INT 17850
14903: PUSH
14904: LD_INT 16450
14906: PUSH
14907: LD_INT 15750
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: LIST
14914: PUSH
14915: LD_OWVAR 67
14919: ARRAY
14920: ST_TO_ADDR
// wave := 0 ;
14921: LD_ADDR_VAR 0 3
14925: PUSH
14926: LD_INT 0
14928: ST_TO_ADDR
// while true do
14929: LD_INT 1
14931: IFFALSE 15028
// begin wave := wave + 1 ;
14933: LD_ADDR_VAR 0 3
14937: PUSH
14938: LD_VAR 0 3
14942: PUSH
14943: LD_INT 1
14945: PLUS
14946: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
14947: LD_INT 22
14949: PUSH
14950: LD_INT 2
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PPUSH
14957: CALL_OW 69
14961: IFFALSE 14990
// repeat wait ( 0 0$1 ) ;
14963: LD_INT 35
14965: PPUSH
14966: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
14970: LD_INT 22
14972: PUSH
14973: LD_INT 2
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL_OW 69
14984: PUSH
14985: LD_INT 0
14987: EQUAL
14988: IFFALSE 14963
// if ru_force < 20 then
14990: LD_EXP 34
14994: PUSH
14995: LD_INT 20
14997: LESS
14998: IFFALSE 15009
// PrepareAttack ( wave ) ;
15000: LD_VAR 0 3
15004: PPUSH
15005: CALL 13901 0 1
// ru_can_attack := true ;
15009: LD_ADDR_EXP 8
15013: PUSH
15014: LD_INT 1
15016: ST_TO_ADDR
// wait ( time ) ;
15017: LD_VAR 0 2
15021: PPUSH
15022: CALL_OW 67
// end ;
15026: GO 14929
// end ;
15028: PPOPN 3
15030: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
15031: LD_EXP 8
15035: PUSH
15036: LD_EXP 34
15040: AND
15041: IFFALSE 15783
15043: GO 15045
15045: DISABLE
15046: LD_INT 0
15048: PPUSH
15049: PPUSH
15050: PPUSH
15051: PPUSH
15052: PPUSH
15053: PPUSH
15054: PPUSH
15055: PPUSH
15056: PPUSH
// begin enable ;
15057: ENABLE
// points1 := [ 107 , 123 ] ;
15058: LD_ADDR_VAR 0 4
15062: PUSH
15063: LD_INT 107
15065: PUSH
15066: LD_INT 123
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
15073: LD_ADDR_VAR 0 5
15077: PUSH
15078: LD_INT 55
15080: PUSH
15081: LD_INT 42
15083: PUSH
15084: EMPTY
15085: LIST
15086: LIST
15087: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
15088: LD_ADDR_VAR 0 6
15092: PUSH
15093: LD_INT 102
15095: PUSH
15096: LD_INT 140
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: PUSH
15103: LD_INT 105
15105: PUSH
15106: LD_INT 142
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PUSH
15113: LD_INT 129
15115: PUSH
15116: LD_INT 131
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: PUSH
15123: EMPTY
15124: LIST
15125: LIST
15126: LIST
15127: ST_TO_ADDR
// for i in ru_force do
15128: LD_ADDR_VAR 0 1
15132: PUSH
15133: LD_EXP 34
15137: PUSH
15138: FOR_IN
15139: IFFALSE 15781
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
15141: LD_ADDR_VAR 0 3
15145: PUSH
15146: LD_INT 81
15148: PUSH
15149: LD_INT 3
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: PPUSH
15156: CALL_OW 69
15160: PPUSH
15161: LD_VAR 0 1
15165: PPUSH
15166: CALL_OW 74
15170: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
15171: LD_VAR 0 1
15175: PPUSH
15176: LD_VAR 0 3
15180: PPUSH
15181: CALL_OW 296
15185: PUSH
15186: LD_INT 12
15188: LESS
15189: IFFALSE 15334
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15191: LD_VAR 0 1
15195: PPUSH
15196: CALL_OW 247
15200: PUSH
15201: LD_INT 1
15203: EQUAL
15204: PUSH
15205: LD_VAR 0 1
15209: PPUSH
15210: CALL_OW 257
15214: PUSH
15215: LD_INT 1
15217: EQUAL
15218: AND
15219: PUSH
15220: LD_VAR 0 3
15224: PUSH
15225: LD_INT 21
15227: PUSH
15228: LD_INT 2
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: LD_INT 58
15237: PUSH
15238: EMPTY
15239: LIST
15240: PUSH
15241: EMPTY
15242: LIST
15243: LIST
15244: PPUSH
15245: CALL_OW 69
15249: IN
15250: AND
15251: IFFALSE 15269
// ComEnterUnit ( i , un ) else
15253: LD_VAR 0 1
15257: PPUSH
15258: LD_VAR 0 3
15262: PPUSH
15263: CALL_OW 120
15267: GO 15332
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
15269: LD_VAR 0 3
15273: PUSH
15274: LD_INT 21
15276: PUSH
15277: LD_INT 2
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: PUSH
15284: LD_INT 58
15286: PUSH
15287: EMPTY
15288: LIST
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PPUSH
15294: CALL_OW 69
15298: IN
15299: NOT
15300: IFFALSE 15318
// ComAttackUnit ( i , un ) else
15302: LD_VAR 0 1
15306: PPUSH
15307: LD_VAR 0 3
15311: PPUSH
15312: CALL_OW 115
15316: GO 15332
// ComAttackUnit ( i , JMM ) ;
15318: LD_VAR 0 1
15322: PPUSH
15323: LD_EXP 18
15327: PPUSH
15328: CALL_OW 115
// end else
15332: GO 15779
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_side , 1 ] ) = 0 then
15334: LD_VAR 0 1
15338: PPUSH
15339: LD_VAR 0 4
15343: PUSH
15344: LD_INT 1
15346: ARRAY
15347: PPUSH
15348: LD_VAR 0 4
15352: PUSH
15353: LD_INT 2
15355: ARRAY
15356: PPUSH
15357: CALL_OW 297
15361: PUSH
15362: LD_VAR 0 1
15366: PPUSH
15367: LD_VAR 0 5
15371: PUSH
15372: LD_INT 1
15374: ARRAY
15375: PPUSH
15376: LD_VAR 0 5
15380: PUSH
15381: LD_INT 2
15383: ARRAY
15384: PPUSH
15385: CALL_OW 297
15389: GREATER
15390: PUSH
15391: LD_EXP 9
15395: AND
15396: PUSH
15397: LD_INT 9
15399: PPUSH
15400: LD_INT 22
15402: PUSH
15403: LD_INT 1
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PPUSH
15410: CALL_OW 70
15414: PUSH
15415: LD_INT 0
15417: EQUAL
15418: OR
15419: IFFALSE 15450
// ComAgressiveMove ( i , points2 [ 1 ] , points2 [ 2 ] ) else
15421: LD_VAR 0 1
15425: PPUSH
15426: LD_VAR 0 5
15430: PUSH
15431: LD_INT 1
15433: ARRAY
15434: PPUSH
15435: LD_VAR 0 5
15439: PUSH
15440: LD_INT 2
15442: ARRAY
15443: PPUSH
15444: CALL_OW 114
15448: GO 15779
// begin if GetWeapon ( i ) = ru_rocket_launcher then
15450: LD_VAR 0 1
15454: PPUSH
15455: CALL_OW 264
15459: PUSH
15460: LD_INT 45
15462: EQUAL
15463: IFFALSE 15644
// begin dist := 9999 ;
15465: LD_ADDR_VAR 0 8
15469: PUSH
15470: LD_INT 9999
15472: ST_TO_ADDR
// xy := 0 ;
15473: LD_ADDR_VAR 0 9
15477: PUSH
15478: LD_INT 0
15480: ST_TO_ADDR
// for x in pointsr do
15481: LD_ADDR_VAR 0 7
15485: PUSH
15486: LD_VAR 0 6
15490: PUSH
15491: FOR_IN
15492: IFFALSE 15640
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
15494: LD_VAR 0 1
15498: PPUSH
15499: LD_VAR 0 7
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PPUSH
15508: LD_VAR 0 7
15512: PUSH
15513: LD_INT 2
15515: ARRAY
15516: PPUSH
15517: CALL_OW 297
15521: PUSH
15522: LD_VAR 0 8
15526: LESS
15527: IFFALSE 15572
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
15529: LD_ADDR_VAR 0 8
15533: PUSH
15534: LD_VAR 0 1
15538: PPUSH
15539: LD_VAR 0 7
15543: PUSH
15544: LD_INT 1
15546: ARRAY
15547: PPUSH
15548: LD_VAR 0 7
15552: PUSH
15553: LD_INT 2
15555: ARRAY
15556: PPUSH
15557: CALL_OW 297
15561: ST_TO_ADDR
// xy := x ;
15562: LD_ADDR_VAR 0 9
15566: PUSH
15567: LD_VAR 0 7
15571: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
15572: LD_VAR 0 9
15576: PUSH
15577: LD_VAR 0 1
15581: PPUSH
15582: LD_VAR 0 9
15586: PUSH
15587: LD_INT 1
15589: ARRAY
15590: PPUSH
15591: LD_VAR 0 9
15595: PUSH
15596: LD_INT 2
15598: ARRAY
15599: PPUSH
15600: CALL_OW 297
15604: PUSH
15605: LD_INT 9
15607: GREATER
15608: AND
15609: IFFALSE 15638
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
15611: LD_VAR 0 1
15615: PPUSH
15616: LD_VAR 0 9
15620: PUSH
15621: LD_INT 1
15623: ARRAY
15624: PPUSH
15625: LD_VAR 0 9
15629: PUSH
15630: LD_INT 2
15632: ARRAY
15633: PPUSH
15634: CALL_OW 114
// end ;
15638: GO 15491
15640: POP
15641: POP
// end else
15642: GO 15779
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
15644: LD_ADDR_VAR 0 3
15648: PUSH
15649: LD_OWVAR 3
15653: PUSH
15654: LD_VAR 0 1
15658: DIFF
15659: PPUSH
15660: LD_VAR 0 1
15664: PPUSH
15665: CALL_OW 74
15669: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_lives , 249 ] ] ) then
15670: LD_VAR 0 3
15674: PUSH
15675: LD_INT 21
15677: PUSH
15678: LD_INT 2
15680: PUSH
15681: EMPTY
15682: LIST
15683: LIST
15684: PUSH
15685: LD_INT 58
15687: PUSH
15688: EMPTY
15689: LIST
15690: PUSH
15691: EMPTY
15692: LIST
15693: LIST
15694: PPUSH
15695: CALL_OW 69
15699: IN
15700: PUSH
15701: LD_VAR 0 3
15705: PUSH
15706: LD_INT 22
15708: PUSH
15709: LD_INT 3
15711: PUSH
15712: EMPTY
15713: LIST
15714: LIST
15715: PUSH
15716: LD_INT 24
15718: PUSH
15719: LD_INT 249
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PPUSH
15730: CALL_OW 69
15734: IN
15735: OR
15736: IFFALSE 15752
// ComAttackUnit ( i , un ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_VAR 0 3
15747: PPUSH
15748: CALL_OW 115
// ComAgressiveMove ( i , points1 [ 1 ] , points1 [ 2 ] ) ;
15752: LD_VAR 0 1
15756: PPUSH
15757: LD_VAR 0 4
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PPUSH
15766: LD_VAR 0 4
15770: PUSH
15771: LD_INT 2
15773: ARRAY
15774: PPUSH
15775: CALL_OW 114
// end ; end ; end ; end ;
15779: GO 15138
15781: POP
15782: POP
// end ;
15783: PPOPN 9
15785: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
15786: LD_INT 22
15788: PUSH
15789: LD_INT 3
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: LD_INT 32
15798: PUSH
15799: LD_INT 1
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: EMPTY
15807: LIST
15808: LIST
15809: PPUSH
15810: CALL_OW 69
15814: IFFALSE 15902
15816: GO 15818
15818: DISABLE
15819: LD_INT 0
15821: PPUSH
15822: PPUSH
// begin enable ;
15823: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
15824: LD_ADDR_VAR 0 2
15828: PUSH
15829: LD_INT 22
15831: PUSH
15832: LD_INT 3
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: PUSH
15839: LD_INT 32
15841: PUSH
15842: LD_INT 1
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: PPUSH
15853: CALL_OW 69
15857: ST_TO_ADDR
// for i in tmp do
15858: LD_ADDR_VAR 0 1
15862: PUSH
15863: LD_VAR 0 2
15867: PUSH
15868: FOR_IN
15869: IFFALSE 15900
// if GetFuel ( i ) < 12 then
15871: LD_VAR 0 1
15875: PPUSH
15876: CALL_OW 261
15880: PUSH
15881: LD_INT 12
15883: LESS
15884: IFFALSE 15898
// SetFuel ( i , 12 ) ;
15886: LD_VAR 0 1
15890: PPUSH
15891: LD_INT 12
15893: PPUSH
15894: CALL_OW 240
15898: GO 15868
15900: POP
15901: POP
// end ;
15902: PPOPN 2
15904: END
// every 0 0$1 trigger can_end do
15905: LD_EXP 17
15909: IFFALSE 15936
15911: GO 15913
15913: DISABLE
// begin Wait ( 1 1$35 ) ;
15914: LD_INT 3325
15916: PPUSH
15917: CALL_OW 67
// PrepareAttack ( 10 ) ;
15921: LD_INT 10
15923: PPUSH
15924: CALL 13901 0 1
// ru_can_attack := true ;
15928: LD_ADDR_EXP 8
15932: PUSH
15933: LD_INT 1
15935: ST_TO_ADDR
// end ;
15936: END
